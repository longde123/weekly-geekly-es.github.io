<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👃🏽 🙋 👆🏾 Kubus 1000 dimensi: apakah mungkin untuk membuat model komputasi memori manusia saat ini? 🤴🏾 🔕 🛳️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pagi ini, dalam perjalanan ke kampus Berkeley, saya menyapukan jari di sepanjang daun semak yang harum, dan kemudian menghirup aroma yang sudah dikena...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kubus 1000 dimensi: apakah mungkin untuk membuat model komputasi memori manusia saat ini?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419147/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/hm/bf/hq/hmbfhq9wergzhrrb1fskxsurpsk.png" alt="gambar"></div><br>  Pagi ini, dalam perjalanan ke kampus Berkeley, saya menyapukan jari di sepanjang daun semak yang harum, dan kemudian menghirup aroma yang sudah dikenal.  Saya melakukan ini setiap hari, dan setiap hari kata pertama yang muncul di kepala saya dan melambaikan tangannya sebagai salam.  Tetapi saya tahu bahwa tanaman ini bukan bijak, tetapi rosemary, jadi saya memesan <em>bijak untuk</em> menenangkan diri.  Tapi sudah terlambat.  Setelah <em>rosemary</em> dan <em>sage,</em> saya tidak bisa menghentikan penampilan <em>peterseli</em> dan <em>thyme</em> di atas panggung, setelah itu not pertama dari melodi dan wajah muncul di sampul album, dan sekarang saya kembali pada pertengahan 1960-an, mengenakan kemeja dengan mentimun.  Sementara itu, <em>rosemary</em> membawa celah 13 menit dalam memori Rose Mary Woods (meskipun <em>sekarang</em> , setelah berkonsultasi dengan memori kolektif, saya tahu bahwa itu seharusnya Rose Mary Woods dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ruang 18 setengah menit</a> ).  Dari Watergate, saya melompat ke cerita di halaman utama.  Lalu saya perhatikan di kebun yang terawat baik tanaman lain dengan daun hijau kelabu mengembang.  Ini juga bukan bijak, tetapi lebih bersih (telinga domba).  Namun, orang <em>bijak</em> akhirnya mendapatkan momen kemenangannya.  Dari rumput, saya beralih ke perangkat lunak matematika <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sage</a> , dan kemudian ke sistem pertahanan udara tahun 1950 yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SAGE</a> , Lingkungan Tanah Semi-Otomatis, yang dikelola oleh komputer terbesar yang pernah dibuat. <br><br>  Dalam psikologi dan sastra, pengembaraan mental seperti itu disebut <em>aliran kesadaran</em> (penulis metafora ini adalah William James).  Tetapi saya akan memilih metafora yang berbeda.  Kesadaran saya, sejauh yang saya rasakan, tidak mengalir dengan lancar dari satu topik ke topik lain, melainkan mengalir melintasi lanskap pikiran, lebih seperti kupu-kupu daripada sungai, kadang-kadang dipaku pada satu bunga dan kemudian ke bunga lain, terkadang terbawa oleh hembusan, terkadang mengunjungi tempat yang sama lagi dan lagi. <br><a name="habracut"></a><br>  Untuk menjelajahi arsitektur ingatan saya sendiri, saya mencoba melakukan eksperimen yang lebih santai dengan asosiasi bebas.  Saya mulai dengan resep bunga yang sama - peterseli, sage, rosemary dan thyme - tetapi untuk latihan ini saya tidak berjalan-jalan di taman perbukitan Berkeley;  Aku duduk di meja dan mencatat.  Diagram di bawah ini adalah upaya terbaik untuk merekonstruksi sepenuhnya pemikiran saya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nx/fp/e4/nxfpe47jmecnrrd9v1wju4k2xts.png"></div><br>  peterseli, sage, rosemary, thyme - herbal empat, serta garis dari lagu Simon dan Garfunkel. <br><br>  Simon dan Garfunkel - Paul Simon dan Seni Garfunkel, duet penyanyi dalam genre rock folk tahun 1960-an dan 70-an. <br><br>  Bu  Robinson adalah lagu oleh Simon dan Garfunkel, serta karakter dari film Mike Nichols "The Graduate". <br><br>  "Kemana kamu pergi, Joe DiMaggio?"  - pertanyaan yang diajukan dalam "Ny.  Robinson. " <br><br>  Simon dan Schuster adalah rumah penerbitan yang didirikan pada tahun 1924 oleh Richard Simon dan Max Schuster (awalnya untuk penerbitan teka-teki silang). <br><br>  Jackie Robinson adalah pemain legendaris Brooklyn Dodgers. <br><br>  Robinson Crusoe - novel Daniel Defoe tentang kapal karam (1719). <br><br>  Keluarga Swiss Robinsons - novel Johan David Weiss tentang kapal karam (1812). <br><br>  herbal - tanaman aromatik <br><br>  Tuan  Wizard adalah pertunjukan sains Sabtu 1950-an untuk anak-anak yang dipandu oleh Don Herbert. <br><br>  Alpert - trumpeter Lambang Alpert. <br><br>  Plastik adalah saran karir yang disarankan oleh The Graduate. <br><br>  coo-coo-ca-choo - baris dari “Mrs.  Robinson. " <br><br>  Frank Robinson adalah pemain luar di Baltimore Orioles pada 1970-an. <br><br>  Greig Nettles adalah pemain baseball ketiga New York Yankees di tahun 1970-an. <br><br>  Dustin Hoffman adalah aktor yang bermain di The Graduate. <br><br>  Abby Hoffman - "Yipee!" <br><br>  Leominster adalah kota di Massachusetts yang telah menjadi tempat lahirnya pabrik plastik di Amerika Serikat. <br><br>  Brooks Robinson adalah pemain baseball ketiga Baltimore Orioles di tahun 1970-an. <br><br>  Papillon ("The Moth") - sebuah film tahun 1973 di mana Dustin Hoffman memainkan peran sekunder;  "Papillon" dalam bahasa Prancis, "kupu-kupu." <br><br>  Nabokov - Vladimir Nabokov, seorang penulis kelahiran Rusia dan seorang ahli serangga yang mempelajari kupu-kupu. <br><br>  kupu-kupu, Schmetterling, mariposa, farfalla - “kupu-kupu” dalam bahasa Inggris, Jerman, Spanyol, dan Italia;  tampaknya semua dari mereka (dan kata Prancis juga) berasal dari independen. <br><br>  Apa yang disebut kupu-kupu dalam bahasa Rusia - saya tidak tahu.  Atau tidak tahu kapan pertanyaan ini muncul. <br><br>  "I am the Walrus" adalah lagu Beatles 1967 yang juga memiliki frasa "coo-coo-ca-choo". <br><br>  Carly Simon adalah seorang penyanyi.  Tidak ada hubungan dengan Paul Simon, tetapi adalah putri dari Richard Simon. <br><br>  "Kau begitu sia-sia" adalah lagu oleh Carly Simon. <br><br>  Grafik top-down mewakili topik dalam urutan yang muncul di otak, tetapi koneksi antara node tidak membuat urutan linier tunggal.  Strukturnya menyerupai pohon dengan rantai pendek dari asosiasi yang berurutan, berakhir dengan kembalinya tajam ke simpul sebelumnya, seolah-olah saya ditarik kembali oleh karet gelang yang diregangkan.  Gangguan seperti itu ditandai pada grafik dengan panah hijau;  X merah di bawah adalah tempat di mana saya memutuskan untuk menyelesaikan percobaan. <br><br>  Saya minta maaf kepada mereka yang lahir setelah tahun 1990, banyak topik yang disebutkan mungkin sudah ketinggalan zaman atau misterius bagi Anda.  Penjelasan disajikan di bawah grafik, tetapi saya tidak berpikir mereka akan membuat asosiasi lebih jelas.  Pada akhirnya, kenangan itu bersifat pribadi, mereka hidup di dalam kepala.  Jika Anda ingin mengumpulkan koleksi ide yang relevan dengan pengalaman Anda sendiri, Anda hanya perlu membuat jadwal asosiasi gratis sendiri.  Saya sangat merekomendasikan melakukan ini: Anda mungkin menemukan bahwa Anda tidak tahu bahwa Anda tahu sesuatu. <br><br><hr><br>  Tujuan dari perjalanan saya sehari-hari menuruni bukit di Berkeley adalah Simons Institute dan Kursus Teori Komputasi, di mana saya berpartisipasi dalam program selama satu semester tentang otak dan perhitungan.  Lingkungan seperti itu memunculkan pikiran pikiran.  Saya mulai merenung: bagaimana kita bisa membangun model komputasi dari proses asosiasi bebas?  Di antara berbagai tugas yang diusulkan untuk diselesaikan oleh kecerdasan buatan, yang ini terlihat cukup sederhana.  Tidak perlu untuk rasionalisasi yang mendalam;  semua yang perlu kita simulasikan hanyalah melamun dan berkeliaran di awan - inilah yang dilakukan otak saat tidak dimuat.  Sepertinya tugas seperti itu mudah diselesaikan, bukan? <br><br>  Gagasan pertama yang muncul di kepala saya (setidaknya di kepala <em>saya</em> ) mengenai arsitektur model komputasi seperti itu adalah gerakan acak di sepanjang grafik atau jaringan matematika.  Node jaringan adalah elemen yang disimpan dalam memori - ide, fakta, peristiwa - dan komunikasi adalah berbagai jenis asosiasi di antara mereka.  Misalnya, simpul <em>kupu</em> - <em>kupu</em> dapat dihubungkan dengan <em>ngengat, ulat bulu, raja</em> dan <em>ibu dari mutiara,</em> serta dengan transisi yang disebutkan dalam jadwal saya, dan mungkin memiliki koneksi yang kurang jelas, misalnya <em>, penjelajahan Australia "," Udang "," Mohammed Ali "," pellagra "," tersedak "</em> dan <em>" ketakutan panggung "</em> .  Struktur data host akan berisi daftar pointer ke semua host terkait ini.  Pointer dapat diberi nomor dari 1 hingga n;  program akan menghasilkan nomor pseudo-acak dalam interval ini dan pergi ke node yang sesuai, di mana seluruh prosedur akan mulai lagi. <br><br>  Algoritma ini mencerminkan beberapa karakteristik dasar dari asosiasi bebas, tetapi banyak dari mereka tidak diperhitungkan.  Model ini mengasumsikan bahwa semua node target sama-sama memungkinkan, yang terlihat tidak masuk akal.  Untuk memperhitungkan perbedaan dalam probabilitas, kita dapat menanyakan setiap sisi <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saya</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="0.802ex" height="1.937ex" viewBox="0 -728.2 345.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhigUedKAxpxXbUMWzXbI0Ju5V34Dg#MJMATHI-69" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> i </script>  berat badan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-3"><span class="MJXp-msubsup" id="MJXp-Span-4"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-5" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w </font></font></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-6" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.464ex" height="1.817ex" viewBox="0 -520.7 1060.8 782.1" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhigUedKAxpxXbUMWzXbI0Ju5V34Dg#MJMATHI-77" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhigUedKAxpxXbUMWzXbI0Ju5V34Dg#MJMATHI-69" x="1013" y="-213"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> w_i </script>  , dan kemudian membuat probabilitas sebanding dengan bobot. <br><br>  Yang lebih rumit lagi adalah kenyataan bahwa bobot bergantung pada konteks - pada sejarah baru-baru ini dari aktivitas mental manusia.  Jika saya tidak memiliki kombinasi Ny.  Robinson dan Jackie Robinson, akankah saya memikirkan Joe Di Maggio?  Dan sekarang, ketika saya menulis ini, Joltin 'Joe (nama panggilan Di Maggio) mengingatkan Marilyn Monroe dan kemudian Arthur Miller, dan sekali lagi saya tidak bisa menghentikan aliran pemikiran.  Untuk mereproduksi efek ini dalam model komputer, beberapa mekanisme regulasi dinamis probabilitas seluruh kategori node tergantung pada node lain yang telah dikunjungi baru-baru ini akan diperlukan. <br><br>  Anda juga harus mempertimbangkan efek kebaruan dari jenis yang berbeda.  Sebuah gelang karet harus ditemukan dalam model, terus-menerus menarik saya kembali ke Simon dan Garfunkel dan Mrs.  Robinson  Mungkin, setiap situs yang baru-baru ini dikunjungi harus ditambahkan ke daftar opsi target, bahkan jika tidak terhubung dengan cara apa pun dengan situs saat ini.  Di sisi lain, kecanduan juga kemungkinan: pikiran yang terlalu sering diingat menjadi membosankan, oleh karena itu mereka harus ditekan dalam model. <br><br>  Tes terakhir lainnya: beberapa ingatan bukanlah fakta atau ide yang terisolasi, tetapi bagian dari cerita.  Mereka memiliki struktur naratif dengan peristiwa yang berlangsung dalam urutan kronologis.  Untuk node dari ingatan episodik seperti itu, tepi <em>berikutnya</em> , dan mungkin <em>sebelumnya</em> , diperlukan.  Rantai tulang rusuk seperti itu menyatukan seluruh hidup kita, termasuk semua yang Anda ingat. <br><br><hr><br>  Bisakah model komputasi yang sama mereproduksi pengembaraan mental saya?  Mengumpulkan data untuk model seperti itu akan menjadi proses yang agak panjang, dan ini tidak mengejutkan, karena butuh waktu seumur hidup untuk mengisi tengkorak saya dengan jalinan tanaman obat, Coats of Arms, Simons, Robinsons, dan Hoffmanns.  Jauh lebih banyak daripada jumlah data, saya peduli dengan keseriusan algoritma grafik traversal.  Sangat mudah untuk mengatakan: "pilih simpul sesuai dengan probabilitas tertimbang," tetapi ketika saya melihat rincian kotor dari pelaksanaan tindakan ini, saya hampir tidak dapat membayangkan bahwa sesuatu seperti ini terjadi di otak. <br><br>  Berikut adalah algoritma paling sederhana yang saya tahu untuk pemilihan tertimbang acak.  (Ini bukan yang paling efisien dari algoritma ini, tetapi metodenya bahkan lebih kacau. Keith Schwartz menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tutorial dan ulasan yang</a> sangat baik tentang topik ini.) Misalkan struktur data yang mensimulasikan node jaringan mencakup daftar tautan ke node lain dan daftar bobot yang sesuai. .  Seperti yang ditunjukkan pada gambar di bawah ini, program menghasilkan sejumlah jumlah akumulasi bobot: <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-7"><span class="MJXp-mn" id="MJXp-Span-8"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 </font></font></span><span class="MJXp-mo" id="MJXp-Span-9" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font></span><span class="MJXp-msubsup" id="MJXp-Span-10"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w </font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-12" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span><span class="MJXp-mo" id="MJXp-Span-13" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font></span><span class="MJXp-msubsup" id="MJXp-Span-14"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-15" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w </font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-16" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span><span class="MJXp-mo" id="MJXp-Span-17" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font></span><span class="MJXp-msubsup" id="MJXp-Span-18"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-19" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w </font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-20" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></span></span><span class="MJXp-mo" id="MJXp-Span-21" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font></span><span class="MJXp-msubsup" id="MJXp-Span-22"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w </font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-24" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span><span class="MJXp-mo" id="MJXp-Span-25" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font></span><span class="MJXp-msubsup" id="MJXp-Span-26"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-27" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w </font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-28" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></span></span><span class="MJXp-mo" id="MJXp-Span-29" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font></span><span class="MJXp-msubsup" id="MJXp-Span-30"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w </font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-32" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></span></span><span class="MJXp-mo" id="MJXp-Span-33" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font></span><font style="vertical-align: inherit;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-35"><font style="vertical-align: inherit;">d </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-36"><font style="vertical-align: inherit;">o </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-37"><font style="vertical-align: inherit;">t </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-38"><font style="vertical-align: inherit;">s</font></span></font><span class="MJXp-mtext" id="MJXp-Span-34">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-35"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-36"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-37"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-38"><font style="vertical-align: inherit;"></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="34.984ex" height="2.419ex" viewBox="0 -780.1 15062.4 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhigUedKAxpxXbUMWzXbI0Ju5V34Dg#MJMAIN-30" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhigUedKAxpxXbUMWzXbI0Ju5V34Dg#MJMAIN-2C" x="500" y="0"></use><g transform="translate(945,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhigUedKAxpxXbUMWzXbI0Ju5V34Dg#MJMATHI-77" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhigUedKAxpxXbUMWzXbI0Ju5V34Dg#MJMAIN-31" x="1013" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhigUedKAxpxXbUMWzXbI0Ju5V34Dg#MJMAIN-2C" x="2116" y="0"></use><g transform="translate(2561,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhigUedKAxpxXbUMWzXbI0Ju5V34Dg#MJMATHI-77" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhigUedKAxpxXbUMWzXbI0Ju5V34Dg#MJMAIN-31" x="1013" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhigUedKAxpxXbUMWzXbI0Ju5V34Dg#MJMAIN-2B" x="3953" y="0"></use><g transform="translate(4954,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhigUedKAxpxXbUMWzXbI0Ju5V34Dg#MJMATHI-77" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhigUedKAxpxXbUMWzXbI0Ju5V34Dg#MJMAIN-32" x="1013" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhigUedKAxpxXbUMWzXbI0Ju5V34Dg#MJMAIN-2C" x="6124" y="0"></use><g transform="translate(6570,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhigUedKAxpxXbUMWzXbI0Ju5V34Dg#MJMATHI-77" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhigUedKAxpxXbUMWzXbI0Ju5V34Dg#MJMAIN-31" x="1013" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhigUedKAxpxXbUMWzXbI0Ju5V34Dg#MJMAIN-2B" x="7962" y="0"></use><g transform="translate(8963,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhigUedKAxpxXbUMWzXbI0Ju5V34Dg#MJMATHI-77" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhigUedKAxpxXbUMWzXbI0Ju5V34Dg#MJMAIN-32" x="1013" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhigUedKAxpxXbUMWzXbI0Ju5V34Dg#MJMAIN-2B" x="10356" y="0"></use><g transform="translate(11356,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhigUedKAxpxXbUMWzXbI0Ju5V34Dg#MJMATHI-77" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhigUedKAxpxXbUMWzXbI0Ju5V34Dg#MJMAIN-33" x="1013" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhigUedKAxpxXbUMWzXbI0Ju5V34Dg#MJMAIN-2C" x="12527" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhigUedKAxpxXbUMWzXbI0Ju5V34Dg#MJMATHI-64" x="13222" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhigUedKAxpxXbUMWzXbI0Ju5V34Dg#MJMATHI-6F" x="13745" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhigUedKAxpxXbUMWzXbI0Ju5V34Dg#MJMATHI-74" x="14231" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhigUedKAxpxXbUMWzXbI0Ju5V34Dg#MJMATHI-73" x="14592" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> 0, w_1, w_1 + w_2, w_1 + w_2 + w_3, \ dots </script>  .  Langkah selanjutnya adalah menormalkan seri ini dengan membagi setiap angka dengan jumlah total bobot.  Sekarang kami memiliki serangkaian angka <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-39"><span class="MJXp-msubsup" id="MJXp-Span-40"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-41" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p </font></font></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-42" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.059ex" height="1.817ex" viewBox="-38.5 -520.7 886.3 782.1" role="img" focusable="false" style="vertical-align: -0.607ex; margin-left: -0.089ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhigUedKAxpxXbUMWzXbI0Ju5V34Dg#MJMATHI-70" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/419147/&amp;usg=ALkJrhigUedKAxpxXbUMWzXbI0Ju5V34Dg#MJMATHI-69" x="712" y="-213"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4"> p_i </script>  meningkat secara monoton dari nol menjadi satu.  Selanjutnya, program memilih bilangan real acak <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-43"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-44"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-5"> x </script>  dari interval <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-45"><span class="MJXp-mo" id="MJXp-Span-46" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[ </font></font></span><span class="MJXp-mn" id="MJXp-Span-47"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 </font></font></span><span class="MJXp-mo" id="MJXp-Span-48" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font></span><span class="MJXp-mn" id="MJXp-Span-49"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-50" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-6"> [0, 1) </script>  ; <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-51"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-52"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-7"> x </script>  harus dalam salah satu interval yang dinormalisasi <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-53"><span class="MJXp-msubsup" id="MJXp-Span-54"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-55" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p </font></font></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-56" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-8"> p_i </script>  , dan nilai ini <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-57"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-58"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saya</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9"> i </script>  mendefinisikan node yang dapat dipilih berikutnya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fq/tb/lp/fqtblpodseuus5fug9ael204d7y.png"></div><br>  Dalam kode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bahasa pemrograman Julia,</a> prosedur pemilihan simpul terlihat seperti ini: <br><br><pre><code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">select_next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(links, weights)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">total</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(weights)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cum_weights</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cumsum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(weights)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">probabilities</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cum_weights</span></span></span><span class="hljs-function"> / </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">total</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">1</span></span></span><span class="hljs-function">:</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(probabilities)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">probabilities</span></span></span><span class="hljs-function">[</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-function">] &gt;= </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre> <br>  Saya menggambarkan detail-detail yang membosankan ini dari jumlah akumulasi dan angka pseudo-acak yang begitu lambat untuk menekankan dengan cara ini sehingga algoritma traversal grafik ini tidak sesederhana seperti yang terlihat pada pandangan pertama.  Dan kami masih belum mempertimbangkan topik perubahan probabilitas dengan cepat, meskipun perhatian kami beralih dari topik ke topik. <br><br>  Bahkan lebih sulit untuk memahami proses pembelajaran - menambahkan node dan tepi baru ke jaringan.  Saya mengakhiri sesi asosiasi bebas ketika saya sampai pada pertanyaan yang tidak bisa saya jawab: apa nama kupu-kupu di Rusia?  Tapi <em>sekarang</em> aku bisa menjawabnya.  Lain kali saya memainkan game ini, saya akan menambahkan kata <em>babochka</em> ke daftar.  Dalam model komputasi, memasukkan simpul untuk kata <em>babochka</em> adalah tugas yang cukup sederhana, tetapi simpul baru kami juga harus terhubung ke semua simpul kupu-kupu yang ada.  Apalagi <em>babochka</em> sendiri menambahkan iga baru.  Secara fonetis ia dekat dengan <em>babushka</em> (nenek) - salah satu dari beberapa kata Rusia dalam kamus saya.  Akhiran <em>-ochka adalah</em> kecil, sehingga harus dikaitkan dengan <em>-ette</em> Perancis dan <em>-ini</em> Italia.  Arti harfiah dari kata <em>babochka</em> adalah "jiwa kecil", yang menyiratkan jumlah asosiasi yang lebih besar.  Bagaimanapun, mempelajari satu kata baru mungkin memerlukan pengindeksan ulang seluruh pohon pengetahuan. <br><br><hr><br>  Mari kita coba metode lain.  Lupakan tentang melintasi jaringan secara acak dengan spageti dari pointer ke node.  Sebagai gantinya, mari kita simpan semua barang serupa di lingkungan.  Dari sudut pandang bank memori komputer digital, ini berarti bahwa hal-hal serupa akan disimpan di alamat tetangga.  Berikut adalah segmen memori hipotetis yang berpusat pada konsep <em>anjing</em> .  Tempat-tempat tetangga ditempati dengan kata lain, konsep dan kategori yang paling mungkin disebabkan oleh pemikiran anjing ( <em>anjing</em> ): <em>kucing yang</em> jelas (kucing) dan <em>anak anjing</em> (anak anjing), berbagai jenis anjing dan beberapa anjing tertentu (Skippy adalah anjing keluarga kami, yang di masa kecil saya), serta, mungkin, asosiasi yang lebih kompleks.  Setiap item memiliki alamat digital.  Alamat tidak memiliki makna yang dalam, tetapi penting agar semua sel memori diberi nomor secara berurutan. <br><br><table><tbody><tr><th>  alamatnya </th><th>  isinya </th></tr><tr><td>  19216805 </td><td>  tuhan </td></tr><tr><td>  19216806 </td><td>  anjing yang tidak menggonggong di malam hari </td></tr><tr><td>  19216807 </td><td>  Skippy </td></tr><tr><td>  19216808 </td><td>  Lassie </td></tr><tr><td>  19216809 </td><td>  anjing </td></tr><tr><td>  19216810 </td><td>  kucing </td></tr><tr><td>  19216811 </td><td>  anjing </td></tr><tr><td>  19216812 </td><td>  anak anjing </td></tr><tr><td>  19216813 </td><td>  serigala </td></tr><tr><td>  19216814 </td><td>  gua canem </td></tr><tr><td>  19216815 </td><td>  Basset hound </td></tr><tr><td>  19216816 </td><td>  Weimaraner </td></tr><tr><td>  19216817 </td><td>  dogmatis </td></tr></tbody></table><br>  Tugas santai berkeliaran di array ini dalam memori bisa sangat sederhana.  Ini dapat melintasi alamat memori secara acak, tetapi keuntungannya akan diberikan pada langkah-langkah kecil.  Misalnya, alamat yang dikunjungi berikutnya dapat ditentukan dengan pengambilan sampel dari distribusi normal yang berpusat pada lokasi saat ini.  Ini kode untuk Julia.  (Fungsi <code>randn()</code> mengembalikan bilangan real acak yang diperoleh dari distribusi normal dengan nilai rata-rata <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-59"><span class="MJXp-mtext" id="MJXp-Span-60">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-61"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-62"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u </font></font></span><span class="MJXp-mo" id="MJXp-Span-63" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-64"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-10"> \ mu = 0 </script>  dan standar deviasi <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-65"><span class="MJXp-mtext" id="MJXp-Span-66">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-67"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-68"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-69"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-70"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-71"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font></span><span class="MJXp-mo" id="MJXp-Span-72" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-73"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-11"> \ sigma = 1 </script>  .) <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gaussian_ramble</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr, sigma)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sigma</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addr</span></span></span><span class="hljs-function"> + </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">round</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Int, r)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre> <br>  Skema semacam itu memiliki fitur menarik.  Tidak perlu melakukan tabulasi semua node target yang mungkin sebelum memilih salah satunya.  Probabilitas tidak disimpan sebagai angka, tetapi dikodekan oleh posisi dalam array, dan juga dimodulasi oleh parameter <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-74"><span class="MJXp-mtext" id="MJXp-Span-75">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-76"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-77"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-78"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-79"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-80"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-12"> \ sigma </script>  , yang menentukan seberapa jauh prosedur ingin bergerak dalam array.  Meskipun program masih melakukan aritmatika untuk sampel dari distribusi normal, fungsi seperti itu kemungkinan menjadi solusi yang lebih sederhana. <br><br>  Namun tetap saja, prosedur ini memiliki kelemahan yang menakutkan.  Setelah dikelilingi <em>anjing dengan</em> semua asosiasi langsungnya, kami tidak meninggalkan ruang untuk asosiasi <em>mereka</em> .  Istilah anjing baik dalam konteksnya sendiri, tetapi bagaimana dengan <em>kucing</em> dari daftar?  Di mana kita meletakkan <em>anak kucing</em> , <em>harimau</em> , <em>sembilan nyawa</em> dan <em>Felix</em> ?  Dalam array satu dimensi, tidak ada cara untuk menyematkan setiap elemen memori dalam lingkungan yang sesuai. <br><br>  Jadi mari kita beralih ke dua dimensi!  Membagi alamat menjadi dua komponen, kami mendefinisikan dua sumbu ortogonal.  Paruh pertama dari setiap alamat menjadi koordinat <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-81"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-82"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13"> y </script>  dan koordinat kedua <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-83"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-84"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-14"> x </script>  .  Sekarang <em>anjing</em> dan <em>kucing</em> masih tetangga dekat, tetapi mereka juga memiliki ruang pribadi di mana mereka dapat bermain dengan "teman" mereka sendiri. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/if/kn/ef/ifknefmf6isjnhavuzpqj-q0epi.png"></div><br>  Namun, dua pengukuran juga tidak cukup.  Jika kita mencoba mengisi semua elemen yang terkait dengan <em>Kucing di Topi</em> , mereka pasti akan mulai bertabrakan dan bertentangan dengan elemen-elemen terkait dari <em>anjing yang tidak menggonggong di malam hari</em> .  Jelas, kami membutuhkan lebih banyak dimensi - lebih banyak. <br><br><hr><br>  Sekarang adalah saat yang tepat untuk mengakui - Saya bukan orang pertama yang berpikir tentang bagaimana ingatan dapat diatur dalam ingatan.  Daftar para pendahulu saya dapat dimulai dengan Plato, yang membandingkan ingatan dengan seekor burung;  kita mengenali ingatan dengan bulu mereka, tetapi kadang-kadang sulit bagi kita untuk mendapatkannya jika mereka mulai berdebar di sel tengkorak kita.  Jesuit abad ke-16, Matteo Ricci, menulis tentang "istana kenangan" di mana kita menjelajahi berbagai ruangan dan koridor untuk mencari harta karun masa lalu.  Teori ingatan modern biasanya kurang imajinatif, tetapi lebih detail dan ditujukan pada transisi dari metafora ke mekanisme.  Secara pribadi, yang paling saya sukai adalah model matematika yang diperoleh pada 1980-an oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pentti Canerva</a> , yang sekarang bekerja di Redwood Center for Theoretical Neuroscience di Berkeley.  Dia datang dengan gagasan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memori terdistribusi jarang</a> , yang saya sebut SDM.  Ini berhasil menerapkan geometri luar biasa dari ruang dimensi tinggi. <br><br>  Bayangkan sebuah kubus dalam tiga dimensi.  Jika kita mengasumsikan bahwa panjang sisi sama dengan satuan pengukuran, maka delapan vektor dapat dilambangkan dengan vektor tiga digit biner, dimulai dengan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-85"><span class="MJXp-mn" id="MJXp-Span-86"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-15"> 000 </script>  dan berakhir <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-87"><span class="MJXp-mn" id="MJXp-Span-88"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">111</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-16"> 111 </script>  .  Pada titik mana pun, mengubah satu bit vektor membawa kita ke titik yang merupakan tetangga terdekat.  Mengubah dua bit menggerakkan kita ke tetangga terdekat berikutnya, dan mengganti ketiga bit mengarah ke sudut kubus yang berlawanan - ke titik paling jauh. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ji/w0/zm/jiw0zmihd76v1dliq5ocpkmr7a0.png"></div><br>  Kubus empat dimensi bekerja dengan cara yang sama - <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-89"><span class="MJXp-mn" id="MJXp-Span-90"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-17"> 16 </script>  simpul ditunjukkan oleh vektor yang berisi semua kombinasi digit biner, dimulai <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-91"><span class="MJXp-mn" id="MJXp-Span-92"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-18"> 0000 </script>  dan berakhir <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-93"><span class="MJXp-mn" id="MJXp-Span-94"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1111</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-19"> 1111 </script>  .  Deskripsi ini sebenarnya digeneralisasikan ke <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-95"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-96"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-20-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-20"> N </script>  dimensi di mana setiap titik memiliki <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-97"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-98"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-21-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-21"> N </script>  bit koordinat vektor.  Jika kita mengukur jarak menurut metrik Manhattan - selalu bergerak di sepanjang tepi kubus dan tidak pernah memotong sepanjang diagonal - maka jarak antara dua vektor akan menjadi jumlah posisi di mana dua vektor koordinat berbeda (juga dikenal sebagai jarak Hamming).  (Untuk OR eksklusif, simbol , kadang-kadang disebut <em>sanggul</em> , biasanya digunakan. Ini menampilkan operasi XOR sebagai modulo penambahan biner 2. Kanerva lebih suka ers atau ⊗ dengan dasar bahwa peran XOR dalam komputasi dimensi tinggi lebih seperti penggandaan daripada penambahan Saya memutuskan untuk menghilangkan kontradiksi ini dengan menggunakan simbol &amp; veebar; - cara alternatif untuk menulis XOR, akrab di antara para ahli logika. Ini adalah modifikasi dari simbol ∨ - termasuk OR. Sangat mudah bahwa ini juga merupakan simbol XOR dalam program Julia.) Dengan demikian, unit  pengukuran jarak adalah satu bit, dan perhitungan jarak adalah tugas untuk operator ATAU eksklusif biner (XOR, &amp; veebar;), yang memberi kita nilai untuk bit yang berbeda <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-99"><span class="MJXp-mn" id="MJXp-Span-100"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-22-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-22"> 1 </script>  , dan untuk pasangan identik - nilainya <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-101"><span class="MJXp-mn" id="MJXp-Span-102"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-23-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-23"> 0 </script>  : <br><br><pre> <code class="hljs 1c"><span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-meta"><span class="hljs-meta">&amp;veebar; 0 = 0 0 &amp;veebar; 1 = 1 1 &amp;veebar; 0 = 1 1 &amp;veebar; 1 = 0</span></span></code> </pre> <br>  Fungsi pada Julia untuk mengukur jarak antara simpul menerapkan fungsi XOR ke dua vektor koordinat dan mengembalikan kuantitas sebagai hasilnya <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-103"><span class="MJXp-mn" id="MJXp-Span-104"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-24-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-24"> 1 </script>  . <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u, v)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">w</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">u</span></span></span><span class="hljs-function"> &amp;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">veebar</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">v</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count_ones</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre> <br>  Kapan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-105"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-106"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-25-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-25"> N </script>  semakin besar, beberapa sifat aneh muncul <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-107"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-108"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-26-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-26"> N </script>  -cube.  Pertimbangkan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-109"><span class="MJXp-mn" id="MJXp-Span-110"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-27-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-27"> 1000 </script>  kubus -dimensi memiliki <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-111"><span class="MJXp-msubsup" id="MJXp-Span-112"><span class="MJXp-mn" id="MJXp-Span-113" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-114" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-115"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-28-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-28"> 2 ^ {1000} </script>  puncak.  Jika kita secara acak memilih dua simpulnya, berapa jarak yang diharapkan di antara mereka?  Meskipun ini adalah pertanyaan tentang jarak, tetapi kita dapat menjawabnya tanpa mempelajari geometri - ini hanya tugas menghitung posisi di mana dua vektor biner dibedakan.  Untuk vektor acak, masing-masing bit mungkin sama-sama cenderung sama <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-116"><span class="MJXp-mn" id="MJXp-Span-117"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-29-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-29"> 0 </script>  atau <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-118"><span class="MJXp-mn" id="MJXp-Span-119"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-30-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-30"> 1 </script>  , oleh karena itu, diharapkan bahwa vektor akan berbeda di setengah posisi bit.  Dalam hal <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-120"><span class="MJXp-mn" id="MJXp-Span-121"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-31-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-31"> 1000 </script>  bit standar jarak vektor <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-122"><span class="MJXp-mn" id="MJXp-Span-123"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">500</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-32-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-32"> 500 </script>  bit.  Hasil ini tidak mengejutkan kami.  Namun, <em>perlu</em> dicatat bahwa semua jarak antara vektor terakumulasi erat di sekitar nilai rata-rata 500. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d7/yv/cd/d7yvcdznrtlsgollbjvqf113jak.png"></div><br>  Dalam hal <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-124"><span class="MJXp-mn" id="MJXp-Span-125"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-33-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-33"> 1000 </script>  -bit vektor hampir semua pasangan yang dipilih secara acak berada pada jarak dari <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-126"><span class="MJXp-mn" id="MJXp-Span-127"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">450</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-34-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-34"> 450 </script>  sebelumnya <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-128"><span class="MJXp-mn" id="MJXp-Span-129"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">550</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-35-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-35"> 550 </script>  sedikit.  Dalam sampel seratus juta pasangan acak <em>(lihat grafik di atas),</em> tidak ada satupun yang lebih dekat dari itu <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-130"><span class="MJXp-mn" id="MJXp-Span-131"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">400</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-36-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-36"> 400 </script>  sedikit atau lebih jauh dari <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-132"><span class="MJXp-mn" id="MJXp-Span-133"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">600</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-37-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-37"> 600 </script>  sedikit.  Tidak ada dalam hidup kita di ruang resolusi rendah yang mempersiapkan kita untuk akumulasi probabilitas dalam jarak rata-rata.  Di Bumi ini, kita dapat menemukan tempat di mana kita akan benar-benar sendirian, ketika hampir semua berada dalam jarak beberapa ribu kilometer dari kita;  namun, tidak ada cara untuk mendistribusikan kembali populasi planet ini sehingga <em>setiap orang</em> pada saat yang sama berada dalam keadaan seperti itu.  Tapi di <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-134"><span class="MJXp-mn" id="MJXp-Span-135"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-38-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-38"> 1000 </script>  ruang -dimensi situasinya hanya itu. <br><br>  Tak perlu dikatakan, sulit dibayangkan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-136"><span class="MJXp-mn" id="MJXp-Span-137"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-39-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-39"> 1000 </script>  kubus -dimensi, tetapi kita bisa mendapatkan sedikit pemahaman intuitif tentang geometri, setidaknya untuk contoh lima dimensi.  Di bawah ini adalah tabel dari semua koordinat simpul dalam kubus lima dimensi dimensi unit, disusun sesuai dengan jarak Hamming dari titik awal <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-138"><span class="MJXp-mn" id="MJXp-Span-139"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">00 </font></font></span><span class="MJXp-mo" id="MJXp-Span-140" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font></span><span class="MJXp-mn" id="MJXp-Span-141"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-40-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-40"> 00,000 </script>  .  Sebagian besar puncak (20 dari 32) berada pada jarak sedang - dua atau tiga bit.  Tabel akan memiliki bentuk yang sama pada titik lain yang diambil sebagai titik awal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bc/hj/yd/bchjydq4whfiksudz4grybvi7uy.png"></div><br>  Keberatan serius untuk semua diskusi ini. <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-142"><span class="MJXp-mn" id="MJXp-Span-143"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-41-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-41"> 1000 </script>  -Dimensi kubus adalah kita tidak akan pernah bisa membangun sesuatu seperti itu;  di alam semesta tidak ada atom yang cukup untuk struktur <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-144"><span class="MJXp-msubsup" id="MJXp-Span-145"><span class="MJXp-mn" id="MJXp-Span-146" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-147" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-148"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-42-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-42"> 2 ^ {1000} </script>  bagian.  Tetapi Kanerva menunjukkan bahwa kita membutuhkan ruang untuk menyimpan hanya elemen-elemen yang ingin kita simpan.  Kami dapat merancang peralatan untuk pengambilan sampel acak, misalnya <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-149"><span class="MJXp-msubsup" id="MJXp-Span-150"><span class="MJXp-mn" id="MJXp-Span-151" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 </font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-152" style="vertical-align: 0.5em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-43-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-43"> 10 ^ 8 </script>  simpul (masing-masing memiliki <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-153"><span class="MJXp-mn" id="MJXp-Span-154"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-44-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-44"> 1000 </script>  -bit address) dan tinggalkan sisa kubus dengan infrastruktur hantu yang belum selesai.  Kanerva menyebut subset dari simpul yang ada di <em>sel keras</em> "perangkat keras" <em>(lokasi keras)</em> .  Banyak <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-155"><span class="MJXp-msubsup" id="MJXp-Span-156"><span class="MJXp-mn" id="MJXp-Span-157" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 </font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-158" style="vertical-align: 0.5em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-45-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-45"> 10 ^ 8 </script>  sel padat acak masih akan menunjukkan distribusi jarak terkompresi yang sama dengan kubus penuh;  ini persis seperti yang ditunjukkan pada grafik di atas. <br><br>  Isolasi relatif dari masing-masing simpul dalam sebuah kubus berukuran tinggi memberi kita petunjuk tentang satu kemungkinan keuntungan dari memori terdistribusi jarang: elemen yang disimpan memiliki ruang yang cukup dan dapat didistribusikan di area yang luas tanpa mengganggu tetangganya.  Ini benar-benar fitur luar biasa dari SDM, tetapi ada hal lain. <br><br><hr><br>  Dalam memori komputer tradisional, alamat dan elemen data yang disimpan dipetakan satu ke satu.  Alamat adalah bilangan bulat ordinal dari rentang tetap, katakanlah <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-159"><span class="MJXp-mo" id="MJXp-Span-160" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[ </font></font></span><span class="MJXp-mn" id="MJXp-Span-161"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 </font></font></span><span class="MJXp-mo" id="MJXp-Span-162" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font></span><span class="MJXp-msubsup" id="MJXp-Span-163"><span class="MJXp-mn" id="MJXp-Span-164" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-165" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-166"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64</font></font></span></span></span><span class="MJXp-mo" id="MJXp-Span-167" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-46-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-46"> [0, 2 ^ {64}) </script>  .  Setiap bilangan bulat dalam kisaran ini menentukan satu tempat terpisah dalam memori, dan setiap tempat dikaitkan dengan tepat satu alamat.  Selain itu, di setiap tempat hanya satu nilai yang disimpan sekaligus;  saat menulis nilai baru, yang lama ditimpa. <br><br>  SDM melanggar semua aturan ini.  Ini memiliki ruang alamat yang sangat besar - tidak kurang <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-168"><span class="MJXp-msubsup" id="MJXp-Span-169"><span class="MJXp-mn" id="MJXp-Span-170" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-171" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-172"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-47-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-47"> 2 ^ {1000} </script>  - tetapi hanya sebagian kecil, acak tempat-tempat ini ada sebagai entitas fisik;  itu sebabnya memori disebut <em>jarang</em> .  Sepotong informasi tidak disimpan hanya di satu tempat di memori;  banyak salinan didistribusikan di seluruh wilayah - oleh karena itu <em>didistribusikan</em> .  Selain itu, di setiap alamat yang terpisah beberapa elemen data dapat disimpan pada saat yang sama.  Artinya, informasi tersebar di wilayah yang luas, dan diperas menjadi satu titik.  Arsitektur ini juga mengaburkan perbedaan antara alamat memori dan isi memori;  dalam banyak kasus, pola bit yang disimpan digunakan sebagai alamatnya sendiri.  Akhirnya, memori dapat merespons ke alamat sebagian atau perkiraan dan sangat mungkin untuk menemukan item yang benar.  Sementara memori tradisional adalah "mekanisme pencocokan tepat," SDM adalah "mekanisme kecocokan terbaik" yang mengembalikan elemen yang paling mirip dengan yang diminta. <br><br>  Dalam bukunya tahun 1988, Kanerva memberikan analisis kuantitatif terperinci dengan ingatan yang jarang didistribusikan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-173"><span class="MJXp-mn" id="MJXp-Span-174"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-48-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-48"> 1000 </script>  pengukuran dan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-175"><span class="MJXp-mn" id="MJXp-Span-176"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.000.000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-49-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-49"> 1.000.000 </script>  sel padat.  Sel padat dipilih secara acak dari seluruh ruang. <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-177"><span class="MJXp-msubsup" id="MJXp-Span-178"><span class="MJXp-mn" id="MJXp-Span-179" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-180" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-181"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-50-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-50"> 2 ^ {1000} </script>  kemungkinan vektor alamat.  Setiap sel padat memiliki ruang penyimpanan untuk banyak <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-182"><span class="MJXp-mn" id="MJXp-Span-183"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-51-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-51"> 1000 </script>  vektor bit.  Memori secara keseluruhan dirancang untuk penyimpanan setidaknya <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-184"><span class="MJXp-mn" id="MJXp-Span-185"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10.000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-52-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-52"> 10.000 </script>  pola yang unik.  Di bawah ini saya akan menganggap memori ini sebagai model-SDM kanonik, terlepas dari kenyataan bahwa menurut standar mamalia itu tidak cukup, dan dalam karya yang lebih baru, Kanerva menekankan vektor dengan setidaknya <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-186"><span class="MJXp-mn" id="MJXp-Span-187"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10.000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-53-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-53"> 10.000 </script>  pengukuran. <br><br>  Ini adalah cara kerja memori dalam implementasi komputer sederhana.  Perintah <code>store(X)</code> menulis vektor ke memori <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-188"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-189"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-54-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-54"> X </script>  , mengingat itu alamat dan konten.  Nilai <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-190"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-191"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-55-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-55"> X </script>  disimpan di semua sel padat dalam jarak tertentu ke <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-192"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-193"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-56-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-56"> X </script>  .  Dalam model kanonik, jarak ini adalah 451 bit.  Ini mendefinisikan "lingkaran akses" yang dimaksudkan untuk menyatukan dalam dirinya sendiri sekitar <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-194"><span class="MJXp-mn" id="MJXp-Span-195"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-57-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-57"> 1000 </script>  sel padat;  dengan kata lain, masing-masing vektor disimpan kira-kira dalam <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-196"><span class="MJXp-mn" id="MJXp-Span-197"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mrow" id="MJXp-Span-198"><span class="MJXp-mo" id="MJXp-Span-199" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mn" id="MJXp-Span-200"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-58-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-58"> 1/1000 </script>  satu dari sejuta sel padat. <br><br>  Penting juga untuk dicatat bahwa barang yang disimpan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-201"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-202"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-59-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-59"> X </script>  belum tentu memilih <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-203"><span class="MJXp-mn" id="MJXp-Span-204"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.000.000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-60-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-60"> 1.000.000 </script>  vektor biner yang merupakan alamat sel padat.  Sebaliknya. <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-205"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-206"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-61-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-61"> X </script>  mungkin salah satu dari <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-207"><span class="MJXp-msubsup" id="MJXp-Span-208"><span class="MJXp-mn" id="MJXp-Span-209" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-210" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-211"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-62-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-62"> 2 ^ {1000} </script>  kemungkinan pola biner. <br><br>  Misalkan seribu salinan sudah ditulis ke SDM <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-212"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-213"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-63-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-63"> X </script>  , setelah itu elemen baru tiba <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-214"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-215"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-64-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-64"> Y </script>  , yang juga perlu disimpan dalam set sendiri ribuan sel padat.  Antara dua set ini mungkin ada persimpangan - tempat di mana <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-216"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-217"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-65-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-65"> X </script>  , dan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-218"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-219"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-66-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-66"> Y </script>  .  Nilai baru tidak menimpa atau mengganti yang sebelumnya;  kedua nilai disimpan.  Ketika memori penuh dengan kapasitasnya di <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-220"><span class="MJXp-mn" id="MJXp-Span-221"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10.000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-67-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-67"> 10.000 </script>  masing-masing disimpan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-222"><span class="MJXp-mn" id="MJXp-Span-223"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-68-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-68"> 1000 </script>  kali, dan dalam salinan sel keras khas akan disimpan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-224"><span class="MJXp-mn" id="MJXp-Span-225"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-69-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-69"> 10 </script>  pola yang unik. <br><br>  Sekarang pertanyaannya adalah: bagaimana kita menggunakan memori campuran ini?  Secara khusus, bagaimana kita mendapatkan nilai yang tepat <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-226"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-227"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-70-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-70"> X </script>  tanpa mempengaruhi <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-228"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-229"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-71-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-71"> Y </script>  dan semua barang lainnya yang menumpuk di satu tempat penyimpanan? <br><br>  Algoritma pembacaan akan menggunakan properti dari distribusi jarak yang ingin tahu dalam ruang dimensi tinggi.  Bahkan jika <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-230"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-231"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-72-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-72"> X </script>  dan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-232"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-233"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-73-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-73"> Y </script>  adalah tetangga terdekat dari <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-234"><span class="MJXp-mn" id="MJXp-Span-235"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10.000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-74-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-74"> 10.000 </script>  pola yang tersimpan, kemungkinan besar akan berbeda sebesar 420 atau 430 bit;  oleh karena itu, jumlah sel padat di mana kedua nilai disimpan cukup kecil - biasanya empat, lima atau enam.  Hal yang sama berlaku untuk semua pola yang berpotongan dengan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-236"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-237"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-75-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-75"> X </script>  .  Ada ribuan dari mereka, tetapi tidak satu pun dari pola yang berpengaruh hadir di lebih dari beberapa salinan dalam lingkaran akses <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-238"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-239"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-76-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-76"> X </script>  . <br><br>  Perintah <code>fetch(X)</code> harus mengembalikan nilai yang sebelumnya ditulis oleh perintah <code>store(X)</code> .  Langkah pertama dalam merekonstruksi nilai adalah mengumpulkan semua informasi yang tersimpan di dalam lingkaran akses 451-bit yang dipusatkan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-240"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-241"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-77-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-77"> X </script>  .  Sejak <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-242"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-243"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-78-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-78"> X </script>  Sebelumnya tercatat di semua tempat ini, kami dapat yakin bahwa kami akan menerima <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-244"><span class="MJXp-mn" id="MJXp-Span-245"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-79-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-79"> 1000 </script>  salinannya.  Kami juga akan mendapatkan tentang <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-246"><span class="MJXp-mn" id="MJXp-Span-247"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10.000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-80-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-80"> 10.000 </script>  salinan vektor <em>lain yang</em> disimpan di tempat-tempat di mana lingkaran akses bersinggungan dengan lingkaran <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-248"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-249"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-81-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-81"> X </script>  .  Tetapi karena persimpangan kecil, masing-masing vektor hadir hanya dalam beberapa salinan.  Maka umumnya masing-masing <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-250"><span class="MJXp-mn" id="MJXp-Span-251"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-82-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-82"> 1000 </script>  Agak mungkin <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-252"><span class="MJXp-mn" id="MJXp-Span-253"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-83-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-83"> 0 </script>  atau <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-254"><span class="MJXp-mn" id="MJXp-Span-255"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-84-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-84"> 1 </script>  .  Jika kita menerapkan fungsi prinsip mayoritas ke semua data yang dikumpulkan pada setiap posisi bit, maka hasilnya akan didominasi oleh <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-256"><span class="MJXp-mn" id="MJXp-Span-257"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-85-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-85"> 1000 </script>  salinan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-258"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-259"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-86-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-86"> X </script>  .  Kemungkinan menjadi berbeda dari <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-260"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-261"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-87-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-87"> X </script>  hasilnya kira-kira sama <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-262"><span class="MJXp-msubsup" id="MJXp-Span-263"><span class="MJXp-mn" id="MJXp-Span-264" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-265" style="vertical-align: 0.5em;"><span class="MJXp-mo" id="MJXp-Span-266"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mn" id="MJXp-Span-267"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">19</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-88-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-88"> 10 ^ {- 19} </script>  . <br><br>  Prosedur prinsip mayoritas ditunjukkan secara lebih rinci di bawah ini pada contoh kecil dari lima vektor data masing-masing 20 bit.  Output akan menjadi vektor yang berbeda, masing-masing bit yang mencerminkan sebagian besar bit yang sesuai dalam vektor data.  (Jika jumlah vektor data genap, maka "gambar" diizinkan oleh pemilihan acak <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-268"><span class="MJXp-mn" id="MJXp-Span-269"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-89-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-89"> 0 </script>  atau <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-270"><span class="MJXp-mn" id="MJXp-Span-271"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-90-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-90"> 1 </script>  .) Skema penulisan dan bacaan alternatif yang ditunjukkan di bawah ini menolak untuk menyimpan semua pola satu per satu.  Sebagai gantinya, ia menyimpan jumlah total bit. <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-272"><span class="MJXp-mn" id="MJXp-Span-273"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-91-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-91"> 0 </script>  dan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-274"><span class="MJXp-mn" id="MJXp-Span-275"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-92-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-92"> 1 </script>  di setiap posisi.  Sel padat memiliki <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-276"><span class="MJXp-mn" id="MJXp-Span-277"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-93-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-93"> 1000 </script>  -bit counter diinisialisasi oleh semua nol.  Ketika sebuah pola dituliskan di tempatnya, setiap bit counter ditambahkan untuk <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-278"><span class="MJXp-mn" id="MJXp-Span-279"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-94-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-94"> 1 </script>  atau berkurang untuk <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-280"><span class="MJXp-mn" id="MJXp-Span-281"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-95-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-95"> 0 </script>  .  Algoritma pembacaan hanya melihat tanda dari setiap bit counter, kembali <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-282"><span class="MJXp-mn" id="MJXp-Span-283"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-96-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-96"> 1 </script>  untuk nilai positif, <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-284"><span class="MJXp-mn" id="MJXp-Span-285"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-97-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-97"> 0 </script>  untuk nilai negatif dan acak ketika bit counter sama <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-286"><span class="MJXp-mn" id="MJXp-Span-287"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-98-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-98"> 0 </script>  . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f91/b82/967/f91b82967ddba26afa8e57373cc6091c.png"></div><br>  Dua skema penyimpanan ini memberikan hasil yang identik. <br><br><hr><br>  Dalam hal komputasi, versi memori terdistribusi jarang ini terlihat seperti lelucon yang dipikirkan dengan saksama.  Untuk diingat <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-288"><span class="MJXp-mn" id="MJXp-Span-289"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10.000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-99-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-99"> 10.000 </script>  elemen kita membutuhkan sejuta sel padat, di mana kita akan menyimpan seribu salinan berlebihan dari setiap pola.  Untuk mengambil hanya satu item dari memori, kami mengumpulkan data dengan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-290"><span class="MJXp-mn" id="MJXp-Span-291"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11.000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-100-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-100"> 11.000 </script>  pola yang disimpan dan menerapkan mekanisme prinsip mayoritas untuk mengungkapnya.  Dan semua ini dilakukan dengan bantuan sekelompok manuver akrobatik hanya untuk mendapatkan vektor yang sudah kita miliki.  Memori tradisional bekerja jauh lebih sedikit secara acak: keduanya menulis dan membaca mengakses satu tempat. <br><br>  Tetapi SDM dapat melakukan apa yang tidak bisa dilakukan oleh memori tradisional.  Secara khusus, dapat mengekstrak informasi berdasarkan sebagian atau perkiraan data.  Katakanlah vektor <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-292"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-293"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-101-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-101"> Z </script>  adalah versi yang rusak <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-294"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-295"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-102-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-102"> X </script>  di mana telah berubah <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-296"><span class="MJXp-mn" id="MJXp-Span-297"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-103-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-103"> 100 </script>  dari <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-298"><span class="MJXp-mn" id="MJXp-Span-299"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-104-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-104"> 1000 </script>  vektor.  Karena dua vektor serupa, perintah <code>fetch(Z)</code> akan mengunjungi banyak tempat yang sama di mana ia disimpan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-300"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-301"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-105-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-105"> X </script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dengan jarak Hamming 100, kita bisa berharap itu </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-302"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-303"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-106-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-106"> X </script>  dan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-304"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-305"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-107-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-107">Z</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> akan dibagikan oleh sekitar 300 sel padat. </font><font style="vertical-align: inherit;">Berkat persimpangan besar ini, vektor kembali</font></font><code>fetch(Z)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(sebut saja itu</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-306"><span class="MJXp-msubsup" id="MJXp-Span-307"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-308" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-309" style="vertical-align: 0.5em;"><span class="MJXp-mi" id="MJXp-Span-310"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">′</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-108-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-108">Z^{\prime}</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) akan lebih dekat dengan</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-311"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-312"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-109-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-109"> X </script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> apa itu</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-313"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-314"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-110-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-110">Z</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat mengulangi proses ini dengan tim </font></font><code>fetch(Z′)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang akan mengembalikan hasilnya</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-315"><span class="MJXp-msubsup" id="MJXp-Span-316"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-317" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-318" style="vertical-align: 0.5em;"><span class="MJXp-mi" id="MJXp-Span-319"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">′ </font></font></span><span class="MJXp-mi" id="MJXp-Span-320"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">′</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-111-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-111">Z^{\prime\prime}</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , bahkan lebih dekat ke</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-321"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-322"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-112-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-112"> X </script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hanya dalam beberapa iterasi, prosedur akan mencapai </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-323"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-324"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-113-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-113"> X </script>  . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kanerva menunjukkan bahwa urutan operasi baca rekursif yang konvergen akan berhasil dengan kepastian yang hampir lengkap jika pola awal tidak terlalu jauh dari target. Dengan kata lain, ada jari-jari kritis: setiap pemeriksaan memori, mulai dari tempat di dalam lingkaran kritis, akan hampir persis menyatu ke pusat, dan akan melakukannya dengan cukup cepat. Upaya untuk mengembalikan elemen yang disimpan di luar lingkaran kritis akan gagal, karena proses penarikan rekursif akan pindah ke jarak rata-rata. Analisis Kanerv menunjukkan bahwa untuk SDM kanonik, radius kritisnya adalah 209 bit. Dengan kata lain, jika kita mengetahui sekitar 80 persen dari bit, kita dapat membuat ulang seluruh pola.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ilustrasi di bawah ini melacak evolusi urutan ingatan rekursif dengan sinyal sumber selain target. </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-325"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-326"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-114-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-114"> X </script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aktif</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-327"><span class="MJXp-mn" id="MJXp-Span-328"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 </font></font></span><span class="MJXp-mo" id="MJXp-Span-329" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font></span><span class="MJXp-mn" id="MJXp-Span-330"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5 </font></font></span><span class="MJXp-mo" id="MJXp-Span-331" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font></span><span class="MJXp-mn" id="MJXp-Span-332"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 </font></font></span><span class="MJXp-mo" id="MJXp-Span-333" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font></span><span class="MJXp-mn" id="MJXp-Span-334"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15 </font></font></span><span class="MJXp-mo" id="MJXp-Span-335" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... </font></font></span><span class="MJXp-mn" id="MJXp-Span-336"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-115-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-115">0, 5, 10, 15 \dots 1000</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dalam percobaan ini, semua urutan dimulai dengan jarak </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-337"><span class="MJXp-mn" id="MJXp-Span-338"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">205</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-116-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-116">205</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau kurang konvergen ke</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-339"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-340"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-117-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-117"> X </script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-341"><span class="MJXp-mn" id="MJXp-Span-342"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-118-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-118"> 10 </script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau kurang iterasi</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(jejak biru)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Semua urutan mulai dari jarak awal yang lebih besar berkeliaran tanpa tujuan melalui ruang kosong yang luas</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-343"><span class="MJXp-mn" id="MJXp-Span-344"><font style="vertical-align: inherit;"></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-119-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-119">1000</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubus</font><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-343"><span class="MJXp-mn" id="MJXp-Span-344"><font style="vertical-align: inherit;"> 1000</font></span></span></span><font style="vertical-align: inherit;"> dimensi, tersisa sekitar 500 bit dari mana saja.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ks/ox/sa/ksoxsaesutehnsikhkl5ofspzze.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transisi dari konvergen ke jalur divergen tidak sepenuhnya jelas, dan ini terlihat dalam grafik compang-camping yang ditunjukkan di bawah ini. </font><font style="vertical-align: inherit;">Di sini kami memperbesar untuk melihat nasib lintasan dimulai dengan offset masuk</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-345"><span class="MJXp-mn" id="MJXp-Span-346"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">175 </font></font></span><span class="MJXp-mo" id="MJXp-Span-347" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font></span><span class="MJXp-mn" id="MJXp-Span-348"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">176 </font></font></span><span class="MJXp-mo" id="MJXp-Span-349" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font></span><span class="MJXp-mn" id="MJXp-Span-350"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">177 </font></font></span><span class="MJXp-mo" id="MJXp-Span-351" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font></span><span class="MJXp-mo" id="MJXp-Span-352" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... </font></font></span><span class="MJXp-mn" id="MJXp-Span-353"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">225</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-120-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-120">175, 176, 177, \dots 225</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bit. </font><font style="vertical-align: inherit;">Semua titik awal dalam 209 bit target ditunjukkan dengan warna biru; </font><font style="vertical-align: inherit;">mulai dari jarak yang lebih jauh berwarna oranye. </font><font style="vertical-align: inherit;">Sebagian besar jalur biru bertemu, dengan cepat bergerak ke jarak nol, sedangkan sebagian besar jalur oranye tidak. </font><font style="vertical-align: inherit;">Namun, dekat dengan jarak kritis, ada banyak pengecualian.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lm/aj/rs/lmajrsq2z4z_tlzg5igefbjhwbu.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grafik di bawah ini menunjukkan tampilan lain pada bagaimana jarak awal dari target memengaruhi kemungkinan konvergensi ke alamat memori yang benar. </font><font style="vertical-align: inherit;">Di kejauhan</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-354"><span class="MJXp-mn" id="MJXp-Span-355"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">170</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-121-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-121">170</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bit berhasil di hampir semua upaya; </font><font style="vertical-align: inherit;">di</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-356"><span class="MJXp-mn" id="MJXp-Span-357"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">240</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-122-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-122">240</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hampir semua tidak berhasil. </font><font style="vertical-align: inherit;">Tampaknya titik persimpangan (di mana kesuksesan dan kegagalan sama-sama memungkinkan) terletak sekitar</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-358"><span class="MJXp-mn" id="MJXp-Span-359"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">203</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-123-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-123">203</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bit, sedikit di bawah hasil Kanerva, sama dengan</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-360"><span class="MJXp-mn" id="MJXp-Span-361"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">209</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-124-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-124">209</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Tidak ada yang misterius dalam perbedaan ini. Dalam perhitungan Kanerv, lingkaran akses seharusnya membatasi dengan tepat </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-362"><span class="MJXp-mn" id="MJXp-Span-363"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-125-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-125">1000</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sel padat. </font><font style="vertical-align: inherit;">Semua sel padat dalam jarak termasuk dalam percobaan saya.</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-364"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-365"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r </font></font></span><span class="MJXp-mo" id="MJXp-Span-366" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">≤ </font></font></span><span class="MJXp-mn" id="MJXp-Span-367"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">451</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-126-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-126">r \le 451</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font><font style="vertical-align: inherit;">rata-rata ada</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-368"><span class="MJXp-mn" id="MJXp-Span-369"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1070</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-127-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-127">1070</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tempat semacam itu.)</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ei/74/gc/ei74gcngwrfwrae1iwfle95ybg4.png"></div><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemampuan untuk menciptakan kembali ingatan dari informasi parsial adalah elemen yang akrab dalam kehidupan manusia. Anda melihat seorang aktor di sebuah acara televisi, dan Anda mengerti bahwa Anda pernah melihatnya sebelumnya, tetapi tidak ingat di mana. Beberapa menit kemudian Anda sadar: ini adalah Tuan Bates dari </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Downton Abbey</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tetapi tanpa kostum kepala pelayan. Pertemuan lulusan sekolah menengah: melihat seorang pria botak ketat di sisi lain ruangan, dapatkah Anda mengenalinya sebagai teman yang Anda kenal hanya sebagai remaja dengan celana pendek olahraga? Terkadang dibutuhkan banyak upaya untuk mengisi kekosongan. Saya sudah </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menulis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tentang "titik buta" saya sendiri yang tidak dapat dijelaskan untuk mengenang wisteria yang tumbuh, yang hanya dapat saya sebutkan setelah dengan sabar membolak-balik katalog bau palsu: hydrangea, verbena, dan forsythia.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisakah kemampuan kita untuk memulihkan memori dari input yang tidak lengkap atau berisik bekerja seperti proses rekursif mengingat vektor dimensi tinggi? Ini akan menjadi hipotesis yang menarik, tetapi ada alasan untuk mewaspadai itu. Misalnya, otak tampaknya mampu mengekstrak makna dari sinyal yang jauh lebih sedikit. Saya tidak perlu mendengarkan empat perlima dari “Simfoni Kelima” untuk mengidentifikasinya, empat not pertama sudah cukup. Warna berkedip-kedip di pohon langsung membuat Anda mengingat spesies burung yang sesuai - kardinal, blue jay, carduelis. Napas sedikit pun dengan bau debu kapur membawaku kembali ke ruang kelas yang mengantuk, tempat aku melukis selama setengah hari di mejaku. Ingatan seperti itu dipicu oleh sebagian kecil dari informasi yang mewakili mereka, jauh kurang dari 80 persen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kanerva menyebutkan fitur lain dari ingatan manusia yang dapat dimodelkan menggunakan SDM: fenomena “berputar di ujung lidah”, intinya adalah Anda tahu bahwa Anda tahu sesuatu, meskipun Anda tidak bisa langsung menyebutnya. Perasaan ini agak misterius: jika Anda tidak dapat menemukan apa yang Anda cari, bagaimana Anda bisa tahu bahwa semuanya tersimpan di otak? Proses penarikan rekursif dari SDM menawarkan kita kemungkinan jawaban. Ketika pola berurutan yang diambil dari memori semakin dekat satu sama lain, kita dapat memastikan bahwa mereka akan menyatu dengan tujuan bahkan sebelum mereka mencapai itu.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam upaya mengekstraksi fakta yang membandel dari ingatan, banyak orang mendapati bahwa terus-menerus mengetuk pintu yang sama bukanlah strategi yang bijaksana. Daripada menuntut jawaban langsung - untuk memerintahkan otak Anda - seringkali lebih baik untuk mengesampingkan tugas, berjalan-jalan, mungkin tidur siang; jawabannya mungkin seolah-olah itu tidak diundang. Bisakah pengamatan ini dijelaskan oleh model SDM? Mungkin setidaknya sebagian. Jika urutan pola yang ditarik tidak menyatu, maka penelitian lebih lanjut mungkin terbukti sia-sia. Jika Anda memulai lagi dari titik tetangga di ruang memori, Anda dapat mencapai hasil yang lebih baik. Tetapi ada sebuah misteri di sini: bagaimana menemukan titik awal baru dengan prospek yang lebih baik? Anda mungkin berpikir bahwa cukup sederhana untuk secara acak mengganti beberapa bit dalam pola input dan harapansebagai hasilnya, ia akan lebih dekat ke tujuan, tetapi kemungkinannya kecil. Jika vektor dalam</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-370"><span class="MJXp-mn" id="MJXp-Span-371"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">250</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bit dari target itu</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-128-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-128">250</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-372"><span class="MJXp-mn" id="MJXp-Span-373"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">750</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bit sudah benar (tapi kita tidak tahu</font><em><font style="vertical-align: inherit;">apa</font></em><font style="vertical-align: inherit;">dari</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-129-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-129">750</script><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-374"><span class="MJXp-mn" id="MJXp-Span-375"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">750</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bit); </font><font style="vertical-align: inherit;">dengan perubahan acak, kami memiliki probabilitas</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-130-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-130">750</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-376"><span class="MJXp-mn" id="MJXp-Span-377"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 </font></font></span><span class="MJXp-mrow" id="MJXp-Span-378"><span class="MJXp-mo" id="MJXp-Span-379" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mn" id="MJXp-Span-380"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> datang dekat dan pergi lebih jauh. </font><font style="vertical-align: inherit;">Untuk membuat kemajuan, Anda perlu tahu ke arah mana harus bergerak, dan masuk</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-131-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-131">3/4</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-381"><span class="MJXp-mn" id="MJXp-Span-382"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ruang 1000</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dimensi adalah pertanyaan yang sulit.</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-132-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-132">1000</script><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salah satu aspek arsitektur SDM adalah tampaknya sesuai dengan efek pengulangan atau mendengarkan kembali ke memori. Jika Anda mengulangi puisi itu beberapa kali atau berlatih memainkan musik, Anda dapat berharap bahwa di masa depan Anda akan mengingatnya dengan lebih mudah. Model komputasi harus menunjukkan efek pelatihan yang serupa. Tetapi ini tidak mungkin dalam memori komputer tradisional: tidak ada keuntungan untuk menulis ulang nilai yang sama beberapa kali di alamat yang sama. Di SDM, di sisi lain, setiap pengulangan pola menambahkan salinan lain ke semua sel padat dalam lingkaran akses pola. Akibatnya, sedikit pengaruh dari pola berpotongan terjadi, dan jari-jari penarikan kritis meningkat. Efeknya memiliki efek signifikan:saat menulis ke memori satu salinan pola, jari-jari kritis meningkat dari sekitar</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-383"><span class="MJXp-mn" id="MJXp-Span-384"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">200</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bit hingga lebih dari</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-133-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-133">200</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-385"><span class="MJXp-mn" id="MJXp-Span-386"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">300</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-134-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-134">300</script>  . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Demikian pula, memainkan satu pola dapat membuat sulit untuk mengembalikan sisanya. </font><font style="vertical-align: inherit;">Ini mengingatkan pada lupa ketika pola yang dicetak secara aktif mengisi tetangganya dan menangkap bagian dari wilayah mereka. </font><font style="vertical-align: inherit;">Efek ini juga secara signifikan mempengaruhi SDM, sedemikian rupa sehingga bahkan tampak tidak realistis. </font><font style="vertical-align: inherit;">Tampaknya suatu vektor yang disimpan delapan atau sepuluh kali memonopoli sebagian besar memori; </font><font style="vertical-align: inherit;">ia menjadi obsesi, jawaban untuk semua pertanyaan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keuntungan penting dari memori terdistribusi jarang adalah ketahanannya terhadap kegagalan atau kesalahan perangkat keras. </font><font style="vertical-align: inherit;">Saya akan marah jika kehilangan satu neuron di otak saya meninggalkan lubang di ingatan saya dan saya tidak bisa mengenali huruf </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau ingat bagaimana mengikat tali sepatu. </font><font style="vertical-align: inherit;">SDM tidak menderita kerapuhan ini. </font><font style="vertical-align: inherit;">Ketika setiap pola yang disimpan memiliki seribu salinan, tidak ada satu tempat pun yang penting. </font><font style="vertical-align: inherit;">Dan faktanya, Anda dapat menghapus semua informasi yang disimpan dalam 60 persen sel padat, dan masih memiliki daya ingat yang sempurna</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-387"><span class="MJXp-mn" id="MJXp-Span-388"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-135-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-135">10000</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , jika kita menganggap bahwa kita mengirimkan alamat yang benar-benar akurat sebagai sinyal. </font><font style="vertical-align: inherit;">Dengan sinyal parsial, jari-jari kritis menyusut ketika bintik-bintik yang hilang meningkat. </font><font style="vertical-align: inherit;">Setelah menghancurkan 60 persen dari situs, jari-jari kritis dikompresi</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-389"><span class="MJXp-mn" id="MJXp-Span-390"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">200 </font></font></span><span class="MJXp-mo" id="MJXp-Span-391" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-136-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-136">200+</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bit hingga sekitar</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-392"><span class="MJXp-mn" id="MJXp-Span-393"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">150</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-137-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-137">150</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bit. Setelah penghancuran 80 persen tempat, memori rusak parah, tetapi tidak hancur.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana dengan mengambang di awan? Bisakah kita dengan santai berkeliaran di padang rumput dari memori yang jarang terdistribusi, melompat dengan keberuntungan dari satu pola yang tersimpan ke yang lain? Saya akan kembali ke pertanyaan ini.</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagian besar di atas ditulis beberapa minggu yang lalu. Pada waktu itu, saya membaca tentang berbagai teori ingatan yang saling bersaing dan mendiskusikan kemampuan mereka dengan rekan-rekan dari Institut Simons. Saya menuliskan pikiran saya tentang hal ini, tetapi menunda publikasi mereka karena keraguan yang terus-menerus: apakah saya memahami matematika dari memori yang jarang didistribusikan dengan benar? Sekarang aku senang aku tidak terburu-buru. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Program Brain and Computing berakhir pada Mei. Para pesertanya pergi: Saya kembali ke New England, di mana sage dan rosemary adalah tanaman pot kecil, dan bukan semak-semak rimbun yang tergantung di jalan setapak. Pagi saya berjalan ke kampus Berkeley, kesempatan sehari-hari untuk merefleksikan sifat ingatan dan pembelajaran, menjadi "engrams" yang disimpan di suatu tempat di kepala saya (namun, saya masih tidak tahu di mana mencarinya).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, saya tidak menyerah pencarian saya. </font><font style="vertical-align: inherit;">Setelah meninggalkan Berkeley, saya terus membaca tentang teori ingatan. </font><font style="vertical-align: inherit;">Saya juga menulis program untuk mempelajari memori terdistribusi Pentti Canerva yang jarang dan ide-idenya yang lebih luas tentang "komputasi hyperspace". </font><font style="vertical-align: inherit;">Bahkan jika proyek ini gagal mengungkapkan kepada saya rahasia ingatan manusia, itu pasti akan mengajari saya sesuatu tentang seni navigasi matematika dan komputasi dalam ruang dimensi tinggi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diagram di bawah ini menunjukkan cara "benar" untuk menerapkan SDM, seperti yang saya pahami. </font><font style="vertical-align: inherit;">Elemen utama adalah matriks silang, di mana baris sesuai dengan sel memori padat, dan kolom membawa sinyal yang mensimulasikan bit individu dari vektor input. </font><font style="vertical-align: inherit;">Ada sejuta baris dalam memori kanonik, yang masing-masing ditugaskan secara acak</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-394"><span class="MJXp-mn" id="MJXp-Span-395"><font style="vertical-align: inherit;"></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alamat</font><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-394"><span class="MJXp-mn" id="MJXp-Span-395"><font style="vertical-align: inherit;"> 1000</font></span></span></span><font style="vertical-align: inherit;"> bit, dan</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-138-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-138">1000</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-396"><span class="MJXp-mn" id="MJXp-Span-397"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-139-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-139">1000</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kolom </font><font style="vertical-align: inherit;">Versi demo ini terdiri dari 20 baris dan 8 kolom.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hm/bf/hq/hmbfhq9wergzhrrb1fskxsurpsk.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proses yang digambarkan dalam diagram terdiri dari menyimpan satu vektor input ke dalam memori kosong. </font><font style="vertical-align: inherit;">Delapan bit input secara bersamaan dibandingkan dengan semua 20 alamat sel padat. </font><font style="vertical-align: inherit;">Ketika bit input dan bit alamat bertepatan - nol dengan nol atau satu dengan satu - kita meletakkan sebuah titik di persimpangan kolom dan baris. </font><font style="vertical-align: inherit;">Kemudian kami menghitung jumlah titik di setiap baris, dan jika jumlahnya sama dengan atau melebihi nilai ambang batas, maka kami menulis vektor input dalam register yang terkait dengan baris ini </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(bidang biru)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dalam contoh kami, nilai ambang adalah 5, dan dalam 8 dari 20 alamat setidaknya ada 5 kecocokan. </font><font style="vertical-align: inherit;">Masuk</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-398"><span class="MJXp-mn" id="MJXp-Span-399"><font style="vertical-align: inherit;"></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-140-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-140">1000</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nilai ambang memori</font><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-398"><span class="MJXp-mn" id="MJXp-Span-399"><font style="vertical-align: inherit;"> 1000-</font></span></span></span><font style="vertical-align: inherit;"> bit akan sama</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-400"><span class="MJXp-mn" id="MJXp-Span-401"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">451</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-141-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-141">451</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan hanya sekitar seperseribu dari semua register yang akan dipilih.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keajaiban arsitektur ini adalah bahwa semua perbandingan bit - dan ada satu miliar di antaranya dalam model kanonik - terjadi secara bersamaan. Oleh karena itu, waktu akses untuk membaca dan menulis tidak tergantung pada jumlah sel padat dan bisa sangat kecil. Jenis pengaturan umum ini, yang dikenal sebagai memori asosiatif atau pengalamatan konten, digunakan di beberapa area komputasi, seperti mengaktifkan pendeteksi partikel di Large Hadron Collider dan mentransmisikan paket melalui router di Internet. Dan diagram sirkuit dapat dikaitkan dengan struktur otak tertentu. Kanerva menunjukkan bahwa otak kecil sangat mirip dengan matriks seperti itu. Garis-garisnya datar, sel Purkinje berbentuk kipas, dikumpulkan seperti halaman-halaman buku; kolom adalah serat paralel yang meregangkan seluruh sel Purkinje. (Namun, otak kecil bukanlah wilayah otak mamalia,di mana memori kognitif dianggap berada.)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akan lebih bagus untuk membangun simulasi SDM berdasarkan lintas-arsitektur ini; </font><font style="vertical-align: inherit;">Sayangnya, saya tidak tahu bagaimana menerapkannya pada peralatan komputer yang saya miliki. </font><font style="vertical-align: inherit;">Dalam prosesor tradisional, tidak ada cara untuk secara bersamaan membandingkan semua bit input dengan bit sel keras. </font><font style="vertical-align: inherit;">Sebagai gantinya, saya harus melalui jutaan sel padat secara berurutan, dan membandingkan ribuan bit di setiap tempat. </font><font style="vertical-align: inherit;">Ini berarti perbandingan sejuta bit untuk setiap elemen yang disimpan atau diambil dari memori. </font><font style="vertical-align: inherit;">Tambahkan ke ini waktu untuk menulis atau membaca sejuta bit (ribuan salinan)</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-402"><span class="MJXp-mn" id="MJXp-Span-403"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000-</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-142-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-142">1000</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bit vektor), dan Anda mendapatkan proses yang agak lambat. </font><font style="vertical-align: inherit;">Berikut adalah kode untuk menyimpan vektor:</font></font><br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">store</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v::BitVector)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SDM</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hamming_distance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v, loc.address)</span></span></span><span class="hljs-function"> &lt;= </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_to_register</span></span></span><span class="hljs-function">!</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(loc.register, v)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implementasi ini memakan waktu sekitar satu jam untuk menginventarisir memori </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-404"><span class="MJXp-mn" id="MJXp-Span-405"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10.000</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pola hafalan. </font><font style="vertical-align: inherit;">(Program lengkap dalam bentuk notebook Jupyter tersedia</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">di GitHub</font></a><font style="vertical-align: inherit;">.)</font><font style="vertical-align: inherit;">Apakah ada algoritma yang lebih baik untuk mensimulasikan SDM pada perangkat keras biasa? </font><font style="vertical-align: inherit;">Salah satu strategi yang memungkinkan memungkinkan untuk menghindari pencarian berulang untuk satu set sel padat di dalam lingkaran akses vektor yang diberikan; </font><font style="vertical-align: inherit;">sebaliknya, ketika vektor pertama kali ditulis ke memori, program menyimpan pointer ke masing-masing dari ribuan tempat penyimpanannya. </font><font style="vertical-align: inherit;">Di masa depan, dengan referensi ke vektor yang sama, program dapat mengikuti</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-143-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-143">10000</script><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-406"><span class="MJXp-mn" id="MJXp-Span-407"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pointer tersimpan, dan tidak memindai seluruh array sejuta sel padat. </font><font style="vertical-align: inherit;">Harga dari skema caching ini adalah kebutuhan untuk menyimpan semua petunjuk ini - dalam SDM kanonik mereka</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-144-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-144">1000</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-408"><span class="MJXp-mn" id="MJXp-Span-409"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-145-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-145"> 10 </script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> juta. </font><font style="vertical-align: inherit;">Ini cukup nyata, dan mungkin layak jika Anda ingin menyimpan dan mengambil hanya nilai yang diketahui. </font><font style="vertical-align: inherit;">Tetapi pikirkan tentang apa yang terjadi sebagai respons terhadap permintaan memori perkiraan dengan penarikan rekursif</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-410"><span class="MJXp-msubsup" id="MJXp-Span-411"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-412" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-413" style="vertical-align: 0.5em;"><span class="MJXp-mi" id="MJXp-Span-414"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">′</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-146-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-146">Z^{\prime}</script>  dan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-415"><span class="MJXp-msubsup" id="MJXp-Span-416"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-417" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-418" style="vertical-align: 0.5em;"><span class="MJXp-mi" id="MJXp-Span-419"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">′ </font></font></span><span class="MJXp-mi" id="MJXp-Span-420"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">′</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-147-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-147">Z^{\prime\prime}</script>  dan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-421"><span class="MJXp-msubsup" id="MJXp-Span-422"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-423" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-424" style="vertical-align: 0.5em;"><span class="MJXp-mi" id="MJXp-Span-425"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">′ </font></font></span><span class="MJXp-mi" id="MJXp-Span-426"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">′ </font></font></span><span class="MJXp-mi" id="MJXp-Span-427"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">′</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-148-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-148">Z^{\prime\prime\prime}</script>  , dan seterusnya.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak satu pun dari nilai-nilai perantara ini akan ditemukan dalam cache, sehingga pemindaian penuh dari semua sel padat masih akan diperlukan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mungkin ada cara yang lebih sulit untuk memotong jalan. Dalam sebuah artikel ulasan baru-baru ini, " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perkiraan Pencarian Tetangga Terdekat dalam Dimensi Tinggi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " oleh Alexander Andoni, Peter Indyk dan Ilya Razenstein, teknik yang menarik disebutkan disebut hashing sensitif lokalitas (hashing berdasarkan lokalitas), tetapi sejauh ini saya tidak cukup mengerti bagaimana menyesuaikannya dengan tugas SDM.</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemampuan untuk memulihkan memori dari sinyal parsial menyakitkan fitur manusia dari model komputasi. </font><font style="vertical-align: inherit;">Mungkin itu dapat diperluas untuk menyediakan mekanisme yang masuk akal dari pengembaraan di sekitar ruang pikiran, di mana satu pemikiran mengarah ke yang berikutnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Awalnya saya pikir saya tahu bagaimana ini bisa berhasil. </font><font style="vertical-align: inherit;">Pola penyimpanan SDM</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-428"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-429"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-149-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-149"> X </script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menciptakan area tarik-menarik di sekitarnya, tempat studi memori rekursif mulai dari radius kritis bertemu</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-430"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-431"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-150-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-150"> X </script>  .  Di <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-432"><span class="MJXp-mn" id="MJXp-Span-433"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10.000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-151-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-151">10000</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> penarik ini, saya bisa bayangkan bagaimana mereka membagi ruang memori menjadi matriks modul individu seperti busa sabun berukuran tinggi. Area untuk setiap elemen yang disimpan menempati volume terpisah, dikelilingi di semua sisi oleh area lain dan berbatasan dengan mereka, dengan batas yang jelas antara domain yang berdekatan. Untuk mendukung proposisi ini, saya dapat melihat bahwa jari-jari rata-rata wilayah tarik-menarik, ketika konten baru ditambahkan ke memori, dikompresi, seolah-olah gelembung dikompresi karena crowding.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visi proses di dalam SDM seperti itu menyarankan cara sederhana untuk berpindah dari satu domain ke domain lain: Anda perlu secara acak mengalihkan sejumlah bit vektor untuk memindahkannya dari objek wisata saat ini ke objek tetangga, dan kemudian menerapkan algoritma penarikan rekursif. Mengulangi prosedur ini akan menghasilkan traversal acak dari banyak topik yang tersimpan dalam memori. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Satu-satunya masalah adalah bahwa pendekatan ini tidak berhasil. Jika Anda memeriksanya, maka itu benar-benar akan berkeliaran tanpa tujuan</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-434"><span class="MJXp-mn" id="MJXp-Span-435"><font style="vertical-align: inherit;"></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-152-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-152">1000</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jaringan</font><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-434"><span class="MJXp-mn" id="MJXp-Span-435"><font style="vertical-align: inherit;"> 1000</font></span></span></span><font style="vertical-align: inherit;"> dimensi, tetapi kita tidak akan pernah menemukan apa pun yang tersimpan di sana. </font><font style="vertical-align: inherit;">Seluruh rencana didasarkan pada pemahaman intuitif yang salah tentang geometri SDM. </font><font style="vertical-align: inherit;">Vektor yang disimpan dengan wilayah tariknya</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dikemas rapat seperti gelembung sabun; </font><font style="vertical-align: inherit;">sebaliknya, mereka adalah galaksi-galaksi terisolasi yang tergantung di alam semesta yang luas dan bebas, dipisahkan oleh ruang-ruang kosong yang luas di antara mereka. </font><font style="vertical-align: inherit;">Perhitungan singkat menunjukkan sifat situasi yang sebenarnya. </font><font style="vertical-align: inherit;">Dalam model kanonik, jari-jari kritis menentukan wilayah tarikan kira-kira sama dengan</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-436"><span class="MJXp-mn" id="MJXp-Span-437"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">200</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-153-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-153">200</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Volume dari satu wilayah, diukur sebagai jumlah vektor di dalamnya, adalah </font></font><br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-438"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-439">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-440">u</span><span class="MJXp-msubsup" id="MJXp-Span-441"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-442" style="margin-right: 0.05em;">m</span><span class="MJXp-script-box" style="height: 1.86em; vertical-align: -0.64em;"><span class=" MJXp-script"><span><span style="margin-bottom: -0.25em;"><span class="MJXp-mrow" id="MJXp-Span-447"><span class="MJXp-mn" id="MJXp-Span-448">200</span></span></span></span></span><span class=" MJXp-script"><span><span style="margin-top: -0.85em;"><span class="MJXp-mrow" id="MJXp-Span-443"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-444">k</span><span class="MJXp-mo" id="MJXp-Span-445">=</span><span class="MJXp-mn" id="MJXp-Span-446">1</span></span></span></span></span></span></span><span class="MJXp-mrow" id="MJXp-Span-449"><span class="MJXp-TeXmathchoice" id="MJXp-Span-450"><span class="MJXp-mrow" id="MJXp-Span-451"><span class="MJXp-mo" id="MJXp-Span-452" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.319em;"><span class="MJXp-right MJXp-scale6" style="font-size: 2.274em; margin-left: -0.09em;">(</span></span></span></span><span class="MJXp-mfrac" id="MJXp-Span-453"><span class="MJXp-box"><span class="MJXp-mn" id="MJXp-Span-454">1000</span></span><span class="MJXp-box" style="margin-top: -0.7em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em;"></span></span><span><span class="MJXp-box"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-455">k</span></span></span></span></span></span><span class="MJXp-TeXmathchoice" id="MJXp-Span-456"><span class="MJXp-mrow" id="MJXp-Span-457"><span class="MJXp-mo" id="MJXp-Span-458" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.319em;"><span class="MJXp-right MJXp-scale6" style="font-size: 2.274em; margin-left: -0.09em;">)</span></span></span></span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-154-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-154">sum_{k = 1}^{200} \binom{1000}{k}</script></p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang kira-kira sama </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-459"><span class="MJXp-msubsup" id="MJXp-Span-460"><span class="MJXp-mn" id="MJXp-Span-461" style="margin-right: 0.05em;">10</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-462" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-463">216</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-155-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-155">10^{216}</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Karena itu semuanya </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-464"><span class="MJXp-mn" id="MJXp-Span-465">10000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-156-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-156">10000</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> area menempati volume </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-466"><span class="MJXp-msubsup" id="MJXp-Span-467"><span class="MJXp-mn" id="MJXp-Span-468" style="margin-right: 0.05em;">10</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-469" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-470">220</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-157-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-157">10^{220}</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ini adalah jumlah yang besar, tetapi masih sebagian kecil </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-471"><span class="MJXp-mn" id="MJXp-Span-472">1000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-158-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-158">1000</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kubus -dimensi. </font><font style="vertical-align: inherit;">Di antara semua simpul kubus, hanya</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-473"><span class="MJXp-mn" id="MJXp-Span-474">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-159-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-159"> 1 </script>  dari <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-475"><span class="MJXp-msubsup" id="MJXp-Span-476"><span class="MJXp-mn" id="MJXp-Span-477" style="margin-right: 0.05em;">10</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-478" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-479">80</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-160-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-160">10^{80}</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terletak dalam 200 bit dari pola yang disimpan. Anda dapat berkeliaran selamanya tanpa menemukan salah satu dari area ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Selamanya? Oh, ya, ya, itu mungkin tidak selamanya. Karena hypercube adalah struktur yang terbatas, cara apa pun melalui itu harus cepat atau lambat menjadi periodik, atau jatuh ke titik tetap dari mana ia tidak pernah pergi, atau tersesat dalam siklus berulang Vektor yang disimpan adalah titik tetap, di samping itu, ada banyak titik tetap lainnya yang tidak sesuai dengan pola yang signifikan. berbalik.)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mencoba menyelamatkan ide buruk ini, saya melakukan beberapa percobaan lagi. </font><font style="vertical-align: inherit;">Dalam satu kasus, saya sewenang-wenang menyimpan beberapa konsep terkait ke alamat tetangga ("tetangga", yaitu </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dalam 200 atau 300 bit). </font><font style="vertical-align: inherit;">Mungkin di dalam kluster ini, saya bisa melompat dengan aman dari titik ke titik. </font><font style="vertical-align: inherit;">Namun pada kenyataannya, seluruh cluster terkondensasi menjadi satu wilayah besar daya tarik untuk pola sentral, yang menjadi lubang hitam yang menghisap semua teman-temannya. </font><font style="vertical-align: inherit;">Saya juga mencoba bermain dengan nilai</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-480"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-481">r</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-161-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-161">r</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(jari-jari lingkaran akses untuk semua operasi baca dan tulis). </font><font style="vertical-align: inherit;">Dalam model kanonik</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-482"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-483">r</span><span class="MJXp-mo" id="MJXp-Span-484" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-485">451</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-162-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-162">r = 451</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya berpikir bahwa menulis ke lingkaran yang sedikit lebih kecil atau membaca dari lingkaran yang sedikit lebih besar akan memberikan ruang yang cukup untuk hasil yang acak, tetapi harapan ini juga tidak terwujud. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semua upaya ini didasarkan pada kesalahpahaman ruang vektor dimensi tinggi. Upaya untuk menemukan kelompok nilai-nilai tetangga di hypercube tidak ada harapan; pola yang disimpan terlalu spasi dalam volume. Penciptaan cluster padat yang sewenang-wenang juga tidak ada gunanya, karena menghancurkan properti yang membuat sistem menarik - kemampuan untuk menyatu dengan elemen yang tersimpan dari mana saja di area sekitar objek wisata. Jika kita ingin membuat algoritma cloud-wandering untuk SDM, maka kita perlu menemukan cara lain.</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam mencari mekanisme alternatif dari aliran kesadaran, Anda dapat mencoba untuk menambahkan sedikit teori grafik ke dunia memori terdistribusi jarang. </font><font style="vertical-align: inherit;">Kemudian kita dapat mengambil satu langkah mundur, kembali ke ide asli dari pengembaraan mental dalam bentuk jalan-jalan acak di sekitar grafik atau jaringan. </font><font style="vertical-align: inherit;">Elemen kunci untuk menyematkan grafik tersebut di SDM ternyata menjadi alat yang akrab bagi kita: operator ATAU eksklusif. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti disebutkan di atas, jarak Hamming antara dua vektor dihitung dengan mengambil bitor XOR dan menghitung unit yang dihasilkan. </font><font style="vertical-align: inherit;">Tetapi operasi XOR tidak hanya memberikan jarak antara dua vektor, tetapi juga informasi lainnya; </font><font style="vertical-align: inherit;">itu juga menentukan orientasi atau arah garis yang menghubungkannya. </font><font style="vertical-align: inherit;">Secara khusus, operasi</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-489"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-490">u</span><span class="MJXp-mo" id="MJXp-Span-491" style="margin-left: 0.267em; margin-right: 0.267em;">⊻</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-492">v</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-163-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-163">u \veebar v</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memberikan daftar vektor bit yang perlu diubah untuk mengkonversi </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-493"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-494">u</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-164-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-164">u</script>  masuk <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-495"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-496">v</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-165-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-165">v</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan sebaliknya. </font><font style="vertical-align: inherit;">Bisa juga dirasakan</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-497"><span class="MJXp-mn" id="MJXp-Span-498">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-166-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-166"> 1 </script>  dan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-499"><span class="MJXp-mn" id="MJXp-Span-500">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-167-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-167"> 0 </script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dalam vektor XOR sebagai urutan arah yang harus Anda ikuti untuk melacak jalur dari </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-501"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-502">u</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-168-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-168">u</script>  sebelumnya <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-503"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-504">v</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-169-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-169">v</script>  . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XOR selalu menjadi favorit saya dari semua fungsi Boolean. </font><font style="vertical-align: inherit;">Ini adalah operator yang berbeda, tetapi tidak seperti pengurangan, XOR simetris:</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-505"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-506">u</span><span class="MJXp-mo" id="MJXp-Span-507" style="margin-left: 0.267em; margin-right: 0.267em;">⊻</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-508">v</span><span class="MJXp-mo" id="MJXp-Span-509" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-510">v</span><span class="MJXp-mo" id="MJXp-Span-511" style="margin-left: 0.267em; margin-right: 0.267em;">⊻</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-512">u</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-170-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-170">u \veebar v = v \veebar u</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, XOR adalah fungsi terbalik sendiri. </font><font style="vertical-align: inherit;">Konsep ini mudah dimengerti dengan fungsi dengan satu argumen:</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-513"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-514">f</span><span class="MJXp-mo" id="MJXp-Span-515" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-516">x</span><span class="MJXp-mo" id="MJXp-Span-517" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-171-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-171"> f (x) </script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah fungsi kebalikannya sendiri jika </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-518"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-519">f</span><span class="MJXp-mo" id="MJXp-Span-520" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-521">f</span><span class="MJXp-mo" id="MJXp-Span-522" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-523">x</span><span class="MJXp-mo" id="MJXp-Span-524" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-525" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-526" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-527">x</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-172-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-172">f(f(x)) = x</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yaitu, setelah menerapkan fungsi dua kali, kita dapat kembali ke tempat kita mulai. </font><font style="vertical-align: inherit;">Untuk fungsi dengan dua argumen, seperti XOR, situasinya lebih rumit, tetapi masih benar bahwa melakukan tindakan yang sama dua kali mengembalikan keadaan semula. </font><font style="vertical-align: inherit;">Khususnya, jika</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-528"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-529">u</span><span class="MJXp-mo" id="MJXp-Span-530" style="margin-left: 0.267em; margin-right: 0.267em;">⊻</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-531">v</span><span class="MJXp-mo" id="MJXp-Span-532" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-533">w</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-173-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-173">u \veebar v = w</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lalu </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-534"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-535">u</span><span class="MJXp-mo" id="MJXp-Span-536" style="margin-left: 0.267em; margin-right: 0.267em;">⊻</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-537">w</span><span class="MJXp-mo" id="MJXp-Span-538" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-539">v</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-174-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-174">u \veebar w = v</script>  dan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-540"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-541">v</span><span class="MJXp-mo" id="MJXp-Span-542" style="margin-left: 0.267em; margin-right: 0.267em;">⊻</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-543">w</span><span class="MJXp-mo" id="MJXp-Span-544" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-545">u</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-175-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-175">v \veebar w = u</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tiga vektor - </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-546"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-547">u</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-176-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-176">u</script>  , <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-548"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-549">v</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-177-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-177">v</script>  dan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-550"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-551">w</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-178-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-178">w</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Menciptakan alam semesta tertutup kecil. </font><font style="vertical-align: inherit;">Anda dapat menerapkan operator XOR untuk pasangan mereka dan mendapatkan elemen ketiga dari set tersebut. </font><font style="vertical-align: inherit;">Berikut ini adalah upaya untuk menggambarkan ide ini. </font><font style="vertical-align: inherit;">Setiap meniru persegi</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-552"><span class="MJXp-mn" id="MJXp-Span-553">10000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-179-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-179">10000</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bit vektor berbaris sebagai 100 x 100 tabel piksel terang dan gelap. </font><font style="vertical-align: inherit;">Tiga pola tersebut tampak acak dan independen, tetapi pada kenyataannya, masing-masing panel adalah XOR dari dua lainnya. </font><font style="vertical-align: inherit;">Misalnya, di kotak paling kiri, setiap piksel merah bersesuaian dengan hijau atau biru, tetapi tidak pernah keduanya.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/xt/rc/wdxtrcs6sx8i6us8r7c7mwf9bn8.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Properti self-invertibility memberitahu kita cara baru untuk mengatur informasi dalam SDM. Misalkan kata </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kupu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font><em><font style="vertical-align: inherit;">kupu</font></em><font style="vertical-align: inherit;"> dan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">papillon</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bahasa Prancisnya </font><font style="vertical-align: inherit;">disimpan dalam vektor acak yang acak. Mereka tidak akan dekat satu sama lain; jarak di antara mereka kemungkinan sekitar 500 bit. Sekarang kita menghitung XOR vektor </font><em><font style="vertical-align: inherit;">kupu</font></em><font style="vertical-align: inherit;"> - </font><em><font style="vertical-align: inherit;">kupu</font></em><font style="vertical-align: inherit;"> ini</font></font><em><font style="vertical-align: inherit;"></font></em> <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-554"><span class="MJXp-mo" id="MJXp-Span-555" style="margin-left: 0.267em; margin-right: 0.267em;">⊻</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-180-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-180">\veebar</script> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">papillon</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; hasilnya adalah vektor lain yang juga dapat disimpan dalam SDM. Vektor baru ini menyandikan koneksi </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inggris-Prancis</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Sekarang kami memiliki alat terjemahan. Memiliki vektor untuk </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kupu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font><em><font style="vertical-align: inherit;">kupu</font></em><font style="vertical-align: inherit;"> , kami melakukan XOR untuknya dengan vektor </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inggris-Prancis</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan mendapatkan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">papillon</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Trik yang sama bekerja pada arah yang berlawanan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pasangan kata dan hubungan di antara mereka membentuk inti dari jaringan semantik. Mari kita tingkatkan sedikit. Kita dapat menyimpan kata </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">caterpillar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di alamat yang berubah-ubah </font><font style="vertical-align: inherit;">, lalu menghitung </font><em><font style="vertical-align: inherit;">kupu</font></em><font style="vertical-align: inherit;"> - </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kupu</font></font></em> <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-556"><span class="MJXp-mo" id="MJXp-Span-557" style="margin-left: 0.267em; margin-right: 0.267em;">⊻</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-181-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-181">\veebar</script> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ulat</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan sebut hubungan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dewasa-muda</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> baru ini </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Apa yang disebut </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ulat</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dalam bahasa Prancis </font><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">Ulat dalam bahasa Prancis adalah </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chenille</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Kami menambahkan fakta ini ke jaringan dengan menyimpan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chenille</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ulat</font></font></em> <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-558"><span class="MJXp-mo" id="MJXp-Span-559" style="margin-left: 0.267em; margin-right: 0.267em;">⊻</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-182-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-182">\veebar</script> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inggris-Perancis</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sekarang adalah waktu untuk sihir: jika kita mengambil </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">papillon</font></font></em> <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-560"><span class="MJXp-mo" id="MJXp-Span-561" style="margin-left: 0.267em; margin-right: 0.267em;">⊻</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-183-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-183">\veebar</script> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chenille</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , kita belajar bahwa kata-kata ini dihubungkan oleh hubungan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">orang dewasa-remaja</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , meskipun mereka tidak secara eksplisit menunjukkan hal ini. </font><font style="vertical-align: inherit;">Keterbatasan ini dikenakan oleh geometri struktur itu sendiri.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ec/dx/-p/ecdx-przlx4rgh7wlp1z63ito-y.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grafik dapat diperluas lebih lanjut dengan menambahkan lebih banyak kata-kata yang berhubungan dengan Inggris-Prancis ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dog-chien, horse-cheval</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) atau lebih banyak pasangan dewasa-muda: ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dog-puppy, tree-sapling</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Anda juga dapat menjelajahi banyak hubungan lain: sinonim, antonim, saudara kandung, sebab-akibat, mangsa predator, dan sebagainya. Ada juga cara yang bagus untuk menggabungkan beberapa peristiwa ke dalam urutan kronologis dengan hanya melakukan XOR pada alamat pendahulu dan penerus node.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara menghubungkan konsep XOR adalah hibrida dari teori geometri dan grafik. </font><font style="vertical-align: inherit;">Dalam teori matematika grafik biasa, jarak dan arah tidak signifikan; </font><font style="vertical-align: inherit;">satu-satunya hal yang penting adalah ada atau tidak adanya tepi yang menghubungkan antar node. </font><font style="vertical-align: inherit;">Di SDM, di sisi lain, tepi yang mewakili koneksi antara node adalah vektor dengan panjang terbatas dan directivity dalam</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-562"><span class="MJXp-mn" id="MJXp-Span-563">1000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-184-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-184">1000</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ruang -dimensi. </font><font style="vertical-align: inherit;">Untuk node dan tautan yang diberikan, operasi XOR "mengikat" node ini ke posisi tertentu di tempat lain di hypercube. </font><font style="vertical-align: inherit;">Struktur yang dihasilkan benar-benar kaku - kita tidak dapat memindahkan node tanpa mengubah semua koneksi yang berpartisipasi. </font><font style="vertical-align: inherit;">Dalam kasus kupu-kupu dan ulat bulu, konfigurasi empat simpul pasti menjadi jajar genjang, di mana pasangan di sisi yang berlawanan memiliki panjang dan arah yang sama.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karakteristik unik lain dari grafik yang terkait dengan operasi XOR adalah bahwa node dan edge memiliki representasi yang sama persis. Dalam sebagian besar implementasi ide-ide komputer dari teori grafik, dua entitas sangat berbeda; sebuah node dapat berupa daftar atribut, dan sebuah edge dapat menjadi sepasang pointer ke node yang terhubung dengannya. Dalam SDM, baik node dan edge hanyalah vektor dimensi tinggi yang dapat disimpan dalam format yang sama.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika digunakan sebagai model memori manusia, XOR binding memberi kita kemampuan untuk menghubungkan dua konsep melalui koneksi apa pun yang dapat kita pikirkan. Banyak koneksi di dunia nyata asimetris; mereka tidak memiliki properti self-invertibility yang dimiliki XOR. Vektor XOR dapat menyatakan bahwa Edward dan Victoria adalah orang tua dan anak, tetapi tidak memberi tahu siapa di antara mereka yang siapa. Lebih buruk lagi, vektor XOR menghubungkan tepat dua node dan tidak pernah lagi, sehingga induk dari beberapa anak menempatkan kami pada posisi yang tidak menyenangkan. Kesulitan lain adalah menjaga integritas semua cabang dari grafik besar satu sama lain. Kami tidak bisa begitu saja menambahkan node dan edge; mereka harus dilampirkan ke grafik dalam urutan yang benar. Memasukkan panggung kepompong antara kupu-kupu dan ulat akan membutuhkan penulisan ulang sebagian besar polanya;Anda harus memindahkan beberapa node ke tempat-tempat baru di dalam hypercube dan menghitung ulang vektor koneksi yang menghubungkannya, sambil memastikan bahwa setiap perubahan pada sisi bahasa Inggris mencerminkan dengan benar pada bahasa Prancis.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beberapa masalah ini diselesaikan dengan teknik berbasis XOR lain yang Kanerva sebut bundling. Idenya adalah untuk membuat semacam database untuk menyimpan pasangan atribut-nilai. Entri buku mungkin memiliki atribut seperti </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">penulis</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">judul,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">penerbit</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, masing-masing dipasangkan dengan nilai yang sesuai. </font><font style="vertical-align: inherit;">Tahap pertama dari bundling data adalah XOR yang terpisah dari setiap pasangan atribut-nilai. </font><font style="vertical-align: inherit;">Kemudian vektor yang diperoleh dari operasi ini digabungkan untuk membuat vektor ringkasan tunggal menggunakan algoritma yang sama yang dijelaskan di atas untuk menyimpan beberapa vektor dalam sel SDM yang solid. </font><font style="vertical-align: inherit;">Melakukan XOR dari nama atribut dengan vektor gabungan ini, kami memperoleh perkiraan nilai yang sesuai cukup dekat untuk menentukannya dengan metode penarikan rekursif. </font><font style="vertical-align: inherit;">Dalam percobaan dengan model kanonik, saya menemukan itu</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-564"><span class="MJXp-mn" id="MJXp-Span-565">1000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-185-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-185">1000</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vektor bit dapat menyimpan enam atau tujuh pasangan nilai atribut tanpa banyak risiko kebingungan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binding dan bundling tidak disebutkan dalam buku Kanerva 1988, tetapi ia membicarakannya secara rinci dalam artikel yang lebih baru. (Lihat bagian "Bacaan Tambahan" di bawah ini.) Ini menunjukkan bahwa dengan dua operator ini, banyak vektor dimensi tinggi mengambil struktur bidang aljabar, atau setidaknya perkiraan untuk bidang. Contoh kanonik bidang adalah seperangkat bilangan real bukan dengan operasi penambahan dan perkalian, serta operator kebalikannya. Bilangan real membuat set tertutup di bawah operasi ini: penjumlahan, pengurangan, perkalian, atau pembagian dua bilangan real memberikan bilangan real lain (dengan pengecualian pembagian dengan nol, yang selalu menjadi pelawak di geladak). Demikian pula, himpunan vektor biner ditutup untuk menghubungkan dan bundling, kecualibahwa kadang-kadang, untuk mengembalikan anggota suatu set, hasil yang diekstraksi dari vektor banding perlu "dibersihkan" oleh proses penarikan rekursif.</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisakah menautkan dan menggabungkan membantu kita mendapatkan algoritma cloud-wandering? Mereka memberi kami alat dasar untuk menavigasi grafik semantik, termasuk kemampuan untuk melakukan traversal acak. Dimulai dari sembarang simpul dalam grafik XOR yang terhubung, algoritma traversal acak memilih di antara semua tautan yang tersedia di sengatan ini. Pilihan acak dari vektor komunikasi dan eksekusi XOR dari vektor ini dengan alamat simpul membawa kita ke simpul lain di mana prosedur dapat diulang. Demikian pula, dalam pasangan “nilai-nilai” bundling, atribut yang dipilih secara acak memanggil nilai yang sesuai, yang menjadi simpul berikutnya yang sedang diselidiki.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi bagaimana suatu algoritma mengetahui hubungan mana atau algoritma mana yang tersedia untuk seleksi? Hubungan dan atribut diwakili dalam bentuk vektor dan disimpan dalam memori seperti objek lainnya, jadi tidak ada cara yang jelas untuk mendapatkan vektor ini kecuali Anda tahu apa itu sebenarnya. Kita tidak bisa mengatakan memori "tunjukkan semua koneksi." Kita hanya bisa menunjukkan polanya dan bertanya “adakah vektor seperti itu? Pernahkah Anda melihat sesuatu seperti ini? "</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam memori komputer tradisional, kita bisa mendapatkan dump memori: buka semua alamat dan tampilkan nilai yang ditemukan di setiap tempat. Tetapi untuk memori terdistribusi tidak ada prosedur seperti itu. Fakta yang menyedihkan ini diberikan kepada saya dengan susah payah. Ketika membangun model komputasi SDM, saya berhasil mendapatkan cukup baik untuk mendapatkan kemampuan untuk menyimpan beberapa ribu pola yang dihasilkan secara acak dalam memori saya. Tetapi saya tidak dapat mengekstraknya karena saya tidak tahu harus meminta apa. Solusinya adalah membuat daftar terpisah di luar SDM itu sendiri, di mana semua yang saya simpan akan ditulis. Tetapi anggapan bahwa otak akan menyimpan ingatan dan indeks ingatan ini tampaknya tidak masuk akal. Mengapa tidak menggunakan indeks saja, karena jauh lebih mudah?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena keterbatasan ini, tampaknya memori terdistribusi jarang dilengkapi untuk melayani indera, tetapi tidak imajinasi. Itu dapat mengenali pola-pola yang sudah dikenal dan menyimpan yang baru yang akan dikenali dalam pertemuan di masa depan bahkan dari sinyal parsial atau rusak. Berkat tautan atau bundling, memori juga dapat melacak tautan antara pasangan item yang disimpan. Tetapi semua yang ditulis dalam memori hanya dapat diambil dengan mengirimkan sinyal yang sesuai.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/441/531/686/4415316868403204d8d2df1f22201eeb.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika saya melihat poster </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pascasarjana</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , saya melihat Dustin Hoffman menatap kaki Anne Bancroft dengan kaus kaki. Stimulus visual ini menggairahkan himpunan bagian neuron di korteks serebral, sesuai dengan ingatan saya tentang aktor, karakter, plot, soundtrack dan 1967. Semua aktivitas otak ini dapat dijelaskan oleh arsitektur memori SDM, jika kita mengasumsikan bahwa himpunan bagian neuron dapat direpresentasikan dalam beberapa bentuk abstrak sebagai vektor biner acak yang panjang. Tetapi orang tidak dapat dengan mudah menjelaskan fakta bahwa saya dapat menyebabkan semua sensasi yang sama di otak tanpa melihat gambar ini. Bagaimana saya secara khusus mengekstrak sekuens acak panjang ini dari jalinan besar vektor, tidak tahu persis di mana mereka?</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini mengakhiri perjalanan panjang saya - sebuah catatan keraguan dan kekecewaan. Tidak mengejutkan Anda bahwa saya tidak berhasil mencapai esensi. Ini adalah topik yang sangat kompleks. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada hari pertama program Brain and Computing di Simons Institute, Jeff Lichtman, yang bekerja melacak sirkuit di otak tikus, mengajukan pertanyaan: apakah ilmu saraf sudah mencapai momen Watson-Crick? Dalam genetika molekuler, kami telah mencapai titik di mana kami dapat menghilangkan untai DNA dari sel hidup dan membaca banyak pesan di dalamnya. Kita bahkan dapat merekam pesan kita sendiri dan menyisipkannya kembali ke tubuh. Kemampuan serupa dalam ilmu saraf adalah mempelajari jaringan otak dan membaca informasi yang tersimpan di dalamnya - pengetahuan, ingatan, pandangan dunia. Mungkin kita bahkan dapat menulis informasi langsung ke otak.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ilmu pengetahuan bahkan tidak mendekati pencapaian tujuan ini, dengan sukacita banyak orang. Termasuk saya: Saya tidak ingin pikiran saya tersedot keluar dari kepala saya melalui elektroda atau pipet dan digantikan oleh #fakenews. Namun, saya </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">benar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font><em><font style="vertical-align: inherit;">benar</font></em><font style="vertical-align: inherit;"> ingin tahu cara kerja otak.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Program Simons Institute telah membutakan saya dengan keberhasilan neuroscience baru-baru ini, tetapi juga membuat saya sadar bahwa salah satu pertanyaan paling serius masih belum terjawab. Proyek-proyek konektivitas Lichtmann dan lainnya membuat peta terperinci jutaan neuron dan koneksi mereka. Teknik-teknik perekaman baru memungkinkan kita untuk mendengarkan sinyal yang dipancarkan oleh neurosit individu dan mengikuti gelombang eksitasi melintasi area luas otak. Kami memiliki katalog jenis neuron yang cukup komprehensif dan kami tahu banyak tentang fisiologi dan biokimia mereka. Semua ini mengesankan, tetapi masih ada teka-teki. Kita dapat merekam sinyal saraf, tetapi sebagian besar kita tidak tahu apa artinya. Kita tidak tahu bagaimana informasi dikodekan dan disimpan di otak. Ini mirip dengan mencoba memahami diagram sirkuit komputer digital tanpa pengetahuan tentang aritmatika biner dan logika Boolean.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Model memori terdistribusi Pentti Canerva yang jarang adalah salah satu upaya untuk mengisi beberapa celah ini. </font><font style="vertical-align: inherit;">Ini bukan satu-satunya upaya seperti itu. </font><font style="vertical-align: inherit;">Alternatif yang lebih dikenal adalah pendekatan John Hopfield - konsep jaringan saraf sebagai sistem dinamis, mengambil bentuk penarik meminimalkan energi. </font><font style="vertical-align: inherit;">Kedua ide ini memiliki prinsip dasar yang sama: informasi tersebar di sejumlah besar neuron dan dikodekan dalam bentuk yang tidak jelas bagi pengamat eksternal, bahkan ia akan mendapatkan akses ke semua neuron dan sinyal yang melewatinya. </font><font style="vertical-align: inherit;">Skema serupa, yang pada dasarnya matematika dan komputasi, secara konseptual terletak di tengah antara psikologi tingkat tinggi dan teknik saraf tingkat rendah. </font><font style="vertical-align: inherit;">Lapisan ini mengandung nilai.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bacaan tambahan</font></font></b> <div class="spoiler_text"> Hopfield, JJ (1982). Neural networks and physical systems with emergent collective computational abilities. <em>Proceedings of the National Academy of Sciences</em> 79(8):2554–2558. <br><br> Kanerva, Pentti. 1988. <em>Sparse Distributed Memory</em> . Cambridge, Mass.: MIT Press. <br><br> Kanerva, Pentti. 1996. Binary spatter-coding of ordered <em>K</em> -tuples. In C. von der Malsburg, W. von Seelen, JC Vorbruggen and B. Sendhoff, eds. <em>Artificial Neural Networks—ICANN 96 Proceedings</em> , pp. 869–873. Berlin: Springer. <br><br> Kanerva, Pentti. 2000. Large patterns make great symbols: An example of learning from example. In S. Wermter and R. Sun, eds. <em>Hybrid Neural Systems</em> , pp. 194–203. Heidelberg: Springer. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PDF</a> <br><br> Kanerva, Pentti. 2009. Hyperdimensional computing: An introduction to computing in distributed representation with high-dimensional random vectors. <em>Cognitive Computation</em> 1(2):139–159. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PDF</a> <br><br> Kanerva, Pentti. 2010. What we mean when we say “What's the Dollar of Mexico?”: Prototypes and mapping in concept space. Report FS-10-08-006, AAAI Fall Symposium on Quantum Informatics for Cognitive, Social, and Semantic Processes. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PDF</a> <br><br> Kanerva, Pentti. 2014. Computing with 10,000-bit words. Fifty-second Annual Allerton Conference, University of Illinois at Urbana-Champagne, October 2014. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PDF</a> </div></div><br><p> Plate, Tony. 1995. Holographic reduced representations. IEEE Transactions on Neural Networks 6(3):623–641. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PDF</a> <br><br> Plate, Tony A. 2003. <em>Holographic Reduced Representation: Distributed Representation of Cognitive Structure</em> . Stanford, CA: CSLI Publications. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419147/">https://habr.com/ru/post/id419147/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id419135/index.html">Friday JS: 0-line JS dan CSS game</a></li>
<li><a href="../id419137/index.html">Pencatatan aktivitas menggunakan Web Beacon API</a></li>
<li><a href="../id419141/index.html">Seks phishing mendapatkan momentum di AS</a></li>
<li><a href="../id419143/index.html">Membuat mesin arcade emulator. Bagian 4</a></li>
<li><a href="../id419145/index.html">Fintech Digest: Kapitalisasi Apple melebihi $ 1 triliun, AI membantu eBay meningkatkan pendapatan hingga miliaran</a></li>
<li><a href="../id419149/index.html">Panduan untuk Mikrotik RoMON</a></li>
<li><a href="../id419151/index.html">Rumah pintar: dimensi baru kenyamanan dan pengejaran keunggulan. Bagian dua</a></li>
<li><a href="../id419153/index.html">Memorandum Hak Cyborg</a></li>
<li><a href="../id419155/index.html">Porting JS ke Elbrus</a></li>
<li><a href="../id419159/index.html">Kode JS, angka Romawi, teka-teki geometris: bagaimana kita mengenkripsi zaman kita</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>