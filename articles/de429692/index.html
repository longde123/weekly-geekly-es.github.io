<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤷🏿 🎅🏽 🈴 Optimierung der Ereignisbehandlung in Angular 🦃 ✨ 👋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einführung 


 Angular bietet eine bequeme deklarative Möglichkeit, Ereignisse in einer Vorlage mit der Syntax (eventName)="onEventName($event)" zu ab...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimierung der Ereignisbehandlung in Angular</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/429692/"><h1 id="vvedenie">  Einführung </h1><br><p> Angular bietet eine bequeme deklarative Möglichkeit, Ereignisse in einer Vorlage mit der Syntax <code>(eventName)="onEventName($event)"</code> zu abonnieren.  Zusammen mit der <code>ChangeDetectionStrategy.OnPush</code> Änderungsprüfungsrichtlinie startet dieser Ansatz den Änderungsprüfungszyklus automatisch nur für Benutzereingaben, die uns interessieren.  Mit anderen Worten, wenn wir das <code>(input)</code> Ereignis im <code>&lt;input&gt;</code> -Element abhören, wird die Änderungsprüfung nicht ausgelöst, wenn der Benutzer einfach auf das Eingabefeld klickt.  Es verbessert sich stark <br>  Leistung im Vergleich zur Standardrichtlinie ( <code>ChangeDetectionStrategy.Default</code> ).  In Direktiven können wir Ereignisse auf dem Host-Element auch über den <code>@HostListener('eventName')</code> . </p><br><p>  In meiner Praxis gibt es häufig Fälle, in denen die Verarbeitung eines bestimmten Ereignisses nur erforderlich ist, wenn eine Bedingung erfüllt ist.  d.h.  Der Handler sieht ungefähr so ​​aus: </p><a name="habracut"></a><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ComponentWithEventHandler</span></span></span><span class="hljs-class"> { // ... onEvent(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Event</span></span></span><span class="hljs-class">) { if (!</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">condition</span></span></span><span class="hljs-class">) { return; } // </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Handling</span></span></span><span class="hljs-class"> event ... } }</span></span></code> </pre> <br><p>  Selbst wenn die Bedingung nicht erfüllt ist und tatsächlich keine Aktionen ausgeführt wurden, wird der Änderungsüberprüfungszyklus trotzdem gestartet.  Bei häufigen Ereignissen wie <code>mousemove</code> oder <code>mousemove</code> kann dies die Anwendungsleistung beeinträchtigen. </p><br><p>  In der Komponenten-UI-Bibliothek, an der ich arbeite, löste das Abonnieren von <code>mousemove</code> in den Dropdown-Menüs eine Nachzählung von Änderungen im gesamten Komponentenbaum für jede Mausbewegung aus.  Es war notwendig, die Maus zu überwachen, um das richtige Menüverhalten zu implementieren, aber es war eindeutig eine Optimierung wert.  Mehr dazu weiter unten. </p><br><p>  Solche Momente sind besonders wichtig für universelle UI-Elemente.  Möglicherweise befinden sich viele davon auf der Seite, und Anwendungen können sehr komplex sein und hohe Anforderungen an die Leistung stellen. </p><br><p>  Sie können die Situation korrigieren, indem Sie Ereignisse unter Umgehung von <code>ngZone</code> , z. B. mit <code>Observable.fromEvent</code> und manuell nach Änderungen <code>ngZone</code> , indem Sie <code>changeDetectorRef.markForCheck()</code> aufrufen.  Dies bringt jedoch eine Menge zusätzlicher Arbeit mit sich und macht es unmöglich, die praktischen integrierten Winkelwerkzeuge zu verwenden. </p><br><p>  Es ist kein Geheimnis, dass Angular es Ihnen ermöglicht, die sogenannten Pseudo-Ereignisse zu abonnieren und genau anzugeben, an welchen Ereignissen wir interessiert sind.  Wir können schreiben <code>(keydown.enter)="onEnter($event)"</code> und der Handler (und damit der Änderungsprüfzyklus) wird nur aufgerufen, wenn die <code>Enter</code> gedrückt wird. Die verbleibenden Drücke werden ignoriert.  In diesem Artikel wird erläutert, wie Sie denselben Ansatz wie Angular verwenden können, um die Ereignisbehandlung zu optimieren.  <code>.prevent</code> als <code>.stop</code> <code>.prevent</code> und <code>.stop</code> , die das Standardverhalten aufheben und verhindern, dass das Ereignis automatisch angezeigt wird. </p><br><h1 id="eventmanagerplugin">  EventManagerPlugin </h1><br><div style="text-align:center;"><img width="600" height="600" src="https://habrastorage.org/webt/ss/vr/ls/ssvrlsnebhii2-bcfct4kcmvllu.jpeg"></div><br><p>  Angular verwendet die <code>EventManager</code> Klasse, um Ereignisse zu verarbeiten.  Es verfügt über eine Reihe sogenannter Plugins, die das abstrakte <code>EventManagerPlugin</code> und die Verarbeitung von Ereignisabonnements an das Plugin delegieren, das dieses Ereignis unterstützt (nach Namen).  In Angular gibt es mehrere Plugins, darunter die HammerJS-Ereignisbehandlung und ein Plugin, das für zusammengesetzte Ereignisse wie <code>keydown.enter</code> .  Dies ist eine interne Implementierung von Angular, und dieser Ansatz kann sich ändern.  Seit der Erstellung des Problems zur Verarbeitung dieser Lösung sind jedoch drei Jahre vergangen, und in dieser Richtung wurden keine Fortschritte erzielt: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/angular/angular/issues/3929</a> </p><br><p>  Was ist daran für uns interessant?  Trotz der Tatsache, dass diese Klassen intern sind und nicht von ihnen geerbt werden können, ist das Token, das für die Implementierung von Abhängigkeiten für Plugins verantwortlich ist, öffentlich.  Dies bedeutet, dass wir unsere eigenen Plugins schreiben und den integrierten Ereignisbehandlungsmechanismus damit erweitern können. </p><br><p>  Wenn Sie sich den Quellcode von <code>EventManagerPlugin</code> , werden Sie feststellen, dass wir nicht davon erben können. Er ist größtenteils abstrakt und es ist einfach, eine eigene Klasse zu implementieren, die den Anforderungen entspricht: </p><br><p>  <a href="">https://github.com/angular/angular/blob/master/packages/platform-browser/src/dom/events/event_manager.ts#L92</a> </p><br><p>  Grob gesagt sollte das Plugin in der Lage sein, festzustellen, ob es mit diesem Ereignis arbeitet, und sollte in der Lage sein, einen Ereignishandler und globale Handler (für <code>body</code> , <code>window</code> und <code>document</code> ) hinzuzufügen.  Wir werden uns für die Modifikatoren <code>.filter</code> , <code>.prevent</code> und <code>.stop</code> .  Um sie an unser Plugin zu binden, implementieren wir die erforderlichen Methodenunterstützungen: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FILTER = <span class="hljs-string"><span class="hljs-string">'.filter'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PREVENT = <span class="hljs-string"><span class="hljs-string">'.prevent'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> STOP = <span class="hljs-string"><span class="hljs-string">'.stop'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">FilteredEventPlugin</span></span> { supports(<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>): boolean { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.includes(FILTER) || <span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.includes(PREVENT) || <span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.includes(STOP) ); } }</code> </pre> <br><p>  <code>EventManager</code> wird also verstehen, dass Ereignisse, in deren Namen bestimmte Modifikatoren vorhanden sind, zur Verarbeitung an unser Plugin übergeben werden müssen.  Dann müssen wir das Hinzufügen von Ereignishandlern implementieren.  Wir sind nicht an globalen Handlern interessiert, in ihrem Fall ist der Bedarf an solchen Tools viel seltener und die Implementierung wäre komplizierter.  Daher entfernen wir einfach unsere Modifikatoren aus dem Ereignisnamen und geben sie an den <code>EventManager</code> damit er <code>EventManager</code> richtige integrierte Plug-In für die Verarbeitung <code>EventManager</code> : </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FilteredEventPlugin</span></span></span><span class="hljs-class"> { supports(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">): boolean { // ... } addGlobalEventListener( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">eventName</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handler</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Function</span></span></span><span class="hljs-class">, ): </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Function</span></span></span><span class="hljs-class"> { const event = eventName .replace(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FILTER</span></span></span><span class="hljs-class">, '') .replace(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PREVENT</span></span></span><span class="hljs-class">, '') .replace(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">STOP</span></span></span><span class="hljs-class">, ''); return this.manager.addGlobalEventListener(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handler</span></span></span><span class="hljs-class">); } }</span></span></code> </pre> <br><p>  Im Falle eines Ereignisses für ein reguläres Element müssen wir unsere eigene Logik schreiben.  Zu diesem <code>EventManager</code> wir den Handler in einen Abschluss ein und übergeben das Ereignis ohne unsere Modifikatoren an den <code>EventManager</code> , der außerhalb von <code>ngZone</code> , um zu vermeiden, dass der Änderungsprüfzyklus <code>ngZone</code> wird: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FilteredEventPlugin</span></span></span><span class="hljs-class"> { supports(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">): boolean { // ... } addEventListener( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HTMLElement</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">eventName</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handler</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Function</span></span></span><span class="hljs-class">, ): </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Function</span></span></span><span class="hljs-class"> { const event = eventName .replace(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FILTER</span></span></span><span class="hljs-class">, '') .replace(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PREVENT</span></span></span><span class="hljs-class">, '') .replace(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">STOP</span></span></span><span class="hljs-class">, ''); //     const filtered = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Event</span></span></span><span class="hljs-class">) =&gt; { // ... }; const wrapper = () =&gt; this.manager.addEventListener(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">filtered</span></span></span><span class="hljs-class">); return this.manager.getZone().runOutsideAngular(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wrapper</span></span></span><span class="hljs-class">); } /* addGlobalEventListener(...): </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Function</span></span></span><span class="hljs-class"> { ... } */ }</span></span></code> </pre> <br><p>  Zu diesem Zeitpunkt haben wir: den Namen des Ereignisses, das Ereignis selbst und das Element, auf das es gehört wird.  Der Handler, der hierher kommt, ist nicht der diesem Ereignis zugewiesene Quellhandler, sondern das Ende der Schließungskette, die Angular für seine eigenen Zwecke erstellt hat. </p><br><p>  Eine Lösung wäre, dem Element ein Attribut hinzuzufügen, das für den Aufruf des Handlers verantwortlich ist oder nicht.  Manchmal ist es zur Entscheidungsfindung erforderlich, das Ereignis selbst zu analysieren: ob die Standardaktion abgebrochen wurde, welches Element die Quelle des Ereignisses ist usw.  Ein Attribut reicht dafür nicht aus. Wir müssen einen Weg finden, eine Filterfunktion festzulegen, die ein Ereignis empfängt und <code>true</code> oder <code>false</code> zurückgibt.  Dann könnten wir unseren Handler wie folgt beschreiben: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> filtered = (<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>: Event) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> filter = getOurHandler(some_arguments); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !eventName.includes(FILTER) || !filter || filter(<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>) ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (eventName.includes(PREVENT)) { <span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.preventDefault(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (eventName.includes(STOP)) { <span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.stopPropagation(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.manager.getZone().run(() =&gt; handler(<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>)); } };</code> </pre> <br><h1 id="reshenie">  Lösung </h1><br><p>  Die Lösung kann ein Singleton-Dienst sein, der die Entsprechung von Elementen zu Ereignis / Filter-Paaren und Hilfsentitäten zum Festlegen dieser Entsprechungen speichert.  Natürlich können auf einem Element mehrere Handler für dasselbe Ereignis vorhanden sein, aber in der Regel können sowohl <code>@HostListener</code> als auch ein Handler auf dieser Komponente in der Vorlage eine Ebene höher installiert sein.  Wir werden diese Situation vorhersehen, während andere Fälle aufgrund ihrer Spezifität für uns von geringem Interesse sind. </p><br><p>  Der Hauptdienst ist recht einfach und besteht aus einer Karte und einigen Methoden zum Einstellen, Empfangen und Reinigen von Filtern: </p><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Filter</span></span></span><span class="hljs-class"> = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Event</span></span></span><span class="hljs-class">) =&gt; boolean; export </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Filters</span></span></span><span class="hljs-class"> = {[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">key</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">]: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Filter</span></span></span><span class="hljs-class">}; class </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FilteredEventMainService</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">private</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">elements</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Map</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Element</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Filters</span></span></span><span class="hljs-class">&gt; = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Map</span></span></span><span class="hljs-class">(); </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">register</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Element</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">filters</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Filters</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">elements</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">set</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">filters</span></span></span><span class="hljs-class">); } unregister(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Element</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">elements</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">delete</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class">); } getFilter(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Element</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">): </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Filter</span></span></span><span class="hljs-class"> | null { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">map</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">elements</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class">); </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">map</span></span></span><span class="hljs-class"> ? </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">map</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">] || </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">null</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">null</span></span></span><span class="hljs-class">; } }</span></span></code> </pre> <br><p>  Somit können wir diesen Service im Plugin implementieren und einen Filter erhalten, indem wir das Element und den Namen des Ereignisses übergeben.  Für die Verwendung in Verbindung mit <code>@HostListener</code> fügen wir einen weiteren kleinen Dienst hinzu, der mit der Komponente lebt und die entsprechenden Filter <code>@HostListener</code> wenn sie entfernt wird: </p><br><pre> <code class="hljs kotlin">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventFiltersService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( <span class="hljs-meta"><span class="hljs-meta">@Inject(ElementRef)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> readonly elementRef: ElementRef, <span class="hljs-meta"><span class="hljs-meta">@Inject(FilteredEventMainService)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> readonly mainService: FilteredEventMainService, ) {} ngOnDestroy() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mainService.unregister(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elementRef.nativeElement); } register(filters: Filters) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mainService.register(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elementRef.nativeElement, filters); } }</code> </pre> <br><p>  Um Elemente zu Filtern hinzuzufügen, können Sie eine ähnliche Anweisung erstellen: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventFiltersDirective</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Input()</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> eventFilters(filters: Filters) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mainService.register(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elementRef.nativeElement, filters); } <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( <span class="hljs-meta"><span class="hljs-meta">@Inject(ElementRef)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> readonly elementRef: ElementRef, <span class="hljs-meta"><span class="hljs-meta">@Inject(FilteredEventMainService)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> readonly mainService: FilteredEventMainService, ) {} ngOnDestroy() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mainService.unregister(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elementRef.nativeElement); } }</code> </pre> <br><p>  Wenn es einen Dienst zum Filtern von Ereignissen innerhalb der Komponente gibt, können Filter nicht über die Direktive daran gehängt werden.  Am Ende kann dies fast immer durch einfaches Umschließen der Komponente mit dem Element erfolgen, dem unsere Direktive zugewiesen wird.  Um zu verstehen, dass für dieses Element bereits ein Dienst vorhanden ist, werden wir ihn optional in der Richtlinie implementieren: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EventFiltersDirective</span></span></span><span class="hljs-class"> { // ... constructor( @</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Optional</span></span></span><span class="hljs-class">() @</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Self</span></span></span><span class="hljs-class">() @</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Inject</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FiltersService</span></span></span><span class="hljs-class">) private readonly filtersService: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FiltersService</span></span></span><span class="hljs-class"> | null, ) {} // ... }</span></span></code> </pre> <br><p>  Wenn dieser Dienst vorhanden ist, wird eine Meldung angezeigt, die besagt, dass die Richtlinie nicht auf ihn anwendbar ist: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventFiltersDirective</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Input()</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> eventFilters(filters: Filters) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.eventFiltersService === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { console.warn(ALREADY_APPLIED_MESSAGE); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mainService.register(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elementRef.nativeElement, filters); } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><div style="text-align:center;"><img width="324" height="500" src="https://habrastorage.org/webt/k5/qi/rd/k5qirdkshv3m4cwjfzama7topjm.jpeg"></div><br><h1 id="primenenie-na-praktike">  Praktische Anwendung </h1><br><p>  Alle beschriebenen Codes finden Sie auf Stackblitz: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://stackblitz.com/edit/angular-event-filter</a> </p><br><p>  Als Anwendungsbeispiele wird dort eine imaginäre <code>select</code> angezeigt - eine Komponente in einem modalen Fenster - und ein Kontextmenü in der Rolle des Dropdowns.  Wenn Sie im Kontextmenü eine Implementierung überprüfen, werden Sie feststellen, dass das Verhalten immer das folgende ist: Wenn Sie mit der Maus über ein Element fahren, wird es fokussiert. Wenn Sie die Pfeile auf der Tastatur drücken, bewegt sich der Fokus durch die Elemente. Wenn Sie jedoch die Maus bewegen, kehrt der Fokus zum Element zurück befindet sich unter dem Mauszeiger.  Es scheint, dass dieses Verhalten einfach zu implementieren ist. Unnötige Reaktionen auf das <code>mousemove</code> können jedoch Dutzende nutzloser Änderungsprüfzyklen auslösen.  Indem Sie als Filter eine Prüfung für den Fokus des Zielelements des Ereignisses festlegen, können Sie diese unnötigen Auslösungen abschneiden und nur diejenigen belassen, die wirklich den Fokus tragen. </p><br><div style="text-align:center;"><img width="600" height="325" src="https://habrastorage.org/webt/ha/4m/1r/ha4m1rwr3suhds0xl1cdgbc1lso.gif"></div><br><p>  Diese <code>select</code> <code>@HostListener</code> nach <code>@HostListener</code> Abonnements.  Wenn Sie die <code>Esc</code> im Popup drücken, sollte es geschlossen werden.  Dies sollte nur geschehen, wenn dieser Klick in einer verschachtelten Komponente nicht erforderlich war und in dieser nicht verarbeitet wurde.  Bei <code>select</code> Drücken von <code>Esc</code> die Dropdown-Liste geschlossen und der Fokus auf das Feld selbst zurückgesetzt. Wenn es jedoch bereits geschlossen ist, sollte es nicht verhindern, dass das Ereignis auftaucht und das modale Fenster später geschlossen wird.  Somit kann die Verarbeitung durch einen Dekorateur beschrieben werden: </p><br><p>  <code>@HostListener('keydown.esc.filtered.stop')</code> beim <code>@HostListener('keydown.esc.filtered.stop')</code> : <code>() =&gt; this.opened</code> . </p><br><p>  Da <code>select</code> eine Komponente mit mehreren fokussierbaren Elementen ist, ist die Verfolgung des allgemeinen Fokus über <code>focusout</code> Popup-Ereignisse möglich.  Sie treten bei allen Änderungen im Fokus auf, einschließlich derer, die die Grenzen der Komponente nicht verlassen.  Dieses Ereignis verfügt über ein verwandtes <code>relatedTarget</code> , das <code>relatedTarget</code> wohin sich der Fokus bewegt.  Nachdem wir es analysiert haben, können wir verstehen, ob wir ein Analogon des <code>blur</code> für unsere Komponente aufrufen sollen: </p><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SelectComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... @HostListener('focusout.filtered') onBlur() { this.opened = false; } // ... }</span></span></code> </pre> <br><p>  Der Filter sieht gleichzeitig so aus: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> focusOutFilter = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{relatedTarget}: FocusEvent</span></span></span><span class="hljs-function">) =&gt;</span></span> !<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elementRef.nativeElement.contains(relatedTarget);</code> </pre> <br><h1 id="vyvod">  Fazit </h1><br><p>  Leider wird die integrierte Verarbeitung von zusammengesetzten Tastenanschlägen in Angular weiterhin in <code>NgZone</code> , was bedeutet, dass nach Änderungen <code>NgZone</code> wird.  Wenn wir wollten, hätten wir nicht auf die integrierte Verarbeitung zurückgreifen können, aber der Leistungsgewinn wäre gering und die Aussparungen in der internen „Küche“ von Angular könnten während des Upgrades beschädigt werden.  Daher müssen wir entweder das zusammengesetzte Ereignis abbrechen oder einen Filter verwenden, der dem Grenzoperator ähnlich ist, und den Handler einfach nicht aufrufen, wenn er nicht relevant ist. </p><br><p>  Der Einstieg in die interne Ereignisverarbeitung von Angular ist ein abenteuerliches Unterfangen, da sich die interne Implementierung in Zukunft ändern kann.  Dies verpflichtet uns, die Aktualisierungen zu verfolgen, insbesondere die Aufgabe auf GitHub, die im zweiten Abschnitt des Artikels angegeben ist.  Jetzt können wir die Ausführung von <code>preventDefault</code> bequem filtern und nach Änderungen <code>preventDefault</code> Jetzt haben wir die Möglichkeit, die für die <code>preventDefault</code> <code>stopPropagation</code> Methoden <code>preventDefault</code> und <code>stopPropagation</code> bequem anzuwenden, wenn Sie ein Abonnement deklarieren.  Ab Zukunft wäre es bequemer, Filter für <code>@HostListener</code> direkt neben ihnen mithilfe von Dekoratoren zu deklarieren.  Im nächsten Artikel möchte ich über mehrere Dekorateure sprechen, die wir zu Hause erstellt haben, und versuchen, diese Lösung zu implementieren. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de429692/">https://habr.com/ru/post/de429692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de429682/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 17: Benutzerauthentifizierung, Teil 2</a></li>
<li><a href="../de429684/index.html">Firebase Summit 2018: kurz zur Hauptsache</a></li>
<li><a href="../de429686/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 17: „Benutzerauthentifizierung“, Teil 3</a></li>
<li><a href="../de429688/index.html">Wie man einen Helden erschafft, dem man glauben wird</a></li>
<li><a href="../de429690/index.html">Errorx - Bibliothek zum Arbeiten mit Fehlern in Go</a></li>
<li><a href="../de429694/index.html">Mail.Ru nannte Yandex-Rankings „absurd“ und fordert, seine Marken daraus zu entfernen</a></li>
<li><a href="../de429696/index.html">Videoberichte mit MOSDROID # 13 Aluminium</a></li>
<li><a href="../de429698/index.html">So arbeiten Sie mit Lebedev Studio: Tutu.ru Erfahrung</a></li>
<li><a href="../de429700/index.html">Definition von Zahlen nach Gehör</a></li>
<li><a href="../de429702/index.html">Google Analytics Pixel Sync Facebook, VK, Yandex, MyTarget</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>