<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∑üèø üéÖüèΩ üà¥ Optimierung der Ereignisbehandlung in Angular ü¶É ‚ú® üëã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 


 Angular bietet eine bequeme deklarative M√∂glichkeit, Ereignisse in einer Vorlage mit der Syntax (eventName)="onEventName($event)" zu ab...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimierung der Ereignisbehandlung in Angular</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/429692/"><h1 id="vvedenie">  Einf√ºhrung </h1><br><p> Angular bietet eine bequeme deklarative M√∂glichkeit, Ereignisse in einer Vorlage mit der Syntax <code>(eventName)="onEventName($event)"</code> zu abonnieren.  Zusammen mit der <code>ChangeDetectionStrategy.OnPush</code> √Ñnderungspr√ºfungsrichtlinie startet dieser Ansatz den √Ñnderungspr√ºfungszyklus automatisch nur f√ºr Benutzereingaben, die uns interessieren.  Mit anderen Worten, wenn wir das <code>(input)</code> Ereignis im <code>&lt;input&gt;</code> -Element abh√∂ren, wird die √Ñnderungspr√ºfung nicht ausgel√∂st, wenn der Benutzer einfach auf das Eingabefeld klickt.  Es verbessert sich stark <br>  Leistung im Vergleich zur Standardrichtlinie ( <code>ChangeDetectionStrategy.Default</code> ).  In Direktiven k√∂nnen wir Ereignisse auf dem Host-Element auch √ºber den <code>@HostListener('eventName')</code> . </p><br><p>  In meiner Praxis gibt es h√§ufig F√§lle, in denen die Verarbeitung eines bestimmten Ereignisses nur erforderlich ist, wenn eine Bedingung erf√ºllt ist.  d.h.  Der Handler sieht ungef√§hr so ‚Äã‚Äãaus: </p><a name="habracut"></a><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ComponentWithEventHandler</span></span></span><span class="hljs-class"> { // ... onEvent(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Event</span></span></span><span class="hljs-class">) { if (!</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">condition</span></span></span><span class="hljs-class">) { return; } // </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Handling</span></span></span><span class="hljs-class"> event ... } }</span></span></code> </pre> <br><p>  Selbst wenn die Bedingung nicht erf√ºllt ist und tats√§chlich keine Aktionen ausgef√ºhrt wurden, wird der √Ñnderungs√ºberpr√ºfungszyklus trotzdem gestartet.  Bei h√§ufigen Ereignissen wie <code>mousemove</code> oder <code>mousemove</code> kann dies die Anwendungsleistung beeintr√§chtigen. </p><br><p>  In der Komponenten-UI-Bibliothek, an der ich arbeite, l√∂ste das Abonnieren von <code>mousemove</code> in den Dropdown-Men√ºs eine Nachz√§hlung von √Ñnderungen im gesamten Komponentenbaum f√ºr jede Mausbewegung aus.  Es war notwendig, die Maus zu √ºberwachen, um das richtige Men√ºverhalten zu implementieren, aber es war eindeutig eine Optimierung wert.  Mehr dazu weiter unten. </p><br><p>  Solche Momente sind besonders wichtig f√ºr universelle UI-Elemente.  M√∂glicherweise befinden sich viele davon auf der Seite, und Anwendungen k√∂nnen sehr komplex sein und hohe Anforderungen an die Leistung stellen. </p><br><p>  Sie k√∂nnen die Situation korrigieren, indem Sie Ereignisse unter Umgehung von <code>ngZone</code> , z. B. mit <code>Observable.fromEvent</code> und manuell nach √Ñnderungen <code>ngZone</code> , indem Sie <code>changeDetectorRef.markForCheck()</code> aufrufen.  Dies bringt jedoch eine Menge zus√§tzlicher Arbeit mit sich und macht es unm√∂glich, die praktischen integrierten Winkelwerkzeuge zu verwenden. </p><br><p>  Es ist kein Geheimnis, dass Angular es Ihnen erm√∂glicht, die sogenannten Pseudo-Ereignisse zu abonnieren und genau anzugeben, an welchen Ereignissen wir interessiert sind.  Wir k√∂nnen schreiben <code>(keydown.enter)="onEnter($event)"</code> und der Handler (und damit der √Ñnderungspr√ºfzyklus) wird nur aufgerufen, wenn die <code>Enter</code> gedr√ºckt wird. Die verbleibenden Dr√ºcke werden ignoriert.  In diesem Artikel wird erl√§utert, wie Sie denselben Ansatz wie Angular verwenden k√∂nnen, um die Ereignisbehandlung zu optimieren.  <code>.prevent</code> als <code>.stop</code> <code>.prevent</code> und <code>.stop</code> , die das Standardverhalten aufheben und verhindern, dass das Ereignis automatisch angezeigt wird. </p><br><h1 id="eventmanagerplugin">  EventManagerPlugin </h1><br><div style="text-align:center;"><img width="600" height="600" src="https://habrastorage.org/webt/ss/vr/ls/ssvrlsnebhii2-bcfct4kcmvllu.jpeg"></div><br><p>  Angular verwendet die <code>EventManager</code> Klasse, um Ereignisse zu verarbeiten.  Es verf√ºgt √ºber eine Reihe sogenannter Plugins, die das abstrakte <code>EventManagerPlugin</code> und die Verarbeitung von Ereignisabonnements an das Plugin delegieren, das dieses Ereignis unterst√ºtzt (nach Namen).  In Angular gibt es mehrere Plugins, darunter die HammerJS-Ereignisbehandlung und ein Plugin, das f√ºr zusammengesetzte Ereignisse wie <code>keydown.enter</code> .  Dies ist eine interne Implementierung von Angular, und dieser Ansatz kann sich √§ndern.  Seit der Erstellung des Problems zur Verarbeitung dieser L√∂sung sind jedoch drei Jahre vergangen, und in dieser Richtung wurden keine Fortschritte erzielt: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/angular/angular/issues/3929</a> </p><br><p>  Was ist daran f√ºr uns interessant?  Trotz der Tatsache, dass diese Klassen intern sind und nicht von ihnen geerbt werden k√∂nnen, ist das Token, das f√ºr die Implementierung von Abh√§ngigkeiten f√ºr Plugins verantwortlich ist, √∂ffentlich.  Dies bedeutet, dass wir unsere eigenen Plugins schreiben und den integrierten Ereignisbehandlungsmechanismus damit erweitern k√∂nnen. </p><br><p>  Wenn Sie sich den Quellcode von <code>EventManagerPlugin</code> , werden Sie feststellen, dass wir nicht davon erben k√∂nnen. Er ist gr√∂√ütenteils abstrakt und es ist einfach, eine eigene Klasse zu implementieren, die den Anforderungen entspricht: </p><br><p>  <a href="">https://github.com/angular/angular/blob/master/packages/platform-browser/src/dom/events/event_manager.ts#L92</a> </p><br><p>  Grob gesagt sollte das Plugin in der Lage sein, festzustellen, ob es mit diesem Ereignis arbeitet, und sollte in der Lage sein, einen Ereignishandler und globale Handler (f√ºr <code>body</code> , <code>window</code> und <code>document</code> ) hinzuzuf√ºgen.  Wir werden uns f√ºr die Modifikatoren <code>.filter</code> , <code>.prevent</code> und <code>.stop</code> .  Um sie an unser Plugin zu binden, implementieren wir die erforderlichen Methodenunterst√ºtzungen: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FILTER = <span class="hljs-string"><span class="hljs-string">'.filter'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PREVENT = <span class="hljs-string"><span class="hljs-string">'.prevent'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> STOP = <span class="hljs-string"><span class="hljs-string">'.stop'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">FilteredEventPlugin</span></span> { supports(<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>): boolean { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.includes(FILTER) || <span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.includes(PREVENT) || <span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.includes(STOP) ); } }</code> </pre> <br><p>  <code>EventManager</code> wird also verstehen, dass Ereignisse, in deren Namen bestimmte Modifikatoren vorhanden sind, zur Verarbeitung an unser Plugin √ºbergeben werden m√ºssen.  Dann m√ºssen wir das Hinzuf√ºgen von Ereignishandlern implementieren.  Wir sind nicht an globalen Handlern interessiert, in ihrem Fall ist der Bedarf an solchen Tools viel seltener und die Implementierung w√§re komplizierter.  Daher entfernen wir einfach unsere Modifikatoren aus dem Ereignisnamen und geben sie an den <code>EventManager</code> damit er <code>EventManager</code> richtige integrierte Plug-In f√ºr die Verarbeitung <code>EventManager</code> : </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FilteredEventPlugin</span></span></span><span class="hljs-class"> { supports(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">): boolean { // ... } addGlobalEventListener( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">eventName</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handler</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Function</span></span></span><span class="hljs-class">, ): </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Function</span></span></span><span class="hljs-class"> { const event = eventName .replace(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FILTER</span></span></span><span class="hljs-class">, '') .replace(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PREVENT</span></span></span><span class="hljs-class">, '') .replace(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">STOP</span></span></span><span class="hljs-class">, ''); return this.manager.addGlobalEventListener(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handler</span></span></span><span class="hljs-class">); } }</span></span></code> </pre> <br><p>  Im Falle eines Ereignisses f√ºr ein regul√§res Element m√ºssen wir unsere eigene Logik schreiben.  Zu diesem <code>EventManager</code> wir den Handler in einen Abschluss ein und √ºbergeben das Ereignis ohne unsere Modifikatoren an den <code>EventManager</code> , der au√üerhalb von <code>ngZone</code> , um zu vermeiden, dass der √Ñnderungspr√ºfzyklus <code>ngZone</code> wird: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FilteredEventPlugin</span></span></span><span class="hljs-class"> { supports(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">): boolean { // ... } addEventListener( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HTMLElement</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">eventName</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handler</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Function</span></span></span><span class="hljs-class">, ): </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Function</span></span></span><span class="hljs-class"> { const event = eventName .replace(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FILTER</span></span></span><span class="hljs-class">, '') .replace(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PREVENT</span></span></span><span class="hljs-class">, '') .replace(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">STOP</span></span></span><span class="hljs-class">, ''); //     const filtered = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Event</span></span></span><span class="hljs-class">) =&gt; { // ... }; const wrapper = () =&gt; this.manager.addEventListener(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">filtered</span></span></span><span class="hljs-class">); return this.manager.getZone().runOutsideAngular(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wrapper</span></span></span><span class="hljs-class">); } /* addGlobalEventListener(...): </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Function</span></span></span><span class="hljs-class"> { ... } */ }</span></span></code> </pre> <br><p>  Zu diesem Zeitpunkt haben wir: den Namen des Ereignisses, das Ereignis selbst und das Element, auf das es geh√∂rt wird.  Der Handler, der hierher kommt, ist nicht der diesem Ereignis zugewiesene Quellhandler, sondern das Ende der Schlie√üungskette, die Angular f√ºr seine eigenen Zwecke erstellt hat. </p><br><p>  Eine L√∂sung w√§re, dem Element ein Attribut hinzuzuf√ºgen, das f√ºr den Aufruf des Handlers verantwortlich ist oder nicht.  Manchmal ist es zur Entscheidungsfindung erforderlich, das Ereignis selbst zu analysieren: ob die Standardaktion abgebrochen wurde, welches Element die Quelle des Ereignisses ist usw.  Ein Attribut reicht daf√ºr nicht aus. Wir m√ºssen einen Weg finden, eine Filterfunktion festzulegen, die ein Ereignis empf√§ngt und <code>true</code> oder <code>false</code> zur√ºckgibt.  Dann k√∂nnten wir unseren Handler wie folgt beschreiben: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> filtered = (<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>: Event) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> filter = getOurHandler(some_arguments); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !eventName.includes(FILTER) || !filter || filter(<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>) ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (eventName.includes(PREVENT)) { <span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.preventDefault(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (eventName.includes(STOP)) { <span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.stopPropagation(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.manager.getZone().run(() =&gt; handler(<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>)); } };</code> </pre> <br><h1 id="reshenie">  L√∂sung </h1><br><p>  Die L√∂sung kann ein Singleton-Dienst sein, der die Entsprechung von Elementen zu Ereignis / Filter-Paaren und Hilfsentit√§ten zum Festlegen dieser Entsprechungen speichert.  Nat√ºrlich k√∂nnen auf einem Element mehrere Handler f√ºr dasselbe Ereignis vorhanden sein, aber in der Regel k√∂nnen sowohl <code>@HostListener</code> als auch ein Handler auf dieser Komponente in der Vorlage eine Ebene h√∂her installiert sein.  Wir werden diese Situation vorhersehen, w√§hrend andere F√§lle aufgrund ihrer Spezifit√§t f√ºr uns von geringem Interesse sind. </p><br><p>  Der Hauptdienst ist recht einfach und besteht aus einer Karte und einigen Methoden zum Einstellen, Empfangen und Reinigen von Filtern: </p><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Filter</span></span></span><span class="hljs-class"> = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Event</span></span></span><span class="hljs-class">) =&gt; boolean; export </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Filters</span></span></span><span class="hljs-class"> = {[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">key</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">]: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Filter</span></span></span><span class="hljs-class">}; class </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FilteredEventMainService</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">private</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">elements</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Map</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Element</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Filters</span></span></span><span class="hljs-class">&gt; = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Map</span></span></span><span class="hljs-class">(); </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">register</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Element</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">filters</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Filters</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">elements</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">set</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">filters</span></span></span><span class="hljs-class">); } unregister(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Element</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">elements</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">delete</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class">); } getFilter(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Element</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">): </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Filter</span></span></span><span class="hljs-class"> | null { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">map</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">elements</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class">); </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">map</span></span></span><span class="hljs-class"> ? </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">map</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">] || </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">null</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">null</span></span></span><span class="hljs-class">; } }</span></span></code> </pre> <br><p>  Somit k√∂nnen wir diesen Service im Plugin implementieren und einen Filter erhalten, indem wir das Element und den Namen des Ereignisses √ºbergeben.  F√ºr die Verwendung in Verbindung mit <code>@HostListener</code> f√ºgen wir einen weiteren kleinen Dienst hinzu, der mit der Komponente lebt und die entsprechenden Filter <code>@HostListener</code> wenn sie entfernt wird: </p><br><pre> <code class="hljs kotlin">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventFiltersService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( <span class="hljs-meta"><span class="hljs-meta">@Inject(ElementRef)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> readonly elementRef: ElementRef, <span class="hljs-meta"><span class="hljs-meta">@Inject(FilteredEventMainService)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> readonly mainService: FilteredEventMainService, ) {} ngOnDestroy() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mainService.unregister(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elementRef.nativeElement); } register(filters: Filters) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mainService.register(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elementRef.nativeElement, filters); } }</code> </pre> <br><p>  Um Elemente zu Filtern hinzuzuf√ºgen, k√∂nnen Sie eine √§hnliche Anweisung erstellen: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventFiltersDirective</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Input()</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> eventFilters(filters: Filters) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mainService.register(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elementRef.nativeElement, filters); } <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( <span class="hljs-meta"><span class="hljs-meta">@Inject(ElementRef)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> readonly elementRef: ElementRef, <span class="hljs-meta"><span class="hljs-meta">@Inject(FilteredEventMainService)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> readonly mainService: FilteredEventMainService, ) {} ngOnDestroy() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mainService.unregister(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elementRef.nativeElement); } }</code> </pre> <br><p>  Wenn es einen Dienst zum Filtern von Ereignissen innerhalb der Komponente gibt, k√∂nnen Filter nicht √ºber die Direktive daran geh√§ngt werden.  Am Ende kann dies fast immer durch einfaches Umschlie√üen der Komponente mit dem Element erfolgen, dem unsere Direktive zugewiesen wird.  Um zu verstehen, dass f√ºr dieses Element bereits ein Dienst vorhanden ist, werden wir ihn optional in der Richtlinie implementieren: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EventFiltersDirective</span></span></span><span class="hljs-class"> { // ... constructor( @</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Optional</span></span></span><span class="hljs-class">() @</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Self</span></span></span><span class="hljs-class">() @</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Inject</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FiltersService</span></span></span><span class="hljs-class">) private readonly filtersService: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FiltersService</span></span></span><span class="hljs-class"> | null, ) {} // ... }</span></span></code> </pre> <br><p>  Wenn dieser Dienst vorhanden ist, wird eine Meldung angezeigt, die besagt, dass die Richtlinie nicht auf ihn anwendbar ist: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventFiltersDirective</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Input()</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> eventFilters(filters: Filters) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.eventFiltersService === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { console.warn(ALREADY_APPLIED_MESSAGE); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mainService.register(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elementRef.nativeElement, filters); } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><div style="text-align:center;"><img width="324" height="500" src="https://habrastorage.org/webt/k5/qi/rd/k5qirdkshv3m4cwjfzama7topjm.jpeg"></div><br><h1 id="primenenie-na-praktike">  Praktische Anwendung </h1><br><p>  Alle beschriebenen Codes finden Sie auf Stackblitz: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://stackblitz.com/edit/angular-event-filter</a> </p><br><p>  Als Anwendungsbeispiele wird dort eine imagin√§re <code>select</code> angezeigt - eine Komponente in einem modalen Fenster - und ein Kontextmen√º in der Rolle des Dropdowns.  Wenn Sie im Kontextmen√º eine Implementierung √ºberpr√ºfen, werden Sie feststellen, dass das Verhalten immer das folgende ist: Wenn Sie mit der Maus √ºber ein Element fahren, wird es fokussiert. Wenn Sie die Pfeile auf der Tastatur dr√ºcken, bewegt sich der Fokus durch die Elemente. Wenn Sie jedoch die Maus bewegen, kehrt der Fokus zum Element zur√ºck befindet sich unter dem Mauszeiger.  Es scheint, dass dieses Verhalten einfach zu implementieren ist. Unn√∂tige Reaktionen auf das <code>mousemove</code> k√∂nnen jedoch Dutzende nutzloser √Ñnderungspr√ºfzyklen ausl√∂sen.  Indem Sie als Filter eine Pr√ºfung f√ºr den Fokus des Zielelements des Ereignisses festlegen, k√∂nnen Sie diese unn√∂tigen Ausl√∂sungen abschneiden und nur diejenigen belassen, die wirklich den Fokus tragen. </p><br><div style="text-align:center;"><img width="600" height="325" src="https://habrastorage.org/webt/ha/4m/1r/ha4m1rwr3suhds0xl1cdgbc1lso.gif"></div><br><p>  Diese <code>select</code> <code>@HostListener</code> nach <code>@HostListener</code> Abonnements.  Wenn Sie die <code>Esc</code> im Popup dr√ºcken, sollte es geschlossen werden.  Dies sollte nur geschehen, wenn dieser Klick in einer verschachtelten Komponente nicht erforderlich war und in dieser nicht verarbeitet wurde.  Bei <code>select</code> Dr√ºcken von <code>Esc</code> die Dropdown-Liste geschlossen und der Fokus auf das Feld selbst zur√ºckgesetzt. Wenn es jedoch bereits geschlossen ist, sollte es nicht verhindern, dass das Ereignis auftaucht und das modale Fenster sp√§ter geschlossen wird.  Somit kann die Verarbeitung durch einen Dekorateur beschrieben werden: </p><br><p>  <code>@HostListener('keydown.esc.filtered.stop')</code> beim <code>@HostListener('keydown.esc.filtered.stop')</code> : <code>() =&gt; this.opened</code> . </p><br><p>  Da <code>select</code> eine Komponente mit mehreren fokussierbaren Elementen ist, ist die Verfolgung des allgemeinen Fokus √ºber <code>focusout</code> Popup-Ereignisse m√∂glich.  Sie treten bei allen √Ñnderungen im Fokus auf, einschlie√ülich derer, die die Grenzen der Komponente nicht verlassen.  Dieses Ereignis verf√ºgt √ºber ein verwandtes <code>relatedTarget</code> , das <code>relatedTarget</code> wohin sich der Fokus bewegt.  Nachdem wir es analysiert haben, k√∂nnen wir verstehen, ob wir ein Analogon des <code>blur</code> f√ºr unsere Komponente aufrufen sollen: </p><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SelectComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... @HostListener('focusout.filtered') onBlur() { this.opened = false; } // ... }</span></span></code> </pre> <br><p>  Der Filter sieht gleichzeitig so aus: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> focusOutFilter = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{relatedTarget}: FocusEvent</span></span></span><span class="hljs-function">) =&gt;</span></span> !<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elementRef.nativeElement.contains(relatedTarget);</code> </pre> <br><h1 id="vyvod">  Fazit </h1><br><p>  Leider wird die integrierte Verarbeitung von zusammengesetzten Tastenanschl√§gen in Angular weiterhin in <code>NgZone</code> , was bedeutet, dass nach √Ñnderungen <code>NgZone</code> wird.  Wenn wir wollten, h√§tten wir nicht auf die integrierte Verarbeitung zur√ºckgreifen k√∂nnen, aber der Leistungsgewinn w√§re gering und die Aussparungen in der internen ‚ÄûK√ºche‚Äú von Angular k√∂nnten w√§hrend des Upgrades besch√§digt werden.  Daher m√ºssen wir entweder das zusammengesetzte Ereignis abbrechen oder einen Filter verwenden, der dem Grenzoperator √§hnlich ist, und den Handler einfach nicht aufrufen, wenn er nicht relevant ist. </p><br><p>  Der Einstieg in die interne Ereignisverarbeitung von Angular ist ein abenteuerliches Unterfangen, da sich die interne Implementierung in Zukunft √§ndern kann.  Dies verpflichtet uns, die Aktualisierungen zu verfolgen, insbesondere die Aufgabe auf GitHub, die im zweiten Abschnitt des Artikels angegeben ist.  Jetzt k√∂nnen wir die Ausf√ºhrung von <code>preventDefault</code> bequem filtern und nach √Ñnderungen <code>preventDefault</code> Jetzt haben wir die M√∂glichkeit, die f√ºr die <code>preventDefault</code> <code>stopPropagation</code> Methoden <code>preventDefault</code> und <code>stopPropagation</code> bequem anzuwenden, wenn Sie ein Abonnement deklarieren.  Ab Zukunft w√§re es bequemer, Filter f√ºr <code>@HostListener</code> direkt neben ihnen mithilfe von Dekoratoren zu deklarieren.  Im n√§chsten Artikel m√∂chte ich √ºber mehrere Dekorateure sprechen, die wir zu Hause erstellt haben, und versuchen, diese L√∂sung zu implementieren. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de429692/">https://habr.com/ru/post/de429692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de429682/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 17: Benutzerauthentifizierung, Teil 2</a></li>
<li><a href="../de429684/index.html">Firebase Summit 2018: kurz zur Hauptsache</a></li>
<li><a href="../de429686/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 17: ‚ÄûBenutzerauthentifizierung‚Äú, Teil 3</a></li>
<li><a href="../de429688/index.html">Wie man einen Helden erschafft, dem man glauben wird</a></li>
<li><a href="../de429690/index.html">Errorx - Bibliothek zum Arbeiten mit Fehlern in Go</a></li>
<li><a href="../de429694/index.html">Mail.Ru nannte Yandex-Rankings ‚Äûabsurd‚Äú und fordert, seine Marken daraus zu entfernen</a></li>
<li><a href="../de429696/index.html">Videoberichte mit MOSDROID # 13 Aluminium</a></li>
<li><a href="../de429698/index.html">So arbeiten Sie mit Lebedev Studio: Tutu.ru Erfahrung</a></li>
<li><a href="../de429700/index.html">Definition von Zahlen nach Geh√∂r</a></li>
<li><a href="../de429702/index.html">Google Analytics Pixel Sync Facebook, VK, Yandex, MyTarget</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>