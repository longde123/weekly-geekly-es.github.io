<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🤝‍👨🏼 🚏 👤 كيف أنشأنا مستودعًا سريعًا وموثوقًا لمشاهدات الإعلانات 🧔🏾 🛋️ 🤠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="واحدة من الوظائف غير واضحة ولكنها مهمة لمواقعنا الإعلانية هي حفظ وعرض عدد مرات المشاهدة. تشاهد مواقعنا مرات مشاهدة الإعلانات لأكثر من 10 سنوات. نجح ال...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>كيف أنشأنا مستودعًا سريعًا وموثوقًا لمشاهدات الإعلانات</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/kolesa/blog/431902/" style=";text-align:right;direction:rtl"> واحدة من الوظائف غير واضحة ولكنها مهمة لمواقعنا <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الإعلانية</a> هي حفظ وعرض عدد مرات المشاهدة.  تشاهد مواقعنا مرات مشاهدة الإعلانات لأكثر من 10 سنوات.  نجح التنفيذ التقني للوظيفة في التغيير عدة مرات خلال هذا الوقت ، والآن هي خدمة (micro) قيد التشغيل ، تعمل مع Redis كقائمة انتظار مؤقت ومهمة ، ومع MongoDB كتخزين دائم.  قبل بضع سنوات ، تعلم العمل ليس فقط مع مجموع مرات مشاهدة الإعلانات ، ولكن أيضًا مع إحصائيات كل يوم.  لكنه تعلم أن يفعل كل هذا بسرعة حقا وموثوق بها مؤخرا جدا. <br><br><img src="https://habrastorage.org/webt/ee/nn/jp/eennjposwyrztis3a7s6cbkhq2e.png" alt="الصورة"><br><br>  في المجموع ، تعالج الخدمة حوالي 300 ألف طلب قراءة و 9 آلاف طلب كتابة في الدقيقة ، يتم تنفيذ 99٪ منها حتى 5 مللي ثانية.  هذه ، بالطبع ، ليست مؤشرات فلكية وليست إطلاق صواريخ على سطح المريخ - ولكنها ليست مهمة تافهة مثل التخزين البسيط للأرقام.  اتضح أن القيام بكل هذا ، وضمان تخزين البيانات المفقودة وقراءة القيم المتسقة ذات الصلة ، يتطلب بعض الجهد الذي سنناقشه أدناه. <br><a name="habracut"></a><br><h3 style=";text-align:right;direction:rtl">  مهام المشروع ونظرة عامة </h3><br>  على الرغم من أن عدادات المشاهدة ليست حرجة بالنسبة إلى العمل مثل معالجة المدفوعات أو <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">طلبات الحصول على قرض</a> ، على <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">سبيل</a> المثال ، فهي مهمة في المقام الأول لمستخدمينا.  الناس مفتونون بتتبع شعبية إعلاناتهم: حتى أن البعض يتصل بالدعم عندما يلاحظون معلومات عرض غير دقيقة (حدث هذا مع أحد تطبيقات الخدمة السابقة).  بالإضافة إلى ذلك ، نقوم بتخزين وعرض إحصاءات مفصلة في حسابات المستخدمين الشخصية (على سبيل المثال ، لتقييم فعالية استخدام الخدمات المدفوعة).  كل هذا يجعلنا نحرص على حفظ كل حدث عرض وعرض القيم الأكثر صلة. <br><br>  بشكل عام ، تبدو وظائف ومبادئ المشروع كما يلي: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  تقدم صفحة الويب أو شاشة التطبيق طلبًا خلف عدادات عرض الإعلانات (يكون الطلب عادةً غير متزامن لتحديد أولويات إخراج المعلومات الأساسية).  وإذا تم عرض صفحة الإعلان نفسه ، سيطلب منك العميل بدلاً من ذلك زيادة وإرجاع كمية المشاهدات المحدثة. </li><li style=";text-align:right;direction:rtl">  من خلال معالجة طلبات القراءة ، تحاول الخدمة الحصول على معلومات من ذاكرة التخزين المؤقت لـ Redis ، وتكمل المجهول عن طريق إكمال طلب إلى MongoDB. </li><li style=";text-align:right;direction:rtl">  يتم إرسال طلبات الكتابة إلى بنيتين في الفجل: قائمة انتظار التحديث التزايدي (تتم معالجتها في الخلفية ، بشكل غير متزامن) وذاكرة التخزين المؤقت لإجمالي عدد مرات المشاهدة. </li><li style=";text-align:right;direction:rtl">  تقوم عملية الخلفية في نفس الخدمة بقراءة العناصر من قائمة الانتظار ، وتجميعها في المخزن المؤقت المحلي ، وتكتبها بشكل دوري إلى MongoDB. </li></ul><br><h3 style=";text-align:right;direction:rtl">  سجل عرض عدادات: مطبات </h3><br>  على الرغم من أن الخطوات الموضحة أعلاه تبدو بسيطة جدًا ، إلا أن المشكلة هنا هي تنظيم التفاعل بين قاعدة البيانات ومثيلات الخدمة المصغرة بحيث لا تضيع البيانات ولا تتكرر ولا تتخلف. <br><br>  باستخدام مستودع واحد فقط (على سبيل المثال ، MongoDB فقط) من شأنه أن يحل بعض هذه المشاكل.  في الواقع ، كانت الخدمة تعمل من قبل ، حتى واجهنا مشاكل التوسع والاستقرار والسرعة. <br><br>  قد يؤدي التنفيذ الساذج لنقل البيانات بين المستودعات ، على سبيل المثال ، إلى حدوث مثل هذه الحالات الشاذة: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  فقدان البيانات أثناء الكتابة التنافسية إلى ذاكرة التخزين المؤقت: <br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  تزيد العملية <b>A</b> من عدد المشاهدات في ذاكرة التخزين المؤقت لـ Redis ، لكنها تكتشف أنه لا توجد بيانات لهذا الكيان (يمكن أن تكون إما إعلان جديد أو إعلان قديم تم استخلاصه من ذاكرة التخزين المؤقت) ، لذلك يجب أن تحصل العملية أولاً على هذه القيمة من MongoDB. <br></li><li style=";text-align:right;direction:rtl">  تحصل العملية <b>A</b> على عدد مرات المشاهدة من MongoDB - على سبيل المثال ، الرقم 5 ؛  ثم تضيف 1 إليها وسوف تكتب إلى Redis <b>6</b> . </li><li style=";text-align:right;direction:rtl">  العملية <b>B</b> (التي بدأها ، على سبيل المثال ، مستخدم آخر للموقع قام أيضًا بإدخال نفس الإعلان) تفعل نفس الشيء في نفس الوقت. </li><li style=";text-align:right;direction:rtl">  عملية <b>A</b> يكتب قيمة <b>6</b> إلى Redis. </li><li style=";text-align:right;direction:rtl">  عملية <b>B</b> يكتب قيمة <b>6</b> إلى Redis. </li><li style=";text-align:right;direction:rtl">  نتيجة لذلك ، يتم فقد عرض واحد بسبب السباق عند تسجيل البيانات. <br>  <i>السيناريو ليس مرجحًا جدًا: على سبيل المثال ، لدينا خدمة مدفوعة تضع إعلانًا على الصفحة الرئيسية للموقع.</i>  <i>للحصول على إعلان جديد ، يمكن أن يؤدي مسار الأحداث هذا إلى فقدان العديد من المشاهدات في آن واحد بسبب تدفقها المفاجئ.</i> </li></ol></li><li style=";text-align:right;direction:rtl">  مثال على سيناريو آخر هو فقدان البيانات عند نقل طرق العرض من Redis إلى MongoDb: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  تلتقط العملية قيمة معلقة من Redis وتخزنها في الذاكرة لكتابتها لاحقًا على MongoDB. </li><li style=";text-align:right;direction:rtl">  فشل طلب الكتابة (أو تعطل العملية قبل تنفيذها). </li><li style=";text-align:right;direction:rtl">  يتم فقد البيانات مرة أخرى ، والتي ستصبح واضحة في المرة التالية التي يتم فيها دفع القيمة المخزنة مؤقتًا واستبدالها بالقيمة من قاعدة البيانات. </li></ol><br></li></ul><br>  قد تحدث أخطاء أخرى ، والأسباب التي تكمن أيضا في الطبيعة غير الذرية للعمليات بين قواعد البيانات ، على سبيل المثال ، تعارض أثناء حذف وزيادة وجهات نظر نفس الكيان. <br><br><h3 style=";text-align:right;direction:rtl">  تسجيل عرض التهم: الحل </h3><br>  يعتمد أسلوبنا في تخزين ومعالجة البيانات في هذا المشروع على توقع أنه في أي وقت من الأوقات قد تفشل MongoDB على الأرجح أكثر من Redis.  هذا ، بالطبع ، ليس <i>قاعدة</i> مطلقة - على الأقل ليس لكل مشروع - ولكن في بيئتنا اعتدنا حقًا على مراقبة المهلات الدورية للاستعلامات في MongoDB الناجمة عن أداء عمليات القرص ، والتي كانت في السابق أحد أسباب فقدان بعض الأحداث. <br><br>  لتجنب العديد من المشكلات المذكورة أعلاه ، نستخدم قوائم انتظار المهام من أجل الحفظ المؤجل والبرامج النصية ، والتي تتيح تغيير البيانات تلقائيًا في العديد من هياكل الفجل مرة واحدة.  مع وضع ذلك في الاعتبار ، فإن تفاصيل حفظ المشاهدات هي كما يلي: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  عندما يقع طلب الكتابة في الخدمة المجهرية ، يتم تشغيل البرنامج النصي لوا <b>IncrementIfExists</b> لزيادة العداد فقط إذا كان موجودًا بالفعل في ذاكرة التخزين المؤقت.  يعود البرنامج النصي على الفور <b>-1 في</b> حالة عدم وجود بيانات للكيان الذي يتم عرضه في الفجل ؛  وإلا ، فإنه يزيد من قيمة المشاهدات في ذاكرة التخزين المؤقت عبر <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">HINCRBY</a> ، ويضيف الحدث إلى قائمة الانتظار للتخزين اللاحق في MongoDB (تسمى <i>قائمة الانتظار المعلقة من</i> قبلنا) عبر <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">LPUSH</a> ، ويعيد كمية محدثة من المشاهدات. <br></li><li style=";text-align:right;direction:rtl">  إذا قامت IncrementIfExists بإرجاع رقم موجب ، فسيتم إرجاع هذه القيمة إلى العميل وينتهي الطلب. <br><br>  بخلاف ذلك ، تلتقط الخدمة الميكروية عداد العرض من MongoDb ، وتزيده بمقدار 1 وترسله إلى الفجل. <br></li><li style=";text-align:right;direction:rtl">  تتم الكتابة إلى الفجل من خلال برنامج نصي آخر <b>للغة</b> - <b>Upsert</b> - مما يحفظ إجمالي عدد المشاهدات في ذاكرة التخزين المؤقت إذا كان لا يزال فارغًا ، أو <b>يزيدها</b> بمقدار 1 إذا تمكن شخص آخر من ملء ذاكرة التخزين المؤقت بين الخطوتين 1 و 3. <br></li><li style=";text-align:right;direction:rtl">  يضيف Upsert أيضًا حدث عرض إلى قائمة الانتظار المعلقة ، ويعيد مبلغًا محدثًا ، يتم إرساله بعد ذلك إلى العميل. <br></li></ol><br>  نظرًا لحقيقة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تنفيذ</a> نصوص lua <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تلقائيًا</a> ، فإننا نتجنب العديد من المشكلات المحتملة التي قد تنتج عن الكتابة التنافسية. <br><br>  التفاصيل المهمة الأخرى هي ضمان النقل الآمن للتحديثات من قائمة الانتظار المعلقة إلى MongoDB.  للقيام بذلك ، استخدمنا قالب "قائمة انتظار موثوقة" الموضحة في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">وثائق Redis</a> ، مما يقلل بشكل كبير من فرص فقدان البيانات عن طريق إنشاء نسخة من العناصر التي تمت معالجتها في قائمة انتظار منفصلة أخرى حتى يتم تخزينها أخيرًا في مخزن ثابت. <br><br>  لفهم خطوات العملية بأكملها بشكل أفضل ، قمنا بإعداد تصور صغير.  أولاً ، دعونا نلقي نظرة على سيناريو طبيعي وناجح (يتم ترقيم الخطوات في الركن الأيمن العلوي ووصفها بالتفصيل أدناه): <br><br><img src="https://habrastorage.org/webt/0v/al/bq/0valbqz3kj6du62z0foxfcb6bay.gif" alt="الصورة"><br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  خدمة microservice يتلقى طلب الكتابة </li><li style=";text-align:right;direction:rtl">  يقوم معالج الطلب بتمريره إلى برنامج نصي lua يقوم بكتابة البحث إلى ذاكرة التخزين المؤقت (مما يجعله قابلاً للقراءة على الفور) وإلى قائمة الانتظار لمزيد من المعالجة. </li><li style=";text-align:right;direction:rtl">  يقوم goroutine في الخلفية (بشكل دوري) بتنفيذ عملية <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">BRPopLPush</a> ، التي تنقل عنصرًا من قائمة انتظار إلى أخرى بشكل <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تلقائي</a> (نسميها "قائمة انتظار المعالجة" - قائمة انتظار تحتوي على عناصر تمت معالجتها حاليًا).  ثم يتم تخزين نفس العنصر في مخزن مؤقت في ذاكرة العملية. <br></li><li style=";text-align:right;direction:rtl">  يصل طلب كتابة آخر ويجري معالجته ، مما يتركنا مع عنصرين في المخزن المؤقت وعنصران في قائمة انتظار المعالجة. </li><li style=";text-align:right;direction:rtl">  بعد بعض المهلة ، تقرر عملية الخلفية لمسح المخزن المؤقت في MongoDB.  تتم كتابة قيم متعددة من المخزن المؤقت من خلال طلب واحد ، مما يؤثر بشكل إيجابي على الإنتاجية.  أيضًا ، قبل التسجيل ، تحاول العملية دمج عدة طرق عرض في عرض واحد ، مع تجميع قيمها لنفس الإعلانات. <br>  <i>في كل مشروع من مشاريعنا ، يتم استخدام 3 حالات من خدمات micros ، كل منها به مخزن مؤقت خاص به ، يتم حفظه في قاعدة البيانات كل ثانيتين.</i>  <i>خلال هذا الوقت ، يتم تجميع حوالي 100 عنصر في مخزن مؤقت واحد.</i> <i><br></i> </li><li style=";text-align:right;direction:rtl">  بعد الكتابة الناجحة ، تزيل العملية العناصر من قائمة انتظار المعالجة ، مما يشير إلى أن المعالجة اكتملت بنجاح. <br></li></ol><br>  عندما تكون جميع النظم الفرعية سليمة ، قد تبدو بعض هذه الخطوات زائدة عن الحاجة.  وقد يكون للقارئ المهتم أيضًا سؤال حول ما يفعله غوفر في الركن الأيسر السفلي. <br>  يتم شرح كل شيء عند النظر في السيناريو عندما يكون MongoDB غير متوفر: <br><br><img src="https://habrastorage.org/webt/hl/jd/bs/hljdbsmwzxn6i2k5xfgj2mm02em.gif" alt="مثال على الخدمة عند تعطل MongoDB"><br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  الخطوة الأولى مماثلة للأحداث من السيناريو السابق: تتلقى الخدمة طلبين لتسجيل المشاهدات ومعالجتها. <br></li><li style=";text-align:right;direction:rtl">  العملية تفقد الاتصال بـ MongoDB (العملية نفسها ، بالطبع ، لا تعرف ذلك بعد). <br>  يحاول معالج Gorutin ، كما كان من قبل ، تدفق المخزن المؤقت الخاص به إلى قاعدة البيانات - ولكن هذه المرة دون نجاح.  تعود إلى انتظار التكرار التالي. <br></li><li style=";text-align:right;direction:rtl">  تستيقظ goroutine خلفية أخرى وتتحقق من قائمة انتظار المعالجة.  تكتشف أن العناصر أضيفت إليها منذ زمن طويل ؛  خلصت إلى أن فشل معالجتها ، فإنها تعيدهم إلى قائمة الانتظار المعلقة. <br></li><li style=";text-align:right;direction:rtl">  بعد فترة من الوقت ، تتم استعادة الاتصال مع MongoDB. <br></li><li style=";text-align:right;direction:rtl">  يحاول goroutine الخلفية الأولى مرة أخرى إجراء عملية كتابة - هذه المرة بنجاح - وفي النهاية يزيل العناصر نهائيًا من قائمة انتظار المعالجة. <br></li></ol><br>  في هذا المخطط ، هناك العديد من المهلات الهامة والاستدلال المستمدة من الاختبار والحس السليم: على سبيل المثال ، يتم نقل العناصر من قائمة انتظار المعالجة إلى قائمة الانتظار المعلقة بعد 15 دقيقة من عدم النشاط.  بالإضافة إلى ذلك ، يقوم goroutine المسؤول عن هذه المهمة بإجراء <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">قفل</a> قبل التنفيذ بحيث لا تحاول عدة مثيلات من الخدمة المجهرية استعادة طرق العرض "المجمدة" في نفس الوقت. <br><br>  بالمعنى الدقيق للكلمة ، حتى هذه التدابير لا توفر ضمانات مدعومة من الناحية النظرية (على سبيل المثال ، نحن نتجاهل سيناريوهات مثل العملية تتجمد لمدة 15 دقيقة) - لكنها في الواقع تعمل بشكل موثوق. <br><br>  أيضًا في هذا المخطط ، يوجد على الأقل 2 من نقاط الضعف المعروفة لنا والتي يجب أن تكون على دراية بها: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  إذا تعطلت خدمة microservice مباشرة بعد الحفظ بنجاح إلى MongoDb ، ولكن قبل مسح قائمة انتظار المعالجة ، سيتم اعتبار هذه البيانات غير محفوظة - وبعد 15 دقيقة سيتم حفظها مرة أخرى. <br>  <i>لتقليل احتمالية حدوث مثل هذا السيناريو ، قدمنا ​​محاولات متكررة للإزالة من قائمة انتظار المعالجة في حالة وجود أخطاء.</i>  <i>في الواقع ، لم نلاحظ بعد مثل هذه الحالات في الإنتاج.</i> <br></li><li style=";text-align:right;direction:rtl">  عند إعادة التشغيل ، قد يفقد الفجل ليس فقط ذاكرة التخزين المؤقت ، ولكن أيضًا بعض المشاهدات غير المحفوظة من قوائم الانتظار ، حيث يتم تكوينه لحفظ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">لقطات RDB</a> بشكل دوري كل بضع دقائق. <br>  <i>على الرغم من أن هذا من الناحية النظرية يمكن أن يكون مشكلة خطيرة (خاصة إذا كان المشروع يتعامل مع بيانات مهمة بالفعل) ، نادراً ما يتم إعادة تشغيل العقد في الممارسة.</i>  <i>في الوقت نفسه ، وفقًا للرصد ، تنفق العناصر في قوائم الانتظار لمدة تقل عن 3 ثوانٍ ، أي أن مقدار الخسائر المحتمل محدود للغاية.</i> <br></li></ul><br>  قد يبدو أن هناك مشاكل أكثر مما نود.  ومع ذلك ، في الواقع ، اتضح أن السيناريو الذي دافعنا عنه في البداية - فشل MongoDB - هو بالفعل تهديد حقيقي أكثر ، وأن مخطط معالجة البيانات الجديد يضمن بنجاح توفر الخدمة ويمنع الخسائر. <br><br>  كان أحد الأمثلة الحية على ذلك عندما كانت نسخة MongoDB في أحد المشاريع غير متاحة بشكل سخيف طوال الليل.  طوال هذا الوقت ، قم بمشاهدة التعدادات المتراكمة وتدويرها في الفجل من قائمة انتظار إلى أخرى ، حتى يتم حفظها في نهاية المطاف في قاعدة البيانات بعد حل الحادث ؛  معظم المستخدمين لم يلاحظوا حتى الفشل. <br><br><h3 style=";text-align:right;direction:rtl">  قراءة عرض التهم </h3><br>  تكون طلبات القراءة أبسط بكثير من طلبات الكتابة: تقوم الخدمة الميكروية أولاً بفحص ذاكرة التخزين المؤقت في الفجل ؛  يتم تعبئة كل ما لم يتم العثور عليه في ذاكرة التخزين المؤقت ببيانات من MongoDb وإعادته إلى العميل. <br><br>  لا توجد الكتابة من البداية إلى النهاية إلى ذاكرة التخزين المؤقت أثناء عمليات القراءة لتجنب الحمل من الحماية ضد عمليات الكتابة التنافسية.  بقيت ذاكرة التخزين المؤقت جيدة ، حيث أنه في أكثر الأحيان ، سيتم تسخينها بالفعل بفضل طلبات الكتابة الأخرى. <br><br>  تتم قراءة إحصائيات العرض اليومي مباشرةً من MongoDB ، حيث يتم طلبها كثيرًا كثيرًا ، وتخزينها أكثر صعوبة.  يعني أيضًا أنه عندما تكون قاعدة البيانات غير متوفرة ، تتوقف قراءة الإحصائيات عن العمل ؛  لكنه يؤثر فقط على جزء صغير من المستخدمين. <br><br><h3 style=";text-align:right;direction:rtl">  نظام تخزين البيانات MongoDB </h3><br>  يعتمد نظام تجميع MongoDB للمشروع على <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هذه التوصيات من مطوري قاعدة البيانات أنفسهم</a> ، ويبدو كما يلي: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يتم حفظ المشاهدات في مجموعتين: واحدة في مجموع المبلغ الإجمالي ، في المجموعة الأخرى - إحصاءات يوما بعد يوم. <br></li><li style=";text-align:right;direction:rtl">  يتم تنظيم البيانات في مجموعة الإحصائيات على أساس <b>وثيقة واحدة لكل إعلان شهريًا</b> .  بالنسبة للإعلانات الجديدة ، يتم إدراج مستند مملوء بواحد وثلاثين صفر للشهر الحالي في المجموعة ؛  وفقًا للمقال المذكور أعلاه ، يتيح لك هذا على الفور تخصيص مساحة كافية لمستند على القرص حتى لا تضطر قاعدة البيانات إلى نقله عند إضافة البيانات. <br>  <i>يجعل هذا العنصر عملية قراءة الإحصائيات صعبة بعض الشيء (يجب إنشاء الطلبات بشهور على الجانب المصغر من الخدمات) ، ولكن بشكل عام ، يظل المخطط بديهيًا للغاية.</i> <br></li><li style=";text-align:right;direction:rtl">  <b>تُستخدم</b> عملية <b>المغالاة</b> في التسجيل ، من أجل التحديث ، وإذا لزم الأمر ، إنشاء مستند للكيان المطلوب في نفس الطلب. <br></li></ul><br>  لا نستخدم إمكانيات المعاملات الخاصة بـ MongoDb لتحديث عدة مجموعات في نفس الوقت ، مما يعني أننا نجازف بإمكانية كتابة البيانات في مجموعة واحدة فقط.  في الوقت الحاضر ، نحن ببساطة تسجيل الدخول في مثل هذه الحالات ؛  هناك عدد قليل منهم ، وحتى الآن لا يمثل هذا نفس المشكلة المهمة مثل السيناريوهات الأخرى. <br><br><h3 style=";text-align:right;direction:rtl">  اختبار </h3><br>  لن أثق في كلماتي بأن السيناريوهات الموصوفة تعمل حقًا إذا لم تكن مغطاة بالاختبارات. <br><br>  نظرًا لأن معظم رمز المشروع يعمل عن كثب مع الفجل و MongoDb ، فإن معظم الاختبارات الموجودة فيه عبارة عن اختبارات تكامل.  يتم دعم بيئة الاختبار من خلال docker-compose ، مما يعني أنه يمكن نشرها بسرعة ، ويوفر إمكانية التكاثر عن طريق إعادة ضبط واستعادة الحالة في كل بداية ، ويجعل من الممكن التجربة دون التأثير على قواعد بيانات الآخرين. <br><br>  في هذا المشروع ، هناك ثلاثة مجالات رئيسية للاختبار: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  التحقق من صحة منطق الأعمال في السيناريوهات النموذجية ، ما يسمى  طريق سعيد.  تجيب هذه الاختبارات على السؤال - عندما تكون جميع الأنظمة الفرعية في حالة جيدة ، هل تعمل الخدمة وفقًا للمتطلبات الوظيفية؟ </li><li style=";text-align:right;direction:rtl">  التحقق من السيناريوهات السلبية التي من المتوقع أن تستمر الخدمة في عملها.  على سبيل المثال ، هل الخدمة لا تفقد البيانات عند تعطل MongoDb؟ <br>  هل نحن متأكدون من أن المعلومات تظل متسقة مع المهلات الدورية وعمليات التجميد التنافسية؟ </li><li style=";text-align:right;direction:rtl">  التحقق من السيناريوهات السلبية التي لا نتوقع استمرار الخدمة فيها ، ولكن يجب توفير الحد الأدنى من الوظائف.  على سبيل المثال ، لا توجد فرصة لاستمرار الخدمة في حفظ البيانات وإعطاءها في حالة عدم توفر الفجل أو المونغو - لكننا نريد أن نتأكد من أنه في مثل هذه الحالات لا تتعطل ، ولكن يتوقع استرداد النظام ثم العودة إلى العمل. </li></ol><br>  للتحقق من السيناريوهات غير الناجحة ، يعمل كود منطق أعمال الخدمة مع واجهات عميل قاعدة البيانات ، والتي يتم استبدالها في الاختبارات الضرورية بالتطبيقات التي تعرض الأخطاء و / أو تحاكي تأخيرات الشبكة.  نحن نحاكي أيضًا التشغيل المتوازي للعديد من مثيلات الخدمة باستخدام نمط " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">كائن البيئة</a> ".  هذا هو البديل لنهج "التحكم الانعكاس" المعروف ، حيث لا تصل الدوال إلى التبعيات نفسها ، ولكنها تستقبلها من خلال كائن البيئة الذي تم تمريره في الوسائط.  من بين المزايا الأخرى ، يتيح لك هذا النهج محاكاة عدة نسخ مستقلة من الخدمة في اختبار واحد ، لكل منها مجموعة خاصة بها من الاتصالات بقاعدة البيانات وتنتج بيئة الإنتاج بشكل أكثر أو أقل كفاءة.  تعمل بعض الاختبارات على كل حالة من هذه الحالات بشكل متوازٍ وتأكد من أنها جميعًا ترى نفس البيانات ، ولا توجد شروط سباق. <br><br>  لقد أجرينا أيضًا اختبار إجهاد بدائي ، لكن لا يزال مفيدًا جدًا بناءً على <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الحصار</a> ، مما ساعد تقريبًا على تقدير الحمل المسموح به وسرعة الاستجابة من الخدمة. <br><br><h3 style=";text-align:right;direction:rtl">  عن الأداء </h3><br>  بالنسبة إلى 90٪ من الطلبات ، يكون وقت المعالجة صغيرًا جدًا ، والأهم من ذلك - الاستقرار ؛  فيما يلي مثال للقياسات في أحد المشاريع على مدار عدة أيام: <br><br><img src="https://habrastorage.org/webt/ln/bk/zy/lnbkzy7-wnykbaelv4vzsd8b53q.png" alt="الصورة"><br><br>  ومن المثير للاهتمام ، أن السجل (والذي هو في الواقع عملية كتابة + قراءة ، لأنه يُرجع قيمًا محدثة) أسرع قليلاً من القراءة (ولكن فقط من وجهة نظر العميل الذي لا يلاحظ الكتابة الفعلية المعلقة). <br>  الزيادة الصباحية المنتظمة في التأخيرات هي أحد الآثار الجانبية لعمل فريق التحليلات لدينا ، الذي يجمع إحصائياته الخاصة يوميًا استنادًا إلى بيانات الخدمة ، مما يخلق "حملاً ثقيلًا اصطناعيًا" لنا. <br><br>      :           (          —          MongoDB),       (      ),     : <br><br><img src="https://habrastorage.org/webt/6f/pz/v9/6fpzv9b8lmswdsjhmrn4gk_qugw.png" alt="الصورة"><br><br><h3 style=";text-align:right;direction:rtl">  الخاتمة </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لقد أظهرت الممارسة ، إلى حد ما بطريقة عكسية ، أن استخدام Redis كمستودع رئيسي لخدمة المشاهدة أدى إلى زيادة الاستقرار العام وتحسين سرعته الإجمالية. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الحمل الرئيسي للخدمة هو قراءة الطلبات ، والتي يتم إرجاع 95٪ منها من ذاكرة التخزين المؤقت ، وبالتالي تعمل بسرعة كبيرة. يتم تأخير طلبات التسجيل ، على الرغم من أنها من وجهة نظر المستخدم النهائي تعمل أيضًا بسرعة وتصبح مرئية لجميع العملاء على الفور. بشكل عام ، يتلقى جميع العملاء تقريبًا ردودًا في أقل من 5 مللي ثانية.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ونتيجة لذلك ، فإن الإصدار الحالي من الخدمة المصغرة المستندة إلى Go و Redis و MongoDB يعمل بنجاح تحت الحمل وقادر على التغلب على عدم التوافر الدوري لأحد متاجر البيانات. </font><font style="vertical-align: inherit;">استنادًا إلى خبرتنا السابقة في مشاكل البنية الأساسية ، حددنا سيناريوهات الخطأ الرئيسية ودافعنا عنها بنجاح ، حتى لا يعاني معظم المستخدمين من الإزعاج. </font><font style="vertical-align: inherit;">ونحن بدورنا نتلقى عددًا أقل بكثير من الشكاوى والتنبيهات والرسائل في السجلات - ونحن مستعدون لزيادة الحركة.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar431902/">https://habr.com/ru/post/ar431902/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar431888/index.html">"أعتقد أن أفكار الفريق هي الأكثر أهمية عند تطوير المنتج."</a></li>
<li><a href="../ar431890/index.html">كيفية وضع النظام على التبادل الحر</a></li>
<li><a href="../ar431892/index.html">نحن نستخدم Veeam Backup & Replication لاختبار الأنظمة والتطبيقات الجديدة قبل الترقية</a></li>
<li><a href="../ar431894/index.html">في ديسمبر ، سيقررون التسجيل الإلزامي لمحطات LPWAN الأساسية</a></li>
<li><a href="../ar431898/index.html">كل شيء عن رشيق - 2: ميزات التنفيذ رشيق</a></li>
<li><a href="../ar431904/index.html">كيف قمنا بإلغاء تحميل اختصاصيي الموارد البشرية: معلومات لإصدار كشوف الدفع</a></li>
<li><a href="../ar431906/index.html">PIFR - طريقة لتوليد قناع ثلاثي الأبعاد ، بغض النظر عن زاوية دوران الوجه</a></li>
<li><a href="../ar431908/index.html">إعداد API Tinkoff Bank. كيف هو الحدس الخاص بك ....؟ أو أغنية عن Oauth 2.0</a></li>
<li><a href="../ar431910/index.html">PSEFABRIC - نهج جديد لإدارة الشبكات والأتمتة. خطوة إلى المثالي</a></li>
<li><a href="../ar431912/index.html">تم القبض على أكبر روبوت في الولايات المتحدة الأمريكية: ماذا يعني هذا بالنسبة للمجتمع الرقمي؟</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>