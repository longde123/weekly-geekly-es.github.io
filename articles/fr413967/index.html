<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>➰ 👼🏽 🔓 Rétro-ingénierie du mode développeur Animal Crossing 👩🏼‍🎓 🎌 👍🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'été dernier, j'ai commencé le reverse engineering Animal Crossing pour le GameCube. Je voulais explorer la possibilité de créer des mods pour ce jeu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rétro-ingénierie du mode développeur Animal Crossing</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413967/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4d/fe4/7f0/b4dfe47f0139ba1af039decfb6274524.jpg" alt="Utiliser le code sur un vrai GameCube"></div><br>  L'été dernier, j'ai commencé le reverse engineering Animal Crossing pour le GameCube.  Je voulais explorer la possibilité de créer des mods pour ce jeu.  De plus, je voulais documenter le processus de création de didacticiels pour les personnes intéressées par le piratage des ROM et le reverse engineering.  Dans cet article, je parlerai des fonctionnalités de débogage des développeurs qui sont restées dans le jeu, et partagerai également comment j'ai découvert des combinaisons de triche qui peuvent être utilisées pour les déverrouiller. <br><a name="habracut"></a><br><h3>  new_Debug_mode </h3><br>  En étudiant les symboles de débogage restants, j'ai remarqué les noms des fonctions et des variables contenant le mot «débogage», et j'ai décidé qu'il serait intéressant de voir s'il restait une fonctionnalité de débogage dans le jeu.  Si j'arrive à activer les fonctions de débogage ou de développement, cela m'aidera à créer des mods. <br><br>  La première fonction que j'ai remarquée était <code>new_Debug_mode</code> .  Il est appelé par la fonction d' <code>entry</code> , qui démarre immédiatement après la fin de l'écran du logo Nintendo.  Elle ne fait que placer la structure d'octets <code>0x1C94</code> et y enregistrer un pointeur. <br><br>  Après avoir été appelé en <code>entry</code> dans la structure hébergée à l'offset <code>0xD4</code> immédiatement avant d'appeler <code>mainproc</code> valeur 0 est définie. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63e/fbc/0af/63efbc0af9ebfb4eeb2c3b42feddcbed.png"></div><br>  Pour voir ce qui se passe lorsque la valeur n'est pas nulle, j'ai corrigé l'instruction <code>li r0, 0</code> à <code>80407C8C</code> , en la remplaçant par <code>li r0, 1</code> .  Les octets bruts de l'instruction <code>li r0, 0</code> sont <code>38 00 00 00</code> où la valeur assignée est à la fin de l'instruction, donc je pourrais simplement remplacer les octets par <code>38 00 00 01</code> et obtenir <code>li r0, 1</code> .  Pour créer des instructions de manière plus fiable, vous pouvez utiliser quelque chose comme <code>kstool</code> : <br><br> <code>$ kstool ppc32be "li 0, 1" <br> li 0, 1 = [ 38 00 00 01 ]</code> <br> <br>  Dans l'émulateur Dolphin, ce patch peut être appliqué en allant dans l'onglet "Patches" dans les propriétés du jeu et en le saisissant comme suit: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e65/ecb/706/e65ecb7061c9470c9a9b71c4aad8e506.png"></div><br>  Après avoir attribué la valeur 1, un graphique intéressant est apparu en bas de l'écran: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be5/cab/e1f/be5cabe1fe1df63d0534c092d49ca8f9.png"></div><br><br>  Cela ressemblait à un indicateur de performance: les petites barres en bas de l'écran ont augmenté ou diminué.  (Plus tard, lorsque j'ai regardé les noms des fonctions qui dessinent ce graphique, j'ai constaté qu'elles affichent en fait des mesures d'utilisation du processeur et de la mémoire.) <br><br>  C'était super, mais pas particulièrement utile.  Après avoir attribué la valeur 1, ma ville a cessé de se charger, donc rien d'autre n'a pu être fait ici. <br><br><h3>  Mode Zuru </h3><br>  J'ai recommencé à chercher d'autres références aux fonctions de débogage, et plusieurs fois j'ai rencontré quelque chose appelé «mode zuru».  Les branches de blocs de code avec fonctionnalité de débogage vérifiaient souvent la variable <code>zurumode_flag</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/88e/4d4/63c/88e4d463c3ea3474d3b67e2cf8367ee2.png" alt="Fonction game_move_first"></div><br>  <code>zzz_LotsOfDebug</code> (le nom que j'ai trouvé moi-même) dans la fonction <code>game_move_first</code> montrée ci-dessus est appelé uniquement lorsque <code>zurumode_flag</code> pas égal à zéro. <br><br>  À la recherche de fonctions associées à cette valeur, j'ai trouvé celles-ci: <br><br><ul><li> <code>zurumode_init</code> </li> <li> <code>zurumode_callback</code> </li> <li> <code>zurumode_update</code> </li> <li> <code>zurumode_cleanup</code> </li> </ul><br>  À première vue, leur objectif est mystérieux, ils jonglent avec des bits dans les décalages d'une variable appelée <code>osAppNMIBuffer</code> . <br><br>  Voici à quoi ressemble le travail de ces fonctions à première vue: <br><br><h4>  zurumode_init </h4><br><ul><li>  Définit <code>zurumode_flag</code> à 0 </li><li>  Vérifie plusieurs bits dans <code>osAppNMIBuffer</code> </li><li>  Enregistre un pointeur sur la fonction <code>zurumode_callback</code> dans la structure <code>padmgr</code> </li><li>  Appelle <code>zurumode_update</code> </li></ul><br><h4>  zurumode_update </h4><br><ul><li>  Vérifie plusieurs bits dans <code>osAppNMIBuffer</code> </li><li>  En fonction de la valeur de ces bits, <code>zurumode_flag</code> met à jour </li><li>  Imprime une chaîne de format sur la console du système d'exploitation. </li></ul><br>  Ceci est généralement utile pour donner du contexte au code, mais il y avait beaucoup de caractères non imprimables dans la ligne.  Le seul texte reconnaissable était «zurumode_flag» et «% d». <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/268/f99/093/268f99093e0f9dec2a19bfc22be95ac7.png" alt="chaîne de formatage en mode zuru"></div><br>  En supposant qu'il pourrait s'agir d'un texte japonais avec un codage de caractères multi-octets, j'ai passé la chaîne via l'outil de reconnaissance de codage et j'ai découvert que la chaîne était codée avec Shift-JIS.  En traduction, la ligne signifiait simplement "La valeur de zurumode_flag est passée de% d à% d".  Cela ne nous donne pas beaucoup de nouvelles informations, mais maintenant nous savons que Shift-JIS est utilisé: dans les fichiers binaires et les tables de lignes, il y a beaucoup plus de lignes dans cet encodage. <br><br><h4>  zurumode_callback </h4><br><ul><li>  Appelle <code>zerumode_check_keycheck</code> </li><li>  Vérifie plusieurs bits dans <code>osAppNMIBuffer</code> </li><li>  La valeur <code>zurumode_flag</code> </li><li>  Appelle <code>zurumode_update</code> </li></ul><br>  <code>zerumode_check_keycheck</code> jusqu'à ce que nous nous rencontrions à cause d'une orthographe différente ... qu'est-ce que c'est? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/49e/ca7/1fd/49eca71fdd3cefb01b01c578a93bbe72.png" alt="zerumode_check_keycheck"></div><br>  Une énorme fonction complexe qui fait beaucoup plus de travail sur les bits avec des valeurs sans nom. <br><br>  À ce stade, j'ai décidé de prendre du recul et d'étudier d'autres fonctions et variables de débogage, car je n'étais pas sûr de l'importance du mode zuru.  De plus, je n'ai pas compris ce que signifie «vérification des clés» ici.  Est-il possible qu'il s'agisse d'une clé cryptographique? <br><br><h3>  Retour au débogage </h3><br>  À cette époque, j'ai remarqué un problème avec ma façon de charger les symboles de débogage dans l'IDA.  Le fichier <code>foresta.map</code> sur le disque du jeu contient de nombreuses adresses et noms de fonctions et de variables.  Au début, je n'ai pas vu que les adresses de chaque section recommencent à zéro, j'ai donc écrit un script simple qui ajoute une entrée de nom pour chaque ligne du fichier. <br><br>  J'ai écrit de nouveaux scripts IDA pour corriger le chargement des tables de symboles pour différentes sections du programme: <code>.text</code> , <code>.rodata</code> , <code>.data</code> et <code>.bss</code> .  La section <code>.text</code> contient toutes les fonctions, donc je l'ai fait pour que cette fois, lorsque je définirai le nom, le script reconnaîtra automatiquement les fonctions à chaque adresse. <br><br>  Dans les sections de données, il a maintenant créé un segment pour chaque objet binaire (par exemple, <code>m_debug.o</code> , qui était censé être du code compilé pour quelque chose appelé <code>m_debug</code> ), et a défini l'espace et les noms pour chaque élément de données. <br><br>  Cela m'a donné beaucoup plus d'informations, mais j'ai dû définir manuellement le type de données pour chaque élément de données, car j'ai défini chaque objet de données comme un tableau d'octets simple.  (Avec le recul, je comprends qu'il serait préférable de supposer que des fragments de 4 octets contenaient des entiers 32 bits, car il y en avait beaucoup et beaucoup contenaient des adresses de fonctions et de données importantes pour la construction de références croisées.) <br><br>  En étudiant le nouveau segment <code>.bss</code> pour <code>m_debug_mode.o</code> , j'ai trouvé plusieurs variables de la forme <code>quest_draw_status</code> et <code>event_status</code> .  C'est intéressant car je voulais que des informations utiles, pas seulement un graphique de performances, soient affichées en mode débogage.  Heureusement, à partir de ces enregistrements de données, il y avait des références croisées à un énorme morceau de code vérifiant <code>debug_print_flg</code> . <br><br>  À l'aide d'un débogueur dans l'émulateur Dolphin, j'ai défini un point d'arrêt à l'emplacement de la fonction où <code>debug_print_flg</code> vérifié (à <code>8039816C</code> ) pour comprendre comment cette vérification fonctionne.  Mais le programme n'est jamais passé à ce point d'arrêt. <br><br>  Voyons pourquoi cela se produit: cette fonction est appelée par <code>game_debug_draw_last</code> .  Devinez quelle valeur est vérifiée avant son appel conditionnel?  <code>zurumode_flag</code> !  Que diable se passe-t-il? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/257/048/964/257048964f9e8265670952e66868fc83.png" alt="vérification zurumode_flag"></div><br>  J'ai défini un point d'arrêt sur ce chèque ( <code>80404E18</code> ) et cela a fonctionné tout de suite.  La valeur de <code>zurumode_flag</code> était nulle, donc en exécution normale, le programme aurait manqué l'appel à cette fonction.  J'ai inséré une instruction de branche NOP à la place (remplacée par une instruction qui ne fait rien) pour vérifier ce qui se passe lorsque la fonction est appelée. <br><br>  Dans le débogueur Dolphin, cela peut être fait en interrompant le jeu, en cliquant avec le bouton droit sur les instructions et en sélectionnant «Insérer nop»: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e6/f00/8d1/2e6f008d1dcf1be707b1961e05df2e71.png" alt="Débogueur Dolphin Nopping"></div><br>  Il ne s'est rien passé.  Ensuite, j'ai vérifié ce qui se passait à l'intérieur de la fonction et découvert une autre construction de branchement qui a contourné tout ce qui était intéressant à <code>803981a8</code> .  J'ai également inséré NOP à la place, et la lettre "D" est apparue dans le coin supérieur droit de l'écran. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a18/9a0/816/a189a0816b08438ad5b85c09adaac57c.png" alt="Lettre de mode de débogage D"></div><br>  Dans cette fonction à <code>8039816C</code> (je l'ai appelée <code>zzz_DebugDrawPrint</code> ), il y a encore un tas de code intéressant, mais il n'est pas appelé.  Si vous regardez cette fonction sous la forme d'un graphique, vous pouvez voir qu'il existe une série d'opérateurs de branchement qui ignorent les blocs de code dans la fonction: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/236/131/4bb/2361314bbb4165b8e1c82386e8c50533.png" alt="Branches dans zzz_DebugDrawPrint"></div><br>  Après avoir inséré NOP au lieu de plusieurs autres constructions de ramification, j'ai commencé à voir diverses choses intéressantes à l'écran: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0db/c19/008/0dbc1900844131d0c3d7f507f2b61b63.png" alt="Plus de trucs de débogage imprimés"></div><br>  La question suivante était de savoir comment activer cette fonctionnalité de débogage sans modifier le code. <br><br>  En outre, dans certaines constructions de branche, <code>zurumode_flag</code> se produit à nouveau dans cette fonction de dessin de débogage.  J'ai ajouté un autre patch afin que dans <code>zurumode_update</code> drapeau <code>zurumode_update</code> <code>zurumode_flag</code> toujours attribuer la valeur 2, car lorsqu'il ne se compare pas à 0, il est comparé spécifiquement à la valeur 2. <br><br>  Après avoir redémarré le jeu, j'ai vu dans le coin supérieur droit de l'écran un tel message "msg.  non. " <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97d/16e/a0b/97d16ea0b169c72dd86ab623e0e3f977.png" alt="affichage du numéro de message"></div><br>  Le nombre 687 est l'identifiant d'enregistrement du dernier message affiché.  Je l'ai vérifié en utilisant le programme de visualisation de table que j'ai écrit au tout début de l'analyse, mais vous pouvez également le vérifier en utilisant l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">éditeur de table de chaînes avec une interface graphique complète</a> , que j'ai écrite pour pirater les ROM.  Voici à quoi ressemble le message dans l'éditeur: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cad/e3f/378/cade3f3785a86e9bf335a144fe16a338.png" alt="Message 687 dans l'éditeur de table de chaînes"></div><br>  À ce stade, il est devenu clair que l'étude du mode zuru n'était plus supprimée - elle est directement liée aux fonctions de débogage du jeu. <br><br><h3>  Retour au mode Zuru à nouveau </h3><br>  <code>zurumode_init</code> initialise plusieurs choses: <br><br><ul><li>  <code>0xC(padmgr_class)</code> reçoit la valeur de l'adresse <code>zurumode_callback</code> </li><li>  <code>0x10(padmgr_class)</code> reçoit la valeur d'adresse de <code>padmgr_class</code> elle-même </li><li>  <code>0x4(zuruKeyCheck)</code> reçoit la valeur du dernier bit du mot chargé à partir de <code>0x3C(osAppNMIBuffer)</code> . </li></ul><br>  J'ai compris ce qu'est <code>padmgr</code> , une abréviation de «gamepad manager».  Cela signifie qu'il peut y avoir une combinaison spéciale de touches (boutons) qui peuvent être saisies sur la manette de jeu pour activer le mode zuru, ou une sorte de dispositif de débogage ou une fonction de la console du développeur qui peut être utilisée pour envoyer un signal pour l'activer. <br><br>  <code>zurumode_init</code> n'est exécuté que lors du premier chargement du jeu (lorsque le bouton de réinitialisation est enfoncé, cela ne fonctionne pas). <br><br>  Après avoir défini un point d'arrêt à l'adresse <code>8040efa4</code> , auquel la valeur <code>0x4(zuruKeyCheck)</code> est attribuée <code>0x4(zuruKeyCheck)</code> , nous pouvons voir que lors du chargement sans appuyer sur les touches, la valeur est définie sur 0. Si vous le remplacez par 1, une chose intéressante se produit: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9dc/5f5/0fb/9dc5f50fbd68beb624745d0704a18383.png" alt="Écran de titre avec le mode zuru"></div><br>  La lettre "D" apparaît à nouveau dans le coin supérieur droit (cette fois est verte, pas jaune), et certaines informations d'assemblage sont également affichées: <br><br> <code>[CopyDate: 02/08/01 00:16:48 ] <br> [Date: 02-07-31 12:52:00] <br> [Creator:SRD@SRD036J]</code> <br> <br>  Un patch qui définit toujours <code>0x4(zuruKeyCheck)</code> à 1 au début ressemble à ceci: <br><br> <code>8040ef9c 38c00001</code> <br> <br>  Cela semble être la bonne façon d'initialiser le mode zuru.  Après cela, diverses actions peuvent être nécessaires pour obtenir l'affichage de certaines informations de débogage.  En commençant le jeu, en vous promenant dessus et en parlant à un villageois, nous ne verrons aucun des messages mentionnés ci-dessus (à l'exception de la lettre "D" dans le coin). <br><br>  Les suspects les plus probables sont <code>zurumode_update</code> et <code>zurumode_callback</code> . <br><br><h4>  zurumode_update </h4><br>  <code>zurumode_update</code> abord appelé dans <code>zurumode_init</code> puis constamment appelé par <code>zurumode_callback</code> . <br><br>  Il vérifie à nouveau le dernier bit <code>0x3C(osAppNMIBuffer)</code> puis, en fonction de cette valeur, met à jour <code>zurumode_flag</code> . <br><br>  Si le bit est nul, le drapeau est mis à zéro. <br><br>  Sinon, l'instruction suivante est exécutée, la valeur complète <code>0x3c(osAppNMIBuffer)</code> étant <code>r5</code> : <br><br> <code>extrwi r3, r5, 1, 28</code> <br> <br>  Il extrait le 28e bit de <code>r5</code> et le stocke dans <code>r3</code> . <br><br>  Ensuite, 1 est ajouté au résultat, c'est-à-dire que le résultat final est toujours 1 ou 2. <br><br>  Ensuite, <code>zurumode_flag</code> comparé au résultat précédent, en fonction du nombre de 28e et dernier bits définis sur <code>0x3c(osAppNMIBuffer)</code> : 0, 1 ou 2. <br><br>  Cette valeur est écrite dans <code>zurumode_flag</code> .  Si cela ne change rien, la fonction se ferme et renvoie la valeur d'indicateur actuelle.  S'il modifie la valeur, une chaîne de blocs de code beaucoup plus complexe est exécutée. <br><br>  Un message s'affiche en japonais: la même «valeur zurumode_flag est passée de% d à% d», dont nous avons parlé plus haut. <br><br>  Ensuite, une série de fonctions est appelée avec différents arguments, selon que le drapeau est devenu égal à zéro ou non.  Le code assembleur de cette partie est monotone, je vais donc montrer son pseudocode: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flag_changed_to_zero) { JC_JUTAssertion_changeDevice(<span class="hljs-number"><span class="hljs-number">2</span></span>) JC_JUTDbPrint_setVisible(JC_JUTDbPrint_getManager(), <span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (BIT(nmiBuffer, <span class="hljs-number"><span class="hljs-number">25</span></span>) || BIT(nmiBuffer, <span class="hljs-number"><span class="hljs-number">31</span></span>)) { JC_JUTAssertion_changeDevice(<span class="hljs-number"><span class="hljs-number">3</span></span>) JC_JUTDbPrint_setVisible(JC_JUTDbPrint_getManager(), <span class="hljs-number"><span class="hljs-number">1</span></span>) }</code> </pre> <br>  Notez que si l'indicateur est nul, l'argument 0 est passé à JC_JUTDbPrint_setVisible. <br><br>  Si l'indicateur n'est pas égal à zéro et que le bit 25 ou le bit 31 sont définis sur <code>0x3C(osAppNMIBuffer)</code> , <code>setVisible</code> argument 1. <br><br>  Il s'agit de la première clé pour activer le mode zuru: le dernier bit <code>0x3C(osAppNMIBuffer)</code> doit être défini sur 1 pour afficher les informations de débogage et définir <code>zurumode_flag</code> valeur non nulle. <br><br><h4>  zurumode_callback </h4><br>  <code>zurumode_callback</code> est situé au <code>8040ee74</code> et est probablement appelé par une fonction liée à la manette de jeu.  Après avoir inséré un point d'arrêt dans le débogueur Dolphin, la pile d'appels nous montre qu'il est réellement appelé à partir de <code>padmgr_HandleRetraceMsg</code> . <br><br>  L'une de ses premières actions a été d'exécuter <code>zerucheck_key_check</code> .  Cette fonction est complexe, mais il semble qu'en général elle est conçue pour lire et mettre à jour la valeur de <code>zuruKeyCheck</code> .  Avant de passer à la fonction de vérification des touches, j'ai décidé de vérifier comment cette valeur est utilisée dans le reste de la fonction de rappel. <br><br>  Ensuite, il vérifie à nouveau pour certains bits dans <code>0x3c(osAppNMIBuffer)</code> .  Si le bit 26 est défini, ou si le bit 25 est défini et que <code>padmgr_isConnectedController(1)</code> renvoie une valeur différente de zéro, le dernier bit de <code>0x3c(osAppNMIBuffer)</code> sur 1! <br><br>  Si aucun de ces bits n'est défini, ou que le bit 25 est défini, mais que <code>padmgr_isConnectedController(1)</code> renvoie 0, la fonction vérifie si l'octet à l'adresse <code>0x4(zuruKeyCheck)</code> est égal à zéro.  S'il est égal, il réinitialise le dernier bit de la valeur d'origine et le <code>0x3c(osAppNMIBuffer)</code> sur <code>0x3c(osAppNMIBuffer)</code> .  Sinon, il définit toujours le dernier bit sur 1. <br><br>  En pseudo code, cela ressemble à ceci: <br><br><pre> <code class="cpp hljs">x = osAppNMIBuffer[<span class="hljs-number"><span class="hljs-number">0x3c</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (BIT(x, <span class="hljs-number"><span class="hljs-number">26</span></span>) || (BIT(x, <span class="hljs-number"><span class="hljs-number">25</span></span>) &amp;&amp; isConnectedController(<span class="hljs-number"><span class="hljs-number">1</span></span>)) || zuruKeyCheck[<span class="hljs-number"><span class="hljs-number">4</span></span>] != <span class="hljs-number"><span class="hljs-number">0</span></span>) { osAppNMIBuffer[<span class="hljs-number"><span class="hljs-number">0x3c</span></span>] = x | <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">// set last bit } else { osAppNMIBuffer[0x3c] = x &amp; ~1 // clear last bit }</span></span></code> </pre> <br>  Après cela, si le bit 26 n'est pas défini, la fonction passe à l'appel de <code>zurumode_update</code> , puis se <code>zurumode_update</code> . <br><br>  Si le bit est défini, alors si <code>0x4(zuruKeyCheck)</code> pas égal à zéro, alors il charge une chaîne de format dans laquelle il affiche ce qui suit: "ZURU% d /% d". <br><br><h4>  Pour résumer le sous-total </h4><br>  Voici ce qui se passe: <br><br>  <code>padmgr_HandleRetraceMsg</code> appelle <code>zurumode_callback</code> .  Je suppose que ce «message de retour de poignée» signifie qu'il scanne simplement les frappes du contrôleur.  À chaque analyse, il peut provoquer une série de rappels différents. <br><br>  Lorsque <code>zurumode_callback</code> exécuté <code>zurumode_callback</code> il vérifie les frappes (boutons) en cours.  Il semble qu'elle vérifie un bouton spécifique ou une combinaison de boutons. <br><br>  Le dernier bit du tampon NMI est mis à jour en fonction des bits spécifiques de sa valeur actuelle, ainsi que de la valeur de l'un des octets <code>zuruKeyCheck</code> ( <code>0x4(zuruKeyCheck)</code> ). <br><br>  Ensuite, <code>zurumode_update</code> est <code>zurumode_update</code> et vérifie ce bit.  S'il est égal à 0, alors l'indicateur de mode zuru est mis à 0. S'il est égal à 1, alors l'indicateur de mode passe à 1 ou 2, selon que le bit 28 est activé. <br><br>  <strong>Il existe trois façons d'activer le mode zuru:</strong> <br><br><ol><li>  Le bit 26 est défini sur <code>0x3C(osAppNMIBuffer)</code> </li><li>  Le bit 25 est défini sur <code>0x3C(osAppNMIBuffer)</code> et le contrôleur est connecté au port 2 </li><li>  <code>0x4(zuruKeyCheck)</code> pas nul </li></ol><br><h4>  osAppNMIBuffer </h4><br>  Intéressé par ce <code>osAppNMIBuffer</code> signifie <code>osAppNMIBuffer</code> , j'ai commencé à chercher «NMI» et j'ai trouvé des liens dans le contexte Nintendo vers «interruption non masquable».  Il s'avère que le nom de cette variable est entièrement mentionné dans la documentation développeur de Nintendo 64: <br><br><blockquote>  osAppNMIBuffer est un tampon de 64 octets qui est effacé lors d'un redémarrage à froid.  Si le système redémarre en raison de NMI, l'état de ce tampon ne change pas. </blockquote><br>  En fait, il s'agit d'un petit morceau de mémoire enregistré lors d'un redémarrage «doux» (avec le bouton de réinitialisation).  Le jeu peut utiliser ce tampon pour stocker toutes les données pendant que la console est sur le réseau.  L'original Animal Crossing est sorti sur Nintendo 64, il est donc logique que quelque chose de similaire ait dû apparaître dans le code. <br><br>  Si nous allons dans le fichier <code>boot.dol</code> binaire (tout ce qui est montré ci-dessus était dans <code>foresta.rel</code> ), alors sa fonction <code>main</code> a beaucoup de liens vers <code>osAppNMIBuffer</code> .  Un rapide coup d'œil montre qu'il existe une série de vérifications qui peuvent conduire à <code>0x3c(osAppNMIBuffer)</code> valeurs de différents bits <code>0x3c(osAppNMIBuffer)</code> aide d'opérations OR. <br><br>  Les valeurs d'opérande OR suivantes peuvent être intéressantes: <br><br><ul><li>  Bit 31: 0x01 </li><li>  Bit 30: 0x02 </li><li>  Bit 29: 0x04 </li><li>  Bit 28: 0x08 </li><li>  Bit 27: 0x10 </li><li>  Bit 26: 0x20 </li></ul><br>  Nous nous souvenons que les bits 25, 26 et 28 sont particulièrement intéressants: 25 et 26 déterminent si le mode zuru est activé et le bit 28 détermine le niveau du drapeau (1 ou 2). <br>  Le bit 31 est également intéressant, mais il semble qu'il change en fonction des valeurs des autres. <br><br><h5>  Bit 26 </h5><br>  Tout d'abord: à l'adresse <code>800062e0</code> il y a une instruction <code>ori r0, r0, 0x20</code> avec une valeur tampon de <code>0x3c</code> .  Il active le bit 26, qui active toujours le mode zuru. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5c/b3c/207/b5cb3c207a61dc20dd12e6724f25099b.png" alt="Règlement du bit 26"></div><br>  Pour que le bit soit défini, le huitième octet renvoyé par <code>DVDGetCurrentDiskID</code> doit être <code>0x99</code> .  Cet identifiant est situé au tout début de l'image disque du jeu et est chargé en mémoire à <code>80000000</code> .  Dans une version commerciale régulière du jeu, l'ID ressemble à ceci: <br><br> <code>47 41 46 45 30 31 00 00 GAFE01..</code> <br> <br>  En remplaçant le dernier octet de l'identifiant par un <code>0x99</code> pour <code>0x99</code> , nous obtenons l'image suivante au démarrage du jeu: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da6/c58/c90/da6c58c90515fefb62ed8cf766ad8776.png" alt="ID de version du jeu 0x99"></div><br>  Et ce qui suit s'affiche dans la console du système d'exploitation: <br><br> <code>06:43:404 HW\EXI_DeviceIPL.cpp:339 N[OSREPORT]: ZURUMODE2 ENABLE <br> 08:00:288 HW\EXI_DeviceIPL.cpp:339 N[OSREPORT]: osAppNMIBuffer[15]=0x00000078</code> <br> <br>  Tous les autres correctifs peuvent être supprimés, après quoi la lettre D apparaît à nouveau dans le coin supérieur droit de l'écran, mais aucun message de débogage n'est activé. <br><br><h5>  Bit 25 </h5><br>  Le bit 25 est utilisé conjointement avec la vérification du port du contrôleur 2. Qu'est-ce qui le fait s'allumer? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddf/d00/4a1/ddfd004a1488ec21842c90581ef177fc.png" alt="Bit 25 et 28"></div><br>  Il s'avère qu'il doit utiliser le même contrôle que pour le bit 28: la version doit être supérieure ou égale à <code>0x90</code> .  Si le bit 26 est défini (l'ID est <code>0x99</code> ), ces deux bits seront également définis et le mode zuru sera toujours activé. <br><br>  Cependant, si la version est comprise entre <code>0x90</code> et <code>0x98</code> , le mode zuru ne s'active pas instantanément.  Rappelez la vérification effectuée dans <code>zurumode_callback</code> - le mode ne sera activé que si le bit 25 est défini <em>et</em> <code>padmgr_isConnectedController(1)</code> renvoie une valeur différente de zéro. <br><br>  Une fois que le contrôleur est connecté au port 2 (l'argument <code>isConnectedController</code> a zéro indexation), le mode zuru est activé.  La lettre D et les informations sur l'assemblage apparaissent sur l'écran initial, et nous ... pouvons contrôler l'affichage du débogage à l'aide des boutons du deuxième contrôleur! <br><br>  Certains boutons effectuent des actions qui non seulement modifient l'affichage, mais aussi, par exemple, augmentent la vitesse du jeu. <br><br><h4>  zerucheck_key_check </h4><br>  Le dernier mystère reste <code>0x4(zuruKeyCheck)</code> .  Il s'avère que cette valeur est mise à jour avec une énorme fonction complexe que j'ai montrée ci-dessus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/49e/ca7/1fd/49eca71fdd3cefb01b01c578a93bbe72.png" alt="zerumode_check_keycheck"></div><br>  En utilisant le débogueur d'émulateur Dolphin, j'ai pu déterminer que la valeur vérifiée par cette fonction est un ensemble de bits correspondant aux pressions de bouton sur le deuxième contrôleur. <br><br>  Le suivi des clics sur les boutons est stocké dans une valeur de 16 bits à <code>0x2(zuruKeyCheck)</code> .  Lorsque le contrôleur n'est pas connecté, la valeur est <code>0x7638</code> . <br><br>  2 octets contenant les drapeaux des pressions des boutons du contrôleur sont téléchargés puis mis à jour au début de <code>zerucheck_key_check</code> .  La nouvelle valeur est transmise avec le registre <code>r4</code> fonction <code>padmgr_HandleRetraceMsg</code> lorsqu'elle appelle la fonction de rappel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f98/478/318/f984783181e592098f8beef9c22cef23.png" alt="fin de la vérification des clés"></div><br>  Vers la fin de <code>zerucheck_key_check</code> il y a un autre endroit où <code>0x4(zuruKeyCheck)</code> mis à jour <code>0x4(zuruKeyCheck)</code> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il n'apparaissait pas dans la liste de références croisées car il l'utilisait comme adresse de base </font></font><code>r3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et nous ne pouvons connaître la valeur </font></font><code>r3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qu'en regardant la valeur qui lui est affectée avant d'appeler cette fonction. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À l'adresse, la </font></font><code>8040ed88</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valeur est </font></font><code>r4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">écrite </font></font><code>0x4(zuruKeyCheck)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Juste avant cela, mais il est écrit du même endroit, puis XOR à partir de 1. La tâche de cette opération est de basculer la valeur d'octet (en fait le dernier bit) entre 0 et 1. (Si la valeur est 0, le résultat de </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XOR à partir de 1 sera 1 . Si la valeur est 1, le résultat sera 0. Voir la table de vérité pour XOR.)</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/048/c32/eb1/048c32eb12dda64c878fa7b9f0bd7ddc.png" alt="fin de la vérification des clés"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plus tôt, lorsque j'ai étudié les valeurs en mémoire, je n'ai pas remarqué ce comportement, mais je vais essayer de casser cette instruction dans le débogueur pour comprendre ce qui se passe. La valeur d'origine est chargée à </font></font><code>8040ed7c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sans toucher aux boutons du contrôleur, je ne parviendrai pas à ce point d'arrêt sur l'écran initial. Pour entrer dans ce bloc de code, la valeur </font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit devenir égale </font></font><code>0xb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avant l'instruction de branchement qui précède le point d'arrêt ( </font></font><code>8040ed74</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Parmi les nombreux chemins différents menant à ce bloc, un seul attribue une </font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valeur </font></font><code>0xb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devant lui à l'adresse </font></font><code>8040ed68</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04c/926/959/04c926959999b5f6facfc8920f6a212f.png" alt="Définition de r5 sur 0xb"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notez que pour atteindre le bloc affectant la </font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valeur </font></font><code>0xB</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la valeur </font></font><code>r0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit être égale </font><font style="vertical-align: inherit;">juste avant </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En suivant les blocs de la chaîne jusqu'au début de la fonction, nous pouvons voir toutes les restrictions nécessaires pour réaliser ce bloc:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8040ed74: la valeur </font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit être égale</font></font><code>0xB</code> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8040ed60: la valeur </font></font><code>r0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit être égale</font></font><code>0x1000</code> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8040ebe8: la valeur </font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit être égale</font></font><code>0xA</code> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8040ebe4: la valeur </font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit être inférieure</font></font><code>0x5B</code> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8040eba4: la valeur </font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit être supérieure</font></font><code>0x7</code> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8040eb94: la valeur </font></font><code>r6</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit être 1</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8040eb5c: la valeur </font></font><code>r0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne doit pas être 0</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8040eb74: les valeurs du bouton du port 2 doivent changer </font></font></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28e/2fa/9f3/28e2fa9f3d35b1c6146f816120dee72b.png" alt="Traçage du chemin du code"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, nous avons atteint le point où les anciennes valeurs de bouton sont chargées et les nouvelles valeurs sont enregistrées. Viennent ensuite quelques opérations appliquées aux nouvelles et anciennes valeurs: </font><font style="vertical-align: inherit;">L'opération XOR marque tous les bits qui ont changé entre les deux valeurs. Ensuite, l'opération ET masque la nouvelle entrée pour définir tous les bits qui ne sont pas actuellement définis sur l'état 0. Le résultat en </font><font style="vertical-align: inherit;">est un ensemble de nouveaux bits (pressions de bouton) dans la nouvelle valeur. S'il n'est pas vide, nous sommes sur la bonne voie. </font><font style="vertical-align: inherit;">Pour faire </font><font style="vertical-align: inherit;">une différence </font><font style="vertical-align: inherit;">, le quatrième des boutons de suivi 16 bits doit changer. Après avoir inséré un point d'arrêt après l'opération XOR / AND, j'ai découvert que le bouton START déclenche cet état. </font><font style="vertical-align: inherit;">La question suivante est de savoir comment le rendre </font><font style="vertical-align: inherit;">initialement égal</font></font><br><br> <code>old_vals = old_vals XOR new_vals <br> old_vals = old_vals AND new_vals</code> <br> <br><font style="vertical-align: inherit;"></font><code>r0</code><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><code>r0</code><font style="vertical-align: inherit;"></font><code>0x1000</code><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><code>r5</code><font style="vertical-align: inherit;"></font><code>0xA</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>r6</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sont chargés depuis </font></font><code>0x0(zuruKeyCheck)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le début de la fonction de test clé et mis à jour plus près de la fin, lorsque nous n'entrons pas dans le bloc de code qui comprend </font></font><code>0x4(zuruKeyCheck)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a plusieurs endroits avant cela où la </font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valeur est affectée </font></font><code>0xA</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><ul><li> <code>8040ed50</code> </li> <li> <code>8040ed00</code> </li> <li> <code>8040ed38</code> </li> </ul><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8040ed38 </font></font></h5><br><ul><li> <code>8040ed34</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: la valeur </font></font><code>r0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit être égale </font></font><code>0x4000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(le bouton B </font><font style="vertical-align: inherit;">est </font><font style="vertical-align: inherit;">enfoncé)</font></font></li><li> <code>8040ebe0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: la valeur </font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit être égale</font></font><code>0x5b</code> </li><li> <code>8040eba4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: la valeur </font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit être supérieure</font></font><code>0x7</code> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> alors tout se passe comme avant ... </font></font></li></ul><br> <code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> devrait commencer par </font></font><code>0x5b</code> <br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8040ed00 </font></font></h5><br><ul><li> <code>8040ecfc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: la valeur </font></font><code>r0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit être égale </font></font><code>0xC000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(A et B sont pressés)</font></font></li><li> <code>8040ebf8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: la valeur </font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit être&gt; = 9</font></font></li><li> <code>8040ebf0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: la valeur </font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit être inférieure à 10</font></font></li><li> <code>8040ebe4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: la valeur </font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit être inférieure</font></font><code>0x5b</code> </li><li> <code>8040eba4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devrait être plus</font></font><code>0x7</code> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> alors tout se passe comme avant ... </font></font></li></ul><br> <code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> devrait commencer à 9 </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8040ed50 </font></font></h5><br><ul><li> <code>8040ed4c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: la valeur </font></font><code>r0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit être égale </font></font><code>0x8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(bouton A enfoncé)</font></font></li><li> <code>8040ec04</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: la valeur </font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit être inférieure</font></font><code>0x5d</code> </li><li> <code>8040ebe4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: la valeur </font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit être supérieure</font></font><code>0x5b</code> </li><li> <code>8040eba4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: la valeur </font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit être supérieure</font></font><code>0x7</code> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> alors tout se passe comme avant ... </font></font></li></ul><br> <code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devrait commencer par </font></font><code>0x5c</code> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il semble qu'il y ait une sorte d'état entre les frappes, après quoi vous devez entrer une certaine séquence de combos à partir des boutons, en terminant par une pression sur START. </font><font style="vertical-align: inherit;">Il semble que A et / ou B devraient aller juste avant START. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous tracez le chemin du code qui définit la </font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valeur à 9, alors un modèle apparaît: </font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- c'est une valeur croissante qui peut soit augmenter lorsqu'une </font></font><code>r0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valeur appropriée est trouvée, soit zéro. </font><font style="vertical-align: inherit;">Les cas les plus étranges lorsque ce n'est pas une valeur dans la plage de </font></font><code>0x0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à</font></font><code>0xB</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, se produisent lors du traitement d'étapes avec plusieurs boutons, par exemple, lorsque A et B sont enfoncés simultanément. Une personne qui essaie d'entrer dans ce combo ne peut généralement pas appuyer sur les deux boutons exactement en même temps tout en suivant la manette de jeu, vous devez donc traiter le bouton sur lequel vous appuyez. premier. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous continuons d'explorer différents chemins de code:</font></font><br><br><ul><li> <code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prend la valeur 9 lorsque vous appuyez sur DROITE à l'adresse </font></font><code>8040ece8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li><li> <code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prend la valeur 8 lorsque le bouton droit C à l'adresse est enfoncé </font></font><code>8040eccc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li><li> <code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prend la valeur 7 lorsque le bouton gauche C est pressé à l'adresse </font></font><code>8040ecb0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li><li> <code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prend la valeur 6 lorsque GAUCHE est pressé à l'adresse </font></font><code>8040ec98</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li><li> <code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prend la valeur 5 (et r6 prend la valeur 1) lorsque BAS est pressé à l'adresse </font></font><code>8040ec7c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li><li> <code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prend la valeur 4 lorsque le bouton supérieur C à l'adresse est enfoncé </font></font><code>8040ec64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li><li> <code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prend la valeur 3 lorsque le bouton inférieur C à l'adresse est enfoncé </font></font><code>8040ec48</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li><li> <code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prend la valeur 2 lorsque vous appuyez sur UP à l'adresse </font></font><code>8040ec30</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li><li> <code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prend la valeur 1 (et </font></font><code>r6</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prend la valeur 1) lorsque Z est pressé à l'adresse </font></font><code>8040ec1c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La séquence actuelle est: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z, UP, C-DOWN, C-UP, DOWN, LEFT, C-LEFT, C-RIGHT, RIGHT, A + B, START </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant de vérifier Z, une autre condition est vérifiée: bien qu'un nouveau bouton doive être enfoncé Z, les drapeaux actuels doivent être égaux </font></font><code>0x2030</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: les pare-chocs gauche et droit doivent également être enfoncés (ils ont les valeurs de </font></font><code>0x10</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>0x20</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">De plus, UP / DOWN / LEFT / RIGHT sont des boutons D-pad, pas un stick analogique.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code de triche </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le combo complet ressemble à ceci: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tenez les pare-chocs L + R et appuyez sur Z </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D-up </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C-DOWN </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C-up </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D-down </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D-gauche </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C-gauche </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C-DROIT </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D-DROIT </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A + B </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> COMMENCER </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ça marche! </font><font style="vertical-align: inherit;">Connectez le contrôleur au deuxième port et entrez le code, après quoi les informations de débogage apparaissent. </font><font style="vertical-align: inherit;">Après cela, vous pouvez commencer à appuyer sur les boutons du deuxième (voire du troisième) contrôleur pour effectuer diverses actions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce combo fonctionnera sans patcher le numéro de version du jeu. </font><font style="vertical-align: inherit;">Il peut même être utilisé dans une copie régulière du jeu au détail sans outils de triche ou mods de console. </font><font style="vertical-align: inherit;">Une nouvelle saisie des combos désactive le mode zuru.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4d/fe4/7f0/b4dfe47f0139ba1af039decfb6274524.jpg" alt="Utiliser le code sur un vrai GameCube"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le message "ZURU% d /% d" est </font></font><code>zurumode_callback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilisé pour afficher l'état de cette combinaison si vous le saisissez lorsque l'ID de disque est déjà égal </font></font><code>0x99</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(probablement pour déboguer le code de triche lui-même). Le premier nombre correspond à votre position actuelle dans la séquence correspondante </font></font><code>r5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Le second prend la valeur 1, lorsque certains boutons de la séquence sont maintenus, ils peuvent correspondre au moment où la </font></font><code>r6</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valeur est affectée 1. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La plupart des messages n'expliquent pas ce qu'ils font à l'écran, donc pour comprendre leur fonction, vous devez trouver des fonctions qui les traitent. Par exemple, une longue ligne d'étoiles bleues et rouges en haut de l'écran sont des espaces réservés pour afficher l'état de diverses quêtes. Lorsque la quête est active, certains numéros y apparaissent, indiquant l'état de la quête.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'écran noir affiché en appuyant sur Z est une console pour afficher les messages de débogage, en particulier pour les aspects de bas niveau, tels que l'allocation de mémoire, les erreurs de tas et autres mauvaises exceptions. Par comportement, </font></font><code>fault_callback_scroll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on peut supposer qu'il est utilisé pour afficher ces erreurs avant le redémarrage du système. Il ne lance aucune de ces erreurs, mais peut les amener à imprimer quelques caractères parasites avec plusieurs NOP. Je pense qu'à l'avenir, il sera très utile pour afficher vos propres messages de débogage:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b06/755/a33/b06755a33e0b0b8b010b7cbff7a26594.png" alt="JUTConsole ordures caractères"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après avoir fait tout cela, j'ai découvert que passer en mode débogage en corrigeant l'ID de </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">version </font><font style="vertical-align: inherit;">est </font></font><code>0x99</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">déjà connu des autres: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://tcrf.net/Animal_Crossing#Debug_Mode</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">(Il y a aussi de bonnes notes sur le lien qui indiquent divers messages et parlent d'autres choses qui peuvent être faites avec le contrôleur dans le port 3.) Cependant, pour autant que je sache, personne n'a encore publié la combinaison de triche.</font></font><br><br>  C’est tout.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Il y a d'autres fonctionnalités pour les développeurs que j'aimerais explorer, comme l'écran de débogage de la carte et l'écran de sélection de l'émulateur NES, et comment les activer sans utiliser de correctifs. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/258/eb3/445/258eb3445236357c201c343d6c8ae4ba.png" alt="Écran de sélection de carte"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> De plus, je publierai des articles sur la rétro-ingénierie des systèmes de dialogue, des événements et des quêtes dans le but de créer des mods. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr413967/">https://habr.com/ru/post/fr413967/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr413955/index.html">Cycle de développement complet du dispositif IoT pour le contrôle du chauffage de piscine sur l'ESP8266 dans un environnement Arduino</a></li>
<li><a href="../fr413957/index.html">Un exemple de création d'une application sportive en temps réel sur Node.js</a></li>
<li><a href="../fr413959/index.html">Plus petite image Docker - moins de 1 000 octets</a></li>
<li><a href="../fr413963/index.html">Mini CRM pour les petites entreprises</a></li>
<li><a href="../fr413965/index.html">Revue de code: vous vous trompez</a></li>
<li><a href="../fr413969/index.html">Technopark Russky - développement innovant de milliards de dollars</a></li>
<li><a href="../fr413971/index.html">Plus de 10 médias d'information en anglais pour les apprenants de langues</a></li>
<li><a href="../fr413973/index.html">Évaluation de Cavium ThunderX2: le rêve du serveur Arm se réalise (partie 2)</a></li>
<li><a href="../fr413977/index.html">Création d'un système de protection antivirus étendu pour une petite entreprise. 3e partie</a></li>
<li><a href="../fr413979/index.html">Mitap "Comment gérer des guildes et des communautés?" de Tutu.ru et AgileVerse</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>