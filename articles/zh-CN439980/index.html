<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🔬 🦁 🧘🏼 学习Docker，第3部分：Dockerfile文件 👩🏿‍🚒 🎢 💇🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在Docker系列第三部分的翻译中，我们将继续受到糕点（即百吉饼）的启发。 今天我们的主要主题是使用Dockerfiles。 我们将分析这些文件中使用的说明。 

 → 第1部分：基础知识 
 → 第2部分：术语和概念 
 → 第3部分：Dockerfile文件 
 → 第4部分：缩小图像尺寸并加快...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>学习Docker，第3部分：Dockerfile文件</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/439980/"> 在Docker系列第三部分的翻译中，我们将继续受到糕点（即百吉饼）的启发。 今天我们的主要主题是使用Dockerfiles。 我们将分析这些文件中使用的说明。 <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1部分：基础知识</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2部分：术语和概念</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第3部分：Dockerfile文件</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第4部分：缩小图像尺寸并加快其组装速度</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第5部分：团队</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第6部分：处理数据</a> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/29b/15a/6bf/29b15a6bfff06c617017301b30ed95c2.jpg"></div><br>  <i><font color="#999999">百吉饼是Dockerfile中的指令。</font></i> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Docker映像</font> </h2><br> 回想一下，Docker容器是栩栩如生的Docker映像。 这是一个独立的操作系统，其中只有最必要的应用程序代码。 <br><br>  Docker映像是构建过程的结果，而Docker容器正在运行映像。  Docker的核心是Dockerfiles。 这样的文件告诉Docker如何组装从中创建容器的映像。 <br><br> 每个Docker映像都有一个名为Dockerfile的文件。 他的名字是这样写的-无需扩展名。 当您运行<code>docker build</code>创建新映像时，假定Dockerfile位于当前工作目录中。 如果此文件位于其他位置，则可以使用<code>-f</code>标志指定其位置。 <br><br> 正如我们在本系列的第一种材料中发现的那样，容器由层组成。 除最后一层外，其他各层中的每一层都是只读的。  Dockerfile告诉Docker系统将哪些层以及添加到映像的顺序。 <br><br> 实际上，每一层只是一个文件，它描述了图像状态与添加前一层后的状态相比所发生的变化。 顺便说一下，在Unix上，几乎所有东西都是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文件</a> 。 <br><br> 基本图像是要创建的图像的源层。 基本图像也称为父图像。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a0/b89/6aa/6a0b896aa35c1f735103ae8924d5371d.jpg"></div><br>  <i><font color="#999999">基本映像是Docker映像的开始位置。</font></i> <br><br> 将映像从远程存储库下载到本地计算机时，仅物理下载该计算机上不可用的图层。  Docker旨在通过重用现有层来节省空间和时间。 <br><br><h2>  <font color="#3AC1EF">Dockerfile文件</font> </h2><br>  Dockerfile包含用于创建映像的说明。 该文件的行以大写字母开头。 遵循指示是他们的论点。 建立图像时，说明从上到下进行处理。 看起来是这样的： <br><br><pre> <code class="plaintext hljs">FROM ubuntu:18.04 COPY . /app</code> </pre> <br> 最终图像中的图层仅由<code>FROM</code> ， <code>RUN</code> ， <code>COPY</code>和<code>ADD</code>指令创建。 其他指令设置，描述元数据或告诉Docker您需要在容器执行期间执行某些操作，例如，打开某些端口或运行某些命令。 <br><br> 在这里，我们假设使用基于Unix操作系统的Docker镜像。 当然，在这里您也可以使用基于Windows的映像，但是使用Windows是一种较不常见的做法，使用此类映像更加困难。 因此，如果有机会，请使用Unix。 <br><br> 首先，这里是Dockerfile指令列表和简短注释。 <br><br><h2>  <font color="#3AC1EF">十二个Dockerfile指令</font> </h2><br><ol><li>  <code>FROM</code>设置基本（父）图像。 </li><li>  <code>LABEL</code> -描述元数据。 例如，有关谁创建和维护图像的信息。 </li><li>  <code>ENV</code>设置持久性环境变量。 </li><li>  <code>RUN</code>执行命令并创建图像层。 用于将软件包安装在容器中。 </li><li>  <code>COPY</code>文件和文件夹复制到容器中。 </li><li>  <code>ADD</code>文件和文件夹复制到容器中，可以解压缩本地.tar文件。 </li><li>  <code>CMD</code>描述带有启动容器时需要执行的参数的命令。 容器启动时可以覆盖参数。 一个文件只能包含一个<code>CMD</code>指令。 </li><li>  <code>WORKDIR</code>设置下一条指令的工作目录。 </li><li>  <code>ARG</code>设置变量以在映像构建期间传递Docker。 </li><li>  <code>ENTRYPOINT</code>为命令提供带有在容器执行期间调用的参数的命令。 参数不被覆盖。 </li><li>  <code>EXPOSE</code>表示需要打开端口。 </li><li>  <code>VOLUME</code>创建用于持久存储的安装点。 </li></ol><br> 现在让我们谈谈这些指示。 <br><br><h2>  <font color="#3AC1EF">说明和使用示例</font> </h2><br><h3>  <font color="#3AC1EF">▍简单的Dockerfile</font> </h3><br>  Dockerfile可能非常简单且简短。 例如-这样： <br><br><pre> <code class="plaintext hljs">FROM ubuntu:18.04</code> </pre> <br><h3>  <font color="#3AC1EF">▍从指导</font> </h3><br>  Dockerfile必须以<code>FROM</code>语句开头，或者以<code>ARG</code>语句后接<code>FROM</code>语句开头。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FROM</a>关键字告诉Docker在构建映像时使用与提供的名称和标记匹配的基本映像。 此外，基本图像也称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">父图像</a> 。 <br><br> 在此示例中，基本映像存储在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ubuntu</a>存储库中。  Ubuntu是官方Docker存储库的名称，该存储库提供了流行的Linux操作系统系列（称为Ubuntu）的基本版本。 <br><br> 请注意，所讨论的Dockerfile包含一个<code>18.04</code>标签，用于指定我们需要的基本映像。 构建映像时将加载此映像。 如果指令中未包含该标记，则Docker将从需要存储库中的最新映像的假设出发。 为了更清楚地表达他们的意图，建议Dockerfile作者指出所需的映像。 <br><br> 首次在本地计算机上使用上述Dockerfile生成映像时，Docker将加载<code>ubuntu</code>映像定义的层。 可以想象它们彼此重叠。 每个下一层是一个文件，描述了与将上一层添加到图像后的状态相比图像的差异。 <br><br> 创建容器时，可以在其中进行更改的图层会添加到所有其他图层的顶部。 其余层中的数据只能读取。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/912/530/d4f/912530d4f3468f0bff2a064d58d62caf.jpg"></div><br>  <i><font color="#999999">容器结构（摘自<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档</a> ）</font></i> <br><br> 出于效率考虑，Docker使用写时复制策略。 如果映像中的层位于上一层，并且某层需要从中读取数据，则Docker将使用现有文件。 您无需下载任何内容。 <br><br> 执行图像时，如果需要通过容器修改图层，则将相应的文件复制到最顶层的可变图层。 要了解有关写时复制策略的更多信息，请阅读Docker文档中的该资料。 <br><br> 我们将继续讨论Dockerfile中使用的指令，并给出具有更复杂结构的此类文件的示例。 <br><br><h3>  <font color="#3AC1EF">▍更复杂的dockerfile</font> </h3><br> 尽管我们刚刚回顾的Dockerfile看起来很整洁并且可以理解，但是它太简单了，它仅使用一条指令。 另外，在容器执行期间没有调用任何指令。 看一下另一个收集小图像的文件。 它具有确定在容器执行期间调用的命令的机制。 <br><br><pre> <code class="plaintext hljs">FROM python:3.7.2-alpine3.8 LABEL maintainer="jeffmshale@gmail.com" ENV ADMIN="jeff" RUN apk update &amp;&amp; apk upgrade &amp;&amp; apk add bash COPY . ./app ADD https://raw.githubusercontent.com/discdiver/pachy-vid/master/sample_vids/vid1.mp4 \ /my_app_directory RUN ["mkdir", "/a_directory"] CMD ["python", "./my_script.py"]</code> </pre> <br> 乍一看，此文件可能看起来很复杂。 因此，让我们对付他。 <br><br> 该图像的基础是带有标签3.7.2-alpine3.8的官方Python图像。 在分析了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这段</a>代码之后，您可以看到该基本映像包括Linux，Python，并且总体而言，它仅限于其组成。  Alpine OS映像在Docker世界中非常流行。 它们体积小，速度快，安全性高。 但是，Alpine映像在常规操作系统通常具有的广泛功能上没有差异。 因此，为了基于这种图像收集有用的东西，图像的创建者需要安装他需要的软件包。 <br><br><h3>  <font color="#3AC1EF">LA说明标签</font> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/839/d5d/720/839d5d7205849f8dee228dcd7a42eaf7.jpg"></div><br>  <i><font color="#999999">标签</font></i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">LABEL语句</a> （标签）允许您将元数据添加到图像。 对于现在正在考虑的文件，它包括图像创建者的联系信息。 声明标签不会减慢图像组装过程或增加其大小。 它们仅包含有关Docker映像的有用信息，因此建议将它们包含在文件中。 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>找到有关在Dockerfile中使用元数据的详细信息。 <br><br><h3>  <font color="#3AC1EF">▍Inv指令</font> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d85/1a1/4d7/d851a14d7b7f4db671afe3b375cb4596.jpg"></div><br>  <i><font color="#999999">环境环境</font></i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ENV</a>指令允许您设置常量环境变量，该变量将在容器执行期间在容器中可用。 在上一个示例中，在创建容器之后，可以使用<code>ADMIN</code>变量。 <br><br>  <code>ENV</code>指令非常适合设置常量。 如果您多次在Dockerfile中使用某个值，例如，当描述在容器中执行的命令时，怀疑您可能有朝一日必须将其更改为另一个值，则可以将其写入类似的常量。 <br><br> 应该注意的是，在Dockerfile文件中，通常有不同的方法来解决相同的问题。 确切使用的是一个问题，该问题的决定取决于遵守Docker环境中采用的工作方法的愿望，以确保解决方案的透明度及其高性能。 例如， <code>RUN</code> ， <code>CMD</code>和<code>ENTRYPOINT</code>具有不同的用途，但它们均用于执行命令。 <br><br><h3>  <font color="#3AC1EF">▍RUN指令</font> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/910/a89/72b/910a8972b92a69418d859a1fbd550ae5.jpg"></div><br>  <i><font color="#999999">RUN指令</font></i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RUN</a>指令允许您在映像构建过程中创建一个图层。 执行后，将新层添加到图像，其状态是固定的。  <code>RUN</code>指令通常用于在映像中安装其他软件包。 在前面的示例中， <code>RUN apk update &amp;&amp; apk upgrade</code>语句告诉Docker系统需要从基本映像更新软件包。 在这两个命令之后是<code>&amp;&amp; apk add bash</code>命令，指示需要在映像中安装bash。 <br><br> 团队中的<code>apk</code>看起来是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Alpine Linux软件包管理器</a>的缩写。 如果使用的是其他Linux家族操作系统的基础映像，则例如，在使用Ubuntu时，可能需要使用<code>RUN apt-get</code>形式的命令来安装软件包。 稍后我们将讨论其他安装软件包的方法。 <br><br> 可以以exec形式或shell形式使用<code>RUN</code>指令和类似的指令，例如<code>CMD</code>和<code>ENTRYPOINT</code> 。  exec表单使用的语法类似于JSON数组的描述。 例如，它可能看起来像这样： <code>RUN ["my_executable", "my_first_param1", "my_second_param2"]</code> 。 <br><br> 在前面的示例中，我们使用了RUN指令的shell形式，如下所示： <code>RUN apk update &amp;&amp; apk upgrade &amp;&amp; apk add bash</code> 。 <br><br> 稍后在Dockerfile中，我们以<code>RUN ["mkdir", "/a_directory"]</code>的形式使用<code>RUN</code>指令的exec形式来创建目录。 同时，使用这种形式的说明，您需要记住需要使用双引号对字符串进行格式化，这是JSON格式中常见的做法。 <br><br><h3>  <font color="#3AC1EF">▍说明书COPY</font> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ba/8b7/b82/5ba8b7b82e09854f7ba3ac1d2ad5b404.jpg"></div><br>  <i><font color="#999999">COPY指令</font></i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">COPY</a>指令在我们的文件中显示如下： <code>COPY . ./app</code>  <code>COPY . ./app</code> 。 她告诉Docker，她需要从程序集的本地上下文中获取文件和文件夹，并将它们添加到映像的当前工作目录中。 如果目标目录不存在，则此指令将创建它。 <br><br><h3>  <font color="#3AC1EF">▍说明添加</font> </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ADD</a>指令使您可以解决与<code>COPY</code>相同的问题，但是还有更多用<code>COPY</code>与之关联。 因此，使用此说明，您可以将从远程源下载的文件添加到容器中，也可以解压缩本地.tar文件。 <br><br> 在此示例中，使用<code>ADD</code>指令将可访问URL的文件复制到<code>my_app_directory</code>容器<code>my_app_directory</code> 。 但是，应注意的是， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Docker文档</a>不建议使用通过URL获得的此类文件，因为它们无法删除，并且会增加映像的大小。 <br><br> 此外， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档</a>建议尽可能使用<code>COPY</code>语句而不是<code>ADD</code>语句来使Dockerfile易于理解。 我相信Docker开发团队应该将<code>ADD</code>和<code>COPY</code>合并为一条指令，这样创建映像的人就不必记住太多指令。 <br><br> 请注意， <code>ADD</code>语句包含换行符- <code>\</code> 。 通过将这些字符分成几行，可以使用它们来提高长命令的可读性。 <br><br><h3>  <font color="#3AC1EF">MD CMD指令</font> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/505/835/d13/505835d13cd3c9300f0d95681b3dbf93.jpg"></div><br>  <i><font color="#999999">CMD指令</font></i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CMD</a>指令为Docker提供了一个在容器启动时执行的命令。 该命令的结果不会在组装过程中添加到映像中。 在我们的示例中，此命令在运行时启动<code>my_script.py</code>脚本。 <br><br> 您还需要了解有关<code>CMD</code>指令的其他信息： <br><br><ul><li> 一个Dockerfile中只能存在一个<code>CMD</code>指令。 如果文件中有多个这样的指令，则系统将忽略除最后一条以外的所有内容。 </li><li>  <code>CMD</code>指令可能具有exec形式。 如果指令不包含对可执行文件的引用，则<code>ENTRYPOINT</code>指令必须存在于文件中。 在这种情况下，这两个指令都必须为<code>JSON</code> 。 </li><li> 传递给<code>docker run</code>的命令行参数将覆盖Dockerfile中<code>CMD</code>语句提供的参数。 </li></ul><br><h3>  <font color="#3AC1EF">▍更复杂的Dockerfile</font> </h3><br> 考虑另一个Dockerfile，其中将使用一些新命令。 <br><br><pre> <code class="plaintext hljs">FROM python:3.7.2-alpine3.8 LABEL maintainer="jeffmshale@gmail.com" #   RUN apk add --update git #     WORKDIR /usr/src/my_app_directory #          COPY . . #       ARG my_var=my_default_value #  ,           ENTRYPOINT ["python", "./app/my_script.py", "my_var"] #   EXPOSE 8000 #      VOLUME /my_volume</code> </pre> <br> 在此示例中，除其他外，您可以看到以<code>#</code>字符开头的注释。 <br>  Dockerfile的主要功能之一就是安装软件包。 如前所述，有多种使用<code>RUN</code>指令安装软件包的方法。 <br><br> 可以使用<code>apk</code>安装Alpine Docker映像中的软件包。 为此，我们已经说过，使用了<code>RUN apk update &amp;&amp; apk upgrade &amp;&amp; apk add bash</code>格式的命令。 <br><br> 此外，可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pip</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">wheel</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">conda</a>安装映像中的Python软件包。 如果我们不是在谈论Python，而是在谈论其他编程语言，则可以使用其他程序包管理器来准备相应的图像。 <br><br> 同时，为了使安装成为可能，底层必须为软件包管理器提供合适的软件包管理器。 因此，如果在安装软件包时遇到问题，请在尝试使用软件包管理器之前确保已安装了软件包管理器。 <br><br> 例如，您可以在Dockerfile中使用<code>RUN</code>语句使用<code>pip</code>安装软件包列表。 如果执行此操作，请将所有命令合并为一条指令，并使用<code>\</code>字符将其与换行符分隔。 由于采用了这种方法，文件看起来会很整洁，这将导致与使用多个<code>RUN</code>指令添加的图层相比，向映像添加的图层更少。 <br><br> 此外，您可以执行其他操作来安装多个软件包。 您可以将它们列出在文件中，然后使用<code>RUN</code>将此文件传输到软件包管理器。 通常，这些文件称为<code>requirements.txt</code> 。 <br><br><h3>  <font color="#3AC1EF">RK WORKDIR说明</font> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/528/9ef/88f/5289ef88f3bc5fc7e4856fdc13d9872e.jpg"></div><br>  <i><font color="#999999">工作目录</font></i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WORKDIR</a>指令允许<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">您</a>更改容器的工作目录。 该目录下跟随<code>WORKDIR</code>的<code>COPY</code> ， <code>ADD</code> ， <code>RUN</code> ， <code>CMD</code>和<code>ENTRYPOINT</code> 。 以下是与此指令相关的一些功能： <br><br><ul><li> 最好使用<code>WORKDIR</code>设置文件夹的绝对路径，而不是使用Dockerfile中的<code>cd</code>命令浏览文件系统。 </li><li> 如果该目录不存在， <code>WORKDIR</code>指令会自动创建一个目录。 </li><li> 您可以使用一些<code>WORKDIR</code>指令。 如果提供了相对于此类指令的说明，则它们各自都会更改当前工作目录。 </li></ul><br><h3>  <font color="#3AC1EF">▍指南ARG</font> </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ARG</a>指令允许您设置一个变量，该变量的值可以在汇编期间从命令行传递到映像。 默认变量的值可以在Dockerfile中表示。 例如： <code>ARG my_var=my_default_value</code> 。 <br><br> 与<code>ENV</code>变量不同， <code>ARG</code>变量在运行时不可用。 但是， <code>ARG</code>变量可用于在映像构建过程中从命令行设置<code>ENV</code>变量的默认值。 在容器执行期间， <code>ENV</code>变量将已经在容器中可用。 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>找到有关使用变量的技术的详细信息。 <br><br><h3>  <font color="#3AC1EF">说明ENTRYPOINT</font> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2f/8b8/e95/c2f8b8e95436c097571b44810ac97a7a.jpg"></div><br>  <i><font color="#999999">过渡到某个地方</font></i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ENTRYPOINT语句</a>使<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">您</a>可以指定带有参数的命令，该命令应在容器启动时执行。 它与<code>CMD</code>命令相似，但是如果使用命令行参数启动容器，则<code>ENTRYPOINT</code>中指定的参数不会被覆盖。 <br><br> 而是将在<code>docker run my_image_name</code>形式的构造中传递的命令行参数添加到<code>ENTRYPOINT</code>指定的参数中。 例如，执行了<code>docker run my_image bash</code>形式的命令后<code>docker run my_image bash</code>参数将添加到<code>ENTRYPOINT</code>指定的参数列表的<code>ENTRYPOINT</code> 。 准备Dockerfile时，请不要忘记<code>CMD</code>或<code>ENTRYPOINT</code> 。 <br><br>  Docker文档中有一些建议，涉及在容器启动时应选择哪种指令<code>CMD</code>或<code>ENTRYPOINT</code>作为执行命令的工具： <br><br><ul><li> 如果您每次启动容器都需要运行相同的命令，请使用<code>ENTRYPOINT</code> 。 </li><li> 如果该容器将用作应用程序，请使用<code>ENTRYPOINT</code> 。 </li><li> 如果您知道启动容器时需要向其传递可以覆盖Dockerfile中指定的参数的参数，请使用<code>CMD</code> 。 </li></ul><br> 在我们的示例中，使用<code>ENTRYPOINT ["python", "my_script.py", "my_var"]</code>指令<code>ENTRYPOINT ["python", "my_script.py", "my_var"]</code>使容器在启动时以参数<code>my_var</code>运行Python脚本<code>my_script.py</code> 。 然后，可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">argparse</a>在脚本中使用<code>my_var</code>表示的值。    ,   Dockerfile  <code>my_var</code> ,   ,       <code>ARG</code> .  ,         ,     . <br><br>  Docker   exec- <code>ENTRYPOINT</code> : <code>ENTRYPOINT ["executable", "param1", "param2"]</code> . <br><br><h3> <font color="#3AC1EF">▍ EXPOSE</font> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee1/cca/45e/ee1cca45e3fd7e9be988556536fb1633.jpg"></div><br> <i><font color="#999999"> EXPOSE</font></i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">EXPOSE</a>   ,      ,          .     . , ,     ,   ,   ,  ,   . <br><br>      ( )    ,    <code>docker run</code>   <code>-p</code> .      <code>-P</code> (   <code>P</code> ),     ,    <code>EXPOSE</code> . <br><br><h3> <font color="#3AC1EF">▍ VOLUME</font> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c1/ff6/a57/7c1ff6a5765f28cbd3d68cbf60d6b4aa.jpg"></div><br> <i><font color="#999999"> VOLUME</font></i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">VOLUME</a>   ,              .     . <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br>     ,       Dockerfile.      .  ,      ,  <code>USER</code> , <code>ONBUILD</code> , <code>STOPSIGNAL</code> , <code>SHELL</code>  <code>HEALTHCHECK</code> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>     Dockerfile. <br><br> ,  Dockerfile —     Docker,      ,        .          ,       . <br><br>  <b>亲爱的读者们！</b>    Docker  ,    ,    Docker-. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN439980/">https://habr.com/ru/post/zh-CN439980/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN439970/index.html">2018-2019年互联网问题和可访问性报告</a></li>
<li><a href="../zh-CN439972/index.html">io_submit：您从未听说过的epoll的替代方法</a></li>
<li><a href="../zh-CN439974/index.html">个人敏捷转型：灵活的生产力之旅</a></li>
<li><a href="../zh-CN439976/index.html">Node.js会永远比Golang慢吗？</a></li>
<li><a href="../zh-CN439978/index.html">学习Docker，第2部分：术语和概念</a></li>
<li><a href="../zh-CN439982/index.html">React教程，第16部分：TODO应用程序第四阶段，事件处理</a></li>
<li><a href="../zh-CN439984/index.html">React教程，第17部分：处理TODO应用程序的第五阶段，修改组件状态</a></li>
<li><a href="../zh-CN439986/index.html">芯片VS集装箱技术的威胁</a></li>
<li><a href="../zh-CN439988/index.html">技术圈五年</a></li>
<li><a href="../zh-CN439990/index.html">《实用的人工智能》一书 机器学习和云技术</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>