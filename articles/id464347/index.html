<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèéÔ∏è üïç üö¨ Modul Ketergantungan Injeksi, JavaScript, dan ES6 üèÇüèæ üßïüèæ üë∫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Implementasi lain dari Dependency Injection dalam JavaScript adalah dengan modul ES6, dengan kemampuan untuk menggunakan kode yang sama di browser dan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Modul Ketergantungan Injeksi, JavaScript, dan ES6</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464347/"><p>  Implementasi lain dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dependency Injection dalam JavaScript</a> adalah dengan modul ES6, dengan kemampuan untuk menggunakan kode yang sama di browser dan di nodejs dan tidak menggunakan transpiler. </p><br><p><img src="https://habrastorage.org/webt/cm/yd/it/cmyditgokfobpp0llt2opzsflts.jpeg" alt="gambar"></p><br><p>  Di bawah potongan adalah pandangan saya tentang DI, tempatnya dalam aplikasi web modern, implementasi mendasar dari wadah DI yang dapat membuat objek baik di depan dan belakang, serta penjelasan tentang apa yang harus dilakukan Michael Jackson dengan itu. </p><a name="habracut"></a><br><p> Saya sangat meminta mereka yang merasa sepele dalam artikel untuk tidak memperkosa diri sendiri dan tidak membaca sampai akhir, sehingga nanti, ketika mereka kecewa, mereka tidak memberi "minus".  Saya tidak menentang "minus" - tetapi hanya jika minus disertai dengan komentar, apa yang sebenarnya di publikasi menyebabkan reaksi negatif.  Ini adalah artikel teknis, jadi cobalah untuk merendahkan gaya presentasi, dan mengkritik dengan tepat komponen teknis di atas.  Terima kasih </p><br><h1 id="obekty-v-prilozhenii">  Objek dalam aplikasi </h1><br><p>  Saya sangat menghargai pemrograman fungsional, tetapi saya telah mencurahkan sebagian besar aktivitas profesional saya untuk membuat aplikasi yang terdiri dari objek.  JavaScript membuat saya terkesan dengan fakta bahwa fungsi di dalamnya juga objek.  Saat membuat aplikasi, saya memikirkan objek, ini adalah deformasi profesional saya. </p><br><p>  Menurut masa hidup, objek dalam aplikasi dapat dibagi ke dalam kategori berikut: </p><br><ul><li>  <strong>permanen</strong> - muncul pada beberapa tahap aplikasi dan dihancurkan hanya ketika aplikasi selesai; </li><li>  <strong>sementara</strong> - timbul ketika perlu untuk melakukan beberapa operasi dan dihancurkan ketika operasi ini selesai; </li></ul><br><p>  Dalam hal ini, dalam pemrograman ada pola desain seperti: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">singleton</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pabrik abstrak</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pembangun</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kolam</a> , ... </li></ul><br><p>  Artinya, dari sudut pandang saya, aplikasi terdiri dari penyendiri yang ada secara permanen yang melakukan sendiri operasi yang diperlukan atau menghasilkan objek sementara untuk menjalankannya. </p><br><h1 id="konteyner-obektov">  Wadah Benda </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ketergantungan injeksi</a> adalah suatu pendekatan yang membuatnya mudah untuk membuat objek dalam suatu aplikasi.  Artinya, dalam aplikasi ada objek khusus yang ‚Äútahu‚Äù cara membuat semua objek lain.  Objek seperti itu disebut Object Container (kadang-kadang Object Manager). </p><br><p>  Wadah Objek bukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Obyek Ilahi</a> , karena  tugasnya hanya untuk membuat objek aplikasi yang signifikan dan menyediakan akses ke objek lain untuk mereka.  Sebagian besar objek aplikasi, yang dihasilkan oleh Container dan terletak di dalamnya, tidak tahu tentang Container itu sendiri.  Mereka dapat ditempatkan di lingkungan lain, disediakan dengan dependensi yang diperlukan, dan mereka juga akan berfungsi dengan sangat baik di sana (penguji tahu apa yang saya maksud). </p><br><h1 id="mesto-vnedreniya">  Tempat implementasi </h1><br><p>  Secara umum, ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua cara</a> untuk menyuntikkan dependensi ke dalam objek: </p><br><ul><li>  melalui konstruktor; </li><li>  melalui properti (atau aksesornya); </li></ul><br><p>  Saya pada dasarnya menggunakan pendekatan pertama, jadi saya akan melanjutkan deskripsi dengan sudut pandang injeksi ketergantungan melalui konstruktor. </p><br><p>  Katakanlah kita memiliki aplikasi yang terdiri dari tiga objek: </p><br><p><img src="https://habrastorage.org/webt/lv/5n/w4/lv5nw4nv1bperu7mgoxtn4luss4.png" alt="gambar"></p><br><p>  Dalam PHP (bahasa ini dengan tradisi DI yang sudah lama ada, saya saat ini memiliki bawaan aktif, saya akan pindah ke JS sedikit kemudian) situasi serupa dapat tercermin dengan cara ini: </p><br><pre><code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $config; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Config $config)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;config = $config; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Application</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $config; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $service; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Config $config, Service $service)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;config = $config; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;service = $service; } }</code> </pre> <br><p>  Informasi ini harus cukup sehingga wadah DI (misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">liga / wadah</a> ), jika dikonfigurasi dengan tepat, dapat, atas permintaan untuk membuat objek <code>Application</code> , membuat <code>Service</code> dependensi dan <code>Config</code> dan meneruskannya parameter ke konstruktor objek <code>Application</code> . </p><br><h1 id="identifikatory-zavisimostey">  Pengidentifikasi ketergantungan </h1><br><p>  Bagaimana Kontainer Obyek memahami bahwa konstruktor objek <code>Application</code> memerlukan dua objek <code>Config</code> dan <code>Service</code> ?  Dengan menganalisis objek melalui API Refleksi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PHP</a> ) atau dengan menganalisis kode objek secara langsung (anotasi kode).  Artinya, dalam kasus umum, kita dapat menentukan nama-nama variabel yang diharapkan oleh konstruktor objek pada input, dan jika bahasa dapat diketik, kita juga bisa mendapatkan jenis variabel ini. </p><br><p>  Dengan demikian, sebagai pengidentifikasi objek, Wadah dapat beroperasi dengan nama parameter input konstruktor atau jenis parameter input. </p><br><h1 id="sozdanie-obektov">  Buat Objek </h1><br><p>  Objek dapat secara eksplisit dibuat oleh pemrogram dan ditempatkan di Kontainer di bawah pengidentifikasi yang sesuai (misalnya, "konfigurasi") </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> \League\Container\Container $container */</span></span> $container-&gt;add(<span class="hljs-string"><span class="hljs-string">"configuration"</span></span>, $config);</code> </pre> <br><p>  dan dapat dibuat oleh Kontainer sesuai dengan aturan khusus tertentu.  Aturan-aturan ini, pada umumnya, turun untuk mencocokkan pengidentifikasi objek ke kode.  Aturan dapat diatur secara eksplisit (pemetaan dalam bentuk kode, XML, JSON, ...) </p><br><pre> <code class="json hljs">[ [<span class="hljs-string"><span class="hljs-string">"object_id_1"</span></span>, <span class="hljs-string"><span class="hljs-string">"/path/to/source1.php"</span></span>], [<span class="hljs-string"><span class="hljs-string">"object_id_2"</span></span>, <span class="hljs-string"><span class="hljs-string">"/path/to/source2.php"</span></span>], ... ]</code> </pre> <br><p>  atau dalam bentuk beberapa algoritma: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function"> </span></span>{. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"/path/to/source/${id}.php"</span></span>; }</code> </pre> <br><p>  Dalam PHP, aturan untuk mencocokkan nama kelas ke file dengan kode sumbernya adalah standar ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PSR-4</a> ), di Jawa, pencocokan dilakukan pada tingkat konfigurasi JVM ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemuat kelas</a> ).  Jika Wadah menyediakan pencarian sumber secara otomatis saat membuat objek, maka nama kelas adalah pengidentifikasi yang cukup baik untuk objek dalam Wadah tersebut. </p><br><h1 id="namespaces">  Ruang nama </h1><br><p>  Biasanya dalam suatu proyek, di samping kode sendiri, modul pihak ketiga juga digunakan.  Dengan munculnya manajer dependensi (pakar, komposer, npm), penggunaan modul telah sangat disederhanakan, dan jumlah modul dalam proyek telah meningkat pesat.  Ruang nama memungkinkan elemen kode dengan nama yang sama ada dalam satu proyek tunggal dari berbagai modul (kelas, fungsi, konstanta). </p><br><p>  Ada bahasa di mana namespace dibangun pada awalnya (Java): </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> vendor.project.<span class="hljs-keyword"><span class="hljs-keyword">module</span></span>.folder;</code> </pre> <br><p>  Ada bahasa di mana namespace ditambahkan selama pengembangan bahasa (PHP): </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Vendor</span></span>\<span class="hljs-title"><span class="hljs-title">Project</span></span>\<span class="hljs-title"><span class="hljs-title">Module</span></span>\<span class="hljs-title"><span class="hljs-title">Folder</span></span>;</code> </pre> <br><p>  Implementasi namespace yang baik memungkinkan Anda untuk secara jelas membahas setiap elemen kode: </p><br><pre> <code class="php hljs">\Doctrine\Common\Annotations\Annotation\Attribute::$name</code> </pre> <br><p>  Namespace memecahkan masalah mengatur banyak elemen perangkat lunak dalam suatu proyek, dan struktur file memecahkan masalah mengatur file pada disk.  Oleh karena itu, tidak hanya ada banyak kesamaan di antara mereka, dan kadang-kadang sangat banyak - di Jawa, misalnya, kelas publik di namespace harus secara unik dilampirkan ke file dengan kode kelas ini. </p><br><p>  Dengan demikian, menggunakan pengidentifikasi kelas objek di namespace proyek sebagai pengidentifikasi objek dalam Container adalah ide yang baik dan dapat berfungsi sebagai dasar untuk membuat aturan untuk deteksi otomatis kode sumber saat membuat objek yang diinginkan. </p><br><pre> <code class="php hljs">$container-&gt;add(\Vendor\Project\Module\ObjectType::class, $obj);</code> </pre> <br><h1 id="avtozagruzka-koda">  Startup kode </h1><br><p>  Dalam <code>composer</code> PHP <code>composer</code> namespace modul dipetakan ke sistem file di dalam modul di deskriptor modul <code>composer.json</code> : </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"autoload"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"psr-4"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Doctrine\\Common\\Annotations\\"</span></span>: <span class="hljs-string"><span class="hljs-string">"lib/Doctrine/Common/Annotations"</span></span> } }</code> </pre> <br><p>  Komunitas JS bisa melakukan pemetaan serupa di <code>package.json</code> jika ada ruang nama di JS. </p><br><h1 id="identifikatory-zavisimostey-v-js">  Pengidentifikasi ketergantungan JS </h1><br><p>  Di atas, saya menunjukkan bahwa Wadah dapat menggunakan nama parameter input konstruktor atau jenis parameter input sebagai pengidentifikasi.  Masalahnya adalah: </p><br><ol><li>  JS adalah bahasa dengan pengetikan dinamis dan tidak menyediakan untuk menunjukkan jenis ketika mendeklarasikan suatu fungsi. </li><li>  JS menggunakan minifiers yang dapat mengubah nama parameter input. </li></ol><br><p>  Pengembang wadah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">awilix</a> DI menyarankan untuk menggunakan objek sebagai satu-satunya parameter input ke konstruktor, dan properti objek ini sebagai dependensi: </p><br><pre> <code class="plaintext hljs">class UserController { constructor(opts) { this.userService = opts.userService } }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengidentifikasi</a> properti objek di JS dapat terdiri dari karakter alfanumerik, "_" dan "$", dan mungkin tidak dimulai dengan angka. </p><br><p>  Karena kita perlu memetakan pengidentifikasi ketergantungan ke jalur ke sumber mereka di sistem file untuk autoload, lebih baik untuk meninggalkan penggunaan "$" dan menggunakan pengalaman PHP.  Sebelum operator <code>namespace</code> muncul di beberapa kerangka kerja (misalnya, dalam Zend 1), nama-nama berikut digunakan untuk kelas: </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Zend_Config_Writer_Json</span></span></span><span class="hljs-class"> </span></span>{...}</code> </pre> <br><p>  Dengan demikian, kita dapat merefleksikan aplikasi kita dari tiga objek ( <code>Application</code> , <code>Config</code> , <code>Service</code> ) pada JS seperti ini: </p><br><pre> <code class="plaintext hljs">class Vendor_Project_Config { constructor() { } } class Vendor_Project_Service { constructor({Vendor_Project_Config}) { this.config = Vendor_Project_Config; } } class Vendor_Project_Application { constructor({Vendor_Project_Config, Vendor_Project_Service}) { this.config = Vendor_Project_Config; this.service = Vendor_Project_Service; } }</code> </pre> <br><p>  Jika kami memposting kode dari setiap kelas: </p><br><pre> <code class="plaintext hljs">export default class Vendor_Project_Application { constructor({Vendor_Project_Config, Vendor_Project_Service}) { this.config = Vendor_Project_Config; this.service = Vendor_Project_Service; } }</code> </pre> <br><p>  dalam file Anda di dalam modul proyek kami: </p><br><ul><li> <code>./src/</code> <br> <ul><li> <code>./Application.js</code> </li> <li> <code>./Config.js</code> </li> <li> <code>./Service.js</code> </li> </ul></li></ul><br><p>  Kemudian kita dapat menghubungkan direktori root modul dengan root "namespace" dari modul dalam konfigurasi Container: </p><br><pre> <code class="plaintext hljs">const ns = "Vendor_Project"; const path = path.join(module_root, "src"); container.addSourceMapping(ns, path);</code> </pre> <br><p>  dan kemudian, mulai dari informasi ini, buat path ke sumber yang sesuai ( <code>${module_root}/src/Config.js</code> ) berdasarkan pengenal dependensi ( <code>${module_root}/src/Config.js</code> ). </p><br><h1 id="es6-moduli">  Modul ES6 </h1><br><p>  ES6 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menawarkan</a> desain umum untuk memuat modul ES6: </p><br><pre> <code class="plaintext hljs">import { something } from 'path/to/source/with/something';</code> </pre> <br><p>  Karena kita perlu melampirkan satu objek (kelas) ke satu file, masuk akal di sumber untuk mengekspor kelas ini secara default: </p><br><pre> <code class="plaintext hljs">export default class Vendor_Project_Path_To_Source_With_Something {...}</code> </pre> <br><p>  Pada prinsipnya, mungkin untuk tidak menulis nama yang panjang untuk kelas, hanya <code>Something</code> akan bekerja juga, tetapi dalam Zend 1 mereka menulis dan tidak pecah, dan keunikan nama kelas dalam proyek secara positif mempengaruhi kemampuan IDE (autocomplete dan kontekstual yang diminta), jadi dan ketika debugging: </p><br><p><img src="https://habrastorage.org/webt/qc/vj/wg/qcvjwg4lkvdwbg0nwcbmotantby.png" alt="gambar"></p><br><p>  Mengimpor kelas dan membuat objek dalam kasus ini terlihat seperti ini: </p><br><pre> <code class="plaintext hljs">import Something from 'path/to/source/with/something'; const something = new Something();</code> </pre> <br><h1 id="front--back-import">  Impor Depan &amp; Belakang </h1><br><p>  Impor berfungsi baik di browser dan di nodejs, tetapi ada nuansa.  Misalnya, browser tidak memahami impor modul simpuljs: </p><br><pre> <code class="plaintext hljs">import path from "path";</code> </pre> <br><p>  Kami mendapatkan kesalahan di browser: </p><br><pre> <code class="plaintext hljs">Failed to resolve module specifier "path". Relative references must start with either "/", "./", or "../".</code> </pre> <br><p>  Artinya, jika kita ingin kode kita berfungsi di browser <strong>dan</strong> nodejs, kita tidak dapat menggunakan konstruksi yang tidak dipahami oleh browser <strong>atau</strong> nodejs.  Saya secara khusus fokus pada hal ini, karena kesimpulan seperti itu terlalu alami untuk dipikirkan.  Cara bernafas. </p><br><h1 id="mesto-di-v-sovremennyh-web-prilozheniyah">  Tempat DI dalam aplikasi web modern </h1><br><p>  Ini murni pendapat pribadi saya, karena pengalaman pribadi saya, seperti semua hal lain dalam publikasi ini. </p><br><p>  Dalam aplikasi web, JS praktis mengambil tempat di bagian depan, di browser, hampir tanpa alternatif.  Di sisi server, Java, PHP, .Net, Ruby, python, digali dengan kuat ... Tetapi dengan munculnya nodejs, JavaScript juga menembus server.  Dan teknologi yang digunakan dalam bahasa lain, termasuk DI, mulai menembus JS server-side. </p><br><p>  Pengembangan JavaScript disebabkan oleh perilaku kode yang tidak sinkron di browser.  Asynchrony bukan fitur yang luar biasa dari JS, melainkan bawaan.  Sekarang kehadiran JS baik di server dan di bagian depan tidak mengejutkan siapa pun, tetapi lebih merangsang penggunaan pendekatan yang sama di kedua ujung aplikasi web.  Dan kode yang sama.  Tentu saja, bagian depan dan belakang pada dasarnya terlalu berbeda dan dalam tugas yang harus diselesaikan untuk menggunakan kode yang sama baik di sana maupun di sana.  Tetapi kita dapat mengasumsikan bahwa dalam aplikasi yang kurang lebih kompleks akan ada browser, server dan kode umum. </p><br><p>  DI sudah digunakan di depan, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RequireJS</a> : </p><br><pre> <code class="plaintext hljs">define( ["./config", "./service"], function App(Config, Service) {} );</code> </pre> <br><p>  Benar, di sini pengidentifikasi dependensi ditulis secara eksplisit dan segera dalam bentuk tautan ke sumber (Anda dapat mengonfigurasi pemetaan pengidentifikasi dalam konfigurasi bootloader). </p><br><p>  Dalam aplikasi web modern, DI ada tidak hanya di sisi server, tetapi juga di browser. </p><br><h1 id="pri-chyom-tut-maykl-dzhekson">  Apa hubungannya Michael Jackson dengan itu? </h1><br><p>  Ketika Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengaktifkan</a> dukungan modul-ES di nodejs (flag <code>--experimental-modules</code> ), mesin mengidentifikasi konten file dengan <code>*.mjs</code> sebagai modul EcmaScript (tidak seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">modul-Common</a> dengan <code>*.cjs</code> ). </p><br><p>  Pendekatan ini kadang-kadang disebut " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Solusi Michael Jackson</a> ", dan skrip disebut Michael Jackson Scripts ( <code>*.mjs</code> ). </p><br><p>  Saya setuju bahwa intrik yang begitu-begitu saja dengan KDPV telah diselesaikan, tetapi ... para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pria itu, Michael Jackson ...</a> </p><br><h1 id="yet-another-di-implementation">  Namun Implementasi DI Lainnya </h1><br><p>  Yah, seperti yang diharapkan, milikmu sendiri <del>  sepeda </del>  Modul DI - <a href="">@ teqfw / di</a> </p><br><p>  Ini bukan solusi yang siap untuk diperjuangkan, tetapi lebih merupakan implementasi mendasar.  Semua dependensi harus merupakan modul ES dan menggunakan fitur umum untuk browser dan nodejs. </p><br><p>  Untuk mengatasi dependensi, modul menggunakan pendekatan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">awilix</a> : </p><br><pre> <code class="plaintext hljs">constructor(spec) { /** @type {Vendor_Module_Config} */ const _config = spec.Vendor_Module_Config; /** @type {Vendor_Module_Service} */ const _service = spec.Vendor_Module_Service; }</code> </pre> <br><p>  Untuk menjalankan contoh kembali: </p><br><pre> <code class="plaintext hljs">import Container from "./src/Container.mjs"; const container = new Container(); container.addSourceMapping("Vendor_Module", "../example"); container.get("Vendor_Module_App") .then((app) =&gt; { app.run(); });</code> </pre> <br><p>  di server: </p><br><pre> <code class="plaintext hljs">$ node --experimental-modules main.mjs</code> </pre> <br><p>  Untuk menjalankan contoh depan ( <code>example.html</code> ): </p><br><pre> <code class="html hljs xml"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">lang</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"en"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">meta</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">charset</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"UTF-8"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span>DI in Browser<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"module"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"./main.mjs"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Load main script './main.mjs', create new DI container, then get object by ID from container.<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Open browser console to see output.<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Anda perlu meletakkan modul di server dan membuka halaman <code>example.html</code> di browser (atau menggunakan kemampuan IDE).  Jika Anda membuka <code>example.html</code> secara langsung, maka kesalahan di Chrom adalah: </p><br><pre> <code class="plaintext hljs">Access to script at 'file:///home/alex/work/teqfw.di/main.mjs' from origin 'null' has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https.</code> </pre> <br><p>  Jika semuanya berjalan dengan baik, maka di konsol (browser atau nodejs) akan ada sesuatu seperti ini: </p><br><pre> <code class="plaintext hljs">Create object with ID 'Vendor_Module_App'. Create object with ID 'Vendor_Module_Config'. There is no dependency with id 'Vendor_Module_Config' yet. 'Vendor_Module_Config' instance is created. Create object with ID 'Vendor_Module_Service'. There is no dependency with id 'Vendor_Module_Service' yet. 'Vendor_Module_Service' instance is created (deps: [Vendor_Module_Config]). 'Vendor_Module_App' instance is created (deps: [Vendor_Module_Config, Vendor_Module_Service]). Application 'Vendor_Module_Config' is running.</code> </pre> <br><h1 id="rezyume">  Ringkasan </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AMD, CommonJS, UMD?</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ESM</a> ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464347/">https://habr.com/ru/post/id464347/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464331/index.html">Manfaat Tidak Berguna: Sintesis Bahan Kimia Penyerap UV dari Kacang Mete</a></li>
<li><a href="../id464333/index.html">Melacak siklus hidup pengguna tanpa tang dan pita listrik</a></li>
<li><a href="../id464335/index.html">Tes unit dalam DBMS - bagaimana kita melakukannya di Sportmaster, bagian satu</a></li>
<li><a href="../id464337/index.html">Cara mem-bypass captcha: jaringan saraf pada Tensorflow, Keras, python v numeric captcha berisik</a></li>
<li><a href="../id464345/index.html">5 alasan untuk membuka startup IT di Jerman</a></li>
<li><a href="../id464351/index.html">Kamera IP PoE, persyaratan khusus, dan operasi bebas masalah - menyatukan semuanya</a></li>
<li><a href="../id464353/index.html">1C: ERP VS 1C: KA 2.0. Apa yang harus produsen makanan pilih?</a></li>
<li><a href="../id464355/index.html">Bagaimana sebuah frame ditampilkan di Shadow Fight 3</a></li>
<li><a href="../id464357/index.html">RSA blockchain acak</a></li>
<li><a href="../id464359/index.html">Fitur pengujian aplikasi Web Seluler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>