<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üâê ü§∞ üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë® OOP est mort, vive OOP üò≠ üë©üèø‚Äçüíª üë®üèΩ‚Äçüç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sources d'inspiration 
 Ce billet a vu le jour gr√¢ce √† une r√©cente publication d' Aras Prantskevichus sur un rapport destin√© aux programmeurs d√©butant...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OOP est mort, vive OOP</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441174/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d22/8c2/d99/d228c2d99b9b17da94979d7fc5f728ee.png" alt="image"></div><br><h1>  Sources d'inspiration </h1><br>  Ce billet a vu le jour gr√¢ce √† une r√©cente publication d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">Aras Prantskevichus</a> sur un rapport destin√© aux programmeurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">d√©butants</a> .  Il explique comment s'adapter aux nouvelles architectures ECS.  Aras suit le mod√®le habituel ( <em>explication ci-dessous</em> ): montre des exemples du terrible code OOP, puis d√©montre que le mod√®le relationnel ( <em>mais l'appelle ¬´ECS¬ª plut√¥t que relationnel</em> ) est une excellente alternative.  Je ne critique en aucun cas Aras - je suis un grand fan de son travail et je le f√©licite pour son excellente pr√©sentation!  J'ai choisi sa pr√©sentation au lieu de centaines d'autres articles sur ECS sur Internet car il a fait des efforts suppl√©mentaires et a publi√© un r√©f√©rentiel git pour √©tude en parall√®le avec la pr√©sentation.  Il contient un petit ¬´jeu¬ª simple, utilis√© comme exemple de s√©lection de diff√©rentes solutions architecturales.  Ce petit projet m'a permis de d√©montrer mes commentaires sur un mat√©riau sp√©cifique, alors merci, Aras! <br><br>  Les diapositives Aras sont disponibles ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">http://aras-p.info/texts/files/2018Academy - ECS-DoD.pdf</a> , et le code est sur github: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">https://github.com/aras-p/dod-playground</a> . <br><br>  Je ne vais pas (encore?) Analyser l'architecture ECS r√©sultante de ce rapport, mais je me concentrerai sur le "mauvais code POO" (similaire √† l'astuce farcie) depuis son d√©but.  Je vais montrer √† quoi cela ressemblerait vraiment si toutes les violations des principes d'OOD (conception orient√©e objet, conception orient√©e objet) √©taient correctement corrig√©es. <br><br>  <strong>Spoiler: l'√©limination de toutes les violations OOD conduit √† des am√©liorations de performances similaires aux conversions Aras en ECS, il utilise √©galement moins de RAM et n√©cessite moins de lignes de code que la version ECS!</strong> <br><br>  <em>TL; DR: Avant de conclure que OOP suce et ECS, faites une pause et examinez OOD (pour savoir comment utiliser OOP correctement), et comprenez √©galement le mod√®le relationnel (pour savoir comment appliquer correctement ECS).</em> <br><a name="habracut"></a><br>  Je participe √† de nombreuses discussions sur ECS sur le forum depuis longtemps, en partie parce que je ne pense pas que ce mod√®le m√©rite d'exister en tant que terme distinct ( <em>spoiler: ce n'est qu'une version ad hoc du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">mod√®le relationnel</a></em> ), mais aussi parce que presque <em>chaque</em> publication, pr√©sentation ou article faisant la promotion d'un mod√®le ECS suit la structure suivante: <br><br><ol><li>  Montrez un exemple de code OOP terrible, dont l'impl√©mentation a de terribles d√©fauts dus √† une utilisation excessive de l'h√©ritage (ce qui signifie que cette impl√©mentation viole de nombreux principes d'OOD). <br></li><li>  Montrer que la composition est une meilleure solution que l'h√©ritage (et sans oublier que OOD nous donne en fait la m√™me le√ßon). <br></li><li>  Montrez que le mod√®le relationnel est id√©al pour les jeux (mais appelez-le ¬´ECS¬ª). </li></ol><br>  Une telle structure me rend furieux parce que: <strong>(A)</strong> c'est une astuce "bourr√©e" ... elle compare le doux au chaud (mauvais code et bon code) ... et c'est injuste, m√™me si cela est fait involontairement et n'est pas n√©cessaire pour d√©montrer que la nouvelle architecture est bonne;  et, plus important encore: <strong>(B)</strong> elle a un effet secondaire - une telle approche supprime les connaissances et dissuade par inadvertance les lecteurs de se familiariser avec les √©tudes men√©es pendant un demi-si√®cle.  Ils ont commenc√© √† √©crire sur le mod√®le relationnel dans les ann√©es 1960.  Tout au long des ann√©es 70 et 80, ce mod√®le s'est consid√©rablement am√©lior√©.  Les d√©butants ont souvent des questions comme "dans <em>quelle classe voulez-vous mettre ces donn√©es?</em> ", Et en r√©ponse, on leur dit souvent quelque chose de vague, comme "il <em>vous suffit d'acqu√©rir de l'exp√©rience et ensuite vous apprenez √† comprendre int√©rieurement</em> " ... mais dans les ann√©es 70, cette question √©tait activement √©tudi√© et dans le cas g√©n√©ral une r√©ponse formelle a √©t√© d√©duite;  c'est ce qu'on appelle la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">normalisation de la base de donn√©es</a> .  En ignorant la recherche existante et en qualifiant ECS de solution compl√®tement nouvelle et moderne, vous cachez cette connaissance aux d√©butants. <br><br>  Les bases de la programmation orient√©e objet ont √©t√© pos√©es il y a aussi longtemps, sinon plus t√¥t ( <em>ce style a commenc√© √† √™tre explor√© dans les ann√©es 1950</em> )!  Cependant, c'est dans les ann√©es 1990 que l'orientation objet est devenue √† la mode, virale et s'est tr√®s vite transform√©e en paradigme de programmation dominant.  L'explosion de popularit√© de nombreux nouveaux langages OO, y compris Java et le ( <em>version standardis√©e</em> ) C ++, s'est produite.  Cependant, comme cela √©tait d√ª √† un battage m√©diatique, tout le monde <em>avait besoin de</em> conna√Ætre ce concept de haut niveau pour √©crire dans son curriculum vitae, mais seuls quelques-uns y ont vraiment particip√©.  Ces nouveaux langages ont cr√©√© les mots cl√©s - <em>classe</em> , <em>virtuel</em> , <em>√©tend</em> , <em>impl√©mente</em> - √† partir de nombreuses fonctionnalit√©s d'OO, et je pense que c'est pourquoi √† ce moment-l√† OO √©tait divis√© en deux entit√©s distinctes qui vivent leur propre vie. <br><br>  Je ferai r√©f√©rence √† l'utilisation de ces fonctionnalit√©s de langage d'inspiration OO comme ¬´ <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">OOP</a></strong> ¬ª et √† l'utilisation de techniques de conception / architecture inspir√©es d'OO ¬´ <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">OOD</a></strong> ¬ª.  Tous ont tr√®s vite repris la POO.  Les √©tablissements d'enseignement ont des cours OO qui pr√©parent de nouveaux programmeurs OOP ... cependant, la connaissance de l'OOD est √† la tra√Æne. <br><br>  Je crois que le code qui utilise les fonctionnalit√©s de langage d'OOP, mais ne suit pas les principes de conception OOD, n'est <strong>pas un code OO</strong> .  La plupart des critiques contre OOP utilisent par exemple du code vid√©, qui n'est pas vraiment un code OO. <br><br>  Le code OOP a une tr√®s mauvaise r√©putation, et en particulier parce que la plupart du code OOP ne suit pas les principes de l'OOD, et n'est donc pas un "vrai" code OO. <br><br><h1>  Contexte </h1><br>  Comme indiqu√© ci-dessus, les ann√©es 1990 sont devenues l'apog√©e de la ¬´mode OO¬ª et c'est √† cette √©poque que la ¬´mauvaise OOP¬ª √©tait probablement la pire.  Si vous avez √©tudi√© la POO √† ce moment-l√†, vous avez probablement appris les ¬´quatre piliers de la POO¬ª: <br><br><ul><li>  Abstraction </li><li>  Encapsulation </li><li>  Polymorphisme </li><li>  H√©ritage </li></ul><br>  Je pr√©f√®re les appeler non pas quatre piliers, mais ¬´quatre outils de POO¬ª.  Ce sont des outils que <em><strong>vous pouvez</strong></em> utiliser pour r√©soudre des probl√®mes.  Cependant, il ne suffit pas simplement de savoir comment l'outil fonctionne, vous devez savoir quand l'utiliser ... De la part des enseignants, il est irresponsable d'enseigner aux gens un nouvel outil, de ne pas leur dire quand chacun vaut la peine d'√™tre utilis√©.  Au d√©but des ann√©es 2000, il y avait une r√©sistance √† la mauvaise utilisation active de ces outils, une sorte de ¬´deuxi√®me vague¬ª de la pens√©e OOD.  Le r√©sultat a √©t√© l'√©mergence de mn√©moniques <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">SOLIDES</a> , qui ont fourni un moyen rapide d'√©valuer les forces architecturales.  Il convient de noter que cette sagesse √©tait en fait r√©pandue dans les ann√©es 90, mais n'a pas encore re√ßu un acronyme sympa, ce qui leur a permis d'√™tre fix√©s en cinq principes de base ... <br><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">Le principe de la responsabilit√© unique</a></strong> ( <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">principe de responsabilit√© unique</a></strong> ).  Chaque classe ne doit avoir qu'une seule raison pour le changement.  Si la classe "A" a deux responsabilit√©s, vous devez cr√©er la classe "B" et "C" pour traiter chacune d'elles individuellement, puis cr√©er "A" √† partir de "B" et "C". </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">Le principe d'ouverture / fermeture</a></strong> ( <b>O</b> stylo / principe ferm√©).  Le logiciel change au fil du temps ( <em>c'est-√†-dire que son support est important</em> ).  Essayez de mettre les parties les plus susceptibles de changer dans les <em>impl√©mentations (</em> <em>c'est-√†-dire dans des classes sp√©cifiques</em> ) et de cr√©er des <em>interfaces</em> bas√©es sur les parties qui ne sont pas susceptibles de changer ( <em>par exemple, les classes de base abstraites</em> ). <br></li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">Le principe de substitution de Barbara Liskov</a></strong> (principe de substitution de <b>L</b> iskov).  Chaque impl√©mentation d'une interface doit r√©pondre √† 100% aux exigences de cette interface, c'est-√†-dire  tout algorithme fonctionnant avec une interface devrait fonctionner avec n'importe quelle impl√©mentation. </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">Le principe de s√©paration de l'interface</a></strong> (principe de s√©gr√©gation d' <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">interface</a></strong> ).  Rendez les interfaces aussi petites que possible afin que chaque partie du code ¬´connaisse¬ª la plus petite quantit√© de base de code, par exemple, √©vite les d√©pendances inutiles.  Cette astuce est √©galement bonne pour C ++, o√π les temps de compilation deviennent √©normes si vous ne les suivez pas. </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">Le principe d'inversion de d√©pendance</a></strong> ( <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">principe d'inversion de d√©pendance</a></strong> ).  Au lieu de deux impl√©mentations sp√©cifiques qui communiquent directement (et d√©pendent l'une de l'autre), elles peuvent g√©n√©ralement √™tre s√©par√©es en formalisant leur interface de communication en tant que troisi√®me classe, utilis√©e comme interface entre elles.  Il peut s'agir d'une classe de base abstraite qui d√©finit les appels des m√©thodes utilis√©es entre elles, ou m√™me simplement d'une structure <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">POD</a> qui d√©finit les donn√©es transf√©r√©es entre elles. </li><li>  Un autre principe n'est pas inclus dans l'acronyme SOLID, mais je suis s√ªr qu'il est tr√®s important: <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">¬´Pr√©f√©rez la composition √† l'h√©ritage¬ª</a></strong> (Principe de r√©utilisation composite).  La composition <em>est le bon choix par d√©faut</em> .  L'h√©ritage devrait √™tre laiss√© pour les cas o√π cela est absolument n√©cessaire. </li></ul><br>  Nous obtenons donc SOLID-C (++) <img alt=":)" height="20" src="https://habrastorage.org/getpro/habr/post_images/e8d/c8c/1e8/e8dc8c1e846d52073e8f2a944b2006fa.png" width="20"><br><br>  Ci-dessous, je ferai r√©f√©rence √† ces principes, en les appelant des acronymes - SRP, OCP, LSP, ISP, DIP, CRP ... <br><br>  Quelques notes suppl√©mentaires: <br><br><ul><li>  Dans OOD, les concepts d' <em>interfaces</em> et d' <em>impl√©mentations</em> ne peuvent √™tre li√©s √† aucun mot cl√© OOP sp√©cifique.  En C ++, nous cr√©ons souvent des interfaces avec <em>des classes de base abstraites</em> et <em>des fonctions virtuelles</em> , puis des <em>impl√©mentations</em> h√©ritent de ces classes de base ... mais ce n'est qu'une fa√ßon sp√©cifique d'impl√©menter le principe de l'interface.  En C ++, on peut aussi utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">PIMPL</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">pointeurs opaques</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">typage canard</a> , typedef, etc ... Vous pouvez cr√©er une structure OOD puis l'impl√©menter en C, dans lequel il n'y a aucun mot-cl√© de langage OOP!  Donc, quand je parle d' <em>interfaces</em> , je ne parle pas n√©cessairement <em>de</em> fonctions <em>virtuelles</em> - je parle du principe de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">masquer l'impl√©mentation</a> .  Les interfaces <em>peuvent</em> √™tre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">polymorphes</a> , mais le plus souvent elles le sont!  Le polymorphisme est tr√®s rarement utilis√© correctement, mais les interfaces sont un concept fondamental pour tous les logiciels. <br><ul><li>  Comme je l'ai pr√©cis√© ci-dessus, si vous cr√©ez une structure POD qui stocke simplement des donn√©es pour la transmission d'une classe √† une autre, cette structure est utilis√©e comme <em>interface</em> - il s'agit d'une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">description</a> formelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">des donn√©es</a> . <br></li><li>  M√™me si vous cr√©ez simplement une classe distincte avec les parties <em>publiques</em> et <em>priv√©es</em> , tout ce qui se trouve dans la partie commune est une <em>interface</em> et tout dans la partie priv√©e est une <em>impl√©mentation</em> . </li></ul></li><li>  L'h√©ritage a en fait (au moins) deux types - l'h√©ritage d'interface et l'h√©ritage d'impl√©mentation. <br><ul><li>  En C ++, l'h√©ritage d'interface comprend des classes de base abstraites avec des fonctions virtuelles pures, PIMPL, typedef conditionnel.  En Java, l'h√©ritage d'interface est exprim√© par le mot cl√© <em>implements</em> . </li><li>  En C ++, l'h√©ritage des impl√©mentations se produit chaque fois que les classes de base contiennent autre chose que des fonctions virtuelles pures.  En Java, l'h√©ritage d'impl√©mentation est exprim√© √† l'aide du <em>mot-cl√© extend</em> . </li><li>  OOD a beaucoup de r√®gles pour h√©riter des interfaces, mais l'h√©ritage des impl√©mentations vaut g√©n√©ralement la peine d'√™tre consid√©r√© comme du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">"code en un rien"</a> ! </li></ul></li></ul><br>  Et enfin, je devrais montrer quelques exemples de la terrible formation OOP et comment elle conduit √† un mauvais code dans la vie r√©elle (et √† la mauvaise r√©putation d'OOP). <br><br><ol><li>  Lorsque vous avez appris les hi√©rarchies / h√©ritages, vous pourriez avoir √©t√© charg√© d'une t√¢che similaire: <strong><em>supposons que vous ayez une application universitaire contenant un r√©pertoire des √©tudiants et du personnel.</em></strong>  <strong><em>Vous pouvez cr√©er la classe de base Person, puis la classe Student et la classe Staff, h√©rit√©es de Person.</em></strong> <br><br>  Non, non, non.  Ici, je vais vous arr√™ter.  L'implication tacite du principe LSP est que <em>les hi√©rarchies de classes</em> et les <em>algorithmes qui les traitent</em> sont symbiotiques.  Ce sont les deux moiti√©s de l'ensemble du programme.  La POO est une extension de la programmation proc√©durale, et elle est encore principalement associ√©e √† ces proc√©dures.  Si nous ne savons pas quels types d'algorithmes fonctionneront avec les <i>√©tudiants</i> et le <em>personnel</em> ( <em>et quels algorithmes seront simplifi√©s en raison du polymorphisme</em> ), il sera compl√®tement irresponsable de commencer √† cr√©er la structure des hi√©rarchies de classes.  Vous devez d'abord conna√Ætre les algorithmes <em>et les</em> donn√©es. </li><li>  Quand on vous a enseign√© les hi√©rarchies / h√©ritages, on vous a probablement confi√© une t√¢che similaire: <b><i>supposons que vous ayez une classe de formes.</i></b>  <b><i>Nous avons √©galement des carr√©s et des rectangles comme sous-classes.</i></b>  <b><i>Un carr√© doit-il √™tre un rectangle ou un rectangle un carr√©?</i></b> <br><br>  Il s'agit en fait d'un bon exemple pour d√©montrer la diff√©rence entre l'h√©ritage des impl√©mentations et l'h√©ritage des interfaces. <br><ul><li>  Si vous utilisez l'approche de l'h√©ritage d'impl√©mentation, vous ignorez compl√®tement le LSP et, d'un point de vue pratique, pensez √† la possibilit√© de r√©utiliser le code, en utilisant l'h√©ritage comme outil. <br><br>  De ce point de vue, ce qui suit est parfaitement logique: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Square</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rectangle</span></span></span><span class="hljs-class"> :</span></span> Square { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height; };</code> </pre> <br>  Le carr√© n'a que la largeur, et le rectangle a la largeur + hauteur, c'est-√†-dire, en d√©veloppant le carr√© avec la composante hauteur, nous obtenons un rectangle! <br><ul><li>  Comme vous l'avez peut-√™tre devin√©, OOD dit que faire cela est ( <em>probablement</em> ) mal.  J'ai dit <em>"probablement"</em> car ici vous pouvez discuter des caract√©ristiques implicites de l'interface ... eh bien. <br><br>  Un carr√© a toujours la m√™me hauteur et la m√™me largeur, donc √† partir de l'interface du carr√©, il est parfaitement vrai de supposer que la zone est "largeur * largeur". <br><br>  H√©ritant d'un carr√©, la classe des rectangles (selon LSP) <strong>doit</strong> ob√©ir aux r√®gles de l'interface du carr√©.  Tout algorithme qui fonctionne correctement pour un carr√© devrait √©galement fonctionner correctement pour un rectangle. </li><li>  Prenez un autre algorithme: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Square*&gt; shapes; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> area = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> s : shapes) area += s-&gt;width * s-&gt;width;</code> </pre> <br>  Cela fonctionnera correctement pour les carr√©s (calculant la somme de leurs surfaces), mais ne fonctionnera pas pour les rectangles. <br><br>  Par cons√©quent, le rectangle viole le principe LSP. </li></ul></li><li>  Si vous utilisez l'approche de l'h√©ritage d'interface, ni Square ni Rectangle n'h√©riteront les uns des autres.  Les interfaces pour le carr√© et le rectangle sont en fait diff√©rentes, et l'une n'est pas un surensemble de l'autre. <br></li><li>  Par cons√©quent, OOD emp√™che l'utilisation de l'h√©ritage des impl√©mentations.  Comme indiqu√© ci-dessus, si vous souhaitez r√©utiliser du code, alors OOD dit que la composition est le bon choix! <br><ul><li>  Ainsi, la version <i>correcte</i> du (mauvais) code ci-dessus pour la hi√©rarchie d'h√©ritage des impl√©mentations C ++ ressemble √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shape</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Square</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Shape { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> width * width; }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rectangle</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Square, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Shape { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> width * height; }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height; };</code> </pre> <br><ul><li>  "Virtuel public" en Java signifie "impl√©mente".  Utilis√© lors de la mise en ≈ìuvre de l'interface. <br></li><li>  "Priv√©" vous permet d'√©tendre la classe de base sans h√©riter de son interface - dans ce cas, le rectangle n'est <b>pas un</b> carr√©, bien qu'il en h√©rite. <br></li></ul></li><li>  Je ne recommande pas d'√©crire un tel code, mais si vous souhaitez utiliser l'h√©ritage des impl√©mentations, vous devez le faire! </li></ul></li></ul></li></ol><br>  TL; DR - votre classe OOP vous a dit √† quoi ressemblait l'h√©ritage.  Votre classe OOD manquante aurait d√ª vous dire de ne pas l'utiliser 99% du temps! <br><br><h1>  Concepts d'entit√© / de composant </h1><br>  Apr√®s avoir rempli les conditions pr√©alables, passons au point de d√©part d'Aras - au soi-disant point de d√©part d'un ¬´POO typique¬ª. <br><br>  Mais pour commencer, un autre ajout - Aras appelle ce code ¬´POO traditionnel¬ª, et je veux m'y opposer.  Ce code peut √™tre typique de la POO dans le monde r√©el, mais, comme les exemples ci-dessus, il viole toutes sortes de principes de base de la PO, il ne doit donc pas du tout √™tre consid√©r√© comme traditionnel. <br><br>  Je vais commencer par le premier commit avant qu'il ne commence √† refaire la structure vers ECS: <a href="" rel="external nofollow">"Faites-le fonctionner √† nouveau sur Windows" 3529f232510c95f53112bbfff87df6bbc6aa1fae</a> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ------------------------------------------------------------------------------------------------- // super simple "component system" class GameObject; class Component; typedef std::vector&lt;Component*&gt; ComponentVector; typedef std::vector&lt;GameObject*&gt; GameObjectVector; // Component base class. Knows about the parent game object, and has some virtual methods. class Component { public: Component() : m_GameObject(nullptr) {} virtual ~Component() {} virtual void Start() {} virtual void Update(double time, float deltaTime) {} const GameObject&amp; GetGameObject() const { return *m_GameObject; } GameObject&amp; GetGameObject() { return *m_GameObject; } void SetGameObject(GameObject&amp; go) { m_GameObject = &amp;go; } bool HasGameObject() const { return m_GameObject != nullptr; } private: GameObject* m_GameObject; }; // Game object class. Has an array of components. class GameObject { public: GameObject(const std::string&amp;&amp; name) : m_Name(name) { } ~GameObject() { // game object owns the components; destroy them when deleting the game object for (auto c : m_Components) delete c; } // get a component of type T, or null if it does not exist on this game object template&lt;typename T&gt; T* GetComponent() { for (auto i : m_Components) { T* c = dynamic_cast&lt;T*&gt;(i); if (c != nullptr) return c; } return nullptr; } // add a new component to this game object void AddComponent(Component* c) { assert(!c-&gt;HasGameObject()); c-&gt;SetGameObject(*this); m_Components.emplace_back(c); } void Start() { for (auto c : m_Components) c-&gt;Start(); } void Update(double time, float deltaTime) { for (auto c : m_Components) c-&gt;Update(time, deltaTime); } private: std::string m_Name; ComponentVector m_Components; }; // The "scene": array of game objects. static GameObjectVector s_Objects; // Finds all components of given type in the whole scene template&lt;typename T&gt; static ComponentVector FindAllComponentsOfType() { ComponentVector res; for (auto go : s_Objects) { T* c = go-&gt;GetComponent&lt;T&gt;(); if (c != nullptr) res.emplace_back(c); } return res; } // Find one component of given type in the scene (returns first found one) template&lt;typename T&gt; static T* FindOfType() { for (auto go : s_Objects) { T* c = go-&gt;GetComponent&lt;T&gt;(); if (c != nullptr) return c; } return nullptr; }</span></span></code> </pre> <br>  Oui, il est difficile de comprendre imm√©diatement une centaine de lignes de code, alors commen√ßons progressivement ... Nous avons besoin d'un autre aspect des conditions pr√©alables - il √©tait populaire d'utiliser l'h√©ritage dans les jeux des ann√©es 90 pour r√©soudre tous les probl√®mes de r√©utilisation du code.  Vous aviez Entity, Extensible Character, extensible Player and Monster, et ainsi de suite ... Ceci est un h√©ritage d'impl√©mentations, comme nous l'avons d√©crit plus haut ( <em>"code avec un √©tranglement"</em> ), et il semble qu'il soit juste de commencer par cela, mais en cons√©quence cela conduit √† un tr√®s base de code rigide.  Parce que OOD a le principe de ¬´composition sur h√©ritage¬ª d√©crit ci-dessus.  Ainsi, dans les ann√©es 2000, le principe de ¬´composition sur h√©ritage¬ª est devenu populaire et les d√©veloppeurs de jeux ont commenc√© √† √©crire du code similaire. <br><br>  Que fait ce code?  Eh bien pas bon <img alt=":D" height="20" src="https://habrastorage.org/getpro/habr/post_images/4c3/d02/890/4c3d028909133f97a7a351651c98c08b.png" title=": D" width="20"><br><br>  En bref, <strong>ce code r√©impl√©mente une fonctionnalit√© existante du langage - la composition en</strong> tant que biblioth√®que d'ex√©cution, et non en tant que fonctionnalit√© du langage.  Vous pouvez imaginer cela comme si le code cr√©ait r√©ellement un nouveau m√©talangage au-dessus de C ++ et une machine virtuelle (VM) pour ex√©cuter ce m√©talangage.  Dans le jeu de d√©monstration Aras, ce code n'est pas requis ( <em>nous allons le supprimer compl√®tement bient√¥t!</em> ) Et ne sert qu'√† r√©duire les performances du jeu d'environ 10 fois. <br><br>  Mais que fait-il r√©ellement?  Il s'agit du concept de "syst√®me omposant <strong>E</strong> ntity / <strong>C</strong> " ( <em>parfois pour une raison quelconque appel√© "syst√®me omponent <strong>E</strong> ntity / <strong>C</strong> "</em> ), mais il est compl√®tement diff√©rent du concept de " <strong>E</strong> ntity <strong>C</strong> Sysstem omponent "(" entity-component-system ") ( <em>qui pour des raisons √©videntes n'est jamais appel√©" <strong>S</strong> ystem <strong>C</strong> omponent <strong>S</strong> ystem systems</em> ). Il formalise plusieurs principes de la "CE": <br><br><ul><li>  le jeu sera construit √† partir de l'absence de fonctionnalit√©s des "Entit√©s" ("Entit√©") ( <em>dans cet exemple appel√©</em> GameObjects), qui se composent de "composants" ("Composant"). </li><li>  GameObjects impl√©mente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">le mod√®le ¬´localisateur de service¬ª</a> - leurs composants enfants seront interrog√©s par type. </li><li>  Les composants savent √† quel GameObject ils appartiennent - ils peuvent trouver des composants qui sont au m√™me niveau avec eux en interrogeant le GameObject parent. <br></li><li>  La composition ne peut avoir qu'un niveau (les <em>composants ne peuvent pas avoir leurs propres composants enfants, GameObjects ne peut pas avoir de GameObjects enfants</em> ). <br></li><li>  GameObject ne peut avoir qu'un seul composant de chaque type ( <em>dans certains cadres, c'est une exigence obligatoire, dans d'autres non</em> ). <br></li><li>  Chaque composant change (probablement) au fil du temps d'une mani√®re non sp√©cifi√©e, donc l'interface contient une "mise √† jour de vide virtuel". <br></li><li>  Les GameObjects appartiennent √† une sc√®ne qui peut ex√©cuter des requ√™tes sur tous les GameObjects (et donc tous les composants). </li></ul><br>  Un concept similaire √©tait tr√®s populaire dans les ann√©es 2000, et malgr√© ses limites, il s'est av√©r√© √™tre suffisamment flexible pour cr√©er d'innombrables jeux √† l'√©poque et aujourd'hui. <br><br>  Cependant, cela n'est pas obligatoire.  Votre langage de programmation prend d√©j√† en charge la composition en tant que caract√©ristique du langage - il n'y a pas besoin d'un concept gonfl√© pour y acc√©der ... Pourquoi, alors, ces concepts existent-ils?  Eh bien, pour √™tre honn√™te, ils vous permettent d'effectuer <em>une composition dynamique lors de l'ex√©cution</em> .  Au lieu de d√©finir durement les types GameObject dans le code, vous pouvez les charger √† partir de fichiers de donn√©es.  Et c'est tr√®s pratique, car cela permet aux concepteurs de jeux / niveaux de cr√©er leurs propres types d'objets ... Cependant, dans la plupart des projets de jeux, il y a tr√®s peu de concepteurs et litt√©ralement toute une arm√©e de programmeurs, donc je dirais que c'est une opportunit√© importante.  Pire encore, ce n'est pas le seul moyen d'impl√©menter une composition au moment de l'ex√©cution!  Par exemple, Unity utilise C # comme son ¬´langage de script¬ª, et de nombreux autres jeux utilisent ses alternatives, par exemple, Lua - un outil pratique pour les concepteurs peut g√©n√©rer du code C # / Lua pour d√©finir de nouveaux objets de jeu sans avoir besoin d'un tel concept gonfl√©!  Nous allons rajouter cette ¬´fonctionnalit√©¬ª dans le prochain post, et faire en sorte qu'elle ne nous co√ªte pas dix fois moins de performances ... <br><br>  √âvaluons ce code selon OOD: <br><br><ul><li>  GameObject :: GetComponent utilise dynamic_cast.  La plupart des gens vous diront que dynamic_cast est un ¬´code avec un √©tranglement¬ª, un gros indice que vous avez un bug quelque part.  Je dirais ceci - c'est la preuve que vous avez viol√© le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">LSP</a> - vous avez une sorte d'algorithme qui fonctionne avec l'interface de base, mais il doit conna√Ætre diff√©rents d√©tails d'impl√©mentation.  Pour cette raison particuli√®re, le code sent mauvais. <br></li><li>  GameObject, en principe, n'est pas mauvais, si vous imaginez qu'il impl√©mente le mod√®le ¬´localisateur de service¬ª ... mais si vous allez plus loin que la critique du point de vue d'OOD, ce mod√®le cr√©e des connexions implicites entre les parties du projet, et je pense ( <em>sans lien vers Wikipedia qui peut prendre en charge moi avec des connaissances en informatique</em> ) que les canaux de communication implicites sont un contre- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">mod√®le</a> , et ils devraient pr√©f√©rer les canaux de communication explicites.  Le m√™me argument s'applique au "concept d'√©v√©nements" gonfl√© qui est parfois utilis√© dans les jeux ... <br></li><li>  Je veux d√©clarer qu'un composant est une violation de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">SRP</a> parce que son interface ( <em>Virtual void Update (time)</em> ) est trop large.  L'utilisation de ¬´Virtual void Update¬ª dans le d√©veloppement de jeux est omnipr√©sente, mais je dirais √©galement qu'elle est anti-mod√®le.  Un bon logiciel devrait vous permettre de penser facilement au flux de contr√¥le et au flux de donn√©es.  Placer <em>chaque √©l√©ment du code de gameplay</em> derri√®re l'appel "Virtual void Update" obscurcit compl√®tement et compl√®tement le flux de contr√¥le et le flux de donn√©es.  √Ä mon humble avis, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">les effets secondaires</a> invisibles, √©galement appel√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">effets √†</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">longue port√©e</a> , sont quelques-unes des sources les plus courantes de bogues, et la ¬´mise √† jour du vide virtuel¬ª garantit que presque tout sera un effet secondaire invisible. <br></li><li>  Bien que l'objectif de la classe Component soit d'activer la composition, elle le fait par h√©ritage, ce qui constitue une violation de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">CRP</a> . </li><li>  Le seul bon c√¥t√© de cet exemple est que le code de jeu est exag√©r√© afin de se conformer aux principes de SRP et ISP - il est divis√© en de nombreux composants simples avec tr√®s peu de responsabilit√©, ce qui est id√©al pour r√©utiliser le code. <br><br>  Cependant, il n'est pas si bon √† maintenir DIP - de nombreux composants ont une connaissance directe les uns des autres. </li></ul><br>  Ainsi, tout le code ci-dessus peut √™tre supprim√©.  Toute cette structure.  Supprimez GameObject (dans d'autres frameworks √©galement appel√©s Entity), supprimez Component, supprimez FindOfType.  Cela fait partie d'une machine virtuelle inutile qui viole les principes OOD et ralentit terriblement notre jeu. <br><br><h1>  Composition sans frameworks (c'est-√†-dire en utilisant les fonctionnalit√©s du langage de programmation lui-m√™me) </h1><br>  Si nous supprimons le cadre de composition et que nous n'avons pas la classe de base Composant, comment nos GameObjects parviendront-ils √† utiliser la composition et √† se composer de composants?  Comme le titre l'indique, au lieu d'√©crire cette machine virtuelle gonfl√©e et de cr√©er des GameObjects dans un √©trange m√©talangage par dessus, √©crivons-les simplement en C ++ parce que nous sommes des programmeurs de jeux et c'est litt√©ralement notre travail. <br><br>  Voici le commit qui a supprim√© le framework Entity / Component: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">https://github.com/hodgman/dod-playground/commit/f42290d0217d700dea2ed002f2f3b1dc45e8c27c</a> <br><br>  Voici la version originale du code source: <a href="" rel="external nofollow">https://github.com/hodgman/dod-playground/blob/3529f232510c95f53112bbfff87df6bbc6aa1fae/source/game.cpp</a> <br><br>  Voici la version modifi√©e du code source: <a href="" rel="external nofollow">https://github.com/hodgman/dod-playground/blob/f42290d0217d700dea2ed002f2f3b1dc45e8c27c/source/game.cpp</a> <br><br>  En bref sur les changements: <br><br><ul><li>  Suppression de ": Public Component" de chaque type de composant. <br></li><li>  Ajout d'un constructeur √† chaque type de composant. <br><ul><li>  OOD consiste principalement √† encapsuler l'√©tat d'une classe, mais comme ces classes sont si petites / simples, il n'y a vraiment rien √† cacher: l'interface est une description des donn√©es.  Cependant, l'une des principales raisons pour lesquelles l'encapsulation est le pilier principal est qu'elle nous permet de garantir la v√©rit√© constante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">des invariants de classe</a> ... ou si l'invariant est cass√©, il vous suffit d'examiner le code d'impl√©mentation encapsul√© pour trouver l'erreur.  Dans cet exemple de code, il vaut la peine d'ajouter des constructeurs pour impl√©menter un simple invariant - toutes les valeurs doivent √™tre initialis√©es. </li></ul></li><li>  J'ai renomm√© les m√©thodes ¬´g√©n√©rales¬ª trop g√©n√©rales pour que leurs noms refl√®tent ce qu'elles font r√©ellement - UpdatePosition pour MoveComponent et ResolveCollisions pour EviterComponent. <br></li><li>  J'ai supprim√© trois blocs de code cod√©s en dur qui ressemblaient √† un mod√®le / pr√©fabriqu√© - le code qui cr√©e un GameObject contenant des types sp√©cifiques de composant, et je l'ai remplac√© par trois classes C ++. <br></li><li>  √âlimination de la "mise √† jour du vide virtuel". <br></li><li>  Au lieu que les composants se recherchent via le mod√®le de ¬´localisateur de services¬ª, le jeu les lie explicitement lors de la construction. </li></ul><br><h2>  Les objets </h2><br>  Par cons√©quent, au lieu de ce code "machine virtuelle": <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// create regular objects that move for (auto i = 0; i &lt; kObjectCount; ++i) { GameObject* go = new GameObject("object"); // position it within world bounds PositionComponent* pos = new PositionComponent(); pos-&gt;x = RandomFloat(bounds-&gt;xMin, bounds-&gt;xMax); pos-&gt;y = RandomFloat(bounds-&gt;yMin, bounds-&gt;yMax); go-&gt;AddComponent(pos); // setup a sprite for it (random sprite index from first 5), and initial white color SpriteComponent* sprite = new SpriteComponent(); sprite-&gt;colorR = 1.0f; sprite-&gt;colorG = 1.0f; sprite-&gt;colorB = 1.0f; sprite-&gt;spriteIndex = rand() % 5; sprite-&gt;scale = 1.0f; go-&gt;AddComponent(sprite); // make it move MoveComponent* move = new MoveComponent(0.5f, 0.7f); go-&gt;AddComponent(move); // make it avoid the bubble things AvoidComponent* avoid = new AvoidComponent(); go-&gt;AddComponent(avoid); s_Objects.emplace_back(go); }</span></span></code> </pre> <br>  Nous avons maintenant du code C ++ normal: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegularObject</span></span></span><span class="hljs-class"> {</span></span> PositionComponent pos; SpriteComponent sprite; MoveComponent move; AvoidComponent avoid; RegularObject(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> WorldBoundsComponent&amp; bounds) : move(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.7f</span></span>) <span class="hljs-comment"><span class="hljs-comment">// position it within world bounds , pos(RandomFloat(bounds.xMin, bounds.xMax), RandomFloat(bounds.yMin, bounds.yMax)) // setup a sprite for it (random sprite index from first 5), and initial white color , sprite(1.0f, 1.0f, 1.0f, rand() % 5, 1.0f) { } }; ... // create regular objects that move regularObject.reserve(kObjectCount); for (auto i = 0; i &lt; kObjectCount; ++i) regularObject.emplace_back(bounds);</span></span></code> </pre> <br><h2>  Des algorithmes </h2><br>  Un autre changement majeur a √©t√© apport√© aux algorithmes.  Rappelez-vous, au d√©but, j'ai dit que les interfaces et les algorithmes fonctionnent en symbiose et devraient s'influencer mutuellement.  Ainsi, l'anti-mod√®le " <em>Virtual void Update</em> " est devenu l'ennemi ici aussi.  Le code initial contient l'algorithme de boucle principale, compos√© uniquement de ceci: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// go through all objects for (auto go : s_Objects) { // Update all their components go-&gt;Update(time, deltaTime);</span></span></code> </pre> <br>  Vous pouvez dire que c'est beau et simple, mais √† mon humble avis, c'est tr√®s, tr√®s mauvais.  Cela obscurcit compl√®tement le <em>flux de</em> <em>contr√¥le</em> et le <em>flux de donn√©es</em> dans le jeu.  Si nous voulons √™tre en mesure de comprendre notre logiciel, si nous voulons le soutenir, si nous voulons lui ajouter de nouvelles choses, l'optimiser, l'ex√©cuter efficacement sur plusieurs c≈ìurs de processeur, alors nous devons comprendre √† la fois le flux de contr√¥le et le flux de donn√©es.  Par cons√©quent, "Virtual void Update" doit √™tre mis √† feu. <br><br>  Au lieu de cela, nous avons cr√©√© une boucle principale plus explicite, ce qui simplifie consid√©rablement la compr√©hension du flux de contr√¥le (le <em>flux de donn√©es qu'il contient est toujours obscurci, mais nous corrigerons cela dans les validations suivantes</em> ). <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Update all positions for (auto&amp; go : s_game-&gt;regularObject) { UpdatePosition(deltaTime, go, s_game-&gt;bounds.wb); } for (auto&amp; go : s_game-&gt;avoidThis) { UpdatePosition(deltaTime, go, s_game-&gt;bounds.wb); } // Resolve all collisions for (auto&amp; go : s_game-&gt;regularObject) { ResolveCollisions(deltaTime, go, s_game-&gt;avoidThis); }</span></span></code> </pre> <br>  L'inconv√©nient de ce style est que pour <em>chaque nouveau type d'objet</em> ajout√© au jeu, nous devons ajouter plusieurs lignes √† la boucle principale.  J'y reviendrai dans un prochain article de cette s√©rie. <br><br><h1>  Performances </h1><br>  Il y a beaucoup d'√©normes violations d'OOD, de mauvaises d√©cisions sont prises lors du choix d'une structure, et il existe de nombreuses opportunit√©s d'optimisation, mais j'y reviendrai dans le prochain post de la s√©rie.  Cependant, d√©j√† √† ce stade, il est clair que la version avec "OOD fixe" correspond presque compl√®tement ou gagne le code final "ECS" √† la fin de la pr√©sentation ... Et tout ce que nous avons fait, c'est simplement prendre le mauvais code pseudo-OOP et le faire respecter les principes OOP (et aussi supprim√© une centaine de lignes de code)! <br><br><div style="text-align:center;"><img alt="img" src="https://habrastorage.org/getpro/habr/post_images/d22/8c2/d99/d228c2d99b9b17da94979d7fc5f728ee.png"></div><br><h1>  Prochaines √©tapes </h1><br>  Ici, je veux consid√©rer un √©ventail beaucoup plus large de probl√®mes, y compris la r√©solution des probl√®mes OOD restants, les objets immuables ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">programmation dans un style fonctionnel</a> ) et les avantages qu'ils peuvent apporter dans les discussions sur les flux de donn√©es, le passage de messages, l'application de la logique DOD √† notre code OOD, appliquer la sagesse pertinente dans le code OOD, supprimer ces classes ¬´d'entit√©s¬ª avec lesquelles nous nous sommes retrouv√©s et utiliser uniquement des composants purs, utiliser diff√©rents styles pour connecter les composants (comparer les pointeurs et  la responsabilit√© de l' ex√©cution) des composants de conteneurs du monde r√©el, la version ECS-r√©vision pour une meilleure optimisation, ainsi que une optimisation plus pouss√©e, ne figure pas dans le rapport Aras <em>(comme le multi-threading / SIMD).</em>  L'ordre ne sera pas n√©cessairement celui-ci, et je ne consid√©rerai peut-√™tre pas tout ce qui pr√©c√®de ... <br><br><h1>  Addition </h1><br>  Les liens vers l'article se sont r√©pandus au-del√† des cercles des d√©veloppeurs de jeux, donc j'ajouterai: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">ECS</a> " ( <em>cet article Wikipedia est mauvais, en passant, il combine les concepts d'EC et d'ECS, et ce n'est pas la m√™me chose ...</em> ) - c'est un faux mod√®le circulant au sein des communaut√©s d√©veloppeurs de jeux.  En fait, il s'agit d'une version du mod√®le relationnel dans lequel les ¬´entit√©s¬ª ne sont que des identifiants qui d√©signent un objet informe, les ¬´composants¬ª sont des lignes dans des tableaux sp√©cifiques qui font r√©f√©rence aux identifiants et les ¬´syst√®mes¬ª sont du code proc√©dural qui peut modifier les composants .  Ce ¬´mod√®le¬ª a toujours √©t√© positionn√© comme une solution au probl√®me de l'application excessive de l'h√©ritage, mais il n'est pas mentionn√© qu'une application excessive de l'h√©ritage viole en fait les recommandations de la POO.  D'o√π mon indignation.  Ce n'est pas la ¬´seule vraie fa√ßon¬ª d'√©crire des logiciels.  Le message est con√ßu pour s'assurer que les gens apprennent r√©ellement les principes de conception existants. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr441174/">https://habr.com/ru/post/fr441174/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr441158/index.html">Comment l'√©thique est devenue le probl√®me le plus cher de la Silicon Valley et la philosophie est devenue sa solution la plus pratique</a></li>
<li><a href="../fr441160/index.html">Comment apprendre √† savoir quand dire non</a></li>
<li><a href="../fr441166/index.html">Nous obtenons le mot de passe principal du gestionnaire de mots de passe verrouill√© 1 Mot de passe 4</a></li>
<li><a href="../fr441168/index.html">QUIC DataChannels: premi√®res √©tapes</a></li>
<li><a href="../fr441172/index.html">Comment le march√© de l'impression 3D a augment√© en 2018 et ce que cela signifie pour les entreprises</a></li>
<li><a href="../fr441180/index.html">Nuageux avec une chance de publicit√© non d√©sactivable dans le ciel √©toil√©</a></li>
<li><a href="../fr441182/index.html">Approche synesth√©sique de la machine pour d√©tecter les attaques DDoS r√©seau. 2e partie</a></li>
<li><a href="../fr441184/index.html">La premi√®re conf√©rence de jeu Mail.ru Group</a></li>
<li><a href="../fr441186/index.html">Visionneuse ASH: red√©marrage</a></li>
<li><a href="../fr441192/index.html">Utiliser la puissance de calcul de R pour tester l'hypoth√®se d'√©galit√© des moyens</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>