<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🉐 🤰 👩‍❤️‍💋‍👨 OOP est mort, vive OOP 😭 👩🏿‍💻 👨🏽‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sources d'inspiration 
 Ce billet a vu le jour grâce à une récente publication d' Aras Prantskevichus sur un rapport destiné aux programmeurs débutant...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OOP est mort, vive OOP</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441174/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d22/8c2/d99/d228c2d99b9b17da94979d7fc5f728ee.png" alt="image"></div><br><h1>  Sources d'inspiration </h1><br>  Ce billet a vu le jour grâce à une récente publication d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">Aras Prantskevichus</a> sur un rapport destiné aux programmeurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">débutants</a> .  Il explique comment s'adapter aux nouvelles architectures ECS.  Aras suit le modèle habituel ( <em>explication ci-dessous</em> ): montre des exemples du terrible code OOP, puis démontre que le modèle relationnel ( <em>mais l'appelle «ECS» plutôt que relationnel</em> ) est une excellente alternative.  Je ne critique en aucun cas Aras - je suis un grand fan de son travail et je le félicite pour son excellente présentation!  J'ai choisi sa présentation au lieu de centaines d'autres articles sur ECS sur Internet car il a fait des efforts supplémentaires et a publié un référentiel git pour étude en parallèle avec la présentation.  Il contient un petit «jeu» simple, utilisé comme exemple de sélection de différentes solutions architecturales.  Ce petit projet m'a permis de démontrer mes commentaires sur un matériau spécifique, alors merci, Aras! <br><br>  Les diapositives Aras sont disponibles ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">http://aras-p.info/texts/files/2018Academy - ECS-DoD.pdf</a> , et le code est sur github: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">https://github.com/aras-p/dod-playground</a> . <br><br>  Je ne vais pas (encore?) Analyser l'architecture ECS résultante de ce rapport, mais je me concentrerai sur le "mauvais code POO" (similaire à l'astuce farcie) depuis son début.  Je vais montrer à quoi cela ressemblerait vraiment si toutes les violations des principes d'OOD (conception orientée objet, conception orientée objet) étaient correctement corrigées. <br><br>  <strong>Spoiler: l'élimination de toutes les violations OOD conduit à des améliorations de performances similaires aux conversions Aras en ECS, il utilise également moins de RAM et nécessite moins de lignes de code que la version ECS!</strong> <br><br>  <em>TL; DR: Avant de conclure que OOP suce et ECS, faites une pause et examinez OOD (pour savoir comment utiliser OOP correctement), et comprenez également le modèle relationnel (pour savoir comment appliquer correctement ECS).</em> <br><a name="habracut"></a><br>  Je participe à de nombreuses discussions sur ECS sur le forum depuis longtemps, en partie parce que je ne pense pas que ce modèle mérite d'exister en tant que terme distinct ( <em>spoiler: ce n'est qu'une version ad hoc du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">modèle relationnel</a></em> ), mais aussi parce que presque <em>chaque</em> publication, présentation ou article faisant la promotion d'un modèle ECS suit la structure suivante: <br><br><ol><li>  Montrez un exemple de code OOP terrible, dont l'implémentation a de terribles défauts dus à une utilisation excessive de l'héritage (ce qui signifie que cette implémentation viole de nombreux principes d'OOD). <br></li><li>  Montrer que la composition est une meilleure solution que l'héritage (et sans oublier que OOD nous donne en fait la même leçon). <br></li><li>  Montrez que le modèle relationnel est idéal pour les jeux (mais appelez-le «ECS»). </li></ol><br>  Une telle structure me rend furieux parce que: <strong>(A)</strong> c'est une astuce "bourrée" ... elle compare le doux au chaud (mauvais code et bon code) ... et c'est injuste, même si cela est fait involontairement et n'est pas nécessaire pour démontrer que la nouvelle architecture est bonne;  et, plus important encore: <strong>(B)</strong> elle a un effet secondaire - une telle approche supprime les connaissances et dissuade par inadvertance les lecteurs de se familiariser avec les études menées pendant un demi-siècle.  Ils ont commencé à écrire sur le modèle relationnel dans les années 1960.  Tout au long des années 70 et 80, ce modèle s'est considérablement amélioré.  Les débutants ont souvent des questions comme "dans <em>quelle classe voulez-vous mettre ces données?</em> ", Et en réponse, on leur dit souvent quelque chose de vague, comme "il <em>vous suffit d'acquérir de l'expérience et ensuite vous apprenez à comprendre intérieurement</em> " ... mais dans les années 70, cette question était activement étudié et dans le cas général une réponse formelle a été déduite;  c'est ce qu'on appelle la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">normalisation de la base de données</a> .  En ignorant la recherche existante et en qualifiant ECS de solution complètement nouvelle et moderne, vous cachez cette connaissance aux débutants. <br><br>  Les bases de la programmation orientée objet ont été posées il y a aussi longtemps, sinon plus tôt ( <em>ce style a commencé à être exploré dans les années 1950</em> )!  Cependant, c'est dans les années 1990 que l'orientation objet est devenue à la mode, virale et s'est très vite transformée en paradigme de programmation dominant.  L'explosion de popularité de nombreux nouveaux langages OO, y compris Java et le ( <em>version standardisée</em> ) C ++, s'est produite.  Cependant, comme cela était dû à un battage médiatique, tout le monde <em>avait besoin de</em> connaître ce concept de haut niveau pour écrire dans son curriculum vitae, mais seuls quelques-uns y ont vraiment participé.  Ces nouveaux langages ont créé les mots clés - <em>classe</em> , <em>virtuel</em> , <em>étend</em> , <em>implémente</em> - à partir de nombreuses fonctionnalités d'OO, et je pense que c'est pourquoi à ce moment-là OO était divisé en deux entités distinctes qui vivent leur propre vie. <br><br>  Je ferai référence à l'utilisation de ces fonctionnalités de langage d'inspiration OO comme « <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">OOP</a></strong> » et à l'utilisation de techniques de conception / architecture inspirées d'OO « <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">OOD</a></strong> ».  Tous ont très vite repris la POO.  Les établissements d'enseignement ont des cours OO qui préparent de nouveaux programmeurs OOP ... cependant, la connaissance de l'OOD est à la traîne. <br><br>  Je crois que le code qui utilise les fonctionnalités de langage d'OOP, mais ne suit pas les principes de conception OOD, n'est <strong>pas un code OO</strong> .  La plupart des critiques contre OOP utilisent par exemple du code vidé, qui n'est pas vraiment un code OO. <br><br>  Le code OOP a une très mauvaise réputation, et en particulier parce que la plupart du code OOP ne suit pas les principes de l'OOD, et n'est donc pas un "vrai" code OO. <br><br><h1>  Contexte </h1><br>  Comme indiqué ci-dessus, les années 1990 sont devenues l'apogée de la «mode OO» et c'est à cette époque que la «mauvaise OOP» était probablement la pire.  Si vous avez étudié la POO à ce moment-là, vous avez probablement appris les «quatre piliers de la POO»: <br><br><ul><li>  Abstraction </li><li>  Encapsulation </li><li>  Polymorphisme </li><li>  Héritage </li></ul><br>  Je préfère les appeler non pas quatre piliers, mais «quatre outils de POO».  Ce sont des outils que <em><strong>vous pouvez</strong></em> utiliser pour résoudre des problèmes.  Cependant, il ne suffit pas simplement de savoir comment l'outil fonctionne, vous devez savoir quand l'utiliser ... De la part des enseignants, il est irresponsable d'enseigner aux gens un nouvel outil, de ne pas leur dire quand chacun vaut la peine d'être utilisé.  Au début des années 2000, il y avait une résistance à la mauvaise utilisation active de ces outils, une sorte de «deuxième vague» de la pensée OOD.  Le résultat a été l'émergence de mnémoniques <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">SOLIDES</a> , qui ont fourni un moyen rapide d'évaluer les forces architecturales.  Il convient de noter que cette sagesse était en fait répandue dans les années 90, mais n'a pas encore reçu un acronyme sympa, ce qui leur a permis d'être fixés en cinq principes de base ... <br><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">Le principe de la responsabilité unique</a></strong> ( <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">principe de responsabilité unique</a></strong> ).  Chaque classe ne doit avoir qu'une seule raison pour le changement.  Si la classe "A" a deux responsabilités, vous devez créer la classe "B" et "C" pour traiter chacune d'elles individuellement, puis créer "A" à partir de "B" et "C". </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">Le principe d'ouverture / fermeture</a></strong> ( <b>O</b> stylo / principe fermé).  Le logiciel change au fil du temps ( <em>c'est-à-dire que son support est important</em> ).  Essayez de mettre les parties les plus susceptibles de changer dans les <em>implémentations (</em> <em>c'est-à-dire dans des classes spécifiques</em> ) et de créer des <em>interfaces</em> basées sur les parties qui ne sont pas susceptibles de changer ( <em>par exemple, les classes de base abstraites</em> ). <br></li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">Le principe de substitution de Barbara Liskov</a></strong> (principe de substitution de <b>L</b> iskov).  Chaque implémentation d'une interface doit répondre à 100% aux exigences de cette interface, c'est-à-dire  tout algorithme fonctionnant avec une interface devrait fonctionner avec n'importe quelle implémentation. </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">Le principe de séparation de l'interface</a></strong> (principe de ségrégation d' <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">interface</a></strong> ).  Rendez les interfaces aussi petites que possible afin que chaque partie du code «connaisse» la plus petite quantité de base de code, par exemple, évite les dépendances inutiles.  Cette astuce est également bonne pour C ++, où les temps de compilation deviennent énormes si vous ne les suivez pas. </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">Le principe d'inversion de dépendance</a></strong> ( <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">principe d'inversion de dépendance</a></strong> ).  Au lieu de deux implémentations spécifiques qui communiquent directement (et dépendent l'une de l'autre), elles peuvent généralement être séparées en formalisant leur interface de communication en tant que troisième classe, utilisée comme interface entre elles.  Il peut s'agir d'une classe de base abstraite qui définit les appels des méthodes utilisées entre elles, ou même simplement d'une structure <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">POD</a> qui définit les données transférées entre elles. </li><li>  Un autre principe n'est pas inclus dans l'acronyme SOLID, mais je suis sûr qu'il est très important: <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">«Préférez la composition à l'héritage»</a></strong> (Principe de réutilisation composite).  La composition <em>est le bon choix par défaut</em> .  L'héritage devrait être laissé pour les cas où cela est absolument nécessaire. </li></ul><br>  Nous obtenons donc SOLID-C (++) <img alt=":)" height="20" src="https://habrastorage.org/getpro/habr/post_images/e8d/c8c/1e8/e8dc8c1e846d52073e8f2a944b2006fa.png" width="20"><br><br>  Ci-dessous, je ferai référence à ces principes, en les appelant des acronymes - SRP, OCP, LSP, ISP, DIP, CRP ... <br><br>  Quelques notes supplémentaires: <br><br><ul><li>  Dans OOD, les concepts d' <em>interfaces</em> et d' <em>implémentations</em> ne peuvent être liés à aucun mot clé OOP spécifique.  En C ++, nous créons souvent des interfaces avec <em>des classes de base abstraites</em> et <em>des fonctions virtuelles</em> , puis des <em>implémentations</em> héritent de ces classes de base ... mais ce n'est qu'une façon spécifique d'implémenter le principe de l'interface.  En C ++, on peut aussi utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">PIMPL</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">pointeurs opaques</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">typage canard</a> , typedef, etc ... Vous pouvez créer une structure OOD puis l'implémenter en C, dans lequel il n'y a aucun mot-clé de langage OOP!  Donc, quand je parle d' <em>interfaces</em> , je ne parle pas nécessairement <em>de</em> fonctions <em>virtuelles</em> - je parle du principe de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">masquer l'implémentation</a> .  Les interfaces <em>peuvent</em> être <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">polymorphes</a> , mais le plus souvent elles le sont!  Le polymorphisme est très rarement utilisé correctement, mais les interfaces sont un concept fondamental pour tous les logiciels. <br><ul><li>  Comme je l'ai précisé ci-dessus, si vous créez une structure POD qui stocke simplement des données pour la transmission d'une classe à une autre, cette structure est utilisée comme <em>interface</em> - il s'agit d'une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">description</a> formelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">des données</a> . <br></li><li>  Même si vous créez simplement une classe distincte avec les parties <em>publiques</em> et <em>privées</em> , tout ce qui se trouve dans la partie commune est une <em>interface</em> et tout dans la partie privée est une <em>implémentation</em> . </li></ul></li><li>  L'héritage a en fait (au moins) deux types - l'héritage d'interface et l'héritage d'implémentation. <br><ul><li>  En C ++, l'héritage d'interface comprend des classes de base abstraites avec des fonctions virtuelles pures, PIMPL, typedef conditionnel.  En Java, l'héritage d'interface est exprimé par le mot clé <em>implements</em> . </li><li>  En C ++, l'héritage des implémentations se produit chaque fois que les classes de base contiennent autre chose que des fonctions virtuelles pures.  En Java, l'héritage d'implémentation est exprimé à l'aide du <em>mot-clé extend</em> . </li><li>  OOD a beaucoup de règles pour hériter des interfaces, mais l'héritage des implémentations vaut généralement la peine d'être considéré comme du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">"code en un rien"</a> ! </li></ul></li></ul><br>  Et enfin, je devrais montrer quelques exemples de la terrible formation OOP et comment elle conduit à un mauvais code dans la vie réelle (et à la mauvaise réputation d'OOP). <br><br><ol><li>  Lorsque vous avez appris les hiérarchies / héritages, vous pourriez avoir été chargé d'une tâche similaire: <strong><em>supposons que vous ayez une application universitaire contenant un répertoire des étudiants et du personnel.</em></strong>  <strong><em>Vous pouvez créer la classe de base Person, puis la classe Student et la classe Staff, héritées de Person.</em></strong> <br><br>  Non, non, non.  Ici, je vais vous arrêter.  L'implication tacite du principe LSP est que <em>les hiérarchies de classes</em> et les <em>algorithmes qui les traitent</em> sont symbiotiques.  Ce sont les deux moitiés de l'ensemble du programme.  La POO est une extension de la programmation procédurale, et elle est encore principalement associée à ces procédures.  Si nous ne savons pas quels types d'algorithmes fonctionneront avec les <i>étudiants</i> et le <em>personnel</em> ( <em>et quels algorithmes seront simplifiés en raison du polymorphisme</em> ), il sera complètement irresponsable de commencer à créer la structure des hiérarchies de classes.  Vous devez d'abord connaître les algorithmes <em>et les</em> données. </li><li>  Quand on vous a enseigné les hiérarchies / héritages, on vous a probablement confié une tâche similaire: <b><i>supposons que vous ayez une classe de formes.</i></b>  <b><i>Nous avons également des carrés et des rectangles comme sous-classes.</i></b>  <b><i>Un carré doit-il être un rectangle ou un rectangle un carré?</i></b> <br><br>  Il s'agit en fait d'un bon exemple pour démontrer la différence entre l'héritage des implémentations et l'héritage des interfaces. <br><ul><li>  Si vous utilisez l'approche de l'héritage d'implémentation, vous ignorez complètement le LSP et, d'un point de vue pratique, pensez à la possibilité de réutiliser le code, en utilisant l'héritage comme outil. <br><br>  De ce point de vue, ce qui suit est parfaitement logique: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Square</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rectangle</span></span></span><span class="hljs-class"> :</span></span> Square { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height; };</code> </pre> <br>  Le carré n'a que la largeur, et le rectangle a la largeur + hauteur, c'est-à-dire, en développant le carré avec la composante hauteur, nous obtenons un rectangle! <br><ul><li>  Comme vous l'avez peut-être deviné, OOD dit que faire cela est ( <em>probablement</em> ) mal.  J'ai dit <em>"probablement"</em> car ici vous pouvez discuter des caractéristiques implicites de l'interface ... eh bien. <br><br>  Un carré a toujours la même hauteur et la même largeur, donc à partir de l'interface du carré, il est parfaitement vrai de supposer que la zone est "largeur * largeur". <br><br>  Héritant d'un carré, la classe des rectangles (selon LSP) <strong>doit</strong> obéir aux règles de l'interface du carré.  Tout algorithme qui fonctionne correctement pour un carré devrait également fonctionner correctement pour un rectangle. </li><li>  Prenez un autre algorithme: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Square*&gt; shapes; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> area = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> s : shapes) area += s-&gt;width * s-&gt;width;</code> </pre> <br>  Cela fonctionnera correctement pour les carrés (calculant la somme de leurs surfaces), mais ne fonctionnera pas pour les rectangles. <br><br>  Par conséquent, le rectangle viole le principe LSP. </li></ul></li><li>  Si vous utilisez l'approche de l'héritage d'interface, ni Square ni Rectangle n'hériteront les uns des autres.  Les interfaces pour le carré et le rectangle sont en fait différentes, et l'une n'est pas un surensemble de l'autre. <br></li><li>  Par conséquent, OOD empêche l'utilisation de l'héritage des implémentations.  Comme indiqué ci-dessus, si vous souhaitez réutiliser du code, alors OOD dit que la composition est le bon choix! <br><ul><li>  Ainsi, la version <i>correcte</i> du (mauvais) code ci-dessus pour la hiérarchie d'héritage des implémentations C ++ ressemble à ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shape</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Square</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Shape { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> width * width; }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rectangle</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Square, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Shape { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> width * height; }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height; };</code> </pre> <br><ul><li>  "Virtuel public" en Java signifie "implémente".  Utilisé lors de la mise en œuvre de l'interface. <br></li><li>  "Privé" vous permet d'étendre la classe de base sans hériter de son interface - dans ce cas, le rectangle n'est <b>pas un</b> carré, bien qu'il en hérite. <br></li></ul></li><li>  Je ne recommande pas d'écrire un tel code, mais si vous souhaitez utiliser l'héritage des implémentations, vous devez le faire! </li></ul></li></ul></li></ol><br>  TL; DR - votre classe OOP vous a dit à quoi ressemblait l'héritage.  Votre classe OOD manquante aurait dû vous dire de ne pas l'utiliser 99% du temps! <br><br><h1>  Concepts d'entité / de composant </h1><br>  Après avoir rempli les conditions préalables, passons au point de départ d'Aras - au soi-disant point de départ d'un «POO typique». <br><br>  Mais pour commencer, un autre ajout - Aras appelle ce code «POO traditionnel», et je veux m'y opposer.  Ce code peut être typique de la POO dans le monde réel, mais, comme les exemples ci-dessus, il viole toutes sortes de principes de base de la PO, il ne doit donc pas du tout être considéré comme traditionnel. <br><br>  Je vais commencer par le premier commit avant qu'il ne commence à refaire la structure vers ECS: <a href="" rel="external nofollow">"Faites-le fonctionner à nouveau sur Windows" 3529f232510c95f53112bbfff87df6bbc6aa1fae</a> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ------------------------------------------------------------------------------------------------- // super simple "component system" class GameObject; class Component; typedef std::vector&lt;Component*&gt; ComponentVector; typedef std::vector&lt;GameObject*&gt; GameObjectVector; // Component base class. Knows about the parent game object, and has some virtual methods. class Component { public: Component() : m_GameObject(nullptr) {} virtual ~Component() {} virtual void Start() {} virtual void Update(double time, float deltaTime) {} const GameObject&amp; GetGameObject() const { return *m_GameObject; } GameObject&amp; GetGameObject() { return *m_GameObject; } void SetGameObject(GameObject&amp; go) { m_GameObject = &amp;go; } bool HasGameObject() const { return m_GameObject != nullptr; } private: GameObject* m_GameObject; }; // Game object class. Has an array of components. class GameObject { public: GameObject(const std::string&amp;&amp; name) : m_Name(name) { } ~GameObject() { // game object owns the components; destroy them when deleting the game object for (auto c : m_Components) delete c; } // get a component of type T, or null if it does not exist on this game object template&lt;typename T&gt; T* GetComponent() { for (auto i : m_Components) { T* c = dynamic_cast&lt;T*&gt;(i); if (c != nullptr) return c; } return nullptr; } // add a new component to this game object void AddComponent(Component* c) { assert(!c-&gt;HasGameObject()); c-&gt;SetGameObject(*this); m_Components.emplace_back(c); } void Start() { for (auto c : m_Components) c-&gt;Start(); } void Update(double time, float deltaTime) { for (auto c : m_Components) c-&gt;Update(time, deltaTime); } private: std::string m_Name; ComponentVector m_Components; }; // The "scene": array of game objects. static GameObjectVector s_Objects; // Finds all components of given type in the whole scene template&lt;typename T&gt; static ComponentVector FindAllComponentsOfType() { ComponentVector res; for (auto go : s_Objects) { T* c = go-&gt;GetComponent&lt;T&gt;(); if (c != nullptr) res.emplace_back(c); } return res; } // Find one component of given type in the scene (returns first found one) template&lt;typename T&gt; static T* FindOfType() { for (auto go : s_Objects) { T* c = go-&gt;GetComponent&lt;T&gt;(); if (c != nullptr) return c; } return nullptr; }</span></span></code> </pre> <br>  Oui, il est difficile de comprendre immédiatement une centaine de lignes de code, alors commençons progressivement ... Nous avons besoin d'un autre aspect des conditions préalables - il était populaire d'utiliser l'héritage dans les jeux des années 90 pour résoudre tous les problèmes de réutilisation du code.  Vous aviez Entity, Extensible Character, extensible Player and Monster, et ainsi de suite ... Ceci est un héritage d'implémentations, comme nous l'avons décrit plus haut ( <em>"code avec un étranglement"</em> ), et il semble qu'il soit juste de commencer par cela, mais en conséquence cela conduit à un très base de code rigide.  Parce que OOD a le principe de «composition sur héritage» décrit ci-dessus.  Ainsi, dans les années 2000, le principe de «composition sur héritage» est devenu populaire et les développeurs de jeux ont commencé à écrire du code similaire. <br><br>  Que fait ce code?  Eh bien pas bon <img alt=":D" height="20" src="https://habrastorage.org/getpro/habr/post_images/4c3/d02/890/4c3d028909133f97a7a351651c98c08b.png" title=": D" width="20"><br><br>  En bref, <strong>ce code réimplémente une fonctionnalité existante du langage - la composition en</strong> tant que bibliothèque d'exécution, et non en tant que fonctionnalité du langage.  Vous pouvez imaginer cela comme si le code créait réellement un nouveau métalangage au-dessus de C ++ et une machine virtuelle (VM) pour exécuter ce métalangage.  Dans le jeu de démonstration Aras, ce code n'est pas requis ( <em>nous allons le supprimer complètement bientôt!</em> ) Et ne sert qu'à réduire les performances du jeu d'environ 10 fois. <br><br>  Mais que fait-il réellement?  Il s'agit du concept de "système omposant <strong>E</strong> ntity / <strong>C</strong> " ( <em>parfois pour une raison quelconque appelé "système omponent <strong>E</strong> ntity / <strong>C</strong> "</em> ), mais il est complètement différent du concept de " <strong>E</strong> ntity <strong>C</strong> Sysstem omponent "(" entity-component-system ") ( <em>qui pour des raisons évidentes n'est jamais appelé" <strong>S</strong> ystem <strong>C</strong> omponent <strong>S</strong> ystem systems</em> ). Il formalise plusieurs principes de la "CE": <br><br><ul><li>  le jeu sera construit à partir de l'absence de fonctionnalités des "Entités" ("Entité") ( <em>dans cet exemple appelé</em> GameObjects), qui se composent de "composants" ("Composant"). </li><li>  GameObjects implémente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">le modèle «localisateur de service»</a> - leurs composants enfants seront interrogés par type. </li><li>  Les composants savent à quel GameObject ils appartiennent - ils peuvent trouver des composants qui sont au même niveau avec eux en interrogeant le GameObject parent. <br></li><li>  La composition ne peut avoir qu'un niveau (les <em>composants ne peuvent pas avoir leurs propres composants enfants, GameObjects ne peut pas avoir de GameObjects enfants</em> ). <br></li><li>  GameObject ne peut avoir qu'un seul composant de chaque type ( <em>dans certains cadres, c'est une exigence obligatoire, dans d'autres non</em> ). <br></li><li>  Chaque composant change (probablement) au fil du temps d'une manière non spécifiée, donc l'interface contient une "mise à jour de vide virtuel". <br></li><li>  Les GameObjects appartiennent à une scène qui peut exécuter des requêtes sur tous les GameObjects (et donc tous les composants). </li></ul><br>  Un concept similaire était très populaire dans les années 2000, et malgré ses limites, il s'est avéré être suffisamment flexible pour créer d'innombrables jeux à l'époque et aujourd'hui. <br><br>  Cependant, cela n'est pas obligatoire.  Votre langage de programmation prend déjà en charge la composition en tant que caractéristique du langage - il n'y a pas besoin d'un concept gonflé pour y accéder ... Pourquoi, alors, ces concepts existent-ils?  Eh bien, pour être honnête, ils vous permettent d'effectuer <em>une composition dynamique lors de l'exécution</em> .  Au lieu de définir durement les types GameObject dans le code, vous pouvez les charger à partir de fichiers de données.  Et c'est très pratique, car cela permet aux concepteurs de jeux / niveaux de créer leurs propres types d'objets ... Cependant, dans la plupart des projets de jeux, il y a très peu de concepteurs et littéralement toute une armée de programmeurs, donc je dirais que c'est une opportunité importante.  Pire encore, ce n'est pas le seul moyen d'implémenter une composition au moment de l'exécution!  Par exemple, Unity utilise C # comme son «langage de script», et de nombreux autres jeux utilisent ses alternatives, par exemple, Lua - un outil pratique pour les concepteurs peut générer du code C # / Lua pour définir de nouveaux objets de jeu sans avoir besoin d'un tel concept gonflé!  Nous allons rajouter cette «fonctionnalité» dans le prochain post, et faire en sorte qu'elle ne nous coûte pas dix fois moins de performances ... <br><br>  Évaluons ce code selon OOD: <br><br><ul><li>  GameObject :: GetComponent utilise dynamic_cast.  La plupart des gens vous diront que dynamic_cast est un «code avec un étranglement», un gros indice que vous avez un bug quelque part.  Je dirais ceci - c'est la preuve que vous avez violé le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">LSP</a> - vous avez une sorte d'algorithme qui fonctionne avec l'interface de base, mais il doit connaître différents détails d'implémentation.  Pour cette raison particulière, le code sent mauvais. <br></li><li>  GameObject, en principe, n'est pas mauvais, si vous imaginez qu'il implémente le modèle «localisateur de service» ... mais si vous allez plus loin que la critique du point de vue d'OOD, ce modèle crée des connexions implicites entre les parties du projet, et je pense ( <em>sans lien vers Wikipedia qui peut prendre en charge moi avec des connaissances en informatique</em> ) que les canaux de communication implicites sont un contre- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">modèle</a> , et ils devraient préférer les canaux de communication explicites.  Le même argument s'applique au "concept d'événements" gonflé qui est parfois utilisé dans les jeux ... <br></li><li>  Je veux déclarer qu'un composant est une violation de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">SRP</a> parce que son interface ( <em>Virtual void Update (time)</em> ) est trop large.  L'utilisation de «Virtual void Update» dans le développement de jeux est omniprésente, mais je dirais également qu'elle est anti-modèle.  Un bon logiciel devrait vous permettre de penser facilement au flux de contrôle et au flux de données.  Placer <em>chaque élément du code de gameplay</em> derrière l'appel "Virtual void Update" obscurcit complètement et complètement le flux de contrôle et le flux de données.  À mon humble avis, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">les effets secondaires</a> invisibles, également appelés <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">effets à</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">longue portée</a> , sont quelques-unes des sources les plus courantes de bogues, et la «mise à jour du vide virtuel» garantit que presque tout sera un effet secondaire invisible. <br></li><li>  Bien que l'objectif de la classe Component soit d'activer la composition, elle le fait par héritage, ce qui constitue une violation de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">CRP</a> . </li><li>  Le seul bon côté de cet exemple est que le code de jeu est exagéré afin de se conformer aux principes de SRP et ISP - il est divisé en de nombreux composants simples avec très peu de responsabilité, ce qui est idéal pour réutiliser le code. <br><br>  Cependant, il n'est pas si bon à maintenir DIP - de nombreux composants ont une connaissance directe les uns des autres. </li></ul><br>  Ainsi, tout le code ci-dessus peut être supprimé.  Toute cette structure.  Supprimez GameObject (dans d'autres frameworks également appelés Entity), supprimez Component, supprimez FindOfType.  Cela fait partie d'une machine virtuelle inutile qui viole les principes OOD et ralentit terriblement notre jeu. <br><br><h1>  Composition sans frameworks (c'est-à-dire en utilisant les fonctionnalités du langage de programmation lui-même) </h1><br>  Si nous supprimons le cadre de composition et que nous n'avons pas la classe de base Composant, comment nos GameObjects parviendront-ils à utiliser la composition et à se composer de composants?  Comme le titre l'indique, au lieu d'écrire cette machine virtuelle gonflée et de créer des GameObjects dans un étrange métalangage par dessus, écrivons-les simplement en C ++ parce que nous sommes des programmeurs de jeux et c'est littéralement notre travail. <br><br>  Voici le commit qui a supprimé le framework Entity / Component: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">https://github.com/hodgman/dod-playground/commit/f42290d0217d700dea2ed002f2f3b1dc45e8c27c</a> <br><br>  Voici la version originale du code source: <a href="" rel="external nofollow">https://github.com/hodgman/dod-playground/blob/3529f232510c95f53112bbfff87df6bbc6aa1fae/source/game.cpp</a> <br><br>  Voici la version modifiée du code source: <a href="" rel="external nofollow">https://github.com/hodgman/dod-playground/blob/f42290d0217d700dea2ed002f2f3b1dc45e8c27c/source/game.cpp</a> <br><br>  En bref sur les changements: <br><br><ul><li>  Suppression de ": Public Component" de chaque type de composant. <br></li><li>  Ajout d'un constructeur à chaque type de composant. <br><ul><li>  OOD consiste principalement à encapsuler l'état d'une classe, mais comme ces classes sont si petites / simples, il n'y a vraiment rien à cacher: l'interface est une description des données.  Cependant, l'une des principales raisons pour lesquelles l'encapsulation est le pilier principal est qu'elle nous permet de garantir la vérité constante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">des invariants de classe</a> ... ou si l'invariant est cassé, il vous suffit d'examiner le code d'implémentation encapsulé pour trouver l'erreur.  Dans cet exemple de code, il vaut la peine d'ajouter des constructeurs pour implémenter un simple invariant - toutes les valeurs doivent être initialisées. </li></ul></li><li>  J'ai renommé les méthodes «générales» trop générales pour que leurs noms reflètent ce qu'elles font réellement - UpdatePosition pour MoveComponent et ResolveCollisions pour EviterComponent. <br></li><li>  J'ai supprimé trois blocs de code codés en dur qui ressemblaient à un modèle / préfabriqué - le code qui crée un GameObject contenant des types spécifiques de composant, et je l'ai remplacé par trois classes C ++. <br></li><li>  Élimination de la "mise à jour du vide virtuel". <br></li><li>  Au lieu que les composants se recherchent via le modèle de «localisateur de services», le jeu les lie explicitement lors de la construction. </li></ul><br><h2>  Les objets </h2><br>  Par conséquent, au lieu de ce code "machine virtuelle": <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// create regular objects that move for (auto i = 0; i &lt; kObjectCount; ++i) { GameObject* go = new GameObject("object"); // position it within world bounds PositionComponent* pos = new PositionComponent(); pos-&gt;x = RandomFloat(bounds-&gt;xMin, bounds-&gt;xMax); pos-&gt;y = RandomFloat(bounds-&gt;yMin, bounds-&gt;yMax); go-&gt;AddComponent(pos); // setup a sprite for it (random sprite index from first 5), and initial white color SpriteComponent* sprite = new SpriteComponent(); sprite-&gt;colorR = 1.0f; sprite-&gt;colorG = 1.0f; sprite-&gt;colorB = 1.0f; sprite-&gt;spriteIndex = rand() % 5; sprite-&gt;scale = 1.0f; go-&gt;AddComponent(sprite); // make it move MoveComponent* move = new MoveComponent(0.5f, 0.7f); go-&gt;AddComponent(move); // make it avoid the bubble things AvoidComponent* avoid = new AvoidComponent(); go-&gt;AddComponent(avoid); s_Objects.emplace_back(go); }</span></span></code> </pre> <br>  Nous avons maintenant du code C ++ normal: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegularObject</span></span></span><span class="hljs-class"> {</span></span> PositionComponent pos; SpriteComponent sprite; MoveComponent move; AvoidComponent avoid; RegularObject(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> WorldBoundsComponent&amp; bounds) : move(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.7f</span></span>) <span class="hljs-comment"><span class="hljs-comment">// position it within world bounds , pos(RandomFloat(bounds.xMin, bounds.xMax), RandomFloat(bounds.yMin, bounds.yMax)) // setup a sprite for it (random sprite index from first 5), and initial white color , sprite(1.0f, 1.0f, 1.0f, rand() % 5, 1.0f) { } }; ... // create regular objects that move regularObject.reserve(kObjectCount); for (auto i = 0; i &lt; kObjectCount; ++i) regularObject.emplace_back(bounds);</span></span></code> </pre> <br><h2>  Des algorithmes </h2><br>  Un autre changement majeur a été apporté aux algorithmes.  Rappelez-vous, au début, j'ai dit que les interfaces et les algorithmes fonctionnent en symbiose et devraient s'influencer mutuellement.  Ainsi, l'anti-modèle " <em>Virtual void Update</em> " est devenu l'ennemi ici aussi.  Le code initial contient l'algorithme de boucle principale, composé uniquement de ceci: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// go through all objects for (auto go : s_Objects) { // Update all their components go-&gt;Update(time, deltaTime);</span></span></code> </pre> <br>  Vous pouvez dire que c'est beau et simple, mais à mon humble avis, c'est très, très mauvais.  Cela obscurcit complètement le <em>flux de</em> <em>contrôle</em> et le <em>flux de données</em> dans le jeu.  Si nous voulons être en mesure de comprendre notre logiciel, si nous voulons le soutenir, si nous voulons lui ajouter de nouvelles choses, l'optimiser, l'exécuter efficacement sur plusieurs cœurs de processeur, alors nous devons comprendre à la fois le flux de contrôle et le flux de données.  Par conséquent, "Virtual void Update" doit être mis à feu. <br><br>  Au lieu de cela, nous avons créé une boucle principale plus explicite, ce qui simplifie considérablement la compréhension du flux de contrôle (le <em>flux de données qu'il contient est toujours obscurci, mais nous corrigerons cela dans les validations suivantes</em> ). <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Update all positions for (auto&amp; go : s_game-&gt;regularObject) { UpdatePosition(deltaTime, go, s_game-&gt;bounds.wb); } for (auto&amp; go : s_game-&gt;avoidThis) { UpdatePosition(deltaTime, go, s_game-&gt;bounds.wb); } // Resolve all collisions for (auto&amp; go : s_game-&gt;regularObject) { ResolveCollisions(deltaTime, go, s_game-&gt;avoidThis); }</span></span></code> </pre> <br>  L'inconvénient de ce style est que pour <em>chaque nouveau type d'objet</em> ajouté au jeu, nous devons ajouter plusieurs lignes à la boucle principale.  J'y reviendrai dans un prochain article de cette série. <br><br><h1>  Performances </h1><br>  Il y a beaucoup d'énormes violations d'OOD, de mauvaises décisions sont prises lors du choix d'une structure, et il existe de nombreuses opportunités d'optimisation, mais j'y reviendrai dans le prochain post de la série.  Cependant, déjà à ce stade, il est clair que la version avec "OOD fixe" correspond presque complètement ou gagne le code final "ECS" à la fin de la présentation ... Et tout ce que nous avons fait, c'est simplement prendre le mauvais code pseudo-OOP et le faire respecter les principes OOP (et aussi supprimé une centaine de lignes de code)! <br><br><div style="text-align:center;"><img alt="img" src="https://habrastorage.org/getpro/habr/post_images/d22/8c2/d99/d228c2d99b9b17da94979d7fc5f728ee.png"></div><br><h1>  Prochaines étapes </h1><br>  Ici, je veux considérer un éventail beaucoup plus large de problèmes, y compris la résolution des problèmes OOD restants, les objets immuables ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">programmation dans un style fonctionnel</a> ) et les avantages qu'ils peuvent apporter dans les discussions sur les flux de données, le passage de messages, l'application de la logique DOD à notre code OOD, appliquer la sagesse pertinente dans le code OOD, supprimer ces classes «d'entités» avec lesquelles nous nous sommes retrouvés et utiliser uniquement des composants purs, utiliser différents styles pour connecter les composants (comparer les pointeurs et  la responsabilité de l' exécution) des composants de conteneurs du monde réel, la version ECS-révision pour une meilleure optimisation, ainsi que une optimisation plus poussée, ne figure pas dans le rapport Aras <em>(comme le multi-threading / SIMD).</em>  L'ordre ne sera pas nécessairement celui-ci, et je ne considérerai peut-être pas tout ce qui précède ... <br><br><h1>  Addition </h1><br>  Les liens vers l'article se sont répandus au-delà des cercles des développeurs de jeux, donc j'ajouterai: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external nofollow">ECS</a> " ( <em>cet article Wikipedia est mauvais, en passant, il combine les concepts d'EC et d'ECS, et ce n'est pas la même chose ...</em> ) - c'est un faux modèle circulant au sein des communautés développeurs de jeux.  En fait, il s'agit d'une version du modèle relationnel dans lequel les «entités» ne sont que des identifiants qui désignent un objet informe, les «composants» sont des lignes dans des tableaux spécifiques qui font référence aux identifiants et les «systèmes» sont du code procédural qui peut modifier les composants .  Ce «modèle» a toujours été positionné comme une solution au problème de l'application excessive de l'héritage, mais il n'est pas mentionné qu'une application excessive de l'héritage viole en fait les recommandations de la POO.  D'où mon indignation.  Ce n'est pas la «seule vraie façon» d'écrire des logiciels.  Le message est conçu pour s'assurer que les gens apprennent réellement les principes de conception existants. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr441174/">https://habr.com/ru/post/fr441174/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr441158/index.html">Comment l'éthique est devenue le problème le plus cher de la Silicon Valley et la philosophie est devenue sa solution la plus pratique</a></li>
<li><a href="../fr441160/index.html">Comment apprendre à savoir quand dire non</a></li>
<li><a href="../fr441166/index.html">Nous obtenons le mot de passe principal du gestionnaire de mots de passe verrouillé 1 Mot de passe 4</a></li>
<li><a href="../fr441168/index.html">QUIC DataChannels: premières étapes</a></li>
<li><a href="../fr441172/index.html">Comment le marché de l'impression 3D a augmenté en 2018 et ce que cela signifie pour les entreprises</a></li>
<li><a href="../fr441180/index.html">Nuageux avec une chance de publicité non désactivable dans le ciel étoilé</a></li>
<li><a href="../fr441182/index.html">Approche synesthésique de la machine pour détecter les attaques DDoS réseau. 2e partie</a></li>
<li><a href="../fr441184/index.html">La première conférence de jeu Mail.ru Group</a></li>
<li><a href="../fr441186/index.html">Visionneuse ASH: redémarrage</a></li>
<li><a href="../fr441192/index.html">Utiliser la puissance de calcul de R pour tester l'hypothèse d'égalité des moyens</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>