<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎂 🤰🏽 🚣🏽 Demistifikasi prinsip-prinsip komputasi kuantum 👨🏾‍🏭 🤴🏼 👩🏿‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Saya pikir saya bisa mengatakan bahwa tidak ada yang mengerti mekanika kuantum," kata Richard Feynman 

 Topik komputasi kuantum selalu menarik penul...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Demistifikasi prinsip-prinsip komputasi kuantum</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/476444/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cc/7de/0de/1cc7de0de64ab4691f4d12f2b54a51ab.png" width="400"></div><br>  "Saya pikir saya bisa mengatakan bahwa tidak ada yang mengerti mekanika kuantum," kata Richard Feynman <br><br>  Topik komputasi kuantum selalu menarik penulis teknis dan jurnalis.  Potensi dan kompleksitas komputasinya memberinya semacam lingkaran mistis.  Terlalu sering artikel tematik dan infografis menjelaskan secara rinci semua jenis prospek untuk industri ini, sementara hampir tidak menyentuh masalah penerapan praktisnya: ini mungkin menyesatkan pembaca yang tidak terlalu berhati-hati. <br><a name="habracut"></a><br>  Dalam artikel sains populer, deskripsi sistem kuantum dihilangkan dan pernyataan seperti: <br><br>  <i>Bit reguler dapat sama dengan "1" atau "0", tetapi qubit dapat secara bersamaan sama dengan "1" dan "0".</i> <br><br>  Jika Anda sangat beruntung (yang saya tidak yakin), maka mereka akan memberi tahu Anda bahwa: <br><br>  <i>Qubit berada dalam superposisi antara "1" dan "0".</i> <br><br>  Tidak satu pun dari penjelasan ini yang masuk akal, karena kami mencoba merumuskan fenomena kuantum-mekanis menggunakan alat bahasa yang dibuat dalam dunia yang sangat tradisional.  Untuk menjelaskan dengan jelas prinsip-prinsip komputasi kuantum, perlu menggunakan bahasa lain - matematika. <br><br>  Dalam panduan ini, saya akan berbicara tentang alat matematika yang diperlukan untuk memodelkan dan memahami sistem komputasi kuantum, dan bagaimana mengilustrasikan dan menerapkan logika komputasi kuantum.  Selain itu, saya akan memberikan contoh algoritma kuantum dan memberi tahu apa keunggulannya dibandingkan komputer tradisional. <br><br>  Saya akan melakukan yang terbaik untuk membicarakan semua ini dalam bahasa yang dapat dimengerti, tetapi saya tetap berharap para pembaca artikel ini memiliki ide dasar tentang aljabar linier dan logika digital (aljabar linier dijelaskan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , logika digital ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ). <br><br>  Untuk memulai, mari kita membahas prinsip-prinsip logika digital.  Ini didasarkan pada penggunaan sirkuit listrik untuk perhitungan.  Untuk membuat uraian kami lebih abstrak, kami menyederhanakan status kawat menjadi "1" atau "0", yang akan sesuai dengan status "hidup" atau "mati".  Setelah membangun transistor dalam urutan tertentu, kami akan membuat apa yang disebut elemen logika yang mengambil satu atau lebih nilai dari sinyal input dan mengubahnya menjadi sinyal output berdasarkan aturan logika Boolean tertentu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ec/872/e40/4ec872e405490899e02ed8c8c9923055.png"></div><br><h2>  Elemen logika umum dan tabel status </h2><br>  Atas dasar rantai elemen-elemen dasar seperti itu, dimungkinkan untuk membuat elemen-elemen yang lebih kompleks, dan atas dasar rantai elemen-elemen yang lebih kompleks pada akhirnya kita dapat mengandalkan untuk mendapatkan analog dari prosesor sentral dengan tingkat abstrak yang tinggi. <br><br>  Seperti yang saya sebutkan sebelumnya, kita perlu cara untuk memetakan logika digital secara matematis.  Pertama, mari kita perkenalkan logika matematika tradisional.  Menggunakan aljabar linier, bit klasik dengan nilai "1" dan "0" dapat direpresentasikan sebagai dua vektor kolom: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c9c/434/3df/c9c4343df6118928be1a7bca294bbf9b.png" width="200"></div><br>  di mana angka-angka di sebelah kiri adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">notasi</a> vektor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dirac</a> .  Dengan mewakili bit kami dengan cara ini, kami dapat memodelkan operasi logis pada bit menggunakan transformasi vektor.  Harap dicatat: terlepas dari kenyataan bahwa ketika menggunakan dua bit dalam elemen logika, Anda dapat melakukan banyak operasi ("DAN" (DAN), "Tidak" (TIDAK), "Kecualikan Atau" (XOR), dll.), Saat menggunakan satu bit dimungkinkan untuk melakukan hanya empat operasi: konversi identitas, negasi, perhitungan konstanta "0" dan perhitungan konstanta "1".  Selama konversi yang identik, bit tetap tidak berubah, ketika dinegasikan, nilai bit dibalik (dari "0" menjadi "1" atau dari "1" ke "0"), dan perhitungan konstanta "1" atau "0" mengatur bit ke "1" atau "0" terlepas dari nilai sebelumnya. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a8/8bd/c76/7a88bdc760e2f03ffd3da0030335445c.png" width="400"></div><br><div class="scrollable-table"><table><tbody><tr><td>  Identitas <br></td><td>  Transformasi identitas <br></td></tr><tr><td>  Negasi <br></td><td>  Bantahan <br></td></tr><tr><td>  Constant-0 <br></td><td>  Perhitungan konstanta "0" <br></td></tr><tr><td>  Constant-1 <br></td><td>  Perhitungan konstanta "1" <br></td></tr></tbody></table></div><br>  Berdasarkan representasi bit baru kami, sangat mudah untuk melakukan operasi pada bit yang sesuai menggunakan transformasi vektor: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3f/6f4/92d/a3f6f492dc62d70852f3be02a1323a69.png" width="400"></div><br><br>  Sebelum melanjutkan, mari kita lihat konsep <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komputasi reversibel</a> , yang hanya menyiratkan bahwa untuk memastikan reversibilitas suatu operasi atau elemen logis, perlu untuk menentukan daftar nilai sinyal input berdasarkan sinyal output dan nama-nama operasi yang digunakan.  Dengan demikian, kita dapat menyimpulkan bahwa transformasi identitas dan negasi dapat dibalik, tetapi operasi penghitungan konstanta "1" dan "0" tidak.  Karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">keunikan</a> mekanika kuantum, komputer kuantum menggunakan operasi yang dapat dibalik secara eksklusif, itulah sebabnya kami akan fokus pada mereka.  Selanjutnya, kita akan mengonversi elemen ireversibel menjadi yang reversibel untuk memastikan bahwa elemen tersebut dapat digunakan oleh komputer kuantum. <br><br>  Menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">produk tensor dari</a> bit individual, banyak bit dapat direpresentasikan: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21c/07e/a5f/21c07ea5f6329faf6214fcff5fbbcc5e.png" width="400"></div><br>  Sekarang kita memiliki hampir semua konsep matematika yang diperlukan, kita akan beralih ke elemen logika kuantum pertama kita.  Ini adalah operator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CNOT</a> , atau "TIDAK" yang dikendalikan, yang sangat penting dalam komputasi reversibel dan kuantum.  Elemen CNOT diterapkan pada dua bit dan mengembalikan dua bit.  Bit pertama ditugaskan sebagai "kontrol", dan yang kedua - "kontrol".  Jika bit kontrol diatur ke "1", bit kontrol mengubah nilainya;  jika bit kontrol diatur ke “0”, bit kontrol tidak berubah. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2e/55a/f27/f2e55af2760a72e7389a1ce0777cc216.png"></div><br>  Operator ini dapat direpresentasikan sebagai vektor transformasi berikut: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c18/c12/c0a/c18c12c0a3d170ae5d6cc02726f9e24a.png"></div><br>  Untuk mendemonstrasikan semua yang telah kita bahas, saya akan menunjukkan kepada Anda bagaimana menggunakan elemen CNOT sehubungan dengan banyak bit: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdb/1f0/ef0/bdb1f0ef078a62a045af5a3432ff5eaa.png"></div><br>  Kami meringkas apa yang telah dikatakan: dalam contoh pertama, kami menguraikan | 10⟩ menjadi bagian-bagian dari produk tensornya dan menggunakan matriks CNOT untuk mendapatkan keadaan produk yang sesuai baru;  maka kita faktor ke | 11⟩ sesuai dengan tabel nilai CNOT yang diberikan sebelumnya. <br><br>  Jadi, kami mengingat semua aturan matematika yang akan membantu kami menangani perhitungan tradisional dan bit biasa, dan akhirnya kami dapat beralih ke komputasi kuantum dan qubit modern. <br><br>  Jika Anda membaca di tempat ini, maka saya punya kabar baik untuk Anda: qubit dapat dengan mudah diungkapkan secara matematis.  Secara umum, jika bit klasik (cbit) dapat diatur ke | 1⟩ atau | 0⟩, qubit hanya dalam superposisi dan dapat sama dengan | 0⟩ dan | 1⟩ sebelum pengukuran.  Setelah pengukuran, itu runtuh di | 0⟩ atau | 1⟩.  Dengan kata lain, qubit dapat direpresentasikan sebagai kombinasi linear dari | 0⟩ dan | 1⟩ sesuai dengan rumus di bawah ini: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd7/ec8/e2e/fd7ec8e2e1b3dd8167d584664a4bfa90.png" width="200"></div><br>  di mana <i>a₀</i> dan <i>a₁</i> masing-masing mewakili amplitudo | 0⟩ dan | 1⟩.  Mereka dapat dianggap sebagai "probabilitas kuantum", yang mewakili probabilitas qubit runtuh ke salah satu negara setelah pengukurannya, karena dalam mekanika kuantum objek dalam superposisi runtuh menjadi salah satu keadaan setelah diperbaiki.  Luaskan ekspresi ini dan dapatkan yang berikut: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c80/3ae/a51/c803aea51e4c1afa3d1fb2120f02333b.png" width="200"></div><br>  Untuk menyederhanakan penjelasan saya, saya akan menggunakan gagasan ini dalam artikel ini. <br><br>  Untuk qubit ini, peluang jebol ke <i>a₀</i> setelah pengukuran adalah |  <i>a</i> ₀ | ², dan kemungkinan jatuh menjadi ₁ sama dengan |  <i>a</i> ₁ | ².  Misalnya, untuk qubit berikut: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1a/d62/80d/b1ad6280d3eb193391b69bcd43fa28c7.png" width="200"></div><br>  peluang runtuhnya "1" adalah | 1 / √2 | ², atau ½, yaitu, 50/50. <br><br>  Karena dalam sistem klasik semua probabilitas dalam penjumlahan harus memberikan kesatuan (untuk distribusi probabilitas penuh), kita dapat menyimpulkan bahwa kuadrat dari nilai absolut amplitudo | 0⟩ dan | 1⟩ harus berjumlah satu.  Berdasarkan informasi ini, kita dapat menyusun persamaan berikut: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74e/96b/6aa/74e96b6aa455eaab9c77562b3286648b.png"></div><br>  Jika Anda terbiasa dengan trigonometri, Anda akan melihat bahwa persamaan ini sesuai dengan teorema Pythagoras (a² + b² = c²), yaitu, kita dapat secara grafik mewakili kemungkinan keadaan qubit dalam bentuk titik pada lingkaran unit, yaitu: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/792/666/ef3/792666ef38e24cb8ce453e802f2fac6e.png" width="400"></div><br>  Operator dan elemen logis diterapkan pada qubit dan juga dalam kasus bit klasik - berdasarkan transformasi matriks.  Semua operator matriks reversibel yang kita ingat sampai saat ini, khususnya, CNOT, dapat digunakan untuk bekerja dengan qubit.  Operator matriks semacam itu memungkinkan untuk menggunakan masing-masing amplitudo suatu qubit tanpa mengukur dan menciutkannya.  Biarkan saya memberi Anda contoh menggunakan operator negasi untuk qubit: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa4/8f9/17b/fa48f917b87b850ee63c2d85abc95a83.png"></div><br>  Sebelum kita melanjutkan, saya ingat bahwa amplitudo <i>a</i> ₀ dan ₁ sebenarnya adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bilangan kompleks</a> , sehingga keadaan qubit dapat paling akurat ditampilkan pada unit sphere tiga dimensi, juga dikenal sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sphere Bloch</a> : <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/12c/e7e/1b4/12ce7e1b4211732a27bcf4b9b45d1be4.png" width="400"></div><br>  Namun, untuk menyederhanakan penjelasan, di sini kita membatasi diri pada bilangan real. <br><br>  Tampaknya sudah tiba saatnya untuk membahas beberapa elemen logis yang masuk akal secara eksklusif dalam konteks komputasi kuantum. <br><br>  Salah satu operator yang paling penting adalah "elemen Hadamard": dibutuhkan sedikit dalam keadaan "0" atau "1" dan menempatkannya dalam superposisi yang sesuai dengan kemungkinan 50% untuk menciutkannya menjadi "1" atau "0" setelah pengukuran. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/587/3c7/11c/5873c711c538223c223588bb2767b080.png" width="400"></div><br>  Perhatikan bahwa ada angka negatif di sisi kanan bawah operator Hadamard.  Ini disebabkan oleh fakta bahwa hasil penggunaan operator tergantung pada nilai sinyal input: - | 1⟩ atau | 0⟩, dan oleh karena itu perhitungannya dapat dibalik. <br><br>  Poin penting lain yang terkait dengan elemen Hadamard adalah reversibilitasnya, yaitu dapat mengambil qubit di superposisi yang sesuai dan mengubahnya menjadi | 0⟩ atau | 1⟩. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/803/8e1/e67/8038e1e6747112de2a6f516e42932c5d.png" width="400"></div><br>  Ini sangat penting karena memungkinkan kita untuk berubah dari keadaan kuantum tanpa menentukan keadaan qubit - dan, dengan demikian, tanpa menciutkannya.  Jadi, kita dapat menyusun komputasi kuantum berdasarkan prinsip deterministik dan bukan probabilistik. <br><br>  Operator kuantum yang berisi bilangan real eksklusif adalah kebalikannya, sehingga kami dapat menyajikan hasil penerapan operator ke qubit sebagai transformasi dalam lingkaran unit dalam bentuk mesin keadaan: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/505/c91/b24/505c91b2434b2d73e8738fbd31545718.png" width="400"></div><br>  Dengan demikian, qubit, keadaan yang ditunjukkan pada diagram di atas, setelah menerapkan operasi Hadamard dikonversi ke keadaan yang ditunjukkan oleh panah yang sesuai.  Demikian pula, kita dapat membangun mesin negara lain yang akan menggambarkan transformasi qubit menggunakan operator negasi, seperti yang ditunjukkan di atas (juga dikenal sebagai operator negasi Pauli, atau bit inversi), seperti yang ditunjukkan di bawah ini: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/854/3d9/b1b/8543d9b1bf8a155b7a8945d814edfc00.png" width="400"></div><br>  Untuk melakukan operasi yang lebih kompleks dengan qubit kami, Anda dapat menggunakan rantai banyak operator atau menerapkan elemen berkali-kali.  Contoh transformasi serial berdasarkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">representasi rantai kuantum adalah</a> sebagai berikut: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/134/ef3/1cb/134ef31cb001fc1c9ff3c3854d32838b.png"></div><br>  Yaitu, jika kita mulai dengan bit | 0⟩, menerapkan kebalikan dari bit, dan kemudian operasi Hadamard, lalu inversi bit lain, dan lagi operasi Hadamard, setelah inversi bit terakhir, kita mendapatkan vektor di sisi kanan rantai.  Dengan menempatkan berbagai mesin negara di atas satu sama lain, kita bisa mulai dengan | 0⟩ dan melacak panah berwarna yang sesuai dengan masing-masing transformasi untuk memahami bagaimana semua ini bekerja. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad5/d18/c3f/ad5d18c3f9158b0e90d72403ad04564e.png" width="400"></div><br>  Karena kita sudah sejauh ini, saatnya untuk mempertimbangkan salah satu jenis algoritma kuantum, yaitu algoritma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Deutsch-Joji</a> , dan menunjukkan keunggulannya dibandingkan komputer klasik.  Perlu dicatat bahwa algoritma Deutsch-Yogi sepenuhnya deterministik, yaitu, ia mengembalikan jawaban yang benar dalam 100% kasus (tidak seperti banyak algoritma kuantum lainnya berdasarkan pada penentuan probabilistik qubit). <br><br>  Mari kita bayangkan bahwa Anda memiliki kotak hitam yang berisi fungsi / operator pada satu bit (ingat - ketika menggunakan satu bit, hanya empat operasi yang mungkin: secara identik mengubah, meniadakan, menghitung konstanta "0" dan menghitung konstanta "1").  Fungsi apa yang dilakukan dalam kotak?  Anda tidak tahu yang mana, namun, Anda dapat memilah sebanyak varian nilai input yang Anda inginkan dan mengevaluasi hasilnya pada output. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c5e/f24/938/c5ef249384466b29fb07ea99b2c1b000.png"></div><br>  Berapa banyak sinyal input dan output yang harus didorong melalui kotak hitam untuk mengetahui fungsi mana yang digunakan?  Pikirkan sebentar. <br><br>  Dalam kasus komputer klasik, Anda harus membuat 2 kueri untuk menentukan fungsi yang digunakan.  Misalnya, jika ketika Anda memasukkan "1" kita mendapatkan "0" pada output, menjadi jelas bahwa fungsi untuk menghitung konstanta "0" atau fungsi negasi digunakan, setelah itu Anda harus mengubah nilai sinyal input menjadi "0" dan melihat apa yang terjadi di pintu keluar. <br><br>  Dalam kasus komputer kuantum, Anda juga akan memerlukan dua kueri, karena Anda masih membutuhkan dua nilai output yang berbeda untuk menentukan fungsi persis yang berlaku pada nilai input.  Namun, jika kita merumuskan kembali sedikit pertanyaan, ternyata komputer kuantum masih memiliki keunggulan yang serius: jika Anda ingin mengetahui apakah fungsi yang digunakan adalah konstan atau variabel, keunggulan akan berada di sisi komputer kuantum. <br><br>  Fungsi yang digunakan dalam kotak adalah variabel, jika nilai yang berbeda dari sinyal input memberikan hasil yang berbeda pada output (misalnya, konversi dan inversi bit yang identik), dan jika nilai output tidak berubah terlepas dari nilai input, maka fungsinya konstan (misalnya, menghitung konstanta "1" atau perhitungan konstanta "0"). <br><br>  Dengan menggunakan algoritma kuantum, Anda dapat menentukan apakah fungsi dalam kotak hitam adalah konstan atau variabel berdasarkan hanya satu permintaan.  Tetapi sebelum kita memeriksa secara terperinci bagaimana melakukan ini, kita perlu menemukan cara yang akan memungkinkan kita untuk menyusun masing-masing fungsi ini pada komputer kuantum.  Karena setiap operator kuantum harus dapat dibalik, kami segera menghadapi masalah: fungsi untuk menghitung konstanta "1" dan "0" tidak. <br><br>  Dalam komputasi kuantum, solusi berikut sering digunakan: qubit output tambahan ditambahkan, yang mengembalikan nilai sinyal input yang diterima oleh fungsi. <br><div class="scrollable-table"><table><tbody><tr><td>  Kepada: <br></td><td>  Setelah: <br></td></tr><tr><td><img src="https://habrastorage.org/webt/xi/kq/k3/xikqk3njz-k-xetlo8efjhjsggk.png"><br></td><td><img src="https://habrastorage.org/webt/lj/rq/f9/ljrqf955o6xtubsf9mrrvridfko.png"><br></td></tr></tbody></table></div>  Dengan demikian, kita dapat menentukan nilai input hanya berdasarkan nilai yang diperoleh pada output, dan fungsi menjadi tidak dapat dibalik.  Struktur sirkuit kuantum menciptakan kebutuhan akan bit input tambahan.  Demi mengembangkan operator yang sesuai, kami mengasumsikan bahwa input qubit tambahan diatur ke | 0⟩. <br><br>  Menerapkan representasi yang sama dari rantai kuantum yang kita gunakan sebelumnya, kita akan melihat bagaimana masing-masing dari empat elemen (transformasi identitas, negasi, perhitungan konstanta "0" dan perhitungan konstanta "1") dapat diimplementasikan menggunakan operator kuantum. <br><br>  Misalnya, Anda dapat mengimplementasikan fungsi untuk menghitung konstanta “0”: <br><br>  <b>Perhitungan konstanta "0":</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/395/b09/e52/395b09e5258ce87f8f9a873d573853c2.png"></div><br>  Di sini kita tidak perlu operator sama sekali.  Input qubit pertama (yang kami ambil sama dengan | 0⟩) ​​kembali dengan nilai yang sama, dan nilai input kedua mengembalikan dirinya sendiri - seperti biasa. <br><br>  Dengan fungsi untuk menghitung konstanta "1", situasinya sedikit berbeda: <br><br>  <b>Perhitungan konstanta "1":</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbe/82d/51e/fbe82d51e97a2c5cc8d7b4d5446555c8.png"></div><br>  Karena kami menerima bahwa input qubit pertama selalu diatur ke | 0⟩, sebagai hasil dari penerapan operator inversi bit, ia selalu memberikan satu pada output.  Dan seperti biasa, qubit kedua memberikan nilainya sendiri pada output. <br><br>  Ketika operator transformasi identitas ditampilkan, tugas mulai menjadi lebih rumit.  Inilah cara melakukannya: <br><br>  <b>Transformasi Identitas:</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3bc/a2c/0c9/3bca2c0c97de2080ae979084924569a6.png"></div><br>  Simbol yang digunakan di sini menunjukkan elemen CNOT: garis atas menunjukkan bit kontrol, dan garis bawah menunjukkan bit kontrol.  Biarkan saya mengingatkan Anda bahwa ketika menggunakan operator CNOT, nilai bit kontrol berubah jika bit kontrol | 1⟩, tetapi tetap tidak berubah jika bit kontrol | 0⟩.  Karena kami mengasumsikan bahwa nilai baris atas selalu sama dengan | 0⟩, nilainya selalu ditetapkan ke baris bawah. <br><br>  Demikian pula, kami bertindak dengan operator negasi: <br><br>  <b>Bantahan:</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e0/9ea/05e/3e09ea05eb3aa4509360adb50250a57d.png" width="400"></div><br>  Kami cukup membalikkan bit di akhir jalur output. <br><br>  Sekarang kita telah menemukan presentasi pendahuluan, mari kita lihat kelebihan spesifik dari komputer kuantum daripada komputer tradisional ketika harus menentukan kekonstanan atau variabilitas fungsi yang disembunyikan di dalam kotak hitam menggunakan hanya satu permintaan. <br><br>  Untuk mengatasi masalah ini dengan menggunakan komputasi kuantum dalam satu permintaan, perlu menerjemahkan qubit input menjadi superposisi sebelum dipindahkan ke fungsi, seperti yang ditunjukkan di bawah ini: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e76/ed6/9ca/e76ed69ca877e88a0cc269a5a3a27770.png"></div><br>  Elemen Hadamard diterapkan kembali ke hasil penggunaan fungsi untuk mendapatkan qubit dari superposisi dan membuat algoritma deterministik.  Kami memulai sistem di negara | 00⟩ dan untuk alasan yang akan saya bicarakan sekarang, kami mendapatkan hasilnya | 11⟩ jika fungsi yang digunakan konstan.  Jika fungsi di dalam kotak hitam adalah variabel, maka setelah mengukur sistem mengembalikan hasilnya | 01⟩. <br><br>  Untuk membahas sisa artikel, mari kita beralih ke ilustrasi yang saya tunjukkan sebelumnya: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad5/d18/c3f/ad5d18c3f9158b0e90d72403ad04564e.png" width="400"></div><br>  Menggunakan operator inversi bit, dan kemudian menerapkan elemen Hadamard untuk kedua nilai input yang sama dengan | 0⟩, kami akan memastikan terjemahannya ke dalam superposisi yang sama | 0⟩ dan | 1⟩, yaitu: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a0/f37/764/6a0f37764e197dc76be36173f72b2f7a.png" width="400"></div><br>  Menggunakan contoh mentransfer nilai fungsi ini ke kotak hitam, mudah untuk menunjukkan bahwa kedua fungsi nilai konstan memberikan | 11⟩ ke output. <br><br>  <b>Perhitungan konstanta "0":</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/959/675/2ca/9596752cadbc0194e1883322fed9ba2d.png" width="400"></div><br> ,  ,     «1»     |11⟩,  : <br><br> <b>  «1»:</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd7/628/2d3/bd76282d39512c75f15d30cbc18ade2a.png" width="400"></div><br>  :       |1⟩,  -1² = 1. <br><br>      ,             |01⟩ (    ),     . <br><br> <b> :</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/771/51d/245/77151d245aa16fa8f8832ef4a4026576.png" width="400"></div><br>  CNOT   ,        ,                   CNOT    : <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d11/c25/1ee/d11c251ee0068742d7004e5fe2fe0fe8.png"></div><br>             |01⟩,       : <br><br> <b>:</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/29b/9a3/120/29b9a31201cd3ce106480ba82f40970e.png" width="400"></div><br>  ,     ,       ,    . <br><br><h2>   ? </h2><br>    .     .    ,    , ,           ,   ,            . <br><br>            — , ,       ,      -     (,       !).        — ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a> ,    |0⟩  |1⟩          . <br><br>           , <i></i>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">«   » (An Introduction to Quantum Algorithms)</a>  :     ,         . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id476444/">https://habr.com/ru/post/id476444/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id476428/index.html">Statistik Nginx VTS, Mockify - mock API, Wiremock dan Mockify perbandingan</a></li>
<li><a href="../id476430/index.html">Cara membuat portofolio teknis yang sempurna</a></li>
<li><a href="../id476434/index.html">Kami menulis driver USB untuk perangkat yang ditinggalkan</a></li>
<li><a href="../id476436/index.html">Laporan dari pertemuan pertama di Rusia tentang pengembang robot tentang Sistem Operasi Robot</a></li>
<li><a href="../id476442/index.html">Berikan ruang atau mikrokontroler seperti pengukur frekuensi</a></li>
<li><a href="../id476446/index.html">Jira Plugins: Beberapa Contoh Penemuan Sepeda yang Berhasil</a></li>
<li><a href="../id476448/index.html">Eksplorasi shader pasir dari game Journey</a></li>
<li><a href="../id476450/index.html">Gambaran umum cPanel - konsol berbasis web untuk mengelola situs dan hosting</a></li>
<li><a href="../id476452/index.html">Penyimpanan bernilai kunci, atau bagaimana aplikasi kita menjadi lebih nyaman</a></li>
<li><a href="../id476454/index.html">5G akan datang: perusahaan mana yang akan memastikan pengenalan teknologi baru pada tahun 2020</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>