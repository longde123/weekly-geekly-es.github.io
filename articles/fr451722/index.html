<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚣🏾 👨🏽‍🎨 🕰️ Bibliothèque de widgets asynchrones Qt-async 📄 🤦🏾 🤰🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonne journée à tous. Je veux parler un peu de mon projet qt-async , peut-être qu'il semblera intéressant ou même utile à quelqu'un. 

 L'asynchronie ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bibliothèque de widgets asynchrones Qt-async</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451722/"> Bonne journée à tous.  Je veux parler un peu de mon projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">qt-async</a> , peut-être qu'il semblera intéressant ou même utile à quelqu'un. <br><br>  L'asynchronie et le multithreading font depuis longtemps partie intégrante de la vie quotidienne des développeurs.  De nombreuses langues et bibliothèques modernes sont conçues pour une utilisation asynchrone.  Le langage C ++ évolue également lentement dans cette direction - std :: thread, std :: promise / future sont apparus, ils sont sur le point d'apporter des coroutines et des réseaux.  La bibliothèque Qt n'est pas en reste, offrant ses analogues QThread, QRunnable, QThreadPool, QFuture, etc.  En même temps, je n'ai pas trouvé de widgets pour afficher des actions asynchrones dans Qt (peut-être que je regardais mal, correct si je me trompe). <br><br>  J'ai donc décidé de combler cette lacune et d'essayer de mettre en œuvre un tel widget moi-même.  Le développement multithread est une entreprise complexe mais intéressante. <br><a name="habracut"></a><br>  Avant de procéder à l'implémentation du widget, vous devez décrire le modèle qu'il présentera à l'utilisateur sous forme de fenêtre.  Dans sa forme la plus générale, le fonctionnement du widget me semble être le suivant: à un moment donné, l'utilisateur ou le système démarre une opération asynchrone.  À ce stade, le widget affiche la progression de l'opération ou simplement une indication de l'opération.  Facultativement, l'utilisateur a la possibilité d'annuler l'opération.  Ensuite, l'opération asynchrone se termine de deux manières: soit une erreur s'est produite et notre widget l'affiche, soit le widget affiche le résultat de l'opération réussie. <br><br>  Ainsi, notre modèle peut être dans l'un des trois états suivants: <br><br><ol><li>  Progression - une opération asynchrone est en cours </li><li>  Erreur - échec de l'opération asynchrone </li><li>  Valeur - opération asynchrone terminée avec succès </li></ol><br>  Dans chacun des états, le modèle doit stocker les données correspondantes, j'ai donc appelé le modèle AsyncValue.  Il est important de noter que le fonctionnement asynchrone lui-même ne fait pas partie de notre modèle, il ne fait que changer son état.  Il s'avère que AsyncValue peut être utilisé avec n'importe quelle bibliothèque asynchrone, en observant un modèle d'utilisation simple: <br><br><ol><li>  Au début de l'opération asynchrone, définissez AsuncValue sur Progress </li><li>  À la fin - soit en erreur, soit en valeur, selon le succès de l'opération </li><li>  Facultativement, pendant l'opération, vous pouvez mettre à jour les données de progression et écouter l'indicateur Stop si l'utilisateur a la possibilité d'arrêter l'opération. </li></ol><br>  Voici un exemple schématique utilisant QRunnable: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyRunnable</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QRunnable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MyRunnable(AsyncValue&amp; value) : m_value(value) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> final </span></span>{ m_value.setProgress(...); <span class="hljs-comment"><span class="hljs-comment">// do calculation if (success) m_value.setValue(...); else m_value.setError(...); } private: AsyncValue&amp; m_value; }</span></span></code> </pre> <br>  Le même schéma pour travailler avec std :: thread: <br><br><pre> <code class="cpp hljs">AsyncValue value; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">thread </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([&amp;value] () { value.setProgress(...); </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">// do calculation if (success) value.setValue(...); else value.setError(...); });</span></span></span></span></span></span></code> </pre><br>  Ainsi, la première version de notre classe pourrait ressembler à ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ValueType_t, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ErrorType_t, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ProgressType_t&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncValue</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ValueType = ValueType_t; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ErrorType = ErrorType_t; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ProgressType = ProgressType_t; <span class="hljs-comment"><span class="hljs-comment">// public API private: QReadWriteLock m_lock; std::variant&lt;ValueType, ErrorType, ProgressType&gt; m_value; };</span></span></code> </pre><br>  Tous ceux qui rencontrent des classes qui prennent en charge le multithreading savent que l'interface de ces classes est différente des analogues à thread unique.  Par exemple, la fonction size () est inutile et dangereuse dans un vecteur multi-thread.  Son résultat peut devenir immédiatement invalide, puisque le vecteur peut être modifié en ce moment dans un autre thread. <br><br>  Les utilisateurs de la classe AsyncValue doivent pouvoir accéder aux données de classe.  L'émission d'une copie des données peut être coûteuse, tous les types ValueType / ErrorType / ProgressType peuvent être lourds.  L'émission d'un lien vers des données internes est dangereuse - à tout moment, elle peut devenir invalide.  La solution suivante est proposée: <br><br>  1. Donnez accès aux données via les fonctions accessValue / accessError / accessProgress, dans lesquelles sont reçues les lambdas qui reçoivent les données correspondantes.  Par exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Pred&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accessValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Pred valuePred)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">QReadLocker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">locker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;m_lock)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_value.index() != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; valuePred(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(m_value)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br>  Ainsi, l'accès à la valeur interne s'effectue par référence et se trouve sous le verrou de lecture.  Autrement dit, le lien au moment de l'accès ne deviendra pas invalide. <br><br>  2. L'utilisateur AsyncValue dans la fonction accessValue peut se souvenir du lien vers les données internes, à condition qu'il soit abonné au signal stateChanged et qu'après traitement, le signal ne doit plus utiliser ce lien, car  elle deviendra invalide. <br><br>  Dans de telles conditions, le consommateur AsyncValue est toujours garanti d'avoir un accès aux données valide et pratique.  Cette solution a plusieurs conséquences qui affectent l'implémentation de la classe AsyncValue. <br><br>  Tout d'abord, notre classe devrait envoyer un signal lorsqu'un état change, mais en même temps c'est un modèle.  Nous devrons ajouter une classe Qt de base, où nous pourrons déterminer le signal par lequel le widget mettra à jour son contenu, et tous les intéressés mettront à jour les liens vers les données internes. <br><br><pre> <code class="cpp hljs">lass AsyncValueBase : <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QObject { <span class="hljs-function"><span class="hljs-function">Q_OBJECT </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Q_DISABLE_COPY</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AsyncValueBase)</span></span></span><span class="hljs-function"> signals: </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stateChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; };</code> </pre><br>  Deuxièmement, le moment de l'envoi du signal doit être bloqué pour la lecture (afin que AsyncValue ne puisse pas être modifié jusqu'à ce que tout le monde traite le signal) et, <i>plus important encore</i> , à ce moment-là, il devrait y avoir des liens valides vers des données nouvelles et anciennes.  Parce que dans le processus d'envoi du signal, certains consommateurs AsyncValue utilisent toujours les anciens liens et ceux qui ont traité le signal utilisent les nouveaux. <br><br>  Il s'avère que std :: variant ne nous convient pas et nous devrons stocker des données dans la mémoire dynamique afin que les adresses des nouvelles et anciennes données restent inchangées. <br><br>  Une petite digression. <br><br>  Vous pouvez envisager d'autres implémentations de la classe AsyncValue qui ne nécessitent pas d'allocations dynamiques: <br><br><ol><li>  Ne donnez aux consommateurs que des copies des données internes AsyncValue.  Comme je l'ai écrit plus tôt, une telle solution peut être plus sous-optimale si les données sont volumineuses. </li><li>  Définissez deux signaux au lieu d'un: stateWillChange / stateDidChange.  Obliger les consommateurs à se débarrasser des anciens liens au premier signal et à recevoir de nouveaux liens au second signal.  Ce schéma, il me semble, complique excessivement les consommateurs AsyncValue, car  ils ont des intervalles de temps lorsque l'accès à AsyncValue est refusé. </li></ol><br>  L'implémentation schématique suivante de la fonction setValue est obtenue: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AsyncValue::setValue(...) {  m_lock            {   m_lock          m_lock   }  stateChanged       m_lock   };</code> </pre><br>  Comme vous pouvez le voir, nous devons augmenter le verrou m_lock pour l'écriture et le retourner pour la lecture.  Malheureusement, il n'y a pas un tel support dans la classe QReadWriteLock.  Vous pouvez obtenir la fonctionnalité souhaitée avec une paire de QMutex / QReadWriteLock.  Voici une implémentation de la classe AsyncValue, proche du réel: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   AsyncValue enum class ASYNC_VALUE_STATE { VALUE, ERROR, PROGRESS }; Q_DECLARE_METATYPE(ASYNC_VALUE_STATE); //        class AsyncValueBase : public QObject { Q_OBJECT Q_DISABLE_COPY(AsyncValueBase) signals: void stateChanged(ASYNC_VALUE_STATE state); protected: explicit AsyncValueBase(ASYNC_VALUE_STATE state, QObject* parent = nullptr); //     PromoteToWriteLock/DemoteToReadLock QMutex m_writeLock; QReadWriteLock m_contentLock; //   ASYNC_VALUE_STATE m_state; }; template &lt;typename ValueType_t, typename ErrorType_t, typename ProgressType_t&gt; class AsyncValueTemplate : public AsyncValueBase { //  struct Content { std::unique_ptr&lt;ValueType_t&gt; value; std::unique_ptr&lt;ErrorType_t&gt; error; std::unique_ptr&lt;ProgressType+t&gt; progress; }; Content m_content; public: using ValueType = ValueType_t; using ErrorType = ErrorType_t; using ProgressType = ProgressType_t; //    template &lt;typename... Args&gt; void emplaceValue(Args&amp;&amp; ...arguments) { moveValue(std::make_unique&lt;ValueType&gt;(std::forward&lt;Args&gt;(arguments)...)); } //    void moveValue(std::unique_ptr&lt;ValueType&gt; value) { //       Content oldContent; //   emplaceXXX/moveXXX    QMutexLocker writeLocker(&amp;m_writeLock); { //       QWriteLocker locker(&amp;m_contentLock); //      oldContent = std::move(m_content); //    m_content.value = std::move(value); //    m_state = ASYNC_VALUE_STATE::VALUE; //     } //   emitStateChanged(); //    emplaceXXX/moveXXX  //    } //   value void emplaceError(Args&amp;&amp; ...arguments); void moveError(std::unique_ptr&lt;ErrorType&gt; error); void emplaceProgress(Args&amp;&amp; ...arguments); void moveProgress(std::unique_ptr&lt;ProgressType&gt; progress); template &lt;typename Pred&gt; bool accessValue(Pred valuePred) { //     QReadLocker locker(&amp;m_contentLock); //    if (m_state != ASYNC_VALUE_STATE::VALUE) return false; //      valuePred(*m_content.value); //     return true; } //  accessValue bool accessError(Pred errorPred) bool accessProgress(Pred progressPred) };</span></span></code> </pre><br>  Pour ceux qui ne sont ni fatigués ni perdus, nous continuons. <br><br>  Comme vous pouvez le voir, nous avons des fonctions accessXXX qui n'attendent pas que AsyncValue entre dans l'état correspondant, mais renvoie simplement false.  Il est parfois utile d'attendre de manière synchrone jusqu'à ce qu'une valeur ou une erreur apparaisse dans AsyncValue.  Essentiellement, nous avons besoin d'un analogue de std :: future :: get.  Voici la signature de la fonction: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ValuePred, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ErrorPred&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ValuePred valuePred, ErrorPred errorPred)</span></span></span></span>;</code> </pre><br>  Pour que cette fonction fonctionne, nous avons besoin d'une variable de condition - un objet de synchronisation qui peut être attendu dans un thread et activé dans un autre.  Dans la fonction d'attente, nous devons attendre, et lorsque nous changeons l'état de AsyncValue de Progress en Value ou Error, nous devons informer les serveurs. <br><br>  L'ajout d'un autre champ à la classe AsyncValue, qui est nécessaire dans de rares cas lorsque la fonction d'attente est utilisée, m'a conduit à penser - ce champ peut-il être rendu facultatif?  La réponse est évidente, bien sûr, elle est possible si vous stockez std :: unique_ptr et la créez si nécessaire.  La deuxième question s'est posée - est-il possible de rendre ce champ facultatif et de ne pas faire d'allocations dynamiques.  Peu importe, regardez le code suivant.  L'idée principale est la suivante: le premier appel d'attente crée une structure QWaitCondition sur la pile et écrit son pointeur sur AsyncValue, les appels d'attente suivants vérifient simplement si le pointeur n'est pas vide, utilisez la structure par ce pointeur, si le pointeur est vide, voir ci-dessus pour le premier appel d'attente . <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncValueBase</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QObject { ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Waiter</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//     QWaitCondition waitValue; //   wait quint16 subWaiters = 0; //  wait     QWaitCondition waitSubWaiters; }; //    Waiter* m_waiter = nullptr; }; template &lt;typename ValuePred, typename ErrorPred&gt; void wait(ValuePred valuePred, ErrorPred errorPred) { //   -      if (access(valuePred, errorPred)) return; //  AsyncValue   QMutexLocker writeLocker(&amp;m_writeLock); //     if (access(valuePred, errorPred)) return; //    wait  if (!m_waiter) { //  Waiter   Waiter theWaiter; //       if SCOPE_EXIT { //     wait, //    theWaiter if (m_waiter-&gt;subWaiters &gt; 0) { //    subWaiters   do { m_waiter-&gt;waitSubWaiters.wait(&amp;m_writeLock); } while (m_waiter-&gt;subWaiters != 0); } //   wait  , //       Waiter m_waiter = nullptr; }; //    Waiter  AsyncValue //    wait   m_waiter = &amp;theWaiter; //   AsyncValue     Value  Error //    do { m_waiter-&gt;waitValue.wait(&amp;m_writeLock); } while (!access(valuePred, errorPred)); } //   wait   else { //       else SCOPE_EXIT { //      m_waiter-&gt;subWaiters -= 1; //     -&gt;   wait if (m_waiter-&gt;subWaiters == 0) m_waiter-&gt;waitSubWaiters.wakeAll(); }; //      m_waiter-&gt;subWaiters += 1; //   AsyncValue     Value  Error //    do { m_waiter-&gt;waitValue.wait(&amp;m_writeLock); } while (!access(valuePred, errorPred)); } }</span></span></code> </pre><br>  Comme déjà mentionné, AsyncValue n'a pas de méthode pour le calcul asynchrone afin de ne pas être lié à une bibliothèque spécifique.  Au lieu de cela, des fonctions gratuites sont utilisées qui implémentent l'asynchronie d'une manière ou d'une autre.  Voici un exemple de calcul de AsyncValue sur un pool de threads: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> AsyncValueType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... ProgressArgs&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncValueRunThreadPool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QThreadPool *pool, AsyncValueType&amp; value, Func&amp;&amp; func, ProgressArgs&amp;&amp; ...progressArgs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    auto progress = std::make_unique&lt;typename AsyncValueType::ProgressType&gt;(std::forward&lt;ProgressArgs&gt;(progressArgs)...); //    auto progressPtr = progress.get(); //    AsyncValue if (!value.startProgress(std::move(progress))) return false; QtConcurrent::run(pool, [&amp;value, progressPtr, func = std::forward&lt;Func&gt;(func)](){ SCOPE_EXIT { //     AsyncValue,    value.completeProgress(progressPtr); }; //  AsyncValue func(*progressPtr, value); }); return true; }</span></span></code> </pre><br>  La bibliothèque implémente deux autres fonctions similaires: asyncValueRunNetwork pour le traitement des requêtes réseau et asyncValueRunThread, qui effectue une opération sur un thread nouvellement créé.  Les utilisateurs de bibliothèque peuvent facilement créer leurs propres fonctions et les utiliser pour utiliser les outils asynchrones qu'ils utilisent ailleurs. <br><br>  Pour augmenter la sécurité, la classe AsyncValue a été étendue avec une autre classe de modèle AsyncTrackErrorsPolicy, qui vous permet de répondre à l'utilisation abusive d'AsyncValue.  Par exemple, voici l'implémentation par défaut de la fonction AsyncTrackErrorsPolicy :: inProgressWhileDestruct, qui sera appelée si AsyncValue est détruite pendant l'exécution de l'opération asynchrone: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inProgressWhileDestruct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ Q_ASSERT(<span class="hljs-literal"><span class="hljs-literal">false</span></span> &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Destructing value while it's in progress"</span></span>); }</code> </pre><br>  Quant aux widgets, leur implémentation est assez simple et concise.  AsyncWidget est un conteneur qui contient un widget pour afficher une erreur, une progression ou une valeur en fonction de l'état dans lequel AsyncValue est actuellement. <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> QWidget* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createValueWidgetImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ValueType&amp; value, QWidget* parent)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> QWidget* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createErrorWidgetImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ErrorType&amp; error, QWidget* parent)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> QWidget* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProgressWidgetImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ProgressType&amp; progress, QWidget* parent)</span></span></span></span>;</code> </pre><br>  L'utilisateur est obligé de redéfinir uniquement la première fonction, pour afficher la valeur, les deux autres ont des implémentations par défaut. <br><br>  La bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">qt-async</a> s'est avérée compacte, mais en même temps très utile.  L'utilisation d'AsyncValue / AsyncWidget, où il y avait auparavant des fonctions synchrones et une interface graphique statique, permettra à vos applications de devenir modernes et plus réactives. <br><br>  Pour ceux qui ont lu le bonus jusqu'à la fin - une vidéo de l'application de démonstration <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/aTXOpmVRXq0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr451722/">https://habr.com/ru/post/fr451722/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr451708/index.html">Comment se préparer au contrôle ILV des données personnelles: un guide complet</a></li>
<li><a href="../fr451710/index.html">Internet pour le résident d'été. Nous obtenons la vitesse maximale dans les réseaux 4G. Partie 2. Choisir une antenne externe</a></li>
<li><a href="../fr451716/index.html">Amélioration des performances logicielles avec les outils Intel pour les développeurs. Modélisation numérique des objets astrophysiques</a></li>
<li><a href="../fr451718/index.html">Créer un assistant vocal</a></li>
<li><a href="../fr451720/index.html">Chargement de FIAS dans la base de données sur MSSQLSERVER par des moyens improvisés (SQLXMLBULKLOAD). Comment cela (probablement) n'a pas besoin d'être fait</a></li>
<li><a href="../fr451724/index.html">Skyrmion à skyrmion discord: skyrmions polaires tridimensionnels dans les ferroélastiques</a></li>
<li><a href="../fr451726/index.html">Vous cherchez du travail à l'étranger: 7 conseils simples pour les professionnels de l'informatique</a></li>
<li><a href="../fr451728/index.html">RESTinio est un serveur HTTP asynchrone. Asynchrone</a></li>
<li><a href="../fr451738/index.html">Brève revue de l'article "DeViSE: un modèle d'intégration visuelle et sémantique profonde"</a></li>
<li><a href="../fr451742/index.html">Un jour avant DotNext 2019 Piter. Annonce de diffusion gratuite</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>