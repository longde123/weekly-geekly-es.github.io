<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👞 💙 🧑🏿‍🤝‍🧑🏿 Seluruh kebenaran tentang RTOS dari Colin Walls 😵 👨🏻‍🚒 ⌨️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seluruh kebenaran tentang RTOS. Artikel # 1. 

 Sistem Operasi Real-Time: Pendahuluan 

 Seri artikel ini dikhususkan untuk studi menyeluruh tentang s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Seluruh kebenaran tentang RTOS dari Colin Walls</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414093/"> Seluruh kebenaran tentang RTOS.  Artikel # 1. <br><br>  <b>Sistem Operasi Real-Time: Pendahuluan</b> <br><br>  Seri artikel ini dikhususkan untuk studi menyeluruh tentang semua aspek sistem operasi waktu nyata (RTOS).  Artikel ini ditujukan untuk pengembang yang ingin mengetahui cara kerja RTOS dan cara menggunakannya.  Titik awal akan menjadi diskusi tentang sistem real-time secara umum, dan kemudian kita akan berbicara tentang bagaimana RTOS dapat menyederhanakan implementasi mereka dan membuat kode yang dihasilkan lebih dapat diandalkan. <br><br>  Melihat ke dalam RTOS, kita akan melihat cara kerja penjadwal tugas.  Berkat multithreading, tampaknya CPU melakukan beberapa operasi pada saat bersamaan.  Ini bukan sihir, pemahaman tentang prinsip-prinsip penjadwal tugas tersedia bahkan untuk insinyur perangkat lunak yang tidak berpengalaman.  Kita akan berbicara tentang objek lain dari RTOS: tentang interaksi antara tugas dan sinkronisasi, tentang mode waktu nyata, tentang manajemen memori, dll., Semuanya akan dijelaskan secara akurat dan didukung oleh contoh kode. <br><a name="habracut"></a><br>  Untuk pengembang, aspek kunci RTOS adalah API, serangkaian panggilan prosedur yang menyediakan akses ke fungsionalitas RTOS.  Seri ini akan menampilkan artikel tentang bagaimana API bekerja, standar apa yang tersedia, dan bagaimana cara berpindah dari satu API ke yang lain. <br><br>  Di bawah ini adalah daftar topik yang akan kami pertimbangkan dalam waktu dekat: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Struktur program dan waktu nyata</a> </li><li>  Sistem operasi waktu-nyata </li><li>  Tugas dan Perencanaan </li><li>  Interaksi tugas dan sinkronisasi </li><li>  Layanan sistem operasi lain </li><li>  Nucleus SE </li><li>  Perencana </li><li>  Tugasnya </li><li>  Bagian dari memori </li><li>  Sinyal </li><li>  Grup Bendera Acara </li><li>  Semafor </li><li>  Kotak surat </li><li>  Antrian </li><li>  Saluran </li><li>  Waktu sistem </li><li>  Pengatur waktu perangkat lunak </li><li>  Gangguan </li><li>  Diagnostik dan pengecekan kesalahan </li><li>  Inisialisasi dan Peluncuran </li></ul><br>  Rangkaian artikel tidak terikat dengan sistem operasi waktu nyata tertentu, sebagian besar materi berlaku untuk opsi yang tersedia untuk menerapkan RTOS.  Menurut penulis, penggunaan OS komersial siap pakai dengan dukungan yang ada adalah cara kerja yang paling dapat diandalkan dan paling produktif.  Salah satu artikel akan dikhususkan untuk diskusi terperinci tentang topik "make vs buy" dan metodologi lain untuk memilih RTOS. <br><br>  Namun, untuk menjelaskan desain internal RTOS, contoh kode produk nyata, Nucleus SE, digunakan. <br><br>  Sumber: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://www.embedded.com/design/operating-systems/4442729/Introducing--RTOS-Revealed</a> <br><br><h3>  Seluruh kebenaran tentang RTOS.  Artikel # 2 </h3><br>  <b>RTOS: Struktur dan mode waktu-nyata</b> <br>  <b>Struktur program dan waktu nyata</b> <br><br>  Seri artikel ini adalah tentang embedded system dan, khususnya, tentang perangkat lunak yang berjalan pada embedded system.  Mari kita mulai dengan definisi.  Apa itu sistem tertanam?  Pada tahun 1986, ketika saya menulis buku pertama tentang hal ini, istilah seperti itu tidak ada.  Konsep "sistem khusus" atau "sistem mikro" digunakan, tetapi mereka, tentu saja, tidak mencerminkan keseluruhan esensi.  Beberapa tahun kemudian, kata "built-in" mulai digunakan, dan semua spesialis mulai menggunakannya secara aktif. <br><br>  Kembali ke definisi sistem tertanam.  Dalam upaya menjelaskan kepada teman dan keluarga tentang apa yang sedang saya kerjakan, saya datang dengan penjelasan berikut: sistem tertanam adalah setiap perangkat elektronik yang memiliki prosesor, tetapi yang biasanya tidak diterima sebagai komputer. <br><br>  Sistem operasi (OS) selalu ada di komputer;  dalam sistem embedded modern, hanya beberapa jenis OS yang digunakan.  Terlepas dari kenyataan bahwa penggunaan kernel berlaku dalam sistem berperforma tinggi (32- dan 64-bit), dimungkinkan untuk mengambil manfaat dari penggunaannya pada perangkat berdaya rendah.  Fokus artikel ini adalah pada sistem operasi, baik secara umum maupun dengan implementasi spesifik. <br><br>  <b>Mengapa menggunakan sistem operasi sama sekali?</b> <br><br>  Mari kita lihat mengapa sistem operasi pada prinsipnya digunakan.  Ada banyak penjelasan, beberapa di antaranya tergantung pada faktor manusia dan karakteristik teknis.  Saya ingat ceritanya.  Di salah satu kantor kami ada sudut dapur di mana Anda bisa membuat kopi.  Di pintu ada tulisan dengan tulisan: "Tolong jangan tutup pintu."  Di bawahnya, seseorang menulis: "Mengapa tidak?", Yang orang lain menjawab: "Karena."  Versi yang sangat singkat dari frasa "karena kami memberitahu Anda untuk melakukan hal itu."  Untuk alasan yang sama, sistem operasi digunakan pada beberapa sistem, hanya karena itu perlu dilakukan. <br><br>  Penjelasan lain adalah penggunaan aplikasi desktop.  Di mana Anda memulai jika Anda menulis perangkat lunak untuk PC atau Mac?  Anda menyalakan komputer, mulai Windows / Linux atau macOS dan mulai pemrograman.  Memiliki sistem operasi adalah kondisi yang diberikan, dan menyediakan sejumlah layanan yang bermanfaat.  Tidak mungkin Anda akan memutuskan untuk memulai dari awal ketika memprogram bare metal.  Oleh karena itu, tidak mengherankan jika seorang insinyur yang memiliki pengalaman menulis perangkat lunak, tetapi untuk siapa firmware baru, akan bergantung pada keberadaan sistem operasi dalam sistem yang ia kembangkan. <br><br>  Perlu dicatat aspek kunci dari OS desktop yang diketahui pengguna adalah antarmuka pengguna (UI).  Tanyakan kepada seseorang apa itu Windows dan mereka akan menjawab bahwa itu adalah windows, menu, kotak dialog, ikon, tetapi sistem file, komunikasi antar-program dan kemampuan untuk berinteraksi dengan sistem lain hampir tidak disebutkan.  Ini adalah perbedaan utama antara desktop dan sistem tertanam: yang terakhir mungkin tidak memiliki antarmuka pengguna, dan jika ya, itu cukup mudah.  Ini adalah yang pertama dari banyak perbedaan utama: <br><br><ul><li>  Sistem tertanam biasanya menjalankan aplikasi perangkat lunak tunggal dari daya hidup ke daya mati. </li><li>  Sistem tertanam memiliki sumber daya terbatas.  Jumlah memori bisa sangat besar, tetapi bukan fakta bahwa itu dapat diperluas;  Prosesor memiliki daya terbatas. </li><li>  Banyak aplikasi tertanam bekerja secara real time.  Lebih lanjut tentang ini di artikel di bawah ini. </li><li>  Alat pengembangan firmware khusus dan berjalan di komputer host (seperti PC), dan bukan pada sistem target. </li><li>  Memperbarui firmware adalah proses yang rumit.  Meskipun ada peluang yang muncul karena perangkat yang terhubung, pembaruan firmware selama operasi masih bukan norma (tidak seperti pembaruan dan tambalan biasa (tambalan) yang digunakan untuk perangkat lunak desktop). </li></ul><br>  Sebelum kita mempertimbangkan bagaimana membuat struktur aplikasi yang tertanam, kita akan memahami konsep yang digunakan pada komputer untuk menjalankan program menggunakan sistem operasi. <br><br>  Pertama, ada eksekusi program bergaya DOS, ketika program dijalankan secara bergantian. <br><br><img src="https://habrastorage.org/webt/ej/9e/iv/ej9eivyn4rgsnw537us256hmreg.jpeg"><br><br>  Setiap program diluncurkan, diimplementasikan, dan diakhiri.  Kami menggunakan, katakanlah, program 1, lalu program 2, lalu mungkin istirahat, beralih ke program 3, dan kemudian kembali ke program 2. Penggunaan kedua program 2 dimulai lagi: peluncuran tidak dimulai dari tempat kami tinggalkan ini (kecuali dalam kasus di mana aplikasi itu sendiri tidak memberikan kesempatan seperti itu). <br><br>  Setelah DOS, segalanya menjadi sedikit rumit, karena Windows sudah menjadi hal yang biasa.  Menjalankan program bergaya Windows berarti menjalankan banyak program dalam mode multithreaded. <br><br><img src="https://habrastorage.org/webt/wv/rq/ka/wvrqka0aosmshscfa2kd9-inn1y.jpeg"><br><br>  Dalam mode ini, tampaknya program sedang berjalan pada saat yang bersamaan, dan Windows mengendalikan ilusi ini.  Pertama, program 1 dimulai, kemudian pada saat yang sama program 2 dimulai, lalu program 3. Program 2 berakhir, program 1 dan 3 masih berjalan.  Program 3 berakhir, hanya sisa program 1. Nanti, program 2 melanjutkan, dan program 1 berakhir, hanya sisa program 2. Ini adalah program yang realistis ketika Windows digunakan oleh pengguna biasa.  Sistem operasi mengalokasikan sumber daya sehingga semua program menggunakan prosesor dengan benar.  Ini juga menyediakan komunikasi yang mudah antar program (mis. Clipboard) dan mengontrol antarmuka pengguna. <br><br>  Beberapa perangkat portabel memerlukan lebih banyak fleksibilitas daripada yang dapat ditawarkan DOS, tetapi mengingat sumber daya yang terbatas, biaya overhead yang lebih rendah diperlukan daripada Windows.  Akibatnya, kami memiliki eksekusi program dengan gaya iOS, yaitu: <br><br><img src="https://habrastorage.org/webt/sb/zy/3a/sbzy3a8yc8spbyql1snfbly-dle.jpeg"><br><br>  Program diluncurkan satu per satu, tetapi statusnya disimpan secara otomatis sehingga Anda dapat melanjutkan dari tempat yang sama saat menutup.  Misalnya, program 1 dimulai, kemudian berhenti untuk menggunakan program 2, lalu, misalnya, perangkat mati untuk sementara waktu.  Ketika melanjutkan, program 3 dimuat (keadaan program 2 disimpan secara otomatis), dan kemudian pengguna kembali ke program 2, terus bekerja di dalamnya.  Saya mengerti bahwa model pelaksanaan aplikasi iOS jauh lebih rumit daripada yang dijelaskan di atas, namun, deskripsi ini hanya ringkasan singkat dari persepsi awal pengguna. <br><br>  Sebagian besar aplikasi bawaan tidak cocok dengan model di atas.  Sebagai aturan, perangkat memulai program ketika daya dihidupkan dan terus bekerja hanya dengan perangkat lunak ini untuk waktu yang tidak terbatas.  Struktur kode semacam itu harus dipikirkan dengan cermat. <br><br>  <b>Model Firmware</b> <br><br>  Sistem desktop hampir semuanya sama.  Dari sudut pandang program aplikasi, semua komputer pribadi dengan Windows identik.  Sistem tertanam adalah unik: masing-masing berbeda dari yang lain.  Perbedaan dapat bersifat teknis: jenis prosesor, ukuran memori, jumlah perangkat periferal.  Aspek prioritas aplikasi juga dapat berbeda dalam kecepatan, konsumsi energi, keamanan dan keandalan.  Mungkin ada perbedaan komersial yang mempengaruhi harga: volume produksi dan pilihan antara perangkat keras khusus atau standar. <br><br>  Perbedaan-perbedaan ini penting untuk pengembang tertanam.  Misalnya, pilihan alat pengembangan (compiler, debuggers, dll.) Tergantung pada jenis prosesor.  Banyak faktor yang mempengaruhi pilihan sistem operasi atau bahkan keputusan untuk menerapkannya secara prinsip.  Struktur perangkat lunak (model perangkat lunak) harus dipilih dengan cermat untuk setiap aplikasi yang disematkan masing-masing. <br><br>  Tergantung pada persyaratan aplikasi, perangkat lunak yang disematkan mungkin memiliki berbagai struktur dengan tingkat kompleksitas yang berbeda, misalnya: <br><br><img src="https://habrastorage.org/webt/sp/q3/7y/spq37yogargo4kr40r_mqk_4wow.jpeg"><br><br>  Bentuk paling sederhana adalah struktur tertutup di mana urutan tindakan yang sama diulang.  Jika aplikasi ini cukup sederhana sehingga dapat diimplementasikan dengan cara ini, ini sangat ideal: kode sederhana dapat diandalkan dan dimengerti.  Namun, struktur seperti itu sangat sensitif terhadap bagian kode yang dapat memakan waktu prosesor terlalu banyak, yaitu, beberapa perintah dijalankan begitu lama sehingga mereka menunda pelaksanaan tugas aplikasi lainnya.  Selain itu, model ini tidak memiliki skala yang baik: meningkatkan kode dapat menjadi masalah, karena add-on dapat memengaruhi kinerja kode lama. <br><br>  Jika sesuatu yang lebih rumit diperlukan, Anda dapat mencoba untuk menempatkan bagian yang tidak penting dari kode dalam loop utama, dan bagian yang sensitif terhadap waktu dalam interrupt handler (Interrupt Service Routines, ISR).  Tindakan interrupt handler pada dasarnya cukup singkat, hanya melakukan tugas-tugas penting dan menandai bagian-bagian dari loop utama untuk menyelesaikan pekerjaan sesegera mungkin.  Kesulitan dapat muncul ketika perlu untuk mendistribusikan pekerjaan antara loop utama dan pengendali interupsi (serta antara beberapa pengembang). <br><br>  Untuk fleksibilitas aplikasi maksimum, Anda perlu membaginya menjadi beberapa program yang terpisah dan relatif independen (sebut saja tugas atau utas), yang akan dieksekusi dalam mode multi-utas.  Penangan interupsi kecil juga dapat dimasukkan dalam sistem, tetapi mereka terutama akan memberi tahu tugas atau memicu tindakan.  Untuk mencapai ini, Anda memerlukan sistem operasi, atau setidaknya sebuah kernel.  Penggunaan multithreading tidak hanya menyediakan distribusi fungsionalitas yang fleksibel dalam perangkat lunak, tetapi juga memfasilitasi distribusi pekerjaan antar pengembang. <br><br>  <b>Apa itu waktu nyata?</b> <br><br>  Sebelumnya, saya menulis bahwa banyak aplikasi tertanam bekerja secara real time.  Dalam konteks ini, biasanya berbicara tentang sistem operasi waktu-nyata, dan bukan tentang OS sederhana.  Mari kita definisikan terminologinya. <br><br>  “Sistem operasi real-time adalah sistem di mana kebenaran perhitungan tidak hanya bergantung pada kebenaran logis dari perhitungan, tetapi juga pada waktu di mana hasil akan dicapai. <br><br>  Jika batasan waktu sistem tidak terpenuhi, diyakini bahwa kegagalan sistem telah terjadi. " <br><br>  Ciri penting dari sistem semacam itu adalah sifatnya yang dapat diprediksi atau, seperti yang sering mereka katakan, determinisme. <br><br>  Sistem operasi waktu nyata tidak selalu sangat cepat; "waktu nyata" tidak selalu berarti "waktu sangat cepat."  Ini berarti bahwa setiap tindakan yang diperlukan akan diselesaikan pada waktu yang tepat.  Yaitu, cukup cepat, tetapi pada saat yang sama tidak terlalu cepat (yaitu, cukup lambat). <br><br>  RTOS (bila digunakan dengan benar) memberikan kontrol yang sangat tepat atas distribusi waktu prosesor untuk tugas dan, karenanya, membuat aplikasi sepenuhnya deterministik.  Satu-satunya hal yang dapat merusak gambar ini adalah interupsi.  Ada RTOS yang sepenuhnya mengendalikan interupsi.  Tugas mereka adalah mengelola layanan interupsi sebagai bagian dari penjadwal tugas.  Terlepas dari kenyataan bahwa ini harus mengarah pada perilaku yang dapat diprediksi, mekanisme ini cukup rumit dan mengandung biaya overhead yang tinggi. <br><br>  Sebagian besar RTOS memungkinkan pengendali interupsi untuk "mencuri" waktu dari tugas yang sedang dijalankan pada saat interupsi.  Ini, pada gilirannya, memaksa programmer untuk menulis kode interrupt handler sesingkat mungkin.  Akibatnya, kami memiliki kesalahan yang diizinkan secara waktu nyata.  Satu-satunya kesulitan adalah membuat panggilan ke layanan RTOS sebagai bagian dari tugas penangan.  Beberapa panggilan bisa sangat tidak berbahaya, sementara yang lain akan menyebabkan perubahan konteks ketika kembali dari interupsi.  Situasi ini harus ditangani secara khusus, yang dimungkinkan dengan bantuan berbagai RTOS. <br><br>  Sumber: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.embedded.com/design/operating-systems/4442900/Program-structure-and-real-time</a> <br><br>  <i>Ketika kami mengerjakan sistem operasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OSRV MAX</a> real-time kami sendiri <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">(artikel yang sebelumnya diterbitkan tentang hal itu)</a> , tim kami “menemukan” blog Colin Walls, seorang ahli mikroelektronika dan firmware di Mentor Graphics.</i>  <i>Artikel-artikel tampak menarik, menerjemahkannya untuk diri mereka sendiri, tetapi agar tidak "menulis ke meja" mereka memutuskan untuk menerbitkan.</i>  <i>Saya harap mereka juga bermanfaat bagi Anda.</i>  <i>Jika demikian, maka kami berencana untuk menerbitkan semua artikel yang diterjemahkan dalam seri.</i> <br><br>  <i>Tentang Pengarang: Colin Walls telah bekerja di industri elektronik selama lebih dari tiga puluh tahun, mencurahkan sebagian besar waktunya untuk firmware.</i>  <i>Dia sekarang adalah seorang insinyur firmware di Mentor Embedded (sebuah divisi dari Mentor Graphics).</i>  <i>Colin Walls sering berbicara di konferensi dan seminar, penulis berbagai artikel teknis dan dua buku tentang firmware.</i>  <i>Tinggal di Inggris.</i>  <i>Blog profesional Colin: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://blogs.mentor.com/colinwalls</a> , email: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">colin_walls@mentor.com</a></i> <i><br><br></i>  <i>Pasal 3 diterbitkan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini.</a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414093/">https://habr.com/ru/post/id414093/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414081/index.html">Pengembangan Chatbot untuk Facebook Messenger di node.js</a></li>
<li><a href="../id414083/index.html">Musim panas mitap Apache Ignite di St. Petersburg</a></li>
<li><a href="../id414085/index.html">Cara membuat sampel untuk Unified Biometric System dan mengapa itu bisa berbahaya</a></li>
<li><a href="../id414087/index.html">Otomasi segera atau bagaimana bisnis dapat bekerja online hari ini</a></li>
<li><a href="../id414089/index.html">Pemblokiran Telegram ditegakkan oleh keputusan Pengadilan Kota Moskow</a></li>
<li><a href="../id414095/index.html">[Terjemahan] Elasticsearch 6.3.0 dirilis</a></li>
<li><a href="../id414097/index.html">Komputer Apple menutup kerentanan firmware yang ditemukan oleh para pakar Teknologi Positif</a></li>
<li><a href="../id414103/index.html">Buka webinar: "Jaringan saraf untuk tugas farmasi"</a></li>
<li><a href="../id414105/index.html">Memprediksi hasil Piala Dunia 2018 menggunakan algoritma hutan acak</a></li>
<li><a href="../id414109/index.html">Menggunakan Docker untuk Membangun dan Menjalankan Proyek C ++</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>