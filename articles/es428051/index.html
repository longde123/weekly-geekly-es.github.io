<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîë üè≥Ô∏è‚Äçüåà üóª C√≥mo hacer a√∫n m√°s inv√°lidos estados a√∫n m√°s indescriptibles üßî üçó üï¥üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No hace mucho tiempo, se tradujo un art√≠culo en Habr sobre c√≥mo usar los tipos de datos algebraicos para garantizar que los estados incorrectos sean i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo hacer a√∫n m√°s inv√°lidos estados a√∫n m√°s indescriptibles</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428051/"><p>  No hace mucho tiempo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se tradujo un art√≠culo</a> en Habr sobre c√≥mo usar los tipos de datos algebraicos para garantizar que los estados incorrectos sean inexpresables.  Hoy nos fijamos en una forma un poco m√°s generalizada, escalable y segura de expresar lo inexpresable, y Haskell nos ayudar√° en esto. </p><a name="habracut"></a><br><p> En resumen, ese art√≠culo analiza alguna entidad con una direcci√≥n postal y una direcci√≥n de correo electr√≥nico, as√≠ como con la condici√≥n adicional de que debe haber al menos una de estas direcciones.  ¬øC√≥mo se propone expresar esta condici√≥n a nivel de tipo?  Se propone escribir las direcciones de la siguiente manera: </p><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ContactInfo = | EmailOnly <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> EmailContactInfo | PostOnly <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> PostalContactInfo | EmailAndPost <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> EmailContactInfo * PostalContactInfo</code> </pre> <br><p>  ¬øQu√© problemas tiene este enfoque? </p><br><p>  Lo m√°s obvio (y mencionado varias veces en los comentarios sobre ese art√≠culo) es que este enfoque no es escalable en absoluto.  Imagine que no tenemos dos tipos de direcciones, sino tres o cinco, y la condici√≥n de correcci√≥n parece ser "debe haber una direcci√≥n postal, o una direcci√≥n de correo electr√≥nico y una direcci√≥n de oficina, y no debe haber varias direcciones del mismo tipo".  Aquellos que lo deseen pueden escribir el tipo apropiado como ejercicio de autoevaluaci√≥n.  La tarea con un asterisco es reescribir este tipo en el caso de que la condici√≥n sobre la ausencia de duplicados haya desaparecido del TOR. </p><br><h3>  Compartir </h3><br><p>  ¬øC√≥mo resolver este problema?  Tratemos de fantasear.  Primero descomponemos y separamos la clase de direcci√≥n (por ejemplo, correo / correo electr√≥nico / n√∫mero de escritorio en la oficina) y los contenidos correspondientes a esta clase: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrType</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Post</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Email</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Office</span></span></span></span></code> </pre> <br><p>  Todav√≠a no pensaremos en el contenido, porque no hay nada en el TK con la condici√≥n de validez de la lista de direcciones. </p><br><p>  Si verificamos la condici√≥n correspondiente en el tiempo de ejecuci√≥n de alg√∫n constructor de alg√∫n lenguaje OOP ordinario, entonces simplemente escribir√≠amos una funci√≥n como </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">valid</span></span> :: [<span class="hljs-type"><span class="hljs-type">AddrType</span></span>] -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> valid xs = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hasNoDups = nub xs == xs <span class="hljs-comment"><span class="hljs-comment">--      hasPost = Post `elem` xs hasEmail = Email `elem` xs hasOffice = Office `elem` xs in hasNoDups &amp;&amp; (hasPost || (hasEmail &amp;&amp; hasOffice))</span></span></code> </pre> <br><p>  y lanzar√≠a alguna ejecuci√≥n si devuelve <code>False</code> . </p><br><p>  ¬øPodemos verificar una condici√≥n similar con la ayuda de un temporizador, al compilar?  Resulta que s√≠, podemos, si el sistema de tipos del lenguaje es lo suficientemente expresivo, y el resto del art√≠culo elegiremos este enfoque. </p><br><p>  Aqu√≠ los tipos dependientes nos ayudar√°n mucho, y dado que la forma m√°s adecuada de escribir un c√≥digo validado en Haskell es escribirlo primero en Agde o Idris, cambiaremos nuestros zapatos y escribiremos en Idris.  La sintaxis idris est√° bastante cerca de Haskell: por ejemplo, con la funci√≥n mencionada anteriormente, solo necesita cambiar ligeramente la firma: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> : List AddrType -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span></code> </pre> <br><p>  Ahora recuerde que, adem√°s de las clases de direcci√≥n, tambi√©n necesitamos sus contenidos y codificamos la dependencia de los campos en la clase de direcci√≥n como GADT: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrType</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PostFields</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">city</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">street</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Post</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EmailFields</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">email</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Email</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">OfficeFields</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">floor</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">desk</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nat</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Office</span></span></span></span></code> </pre> <br><p>  Es decir, si se nos da un valor de <code>fields</code> tipo <code>AddrFields t</code> , entonces sabemos que <code>t</code> es una <code>AddrType</code> AddrType y que los <code>fields</code> contienen un conjunto de campos correspondientes a esta clase en particular. </p><br><div class="spoiler">  <b class="spoiler_title">Sobre esta publicaci√≥n</b> <div class="spoiler_text"><p>  Esta no es la codificaci√≥n m√°s segura, ya que GADT no tiene que ser inyectiva, y ser√≠a m√°s correcto declarar tres tipos de datos separados <code>PostFields</code> , <code>EmailFields</code> , <code>EmailFields</code> y escribir una funci√≥n </p><br><pre> <code class="hljs pgsql">addrFields : AddrType -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> addrFields Post = PostFields addrFields Email = EmailFields addrFields Office = OfficeFields</code> </pre> <br><p>  pero esto es demasiada escritura, lo que para el prototipo no da una ganancia significativa, y en Haskell para esto todav√≠a hay mecanismos m√°s concisos y agradables. </p></div></div><br><p>  ¬øCu√°l es la direcci√≥n completa en este modelo?  Este es un par de la clase de direcci√≥n y los campos correspondientes: </p><br><pre> <code class="hljs pgsql">Addr : <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> Addr = (t : AddrType ** AddrFields t)</code> </pre> <br><p>  Los fan√°ticos de la teor√≠a de tipos dir√°n que este es un tipo dependiente existencial: si se nos da alg√∫n valor de tipo <code>Addr</code> , entonces esto significa que hay un valor <code>t</code> tipo <code>AddrType</code> y un conjunto correspondiente de campos <code>AddrFields t</code> .  Naturalmente, las direcciones de una clase diferente son del mismo tipo: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">someEmailAddr</span></span> : Addr someEmailAddr = (Email ** EmailFields <span class="hljs-string"><span class="hljs-string">"that</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">@feel</span></span></span><span class="hljs-string">.bro"</span></span>) someOfficeAddr : Addr someOfficeAddr = (Office ** OfficeFields (-<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">762</span></span>)</code> </pre> <br><p>  Adem√°s, si nos <code>EmailFields</code> , entonces la √∫nica clase de direcci√≥n que es adecuada es <code>Email</code> , por lo que puede omitirla, el temporizador la imprimir√° usted mismo: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">someEmailAddr</span></span> : Addr someEmailAddr = (_ ** EmailFields <span class="hljs-string"><span class="hljs-string">"that</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">@feel</span></span></span><span class="hljs-string">.bro"</span></span>) someOfficeAddr : Addr someOfficeAddr = (_ ** OfficeFields (-<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">762</span></span>)</code> </pre> <br><p>  Escribimos una funci√≥n auxiliar que proporciona la lista correspondiente de clases de direcci√≥n de la lista de direcciones, y la generalizamos inmediatamente para trabajar en un functor arbitrario: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">types</span></span> : Functor f =&gt; f Addr -&gt; f AddrType <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> = map fst</code> </pre> <br><p>  Aqu√≠, el tipo de <code>Addr</code> existencial se comporta como una pareja familiar: en particular, puede solicitar su primer componente <code>AddrType</code> (tarea con un asterisco: ¬øpor qu√© no puedo pedir el segundo componente?). </p><br><h4>  Elevar </h4><br><p>  Ahora pasamos a una parte clave de nuestra historia.  Entonces, tenemos una lista de direcciones de <code>List Addr</code> y algunos predicados <code>valid : List AddrType -&gt; Bool</code> , cuya ejecuci√≥n para esta lista queremos garantizar a nivel de tipos.  ¬øC√≥mo los combinamos?  Por supuesto, otro tipo! </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkValidatedAddrList</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prf</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">valid</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">types</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">True</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> lst</span></span></code> </pre> <br><p>  Ahora analizaremos lo que escribimos aqu√≠. </p><br><p>  <code>data ValidatedAddrList : List Addr -&gt; Type where</code> significa que el tipo <code>ValidatedAddrList</code> parametrizado, de hecho, por la lista de direcciones. </p><br><p>  Veamos la firma del √∫nico constructor <code>MkValidatedAddrList</code> de este tipo: <code>(lst : List Addr) -&gt; (prf : valid (types lst) = True) -&gt; ValidatedAddrList lst</code> .  Es decir, toma una lista de direcciones <code>prf</code> y otro argumento <code>prf</code> de tipo <code>valid (types lst) = True</code> .  ¬øQu√© significa este tipo?  Por lo tanto, significa que el valor a la izquierda de <code>=</code> es igual al valor a la derecha de <code>=</code> , es decir, <code>valid (types lst)</code> , de hecho, es verdadero. </p><br><p>  Como funciona  Firma <code>=</code> parece a <code>(x : A) -&gt; (y : B) -&gt; Type</code> .  Es decir, <code>=</code> toma dos valores arbitrarios <code>x</code> e <code>y</code> (posiblemente incluso de diferentes tipos <code>A</code> y <code>B</code> , lo que significa que la desigualdad en el idris es heterog√©nea, y que es algo ambigua desde el punto de vista de la teor√≠a de tipos, pero este es un tema para otra discusi√≥n).  ¬øQu√© demuestra entonces la igualdad?  Y debido al hecho de que el √∫nico constructor <code>=</code> - <code>Refl</code> con una firma de <em>casi</em> <code>(x : A) -&gt; x = x</code> .  Es decir, si tenemos un valor de tipo <code>x = y</code> , entonces sabemos que fue construido usando <code>Refl</code> (porque no hay otros constructores), lo que significa que <code>x</code> es realmente igual a <code>y</code> . </p><br><p>  Tenga en cuenta que esta es la raz√≥n por la cual en Haskell siempre fingiremos, en el mejor de los casos, que estamos probando algo, porque Haskell tiene <code>undefined</code> que habita cualquier tipo, por lo que el argumento anterior no funciona all√≠: para cualquier <code>x</code> , <code>y</code> t√©rmino de tipo <code>x = y</code> podr√≠a crearse a trav√©s de <code>undefined</code> (o a trav√©s de una recursi√≥n infinita, digamos que en general es lo mismo en t√©rminos de teor√≠a de tipos). </p><br><p>  Tambi√©n observamos que la igualdad aqu√≠ no se entiende en el sentido de Haskell <code>Eq</code> o alg√∫n <code>operator==</code> en C ++, sino que es mucho m√°s riguroso: estructural, lo que, simplificando, significa que los dos valores tienen la misma <em>forma</em> .  Es decir, enga√±arlo tan simplemente no funciona.  Pero las cuestiones de igualdad se dibujan tradicionalmente en un art√≠culo separado. </p><br><p>  Para consolidar nuestra comprensi√≥n de la igualdad, escribimos pruebas unitarias para la funci√≥n <code>valid</code> : </p><br><pre> <code class="hljs powershell">testPostValid : valid [<span class="hljs-type"><span class="hljs-type">Post</span></span>] = True testPostValid = Refl testEmptyInvalid : valid [] = False testEmptyInvalid = Refl testDupsInvalid : valid [<span class="hljs-type"><span class="hljs-type">Post</span></span>, <span class="hljs-type"><span class="hljs-type">Post</span></span>] = False testDupsInvalid = Refl testPostEmailValid : valid [<span class="hljs-type"><span class="hljs-type">Post</span></span>, <span class="hljs-type"><span class="hljs-type">Email</span></span>] = True testPostEmailValid = Refl</code> </pre> <br><p>  Estas pruebas son buenas ya que ni siquiera necesita ejecutarlas, es suficiente que el taypcher las verifique.  De hecho, reemplacemos <code>True</code> con <code>False</code> , por ejemplo, en el primero de ellos y veamos qu√© sucede: </p><br><pre> <code class="hljs pgsql">testPostValid : <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> [Post] = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> testPostValid = Refl</code> </pre> <br><p>  Typsekher jura </p><br><p><img src="https://habrastorage.org/webt/l7/to/xm/l7toxmndt6lzzbpmjersntiujfg.png"></p><br><p>  como se esperaba  Genial </p><br><h4>  Simplificar </h4><br><p>  Ahora refactoricemos <code>ValidatedAddrList</code> poco nuestra <code>ValidatedAddrList</code> . </p><br><p>  En primer lugar, el patr√≥n de comparar un cierto valor con <code>True</code> bastante com√∫n, por lo que hay un tipo especial <code>So</code> en el idris para esto: puede tomar <code>So x</code> como sin√≥nimo de <code>x = True</code> .  Arreglemos la definici√≥n de <code>ValidatedAddrList</code> : </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkValidatedAddrList</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prf</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">So</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">valid</span></span></span><span class="hljs-class"> $ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">types</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class">)) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> lst</span></span></code> </pre> <br><p>  Adem√°s, <code>So</code> tiene una conveniente funci√≥n auxiliar para <code>choose</code> , que en esencia eleva la verificaci√≥n al nivel de tipos: </p><br><pre> <code class="hljs pgsql">&gt; :doc choose Data.So.choose : (b : <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; Either (So b) (So (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> b)) <span class="hljs-keyword"><span class="hljs-keyword">Perform</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> analysis <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> a <span class="hljs-type"><span class="hljs-type">Boolean</span></span>, providing clients <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> a So proof</code> </pre> <br><p>  Nos ser√° √∫til cuando escribamos funciones que modifiquen este tipo. </p><br><p>  En segundo lugar, a veces (especialmente en el desarrollo interactivo) idris puede encontrar el valor <code>prf</code> apropiado <code>prf</code> s√≠ solo.  Para que en tales casos no fuera necesario construirlo a mano, hay un az√∫car sint√°ctico correspondiente: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkValidatedAddrList</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class">) -&gt; {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prf</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">So</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">valid</span></span></span><span class="hljs-class"> $ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">types</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class">)} -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> lst</span></span></code> </pre> <br><p>  Las llaves indican que este es un argumento impl√≠cito de que idris intentar√° salir de contexto, y <code>auto</code> significa que √©l tambi√©n intentar√° construirlo √©l mismo. </p><br><p>  Entonces, ¬øqu√© nos da esta nueva <code>ValidatedAddrList</code> ?  Y proporciona una cadena de razonamiento de este tipo: que <code>val</code> sea ‚Äã‚Äãun valor de tipo <code>ValidatedAddrList lst</code> .  Esto significa que <code>lst</code> es una lista de direcciones, y adem√°s, <code>val</code> se cre√≥ utilizando el constructor <code>MkValidatedAddrList</code> , al que pasamos este mismo <code>prf</code> y otro valor <code>prf</code> de tipo <code>So (valid $ types lst)</code> , que es casi <code>valid (types lst) = True</code>  Y para que podamos construir <code>prf</code> , necesitamos, de hecho, demostrar que esta igualdad es v√°lida. </p><br><p>  Y lo m√°s hermoso es que todo esto es comprobado por un tipeador.  S√≠, la verificaci√≥n de validez tendr√° que realizarse en tiempo de ejecuci√≥n (porque las direcciones se pueden leer desde un archivo o desde la red), pero el temporizador se asegurar√° de que esta verificaci√≥n se realice: sin ella, es imposible crear una <code>ValidatedAddrList</code> .  Al menos en idris.  En Haskell, por desgracia. </p><br><h4>  Insertar </h4><br><p>  Para verificar la inevitabilidad de la verificaci√≥n, intente escribir una funci√≥n para agregar una direcci√≥n a la lista.  Primer intento: </p><br><pre> <code class="hljs coffeescript">insert : <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr : Addr)</span></span></span><span class="hljs-function"> -&gt;</span></span> ValidatedAddrList lst -&gt; ValidatedAddrList (addr :: lst) insert addr (MkValidatedAddrList lst) = MkValidatedAddrList (addr :: lst)</code> </pre> <br><p>  No, el verificador de errores da en los dedos (aunque no es muy legible, el costo de la <code>valid</code> demasiado complicado): </p><br><p><img src="https://habrastorage.org/webt/au/oa/6j/auoa6jeo10ucav7rffetqmvylec.png"></p><br><p>  ¬øC√≥mo obtenemos una copia de esto?  No de otra manera que la mencionada <code>choose</code> .  Segundo intento: </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; ValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">choose</span></span> (valid $ types (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> l =&gt; MkValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> r =&gt; ?rhs</code> </pre> <br><p>  Casi typechetsya.  "Casi" porque no est√° claro qu√© sustituir por <code>rhs</code> .  M√°s bien, est√° claro: en este caso, la funci√≥n debe informar de alguna manera un error.  Por lo tanto, debe cambiar la firma y ajustar el valor de retorno, por ejemplo, en <code>Maybe</code> : </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; Maybe (ValidatedAddrList (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">choose</span></span> (valid $ types (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> l =&gt; Just $ MkValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> r =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Nothing</span></span></code> </pre> <br><p>  Esto est√° en mosaico y funciona como deber√≠a. </p><br><p>  Pero ahora surge el siguiente problema no muy obvio, que fue, de hecho, en el art√≠culo original.  El tipo de esta funci√≥n no deja de escribir una implementaci√≥n de este tipo: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; Maybe (ValidatedAddrList (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">Nothing</span></span></code> </pre> <br><p>  Es decir, siempre decimos que no podr√≠amos crear una nueva lista de direcciones.  Typhechaetsya?  Si  ¬øEs correcto?  Bueno, apenas  ¬øSe puede evitar esto? </p><br><p>  Resulta que es posible, y tenemos todas las herramientas necesarias para esto.  Si tiene √©xito, <code>insert</code> devuelve una <code>ValidatedAddrList</code> , que contiene evidencia de este mismo √©xito.  ¬°Agregue simetr√≠a elegante y solicite a la funci√≥n que devuelva tambi√©n una prueba de falla! </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; Either (So (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> $ valid $ types (addr :: lst))) (ValidatedAddrList (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">choose</span></span> (valid $ types (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> l =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> $ MkValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> r =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> r</code> </pre> <br><p>  Ahora no podemos simplemente tomar y siempre devolver <code>Nothing</code> . </p><br><p>  Puede hacer lo mismo para las funciones de eliminaci√≥n de direcciones y similares. </p><br><p>  Veamos c√≥mo se ve todo al final. </p><br><p>  Intentemos crear una lista de direcciones vac√≠a: </p><br><p><img src="https://habrastorage.org/webt/9l/pf/a_/9lpfa_ytfrgfsvxbvy4lkk0a8uy.png"></p><br><p>  Es imposible, una lista vac√≠a no es v√°lida. </p><br><p>  ¬øQu√© tal una lista de solo una direcci√≥n postal? </p><br><p><img src="https://habrastorage.org/webt/au/d2/jq/aud2jqe2malfgrjg2txzsncdom4.png"></p><br><p>  Bien, intentemos insertar la direcci√≥n postal en la lista que ya tiene la direcci√≥n postal: </p><br><p><img src="https://habrastorage.org/webt/xl/cx/ri/xlcxrimioc_dutfysgtdmr2srmc.png"></p><br><p>  Intentemos insertar el correo electr√≥nico: </p><br><p><img src="https://habrastorage.org/webt/sn/1n/zw/sn1nzwqz5erm1vjnq59dkel3zzi.png"></p><br><p>  Al final, todo funciona exactamente como se esperaba. </p><br><p>  Uf  Pens√© que ser√≠an tres l√≠neas, pero result√≥ un poco m√°s.  Entonces, para explorar qu√© tan lejos podemos llegar en Haskell, estaremos en el pr√≥ximo art√≠culo.  Mientras tanto, un poco </p><br><h4>  Reflexionar </h4><br><p>  ¬øCu√°l es, al final, el beneficio de tal decisi√≥n en comparaci√≥n con la que se da en el art√≠culo, al que nos referimos al principio? </p><br><ol><li>  De nuevo, es mucho m√°s escalable.  Las funciones de validaci√≥n complejas son m√°s f√°ciles de escribir. </li><li>  Est√° m√°s aislado.  El c√≥digo del cliente no tiene que saber qu√© hay dentro de la funci√≥n de validaci√≥n, mientras que el formulario <code>ContactInfo</code> del art√≠culo original requiere que est√© vinculado. </li><li>  La l√≥gica de validaci√≥n se escribe en forma de funciones ordinarias y familiares, para que pueda verificarse de inmediato con una lectura reflexiva y probarse con pruebas de tiempo de compilaci√≥n, en lugar de derivar el significado de validaci√≥n de un formulario de tipo de datos que representa un resultado ya verificado. </li><li>  Es posible especificar con mayor precisi√≥n el comportamiento de las funciones que funcionan con el tipo de datos que nos interesa, especialmente en el caso de no pasar la prueba.  Por ejemplo, la <code>insert</code> escrita como resultado es simplemente imposible de escribir <em>incorrectamente</em> .  Del mismo modo, uno podr√≠a escribir <code>insertOrReplace</code> , <code>insertOrIgnore</code> y similares, cuyo comportamiento est√° completamente especificado en el tipo. </li></ol><br><p>  ¬øCu√°l es el beneficio en comparaci√≥n con una soluci√≥n OOP como esa? </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ValidatedAddrListClass</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">public</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">ValidatedAddrListClass</span></span>(std::vector&lt;Addr&gt; addrs) { if (!<span class="hljs-built_in"><span class="hljs-built_in">valid</span></span>(addrs)) throw ValidationError {}; } };</code> </pre> <br><ol><li>  El c√≥digo es m√°s modularizado y seguro.  En el caso anterior, un cheque es una <em>acci√≥n</em> que se verifica una vez y que luego olvidaron.  Todo se basa en la honestidad y el entendimiento de que si tiene un <code>ValidatedAddrListClass</code> , su implementaci√≥n una vez que se verific√≥ all√≠.  El hecho de esta verificaci√≥n de la clase no puede seleccionarse como un cierto valor.  En el caso de un <em>valor de</em> alg√∫n tipo, este valor puede transferirse entre diferentes partes del programa, usarse para construir valores m√°s complejos (por ejemplo, nuevamente, negar esta verificaci√≥n), investigar (ver el siguiente p√°rrafo) y generalmente hacer lo mismo que sol√≠amos hacer. con valores </li><li>  Dichas comprobaciones pueden utilizarse en la coincidencia de patrones (dependientes).  Es cierto que no en el caso de esta funci√≥n <code>valid</code> y no en el caso de idris, es dolorosamente complicado e idris es penosamente aburrido, de modo que la informaci√≥n √∫til para los patrones puede extraerse de la estructura <code>valid</code> .  Sin embargo, <code>valid</code> puede reescribirse en un estilo de coincidencia de patrones un poco m√°s amigable, pero esto est√° m√°s all√° del alcance de este art√≠culo y generalmente no es trivial en s√≠ mismo. </li></ol><br><p>  ¬øCu√°les son las desventajas? </p><br><p>  Solo veo un defecto fundamental grave: <code>valid</code> es una funci√≥n demasiado est√∫pida.  Solo devuelve un bit de informaci√≥n, ya sea que los datos hayan pasado la validaci√≥n o no.  En el caso de los tipos m√°s inteligentes, podr√≠amos lograr algo m√°s interesante. </p><br><p>  Por ejemplo, imagine que el requisito de unicidad de direcciones ha desaparecido de TK.  En este caso, es obvio que agregar una nueva direcci√≥n a la lista de direcciones existente no invalidar√° la lista, por lo que podr√≠amos <em>probar este teorema</em> escribiendo una funci√≥n con el tipo <code>So (valid $ types lst) -&gt; So (valid $ types $ addr :: lst)</code> y √∫selo, por ejemplo, para escribir con seguridad de tipos siempre exitoso </p><br><pre> <code class="hljs coffeescript">insert : <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr : Addr)</span></span></span><span class="hljs-function"> -&gt;</span></span> ValidatedAddrList lst -&gt; ValidatedAddrList (addr :: lst)</code> </pre> <br><p>  Pero, por desgracia, teoremas como la recursividad y la inducci√≥n, y nuestro problema no tiene una estructura inductiva elegante, por lo tanto, en mi opini√≥n, el c√≥digo con roble booleano <code>valid</code> tambi√©n <code>valid</code> bueno. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es428051/">https://habr.com/ru/post/es428051/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es428039/index.html">El gobierno no planea abogar por la neutralidad de la red</a></li>
<li><a href="../es428041/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 336 (22-28 de octubre de 2018)</a></li>
<li><a href="../es428043/index.html">Esperando el sexto, Winamp 5.8: el "secreto" de origen, la posibilidad de la versi√≥n oficial</a></li>
<li><a href="../es428045/index.html">PHP Digest No. 142 (15-29 de octubre de 2018)</a></li>
<li><a href="../es428047/index.html">An√°lisis de rendimiento de servidores WSGI: vuelva a colocar uWSGI en su lugar</a></li>
<li><a href="../es428053/index.html">C√≥mo crear una estrategia de prueba: versi√≥n de ingenieros reales</a></li>
<li><a href="../es428055/index.html">Retrospectiva de startups tecnol√≥gicas. Z3: la primera computadora de retransmisi√≥n</a></li>
<li><a href="../es428057/index.html">Una nueva mirada a la documentaci√≥n de la API y el SDK en Yandex. Conferencia sobre Hyperbaton</a></li>
<li><a href="../es428059/index.html">Conecte el almacenamiento LUN de m√∫ltiples rutas a VMware ESXi y Debian GNU / Linux</a></li>
<li><a href="../es428061/index.html">Gesti√≥n de costes del proyecto con gesti√≥n del valor ganado</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>