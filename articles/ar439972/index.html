<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌁 ♌️ 👩‍⚕️ io_submit: بديل لل epoll لم تسمع به من قبل 😆 🏳️‍🌈 🏴‍☠️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="في الآونة الأخيرة ، تم جذب انتباه المؤلف إلى مقال على LWN حول واجهة kernel جديدة للاستطلاع. يناقش آلية الاقتراع الجديدة في Linux AIO API (واجهة لمعالج...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>io_submit: بديل لل epoll لم تسمع به من قبل</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/439972/" style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/sq/pn/nd/sqpnnd88db_ax0ark-6wxrqkobc.jpeg"><br><br>  في الآونة الأخيرة ، تم جذب انتباه المؤلف إلى مقال على LWN حول واجهة kernel جديدة للاستطلاع.  يناقش آلية الاقتراع الجديدة في Linux AIO API (واجهة لمعالجة الملفات غير المتزامنة) ، والتي تمت إضافتها إلى إصدار kernel 4.18.  الفكرة مثيرة للغاية: يقترح مؤلف التصحيح استخدام Linux AIO API للعمل مع الشبكة. <br><br>  لكن انتظر لحظة!  بعد كل شيء ، تم إنشاء Linux AIO للعمل مع I / O غير المتزامن من قرص لآخر!  الملفات الموجودة على القرص ليست هي نفس اتصالات الشبكة.  هل من الممكن استخدام Linux AIO API للشبكات؟ <br><br>  اتضح ، نعم ، هذا ممكن!  تشرح هذه المقالة كيفية استخدام نقاط القوة في Linux AIO API لإنشاء خوادم شبكة أسرع وأفضل. <br><br>  لكن لنبدأ بشرح ماهية Linux AIO. <br><a name="habracut"></a><br><h1 style=";text-align:right;direction:rtl">  مقدمة لنظام Linux AIO </h1><br>  يوفر Linux AIO الإدخال / الإخراج غير المتزامن من قرص إلى قرص لبرنامج المستخدم. <br><br>  تاريخيا ، على لينكس ، تم حظر جميع عمليات القرص.  إذا اتصلت بـ <code>open()</code> أو <code>read()</code> أو <code>write()</code> أو <code>fsync()</code> ، فسيتوقف الدفق حتى تظهر البيانات <code>fsync()</code> في ذاكرة التخزين المؤقت للقرص.  هذا عادة لا يمثل مشكلة.  إذا لم يكن لديك العديد من عمليات الإدخال / الإخراج والذاكرة الكافية ، فستقوم مكالمات النظام بالتدريج في ملء ذاكرة التخزين المؤقت ، وسيعمل كل شيء بسرعة كافية. <br><br>  يتناقص أداء عمليات الإدخال / الإخراج عندما يكون عددهم كبيرًا بدرجة كافية ، على سبيل المثال ، في حالات قواعد البيانات والوكلاء.  بالنسبة إلى هذه التطبيقات ، من غير المقبول إيقاف العملية بالكامل من أجل انتظار مكالمة نظام <code>read()</code> واحدة. <br><br>  لحل هذه المشكلة ، يمكن للتطبيقات استخدام ثلاث طرق: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  استخدم تجمعات مؤشرات الترابط ووظائف حظر المكالمات في مؤشرات ترابط منفصلة.  هذه هي الطريقة التي يعمل بها POSIX AIO في glibc (لا تخلط بينه وبين Linux AIO).  لمزيد من المعلومات ، راجع <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">وثائق IBM</a> .  هذه هي الطريقة التي حللنا بها المشكلة في Cloudflare: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">نستخدم تجمع</a> مؤشرات <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الترابط</a> للاتصال <code>read()</code> و <code>open()</code> . <br></li><li style=";text-align:right;direction:rtl">  قم <code>posix_fadvise(2)</code> ذاكرة التخزين المؤقت على القرص باستخدام <code>posix_fadvise(2)</code> ونتمنى الأفضل. <br></li><li style=";text-align:right;direction:rtl">  استخدم Linux AIO بالاقتران مع نظام الملفات XFS ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">وفتح الملفات مع علامة O_DIRECT</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">وتجنب المشاكل غير الموثقة</a> . <br></li></ol><br>  ومع ذلك ، فإن أيا من هذه الأساليب مثالية.  حتى Linux AIO ، عند استخدامه بدون تفكير ، يمكن حظره في استدعاء <code>io_submit()</code> .  تم ذكر ذلك مؤخرًا في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مقال</a> آخر <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">حول LWN</a> : <br><blockquote style=";text-align:right;direction:rtl">  "تحتوي واجهة الإدخال / الإخراج غير المتزامنة لنظام Linux على الكثير من النقاد وعدد قليل من المؤيدين ، لكن معظم الناس يتوقعون على الأقل عدم التزامن منه.  في الواقع ، يمكن حظر عملية AIO في النواة لعدد من الأسباب في المواقف التي لا يستطيع فيها مؤشر ترابط الاتصال تحمّلها. " </blockquote>  الآن وقد أصبحنا نعرف نقاط الضعف في Linux AIO API ، دعنا ننظر إلى نقاط قوتها. <br><br><h2 style=";text-align:right;direction:rtl">  برنامج بسيط يستخدم Linux AIO </h2><br>  من أجل استخدام Linux AIO ، عليك أولاً <a href="">تحديد مكالمات النظام الخمسة الضرورية</a> بنفسك - glibc لا توفر لهم. <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  تحتاج أولاً إلى الاتصال بـ <code>io_setup()</code> لتهيئة بنية <code>aio_context</code> .  سيعود kernel بمؤشر غير شفاف إلى الهيكل. <br></li><li style=";text-align:right;direction:rtl">  بعد ذلك ، يمكنك استدعاء <code>io_submit()</code> لإضافة متجه "كتل التحكم في الإدخال / الإخراج" إلى قائمة انتظار المعالجة في شكل بنية iocb هيكلية. <br></li><li style=";text-align:right;direction:rtl">  الآن ، أخيرًا ، يمكننا استدعاء <code>io_getevents()</code> والانتظار للحصول على إجابة منه في شكل متجه لهياكل <code>io_event</code> الهيكلية - نتائج كل من كتل iocb. <br></li></ol><br>  هناك ثمانية أوامر يمكنك استخدامها في iocb.  أمرين للقراءة ، وهما للكتابة ، وخياران fsync ، وأمر POLL ، الذي تمت إضافته في الإصدار kernel 4.18 (الأمر الثامن هو NOOP): <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">IOCB_CMD_PREAD = 0, IOCB_CMD_PWRITE = 1, IOCB_CMD_FSYNC = 2, IOCB_CMD_FDSYNC = 3, IOCB_CMD_POLL = 5,   /* from 4.18 */ IOCB_CMD_NOOP = 6, IOCB_CMD_PREADV = 7, IOCB_CMD_PWRITEV = 8,</code> </pre> <br>  <a href=""><code> iocb</code></a> ، التي يتم تمريرها إلى وظيفة <code>io_submit</code> ، كبيرة جدًا ومصممة للعمل مع القرص.  إليك نسخته المبسطة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">struct iocb { __u64 data;           /* user data */ ... __u16 aio_lio_opcode; /* see IOCB_CMD_ above */ ... __u32 aio_fildes;     /* file descriptor */ __u64 aio_buf;        /* pointer to buffer */ __u64 aio_nbytes;     /* buffer size */ ... }</code> </pre> <br>  بنية <code>io_event</code> الكاملة التي ترجع <code>io_getevents</code> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">struct io_event { __u64  data; /* user data */ __u64  obj; /* pointer to request iocb */ __s64  res; /* result code for this event */ __s64  res2; /* secondary result */ };</code> </pre><br>  <b>مثال</b>  برنامج بسيط يقوم بقراءة الملف / etc / passwd باستخدام Linux AIO API: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">fd = open("/etc/passwd", O_RDONLY); aio_context_t ctx = 0; r = io_setup(128, &amp;ctx); char buf[4096]; struct iocb cb = {.aio_fildes = fd,                 .aio_lio_opcode = IOCB_CMD_PREAD,                 .aio_buf = (uint64_t)buf,                 .aio_nbytes = sizeof(buf)}; struct iocb *list_of_iocb[1] = {&amp;cb}; r = io_submit(ctx, 1, list_of_iocb); struct io_event events[1] = {{0}}; r = io_getevents(ctx, 1, 1, events, NULL); bytes_read = events[0].res; printf("read %lld bytes from /etc/passwd\n", bytes_read);</code> </pre> <br>  المصادر الكاملة متوفرة ، بالطبع ، <a href="">على جيثب</a> .  هنا هو الإخراج الضيق لهذا البرنامج: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">openat(AT_FDCWD, "/etc/passwd", O_RDONLY) io_setup(128, [0x7f4fd60ea000]) io_submit(0x7f4fd60ea000, 1, [{aio_lio_opcode=IOCB_CMD_PREAD, aio_fildes=3, aio_buf=0x7ffc5ff703d0, aio_nbytes=4096, aio_offset=0}]) io_getevents(0x7f4fd60ea000, 1, 1, [{data=0, obj=0x7ffc5ff70390, res=2494, res2=0}], NULL)</code> </pre> <br>  كل شيء سار على ما يرام ، ولكن القراءة من القرص لم تكن متزامنة: تم حظر استدعاء io_submit ونفذت كل العمل ، <code>io_getevents</code> تنفيذ وظيفة <code>io_getevents</code> على الفور.  قد نحاول أن نقرأ بشكل غير متزامن ، ولكن هذا يتطلب علامة O_DIRECT ، والتي تتجاوز عمليات القرص ذاكرة التخزين المؤقت. <br><br>  دعونا توضيح كيفية تأمين <code>io_submit</code> على الملفات العادية.  فيما يلي مثال مشابه يُظهر إخراج الشرائط نتيجة قراءة كتلة 1 جيجابايت من <code>/dev/zero</code> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">io_submit(0x7fe1e800a000, 1, [{aio_lio_opcode=IOCB_CMD_PREAD, aio_fildes=3, aio_buf=0x7fe1a79f4000, aio_nbytes=1073741824, aio_offset=0}]) \   = 1 &lt;0.738380&gt; io_getevents(0x7fe1e800a000, 1, 1, [{data=0, obj=0x7fffb9588910, res=1073741824, res2=0}], NULL) \   = 1 &lt;0.000015&gt;</code> </pre> <br>  أنفقت النواة 738 مللي ثانية على مكالمة <code>io_submit</code> و 15 ns فقط على <code>io_getevents</code> .  يتصرف بشكل مشابه مع اتصالات الشبكة - يتم تنفيذ كل العمل بواسطة <code>io_submit</code> . <br><br><img src="https://habrastorage.org/webt/e6/kw/kf/e6kwkfffjb-qvsfqgfdyl2ibmaq.jpeg"><br>  <a href="">Photo</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Helix84</a> CC / BY-SA / 3.0 <br><br><h2 style=";text-align:right;direction:rtl">  لينكس AIO والشبكة </h2><br>  يكون تطبيق <code>io_submit</code> متحفظًا تمامًا: إذا لم يتم فتح واصف الملف الذي تم تمريره بعلامة O_DIRECT ، فستقوم الدالة ببساطة بحظر الإجراء المحدد وتنفيذه.  في حالة اتصالات الشبكة ، هذا يعني: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  لحظر الاتصالات ، سينتظر IOCV_CMD_PREAD حزمة استجابة ؛ <br></li><li style=";text-align:right;direction:rtl">  للاتصالات غير المحظورة ، سيعود IOCB_CMD_PREAD الكود -11 (EAGAIN). <br></li></ul><br>  يتم استخدام نفس الدلالات أيضًا في استدعاء نظام <code>read()</code> العادي ، لذلك يمكننا القول أن io_submit عند العمل مع اتصالات الشبكة ليست أكثر ذكاءً من مكالمات <code>read() / write()</code> القديمة الجيدة. <br><br>  من المهم ملاحظة أن طلبات <code>iocb</code> تنفيذها بواسطة النواة بالتسلسل. <br><br>  على الرغم من أن Linux AIO لن يساعدنا في عمليات غير متزامنة ، إلا أنه يمكن استخدامه لدمج مكالمات النظام في مجموعات. <br><br>  إذا كان خادم الويب يحتاج إلى إرسال واستقبال البيانات من مئات اتصالات الشبكة ، فإن استخدام <code>io_submit</code> قد يكون فكرة رائعة ، لأنه يتجنب مئات المكالمات وإرسالها.  سيؤدي ذلك إلى تحسين الأداء - لا يعد التبديل من مساحة المستخدم إلى النواة والعكس صحيحًا ، خاصة بعد تطبيق <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تدابير مكافحة Specter و Meltdown</a> . <br><br><table style=";text-align:right;direction:rtl"><tbody><tr><td></td><td align="center">  <b>واحد العازلة</b> <br></td><td align="center">  <b>مخازن متعددة</b> <br></td></tr><tr><td>  واصف ملف واحد <br></td><td>  قراءة () <br></td><td>  readv () <br></td></tr><tr><td>  واصفات الملفات المتعددة <br></td><td>  io_submit + IOCB_CMD_PREAD <br></td><td>  io_submit + IOCB_CMD_PREADV <br></td></tr></tbody></table><br>  لتوضيح تجميع مكالمات النظام في حزم باستخدام <code>io_submit</code> دعنا نكتب برنامجًا صغيرًا يرسل بيانات من اتصال TCP إلى آخر.  في أبسط أشكاله (بدون Linux AIO) ، يبدو مثل هذا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">while True: d = sd1.read(4096) sd2.write(d)</code> </pre> <br>  يمكننا التعبير عن نفس الوظيفة من خلال Linux AIO.  سيكون الرمز في هذه الحالة كما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">struct iocb cb[2] = {{.aio_fildes = sd2,                     .aio_lio_opcode = IOCB_CMD_PWRITE,                     .aio_buf = (uint64_t)&amp;buf[0],                     .aio_nbytes = 0},                    {.aio_fildes = sd1,                    .aio_lio_opcode = IOCB_CMD_PREAD,                    .aio_buf = (uint64_t)&amp;buf[0],                    .aio_nbytes = BUF_SZ}}; struct iocb *list_of_iocb[2] = {&amp;cb[0], &amp;cb[1]}; while(1) { r = io_submit(ctx, 2, list_of_iocb); struct io_event events[2] = {}; r = io_getevents(ctx, 2, 2, events, NULL); cb[0].aio_nbytes = events[1].res; }</code> </pre> <br>  يضيف هذا الرمز وظيفتين إلى <code>io_submit</code> : أولاً طلب كتابة إلى <code>sd2</code> ، ثم طلب قراءة من sd1.  بعد القراءة ، تقوم الشفرة بتصحيح حجم مخزن الكتابة المؤقت وتكرار الحلقة من البداية.  هناك خدعة واحدة: في المرة الأولى التي تحدث فيها الكتابة مع وجود مخزن مؤقت بالحجم 0. يعد ذلك ضروريًا لأن لدينا القدرة على الجمع بين كتابة + قراءة في مكالمة <code>io_submit</code> واحدة (ولكن ليس للقراءة + الكتابة). <br><br>  هل هذا الرمز أسرع من <code>read()</code> العادية <code>read()</code> / <code>write()</code> ؟  ليس بعد.  كلا الإصدارين يستخدمان مكالمات النظام: قراءة + كتابة و io_submit + io_getevents.  ولكن ، لحسن الحظ ، يمكن تحسين الرمز. <br><br><h2 style=";text-align:right;direction:rtl">  التخلص من io_getevents </h2><br>  في وقت التشغيل <code>io_setup()</code> يخصص kernel عدة صفحات من الذاكرة لهذه العملية.  هذه هي الطريقة التي تبدو بها كتلة الذاكرة / خرائط proc //: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">marek:~$ cat /proc/`pidof -s aio_passwd`/maps ... 7f7db8f60000-7f7db8f63000 rw-s 00000000 00:12 2314562     /[aio] (deleted) ...</code> </pre> <br>  تم تخصيص كتلة الذاكرة [aio] (12 كيلو بايت في هذه الحالة) <code>io_setup</code> .  يتم استخدامه للمخزن المؤقت الدائري حيث يتم تخزين الأحداث.  في معظم الحالات ، لا يوجد سبب للاتصال بـ <code>io_getevents</code> - يمكن الحصول على بيانات إكمال الحدث من المخزن المؤقت الحلقي دون الحاجة إلى التبديل إلى وضع kernel.  هنا هو الإصدار الصحيح من الكود: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">int io_getevents(aio_context_t ctx, long min_nr, long max_nr,                struct io_event *events, struct timespec *timeout) {   int i = 0;   struct aio_ring *ring = (struct aio_ring*)ctx;   if (ring == NULL || ring-&gt;magic != AIO_RING_MAGIC) {       goto do_syscall;   }   while (i &lt; max_nr) {       unsigned head = ring-&gt;head;       if (head == ring-&gt;tail) {           /* There are no more completions */           break;       } else {           /* There is another completion to reap */           events[i] = ring-&gt;events[head];           read_barrier();           ring-&gt;head = (head + 1) % ring-&gt;nr;           i++;       }   }   if (i == 0 &amp;&amp; timeout != NULL &amp;&amp; timeout-&gt;tv_sec == 0 &amp;&amp; timeout-&gt;tv_nsec == 0) {       /* Requested non blocking operation. */       return 0;   }   if (i &amp;&amp; i &gt;= min_nr) {       return i;   } do_syscall:   return syscall(__NR_io_getevents, ctx, min_nr-i, max_nr-i, &amp;events[i], timeout); }</code> </pre> <br>  النسخة الكاملة من الكود متاحة <a href="">على جيثب</a> .  تم توثيق واجهة هذا المخزن المؤقت الحلقي بشكل سيئ ؛ قام المؤلف بتكييف الكود من مشروع <a href="">axboe / fio</a> . <br><br>  بعد هذا التغيير ، يتطلب إصدارنا من الكود الذي يستخدم Linux AIO مكالمة نظام واحد فقط في حلقة ، مما يجعله أسرع قليلاً من الكود الأصلي باستخدام read + write. <br><br><img src="https://habrastorage.org/webt/xq/er/7t/xqer7tve9zpg23gh2zfjjl_bb-i.jpeg"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">صور</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">القطار صور</a> CC / BY-SA / 2.0 <br><br><h2 style=";text-align:right;direction:rtl">  Epoll البديل </h2><br>  مع إضافة IOCB_CMD_POLL إلى إصدار kernel 4.18 ، أصبح من الممكن استخدام <code>io_submit</code> كبديل لـ select / poll / epoll.  على سبيل المثال ، يتوقع هذا الرمز بيانات من اتصال الشبكة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">struct iocb cb = {.aio_fildes = sd,                 .aio_lio_opcode = IOCB_CMD_POLL,                 .aio_buf = POLLIN}; struct iocb *list_of_iocb[1] = {&amp;cb}; r = io_submit(ctx, 1, list_of_iocb); r = io_getevents(ctx, 1, 1, events, NULL);</code> </pre><br>  <a href="">كود كامل</a> .  هنا هو ناتج الضيق: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">io_submit(0x7fe44bddd000, 1, [{aio_lio_opcode=IOCB_CMD_POLL, aio_fildes=3}]) \   = 1 &lt;0.000015&gt; io_getevents(0x7fe44bddd000, 1, 1, [{data=0, obj=0x7ffef65c11a8, res=1, res2=0}], NULL) \   = 1 &lt;1.000377&gt;</code> </pre> <br>  كما ترون ، نجحت هذه المرة في عدم التزامن: تم تنفيذ io_submit على الفور ، <code>io_getevents</code> لمدة ثانية واحدة ، في انتظار البيانات.  يمكن استخدام هذا بدلاً من استدعاء النظام <code>epoll_wait()</code> . <br><br>  علاوة على ذلك ، يتطلب العمل مع <code>epoll</code> عادةً استخدام مكالمات النظام epoll_ctl.  ويحاول مطورو التطبيقات تجنب المكالمات المتكررة لهذه الوظيفة - لفهم الأسباب ، ما عليك سوى <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">قراءة</a> إشارات EPOLLONESHOT و EPOLLET <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">في الدليل</a> .  باستخدام io_submit للاستعلام عن الاتصالات ، يمكنك تجنب هذه الصعوبات ومكالمات النظام الإضافية.  فقط أضف الاتصالات إلى متجه iocb ، اتصل بـ io_submit مرة واحدة وانتظر التنفيذ.  كل شيء بسيط جدا. <br><br><h2 style=";text-align:right;direction:rtl">  ملخص </h2><br>  في هذا المنشور ، قمنا بتغطية Linux AIO API.  تم تصميم واجهة برمجة التطبيقات هذه في الأصل للعمل مع القرص ، ولكنها تعمل أيضًا مع اتصالات الشبكة.  ومع ذلك ، بخلاف المكالمات العادية () + write () ، فإن استخدام io_submit يسمح لك بتجميع مكالمات النظام وبالتالي زيادة الأداء. <br><br>  بدءًا من الإصدار kernel 4.18 ، يمكن استخدام <code>io_submit  io_getevents</code> في حالة اتصالات الشبكة لأحداث النموذج POLLIN و POLLOUT.  هذا بديل ل <code>epoll()</code> . <br><br>  أستطيع أن أتخيل خدمة شبكة تستخدم فقط <code>io_submit  io_getevents</code> بدلاً من المجموعة القياسية من القراءة والكتابة و epoll_ctl و epoll_wait.  في هذه الحالة ، يمكن أن تعطي ميزة تجميع نظام المكالمات في <code>io_submit</code> ميزة كبيرة ، سيكون مثل هذا الخادم أسرع بكثير. <br><br>  لسوء الحظ ، حتى بعد التحسينات الأخيرة التي طرأت على Linux AIO API ، تستمر المناقشات حول فائدتها.  من المعروف أن <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">لينوس يكرهه</a> : <br><br><blockquote style=";text-align:right;direction:rtl">  "تعد AIO مثالًا فظيعًا على التصميم المرتفع للركبة ، حيث يكمن العذر الرئيسي في ذلك:" لقد توصل هذا إلى أشخاص آخرين أقل موهبة ، لذلك يتعين علينا الامتثال للتوافق حتى يتمكن مطورو قواعد البيانات (الذين نادراً ما يتذوقون ذلك) من استخدامه. "  لكن AIO كان دائمًا شديد الملل. " </blockquote><br>  بذلت عدة محاولات لإنشاء واجهة أفضل لتجميع المكالمات وعدم التزامن ، لكنها كانت تفتقر إلى رؤية مشتركة.  على سبيل المثال ، تسمح <a href="">الإضافة</a> الحديثة <a href="">لـ sendto (MSG_ZEROCOPY)</a> بنقل بيانات غير متزامن حقًا ، لكنها لا تنص على التجميع.  يوفر <code>io_submit</code> للتجميع ، ولكن ليس التزامن.  والأسوأ من ذلك - هناك حاليًا ثلاث طرق لتقديم أحداث غير متزامنة على Linux: الإشارات و <code>io_getevents</code> و MSG_ERRQUEUE. <br><br>  على أي حال ، من الرائع أن تكون هناك طرق جديدة لتسريع عمل خدمات الشبكة. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar439972/">https://habr.com/ru/post/ar439972/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar439962/index.html">نحن نعمل مع مكتب خدمة Atlassian ، نحصل على أقصى استفادة من المكون الإضافي Riada Insight - تقرير من اجتماع مجموعة مستخدمي Atlassian</a></li>
<li><a href="../ar439964/index.html">Runc CVE-2019-5736 الثغرة الأمنية في مضيف</a></li>
<li><a href="../ar439966/index.html">محلل بسيط للعمليات الحسابية</a></li>
<li><a href="../ar439968/index.html">مساحة الجيل وفرصة الفرص</a></li>
<li><a href="../ar439970/index.html">تقرير عن المشاكل وإمكانية الوصول إلى الإنترنت في 2018-2019</a></li>
<li><a href="../ar439974/index.html">التحول رشيقة الشخصية: رحلة مرنة إلى الإنتاجية</a></li>
<li><a href="../ar439976/index.html">هل ستكون Node.js دائمًا أبطأ من Golang؟</a></li>
<li><a href="../ar439978/index.html">عامل إرساء التعلم ، الجزء 2: الشروط والمفاهيم</a></li>
<li><a href="../ar439980/index.html">تعلم عامل الميناء ، الجزء 3: ملفات Dockerfile</a></li>
<li><a href="../ar439982/index.html">رد فعل تعليمي ، الجزء 16: المرحلة الرابعة من العمل على تطبيق TODO ، معالجة الأحداث</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>