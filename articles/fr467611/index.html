<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¸ğŸ¿ ğŸ‡ğŸ¼ âœŠ Algorithmes de dÃ©tection de contour d'image ğŸ–¤ ğŸ”  ğŸ¤½ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'article prÃ©sente les quatre algorithmes de dÃ©tection de boucle les plus courants. 

 Les deux premiers, Ã  savoir l'algorithme de traÃ§age des carrÃ©s ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algorithmes de dÃ©tection de contour d'image</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467611/">  L'article prÃ©sente les quatre algorithmes de dÃ©tection de boucle les plus courants. <br><br>  Les deux premiers, Ã  savoir l'algorithme de traÃ§age des carrÃ©s et de traÃ§age de l'environnement de Moore, sont faciles Ã  mettre en Å“uvre et sont donc souvent utilisÃ©s pour dÃ©terminer le contour d'un motif donnÃ©.  Malheureusement, les deux algorithmes ont plusieurs faiblesses, ce qui rend <b>impossible la</b> dÃ©tection du contour d'une grande classe de motifs en raison de leur type particulier d'adjacence. <br><br>  Ces algorithmes ignoreront tous les <b><i>Â«trousÂ»</i></b> du motif.  Par exemple, si nous avons un motif similaire Ã  celui montrÃ© sur la <b><i>figure 1</i></b> , alors le circuit dÃ©tectÃ© par les algorithmes sera similaire Ã  celui montrÃ© sur la <b><i>figure 2</i></b> (le contour est indiquÃ© par des pixels bleus).  Dans certains domaines d'application, cela est tout Ã  fait acceptable, mais dans d'autres domaines, par exemple, dans la reconnaissance des caractÃ¨res, il est nÃ©cessaire de dÃ©tecter les parties internes du motif pour trouver tous les espaces qui distinguent un caractÃ¨re particulier.  (La <b><i>figure 3</i></b> montre le contour Â«completÂ» du motif.) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e7/d3b/f5b/0e7d3bf5bc9c451588718fe5d909a2fb.gif" alt="image"></div><br><br>  Par consÃ©quent, pour obtenir un contour complet, il est d'abord nÃ©cessaire d'utiliser l'algorithme de <b><i>Â«recherche de trousÂ»</i></b> qui dÃ©termine les trous dans un motif donnÃ©, puis d'appliquer l'algorithme de dÃ©tection de contour Ã  chaque trou. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb7/22c/32f/cb722c32fcc45aeea8d8b097a0d01f84.gif" alt="image"></div><a name="habracut"></a><br><h2>  Qu'est-ce que la connectivitÃ©? </h2><br>  Dans les images numÃ©riques avec des valeurs binaires, un pixel peut avoir l'une des valeurs suivantes: 1 - lorsqu'il fait partie du motif, ou 0 - lorsqu'il fait partie de l'arriÃ¨re-plan, c'est-Ã -dire  pas de dÃ©gradÃ© de gris.  (Nous supposerons que les pixels avec une valeur de 1 sont noirs et avec une valeur de 0 sont blancs). <br><br>  Pour identifier des <b><i>objets</i></b> dans un motif numÃ©rique, nous devons trouver des groupes de pixels noirs qui sont Â«connectÃ©sÂ» les uns aux autres.  En d'autres termes, les <b><i>objets</i></b> d'un modÃ¨le numÃ©rique donnÃ© sont les <b><i>composants connectÃ©s de</i></b> ce modÃ¨le. <br><br>  Dans le cas gÃ©nÃ©ral, un <b><i>composant connectÃ©</i></b> est un ensemble de pixels noirs <b>P</b> , de telle sorte que pour chaque paire de pixels <b>p <sub>i</sub></b> et <b>p <sub>j</sub></b> dans <b>P</b> il y a une sÃ©quence de pixels <b><i>p <sub>i</sub> , ..., p <sub>j</sub></i></b> tels que: <br><br>  a) tous les pixels de la sÃ©quence sont dans l'ensemble <b>P</b> , c'est-Ã -dire  sont noirs, et <br><br>  b) tous les 2 pixels <b><i>de la sÃ©quence cÃ´te Ã  cÃ´te</i></b> sont des Â«voisinsÂ». <br><br>  Une question importante se pose: <b><i>quand peut-on dire que 2 pixels sont Â«voisinsÂ»?</i></b>  Puisque nous utilisons des pixels carrÃ©s, la rÃ©ponse Ã  la question prÃ©cÃ©dente n'est pas anodine pour la raison suivante: en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pavage carrÃ©, les</a> pixels ont un bord ou un sommet commun, ou n'ont rien en commun.  Chaque pixel a 8 pixels en commun avec lui;  ces pixels constituent le "voisinage de Moore" de ce pixel.  Faut-il considÃ©rer des pixels "voisins" n'ayant qu'un seul sommet commun?  Ou pour Ãªtre considÃ©rÃ©s comme Â«voisinsÂ», deux pixels doivent avoir un bord commun? <br><br>  Il existe donc deux types de connectivitÃ©, Ã  savoir: la connectivitÃ© 4 et la connectivitÃ© 8. <br><br><h4>  4 connexions </h4><br>  Quand peut-on dire qu'un ensemble donnÃ© de pixels noirs est <b><i>connectÃ© Ã  4?</i></b>  Tout d'abord, vous devez dÃ©finir le concept de <b><i>4 voisins</i></b> (Ã©galement appelÃ© <b><i>voisin direct</i></b> ): <br><br>  <b>DÃ©finition 4 voisins</b> : Un pixel <b>Q</b> est un <b><i>4 voisins d'un</i></b> pixel <b>P</b> donnÃ© si <b>Q</b> et <b>P</b> ont un bord commun.  Les 4 voisins du pixel <b>P</b> (dÃ©signÃ©s par <b>P2, P4, P6</b> et <b>P8</b> ) sont reprÃ©sentÃ©s sur la <b><i>figure 2</i></b> ci-dessous. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02b/592/5ef/02b5925eff29a4b14330e63c43714837.gif" height="202" width="177"></div><br>  <b>DÃ©finition d'un composant Ã  4 connexions</b> : l'ensemble des pixels noirs <b>P</b> est un <b><i>composant Ã  4 connexions</i></b> si pour chaque paire de pixels <b>p <sub>i</sub></b> et <b>p <sub>j</sub></b> dans <b>P</b> il y a une sÃ©quence de pixels <b><i>p <sub>i</sub> , ..., p <sub>j</sub></i></b> tels que: <br><br>  a) tous les pixels de la sÃ©quence sont dans l'ensemble <b>P</b> , c'est-Ã -dire  sont noirs, et <br><br>  b) tous les deux pixels <b><i>adjacents dans la sÃ©quence</i></b> sont <b><i>4 voisins</i></b> <br><br><h4>  Exemples de modÃ¨les Ã  4 connexions </h4><br>  Les diagrammes ci-dessous montrent des exemples de modÃ¨les Ã  4 connexions: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b71/3c8/b76/b713c8b761d034fc04d486aed3029149.gif" height="216" width="576"></div><br><br><h4>  8 connexions </h4><br>  Quand puis-je dire qu'un ensemble donnÃ© de pixels noirs est <b><i>connectÃ© Ã  8</i></b> ?  Tout d'abord, nous devons dÃ©finir le concept d'un <b><i>voisin Ã  8</i></b> (Ã©galement appelÃ© <b><i>voisin indirect</i></b> ): <br><br>  <b>DÃ©finition de 8 voisins</b> : Un pixel <b>Q</b> est un <b><i>8 voisins</i></b> (ou juste un <b><i>voisin</i></b> ) d'un pixel <b>P</b> donnÃ© si <b>Q</b> et <b>P</b> ont un bord ou un sommet commun.  Les 8 voisins d'un pixel <b>P</b> constituent le voisinage de Moore de ce pixel. <br><br>  <b>DÃ©finition d'un composant connectÃ© Ã  8</b> : l'ensemble des pixels noirs <b>P</b> est un <b><i>composant connectÃ© Ã  8</i></b> (ou juste un <b><i>composant connectÃ©</i></b> ) si pour chaque paire de pixels <b>p <sub>i</sub></b> et <b>p <sub>j</sub></b> dans <b>P</b> il y a une sÃ©quence de pixels <b><i>p <sub>i</sub> , ..., p <sub>j</sub></i></b> tels que : <br><br>  a) tous les pixels de la sÃ©quence sont dans l'ensemble <b>P</b> , c'est-Ã -dire  sont noirs, et <br><br>  b) tous les deux pixels <b><i>adjacents dans cette sÃ©quence</i></b> sont <b><i>8 voisins</i></b> <br><br>  <b>Remarque</b> : tous les modÃ¨les Ã  4 connexions sont Ã  8 connexions, c'est-Ã -dire  Les modÃ¨les Ã  4 connexions sont un sous-ensemble des nombreux modÃ¨les Ã  8 connexions.  En revanche, un modÃ¨le Ã  8 connexions peut ne pas Ãªtre Ã  4 connexions. <br><br><h4>  Exemple de modÃ¨le liÃ© Ã  8 </h4><br>  Le diagramme ci-dessous montre un modÃ¨le qui est connectÃ© Ã  8 mais pas Ã  4: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f0/3d4/d90/7f03d4d904e9a4ebd1b7765ee7f4358f.gif" height="180" width="180"></div><br><br><h4>  Un exemple de modÃ¨le non connectÃ© Ã  8: </h4><br>  Le diagramme ci-dessous montre un exemple d'un modÃ¨le qui n'est pas connectÃ© Ã  8, c'est-Ã -dire  composÃ© de plusieurs composants connectÃ©s (le schÃ©ma montre trois composants connectÃ©s): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/768/7bb/f90/7687bbf9070e4e581e4ebfde132a1164.gif" height="180" width="180"></div><br><br><h2>  Algorithme de trace carrÃ©e </h2><br><h4>  IdÃ©e </h4><br>  L'idÃ©e derriÃ¨re l'algorithme de tracÃ© carrÃ© est trÃ¨s simple;  cela peut Ãªtre attribuÃ© au fait que l'algorithme a Ã©tÃ© l'une des premiÃ¨res tentatives de dÃ©tection du contour d'un motif binaire. <br><br>  Pour comprendre comment Ã§a marche, il faut un peu d'imagination ... <br><br>  Supposons que nous ayons un motif numÃ©rique, par exemple, un groupe de pixels noirs sur un fond de pixels blancs, c'est-Ã -dire  sur la grille;  trouver le pixel noir et le dÃ©clarer comme notre pixel " <b>initial</b> ".  (Trouver le pixel Â« <b>initial</b> Â» peut Ãªtre implÃ©mentÃ© de diffÃ©rentes maniÃ¨res; nous commencerons par le coin infÃ©rieur gauche de la grille, nous balayerons chaque colonne de pixels de bas en haut, de la colonne la plus Ã  gauche Ã  l'extrÃªme droite, jusqu'Ã  ce que nous tombions sur un pixel noir. Nous le dÃ©clarerons Â« <b>initial</b> Â» ".) <br><br>  Imaginez maintenant que vous Ãªtes une coccinelle debout sur le pixel de <b>dÃ©part</b> , comme le montre la <b><i>figure 1</i></b> ci-dessous.  Pour obtenir le contour d'un motif, vous devez procÃ©der comme suit: <br><br> <code> ,      ,  ,  <br> <br>  ,      ,  , <br> <br>      <b></b> .</code> <br> <br>  Les pixels noirs que vous avez encerclÃ©s seront le contour du motif. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/baa/0c2/69e/baa0c269e22368fa231d774f6bf3b062.gif" height="252" width="216"></div><br>  Un aspect important de l'algorithme du tracÃ© carrÃ© est le Â«sens de l'orientationÂ».  Les virages Ã  gauche et Ã  droite sont effectuÃ©s par rapport Ã  l'emplacement actuel, ce qui dÃ©pend de la faÃ§on dont vous Ãªtes arrivÃ© au pixel actuel.  Par consÃ©quent, afin de faire les bons mouvements, vous devez suivre votre direction. <br><br><h4>  Algorithme </h4><br>  Ce qui suit est une description formelle de l'algorithme de trace carrÃ©e: <br><br>  EntrÃ©e: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pavage</a> carrÃ©, <b>T</b> , contenant la composante connectÃ©e <b>P des</b> cellules noires. <br><br>  Sortie: ligne <b>B (b <sub>1</sub> , b <sub>2</sub> , ..., b <sub>k</sub> )</b> de pixels de bordure, c'est-Ã -dire  contour. <br><br>  Commencer <br><br><ul><li>  DÃ©finissez <b>B</b> comme un ensemble vide. </li><li>  Scannez les cellules <b>T</b> de bas en haut et de gauche Ã  droite jusqu'Ã  ce qu'un pixel noir <b>s</b> de <b>P soit trouvÃ©</b> . </li><li>  InsÃ©rez <b>s</b> dans <b>B.</b> </li><li>  Faire du pixel actuel <b>p le</b> pixel initial <b>s</b> . </li><li>  Tournez Ã  gauche, c'est-Ã -dire  aller au pixel voisin Ã  gauche de <b>p</b> . </li><li>  Mettre Ã  jour <b>p</b> , c'est-Ã -dire  il devient le pixel actuel. </li><li>  Alors que <b>p n'est</b> pas Ã©gal Ã  <b>s</b> , exÃ©cutez <br><br>  Si le pixel actuel <b>p</b> est noir <br><ul><li>  insÃ©rez <b>p</b> dans <b>B</b> et tournez Ã  gauche (allez au pixel voisin Ã  gauche de <b>p</b> ). </li><li>  Mettre Ã  jour <b>p</b> , c'est-Ã -dire  il devient le pixel actuel. </li></ul><br>  sinon <br><ul><li>  tourner Ã  droite (passer au pixel suivant Ã  droite de <b>p</b> ). </li><li>  Mettre Ã  jour <b>p</b> , c'est-Ã -dire  il devient le pixel actuel. </li></ul><br>  Fin du cycle Â«ByeÂ» </li></ul><br>  La fin <br><br>  <b>Remarque: les</b> concepts de Â«gaucheÂ» et de Â«droiteÂ» doivent Ãªtre considÃ©rÃ©s non pas par rapport Ã  la page ou au lecteur, mais par rapport Ã  la direction d'entrÃ©e dans le pixel Â«actuelÂ» pendant la numÃ©risation. <br><br><h4>  DÃ©monstration </h4><br>  Ce qui suit est une dÃ©monstration animÃ©e de la faÃ§on dont l'algorithme de trace carrÃ©e dÃ©tecte le contour d'un motif.  N'oubliez pas que la coccinelle se dÃ©place en pixels;  remarquez comment sa direction change en tournant Ã  gauche et Ã  droite.  Les virages Ã  gauche et Ã  droite sont effectuÃ©s par rapport Ã  la direction actuelle dans un pixel, c'est-Ã -dire  orientation coccinelle. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39c/148/f77/39c148f774519015dc130273d8383dd3.gif" height="360" width="288"></div><br><h4>  Analyse </h4><br>  Il s'avÃ¨re que les capacitÃ©s de l'algorithme de trace carrÃ©e sont trÃ¨s limitÃ©es.  Il est incapable de dÃ©tecter les contours d'une grande famille de motifs qui surviennent souvent dans des applications rÃ©elles. <br><br>  Ceci est principalement dÃ» au fait que les rotations gauche et droite ne prennent pas en compte les pixels situÃ©s <br>  diagonales "du pixel actuel. <br><br>  Examinons les diffÃ©rents modÃ¨les avec une connectivitÃ© diffÃ©rente et voyons pourquoi l'algorithme de trace carrÃ©e Ã©choue.  De plus, nous Ã©tudierons les moyens d'amÃ©liorer les capacitÃ©s de l'algorithme et de le faire fonctionner mÃªme avec des modÃ¨les qui ont un type spÃ©cial de connectivitÃ©. <br><br><h4>  CritÃ¨re d'arrÃªt </h4><br>  L'une des faiblesses de l'algorithme est le choix du critÃ¨re d'arrÃªt.  En d'autres termes, quand un algorithme cesse-t-il de s'exÃ©cuter? <br><br>  Dans la description d'origine de l'algorithme de trace carrÃ©e, la condition de fin consiste Ã  toucher le pixel <b>initial</b> une deuxiÃ¨me fois.  Il s'avÃ¨re que si l'algorithme dÃ©pend d'un tel critÃ¨re, il ne pourra pas dÃ©tecter les contours d'une grande famille de motifs. <br><br>  Ce qui suit est une dÃ©monstration animÃ©e expliquant comment l'algorithme est incapable de dÃ©tecter le contour exact du motif en raison de la sÃ©lection d'un mauvais critÃ¨re d'arrÃªt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ef/783/09a/0ef78309a17e9e72b09a28890abb6791.gif" height="252" width="216"></div><br>  Comme vous pouvez le voir, l'amÃ©lioration du critÃ¨re d'arrÃªt peut Ãªtre un bon dÃ©but pour amÃ©liorer les performances globales de l'algorithme.  Il existe deux alternatives efficaces pour un critÃ¨re d'arrÃªt existant: <br><br>  a) ArrÃªtez-vous uniquement en visitant le pixel de <b>dÃ©part</b> <b><i>n</i></b> fois, oÃ¹ n vaut au moins 2, OU <br><br>  b) ArrÃªtez aprÃ¨s avoir frappÃ© le pixel de <b>dÃ©part</b> une deuxiÃ¨me fois, tout comme nous l'avons touchÃ© au dÃ©part. <br><br>  Ce critÃ¨re a Ã©tÃ© proposÃ© par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jacob Eliosoff</a> , nous l'appellerons donc le <b><i>critÃ¨re d'arrÃªt de Jacob</i></b> . <br><br>  La modification du critÃ¨re d'arrÃªt dans le cas gÃ©nÃ©ral amÃ©liore l'efficacitÃ© de l'algorithme de trace carrÃ©e, mais ne remÃ©die pas aux autres faiblesses qu'il prÃ©sente dans le cas de modÃ¨les avec des types de connectivitÃ© spÃ©ciaux. <br><br>  L'algorithme de traÃ§age carrÃ© est incapable de dÃ©tecter le contour d'une famille de motifs avec une connectivitÃ© de 8 qui n'a PAS une connectivitÃ© de 4. <br><br>  Ce qui suit est une dÃ©monstration animÃ©e de la faÃ§on dont l'algorithme de trace carrÃ©e (avec le critÃ¨re d'arrÃªt de Jacob) ne parvient pas Ã  dÃ©tecter le contour correct d'un modÃ¨le avec connectivitÃ© 8 sans connectivitÃ© 4: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9bb/c26/238/9bbc26238da41c3fb5c5eac1e44fe507.gif" height="288" width="216"></div><br><h2>  Cet algorithme est-il complÃ¨tement inutile? </h2><br>  Si vous lisez l'analyse ci-dessus, vous pensez probablement que l'algorithme de trace carrÃ©e ne parvient pas Ã  dÃ©tecter les contours de la plupart des modÃ¨les.  Mais cela s'avÃ¨re.  qu'il existe une famille spÃ©ciale de motifs dans lesquels le chemin est entiÃ¨rement dÃ©tectÃ© par l'algorithme de trace carrÃ©e. <br><br>  Soit <b>P</b> l'ensemble des pixels noirs avec la connectivitÃ© 4 sur la grille.  Soit les pixels blancs de la grille, c'est-Ã -dire  les pixels d'arriÃ¨re-plan <b>W</b> ont Ã©galement une connectivitÃ© de 4. Il s'avÃ¨re que dans de telles conditions du motif et de son arriÃ¨re-plan, il peut Ãªtre prouvÃ© que l'algorithme de trace carrÃ©e (avec le critÃ¨re d'arrÃªt de Jacob) traitera toujours avec succÃ¨s la dÃ©termination du contour. <br><br>  Ci-dessous est la preuve que dans le cas oÃ¹ le motif et les pixels d'arriÃ¨re-plan sont connectÃ©s, l'algorithme de trace carrÃ©e dÃ©terminera correctement le contour lors de l'utilisation du critÃ¨re d'arrÃªt Jacob. <br><br>  Preuve <br>  <b>Ã‰tant donnÃ©</b> : le motif <b>P est</b> tel que tous les pixels du motif (c'est-Ã -dire noir) et les pixels d'arriÃ¨re-plan (c'est-Ã -dire blanc) W ont une connectivitÃ© de 4. <br><br>  <b>PremiÃ¨re observation</b> <br><br>  Puisque l'ensemble de pixels blancs W a une connectivitÃ© de 4, cela signifie qu'il ne peut pas y avoir de Â« <b><i>trous</i></b> Â» dans le motif (en termes informels, Â« <b><i>trous</i></b> Â», nous entendons des groupes de pixels blancs complÃ¨tement entourÃ©s par des pixels noirs du motif). <br><br>  La prÃ©sence de tout Â« <b><i>trou</i></b> Â» dans le motif entraÃ®nera la sÃ©paration du groupe de pixels blancs des pixels blancs restants;  cependant, de nombreux pixels blancs perdent leur connectivitÃ© 4. <br><br>  <i>La figure 2</i> et la <b><i>figure 3</i></b> ci-dessous montrent deux types de Â« <b><i>trous</i></b> Â» qui peuvent se produire dans un modÃ¨le avec connectivitÃ© 4: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d9/a4e/9b1/8d9a4e9b18b2753038c0abbd11ad7dcd.gif" height="180" width="432"></div><br><br>  <b>DeuxiÃ¨me observation</b> <br><br>  Deux pixels noirs d'un motif DOIVENT avoir un cÃ´tÃ© commun. <br><br>  Supposons que deux pixels noirs aient un seul sommet commun.  Ensuite, afin de satisfaire la propriÃ©tÃ© de 4-connectivitÃ© du motif, il doit y avoir un chemin reliant ces deux pixels afin que tous les deux pixels adjacents sur ce chemin aient une connectivitÃ© de 4. Mais cela nous donnera un motif similaire Ã  la <b><i>figure 3</i></b> .  En d'autres termes, cela entraÃ®nera une sÃ©paration des pixels blancs.  <b><i>La figure 4</i></b> ci-dessous montre un motif typique satisfaisant Ã  l'hypothÃ¨se que les pixels du motif et de l'arriÃ¨re-plan sont connectÃ©s en 4, c'est-Ã -dire  n'ont pas de Â« <b><i>trous</i></b> Â» et tous les deux pixels noirs ont un cÃ´tÃ© commun: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a68/2e0/7e0/a682e07e0732655da35269badcfe6b69.gif" height="216" width="216"></div><br>  Il est utile de reprÃ©senter ces modÃ¨les comme suit: <br><br>  Nous considÃ©rons d'abord les pixels limites, c'est-Ã -dire  contour du motif.  Ensuite, si nous considÃ©rons chaque pixel frontiÃ¨re comme ayant 4 bords de longueur unitaire, nous verrons que certains de ces bords sont communs avec les pixels blancs voisins.  Nous appellerons ces arÃªtes des arÃªtes <b><i>limites</i></b> . <br><br>  Ces bords limites peuvent Ãªtre considÃ©rÃ©s comme des bords d'un polygone.  Dans l' <b><i>image</i></b> <b><i><br></i></b>  <b><i>5</i></b> ci-dessous, cette idÃ©e est illustrÃ©e par l'exemple d'un polygone correspondant au motif de la <b><i>figure 4</i></b> ci-dessus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/220/ebe/5ea/220ebe5ea9383e00a2709117b237248b.gif" height="216" width="216"></div><br>  Si nous considÃ©rons toutes les Â«configurationsÂ» possibles de pixels limites qui peuvent se produire dans de tels motifs, nous verrons qu'il existe deux cas simples, illustrÃ©s dans les <b><i>figures 6</i></b> et <b><i>7</i></b> ci-dessous. <br><br>  Les pixels limites peuvent Ãªtre des multiples de ces cas ou d'autres dispositions, c'est-Ã -dire  les rebondissements de ces deux cas.  Les cÃ´tes frontiÃ¨res sont marquÃ©es en bleu comme <b>E1, E2, E3</b> et <b>E4</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf5/99b/6fa/bf599b6fafebb09a80c32eceb0520270.gif" height="216" width="576"></div><br>  <b>TroisiÃ¨me observation</b> <br><br>  Dans le cas des deux cas ci-dessus, quel que soit le pixel initial que nous choisissons, et quelle que soit la direction dans laquelle il <b>tombe</b> , l'algorithme de tracÃ© carrÃ© ne <b>"reviendra"</b> jamais <b>(retour arriÃ¨re)</b> , il ne <b>"traversera"</b> jamais <b>le</b> <i>bord de frontiÃ¨re</i> deux fois seulement s'il ne trace pas la frontiÃ¨re une deuxiÃ¨me fois) et ne manquez jamais le <b><i>bord de</i></b> la <b><i>frontiÃ¨re</i></b> .  DÃ©couvrez-le! <br><br>  Deux concepts doivent Ãªtre clarifiÃ©s ici: <br><br>  a) l'algorithme <b>"remonte"</b> , quand avant de tracer la bordure entiÃ¨re il revient pour visiter un pixel dÃ©jÃ  visitÃ©, et <br><br>  b) pour chaque <b><i>nervure limite,</i></b> il y a deux faÃ§ons de <b>Â«la traverserÂ»</b> , Ã  savoir Â«vers l'intÃ©rieurÂ» et Â«vers l'extÃ©rieurÂ» (oÃ¹ Â«vers l'intÃ©rieurÂ» signifie le mouvement vers l'intÃ©rieur du polygone correspondant et Â«vers l'extÃ©rieurÂ» - vers l'extÃ©rieur du polygone). <br><br>  De plus, lorsque l'algorithme passe "vers l'intÃ©rieur" Ã  travers l'un des bords de frontiÃ¨re, il passera "vers l'extÃ©rieur" Ã  travers le bord de frontiÃ¨re suivant, c'est-Ã -dire  l'algorithme de tracÃ© carrÃ© ne doit pas pouvoir traverser deux bords consÃ©cutifs de la mÃªme maniÃ¨re. <br><br>  <b>DerniÃ¨re observation</b> <br><br>  Chaque motif a un <b>nombre pair d'</b> <b>arÃªtes limites</b> . <br><br>  Si vous regardez le polygone de la <b><i>figure 5</i></b> , vous pouvez voir que: <br><br>  si nous voulons partir du sommet <b>S</b> marquÃ© dans le diagramme et suivre les bords limites jusqu'Ã  ce que nous atteignions Ã  nouveau <b>S</b> , alors nous remarquons que dans le processus, nous traversons un nombre pair de bords limites.  Nous pouvons considÃ©rer chaque bord de frontiÃ¨re comme un Â«pasÂ» dans une direction distincte.  Ensuite, pour chaque Â«pasÂ» Ã  droite, il doit y avoir un Â«pasÂ» correspondant Ã  gauche, si nous voulons revenir Ã  la position de dÃ©part.  Il en va de mÃªme pour les Â«marchesÂ» verticales.  Par consÃ©quent, les Â«Ã©tapesÂ» doivent avoir des paires correspondantes, ce qui explique pourquoi chacun de ces motifs aura un nombre pair d'arÃªtes limites. <br><br>  Par consÃ©quent, lorsque l'algorithme de traÃ§age des carrÃ©s entre par le <b>bord limite initial</b> (du pixel initial) une deuxiÃ¨me fois, il le fera dans <b>la mÃªme</b> direction que la premiÃ¨re fois. <br><br>  La raison en est que, comme il existe deux faÃ§ons de traverser le bord de limite, et que l'algorithme se dÃ©place alternativement vers l'intÃ©rieur et l'extÃ©rieur, et qu'il existe un nombre pair de bords de limite, l'algorithme passera pour la deuxiÃ¨me fois par le bord de limite initial de la mÃªme maniÃ¨re que dans premier. <br><br><h4>  Conclusion </h4><br>  Dans le cas d'un motif et d'un arriÃ¨re-plan connectÃ©s Ã  4, l'algorithme de tracÃ© carrÃ© dÃ©tectera la bordure entiÃ¨re, c'est-Ã -dire  contour, motif et cessera de fonctionner aprÃ¨s une seule trace, c.-Ã -d.  il ne le tracera pas Ã  nouveau, car lorsqu'il atteindra le <b>bord limite initial</b> pour la deuxiÃ¨me fois, il l'entrera de la mÃªme maniÃ¨re que la premiÃ¨re fois.  Par consÃ©quent, l'algorithme de tracÃ© carrÃ© avec le critÃ¨re d'arrÃªt de Jacob dÃ©terminera correctement le compteur de n'importe quel motif, Ã  condition que le motif et l'arriÃ¨re-plan soient tous les quatre connectÃ©s. <br><br><h2>  Retrouver les environs de Moore </h2><br><h4>  IdÃ©e </h4><br>  L'idÃ©e derriÃ¨re le traÃ§age Moore-Neighbour est simple;  mais avant de l'expliquer, nous devons expliquer un concept important: <b><i>le voisinage Moore d'un</i></b> pixel. <br><br><h4>  Le quartier de Moore </h4><br>  Le voisinage de Moore d'un pixel <b>P</b> est un ensemble de 8 pixels ayant un sommet ou un bord commun avec ce pixel.  Ces pixels, Ã  savoir <b>P1, P2, P3, P4, P5, P6, P7 et P8</b> , sont reprÃ©sentÃ©s sur la <b><i>figure 1</i></b> . <br><br>  Le quartier Moore (Ã©galement appelÃ© <b><i>8 voisins</i></b> ou <b><i>voisins</i></b> <b><i>indirects</i></b> ) est un concept important souvent mentionnÃ© dans la littÃ©rature. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/863/08c/2ea/86308c2ea8863bc111d206fb5070250f.gif" height="195" width="178"></div><br>  Nous sommes maintenant prÃªts Ã  nous familiariser avec l'idÃ©e qui sous-tend la trace de l'environnement de Moore. <br><br>  Qu'il y ait un modÃ¨le numÃ©rique, c'est-Ã -dire  un groupe de pixels noirs, sur un fond de pixels blancs, c'est-Ã -dire  sur la grille;  trouver le pixel noir et le dÃ©clarer pixel " <b>initial</b> ".  (Il existe plusieurs faÃ§ons de trouver le pixel Â« <b>initial</b> Â», mais comme prÃ©cÃ©demment, nous commencerons par le coin infÃ©rieur gauche et numÃ©riserons toutes les colonnes de pixels dans l'ordre, jusqu'Ã  ce que nous trouvions le premier pixel noir, que nous dÃ©clarerons Â« <b>initial</b> Â».) <br><br>  Maintenant, imaginez Ã  nouveau que vous Ãªtes une coccinelle debout sur le pixel de <b>dÃ©part</b> , comme le montre la <b><i>figure 2</i></b> ci-dessous.  Sans perte de gÃ©nÃ©ralisation, nous allons dÃ©tecter le contour en se dÃ©plaÃ§ant dans le sens horaire.  (Peu importe la direction que nous choisissons, l'essentiel est de l'utiliser constamment dans l'algorithme). <br><br>  L'idÃ©e gÃ©nÃ©rale est la suivante: chaque fois que nous arrivons au pixel noir <b>P</b> , nous revenons, c'est-Ã -dire au pixel blanc dans lequel nous nous trouvions auparavant.  Ensuite, <b>nous</b> contournons le pixel <b>P</b> dans le sens des aiguilles d'une montre, visitant chaque pixel Ã  proximitÃ© de Moore, jusqu'Ã  ce que nous arrivions au pixel noir.  L'algorithme se termine lorsque le pixel de dÃ©part atteint le pixel de dÃ©marrage une deuxiÃ¨me fois. <br><br>  Ces pixels noirs que l'algorithme a visitÃ©s seront le contour du motif. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43e/afb/a2f/43eafba2f0611e11eb82c8ed7159971c.gif" height="252" width="216"></div><br><h4>  Algorithme </h4><br>  Voici une description formelle de l'algorithme de suivi du voisinage de Moore: <br><br>  EntrÃ©e: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pavage</a> carrÃ© <b>T</b> contenant une composante connectÃ©e <b>P</b> de cellules noires. <br><br>  Sortie: ligne <b>B (b <sub>1</sub> , b <sub>2</sub> , ..., b <sub>k</sub> ) de</b> pixels limites, c'est-Ã -dire  contour. <br><br>  Notons <b>M (a)</b> le voisinage de Moore du pixel <b>a</b> . <br><br>  Soit <b>p</b> le pixel de bordure actuel. <br><br>  Soit <b>c</b> le pixel courant considÃ©rÃ©, c'est-Ã -dire  <b>c</b> est dans <b>M (p)</b> . <br><br>  Commencer <br><br><ul><li>  DÃ©finissez <b>B</b> comme un ensemble vide. </li><li>  De bas en haut et de gauche Ã  droite, scannez les cellules <b>T</b> jusqu'Ã  ce que nous trouvions un pixel noir <b>s</b> de <b>P.</b> </li><li>  InsÃ©rez <b>s</b> dans <b>B.</b> </li><li>  Nous dÃ©finissons le point <b>s</b> comme le point limite actuel <b>p</b> , c'est-Ã -dire  <b>p = s</b> </li><li>  Revenons en arriÃ¨re, c'est-Ã -dire  Passons au pixel d'oÃ¹ nous sommes arrivÃ©s Ã  l' <b>art</b> . </li><li>  Soit <b>c le</b> pixel suivant dans le sens des aiguilles d'une montre dans <b>M (p)</b> . </li><li>  Alors que <b>c n'est</b> pas Ã©gal Ã  <b>s</b> , exÃ©cutez <br><br><ul><li>  si <b>c</b> est noir <br><ul><li>  InsÃ©rez <b>c</b> dans <b>B</b> </li><li>  on pose <b>p = c</b> </li><li>  revenir en arriÃ¨re (dÃ©placer le pixel actuel <b>c</b> vers le pixel Ã  partir duquel nous sommes arrivÃ©s Ã  <b>p</b> ) </li></ul><br>  sinon <br><ul><li>  dÃ©placer le pixel actuel <b>c</b> vers le pixel suivant dans le sens des aiguilles d'une montre dans <b>M (p)</b> </li></ul><br>  Fin du cycle d'adieu </li></ul></li></ul><br>  La fin <br><br><h4>  DÃ©monstration </h4><br>  Ce qui suit est une dÃ©monstration animÃ©e de la faÃ§on dont la trace de voisinage de Moore effectue la dÃ©tection de contour de motif.  (Nous avons dÃ©cidÃ© de tracer le contour dans le sens horaire.) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/544/3f0/295/5443f02954a35cf08c7a9e462bfa0f8a.gif" height="360" width="360"></div><br><h4>  Analyse </h4><br>  La principale faiblesse du tracÃ© des environs de Moore rÃ©side dans le choix des critÃ¨res d'arrÃªt. <br><br>  Dans la description originale de l'algorithme de traÃ§age de l'environnement de Moore, le critÃ¨re d'arrÃªt est de toucher le pixel <b>initial</b> une seconde fois.  Semblable Ã  l'algorithme de tracÃ© carrÃ©, il s'avÃ¨re que le traÃ§age de l'environnement de Moore en utilisant ce critÃ¨re ne peut pas dÃ©tecter les contours d'une grande famille de motifs. <br><br>  Ce qui suit est une dÃ©monstration animÃ©e expliquant pourquoi l'algorithme ne peut pas trouver le contour exact du motif en raison de la sÃ©lection d'un mauvais critÃ¨re d'arrÃªt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1c/d5e/7af/a1cd5e7afa1cd1b7312e5770c6cf826c.gif" height="252" width="216"></div><br>  Comme vous pouvez le voir, l'amÃ©lioration du critÃ¨re d'arrÃªt peut Ãªtre un bon dÃ©but pour amÃ©liorer les performances globales de la trace.  Il existe deux alternatives efficaces pour le critÃ¨re d'arrÃªt, similaires au critÃ¨re d'arrÃªt de Jacob. <br><br>  L'utilisation du critÃ¨re de Jacob amÃ©liore considÃ©rablement l'efficacitÃ© du traÃ§age de l'environnement de Moore, ce qui en fait le meilleur algorithme pour dÃ©terminer le contour de n'importe quel motif, quelle que soit sa connectivitÃ©. <br><br>  La raison en est principalement que l'algorithme vÃ©rifie tout le voisinage de Moore du pixel limite pour rechercher le pixel limite suivant.  Contrairement Ã  l'algorithme de tracÃ© carrÃ©, qui ne tourne qu'Ã  gauche et Ã  droite et qui manque les pixels Â«en diagonaleÂ», le tracÃ© de voisinage de Moore sera toujours en mesure de dÃ©tecter la limite extÃ©rieure de tout composant connectÃ©.  La raison en est la suivante: pour tout motif Ã  <b><i>8 connexions</i></b> (ou simplement <b><i>connectÃ©</i></b> ), le pixel de bordure <b>suivant</b> se trouve dans le voisinage de Moore du pixel de bordure actuel.  Ã‰tant donnÃ© que la trace de voisinage de Moore vÃ©rifie chacun des pixels dans le voisinage de Moore du pixel limite actuel, il doit dÃ©tecter le pixel limite suivant. <br><br>  Lorsque le tracÃ© du voisinage de Moore atteint le pixel initial une deuxiÃ¨me fois de la mÃªme maniÃ¨re que la premiÃ¨re fois, cela signifie qu'un <b>contour externe</b> <b>complet</b> <b>du</b> motif a Ã©tÃ© dÃ©tectÃ©, et si l'algorithme n'est pas arrÃªtÃ©, il dÃ©tectera Ã  nouveau le mÃªme contour. <br><br><h2>  Balayage radial </h2><br>  L'algorithme de balayage radial est un algorithme de dÃ©tection de contour discutÃ© dans certains livres.  MalgrÃ© le nom complexe, l'idÃ©e sous-jacente est trÃ¨s simple.  En fait, il s'avÃ¨re que l'algorithme de balayage radial <b>est identique Ã  la</b> trace de l'environnement de Moore.  On peut se demander: "Pourquoi le mentionnons-nous?" <br><br>  Le traÃ§age de l'environnement de Moore recherche Ã  proximitÃ© de Moore le pixel limite actuel dans une certaine direction (nous avons choisi la direction horaire) jusqu'Ã  ce qu'il trouve un pixel noir.  Elle dÃ©clare ensuite ce pixel comme pixel limite actuel et continue. <br><br>  L'algorithme de balayage radial fait de mÃªme.  D'un autre cÃ´tÃ©, il fournit un moyen intÃ©ressant de trouver le prochain pixel noir dans le voisinage de Moore d'un pixel limite donnÃ©. <br><br>  La mÃ©thode est basÃ©e sur l'idÃ©e suivante: <br><br>  chaque fois que nous trouvons un nouveau pixel limite, en faisons le pixel actuel <b>P</b> et dessinons <b>un segment de ligne imaginaire</b> reliant <b>P</b> au pixel limite <b>prÃ©cÃ©dent</b> .  Ensuite, nous faisons <b>pivoter le</b> segment par rapport Ã  <b>P</b> dans le sens des aiguilles d'une montre jusqu'Ã  ce qu'il rencontre un pixel noir dans le voisinage de Moore du pixel <b>P.</b>  La rotation de la ligne est identique Ã  la vÃ©rification de chaque pixel au voisinage de Moore <b>P.</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous avons crÃ©Ã© une dÃ©monstration animÃ©e du fonctionnement de l'algorithme de balayage radial et Ã  quoi il ressemble en traÃ§ant les environs de Moore. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa1/419/ff6/fa1419ff6b8efc7ef94d978854f99fab.gif" height="360" width="326"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et quand l'algorithme de balayage radial s'arrÃªte-t-il? </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Expliquons le comportement de l'algorithme en utilisant les critÃ¨res d'arrÃªt suivants ...</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CritÃ¨re d'arrÃªt 1 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laissez l'algorithme de balayage radial se terminer lorsqu'il visite le </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixel initial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> une deuxiÃ¨me fois. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous trouverez ci-dessous une dÃ©monstration animÃ©e, Ã  partir de laquelle il est clair pourquoi le critÃ¨re de rupture sera modifiÃ© correctement.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04c/432/408/04c432408fca093316e950c77bdd5537.gif" height="252" width="216"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il convient Ã©galement de mentionner qu'en utilisant ce critÃ¨re d'arrÃªt dans les deux algorithmes, l'efficacitÃ© de l'algorithme de balayage radial est identique au traÃ§age de l'environnement de Moore. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans l'algorithme de trace carrÃ©e et dans la trace de voisinage de Moore, nous avons constatÃ© que l'utilisation du critÃ¨re d'arrÃªt de Jacob amÃ©liore considÃ©rablement les performances des deux algorithmes. </font></font><br><br> <b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le critÃ¨re d'arrÃªt de Jacob</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nÃ©cessite que l'algorithme arrÃªte de s'exÃ©cuter lorsqu'il visite le </font><font style="vertical-align: inherit;">pixel de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dÃ©part</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> une deuxiÃ¨me fois dans la mÃªme direction que la premiÃ¨re fois. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malheureusement, nous ne pouvons pas utiliser le critÃ¨re d'arrÃªt de Jacob dans l'algorithme de balayage radial. La raison en est que l'algorithme de balayage radial ne dÃ©finit pas le concept</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La "direction" dans laquelle il frappe le pixel limite</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">En d'autres termes, la Â«directionÂ» dans laquelle l'algorithme est tombÃ© dans le pixel limite n'est pas claire (et sa dÃ©finition n'est pas triviale). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par consÃ©quent, nous devons proposer un autre critÃ¨re d'arrÃªt, qui ne dÃ©pend pas de la direction de frapper un certain pixel, ce qui peut amÃ©liorer l'efficacitÃ© de l'algorithme de balayage radial ...</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CritÃ¨re d'arrÃªt 2 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supposons que chaque fois que l'algorithme dÃ©tecte un nouveau pixel frontiÃ¨re </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , il soit insÃ©rÃ© dans une </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sÃ©rie de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixels frontiÃ¨re: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ..., P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; et dÃ©clarÃ© comme pixel de bordure actuel. ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous considÃ©rerons le </font><font style="vertical-align: inherit;">pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">initial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Cela signifie que nous connaissons le pixel de bordure prÃ©cÃ©dent </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-1 de</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> chaque pixel de bordure actuel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . (Quant au </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixel de dÃ©part</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nous supposerons que </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est un pixel imaginaire qui n'est Ã©quivalent Ã  aucun des pixels de la grille qui fait face au </font><font style="vertical-align: inherit;">pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">initial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de la rangÃ©e de pixels limites). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sur la base des hypothÃ¨ses ci-dessus, nous pouvons dÃ©terminer le critÃ¨re d'arrÃªt comme suit: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'algorithme arrÃªte l'exÃ©cution lorsque: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) le pixel limite actuel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s'est </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prÃ©cÃ©demment</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rencontrÃ© en tant que pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (oÃ¹ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j &lt;i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dans une sÃ©rie de pixels limites, Et </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i- 1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j-1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En d'autres termes, l'algorithme termine son exÃ©cution lorsqu'il visite le pixel limite P dans le </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">second</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fois si le pixel limite avant P (dans la rangÃ©e de pixels limites) pour la deuxiÃ¨me fois est </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le mÃªme</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixel qu'avant P lorsque P a Ã©tÃ© visitÃ© pour la </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">premiÃ¨re</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fois. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la condition du critÃ¨re d'arrÃªt est satisfaite et que l'algorithme ne s'arrÃªte pas, l'algorithme de balayage radial continuera Ã  dÃ©tecter </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la mÃªme</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> limite une deuxiÃ¨me fois. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les performances de l'algorithme de balayage radial avec ce critÃ¨re d'arrÃªt sont similaires Ã  celles du traÃ§age du voisinage de Moore avec le critÃ¨re d'arrÃªt Jacob.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithme de Theo Pavlidis </font></font></h2><br><h4>  IdÃ©e </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cet algorithme est l'un des derniers algorithmes de dÃ©tection de boucle proposÃ©s par </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Theo Pavlidis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Il l'a citÃ© dans son livre de 1982, </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algorithms for Graphics and Image Processing</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (chapitre 7, section 5). Ce n'est pas aussi simple que l'algorithme de traÃ§age des carrÃ©s ou de traÃ§age de l'environnement de Moore, mais ce n'est pas si compliquÃ© (c'est typique de la plupart des algorithmes de dÃ©tection de bord). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous n'expliquerons pas cet algorithme de la mÃªme maniÃ¨re que cela a Ã©tÃ© fait dans son livre. Notre approche est plus facile Ã  comprendre et donne une idÃ©e de l'idÃ©e gÃ©nÃ©rale sous-jacente Ã  l'algorithme.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sans perte de gÃ©nÃ©ralisation, nous avons dÃ©cidÃ© de faire le tour de la boucle dans le sens horaire pour correspondre Ã  l'ordre de tous les autres algorithmes prÃ©sentÃ©s dans l'article. En revanche, Pavlidis a choisi la direction dans le sens antihoraire. Cela n'affectera pas les performances de l'algorithme. La seule diffÃ©rence est la direction relative des mouvements que nous ferons lorsque nous contournerons le contour. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passons maintenant Ã  l'idÃ©e ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disons que nous avons un modÃ¨le numÃ©rique, c'est-Ã -dire un groupe de pixels noirs sur fond de pixels blancs, c'est-Ã -dire sur la grille; trouver le pixel noir et le dÃ©clarer pixel " </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">initial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". Vous pouvez rechercher le </font><font style="vertical-align: inherit;">pixel </font><font style="vertical-align: inherit;">Â«de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dÃ©part</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Â» de diffÃ©rentes maniÃ¨res, par exemple, comme dÃ©crit ci-dessus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour trouver l' </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">initiale</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixels pour utiliser cette mÃ©thode est facultatif. Au lieu de cela, nous choisirons un </font><font style="vertical-align: inherit;">pixel de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dÃ©part</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qui satisfait aux restrictions suivantes imposÃ©es par l'algorithme Pavlidis pour sÃ©lectionner un pixel de dÃ©part: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une limitation importante de la direction dans laquelle nous entrons le pixel de dÃ©part</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En fait, vous pouvez choisir N'IMPORTE QUEL pixel de bordure noire comme pixel de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dÃ©part</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans cette condition: si vous vous tenez initialement dessus, le pixel voisin gauche n'est PAS noir. En d'autres termes, vous devez entrer le </font><font style="vertical-align: inherit;">pixel de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dÃ©part</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans une direction telle que le pixel voisin gauche est blanc (la Â«gaucheÂ» ici est prise par rapport Ã  la direction dans laquelle nous entrons le </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixel de dÃ©part</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imaginez maintenant que vous Ãªtes une coccinelle debout</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixel de </font><b><font style="vertical-align: inherit;">dÃ©part</font></b><font style="vertical-align: inherit;"> , comme le montre la </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">figure 1</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ci-dessous. Lors de l'exÃ©cution de l'algorithme, nous ne nous intÃ©resserons qu'Ã  trois pixels devant vous, soit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1, P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> illustrÃ©s Ã  la </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">figure 1</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . (Nous dÃ©signerons </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comme le </font><font style="vertical-align: inherit;">pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devant</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vous, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le pixel Ã  gauche de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le pixel Ã  droite de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53e/792/4b1/53e7924b1a7cb6c5e84f70a038d52bc8.gif" height="252" width="216"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme pour l'algorithme de trace carrÃ©e, la chose la plus importante dans l'algorithme de Pavlidis est le Â«sens de l'orientationÂ». Les virages Ã  gauche et Ã  droite sont relatifs Ã  la position actuelle, qui dÃ©pend de la faÃ§on dont vous avez entrÃ© le pixel actuel. Par consÃ©quent, afin de faire les bons mouvements, il est important de garder une trace de votre orientation actuelle. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais quelle que soit votre position, les pixels P1, P2 et P3 sont dÃ©terminÃ©s comme dÃ©crit ci-dessus.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ayant ces informations, nous sommes prÃªts Ã  expliquer l'algorithme ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaque fois que vous vous tenez sur le pixel limite actuel (qui est d'abord le </font><font style="vertical-align: inherit;">pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">initial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), nous faisons ce qui suit: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , vÃ©rifiez le pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Si </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1 est</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> noir, dÃ©clarez </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le pixel limite actuel et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avancer d'un pas, puis faire un pas vers la gauche</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour Ãªtre Ã  P1 (l' </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ordre des</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dÃ©placements est trÃ¨s important). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">figure 2</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ci - </font><font style="vertical-align: inherit;">dessous illustre ce cas. </font><font style="vertical-align: inherit;">Le chemin pour arriver Ã  </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est indiquÃ© en bleu.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae9/c32/131/ae9c321310cb5a8902ae4df3dc42cdc9.gif" height="180" width="206"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et seulement si P1 est blanc, nous procÃ©dons Ã  la vÃ©rification de P2 ...</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2 est</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> noir, alors dÃ©clarons </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2 le</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixel limite actuel et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avanÃ§ons d'un pas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour Ãªtre sur </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ce cas est illustrÃ© Ã  la </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">figure 3</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ci-dessous. </font><font style="vertical-align: inherit;">Le chemin que vous devez suivre sur </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est indiquÃ© en bleu.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b34/7eb/934/b347eb9345873e5ba6aa136ab2fbb406.gif" height="180" width="206"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uniquement si P1 et P2 sont blancs, passez Ã  la vÃ©rification P3 ...</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3 est</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> noir, dÃ©clarez </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3 le</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixel de bordure actuel et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dÃ©placez-vous d'un pas vers la droite, puis d'un pas vers la gauche</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , comme le montre la figure 4 ci-dessous.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ad/bb6/7fa/0adbb67fa67183dec47bb4c1bf3221a7.gif" height="180" width="206"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est tout!</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Trois rÃ¨gles simples pour trois cas simples. Comme vous pouvez le voir, il est important de garder une trace de votre direction dans les virages, car tous les dÃ©placements sont effectuÃ©s par rapport Ã  l'orientation actuelle. Mais il semble que nous ayons oubliÃ© quelque chose? </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et si les trois pixels sont blancs devant nous?</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ensuite, nous tournons (debout au pixel limite actuel) de 90 degrÃ©s dans le sens des aiguilles d'une montre pour voir un nouvel ensemble de trois pixels devant nous. Ensuite, nous faisons la mÃªme vÃ©rification pour ces nouveaux pixels. Vous avez peut-Ãªtre encore une question: que faire si </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ces</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> trois pixels sont blancs?! Ensuite, nous tournons Ã  90 degrÃ©s dans le sens des aiguilles d'une montre, en nous tenant au mÃªme pixel. Avant de vÃ©rifier tout le voisinage du pixel de Moore, vous pouvez faire pivoter trois fois (chaque fois Ã  90 degrÃ©s dans le sens des aiguilles d'une montre).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous tournons trois fois sans jamais trouver de pixels noirs, cela signifie que nous nous trouvons sur un </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixel isolÃ©</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qui n'est connectÃ© Ã  aucun autre pixel noir. C'est pourquoi l'algorithme vous permet de faire pivoter trois fois, puis termine son exÃ©cution. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autre aspect: </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quand l'algorithme termine-t-il l'exÃ©cution?</font></font></i></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L'algorithme se termine dans deux cas: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) comme mentionnÃ© ci-dessus. l'algorithme vous permet de faire pivoter trois fois (90 degrÃ©s dans le sens horaire Ã  chaque fois), aprÃ¨s avoir terminÃ© l'exÃ©cution et dÃ©clarÃ© le pixel isolÃ© OU </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) lorsque le pixel limite actuel est le </font><font style="vertical-align: inherit;">pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">initial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , l'algorithme termine l'exÃ©cution en Â«dÃ©clarantÂ» qu'il a dÃ©tectÃ© le contour du motif.</font></font><br><br><h4>  Algorithme </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici une description formelle de l'algorithme de Pavlidis: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EntrÃ©e: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pavage</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> carrÃ© </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contenant une composante connectÃ©e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cellules noires. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sortie: ligne </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B (b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ..., b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixels limites, c'est-Ã -dire </font><font style="vertical-align: inherit;">contour. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DÃ©finitions:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notons </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p le</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixel limite actuel, c'est-Ã -dire </font><font style="vertical-align: inherit;">le pixel sur lequel nous nous tenons.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DÃ©finissez </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1, P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comme suit: </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(voir Ã©galement la figure 1 ci-dessus)</font></font></i></b> </li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le pixel devant vous, adjacent Ã  celui sur lequel vous vous tenez, c'est-Ã -dire </font><font style="vertical-align: inherit;">avec pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li> <b>P1</b> â€”  ,   <b>P2</b> . </li><li> <b>P3</b> â€”  ,   <b>P2</b> . </li><li>  <b>Â«Â»</b>            . </li></ul><br>  Commencer <br><br><ul><li>  <b>B</b>   . </li><li>   <b>T</b>     ,      <b></b>  <b>s</b>  <b>P</b> <b><i>(.     ,       )</i></b> </li><li>  <b>s</b>  <b>B</b> . </li><li>    <b>p</b>     <b>s</b> . </li><li>  : <br>   <b>P1</b>  <br><ul><li>  <b>P1</b>  <b>B</b> </li><li>  <b>p=P1</b> </li><li>     ,      </li></ul><br>   <b>P2</b>  <br><ul><li>  <b>P2</b>  <b>B</b> </li><li>  <b>p=P2</b> </li><li>      <b><i>(.   3)</i></b> </li></ul><br>   <b>P3</b>  <br><ul><li>  <b>P3</b>  <b>B</b> </li><li>  <b>p=P3</b> </li><li>    ,      <b><i>(.   4)</i></b> </li></ul><br>        90    ,   <b>  p</b> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terminer le programme et dÃ©clarer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p un</font></font></b> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isolÃ©</font></font></b><font style="vertical-align: inherit;"></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sinon </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tourner de 90 degrÃ©s dans le sens des aiguilles d'une montre, se tenant au pixel actuel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></b> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'Ã  prÃ©sent </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p = s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Fin de la boucle de rÃ©pÃ©tition)</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La fin </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DÃ©monstration </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce qui suit est une dÃ©monstration animÃ©e de la faÃ§on dont l'algorithme Pavlidis dÃ©tecte le contour d'un motif donnÃ©. </font><font style="vertical-align: inherit;">N'oubliez pas que nous marchons en pixels; </font><font style="vertical-align: inherit;">remarquez comment l'orientation change lorsque vous tournez Ã  gauche ou Ã  droite. </font><font style="vertical-align: inherit;">Pour expliquer l'algorithme de maniÃ¨re aussi dÃ©taillÃ©e que possible, nous y avons inclus tous les cas possibles.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22a/f0f/1dd/22af0f1dd39a517bb6097cd0fe3ec99d.gif" height="324" width="288"></div><br><h4>  Analyse </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous pensez que l'algorithme Pavlidis est idÃ©al pour dÃ©tecter les contours de motifs, alors vous devriez changer d'avis ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cet algorithme est vraiment un peu plus compliquÃ© que, par exemple, pour tracer les environs de Moore, dans lequel il n'y a pas de cas particuliers qui nÃ©cessitent un traitement sÃ©parÃ©, mais il ne sera pas en mesure de dÃ©terminer les contours d'un grand une famille de modÃ¨les qui a un certain type de connectivitÃ©. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'algorithme fonctionne trÃ¨s bien sur les modÃ¨les Ã  4 connexions. Son problÃ¨me se produit lors du traÃ§age de certains modÃ¨les connectÃ©s Ã  8 qui ne sont pas connectÃ©s Ã  4. Ce qui suit est une dÃ©monstration animÃ©e de la faÃ§on dont l'algorithme Pavlidis ne parvient pas Ã  dÃ©tecter le contour correct d'un modÃ¨le Ã  8 connexions (pas un modÃ¨le Ã  4 connexions) - il saute la majeure partie de la frontiÃ¨re.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/225/56a/816/22556a816442cf010492cc30b64392eb.gif" height="252" width="247"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe deux faÃ§ons simples de modifier un algorithme pour amÃ©liorer considÃ©rablement ses performances. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Remplacer le critÃ¨re d'arrÃªt</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Au lieu de terminer l'algorithme lorsqu'il visite le pixel de dÃ©part une deuxiÃ¨me fois, vous pouvez le terminer lorsqu'il visite le pixel de dÃ©part une troisiÃ¨me ou mÃªme une quatriÃ¨me fois. Cela amÃ©liorera les performances globales de l'algorithme. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OU </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Aller Ã  la source du problÃ¨me, c'est-Ã -dire avant de sÃ©lectionner le pixel de dÃ©part</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Il existe une limitation importante concernant la direction dans laquelle l'entrÃ©e du pixel de dÃ©part est effectuÃ©e. Essentiellement, vous devez entrer le pixel de dÃ©part pour que lorsque vous vous tenez dessus, le pixel Ã  votre gauche soit blanc. La raison de l'introduction de cette restriction est la suivante: puisque nous regardons toujours les trois pixels </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devant</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous dans</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans un certain ordre</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dans certains motifs, nous ignorerons le pixel limite situÃ© directement Ã  gauche du pixel initial. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous risquons de manquer non seulement le pixel voisin gauche du pixel initial, mais aussi le </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixel directement en dessous</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (comme dÃ©montrÃ© dans l'analyse). De plus, dans certains motifs, un pixel correspondant au pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de la </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">figure 5</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ci </font><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">dessous </font><font style="vertical-align: inherit;">sera ignorÃ© </font><font style="vertical-align: inherit;">. Par consÃ©quent, nous supposons que le pixel de dÃ©part doit Ãªtre frappÃ© dans une direction telle que les pixels correspondant aux pixels </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L, W</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> reprÃ©sentÃ©s sur la </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">figure 5</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ci-dessous sont blancs.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c8/a81/359/9c8a81359338b31b6f5c0e016230e629.gif" height="200" width="159"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans ce cas, des modÃ¨les comme celui montrÃ© dans la dÃ©monstration seront dÃ©tectÃ©s correctement et l'efficacitÃ© de l'algorithme Pavlidis s'amÃ©liorera considÃ©rablement. </font><font style="vertical-align: inherit;">D'un autre cÃ´tÃ©, trouver un pixel initial qui satisfait Ã  ces exigences peut Ãªtre difficile, et dans de nombreux cas, il sera impossible de trouver un tel pixel. </font><font style="vertical-align: inherit;">Dans ce cas, vous devez utiliser un autre moyen d'amÃ©liorer l'algorithme Pavlidis, Ã  savoir l'achÃ¨vement de l'algorithme aprÃ¨s avoir visitÃ© le point de dÃ©part pour la troisiÃ¨me fois.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467611/">https://habr.com/ru/post/fr467611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467597/index.html">Personnalisation des directives de produit Big Data avec Vowpal Wabbit</a></li>
<li><a href="../fr467599/index.html">Rendu graphique 3D avec OpenGL</a></li>
<li><a href="../fr467605/index.html">Tout ce dont vous avez besoin est une URL</a></li>
<li><a href="../fr467607/index.html">Confession de haineux docker</a></li>
<li><a href="../fr467609/index.html">CrÃ©ation d'une application mobile sur React Native</a></li>
<li><a href="../fr467615/index.html">Comment crÃ©er un wrapper Python et ne pas devenir fou</a></li>
<li><a href="../fr467617/index.html">Kaspresso: le framework d'autotest que vous attendiez</a></li>
<li><a href="../fr467619/index.html">Les pichets Aquafor sont un bon exemple de la faÃ§on dont les filtres pour le traitement de l'eau ne peuvent pas Ãªtre conÃ§us</a></li>
<li><a href="../fr467621/index.html">Rencontre Elasticsearch Moscou Ã  Ozon</a></li>
<li><a href="../fr467625/index.html">10 services pour crÃ©er une structure de site en 2020</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>