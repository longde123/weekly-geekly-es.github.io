<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∏üèø üèáüèº ‚úä Algorithmes de d√©tection de contour d'image üñ§ üî† ü§Ωüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'article pr√©sente les quatre algorithmes de d√©tection de boucle les plus courants. 

 Les deux premiers, √† savoir l'algorithme de tra√ßage des carr√©s ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algorithmes de d√©tection de contour d'image</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467611/">  L'article pr√©sente les quatre algorithmes de d√©tection de boucle les plus courants. <br><br>  Les deux premiers, √† savoir l'algorithme de tra√ßage des carr√©s et de tra√ßage de l'environnement de Moore, sont faciles √† mettre en ≈ìuvre et sont donc souvent utilis√©s pour d√©terminer le contour d'un motif donn√©.  Malheureusement, les deux algorithmes ont plusieurs faiblesses, ce qui rend <b>impossible la</b> d√©tection du contour d'une grande classe de motifs en raison de leur type particulier d'adjacence. <br><br>  Ces algorithmes ignoreront tous les <b><i>¬´trous¬ª</i></b> du motif.  Par exemple, si nous avons un motif similaire √† celui montr√© sur la <b><i>figure 1</i></b> , alors le circuit d√©tect√© par les algorithmes sera similaire √† celui montr√© sur la <b><i>figure 2</i></b> (le contour est indiqu√© par des pixels bleus).  Dans certains domaines d'application, cela est tout √† fait acceptable, mais dans d'autres domaines, par exemple, dans la reconnaissance des caract√®res, il est n√©cessaire de d√©tecter les parties internes du motif pour trouver tous les espaces qui distinguent un caract√®re particulier.  (La <b><i>figure 3</i></b> montre le contour ¬´complet¬ª du motif.) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e7/d3b/f5b/0e7d3bf5bc9c451588718fe5d909a2fb.gif" alt="image"></div><br><br>  Par cons√©quent, pour obtenir un contour complet, il est d'abord n√©cessaire d'utiliser l'algorithme de <b><i>¬´recherche de trous¬ª</i></b> qui d√©termine les trous dans un motif donn√©, puis d'appliquer l'algorithme de d√©tection de contour √† chaque trou. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb7/22c/32f/cb722c32fcc45aeea8d8b097a0d01f84.gif" alt="image"></div><a name="habracut"></a><br><h2>  Qu'est-ce que la connectivit√©? </h2><br>  Dans les images num√©riques avec des valeurs binaires, un pixel peut avoir l'une des valeurs suivantes: 1 - lorsqu'il fait partie du motif, ou 0 - lorsqu'il fait partie de l'arri√®re-plan, c'est-√†-dire  pas de d√©grad√© de gris.  (Nous supposerons que les pixels avec une valeur de 1 sont noirs et avec une valeur de 0 sont blancs). <br><br>  Pour identifier des <b><i>objets</i></b> dans un motif num√©rique, nous devons trouver des groupes de pixels noirs qui sont ¬´connect√©s¬ª les uns aux autres.  En d'autres termes, les <b><i>objets</i></b> d'un mod√®le num√©rique donn√© sont les <b><i>composants connect√©s de</i></b> ce mod√®le. <br><br>  Dans le cas g√©n√©ral, un <b><i>composant connect√©</i></b> est un ensemble de pixels noirs <b>P</b> , de telle sorte que pour chaque paire de pixels <b>p <sub>i</sub></b> et <b>p <sub>j</sub></b> dans <b>P</b> il y a une s√©quence de pixels <b><i>p <sub>i</sub> , ..., p <sub>j</sub></i></b> tels que: <br><br>  a) tous les pixels de la s√©quence sont dans l'ensemble <b>P</b> , c'est-√†-dire  sont noirs, et <br><br>  b) tous les 2 pixels <b><i>de la s√©quence c√¥te √† c√¥te</i></b> sont des ¬´voisins¬ª. <br><br>  Une question importante se pose: <b><i>quand peut-on dire que 2 pixels sont ¬´voisins¬ª?</i></b>  Puisque nous utilisons des pixels carr√©s, la r√©ponse √† la question pr√©c√©dente n'est pas anodine pour la raison suivante: en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pavage carr√©, les</a> pixels ont un bord ou un sommet commun, ou n'ont rien en commun.  Chaque pixel a 8 pixels en commun avec lui;  ces pixels constituent le "voisinage de Moore" de ce pixel.  Faut-il consid√©rer des pixels "voisins" n'ayant qu'un seul sommet commun?  Ou pour √™tre consid√©r√©s comme ¬´voisins¬ª, deux pixels doivent avoir un bord commun? <br><br>  Il existe donc deux types de connectivit√©, √† savoir: la connectivit√© 4 et la connectivit√© 8. <br><br><h4>  4 connexions </h4><br>  Quand peut-on dire qu'un ensemble donn√© de pixels noirs est <b><i>connect√© √† 4?</i></b>  Tout d'abord, vous devez d√©finir le concept de <b><i>4 voisins</i></b> (√©galement appel√© <b><i>voisin direct</i></b> ): <br><br>  <b>D√©finition 4 voisins</b> : Un pixel <b>Q</b> est un <b><i>4 voisins d'un</i></b> pixel <b>P</b> donn√© si <b>Q</b> et <b>P</b> ont un bord commun.  Les 4 voisins du pixel <b>P</b> (d√©sign√©s par <b>P2, P4, P6</b> et <b>P8</b> ) sont repr√©sent√©s sur la <b><i>figure 2</i></b> ci-dessous. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02b/592/5ef/02b5925eff29a4b14330e63c43714837.gif" height="202" width="177"></div><br>  <b>D√©finition d'un composant √† 4 connexions</b> : l'ensemble des pixels noirs <b>P</b> est un <b><i>composant √† 4 connexions</i></b> si pour chaque paire de pixels <b>p <sub>i</sub></b> et <b>p <sub>j</sub></b> dans <b>P</b> il y a une s√©quence de pixels <b><i>p <sub>i</sub> , ..., p <sub>j</sub></i></b> tels que: <br><br>  a) tous les pixels de la s√©quence sont dans l'ensemble <b>P</b> , c'est-√†-dire  sont noirs, et <br><br>  b) tous les deux pixels <b><i>adjacents dans la s√©quence</i></b> sont <b><i>4 voisins</i></b> <br><br><h4>  Exemples de mod√®les √† 4 connexions </h4><br>  Les diagrammes ci-dessous montrent des exemples de mod√®les √† 4 connexions: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b71/3c8/b76/b713c8b761d034fc04d486aed3029149.gif" height="216" width="576"></div><br><br><h4>  8 connexions </h4><br>  Quand puis-je dire qu'un ensemble donn√© de pixels noirs est <b><i>connect√© √† 8</i></b> ?  Tout d'abord, nous devons d√©finir le concept d'un <b><i>voisin √† 8</i></b> (√©galement appel√© <b><i>voisin indirect</i></b> ): <br><br>  <b>D√©finition de 8 voisins</b> : Un pixel <b>Q</b> est un <b><i>8 voisins</i></b> (ou juste un <b><i>voisin</i></b> ) d'un pixel <b>P</b> donn√© si <b>Q</b> et <b>P</b> ont un bord ou un sommet commun.  Les 8 voisins d'un pixel <b>P</b> constituent le voisinage de Moore de ce pixel. <br><br>  <b>D√©finition d'un composant connect√© √† 8</b> : l'ensemble des pixels noirs <b>P</b> est un <b><i>composant connect√© √† 8</i></b> (ou juste un <b><i>composant connect√©</i></b> ) si pour chaque paire de pixels <b>p <sub>i</sub></b> et <b>p <sub>j</sub></b> dans <b>P</b> il y a une s√©quence de pixels <b><i>p <sub>i</sub> , ..., p <sub>j</sub></i></b> tels que : <br><br>  a) tous les pixels de la s√©quence sont dans l'ensemble <b>P</b> , c'est-√†-dire  sont noirs, et <br><br>  b) tous les deux pixels <b><i>adjacents dans cette s√©quence</i></b> sont <b><i>8 voisins</i></b> <br><br>  <b>Remarque</b> : tous les mod√®les √† 4 connexions sont √† 8 connexions, c'est-√†-dire  Les mod√®les √† 4 connexions sont un sous-ensemble des nombreux mod√®les √† 8 connexions.  En revanche, un mod√®le √† 8 connexions peut ne pas √™tre √† 4 connexions. <br><br><h4>  Exemple de mod√®le li√© √† 8 </h4><br>  Le diagramme ci-dessous montre un mod√®le qui est connect√© √† 8 mais pas √† 4: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f0/3d4/d90/7f03d4d904e9a4ebd1b7765ee7f4358f.gif" height="180" width="180"></div><br><br><h4>  Un exemple de mod√®le non connect√© √† 8: </h4><br>  Le diagramme ci-dessous montre un exemple d'un mod√®le qui n'est pas connect√© √† 8, c'est-√†-dire  compos√© de plusieurs composants connect√©s (le sch√©ma montre trois composants connect√©s): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/768/7bb/f90/7687bbf9070e4e581e4ebfde132a1164.gif" height="180" width="180"></div><br><br><h2>  Algorithme de trace carr√©e </h2><br><h4>  Id√©e </h4><br>  L'id√©e derri√®re l'algorithme de trac√© carr√© est tr√®s simple;  cela peut √™tre attribu√© au fait que l'algorithme a √©t√© l'une des premi√®res tentatives de d√©tection du contour d'un motif binaire. <br><br>  Pour comprendre comment √ßa marche, il faut un peu d'imagination ... <br><br>  Supposons que nous ayons un motif num√©rique, par exemple, un groupe de pixels noirs sur un fond de pixels blancs, c'est-√†-dire  sur la grille;  trouver le pixel noir et le d√©clarer comme notre pixel " <b>initial</b> ".  (Trouver le pixel ¬´ <b>initial</b> ¬ª peut √™tre impl√©ment√© de diff√©rentes mani√®res; nous commencerons par le coin inf√©rieur gauche de la grille, nous balayerons chaque colonne de pixels de bas en haut, de la colonne la plus √† gauche √† l'extr√™me droite, jusqu'√† ce que nous tombions sur un pixel noir. Nous le d√©clarerons ¬´ <b>initial</b> ¬ª ".) <br><br>  Imaginez maintenant que vous √™tes une coccinelle debout sur le pixel de <b>d√©part</b> , comme le montre la <b><i>figure 1</i></b> ci-dessous.  Pour obtenir le contour d'un motif, vous devez proc√©der comme suit: <br><br> <code> ,      ,  ,  <br> <br>  ,      ,  , <br> <br>      <b></b> .</code> <br> <br>  Les pixels noirs que vous avez encercl√©s seront le contour du motif. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/baa/0c2/69e/baa0c269e22368fa231d774f6bf3b062.gif" height="252" width="216"></div><br>  Un aspect important de l'algorithme du trac√© carr√© est le ¬´sens de l'orientation¬ª.  Les virages √† gauche et √† droite sont effectu√©s par rapport √† l'emplacement actuel, ce qui d√©pend de la fa√ßon dont vous √™tes arriv√© au pixel actuel.  Par cons√©quent, afin de faire les bons mouvements, vous devez suivre votre direction. <br><br><h4>  Algorithme </h4><br>  Ce qui suit est une description formelle de l'algorithme de trace carr√©e: <br><br>  Entr√©e: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pavage</a> carr√©, <b>T</b> , contenant la composante connect√©e <b>P des</b> cellules noires. <br><br>  Sortie: ligne <b>B (b <sub>1</sub> , b <sub>2</sub> , ..., b <sub>k</sub> )</b> de pixels de bordure, c'est-√†-dire  contour. <br><br>  Commencer <br><br><ul><li>  D√©finissez <b>B</b> comme un ensemble vide. </li><li>  Scannez les cellules <b>T</b> de bas en haut et de gauche √† droite jusqu'√† ce qu'un pixel noir <b>s</b> de <b>P soit trouv√©</b> . </li><li>  Ins√©rez <b>s</b> dans <b>B.</b> </li><li>  Faire du pixel actuel <b>p le</b> pixel initial <b>s</b> . </li><li>  Tournez √† gauche, c'est-√†-dire  aller au pixel voisin √† gauche de <b>p</b> . </li><li>  Mettre √† jour <b>p</b> , c'est-√†-dire  il devient le pixel actuel. </li><li>  Alors que <b>p n'est</b> pas √©gal √† <b>s</b> , ex√©cutez <br><br>  Si le pixel actuel <b>p</b> est noir <br><ul><li>  ins√©rez <b>p</b> dans <b>B</b> et tournez √† gauche (allez au pixel voisin √† gauche de <b>p</b> ). </li><li>  Mettre √† jour <b>p</b> , c'est-√†-dire  il devient le pixel actuel. </li></ul><br>  sinon <br><ul><li>  tourner √† droite (passer au pixel suivant √† droite de <b>p</b> ). </li><li>  Mettre √† jour <b>p</b> , c'est-√†-dire  il devient le pixel actuel. </li></ul><br>  Fin du cycle ¬´Bye¬ª </li></ul><br>  La fin <br><br>  <b>Remarque: les</b> concepts de ¬´gauche¬ª et de ¬´droite¬ª doivent √™tre consid√©r√©s non pas par rapport √† la page ou au lecteur, mais par rapport √† la direction d'entr√©e dans le pixel ¬´actuel¬ª pendant la num√©risation. <br><br><h4>  D√©monstration </h4><br>  Ce qui suit est une d√©monstration anim√©e de la fa√ßon dont l'algorithme de trace carr√©e d√©tecte le contour d'un motif.  N'oubliez pas que la coccinelle se d√©place en pixels;  remarquez comment sa direction change en tournant √† gauche et √† droite.  Les virages √† gauche et √† droite sont effectu√©s par rapport √† la direction actuelle dans un pixel, c'est-√†-dire  orientation coccinelle. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39c/148/f77/39c148f774519015dc130273d8383dd3.gif" height="360" width="288"></div><br><h4>  Analyse </h4><br>  Il s'av√®re que les capacit√©s de l'algorithme de trace carr√©e sont tr√®s limit√©es.  Il est incapable de d√©tecter les contours d'une grande famille de motifs qui surviennent souvent dans des applications r√©elles. <br><br>  Ceci est principalement d√ª au fait que les rotations gauche et droite ne prennent pas en compte les pixels situ√©s <br>  diagonales "du pixel actuel. <br><br>  Examinons les diff√©rents mod√®les avec une connectivit√© diff√©rente et voyons pourquoi l'algorithme de trace carr√©e √©choue.  De plus, nous √©tudierons les moyens d'am√©liorer les capacit√©s de l'algorithme et de le faire fonctionner m√™me avec des mod√®les qui ont un type sp√©cial de connectivit√©. <br><br><h4>  Crit√®re d'arr√™t </h4><br>  L'une des faiblesses de l'algorithme est le choix du crit√®re d'arr√™t.  En d'autres termes, quand un algorithme cesse-t-il de s'ex√©cuter? <br><br>  Dans la description d'origine de l'algorithme de trace carr√©e, la condition de fin consiste √† toucher le pixel <b>initial</b> une deuxi√®me fois.  Il s'av√®re que si l'algorithme d√©pend d'un tel crit√®re, il ne pourra pas d√©tecter les contours d'une grande famille de motifs. <br><br>  Ce qui suit est une d√©monstration anim√©e expliquant comment l'algorithme est incapable de d√©tecter le contour exact du motif en raison de la s√©lection d'un mauvais crit√®re d'arr√™t: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ef/783/09a/0ef78309a17e9e72b09a28890abb6791.gif" height="252" width="216"></div><br>  Comme vous pouvez le voir, l'am√©lioration du crit√®re d'arr√™t peut √™tre un bon d√©but pour am√©liorer les performances globales de l'algorithme.  Il existe deux alternatives efficaces pour un crit√®re d'arr√™t existant: <br><br>  a) Arr√™tez-vous uniquement en visitant le pixel de <b>d√©part</b> <b><i>n</i></b> fois, o√π n vaut au moins 2, OU <br><br>  b) Arr√™tez apr√®s avoir frapp√© le pixel de <b>d√©part</b> une deuxi√®me fois, tout comme nous l'avons touch√© au d√©part. <br><br>  Ce crit√®re a √©t√© propos√© par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jacob Eliosoff</a> , nous l'appellerons donc le <b><i>crit√®re d'arr√™t de Jacob</i></b> . <br><br>  La modification du crit√®re d'arr√™t dans le cas g√©n√©ral am√©liore l'efficacit√© de l'algorithme de trace carr√©e, mais ne rem√©die pas aux autres faiblesses qu'il pr√©sente dans le cas de mod√®les avec des types de connectivit√© sp√©ciaux. <br><br>  L'algorithme de tra√ßage carr√© est incapable de d√©tecter le contour d'une famille de motifs avec une connectivit√© de 8 qui n'a PAS une connectivit√© de 4. <br><br>  Ce qui suit est une d√©monstration anim√©e de la fa√ßon dont l'algorithme de trace carr√©e (avec le crit√®re d'arr√™t de Jacob) ne parvient pas √† d√©tecter le contour correct d'un mod√®le avec connectivit√© 8 sans connectivit√© 4: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9bb/c26/238/9bbc26238da41c3fb5c5eac1e44fe507.gif" height="288" width="216"></div><br><h2>  Cet algorithme est-il compl√®tement inutile? </h2><br>  Si vous lisez l'analyse ci-dessus, vous pensez probablement que l'algorithme de trace carr√©e ne parvient pas √† d√©tecter les contours de la plupart des mod√®les.  Mais cela s'av√®re.  qu'il existe une famille sp√©ciale de motifs dans lesquels le chemin est enti√®rement d√©tect√© par l'algorithme de trace carr√©e. <br><br>  Soit <b>P</b> l'ensemble des pixels noirs avec la connectivit√© 4 sur la grille.  Soit les pixels blancs de la grille, c'est-√†-dire  les pixels d'arri√®re-plan <b>W</b> ont √©galement une connectivit√© de 4. Il s'av√®re que dans de telles conditions du motif et de son arri√®re-plan, il peut √™tre prouv√© que l'algorithme de trace carr√©e (avec le crit√®re d'arr√™t de Jacob) traitera toujours avec succ√®s la d√©termination du contour. <br><br>  Ci-dessous est la preuve que dans le cas o√π le motif et les pixels d'arri√®re-plan sont connect√©s, l'algorithme de trace carr√©e d√©terminera correctement le contour lors de l'utilisation du crit√®re d'arr√™t Jacob. <br><br>  Preuve <br>  <b>√âtant donn√©</b> : le motif <b>P est</b> tel que tous les pixels du motif (c'est-√†-dire noir) et les pixels d'arri√®re-plan (c'est-√†-dire blanc) W ont une connectivit√© de 4. <br><br>  <b>Premi√®re observation</b> <br><br>  Puisque l'ensemble de pixels blancs W a une connectivit√© de 4, cela signifie qu'il ne peut pas y avoir de ¬´ <b><i>trous</i></b> ¬ª dans le motif (en termes informels, ¬´ <b><i>trous</i></b> ¬ª, nous entendons des groupes de pixels blancs compl√®tement entour√©s par des pixels noirs du motif). <br><br>  La pr√©sence de tout ¬´ <b><i>trou</i></b> ¬ª dans le motif entra√Ænera la s√©paration du groupe de pixels blancs des pixels blancs restants;  cependant, de nombreux pixels blancs perdent leur connectivit√© 4. <br><br>  <i>La figure 2</i> et la <b><i>figure 3</i></b> ci-dessous montrent deux types de ¬´ <b><i>trous</i></b> ¬ª qui peuvent se produire dans un mod√®le avec connectivit√© 4: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d9/a4e/9b1/8d9a4e9b18b2753038c0abbd11ad7dcd.gif" height="180" width="432"></div><br><br>  <b>Deuxi√®me observation</b> <br><br>  Deux pixels noirs d'un motif DOIVENT avoir un c√¥t√© commun. <br><br>  Supposons que deux pixels noirs aient un seul sommet commun.  Ensuite, afin de satisfaire la propri√©t√© de 4-connectivit√© du motif, il doit y avoir un chemin reliant ces deux pixels afin que tous les deux pixels adjacents sur ce chemin aient une connectivit√© de 4. Mais cela nous donnera un motif similaire √† la <b><i>figure 3</i></b> .  En d'autres termes, cela entra√Ænera une s√©paration des pixels blancs.  <b><i>La figure 4</i></b> ci-dessous montre un motif typique satisfaisant √† l'hypoth√®se que les pixels du motif et de l'arri√®re-plan sont connect√©s en 4, c'est-√†-dire  n'ont pas de ¬´ <b><i>trous</i></b> ¬ª et tous les deux pixels noirs ont un c√¥t√© commun: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a68/2e0/7e0/a682e07e0732655da35269badcfe6b69.gif" height="216" width="216"></div><br>  Il est utile de repr√©senter ces mod√®les comme suit: <br><br>  Nous consid√©rons d'abord les pixels limites, c'est-√†-dire  contour du motif.  Ensuite, si nous consid√©rons chaque pixel fronti√®re comme ayant 4 bords de longueur unitaire, nous verrons que certains de ces bords sont communs avec les pixels blancs voisins.  Nous appellerons ces ar√™tes des ar√™tes <b><i>limites</i></b> . <br><br>  Ces bords limites peuvent √™tre consid√©r√©s comme des bords d'un polygone.  Dans l' <b><i>image</i></b> <b><i><br></i></b>  <b><i>5</i></b> ci-dessous, cette id√©e est illustr√©e par l'exemple d'un polygone correspondant au motif de la <b><i>figure 4</i></b> ci-dessus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/220/ebe/5ea/220ebe5ea9383e00a2709117b237248b.gif" height="216" width="216"></div><br>  Si nous consid√©rons toutes les ¬´configurations¬ª possibles de pixels limites qui peuvent se produire dans de tels motifs, nous verrons qu'il existe deux cas simples, illustr√©s dans les <b><i>figures 6</i></b> et <b><i>7</i></b> ci-dessous. <br><br>  Les pixels limites peuvent √™tre des multiples de ces cas ou d'autres dispositions, c'est-√†-dire  les rebondissements de ces deux cas.  Les c√¥tes fronti√®res sont marqu√©es en bleu comme <b>E1, E2, E3</b> et <b>E4</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf5/99b/6fa/bf599b6fafebb09a80c32eceb0520270.gif" height="216" width="576"></div><br>  <b>Troisi√®me observation</b> <br><br>  Dans le cas des deux cas ci-dessus, quel que soit le pixel initial que nous choisissons, et quelle que soit la direction dans laquelle il <b>tombe</b> , l'algorithme de trac√© carr√© ne <b>"reviendra"</b> jamais <b>(retour arri√®re)</b> , il ne <b>"traversera"</b> jamais <b>le</b> <i>bord de fronti√®re</i> deux fois seulement s'il ne trace pas la fronti√®re une deuxi√®me fois) et ne manquez jamais le <b><i>bord de</i></b> la <b><i>fronti√®re</i></b> .  D√©couvrez-le! <br><br>  Deux concepts doivent √™tre clarifi√©s ici: <br><br>  a) l'algorithme <b>"remonte"</b> , quand avant de tracer la bordure enti√®re il revient pour visiter un pixel d√©j√† visit√©, et <br><br>  b) pour chaque <b><i>nervure limite,</i></b> il y a deux fa√ßons de <b>¬´la traverser¬ª</b> , √† savoir ¬´vers l'int√©rieur¬ª et ¬´vers l'ext√©rieur¬ª (o√π ¬´vers l'int√©rieur¬ª signifie le mouvement vers l'int√©rieur du polygone correspondant et ¬´vers l'ext√©rieur¬ª - vers l'ext√©rieur du polygone). <br><br>  De plus, lorsque l'algorithme passe "vers l'int√©rieur" √† travers l'un des bords de fronti√®re, il passera "vers l'ext√©rieur" √† travers le bord de fronti√®re suivant, c'est-√†-dire  l'algorithme de trac√© carr√© ne doit pas pouvoir traverser deux bords cons√©cutifs de la m√™me mani√®re. <br><br>  <b>Derni√®re observation</b> <br><br>  Chaque motif a un <b>nombre pair d'</b> <b>ar√™tes limites</b> . <br><br>  Si vous regardez le polygone de la <b><i>figure 5</i></b> , vous pouvez voir que: <br><br>  si nous voulons partir du sommet <b>S</b> marqu√© dans le diagramme et suivre les bords limites jusqu'√† ce que nous atteignions √† nouveau <b>S</b> , alors nous remarquons que dans le processus, nous traversons un nombre pair de bords limites.  Nous pouvons consid√©rer chaque bord de fronti√®re comme un ¬´pas¬ª dans une direction distincte.  Ensuite, pour chaque ¬´pas¬ª √† droite, il doit y avoir un ¬´pas¬ª correspondant √† gauche, si nous voulons revenir √† la position de d√©part.  Il en va de m√™me pour les ¬´marches¬ª verticales.  Par cons√©quent, les ¬´√©tapes¬ª doivent avoir des paires correspondantes, ce qui explique pourquoi chacun de ces motifs aura un nombre pair d'ar√™tes limites. <br><br>  Par cons√©quent, lorsque l'algorithme de tra√ßage des carr√©s entre par le <b>bord limite initial</b> (du pixel initial) une deuxi√®me fois, il le fera dans <b>la m√™me</b> direction que la premi√®re fois. <br><br>  La raison en est que, comme il existe deux fa√ßons de traverser le bord de limite, et que l'algorithme se d√©place alternativement vers l'int√©rieur et l'ext√©rieur, et qu'il existe un nombre pair de bords de limite, l'algorithme passera pour la deuxi√®me fois par le bord de limite initial de la m√™me mani√®re que dans premier. <br><br><h4>  Conclusion </h4><br>  Dans le cas d'un motif et d'un arri√®re-plan connect√©s √† 4, l'algorithme de trac√© carr√© d√©tectera la bordure enti√®re, c'est-√†-dire  contour, motif et cessera de fonctionner apr√®s une seule trace, c.-√†-d.  il ne le tracera pas √† nouveau, car lorsqu'il atteindra le <b>bord limite initial</b> pour la deuxi√®me fois, il l'entrera de la m√™me mani√®re que la premi√®re fois.  Par cons√©quent, l'algorithme de trac√© carr√© avec le crit√®re d'arr√™t de Jacob d√©terminera correctement le compteur de n'importe quel motif, √† condition que le motif et l'arri√®re-plan soient tous les quatre connect√©s. <br><br><h2>  Retrouver les environs de Moore </h2><br><h4>  Id√©e </h4><br>  L'id√©e derri√®re le tra√ßage Moore-Neighbour est simple;  mais avant de l'expliquer, nous devons expliquer un concept important: <b><i>le voisinage Moore d'un</i></b> pixel. <br><br><h4>  Le quartier de Moore </h4><br>  Le voisinage de Moore d'un pixel <b>P</b> est un ensemble de 8 pixels ayant un sommet ou un bord commun avec ce pixel.  Ces pixels, √† savoir <b>P1, P2, P3, P4, P5, P6, P7 et P8</b> , sont repr√©sent√©s sur la <b><i>figure 1</i></b> . <br><br>  Le quartier Moore (√©galement appel√© <b><i>8 voisins</i></b> ou <b><i>voisins</i></b> <b><i>indirects</i></b> ) est un concept important souvent mentionn√© dans la litt√©rature. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/863/08c/2ea/86308c2ea8863bc111d206fb5070250f.gif" height="195" width="178"></div><br>  Nous sommes maintenant pr√™ts √† nous familiariser avec l'id√©e qui sous-tend la trace de l'environnement de Moore. <br><br>  Qu'il y ait un mod√®le num√©rique, c'est-√†-dire  un groupe de pixels noirs, sur un fond de pixels blancs, c'est-√†-dire  sur la grille;  trouver le pixel noir et le d√©clarer pixel " <b>initial</b> ".  (Il existe plusieurs fa√ßons de trouver le pixel ¬´ <b>initial</b> ¬ª, mais comme pr√©c√©demment, nous commencerons par le coin inf√©rieur gauche et num√©riserons toutes les colonnes de pixels dans l'ordre, jusqu'√† ce que nous trouvions le premier pixel noir, que nous d√©clarerons ¬´ <b>initial</b> ¬ª.) <br><br>  Maintenant, imaginez √† nouveau que vous √™tes une coccinelle debout sur le pixel de <b>d√©part</b> , comme le montre la <b><i>figure 2</i></b> ci-dessous.  Sans perte de g√©n√©ralisation, nous allons d√©tecter le contour en se d√©pla√ßant dans le sens horaire.  (Peu importe la direction que nous choisissons, l'essentiel est de l'utiliser constamment dans l'algorithme). <br><br>  L'id√©e g√©n√©rale est la suivante: chaque fois que nous arrivons au pixel noir <b>P</b> , nous revenons, c'est-√†-dire au pixel blanc dans lequel nous nous trouvions auparavant.  Ensuite, <b>nous</b> contournons le pixel <b>P</b> dans le sens des aiguilles d'une montre, visitant chaque pixel √† proximit√© de Moore, jusqu'√† ce que nous arrivions au pixel noir.  L'algorithme se termine lorsque le pixel de d√©part atteint le pixel de d√©marrage une deuxi√®me fois. <br><br>  Ces pixels noirs que l'algorithme a visit√©s seront le contour du motif. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43e/afb/a2f/43eafba2f0611e11eb82c8ed7159971c.gif" height="252" width="216"></div><br><h4>  Algorithme </h4><br>  Voici une description formelle de l'algorithme de suivi du voisinage de Moore: <br><br>  Entr√©e: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pavage</a> carr√© <b>T</b> contenant une composante connect√©e <b>P</b> de cellules noires. <br><br>  Sortie: ligne <b>B (b <sub>1</sub> , b <sub>2</sub> , ..., b <sub>k</sub> ) de</b> pixels limites, c'est-√†-dire  contour. <br><br>  Notons <b>M (a)</b> le voisinage de Moore du pixel <b>a</b> . <br><br>  Soit <b>p</b> le pixel de bordure actuel. <br><br>  Soit <b>c</b> le pixel courant consid√©r√©, c'est-√†-dire  <b>c</b> est dans <b>M (p)</b> . <br><br>  Commencer <br><br><ul><li>  D√©finissez <b>B</b> comme un ensemble vide. </li><li>  De bas en haut et de gauche √† droite, scannez les cellules <b>T</b> jusqu'√† ce que nous trouvions un pixel noir <b>s</b> de <b>P.</b> </li><li>  Ins√©rez <b>s</b> dans <b>B.</b> </li><li>  Nous d√©finissons le point <b>s</b> comme le point limite actuel <b>p</b> , c'est-√†-dire  <b>p = s</b> </li><li>  Revenons en arri√®re, c'est-√†-dire  Passons au pixel d'o√π nous sommes arriv√©s √† l' <b>art</b> . </li><li>  Soit <b>c le</b> pixel suivant dans le sens des aiguilles d'une montre dans <b>M (p)</b> . </li><li>  Alors que <b>c n'est</b> pas √©gal √† <b>s</b> , ex√©cutez <br><br><ul><li>  si <b>c</b> est noir <br><ul><li>  Ins√©rez <b>c</b> dans <b>B</b> </li><li>  on pose <b>p = c</b> </li><li>  revenir en arri√®re (d√©placer le pixel actuel <b>c</b> vers le pixel √† partir duquel nous sommes arriv√©s √† <b>p</b> ) </li></ul><br>  sinon <br><ul><li>  d√©placer le pixel actuel <b>c</b> vers le pixel suivant dans le sens des aiguilles d'une montre dans <b>M (p)</b> </li></ul><br>  Fin du cycle d'adieu </li></ul></li></ul><br>  La fin <br><br><h4>  D√©monstration </h4><br>  Ce qui suit est une d√©monstration anim√©e de la fa√ßon dont la trace de voisinage de Moore effectue la d√©tection de contour de motif.  (Nous avons d√©cid√© de tracer le contour dans le sens horaire.) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/544/3f0/295/5443f02954a35cf08c7a9e462bfa0f8a.gif" height="360" width="360"></div><br><h4>  Analyse </h4><br>  La principale faiblesse du trac√© des environs de Moore r√©side dans le choix des crit√®res d'arr√™t. <br><br>  Dans la description originale de l'algorithme de tra√ßage de l'environnement de Moore, le crit√®re d'arr√™t est de toucher le pixel <b>initial</b> une seconde fois.  Semblable √† l'algorithme de trac√© carr√©, il s'av√®re que le tra√ßage de l'environnement de Moore en utilisant ce crit√®re ne peut pas d√©tecter les contours d'une grande famille de motifs. <br><br>  Ce qui suit est une d√©monstration anim√©e expliquant pourquoi l'algorithme ne peut pas trouver le contour exact du motif en raison de la s√©lection d'un mauvais crit√®re d'arr√™t: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1c/d5e/7af/a1cd5e7afa1cd1b7312e5770c6cf826c.gif" height="252" width="216"></div><br>  Comme vous pouvez le voir, l'am√©lioration du crit√®re d'arr√™t peut √™tre un bon d√©but pour am√©liorer les performances globales de la trace.  Il existe deux alternatives efficaces pour le crit√®re d'arr√™t, similaires au crit√®re d'arr√™t de Jacob. <br><br>  L'utilisation du crit√®re de Jacob am√©liore consid√©rablement l'efficacit√© du tra√ßage de l'environnement de Moore, ce qui en fait le meilleur algorithme pour d√©terminer le contour de n'importe quel motif, quelle que soit sa connectivit√©. <br><br>  La raison en est principalement que l'algorithme v√©rifie tout le voisinage de Moore du pixel limite pour rechercher le pixel limite suivant.  Contrairement √† l'algorithme de trac√© carr√©, qui ne tourne qu'√† gauche et √† droite et qui manque les pixels ¬´en diagonale¬ª, le trac√© de voisinage de Moore sera toujours en mesure de d√©tecter la limite ext√©rieure de tout composant connect√©.  La raison en est la suivante: pour tout motif √† <b><i>8 connexions</i></b> (ou simplement <b><i>connect√©</i></b> ), le pixel de bordure <b>suivant</b> se trouve dans le voisinage de Moore du pixel de bordure actuel.  √âtant donn√© que la trace de voisinage de Moore v√©rifie chacun des pixels dans le voisinage de Moore du pixel limite actuel, il doit d√©tecter le pixel limite suivant. <br><br>  Lorsque le trac√© du voisinage de Moore atteint le pixel initial une deuxi√®me fois de la m√™me mani√®re que la premi√®re fois, cela signifie qu'un <b>contour externe</b> <b>complet</b> <b>du</b> motif a √©t√© d√©tect√©, et si l'algorithme n'est pas arr√™t√©, il d√©tectera √† nouveau le m√™me contour. <br><br><h2>  Balayage radial </h2><br>  L'algorithme de balayage radial est un algorithme de d√©tection de contour discut√© dans certains livres.  Malgr√© le nom complexe, l'id√©e sous-jacente est tr√®s simple.  En fait, il s'av√®re que l'algorithme de balayage radial <b>est identique √† la</b> trace de l'environnement de Moore.  On peut se demander: "Pourquoi le mentionnons-nous?" <br><br>  Le tra√ßage de l'environnement de Moore recherche √† proximit√© de Moore le pixel limite actuel dans une certaine direction (nous avons choisi la direction horaire) jusqu'√† ce qu'il trouve un pixel noir.  Elle d√©clare ensuite ce pixel comme pixel limite actuel et continue. <br><br>  L'algorithme de balayage radial fait de m√™me.  D'un autre c√¥t√©, il fournit un moyen int√©ressant de trouver le prochain pixel noir dans le voisinage de Moore d'un pixel limite donn√©. <br><br>  La m√©thode est bas√©e sur l'id√©e suivante: <br><br>  chaque fois que nous trouvons un nouveau pixel limite, en faisons le pixel actuel <b>P</b> et dessinons <b>un segment de ligne imaginaire</b> reliant <b>P</b> au pixel limite <b>pr√©c√©dent</b> .  Ensuite, nous faisons <b>pivoter le</b> segment par rapport √† <b>P</b> dans le sens des aiguilles d'une montre jusqu'√† ce qu'il rencontre un pixel noir dans le voisinage de Moore du pixel <b>P.</b>  La rotation de la ligne est identique √† la v√©rification de chaque pixel au voisinage de Moore <b>P.</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous avons cr√©√© une d√©monstration anim√©e du fonctionnement de l'algorithme de balayage radial et √† quoi il ressemble en tra√ßant les environs de Moore. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa1/419/ff6/fa1419ff6b8efc7ef94d978854f99fab.gif" height="360" width="326"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et quand l'algorithme de balayage radial s'arr√™te-t-il? </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Expliquons le comportement de l'algorithme en utilisant les crit√®res d'arr√™t suivants ...</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crit√®re d'arr√™t 1 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laissez l'algorithme de balayage radial se terminer lorsqu'il visite le </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixel initial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> une deuxi√®me fois. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous trouverez ci-dessous une d√©monstration anim√©e, √† partir de laquelle il est clair pourquoi le crit√®re de rupture sera modifi√© correctement.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04c/432/408/04c432408fca093316e950c77bdd5537.gif" height="252" width="216"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il convient √©galement de mentionner qu'en utilisant ce crit√®re d'arr√™t dans les deux algorithmes, l'efficacit√© de l'algorithme de balayage radial est identique au tra√ßage de l'environnement de Moore. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans l'algorithme de trace carr√©e et dans la trace de voisinage de Moore, nous avons constat√© que l'utilisation du crit√®re d'arr√™t de Jacob am√©liore consid√©rablement les performances des deux algorithmes. </font></font><br><br> <b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le crit√®re d'arr√™t de Jacob</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√©cessite que l'algorithme arr√™te de s'ex√©cuter lorsqu'il visite le </font><font style="vertical-align: inherit;">pixel de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©part</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> une deuxi√®me fois dans la m√™me direction que la premi√®re fois. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malheureusement, nous ne pouvons pas utiliser le crit√®re d'arr√™t de Jacob dans l'algorithme de balayage radial. La raison en est que l'algorithme de balayage radial ne d√©finit pas le concept</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La "direction" dans laquelle il frappe le pixel limite</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">En d'autres termes, la ¬´direction¬ª dans laquelle l'algorithme est tomb√© dans le pixel limite n'est pas claire (et sa d√©finition n'est pas triviale). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par cons√©quent, nous devons proposer un autre crit√®re d'arr√™t, qui ne d√©pend pas de la direction de frapper un certain pixel, ce qui peut am√©liorer l'efficacit√© de l'algorithme de balayage radial ...</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crit√®re d'arr√™t 2 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supposons que chaque fois que l'algorithme d√©tecte un nouveau pixel fronti√®re </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , il soit ins√©r√© dans une </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s√©rie de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixels fronti√®re: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ..., P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; et d√©clar√© comme pixel de bordure actuel. ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous consid√©rerons le </font><font style="vertical-align: inherit;">pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">initial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Cela signifie que nous connaissons le pixel de bordure pr√©c√©dent </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-1 de</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> chaque pixel de bordure actuel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . (Quant au </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixel de d√©part</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nous supposerons que </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est un pixel imaginaire qui n'est √©quivalent √† aucun des pixels de la grille qui fait face au </font><font style="vertical-align: inherit;">pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">initial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de la rang√©e de pixels limites). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sur la base des hypoth√®ses ci-dessus, nous pouvons d√©terminer le crit√®re d'arr√™t comme suit: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'algorithme arr√™te l'ex√©cution lorsque: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) le pixel limite actuel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s'est </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pr√©c√©demment</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rencontr√© en tant que pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (o√π </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j &lt;i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dans une s√©rie de pixels limites, Et </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i- 1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j-1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En d'autres termes, l'algorithme termine son ex√©cution lorsqu'il visite le pixel limite P dans le </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">second</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fois si le pixel limite avant P (dans la rang√©e de pixels limites) pour la deuxi√®me fois est </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le m√™me</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixel qu'avant P lorsque P a √©t√© visit√© pour la </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">premi√®re</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fois. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la condition du crit√®re d'arr√™t est satisfaite et que l'algorithme ne s'arr√™te pas, l'algorithme de balayage radial continuera √† d√©tecter </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la m√™me</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> limite une deuxi√®me fois. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les performances de l'algorithme de balayage radial avec ce crit√®re d'arr√™t sont similaires √† celles du tra√ßage du voisinage de Moore avec le crit√®re d'arr√™t Jacob.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithme de Theo Pavlidis </font></font></h2><br><h4>  Id√©e </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cet algorithme est l'un des derniers algorithmes de d√©tection de boucle propos√©s par </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Theo Pavlidis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Il l'a cit√© dans son livre de 1982, </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algorithms for Graphics and Image Processing</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (chapitre 7, section 5). Ce n'est pas aussi simple que l'algorithme de tra√ßage des carr√©s ou de tra√ßage de l'environnement de Moore, mais ce n'est pas si compliqu√© (c'est typique de la plupart des algorithmes de d√©tection de bord). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous n'expliquerons pas cet algorithme de la m√™me mani√®re que cela a √©t√© fait dans son livre. Notre approche est plus facile √† comprendre et donne une id√©e de l'id√©e g√©n√©rale sous-jacente √† l'algorithme.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sans perte de g√©n√©ralisation, nous avons d√©cid√© de faire le tour de la boucle dans le sens horaire pour correspondre √† l'ordre de tous les autres algorithmes pr√©sent√©s dans l'article. En revanche, Pavlidis a choisi la direction dans le sens antihoraire. Cela n'affectera pas les performances de l'algorithme. La seule diff√©rence est la direction relative des mouvements que nous ferons lorsque nous contournerons le contour. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passons maintenant √† l'id√©e ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disons que nous avons un mod√®le num√©rique, c'est-√†-dire un groupe de pixels noirs sur fond de pixels blancs, c'est-√†-dire sur la grille; trouver le pixel noir et le d√©clarer pixel " </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">initial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". Vous pouvez rechercher le </font><font style="vertical-align: inherit;">pixel </font><font style="vertical-align: inherit;">¬´de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©part</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬ª de diff√©rentes mani√®res, par exemple, comme d√©crit ci-dessus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour trouver l' </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">initiale</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixels pour utiliser cette m√©thode est facultatif. Au lieu de cela, nous choisirons un </font><font style="vertical-align: inherit;">pixel de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©part</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qui satisfait aux restrictions suivantes impos√©es par l'algorithme Pavlidis pour s√©lectionner un pixel de d√©part: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une limitation importante de la direction dans laquelle nous entrons le pixel de d√©part</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En fait, vous pouvez choisir N'IMPORTE QUEL pixel de bordure noire comme pixel de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©part</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans cette condition: si vous vous tenez initialement dessus, le pixel voisin gauche n'est PAS noir. En d'autres termes, vous devez entrer le </font><font style="vertical-align: inherit;">pixel de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©part</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans une direction telle que le pixel voisin gauche est blanc (la ¬´gauche¬ª ici est prise par rapport √† la direction dans laquelle nous entrons le </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixel de d√©part</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imaginez maintenant que vous √™tes une coccinelle debout</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixel de </font><b><font style="vertical-align: inherit;">d√©part</font></b><font style="vertical-align: inherit;"> , comme le montre la </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">figure 1</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ci-dessous. Lors de l'ex√©cution de l'algorithme, nous ne nous int√©resserons qu'√† trois pixels devant vous, soit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1, P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> illustr√©s √† la </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">figure 1</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . (Nous d√©signerons </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comme le </font><font style="vertical-align: inherit;">pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devant</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vous, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le pixel √† gauche de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le pixel √† droite de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53e/792/4b1/53e7924b1a7cb6c5e84f70a038d52bc8.gif" height="252" width="216"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme pour l'algorithme de trace carr√©e, la chose la plus importante dans l'algorithme de Pavlidis est le ¬´sens de l'orientation¬ª. Les virages √† gauche et √† droite sont relatifs √† la position actuelle, qui d√©pend de la fa√ßon dont vous avez entr√© le pixel actuel. Par cons√©quent, afin de faire les bons mouvements, il est important de garder une trace de votre orientation actuelle. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais quelle que soit votre position, les pixels P1, P2 et P3 sont d√©termin√©s comme d√©crit ci-dessus.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ayant ces informations, nous sommes pr√™ts √† expliquer l'algorithme ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaque fois que vous vous tenez sur le pixel limite actuel (qui est d'abord le </font><font style="vertical-align: inherit;">pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">initial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), nous faisons ce qui suit: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , v√©rifiez le pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Si </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1 est</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> noir, d√©clarez </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le pixel limite actuel et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avancer d'un pas, puis faire un pas vers la gauche</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour √™tre √† P1 (l' </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ordre des</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d√©placements est tr√®s important). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">figure 2</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ci - </font><font style="vertical-align: inherit;">dessous illustre ce cas. </font><font style="vertical-align: inherit;">Le chemin pour arriver √† </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est indiqu√© en bleu.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae9/c32/131/ae9c321310cb5a8902ae4df3dc42cdc9.gif" height="180" width="206"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et seulement si P1 est blanc, nous proc√©dons √† la v√©rification de P2 ...</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2 est</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> noir, alors d√©clarons </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2 le</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixel limite actuel et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avan√ßons d'un pas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour √™tre sur </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ce cas est illustr√© √† la </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">figure 3</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ci-dessous. </font><font style="vertical-align: inherit;">Le chemin que vous devez suivre sur </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est indiqu√© en bleu.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b34/7eb/934/b347eb9345873e5ba6aa136ab2fbb406.gif" height="180" width="206"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uniquement si P1 et P2 sont blancs, passez √† la v√©rification P3 ...</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3 est</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> noir, d√©clarez </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3 le</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixel de bordure actuel et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©placez-vous d'un pas vers la droite, puis d'un pas vers la gauche</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , comme le montre la figure 4 ci-dessous.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ad/bb6/7fa/0adbb67fa67183dec47bb4c1bf3221a7.gif" height="180" width="206"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est tout!</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Trois r√®gles simples pour trois cas simples. Comme vous pouvez le voir, il est important de garder une trace de votre direction dans les virages, car tous les d√©placements sont effectu√©s par rapport √† l'orientation actuelle. Mais il semble que nous ayons oubli√© quelque chose? </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et si les trois pixels sont blancs devant nous?</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ensuite, nous tournons (debout au pixel limite actuel) de 90 degr√©s dans le sens des aiguilles d'une montre pour voir un nouvel ensemble de trois pixels devant nous. Ensuite, nous faisons la m√™me v√©rification pour ces nouveaux pixels. Vous avez peut-√™tre encore une question: que faire si </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ces</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> trois pixels sont blancs?! Ensuite, nous tournons √† 90 degr√©s dans le sens des aiguilles d'une montre, en nous tenant au m√™me pixel. Avant de v√©rifier tout le voisinage du pixel de Moore, vous pouvez faire pivoter trois fois (chaque fois √† 90 degr√©s dans le sens des aiguilles d'une montre).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous tournons trois fois sans jamais trouver de pixels noirs, cela signifie que nous nous trouvons sur un </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixel isol√©</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qui n'est connect√© √† aucun autre pixel noir. C'est pourquoi l'algorithme vous permet de faire pivoter trois fois, puis termine son ex√©cution. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autre aspect: </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quand l'algorithme termine-t-il l'ex√©cution?</font></font></i></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L'algorithme se termine dans deux cas: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) comme mentionn√© ci-dessus. l'algorithme vous permet de faire pivoter trois fois (90 degr√©s dans le sens horaire √† chaque fois), apr√®s avoir termin√© l'ex√©cution et d√©clar√© le pixel isol√© OU </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) lorsque le pixel limite actuel est le </font><font style="vertical-align: inherit;">pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">initial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , l'algorithme termine l'ex√©cution en ¬´d√©clarant¬ª qu'il a d√©tect√© le contour du motif.</font></font><br><br><h4>  Algorithme </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici une description formelle de l'algorithme de Pavlidis: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entr√©e: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pavage</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> carr√© </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contenant une composante connect√©e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cellules noires. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sortie: ligne </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B (b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ..., b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixels limites, c'est-√†-dire </font><font style="vertical-align: inherit;">contour. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©finitions:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notons </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p le</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixel limite actuel, c'est-√†-dire </font><font style="vertical-align: inherit;">le pixel sur lequel nous nous tenons.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©finissez </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1, P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comme suit: </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(voir √©galement la figure 1 ci-dessus)</font></font></i></b> </li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le pixel devant vous, adjacent √† celui sur lequel vous vous tenez, c'est-√†-dire </font><font style="vertical-align: inherit;">avec pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li> <b>P1</b> ‚Äî  ,   <b>P2</b> . </li><li> <b>P3</b> ‚Äî  ,   <b>P2</b> . </li><li>  <b>¬´¬ª</b>            . </li></ul><br>  Commencer <br><br><ul><li>  <b>B</b>   . </li><li>   <b>T</b>     ,      <b></b>  <b>s</b>  <b>P</b> <b><i>(.     ,       )</i></b> </li><li>  <b>s</b>  <b>B</b> . </li><li>    <b>p</b>     <b>s</b> . </li><li>  : <br>   <b>P1</b>  <br><ul><li>  <b>P1</b>  <b>B</b> </li><li>  <b>p=P1</b> </li><li>     ,      </li></ul><br>   <b>P2</b>  <br><ul><li>  <b>P2</b>  <b>B</b> </li><li>  <b>p=P2</b> </li><li>      <b><i>(.   3)</i></b> </li></ul><br>   <b>P3</b>  <br><ul><li>  <b>P3</b>  <b>B</b> </li><li>  <b>p=P3</b> </li><li>    ,      <b><i>(.   4)</i></b> </li></ul><br>        90    ,   <b>  p</b> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terminer le programme et d√©clarer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p un</font></font></b> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isol√©</font></font></b><font style="vertical-align: inherit;"></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sinon </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tourner de 90 degr√©s dans le sens des aiguilles d'une montre, se tenant au pixel actuel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></b> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'√† pr√©sent </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p = s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Fin de la boucle de r√©p√©tition)</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La fin </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D√©monstration </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce qui suit est une d√©monstration anim√©e de la fa√ßon dont l'algorithme Pavlidis d√©tecte le contour d'un motif donn√©. </font><font style="vertical-align: inherit;">N'oubliez pas que nous marchons en pixels; </font><font style="vertical-align: inherit;">remarquez comment l'orientation change lorsque vous tournez √† gauche ou √† droite. </font><font style="vertical-align: inherit;">Pour expliquer l'algorithme de mani√®re aussi d√©taill√©e que possible, nous y avons inclus tous les cas possibles.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22a/f0f/1dd/22af0f1dd39a517bb6097cd0fe3ec99d.gif" height="324" width="288"></div><br><h4>  Analyse </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous pensez que l'algorithme Pavlidis est id√©al pour d√©tecter les contours de motifs, alors vous devriez changer d'avis ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cet algorithme est vraiment un peu plus compliqu√© que, par exemple, pour tracer les environs de Moore, dans lequel il n'y a pas de cas particuliers qui n√©cessitent un traitement s√©par√©, mais il ne sera pas en mesure de d√©terminer les contours d'un grand une famille de mod√®les qui a un certain type de connectivit√©. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'algorithme fonctionne tr√®s bien sur les mod√®les √† 4 connexions. Son probl√®me se produit lors du tra√ßage de certains mod√®les connect√©s √† 8 qui ne sont pas connect√©s √† 4. Ce qui suit est une d√©monstration anim√©e de la fa√ßon dont l'algorithme Pavlidis ne parvient pas √† d√©tecter le contour correct d'un mod√®le √† 8 connexions (pas un mod√®le √† 4 connexions) - il saute la majeure partie de la fronti√®re.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/225/56a/816/22556a816442cf010492cc30b64392eb.gif" height="252" width="247"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe deux fa√ßons simples de modifier un algorithme pour am√©liorer consid√©rablement ses performances. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Remplacer le crit√®re d'arr√™t</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Au lieu de terminer l'algorithme lorsqu'il visite le pixel de d√©part une deuxi√®me fois, vous pouvez le terminer lorsqu'il visite le pixel de d√©part une troisi√®me ou m√™me une quatri√®me fois. Cela am√©liorera les performances globales de l'algorithme. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OU </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Aller √† la source du probl√®me, c'est-√†-dire avant de s√©lectionner le pixel de d√©part</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Il existe une limitation importante concernant la direction dans laquelle l'entr√©e du pixel de d√©part est effectu√©e. Essentiellement, vous devez entrer le pixel de d√©part pour que lorsque vous vous tenez dessus, le pixel √† votre gauche soit blanc. La raison de l'introduction de cette restriction est la suivante: puisque nous regardons toujours les trois pixels </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devant</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous dans</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans un certain ordre</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dans certains motifs, nous ignorerons le pixel limite situ√© directement √† gauche du pixel initial. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous risquons de manquer non seulement le pixel voisin gauche du pixel initial, mais aussi le </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixel directement en dessous</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (comme d√©montr√© dans l'analyse). De plus, dans certains motifs, un pixel correspondant au pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de la </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">figure 5</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ci </font><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">dessous </font><font style="vertical-align: inherit;">sera ignor√© </font><font style="vertical-align: inherit;">. Par cons√©quent, nous supposons que le pixel de d√©part doit √™tre frapp√© dans une direction telle que les pixels correspondant aux pixels </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L, W</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> repr√©sent√©s sur la </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">figure 5</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ci-dessous sont blancs.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c8/a81/359/9c8a81359338b31b6f5c0e016230e629.gif" height="200" width="159"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans ce cas, des mod√®les comme celui montr√© dans la d√©monstration seront d√©tect√©s correctement et l'efficacit√© de l'algorithme Pavlidis s'am√©liorera consid√©rablement. </font><font style="vertical-align: inherit;">D'un autre c√¥t√©, trouver un pixel initial qui satisfait √† ces exigences peut √™tre difficile, et dans de nombreux cas, il sera impossible de trouver un tel pixel. </font><font style="vertical-align: inherit;">Dans ce cas, vous devez utiliser un autre moyen d'am√©liorer l'algorithme Pavlidis, √† savoir l'ach√®vement de l'algorithme apr√®s avoir visit√© le point de d√©part pour la troisi√®me fois.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467611/">https://habr.com/ru/post/fr467611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467597/index.html">Personnalisation des directives de produit Big Data avec Vowpal Wabbit</a></li>
<li><a href="../fr467599/index.html">Rendu graphique 3D avec OpenGL</a></li>
<li><a href="../fr467605/index.html">Tout ce dont vous avez besoin est une URL</a></li>
<li><a href="../fr467607/index.html">Confession de haineux docker</a></li>
<li><a href="../fr467609/index.html">Cr√©ation d'une application mobile sur React Native</a></li>
<li><a href="../fr467615/index.html">Comment cr√©er un wrapper Python et ne pas devenir fou</a></li>
<li><a href="../fr467617/index.html">Kaspresso: le framework d'autotest que vous attendiez</a></li>
<li><a href="../fr467619/index.html">Les pichets Aquafor sont un bon exemple de la fa√ßon dont les filtres pour le traitement de l'eau ne peuvent pas √™tre con√ßus</a></li>
<li><a href="../fr467621/index.html">Rencontre Elasticsearch Moscou √† Ozon</a></li>
<li><a href="../fr467625/index.html">10 services pour cr√©er une structure de site en 2020</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>