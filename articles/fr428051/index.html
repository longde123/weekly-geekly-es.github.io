<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏇🏼 👨🏿‍💼 👨🏾‍🏫 Comment rendre encore plus indescriptibles des états encore plus invalides 🏑 🤹🏾 📔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il n'y a pas si longtemps, un article a été traduit chez Habr sur la façon d'utiliser les types de données algébriques pour garantir que les états inc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment rendre encore plus indescriptibles des états encore plus invalides</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428051/"><p>  Il n'y a pas si longtemps, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article a été traduit</a> chez Habr sur la façon d'utiliser les types de données algébriques pour garantir que les états incorrects sont inexprimables.  Aujourd'hui, nous examinons un moyen un peu plus généralisé, évolutif et sûr d'exprimer l'inexprimable, et le Haskell nous aidera à cet égard. </p><a name="habracut"></a><br><p>  En bref, cet article traite d'une entité avec une adresse postale et une adresse e-mail, ainsi qu'à la condition supplémentaire qu'il doit y avoir au moins une de ces adresses.  Comment est-il proposé d'exprimer cette condition au niveau du type?  Il est proposé d'écrire les adresses comme suit: </p><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ContactInfo = | EmailOnly <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> EmailContactInfo | PostOnly <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> PostalContactInfo | EmailAndPost <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> EmailContactInfo * PostalContactInfo</code> </pre> <br><p>  Quels sont les problèmes de cette approche? </p><br><p>  Le plus évident (et noté plusieurs fois dans les commentaires sur cet article) est que cette approche n'est pas du tout évolutive.  Imaginez que nous n’ayons pas deux types d’adresses, mais trois ou cinq, et que la condition d’exactitude ressemble à «il doit y avoir soit une adresse postale, soit à la fois une adresse électronique et une adresse de bureau, et il ne devrait pas y avoir plusieurs adresses du même type».  Ceux qui le souhaitent peuvent écrire le type approprié comme exercice d'auto-test.  La tâche avec un astérisque est de réécrire ce type dans le cas où la condition d'absence de doublons a disparu du TOR. </p><br><h3>  Partagez </h3><br><p>  Comment résoudre ce problème?  Essayons de fantasmer.  Tout d'abord, nous décomposons et séparons la classe d'adresses (par exemple, le numéro de courrier / e-mail / bureau au bureau) et le contenu correspondant à cette classe: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrType</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Post</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Email</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Office</span></span></span></span></code> </pre> <br><p>  Nous ne penserons pas encore au contenu, car il n'y a rien dans le cahier des charges pour la validité de la liste d'adresses. </p><br><p>  Si nous vérifions la condition correspondante dans le runtime d'un constructeur d'un langage OOP ordinaire, alors nous écririons simplement une fonction comme </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">valid</span></span> :: [<span class="hljs-type"><span class="hljs-type">AddrType</span></span>] -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> valid xs = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hasNoDups = nub xs == xs <span class="hljs-comment"><span class="hljs-comment">--      hasPost = Post `elem` xs hasEmail = Email `elem` xs hasOffice = Office `elem` xs in hasNoDups &amp;&amp; (hasPost || (hasEmail &amp;&amp; hasOffice))</span></span></code> </pre> <br><p>  et lancerait une exécution si elle renvoie <code>False</code> . </p><br><p>  Pouvons-nous plutôt vérifier une condition similaire à l'aide d'un minuteur lors de la compilation?  Il s'avère que oui, nous pouvons, si le système de type de la langue est suffisamment expressif, et le reste de l'article nous choisirons cette approche. </p><br><p>  Ici, les types dépendants nous aideront beaucoup, et comme la façon la plus adéquate d'écrire un code validé dans Haskell est de l'écrire d'abord dans Agde ou Idris, nous allons changer de chaussures et écrire dans Idris.  La syntaxe idris est assez proche de Haskell: par exemple, avec la fonction susmentionnée, il suffit de modifier légèrement la signature: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> : List AddrType -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span></code> </pre> <br><p>  Souvenez-vous maintenant qu'en plus des classes d'adresses, nous avons également besoin de leur contenu et encodons la dépendance des champs sur la classe d'adresses en tant que GADT: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrType</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PostFields</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">city</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">street</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Post</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EmailFields</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">email</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Email</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">OfficeFields</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">floor</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">desk</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nat</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Office</span></span></span></span></code> </pre> <br><p>  Autrement dit, si on nous donne une valeur de <code>fields</code> type <code>AddrFields t</code> , alors nous savons que <code>t</code> est une <code>AddrType</code> AddrType et que les <code>fields</code> contiennent un ensemble de champs correspondant à cette classe particulière. </p><br><div class="spoiler">  <b class="spoiler_title">À propos de cet article</b> <div class="spoiler_text"><p>  Ce n'est pas l'encodage le plus sûr pour le type, car GADT n'a pas besoin d'être injectif, et il serait plus correct de déclarer trois types de données distincts <code>PostFields</code> , <code>EmailFields</code> , <code>OfficeFields</code> et d'écrire une fonction </p><br><pre> <code class="hljs pgsql">addrFields : AddrType -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> addrFields Post = PostFields addrFields Email = EmailFields addrFields Office = OfficeFields</code> </pre> <br><p>  mais c'est trop d'écriture, ce qui pour le prototype ne donne pas un gain significatif, et dans le Haskell pour cela il y a encore des mécanismes plus concis et plus agréables. </p></div></div><br><p>  Quelle est l'adresse complète de ce modèle?  Il s'agit d'une paire de la classe d'adresses et des champs correspondants: </p><br><pre> <code class="hljs pgsql">Addr : <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> Addr = (t : AddrType ** AddrFields t)</code> </pre> <br><p>  Les fans de la théorie des types diront qu'il s'agit d'un type dépendant de l'existence: si l'on nous donne une valeur de type <code>Addr</code> , cela signifie qu'il existe une valeur <code>t</code> type <code>AddrType</code> et un ensemble correspondant de champs <code>AddrFields t</code> .  Naturellement, les adresses d'une classe différente sont du même type: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">someEmailAddr</span></span> : Addr someEmailAddr = (Email ** EmailFields <span class="hljs-string"><span class="hljs-string">"that</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">@feel</span></span></span><span class="hljs-string">.bro"</span></span>) someOfficeAddr : Addr someOfficeAddr = (Office ** OfficeFields (-<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">762</span></span>)</code> </pre> <br><p>  De plus, si <code>EmailFields</code> est donné, alors la seule classe d'adresse qui convient est <code>Email</code> , donc vous pouvez l'omettre, le temporisateur l'imprimera vous-même: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">someEmailAddr</span></span> : Addr someEmailAddr = (_ ** EmailFields <span class="hljs-string"><span class="hljs-string">"that</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">@feel</span></span></span><span class="hljs-string">.bro"</span></span>) someOfficeAddr : Addr someOfficeAddr = (_ ** OfficeFields (-<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">762</span></span>)</code> </pre> <br><p>  Nous écrivons une fonction auxiliaire qui donne la liste correspondante des classes d'adresses de la liste d'adresses, et la généralisons immédiatement pour travailler sur un foncteur arbitraire: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">types</span></span> : Functor f =&gt; f Addr -&gt; f AddrType <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> = map fst</code> </pre> <br><p>  Ici, le type existentiel <code>Addr</code> se comporte comme un couple familier: en particulier, vous pouvez demander son premier composant <code>AddrType</code> (tâche avec un astérisque: pourquoi ne puis-je pas demander le deuxième composant?). </p><br><h4>  Augmenter </h4><br><p>  Nous passons maintenant à un élément clé de notre histoire.  Nous avons donc une liste d'adresses <code>valid : List AddrType -&gt; Bool</code> et un prédicat <code>valid : List AddrType -&gt; Bool</code> , dont nous voulons garantir l'exécution pour cette liste au niveau des types.  Comment les combinons-nous?  Bien sûr, un autre type! </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkValidatedAddrList</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prf</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">valid</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">types</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">True</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> lst</span></span></code> </pre> <br><p>  Nous allons maintenant analyser ce que nous avons écrit ici. </p><br><p>  <code>data ValidatedAddrList : List Addr -&gt; Type where</code> signifie que le type <code>ValidatedAddrList</code> paramétré, en fait, par la liste d'adresses. </p><br><p>  Voyons la signature du seul constructeur <code>MkValidatedAddrList</code> de ce type: <code>(lst : List Addr) -&gt; (prf : valid (types lst) = True) -&gt; ValidatedAddrList lst</code> .  Autrement dit, il prend une liste d'adresses <code>prf</code> et un autre argument <code>prf</code> de type <code>valid (types lst) = True</code> .  Que signifie ce type?  Cela signifie donc que la valeur à gauche de <code>=</code> est égale à la valeur à droite de <code>=</code> , c'est-à-dire <code>valid (types lst)</code> , en fait, est True. </p><br><p>  Comment ça marche?  Signature <code>=</code> ressemble à <code>(x : A) -&gt; (y : B) -&gt; Type</code> .  Autrement dit, <code>=</code> prend deux valeurs arbitraires <code>x</code> et <code>y</code> (peut-être même de types différents <code>A</code> et <code>B</code> , ce qui signifie que l'inégalité dans l'idris est hétérogène et qu'elle est quelque peu ambiguë du point de vue de la théorie des types, mais c'est un sujet pour une autre discussion).  Qu'est-ce qui démontre alors l'égalité?  Et du fait que le seul constructeur <code>=</code> - <code>Refl</code> avec une signature de <em>presque</em> <code>(x : A) -&gt; x = x</code> .  Autrement dit, si nous avons une valeur de type <code>x = y</code> , alors nous savons qu'elle a été construite à l'aide de <code>Refl</code> (car il n'y a pas d'autres constructeurs), ce qui signifie que <code>x</code> est en fait égal à <code>y</code> . </p><br><p>  Notez que c'est pourquoi dans le Haskell, nous prétendrons toujours au mieux que nous prouvons quelque chose, car le Haskell a <code>undefined</code> qui habite n'importe quel type, donc l'argument ci-dessus ne fonctionne pas là: pour tout <code>x</code> , <code>y</code> terme de type <code>x = y</code> pourrait être créé via <code>undefined</code> (ou par une récursion infinie, disons qu'en gros c'est la même chose en termes de théorie des types). </p><br><p>  Nous notons également que l'égalité ici n'est pas signifiée dans le sens de Haskell <code>Eq</code> ou d'un <code>operator==</code> en C ++, mais beaucoup plus rigoureuse: structurelle, ce qui, simplifiant, signifie que les deux valeurs ont la même <em>forme</em> .  Autrement dit, le tromper ne fonctionne tout simplement pas.  Mais les questions d'égalité sont traditionnellement attirées dans un article distinct. </p><br><p>  Afin de consolider notre compréhension de l'égalité, nous écrivons des tests unitaires pour la fonction <code>valid</code> : </p><br><pre> <code class="hljs powershell">testPostValid : valid [<span class="hljs-type"><span class="hljs-type">Post</span></span>] = True testPostValid = Refl testEmptyInvalid : valid [] = False testEmptyInvalid = Refl testDupsInvalid : valid [<span class="hljs-type"><span class="hljs-type">Post</span></span>, <span class="hljs-type"><span class="hljs-type">Post</span></span>] = False testDupsInvalid = Refl testPostEmailValid : valid [<span class="hljs-type"><span class="hljs-type">Post</span></span>, <span class="hljs-type"><span class="hljs-type">Email</span></span>] = True testPostEmailValid = Refl</code> </pre> <br><p>  Ces tests sont bons car vous n'avez même pas besoin de les exécuter, il suffit que le taypcher les ait vérifiés.  En effet, remplaçons <code>True</code> par <code>False</code> , par exemple, dans le tout premier et voyons ce qui se passe: </p><br><pre> <code class="hljs pgsql">testPostValid : <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> [Post] = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> testPostValid = Refl</code> </pre> <br><p>  Typsekher jure </p><br><p><img src="https://habrastorage.org/webt/l7/to/xm/l7toxmndt6lzzbpmjersntiujfg.png"></p><br><p>  comme prévu.  Super </p><br><h4>  Simplifier </h4><br><p>  Maintenant, refactorisons <code>ValidatedAddrList</code> peu notre <code>ValidatedAddrList</code> . </p><br><p>  Tout d'abord, le modèle de comparaison d'une certaine valeur avec <code>True</code> assez courant, il y a donc un type spécial <code>So</code> dans l'idris pour cela: vous pouvez prendre <code>So x</code> comme synonyme de <code>x = True</code> .  Corrigeons la définition de <code>ValidatedAddrList</code> : </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkValidatedAddrList</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prf</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">So</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">valid</span></span></span><span class="hljs-class"> $ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">types</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class">)) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> lst</span></span></code> </pre> <br><p>  De plus, <code>So</code> a une fonction auxiliaire pratique à <code>choose</code> , ce qui élève essentiellement la vérification au niveau des types: </p><br><pre> <code class="hljs pgsql">&gt; :doc choose Data.So.choose : (b : <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; Either (So b) (So (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> b)) <span class="hljs-keyword"><span class="hljs-keyword">Perform</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> analysis <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> a <span class="hljs-type"><span class="hljs-type">Boolean</span></span>, providing clients <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> a So proof</code> </pre> <br><p>  Cela nous sera utile lorsque nous écrirons des fonctions qui modifient ce type. </p><br><p>  Deuxièmement, parfois (en particulier dans le développement interactif) idris peut trouver par lui-même la valeur <code>prf</code> appropriée.  Pour que dans de tels cas, il n'était pas nécessaire de le construire à la main, il existe un sucre syntaxique correspondant: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkValidatedAddrList</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class">) -&gt; {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prf</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">So</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">valid</span></span></span><span class="hljs-class"> $ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">types</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class">)} -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> lst</span></span></code> </pre> <br><p>  Les accolades signifient qu'il s'agit d'un argument implicite qu'idris essaiera de sortir du contexte, et <code>auto</code> signifie qu'il essaiera également de le construire lui-même. </p><br><p>  Alors, que nous apporte ce nouveau <code>ValidatedAddrList</code> ?  Et cela donne une telle chaîne de raisonnement: soit <code>val</code> une valeur de type <code>ValidatedAddrList lst</code> .  Cela signifie que <code>lst</code> est une liste d'adresses, et en outre, <code>val</code> été créé à l'aide du constructeur <code>MkValidatedAddrList</code> , auquel nous avons transmis ce très <code>prf</code> et une autre valeur <code>prf</code> de type <code>So (valid $ types lst)</code> , qui est presque <code>valid (types lst) = True</code> .  Et pour que nous puissions construire <code>prf</code> , nous devons, en fait, prouver que cette égalité est valable. </p><br><p>  Et le plus beau, c'est que tout est vérifié par un tympher.  Oui, la vérification de validité devra être effectuée en runtime (car les adresses peuvent être lues à partir d'un fichier ou du réseau), mais le temporisateur s'assurera que cette vérification est effectuée: sans elle, il est impossible de créer une <code>ValidatedAddrList</code> .  Au moins dans idris.  À Haskell, hélas. </p><br><h4>  Insérer </h4><br><p>  Pour vérifier l'inévitabilité de la vérification, essayez d'écrire une fonction pour ajouter une adresse à la liste.  Première tentative: </p><br><pre> <code class="hljs coffeescript">insert : <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr : Addr)</span></span></span><span class="hljs-function"> -&gt;</span></span> ValidatedAddrList lst -&gt; ValidatedAddrList (addr :: lst) insert addr (MkValidatedAddrList lst) = MkValidatedAddrList (addr :: lst)</code> </pre> <br><p>  Non, le typo-vérificateur donne sur les doigts (bien que peu lisible, le coût de la <code>valid</code> trop compliqué): </p><br><p><img src="https://habrastorage.org/webt/au/oa/6j/auoa6jeo10ucav7rffetqmvylec.png"></p><br><p>  Comment obtenir une copie de ce document?  Pas autrement que le <code>choose</code> susmentionné.  Deuxième tentative: </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; ValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">choose</span></span> (valid $ types (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> l =&gt; MkValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> r =&gt; ?rhs</code> </pre> <br><p>  Il a presque typechetsya.  "Presque" car on ne sait pas trop quoi substituer à <code>rhs</code> .  C'est plutôt clair: dans ce cas, la fonction doit en quelque sorte signaler une erreur.  Vous devez donc modifier la signature et encapsuler la valeur de retour, par exemple, dans <code>Maybe</code> - <code>Maybe</code> : </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; Maybe (ValidatedAddrList (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">choose</span></span> (valid $ types (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> l =&gt; Just $ MkValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> r =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Nothing</span></span></code> </pre> <br><p>  Ceci est carrelé et fonctionne comme il se doit. </p><br><p>  Mais maintenant se pose le problème peu évident suivant, qui était, en fait, dans l'article original.  Le type de cette fonction n'arrête pas d'écrire une telle implémentation: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; Maybe (ValidatedAddrList (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">Nothing</span></span></code> </pre> <br><p>  Autrement dit, nous disons toujours que nous ne pouvions pas construire une nouvelle liste d'adresses.  Typhechaetsya?  Oui  Est-ce correct?  Enfin, à peine.  Cela peut-il être évité? </p><br><p>  Il s'avère que c'est possible, et nous avons tous les outils nécessaires pour cela.  En cas de succès, <code>insert</code> renvoie un <code>ValidatedAddrList</code> , qui contient des preuves de ce succès.  Ajoutez donc une symétrie élégante et demandez à la fonction de renvoyer également une preuve d'échec! </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; Either (So (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> $ valid $ types (addr :: lst))) (ValidatedAddrList (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">choose</span></span> (valid $ types (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> l =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> $ MkValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> r =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> r</code> </pre> <br><p>  Maintenant, nous ne pouvons pas simplement prendre et toujours retourner <code>Nothing</code> . </p><br><p>  Vous pouvez faire de même pour les fonctions de suppression d'adresses et autres. </p><br><p>  Voyons à quoi tout cela ressemble à la fin. </p><br><p>  Essayons de créer une liste d'adresses vide: </p><br><p><img src="https://habrastorage.org/webt/9l/pf/a_/9lpfa_ytfrgfsvxbvy4lkk0a8uy.png"></p><br><p>  C'est impossible, une liste vide n'est pas valide. </p><br><p>  Que diriez-vous d'une liste d'une simple adresse postale? </p><br><p><img src="https://habrastorage.org/webt/au/d2/jq/aud2jqe2malfgrjg2txzsncdom4.png"></p><br><p>  D'accord, essayons d'insérer l'adresse postale dans la liste qui a déjà l'adresse postale: </p><br><p><img src="https://habrastorage.org/webt/xl/cx/ri/xlcxrimioc_dutfysgtdmr2srmc.png"></p><br><p>  Essayons d'insérer l'e-mail: </p><br><p><img src="https://habrastorage.org/webt/sn/1n/zw/sn1nzwqz5erm1vjnq59dkel3zzi.png"></p><br><p>  Au final, tout fonctionne exactement comme prévu. </p><br><p>  Ouf.  Je pensais que ce serait trois lignes, mais cela s'est avéré un peu plus long.  Donc, pour explorer jusqu'où nous pouvons aller dans le Haskell, nous serons dans le prochain article.  En attendant, un peu </p><br><h4>  Méditer </h4><br><p>  Quel est, au final, le bénéfice d'une telle décision par rapport à celle donnée dans l'article, que nous avons évoqué au tout début? </p><br><ol><li>  Il est, encore une fois, beaucoup plus évolutif.  Les fonctions de validation complexes sont plus faciles à écrire. </li><li>  C'est plus isolé.  Le code client n'a pas besoin de savoir ce qu'il y a à l'intérieur de la fonction de validation, alors que le formulaire <code>ContactInfo</code> de l'article d'origine nécessite qu'il soit lié. </li><li>  La logique de validation est écrite sous la forme de fonctions ordinaires et familières, de sorte qu'elle peut être vérifiée immédiatement avec une lecture réfléchie et testée avec des tests de temps de compilation, plutôt que de dériver le sens de la validation à partir d'un formulaire de type de données qui représente un résultat déjà vérifié. </li><li>  Il devient possible de spécifier plus précisément le comportement des fonctions qui fonctionnent avec le type de données qui nous intéresse, notamment en cas d'échec au test.  Par exemple, l' <code>insert</code> écrite en conséquence est tout simplement impossible à écrire de <em>manière incorrecte</em> .  De même, on pourrait écrire <code>insertOrReplace</code> , <code>insertOrIgnore</code> et similaires, dont le comportement est entièrement spécifié dans le type. </li></ol><br><p>  Quel est le profit par rapport à une solution OOP comme ça? </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ValidatedAddrListClass</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">public</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">ValidatedAddrListClass</span></span>(std::vector&lt;Addr&gt; addrs) { if (!<span class="hljs-built_in"><span class="hljs-built_in">valid</span></span>(addrs)) throw ValidationError {}; } };</code> </pre> <br><ol><li>  Le code est plus modularisé et sécurisé.  Dans le cas ci-dessus, une vérification est une <em>action</em> qui est vérifiée une fois, et à propos de laquelle ils ont ensuite oublié.  Tout est basé sur l'honnêteté et la compréhension que si vous avez une <code>ValidatedAddrListClass</code> , alors sa mise en œuvre a fait une fois une vérification.  Le fait de cette vérification de la classe ne peut pas être choisi comme une certaine valeur.  Dans le cas d'une <em>valeur d'un</em> certain type, cette valeur peut être transférée entre différentes parties du programme, utilisée pour créer des valeurs plus complexes (par exemple, encore une fois, refuser cette vérification), enquêter (voir le paragraphe suivant) et généralement faire la même chose que nous le faisions auparavant avec des valeurs. </li><li>  Ces vérifications peuvent être utilisées dans la correspondance de modèles (dépendante).  Certes, pas dans le cas de cette fonction <code>valid</code> et pas dans le cas d'idris, c'est douloureusement compliqué, et idris est douloureusement terne de sorte que les informations utiles pour les modèles peuvent être extraites de la structure <code>valid</code> .  Néanmoins, <code>valid</code> peut être réécrit dans un style de correspondance de motifs légèrement plus convivial, mais cela dépasse le cadre de cet article et n'est généralement pas trivial en soi. </li></ol><br><p>  Quels sont les inconvénients? </p><br><p>  Je ne vois qu'un seul défaut fondamental grave: la <code>valid</code> est une fonction trop stupide.  Il ne renvoie qu'un seul bit d'informations - que les données aient ou non été validées.  Dans le cas de types plus intelligents, nous pourrions réaliser quelque chose de plus intéressant. </p><br><p>  Par exemple, imaginez que l'exigence d'unicité des adresses ait disparu des savoirs traditionnels.  Dans ce cas, il est évident que l'ajout d'une nouvelle adresse à la liste d'adresses existante ne rendra pas la liste invalide, donc nous pourrions <em>prouver ce théorème</em> en écrivant une fonction avec le type <code>So (valid $ types lst) -&gt; So (valid $ types $ addr :: lst)</code> , et l'utiliser, par exemple, pour écrire un type sûr toujours réussi </p><br><pre> <code class="hljs coffeescript">insert : <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr : Addr)</span></span></span><span class="hljs-function"> -&gt;</span></span> ValidatedAddrList lst -&gt; ValidatedAddrList (addr :: lst)</code> </pre> <br><p>  Mais, hélas, des théorèmes comme la récursivité et l'induction, et notre problème n'a pas de structure inductive élégante, donc, à mon avis, le code avec le chêne booléen <code>valid</code> également bon. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr428051/">https://habr.com/ru/post/fr428051/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr428039/index.html">Le gouvernement n'a pas l'intention de plaider pour la neutralité du réseau</a></li>
<li><a href="../fr428041/index.html">Le condensé de matières fraîches du monde du front-end de la dernière semaine n ° 336 (22-28 octobre 2018)</a></li>
<li><a href="../fr428043/index.html">En attendant le sixième, Winamp 5.8: le «secret» d'origine, la possibilité de la version officielle</a></li>
<li><a href="../fr428045/index.html">PHP Digest n ° 142 (15-29 octobre 2018)</a></li>
<li><a href="../fr428047/index.html">Analyse des performances des serveurs WSGI: remettre uWSGI en place</a></li>
<li><a href="../fr428053/index.html">Comment créer une stratégie de test: version de vrais ingénieurs</a></li>
<li><a href="../fr428055/index.html">Rétrospective des startups technologiques. Z3 - le premier ordinateur relais</a></li>
<li><a href="../fr428057/index.html">Un nouveau regard sur la documentation de l'API et du SDK dans Yandex. Conférence sur Hyperbaton</a></li>
<li><a href="../fr428059/index.html">Connectez le stockage LUN à chemins multiples à VMware ESXi et Debian GNU / Linux</a></li>
<li><a href="../fr428061/index.html">Gérer les coûts du projet avec la gestion de la valeur acquise</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>