<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèáüèº üë®üèø‚Äçüíº üë®üèæ‚Äçüè´ Comment rendre encore plus indescriptibles des √©tats encore plus invalides üèë ü§πüèæ üìî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il n'y a pas si longtemps, un article a √©t√© traduit chez Habr sur la fa√ßon d'utiliser les types de donn√©es alg√©briques pour garantir que les √©tats inc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment rendre encore plus indescriptibles des √©tats encore plus invalides</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428051/"><p>  Il n'y a pas si longtemps, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article a √©t√© traduit</a> chez Habr sur la fa√ßon d'utiliser les types de donn√©es alg√©briques pour garantir que les √©tats incorrects sont inexprimables.  Aujourd'hui, nous examinons un moyen un peu plus g√©n√©ralis√©, √©volutif et s√ªr d'exprimer l'inexprimable, et le Haskell nous aidera √† cet √©gard. </p><a name="habracut"></a><br><p>  En bref, cet article traite d'une entit√© avec une adresse postale et une adresse e-mail, ainsi qu'√† la condition suppl√©mentaire qu'il doit y avoir au moins une de ces adresses.  Comment est-il propos√© d'exprimer cette condition au niveau du type?  Il est propos√© d'√©crire les adresses comme suit: </p><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ContactInfo = | EmailOnly <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> EmailContactInfo | PostOnly <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> PostalContactInfo | EmailAndPost <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> EmailContactInfo * PostalContactInfo</code> </pre> <br><p>  Quels sont les probl√®mes de cette approche? </p><br><p>  Le plus √©vident (et not√© plusieurs fois dans les commentaires sur cet article) est que cette approche n'est pas du tout √©volutive.  Imaginez que nous n‚Äôayons pas deux types d‚Äôadresses, mais trois ou cinq, et que la condition d‚Äôexactitude ressemble √† ¬´il doit y avoir soit une adresse postale, soit √† la fois une adresse √©lectronique et une adresse de bureau, et il ne devrait pas y avoir plusieurs adresses du m√™me type¬ª.  Ceux qui le souhaitent peuvent √©crire le type appropri√© comme exercice d'auto-test.  La t√¢che avec un ast√©risque est de r√©√©crire ce type dans le cas o√π la condition d'absence de doublons a disparu du TOR. </p><br><h3>  Partagez </h3><br><p>  Comment r√©soudre ce probl√®me?  Essayons de fantasmer.  Tout d'abord, nous d√©composons et s√©parons la classe d'adresses (par exemple, le num√©ro de courrier / e-mail / bureau au bureau) et le contenu correspondant √† cette classe: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrType</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Post</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Email</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Office</span></span></span></span></code> </pre> <br><p>  Nous ne penserons pas encore au contenu, car il n'y a rien dans le cahier des charges pour la validit√© de la liste d'adresses. </p><br><p>  Si nous v√©rifions la condition correspondante dans le runtime d'un constructeur d'un langage OOP ordinaire, alors nous √©cririons simplement une fonction comme </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">valid</span></span> :: [<span class="hljs-type"><span class="hljs-type">AddrType</span></span>] -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> valid xs = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hasNoDups = nub xs == xs <span class="hljs-comment"><span class="hljs-comment">--      hasPost = Post `elem` xs hasEmail = Email `elem` xs hasOffice = Office `elem` xs in hasNoDups &amp;&amp; (hasPost || (hasEmail &amp;&amp; hasOffice))</span></span></code> </pre> <br><p>  et lancerait une ex√©cution si elle renvoie <code>False</code> . </p><br><p>  Pouvons-nous plut√¥t v√©rifier une condition similaire √† l'aide d'un minuteur lors de la compilation?  Il s'av√®re que oui, nous pouvons, si le syst√®me de type de la langue est suffisamment expressif, et le reste de l'article nous choisirons cette approche. </p><br><p>  Ici, les types d√©pendants nous aideront beaucoup, et comme la fa√ßon la plus ad√©quate d'√©crire un code valid√© dans Haskell est de l'√©crire d'abord dans Agde ou Idris, nous allons changer de chaussures et √©crire dans Idris.  La syntaxe idris est assez proche de Haskell: par exemple, avec la fonction susmentionn√©e, il suffit de modifier l√©g√®rement la signature: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> : List AddrType -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span></code> </pre> <br><p>  Souvenez-vous maintenant qu'en plus des classes d'adresses, nous avons √©galement besoin de leur contenu et encodons la d√©pendance des champs sur la classe d'adresses en tant que GADT: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrType</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PostFields</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">city</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">street</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Post</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EmailFields</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">email</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Email</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">OfficeFields</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">floor</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">desk</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nat</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Office</span></span></span></span></code> </pre> <br><p>  Autrement dit, si on nous donne une valeur de <code>fields</code> type <code>AddrFields t</code> , alors nous savons que <code>t</code> est une <code>AddrType</code> AddrType et que les <code>fields</code> contiennent un ensemble de champs correspondant √† cette classe particuli√®re. </p><br><div class="spoiler">  <b class="spoiler_title">√Ä propos de cet article</b> <div class="spoiler_text"><p>  Ce n'est pas l'encodage le plus s√ªr pour le type, car GADT n'a pas besoin d'√™tre injectif, et il serait plus correct de d√©clarer trois types de donn√©es distincts <code>PostFields</code> , <code>EmailFields</code> , <code>OfficeFields</code> et d'√©crire une fonction </p><br><pre> <code class="hljs pgsql">addrFields : AddrType -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> addrFields Post = PostFields addrFields Email = EmailFields addrFields Office = OfficeFields</code> </pre> <br><p>  mais c'est trop d'√©criture, ce qui pour le prototype ne donne pas un gain significatif, et dans le Haskell pour cela il y a encore des m√©canismes plus concis et plus agr√©ables. </p></div></div><br><p>  Quelle est l'adresse compl√®te de ce mod√®le?  Il s'agit d'une paire de la classe d'adresses et des champs correspondants: </p><br><pre> <code class="hljs pgsql">Addr : <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> Addr = (t : AddrType ** AddrFields t)</code> </pre> <br><p>  Les fans de la th√©orie des types diront qu'il s'agit d'un type d√©pendant de l'existence: si l'on nous donne une valeur de type <code>Addr</code> , cela signifie qu'il existe une valeur <code>t</code> type <code>AddrType</code> et un ensemble correspondant de champs <code>AddrFields t</code> .  Naturellement, les adresses d'une classe diff√©rente sont du m√™me type: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">someEmailAddr</span></span> : Addr someEmailAddr = (Email ** EmailFields <span class="hljs-string"><span class="hljs-string">"that</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">@feel</span></span></span><span class="hljs-string">.bro"</span></span>) someOfficeAddr : Addr someOfficeAddr = (Office ** OfficeFields (-<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">762</span></span>)</code> </pre> <br><p>  De plus, si <code>EmailFields</code> est donn√©, alors la seule classe d'adresse qui convient est <code>Email</code> , donc vous pouvez l'omettre, le temporisateur l'imprimera vous-m√™me: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">someEmailAddr</span></span> : Addr someEmailAddr = (_ ** EmailFields <span class="hljs-string"><span class="hljs-string">"that</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">@feel</span></span></span><span class="hljs-string">.bro"</span></span>) someOfficeAddr : Addr someOfficeAddr = (_ ** OfficeFields (-<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">762</span></span>)</code> </pre> <br><p>  Nous √©crivons une fonction auxiliaire qui donne la liste correspondante des classes d'adresses de la liste d'adresses, et la g√©n√©ralisons imm√©diatement pour travailler sur un foncteur arbitraire: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">types</span></span> : Functor f =&gt; f Addr -&gt; f AddrType <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> = map fst</code> </pre> <br><p>  Ici, le type existentiel <code>Addr</code> se comporte comme un couple familier: en particulier, vous pouvez demander son premier composant <code>AddrType</code> (t√¢che avec un ast√©risque: pourquoi ne puis-je pas demander le deuxi√®me composant?). </p><br><h4>  Augmenter </h4><br><p>  Nous passons maintenant √† un √©l√©ment cl√© de notre histoire.  Nous avons donc une liste d'adresses <code>valid : List AddrType -&gt; Bool</code> et un pr√©dicat <code>valid : List AddrType -&gt; Bool</code> , dont nous voulons garantir l'ex√©cution pour cette liste au niveau des types.  Comment les combinons-nous?  Bien s√ªr, un autre type! </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkValidatedAddrList</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prf</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">valid</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">types</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">True</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> lst</span></span></code> </pre> <br><p>  Nous allons maintenant analyser ce que nous avons √©crit ici. </p><br><p>  <code>data ValidatedAddrList : List Addr -&gt; Type where</code> signifie que le type <code>ValidatedAddrList</code> param√©tr√©, en fait, par la liste d'adresses. </p><br><p>  Voyons la signature du seul constructeur <code>MkValidatedAddrList</code> de ce type: <code>(lst : List Addr) -&gt; (prf : valid (types lst) = True) -&gt; ValidatedAddrList lst</code> .  Autrement dit, il prend une liste d'adresses <code>prf</code> et un autre argument <code>prf</code> de type <code>valid (types lst) = True</code> .  Que signifie ce type?  Cela signifie donc que la valeur √† gauche de <code>=</code> est √©gale √† la valeur √† droite de <code>=</code> , c'est-√†-dire <code>valid (types lst)</code> , en fait, est True. </p><br><p>  Comment √ßa marche?  Signature <code>=</code> ressemble √† <code>(x : A) -&gt; (y : B) -&gt; Type</code> .  Autrement dit, <code>=</code> prend deux valeurs arbitraires <code>x</code> et <code>y</code> (peut-√™tre m√™me de types diff√©rents <code>A</code> et <code>B</code> , ce qui signifie que l'in√©galit√© dans l'idris est h√©t√©rog√®ne et qu'elle est quelque peu ambigu√´ du point de vue de la th√©orie des types, mais c'est un sujet pour une autre discussion).  Qu'est-ce qui d√©montre alors l'√©galit√©?  Et du fait que le seul constructeur <code>=</code> - <code>Refl</code> avec une signature de <em>presque</em> <code>(x : A) -&gt; x = x</code> .  Autrement dit, si nous avons une valeur de type <code>x = y</code> , alors nous savons qu'elle a √©t√© construite √† l'aide de <code>Refl</code> (car il n'y a pas d'autres constructeurs), ce qui signifie que <code>x</code> est en fait √©gal √† <code>y</code> . </p><br><p>  Notez que c'est pourquoi dans le Haskell, nous pr√©tendrons toujours au mieux que nous prouvons quelque chose, car le Haskell a <code>undefined</code> qui habite n'importe quel type, donc l'argument ci-dessus ne fonctionne pas l√†: pour tout <code>x</code> , <code>y</code> terme de type <code>x = y</code> pourrait √™tre cr√©√© via <code>undefined</code> (ou par une r√©cursion infinie, disons qu'en gros c'est la m√™me chose en termes de th√©orie des types). </p><br><p>  Nous notons √©galement que l'√©galit√© ici n'est pas signifi√©e dans le sens de Haskell <code>Eq</code> ou d'un <code>operator==</code> en C ++, mais beaucoup plus rigoureuse: structurelle, ce qui, simplifiant, signifie que les deux valeurs ont la m√™me <em>forme</em> .  Autrement dit, le tromper ne fonctionne tout simplement pas.  Mais les questions d'√©galit√© sont traditionnellement attir√©es dans un article distinct. </p><br><p>  Afin de consolider notre compr√©hension de l'√©galit√©, nous √©crivons des tests unitaires pour la fonction <code>valid</code> : </p><br><pre> <code class="hljs powershell">testPostValid : valid [<span class="hljs-type"><span class="hljs-type">Post</span></span>] = True testPostValid = Refl testEmptyInvalid : valid [] = False testEmptyInvalid = Refl testDupsInvalid : valid [<span class="hljs-type"><span class="hljs-type">Post</span></span>, <span class="hljs-type"><span class="hljs-type">Post</span></span>] = False testDupsInvalid = Refl testPostEmailValid : valid [<span class="hljs-type"><span class="hljs-type">Post</span></span>, <span class="hljs-type"><span class="hljs-type">Email</span></span>] = True testPostEmailValid = Refl</code> </pre> <br><p>  Ces tests sont bons car vous n'avez m√™me pas besoin de les ex√©cuter, il suffit que le taypcher les ait v√©rifi√©s.  En effet, rempla√ßons <code>True</code> par <code>False</code> , par exemple, dans le tout premier et voyons ce qui se passe: </p><br><pre> <code class="hljs pgsql">testPostValid : <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> [Post] = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> testPostValid = Refl</code> </pre> <br><p>  Typsekher jure </p><br><p><img src="https://habrastorage.org/webt/l7/to/xm/l7toxmndt6lzzbpmjersntiujfg.png"></p><br><p>  comme pr√©vu.  Super </p><br><h4>  Simplifier </h4><br><p>  Maintenant, refactorisons <code>ValidatedAddrList</code> peu notre <code>ValidatedAddrList</code> . </p><br><p>  Tout d'abord, le mod√®le de comparaison d'une certaine valeur avec <code>True</code> assez courant, il y a donc un type sp√©cial <code>So</code> dans l'idris pour cela: vous pouvez prendre <code>So x</code> comme synonyme de <code>x = True</code> .  Corrigeons la d√©finition de <code>ValidatedAddrList</code> : </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkValidatedAddrList</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prf</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">So</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">valid</span></span></span><span class="hljs-class"> $ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">types</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class">)) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> lst</span></span></code> </pre> <br><p>  De plus, <code>So</code> a une fonction auxiliaire pratique √† <code>choose</code> , ce qui √©l√®ve essentiellement la v√©rification au niveau des types: </p><br><pre> <code class="hljs pgsql">&gt; :doc choose Data.So.choose : (b : <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; Either (So b) (So (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> b)) <span class="hljs-keyword"><span class="hljs-keyword">Perform</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> analysis <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> a <span class="hljs-type"><span class="hljs-type">Boolean</span></span>, providing clients <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> a So proof</code> </pre> <br><p>  Cela nous sera utile lorsque nous √©crirons des fonctions qui modifient ce type. </p><br><p>  Deuxi√®mement, parfois (en particulier dans le d√©veloppement interactif) idris peut trouver par lui-m√™me la valeur <code>prf</code> appropri√©e.  Pour que dans de tels cas, il n'√©tait pas n√©cessaire de le construire √† la main, il existe un sucre syntaxique correspondant: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkValidatedAddrList</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class">) -&gt; {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prf</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">So</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">valid</span></span></span><span class="hljs-class"> $ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">types</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class">)} -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> lst</span></span></code> </pre> <br><p>  Les accolades signifient qu'il s'agit d'un argument implicite qu'idris essaiera de sortir du contexte, et <code>auto</code> signifie qu'il essaiera √©galement de le construire lui-m√™me. </p><br><p>  Alors, que nous apporte ce nouveau <code>ValidatedAddrList</code> ?  Et cela donne une telle cha√Æne de raisonnement: soit <code>val</code> une valeur de type <code>ValidatedAddrList lst</code> .  Cela signifie que <code>lst</code> est une liste d'adresses, et en outre, <code>val</code> √©t√© cr√©√© √† l'aide du constructeur <code>MkValidatedAddrList</code> , auquel nous avons transmis ce tr√®s <code>prf</code> et une autre valeur <code>prf</code> de type <code>So (valid $ types lst)</code> , qui est presque <code>valid (types lst) = True</code> .  Et pour que nous puissions construire <code>prf</code> , nous devons, en fait, prouver que cette √©galit√© est valable. </p><br><p>  Et le plus beau, c'est que tout est v√©rifi√© par un tympher.  Oui, la v√©rification de validit√© devra √™tre effectu√©e en runtime (car les adresses peuvent √™tre lues √† partir d'un fichier ou du r√©seau), mais le temporisateur s'assurera que cette v√©rification est effectu√©e: sans elle, il est impossible de cr√©er une <code>ValidatedAddrList</code> .  Au moins dans idris.  √Ä Haskell, h√©las. </p><br><h4>  Ins√©rer </h4><br><p>  Pour v√©rifier l'in√©vitabilit√© de la v√©rification, essayez d'√©crire une fonction pour ajouter une adresse √† la liste.  Premi√®re tentative: </p><br><pre> <code class="hljs coffeescript">insert : <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr : Addr)</span></span></span><span class="hljs-function"> -&gt;</span></span> ValidatedAddrList lst -&gt; ValidatedAddrList (addr :: lst) insert addr (MkValidatedAddrList lst) = MkValidatedAddrList (addr :: lst)</code> </pre> <br><p>  Non, le typo-v√©rificateur donne sur les doigts (bien que peu lisible, le co√ªt de la <code>valid</code> trop compliqu√©): </p><br><p><img src="https://habrastorage.org/webt/au/oa/6j/auoa6jeo10ucav7rffetqmvylec.png"></p><br><p>  Comment obtenir une copie de ce document?  Pas autrement que le <code>choose</code> susmentionn√©.  Deuxi√®me tentative: </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; ValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">choose</span></span> (valid $ types (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> l =&gt; MkValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> r =&gt; ?rhs</code> </pre> <br><p>  Il a presque typechetsya.  "Presque" car on ne sait pas trop quoi substituer √† <code>rhs</code> .  C'est plut√¥t clair: dans ce cas, la fonction doit en quelque sorte signaler une erreur.  Vous devez donc modifier la signature et encapsuler la valeur de retour, par exemple, dans <code>Maybe</code> - <code>Maybe</code> : </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; Maybe (ValidatedAddrList (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">choose</span></span> (valid $ types (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> l =&gt; Just $ MkValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> r =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Nothing</span></span></code> </pre> <br><p>  Ceci est carrel√© et fonctionne comme il se doit. </p><br><p>  Mais maintenant se pose le probl√®me peu √©vident suivant, qui √©tait, en fait, dans l'article original.  Le type de cette fonction n'arr√™te pas d'√©crire une telle impl√©mentation: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; Maybe (ValidatedAddrList (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">Nothing</span></span></code> </pre> <br><p>  Autrement dit, nous disons toujours que nous ne pouvions pas construire une nouvelle liste d'adresses.  Typhechaetsya?  Oui  Est-ce correct?  Enfin, √† peine.  Cela peut-il √™tre √©vit√©? </p><br><p>  Il s'av√®re que c'est possible, et nous avons tous les outils n√©cessaires pour cela.  En cas de succ√®s, <code>insert</code> renvoie un <code>ValidatedAddrList</code> , qui contient des preuves de ce succ√®s.  Ajoutez donc une sym√©trie √©l√©gante et demandez √† la fonction de renvoyer √©galement une preuve d'√©chec! </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; Either (So (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> $ valid $ types (addr :: lst))) (ValidatedAddrList (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">choose</span></span> (valid $ types (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> l =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> $ MkValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> r =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> r</code> </pre> <br><p>  Maintenant, nous ne pouvons pas simplement prendre et toujours retourner <code>Nothing</code> . </p><br><p>  Vous pouvez faire de m√™me pour les fonctions de suppression d'adresses et autres. </p><br><p>  Voyons √† quoi tout cela ressemble √† la fin. </p><br><p>  Essayons de cr√©er une liste d'adresses vide: </p><br><p><img src="https://habrastorage.org/webt/9l/pf/a_/9lpfa_ytfrgfsvxbvy4lkk0a8uy.png"></p><br><p>  C'est impossible, une liste vide n'est pas valide. </p><br><p>  Que diriez-vous d'une liste d'une simple adresse postale? </p><br><p><img src="https://habrastorage.org/webt/au/d2/jq/aud2jqe2malfgrjg2txzsncdom4.png"></p><br><p>  D'accord, essayons d'ins√©rer l'adresse postale dans la liste qui a d√©j√† l'adresse postale: </p><br><p><img src="https://habrastorage.org/webt/xl/cx/ri/xlcxrimioc_dutfysgtdmr2srmc.png"></p><br><p>  Essayons d'ins√©rer l'e-mail: </p><br><p><img src="https://habrastorage.org/webt/sn/1n/zw/sn1nzwqz5erm1vjnq59dkel3zzi.png"></p><br><p>  Au final, tout fonctionne exactement comme pr√©vu. </p><br><p>  Ouf.  Je pensais que ce serait trois lignes, mais cela s'est av√©r√© un peu plus long.  Donc, pour explorer jusqu'o√π nous pouvons aller dans le Haskell, nous serons dans le prochain article.  En attendant, un peu </p><br><h4>  M√©diter </h4><br><p>  Quel est, au final, le b√©n√©fice d'une telle d√©cision par rapport √† celle donn√©e dans l'article, que nous avons √©voqu√© au tout d√©but? </p><br><ol><li>  Il est, encore une fois, beaucoup plus √©volutif.  Les fonctions de validation complexes sont plus faciles √† √©crire. </li><li>  C'est plus isol√©.  Le code client n'a pas besoin de savoir ce qu'il y a √† l'int√©rieur de la fonction de validation, alors que le formulaire <code>ContactInfo</code> de l'article d'origine n√©cessite qu'il soit li√©. </li><li>  La logique de validation est √©crite sous la forme de fonctions ordinaires et famili√®res, de sorte qu'elle peut √™tre v√©rifi√©e imm√©diatement avec une lecture r√©fl√©chie et test√©e avec des tests de temps de compilation, plut√¥t que de d√©river le sens de la validation √† partir d'un formulaire de type de donn√©es qui repr√©sente un r√©sultat d√©j√† v√©rifi√©. </li><li>  Il devient possible de sp√©cifier plus pr√©cis√©ment le comportement des fonctions qui fonctionnent avec le type de donn√©es qui nous int√©resse, notamment en cas d'√©chec au test.  Par exemple, l' <code>insert</code> √©crite en cons√©quence est tout simplement impossible √† √©crire de <em>mani√®re incorrecte</em> .  De m√™me, on pourrait √©crire <code>insertOrReplace</code> , <code>insertOrIgnore</code> et similaires, dont le comportement est enti√®rement sp√©cifi√© dans le type. </li></ol><br><p>  Quel est le profit par rapport √† une solution OOP comme √ßa? </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ValidatedAddrListClass</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">public</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">ValidatedAddrListClass</span></span>(std::vector&lt;Addr&gt; addrs) { if (!<span class="hljs-built_in"><span class="hljs-built_in">valid</span></span>(addrs)) throw ValidationError {}; } };</code> </pre> <br><ol><li>  Le code est plus modularis√© et s√©curis√©.  Dans le cas ci-dessus, une v√©rification est une <em>action</em> qui est v√©rifi√©e une fois, et √† propos de laquelle ils ont ensuite oubli√©.  Tout est bas√© sur l'honn√™tet√© et la compr√©hension que si vous avez une <code>ValidatedAddrListClass</code> , alors sa mise en ≈ìuvre a fait une fois une v√©rification.  Le fait de cette v√©rification de la classe ne peut pas √™tre choisi comme une certaine valeur.  Dans le cas d'une <em>valeur d'un</em> certain type, cette valeur peut √™tre transf√©r√©e entre diff√©rentes parties du programme, utilis√©e pour cr√©er des valeurs plus complexes (par exemple, encore une fois, refuser cette v√©rification), enqu√™ter (voir le paragraphe suivant) et g√©n√©ralement faire la m√™me chose que nous le faisions auparavant avec des valeurs. </li><li>  Ces v√©rifications peuvent √™tre utilis√©es dans la correspondance de mod√®les (d√©pendante).  Certes, pas dans le cas de cette fonction <code>valid</code> et pas dans le cas d'idris, c'est douloureusement compliqu√©, et idris est douloureusement terne de sorte que les informations utiles pour les mod√®les peuvent √™tre extraites de la structure <code>valid</code> .  N√©anmoins, <code>valid</code> peut √™tre r√©√©crit dans un style de correspondance de motifs l√©g√®rement plus convivial, mais cela d√©passe le cadre de cet article et n'est g√©n√©ralement pas trivial en soi. </li></ol><br><p>  Quels sont les inconv√©nients? </p><br><p>  Je ne vois qu'un seul d√©faut fondamental grave: la <code>valid</code> est une fonction trop stupide.  Il ne renvoie qu'un seul bit d'informations - que les donn√©es aient ou non √©t√© valid√©es.  Dans le cas de types plus intelligents, nous pourrions r√©aliser quelque chose de plus int√©ressant. </p><br><p>  Par exemple, imaginez que l'exigence d'unicit√© des adresses ait disparu des savoirs traditionnels.  Dans ce cas, il est √©vident que l'ajout d'une nouvelle adresse √† la liste d'adresses existante ne rendra pas la liste invalide, donc nous pourrions <em>prouver ce th√©or√®me</em> en √©crivant une fonction avec le type <code>So (valid $ types lst) -&gt; So (valid $ types $ addr :: lst)</code> , et l'utiliser, par exemple, pour √©crire un type s√ªr toujours r√©ussi </p><br><pre> <code class="hljs coffeescript">insert : <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr : Addr)</span></span></span><span class="hljs-function"> -&gt;</span></span> ValidatedAddrList lst -&gt; ValidatedAddrList (addr :: lst)</code> </pre> <br><p>  Mais, h√©las, des th√©or√®mes comme la r√©cursivit√© et l'induction, et notre probl√®me n'a pas de structure inductive √©l√©gante, donc, √† mon avis, le code avec le ch√™ne bool√©en <code>valid</code> √©galement bon. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr428051/">https://habr.com/ru/post/fr428051/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr428039/index.html">Le gouvernement n'a pas l'intention de plaider pour la neutralit√© du r√©seau</a></li>
<li><a href="../fr428041/index.html">Le condens√© de mati√®res fra√Æches du monde du front-end de la derni√®re semaine n ¬∞ 336 (22-28 octobre 2018)</a></li>
<li><a href="../fr428043/index.html">En attendant le sixi√®me, Winamp 5.8: le ¬´secret¬ª d'origine, la possibilit√© de la version officielle</a></li>
<li><a href="../fr428045/index.html">PHP Digest n ¬∞ 142 (15-29 octobre 2018)</a></li>
<li><a href="../fr428047/index.html">Analyse des performances des serveurs WSGI: remettre uWSGI en place</a></li>
<li><a href="../fr428053/index.html">Comment cr√©er une strat√©gie de test: version de vrais ing√©nieurs</a></li>
<li><a href="../fr428055/index.html">R√©trospective des startups technologiques. Z3 - le premier ordinateur relais</a></li>
<li><a href="../fr428057/index.html">Un nouveau regard sur la documentation de l'API et du SDK dans Yandex. Conf√©rence sur Hyperbaton</a></li>
<li><a href="../fr428059/index.html">Connectez le stockage LUN √† chemins multiples √† VMware ESXi et Debian GNU / Linux</a></li>
<li><a href="../fr428061/index.html">G√©rer les co√ªts du projet avec la gestion de la valeur acquise</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>