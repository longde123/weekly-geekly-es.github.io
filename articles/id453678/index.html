<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👇🏼 ➕ 🐁 Cara melihat gema atau transmisi video dengan suara melalui air - 2 👐🏽 👈🏻 🐚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo sayang! 

 Hari ini kita akan mengirimkan gambar dengan ultrasound melalui air: kita benar-benar akan melihat gema dan gema, dan bahkan bagaimana...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara melihat gema atau transmisi video dengan suara melalui air - 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453678/"><h3>  Halo sayang! </h3><br><br>  Hari ini kita akan mengirimkan gambar dengan ultrasound melalui air: kita benar-benar akan melihat gema dan gema, dan bahkan bagaimana mereka berubah tergantung pada kondisi.  Semua yang saya akan katakan kepada Anda sederhana, menarik untuk mengulanginya sendiri dan dapat dilakukan oleh hampir semua orang. <br><br>  Jika ada sesuatu yang berkobar di jiwa Anda dari kata-kata ini, selamat datang di Kat, ke perairan gelap kolam kami! <br><br><img src="https://habrastorage.org/webt/e7/dd/ql/e7ddqlsffkcu34ex7scxfsvt4fs.png"><br><a name="habracut"></a><br><br><blockquote>  "Sisanya yang terbaik adalah menafsirkan kebenaran yang terkenal."  (C) ABS, Siang, Abad XXII </blockquote><br><br><h3>  Foreplay </h3><br>  Aturan dasar dari klub saksi hidroacoustics adalah bahwa video menggunakan hidroacoustics pada jarak yang lebih atau kurang signifikan (lebih dari beberapa meter) di badan air tengah tidak dapat ditransmisikan, dan akan selalu mustahil. <br>  Ada alasan serius untuk ini - saluran komunikasi dengan bandwidth yang sangat rendah, kecepatan propagasi sinyal yang rendah (dalam air hanya 1.500 m / s) dan probabilitas kesalahan yang tinggi.  Pita frekuensi yang tersedia hanya beberapa puluh kilohertz. <br>  Tapi ini tidak semua - jika, secara relatif, sinyal pada frekuensi urutan 10 kHz merambat dalam air pada jarak sekitar 8-10 km, maka pada frekuensi 20 kHz sudah 3-5 km, dan semakin tinggi frekuensinya, semakin kuat pelemahannya .  Sebagai contoh, modem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">uWAVE</a> terkecil kami di dunia beroperasi pada pita 20-30 kHz dan mengirimkan data pada kecepatan 78 bit / detik per 1000 meter, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RedLINE</a> dengan pita 5-15 hingga 8000 meter.  Rekor di antara perangkat komersial milik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">EvoLogics</a> - 68 kBits per 300 meter. <br>  Fisika, sayangnya, tidak dapat dibohongi dan tidak mungkin untuk menyetujuinya - fisika dapat ditransmisikan dengan sangat lambat dan tidak berisik, atau dengan cepat, tetapi dalam jarak pendek. <br>  Namun, dalam beberapa kasus adalah mungkin untuk "memotong beberapa sudut", sudut mana yang akan kita potong kali ini lebih rendah. <br><br><h3>  Apa yang akan kita lakukan hari ini dan apa yang dibutuhkan untuk ini? </h3><br>  Dalam artikel sebelumnya, kami sudah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mentransmisikan "video" dengan suara melalui air</a> , saya mengingatkan Anda bahwa ada frame "digambar pada spektrum", yaitu spektrum, atau lebih tepatnya spektrogram sinyal adalah gambar. <br>  Kemudian kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membuat antena hidroakustik sederhana dari puing</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">puing</a> dan membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">modem hidroakustik sederhana</a> .  Di sana kami juga membuat preamp untuk antena (desain PCB untuk produksi sendiri oleh LUT-ohm masih ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ). <br><br>  Kami berpikir, bagaimana lagi Anda dapat mencoba menyampaikan gambar sehingga bahkan seorang siswa <s>TK</s> dapat mengetahuinya, dan seperti yang terlihat bagi kami, mereka datang dengan cara yang bahkan lebih sederhana daripada sebelumnya. <br><br>  Jadi, untuk meringkas, buatlah daftar apa yang kita butuhkan: <br><br>  - Sepasang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">antena sonar dari pemetik pie</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">preamplifier</a> diproduksi oleh LUT <br>  - C # <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode sumber</a> proyek <br>  - sepasang baterai timbal pada 12 volt <br>  - sebuah penguat pada TDA, saya mengambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu</a> untuk hanya 50 rubel pada Ali <br><br><h3>  Sedikit teori </h3><br>  Ingat bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">modem sonar</a> kami didasarkan pada pendeteksi nada sederhana, yang frekuensinya 4 kali lebih sedikit dari frekuensi pengambilan sampel.  Ingat secara singkat cara kerjanya. <br><img src="https://habrastorage.org/webt/__/zm/oe/__zmoe1u0jzgjderykrsaogn0k8.png"><br><br>  Gambar menunjukkan dua osilasi bergeser relatif satu sama lain pada Pi / 2 - yaitu, fase sinus dan kosinus.  Dan jika frekuensinya tepat empat kali lebih sedikit dari frekuensi sampling, maka hanya 4 sampel yang jatuh pada periode tersebut. <br>  Habuchitel yang penuh perhatian tentu memperhatikan bahwa kedua sinyal dialihkan ke Pi / 4.  Dengan perubahan ini, sinyal hanya mengambil dua nilai: √2 / 2 dan -√2 / 2. <br>  Dan nilai-nilai spesifik bahkan tidak penting, penting bahwa Anda hanya dapat menggunakan tanda-tanda: "+" dan "-". <br><br>  Sekarang kita dapat mewakili fase sinus sebagai urutan tanda "+" "+" "-" "-", dan fase cosinus sebagai "+" "-" "-" "+". <br><br><div class="spoiler">  <b class="spoiler_title">Di bawah spoiler, ulangi detektor:</b> <div class="spoiler_text"> Biarkan sinyal input berada di buffer sn, kami memiliki dua buffer cincin rata-rata untuk fase sinus dan cosinus - bs dan bc dengan ukuran N. Mereka memiliki pointer head dan tail yang sama - bH dan bT.  Pada saat awal waktu, bH = N-1, bT = 0. Penghitung siklus rata-rata C = 0. <br>  Kami mengambil 4 sampel dari buffer input dan menambahkannya sesuai dengan urutan karakter. <br><br> <code>a = sn(i) <br> bs(bH) = a <br> bc(bH) = a <br> s1 = s1 + a - bs(bT) <br> s2 = s2 + a - bc(bT) <br> bH = (bH + 1) % N <br> bT = (bT + 1) % N <br> <br> a = sn(i+1) <br> bs(bH) = a <br> bc(bH) = -a <br> s1 = s1 + a - bs(bT) <br> s2 = s2 - a - bc(bT) <br> bH = (bH + 1) % N <br> bT = (bT + 1) % N <br> <br> a = sn(i+2) <br> bs(bH) = -a <br> bc(bH) = -a <br> s1 = s1 - a - bs(bT) <br> s2 = s2 - a - bc(bT) <br> bH = (bH + 1) % N <br> bT = (bT + 1) % N <br> <br> a = sn(i+3) <br> bs(bH) = -a <br> bc(bH) = a <br> s1 = s1 - a - bs(bT) <br> s2 = s2 + a - bc(bT) <br> bH = (bH + 1) % N <br> bT = (bT + 1) % N <br></code> <br><br>  Setelah masing-masing memproses empat sampel, kami memeriksa penghitung siklus rata-rata dan jika telah melebihi N, maka kami menghitung amplitudo pembawa cA: <br><br> <code>if ++cycle &gt;= N <br> cA = sqrt(s1 * s1 + s2 * s2) <br> cycle = 0 <br> end <br></code> <br></div></div><br><br>  Kami menggunakan metode ini sebagai dasar, ini akan bertanggung jawab untuk "sinkronisasi". <br>  Sekarang mari kita lihat bagaimana gambar dikodekan.  Saya sarankan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">manipulasi amplitudo</a> .  Manipulasi adalah ketika sinyal dibagi menjadi segmen yang sama yang disebut chip atau simbol, dan beberapa parameter variabel (dalam kasus kami, amplitudo) disimpan di sepanjang chip. <br>  Jika, misalnya, kami dapat memvariasikan amplitudo dalam kisaran dari 0 hingga 32767 (sampel 16-bit), dan kami perlu mentransfer 255 nilai kecerahan piksel, kemudian per unit perubahan kecerahan piksel, amplitudo chip akan berubah menjadi 32768/255 = 128. <br>  Parameter penting lainnya adalah panjang chip, kami mulai dengan satu periode pembawa - empat sampel dalam kasus kami. <br>  Jadi gambar akan ditransmisikan piksel demi piksel, setiap piksel berlangsung 4 sampel, dan amplitudo untuk periode ini adalah b [x, y] * 128, di mana b [x, y] adalah nilai kecerahan piksel dengan koordinat x dan y pada gambar b. <br><br>  Mari kita perkirakan kecepatan transmisi yang akan terjadi. <br>  Dalam contoh, saya menggunakan ukuran bingkai 120x120 piksel.  Ini berarti bahwa untuk mentransfer satu frame, kita perlu <br><br>  120x120x4 = 57600 sampel, <br><br>  Jika frekuensi sampling 96 kHz, maka transmisi satu frame akan memakan waktu: <br><br>  57600/96000 = 0,6 detik <br><br>  Jelas, kita membutuhkan semacam jeda, interval pengawal tertentu, sehingga detektor dapat menentukan awal dari frame berikutnya.  Untuk alasan yang manusiawi, anggaplah bahwa 0,1 detik sudah cukup bagi kita, selama semua gema mati (sebenarnya tidak).  Kemudian, pada akhirnya, kecepatan transfer akan berubah: <br><br>  1 / (0,6 + 0,1) = 1,428 frame per detik. <br><br>  Sangat mudah untuk membuat kesalahan di sini dan mencoba menghitung kecepatan dalam bit per detik.  Lihat betapa luar biasanya kecepatan transmisi: <br><br>  120 * 120 * 8 / 1.428 = 80 627 bps <br><br>  Tetapi apa yang terjadi jika saya tidak memiliki piksel 8-bit, tetapi 16-bit? <br><br>  120 * 120 * 16 / 1.428 = 161344 bps <br><br>  Tangkapan di sini adalah bahwa, sekali lagi, metode transmisi ini tidak dapat disebut digital, dan konsep bit rate tidak sepenuhnya valid untuk itu. <br>  Cobalah untuk menghitung bit rate untuk sinyal televisi analog.  Dan untuk penerima detektor?  :) <br><br>  Jadi, misalnya, sepotong sinyal akan terlihat seperti, mentransmisikan kecerahan 10 piksel, nilai yang berubah secara bergantian: 1 2 1 2 1 2 1 2 1 2 <br><img src="https://habrastorage.org/webt/ul/kz/st/ulkzsthqa8tt4ykb7stgu7hehqe.png"><br><br>  Sekarang mari kita lihat bagaimana ini bekerja dalam contoh.  Metode Encode dan Decode hidup dalam kelas <a href="">Encoder</a> dan bertanggung jawab untuk memodulasi dan mendemodulasi gambar: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Encode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Bitmap source, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> carrier, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> interframePauseMs</span></span></span><span class="hljs-function">)</span></span> { Bitmap frame; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (source.PixelFormat != System.Drawing.Imaging.PixelFormat.Format8bppIndexed) frame = Grayscale.CommonAlgorithms.RMY.Apply(source); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> frame = source; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!frame.Size.Equals(frameSize)) frame = resizer.Apply(frame); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cols = frameSize.Width; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rows = frameSize.Height; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> col = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> row = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> delta = Math.PI * <span class="hljs-number"><span class="hljs-number">2</span></span> * carrier / sampleRate; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> alpha = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> phase = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> pxAmplitude = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> chipLimit = Math.PI * <span class="hljs-number"><span class="hljs-number">2</span></span> * chipSize; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> pLimit = Math.PI * <span class="hljs-number"><span class="hljs-number">2</span></span>; List&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; samples = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isFinished = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; pSize; i++) { alpha = Math.Sin(phase); phase += delta; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (phase &gt;= pLimit) { phase -= pLimit; } samples.Add(alpha * <span class="hljs-keyword"><span class="hljs-keyword">short</span></span>.MaxValue); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!isFinished) { alpha = Math.Sin(phase); phase += delta; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (phase &gt;= chipLimit) { phase -= chipLimit; pxAmplitude = (((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)frame.GetPixel(col, row).R) / <span class="hljs-number"><span class="hljs-number">255.0</span></span>) * <span class="hljs-keyword"><span class="hljs-keyword">short</span></span>.MaxValue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++col &gt;= cols) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++row &gt;= rows) isFinished = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> col = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } samples.Add(alpha * pxAmplitude); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (interframePauseMs &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { samples.AddRange(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)interframePauseMs) / <span class="hljs-number"><span class="hljs-number">1000.0</span></span>) * (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)sampleRate)]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> samples.ToArray(); }</code> </pre><br><br>  Hal ini dapat dilihat dari kode bahwa sebelum memodulasi gambar, awalan sinkronisasi yang terdiri dari nada murni (sampel pSize) ditambahkan ke sinyal output - ini diperlukan sehingga pada sisi penerima sinkronisasi dapat terjadi sebelum gambar itu sendiri <s>dan secara umum dapat terjadi</s> dalam kondisi buruk. <br>  Metode Decode adalah sebagai berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Bitmap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Decode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] samples, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> carrier, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pSize</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cols = frameSize.Width; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rows = frameSize.Height; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> col = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> row = <span class="hljs-number"><span class="hljs-number">0</span></span>; Bitmap result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bitmap(cols, rows); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> delta = Math.PI * <span class="hljs-number"><span class="hljs-number">2</span></span> * carrier / sampleRate; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> alpha = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> phase = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> chipLimit = Math.PI * <span class="hljs-number"><span class="hljs-number">2</span></span> * chipSize; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> chipAmplitude = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> maxAmplitude = WaveUtils.GetMaxAmplitude(samples); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> pxMax = -maxAmplitude; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> pxMin = maxAmplitude; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> smp; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = pSize; (i &lt; samples.Length) &amp;&amp; (row &lt; rows); i++) { alpha = Math.Sin(phase); phase += delta; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (phase &gt;= chipLimit) { phase -= chipLimit; chipAmplitude = (Math.Max(Math.Abs(pxMax), Math.Abs(pxMin)) / maxAmplitude); pxMin = maxAmplitude; pxMax = -maxAmplitude; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gs = Convert.ToByte(chipAmplitude * <span class="hljs-number"><span class="hljs-number">255</span></span>); result.SetPixel(col, row, Color.FromArgb(<span class="hljs-number"><span class="hljs-number">255</span></span>, gs, gs, gs)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++col &gt;= cols) { col = <span class="hljs-number"><span class="hljs-number">0</span></span>; row++; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { smp = samples[i] * alpha; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smp &gt; pxMax) pxMax = smp; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smp &lt; pxMin) pxMin = smp; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br><br>  Dapat dilihat bahwa kedua metode tidak terikat pada frekuensi tertentu dan dapat digunakan dengan detektor lain. <br><br>  Pencarian sinyal itu sendiri (deteksi, sinkronisasi) juga terjadi seperti pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">modem hidroakustik</a> kami yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">paling sederhana</a> , dengan satu-satunya perbedaan adalah bahwa saya meletakkannya di kelas <a href="">FsBy4CarrierDetector yang</a> terpisah untuk perubahan. <br>  Semua sihir tanpa komplikasi terjadi dalam metode bool ProcessSample (pendek a) <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessSample</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">short</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smpCount == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ring1[ringHead] = a; ring2[ringHead] = a; s1 += a - ring1[ringTail]; s2 += a - ring2[ringTail]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smpCount == <span class="hljs-number"><span class="hljs-number">1</span></span>) { ring1[ringHead] = a; ring2[ringHead] = -a; s1 += a - ring1[ringTail]; s2 += - a - ring2[ringTail]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smpCount == <span class="hljs-number"><span class="hljs-number">2</span></span>) { ring1[ringHead] = -a; ring2[ringHead] = -a; s1 += -a - ring1[ringTail]; s2 += -a - ring2[ringTail]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smpCount == <span class="hljs-number"><span class="hljs-number">3</span></span>) { ring1[ringHead] = -a; ring2[ringHead] = a; s1 += -a - ring1[ringTail]; s2 += a - ring2[ringTail]; } ringHead = (ringHead + <span class="hljs-number"><span class="hljs-number">1</span></span>) % ringSize; ringTail = (ringTail + <span class="hljs-number"><span class="hljs-number">1</span></span>) % ringSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++smpCount &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>) { smpCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++cycle &gt;= ringSize) { s = Math.Sqrt(s1 * s1 + s2 * s2) / ringSize; cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; result = (s - sPrev) &gt;= Threshold; sPrev = s; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><br>  Ini dipanggil pada setiap sampel yang masuk dan mengembalikan true jika terdeteksi pembawa. <br><br>  Karena detektor jauh dari sempurna, dan dapat dengan mudah disinkronkan di tengah garis, saya menambahkan slider khusus, bergerak yang Anda dapat mencapai sinkronisasi yang lebih akurat. <br><br>  Sekarang, setelah kita secara singkat memeriksa bagaimana ini semua bekerja, mari kita beralih ke bagian yang paling lezat: apa yang bisa diperoleh dari semua ini. <br><br><h3>  Sedikit latihan </h3><br>  Pertama, mari kita periksa bagaimana semuanya bekerja tanpa saluran sonar - cukup dengan melampirkan antena penerima dan pemancar satu sama lain. <br>  Pertama, gambar lebih besar (240x120) sehingga setidaknya ada sesuatu yang bisa dibuat: <br><img src="https://habrastorage.org/webt/ev/ys/1t/evys1t89oks6jpvgeyxtgafgbp4.gif"><br><br>  Dan kemudian dengan cepat, sehingga ada <s>lebih banyak kehidupan</s> seperti video: <br><img src="https://habrastorage.org/webt/2j/2t/y_/2j2ty_dym0iowoiq_xgtf_oqdrg.gif"><br><br>  Sepertinya tidak buruk?  Tapi jangan buru-buru menarik kesimpulan, dan pergi ke kolam renang: <br><img src="https://habrastorage.org/webt/_8/0u/jz/_80ujzh-1afojo46fevq6egccvg.jpeg"><br><br>  Dan di sini, seperti yang saya janjikan dalam judul, kita akan melihat gema dengan mata kita sendiri: <br><img src="https://habrastorage.org/webt/lb/aq/xe/lbaqxezsgyzwjik0zxymshqjysi.gif"><br><br>  Bagaimana <s>Anda suka itu, Elon Musk?</s>  apakah kamu suka HD?  Kenapa begitu? <br>  Dan semuanya sangat sederhana - gema pada dasarnya adalah salinan yang tertunda dari sinyal asli, terkenal mengganggu di titik penerima, melipat dalam fase yang berbeda dan memberikan gambar seperti itu.  Karena kami mentransfer gambar, pada akhirnya kami mendapatkan banyak gambar saling melapis dengan amplitudo yang berbeda.  Semua ini pada akhirnya mengarah pada pengaburan dan reproduksi. <br><br>  Menengok ke belakang, mari kita periksa semuanya pada gambar model yang besar.  Saya mengambil foto acak: <br><img src="https://habrastorage.org/webt/oo/hd/jb/oohdjbgoj4pqq-k8f9st0b9rdre.jpeg"><br><br>  Saya memodulasinya, lalu menambahkan gema dan sedikit suara, lalu diterjemahkan, dan ya - hasilnya menyerupai apa yang kami dapatkan di kolam: <br><img src="https://habrastorage.org/webt/bk/dp/y_/bkdpy_9ztpti3b91ulbakqzokes.png"><br><br>  Pada prinsipnya, adalah mungkin untuk melakukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dekonvolusi</a> dan mengurangi refleksi, tetapi <s>biarlah orang-orang dari luar daerah</s> kita yang meninggalkan titik ini untuk pekerjaan mandiri. <br><br>  By the way, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">metode sebelumnya</a> di kolam bekerja sedikit lebih baik, tetapi juga buruk - pada sinyal broadband, multipath dan reverb mengarah ke frekuensi selektif fading, yang dalam gambar (baca pada spektrum) terlihat seperti garis-garis hitam dan putih - di mana sinyal berada di antiphase, dan di mana ia dikembangkan secara bertahap (pada kenyataannya, masih ada banyak opsi antara): <br><img src="https://habrastorage.org/webt/zo/f-/pp/zof-ppqayi-rbz2h9yfgjlvc8da.gif"><br><br>  Pada bulan April, kami memanfaatkan momen itu dan pergi ke kolam dengan model papan tempat memotong roti dan memanjakan diri Anda di sana juga: <br><img src="https://habrastorage.org/webt/mv/c-/v4/mvc-v4-m9tys6na8hip-8t8kzyc.jpeg"><br><br><img src="https://habrastorage.org/webt/pp/wc/8u/ppwc8uemc0xlmsmt_rz5h24s664.jpeg"><br><br>  Hasilnya tidak jauh berbeda dengan hasil yang didapat di pool: <br><img src="https://habrastorage.org/webt/1-/8j/et/1-8jetei8ly02aanoubjimfhlty.png"><br><br><img src="https://habrastorage.org/webt/_o/1q/ij/_o1qijulzi1p0pqxmch5dijhrcc.png"><br><br>  Dan segera untuk perbandingan, metode sebelumnya: <br><img src="https://habrastorage.org/webt/dh/8o/nk/dh8onkjtu5jly6kr7ios0k3td44.png"><br><br>  Dan berikut ini adalah animasi gif yang dikumpulkan dari frame yang disimpan, metode 1: <br><img src="https://habrastorage.org/webt/b7/bq/nz/b7bqnzrvtoa1jkbc0cj4h0okv-u.gif"><br><br>  Dan metode 2, yang kita bahas dalam artikel ini: <br><img src="https://habrastorage.org/webt/of/vg/gb/ofvggbrbktqq30iy0ihoybpx6le.gif"><br><br><h3>  Kesimpulannya </h3><br>  Seperti yang dijanjikan, kami menunjukkan bagaimana gema dan reverb terlihat secara harfiah, menghabiskan waktu dengan manfaat dan melakukan sesuatu dengan tangan kami. <br><br>  Dalam bentuk ini, tentu saja, metode ini tidak berlaku dalam praktik, tetapi bekerja dengannya akan sangat berguna bagi pemula. <br><br>  Secara umum, kami memeriksa di kolam dangkal, di mana kondisinya sangat tidak menguntungkan, dan akan keren jika seseorang mengulangi percobaan kami di reservoir lain dan pasti akan memberi tahu tentang hasilnya. <br><br>  Jika pembaca hanya ingin mencoba (bahkan di udara dengan mikrofon dan speaker), maka di sini adalah tautan untuk rilis: <br>  <a href="">Metode 1</a> <br>  <a href="">Metode 2 (dari artikel ini)</a> <br><br><h3>  PS </h3>  Kami benar-benar menantikan umpan balik dari pembaca, karena sangat penting untuk memahami bahwa Anda melakukan sesuatu dengan sia-sia (atau sia-sia, dan kemudian ini harus dihentikan segera). <br><br><h3>  PS / 2 </h3>  Saya akan menjawab pertanyaan umum segera: untuk ikan dan kehidupan laut lainnya di fasilitas anak-anak seperti itu, ini semua tidak terlalu diperhatikan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id453678/">https://habr.com/ru/post/id453678/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id453664/index.html">Spring Boot - OAuth2 dan JWT</a></li>
<li><a href="../id453666/index.html">Bagaimana saya mengendarai taksi tak berawak</a></li>
<li><a href="../id453668/index.html">10 kesalahan RO muda (bagian I - tiga kesalahan)</a></li>
<li><a href="../id453672/index.html">CardInfo - API untuk menentukan logo, warna bank dan hal-hal lain dengan nomor kartu</a></li>
<li><a href="../id453676/index.html">Menghubungkan ke Windows melalui SSH seperti di Linux</a></li>
<li><a href="../id453682/index.html">Pengembangan "firmware" paling sederhana untuk FPGA yang dipasang di Redd. Bagian 2. Kode program</a></li>
<li><a href="../id453686/index.html">Pekan Keamanan 22: statistik ancaman, trojan perbankan, dan eksploitasi populer</a></li>
<li><a href="../id453688/index.html">Java tidak hanya berdarah perusahaan, tetapi juga aplikasi yang sensitif terhadap latensi cepat</a></li>
<li><a href="../id453692/index.html">Game 3D Shaders for Beginners: Effects</a></li>
<li><a href="../id453694/index.html">Terhubung ke Windows melalui SSH seperti di Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>