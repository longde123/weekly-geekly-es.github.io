<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤽🏾 🏥 👷 用C ++开发接口类 🏂🏿 🏊 🙋🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="接口类在C ++程序中非常广泛地使用。 但是，不幸的是，在实现基于接口类的解决方案时经常会犯错误。 本文介绍了如何正确设计接口类；考虑了几个选项。 详细介绍了智能指针的使用。 给出了一个基于接口类的异常类和集合类模板的实现示例。 

 目录 
 目录  引言 
 1.特殊的成员函数，创建和删除对象 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>用C ++开发接口类</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427281/"><hr><p>  <i>接口类在C ++程序中非常广泛地使用。</i>  <i>但是，不幸的是，在实现基于接口类的解决方案时经常会犯错误。</i>  <i>本文介绍了如何正确设计接口类；考虑了几个选项。</i>  <i>详细介绍了智能指针的使用。</i>  <i>给出了一个基于接口类的异常类和集合类模板的实现示例。</i> </p><hr><br><a name="habracut"></a><br><h1> 目录 </h1><br><div class="spoiler">  <b class="spoiler_title">目录</b> <div class="spoiler_text"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">引言</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.特殊的成员函数，创建和删除对象</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.1。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">特殊会员职能</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.2。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">创建和删除对象-基本详细信息</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.3。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">析构函数访问级别</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.4。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在一个模块中创建和删除</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.5。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">多态删除</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.6。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">类声明不完整时删除</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.纯粹的虚函数和抽象类</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.1。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">纯虚拟功能</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.2。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">抽象类</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.3。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">纯虚拟析构函数</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.接口类</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.1。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实作</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.2。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">对象创建</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.3。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">删除物件</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.3.1。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用删除运算符</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.3.2。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用特殊的虚拟功能</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.3.3。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用外部功能</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.3.4。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用智能指针自动删除</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.4。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">其他用于管理实现类实例的生存期的选项</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.5。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">复制语义</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.6。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">接口类构造函数</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.7。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">双向互动</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.8。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">智能指针</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.9。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">恒定成员函数</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.10。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">COM接口</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.11。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">接口类和库</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.接口类及其实现的示例</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.1。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">接口类</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.2。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实现类</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.3。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">标准智能指针</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.3.1。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">客户端创建</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.3.2。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实施端创建</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.4。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">替代基类实现</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">5.使用接口类实现的异常和集合</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">5.1例外情况</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">5.2集合</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">6.接口类和包装器类</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">7.总结</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">参考文献</a> <br></div></div><br><a name="id-introdaction"></a><br><h1> 引言 </h1><br><p> 接口类是没有数据的类，主要由纯虚函数组成。 通过此解决方案，您可以将实现与接口完全分开（客户端使用接口类），而在另一个位置创建派生类，在该派生类中将重新定义纯虚函数并定义工厂函数。 实施细节对客户端完全隐藏。 这样，就实现了真正的封装，这对于通常的类是不可能的。 您可以从Scott Meyers [Meyers2]中了解有关接口类的信息。 接口类也称为协议类。 </p><br><p> 使用接口类可以削弱项目不同部分之间的依赖性，从而简化团队开发并减少编译/组装时间。 当在运行时有选择地加载模块时，接口类使实现灵活，动态的解决方案更加容易。 使用接口类作为接口（API）库（SDK）可以简化二进制兼容性问题的解决方案。 </p><br><p> 接口类的用途非常广泛，借助它们的帮助，它们可以实现库（SDK）的接口（API），插件（插件）的接口等等。 使用接口类自然可以实现许多四个[GoF]模式。 接口类包括COM接口。 但是，不幸的是，在实现基于接口类的解决方案时经常会犯错误。 让我们尝试澄清这个问题。 </p><br><a name="id-1"></a><br><h1>  1.特殊的成员函数，创建和删除对象 </h1><br><p> 本节简要介绍了许多C ++功能，您需要了解这些功能才能完全理解为接口类提供的解决方案。 </p><br><a name="id-1-1"></a><br><h2>  1.1。 特殊会员职能 </h2><br><p> 如果程序员尚未从以下列表中定义该类的成员函数-默认构造函数，复制构造函数，复制赋值运算符，析构函数-则编译器可以为他执行此操作。  C ++ 11在此列表中添加了移动构造函数和移动赋值运算符。 这些成员函数称为特殊成员函数。 仅在使用它们并且满足每个功能特定的附加条件时才生成它们。 我们提请注意以下事实：这种用法可能被隐藏起来（例如，在实现继承时）。 如果无法生成所需的功能，则会生成错误。  （除重定位操作外，它们均由复制操作代替。）编译器生成的成员函数是公共的并且是可嵌入的。 </p><br><p> 特殊成员函数不会被继承，如果派生类中需要特殊成员函数，则编译器将始终尝试生成该特殊成员函数；程序员在基类中定义的相应成员函数的存在不会对此产生影响。 </p><br><p>程序员可以禁止生成特殊的成员函数，在C ++ 11中声明时，必须使用<code>"=delete"</code>构造，在C ++ 98中，声明相应的成员函数为private而不定义。 在类继承中，禁止在基类中生成特殊成员函数的情况适用于所有派生类。 </p><br><p> 如果程序员对编译器生成的成员函数感到满意，那么在C ++ 11中，他可以明确地指出这一点，而不仅仅是删除声明。 为此，在声明时必须使用<code>"=default"</code>构造，这样可以更好地阅读代码，并且出现与管理访问级别有关的其他功能。 </p><br><p> 特殊成员功能的详细信息可以在[Meyers3]中找到。 </p><br><a name="id-1-2"></a><br><h2>  1.2。 创建和删除对象-基本详细信息 </h2><br><p> 使用<code>new/delete</code>运算符创建和删除对象是典型的二合一操作。 调用<code>new</code> ，首先为该对象分配内存。 如果选择成功，则调用构造函数。 如果构造函数引发异常，则释放分配的内存。 当调用<code>delete</code>运算符时，一切都以相反的顺序进行：首先，调用析构函数，然后释放内存。 析构函数不应引发异常。 </p><br><p> 如果使用<code>new</code>运算符创建对象数组，则首先为整个数组分配内存。 如果选择成功，则将为数组的每个元素（从零开始）调用默认构造函数。 如果任何构造函数引发异常，则对于数组的所有已创建元素，将以构造函数调用的相反顺序调用析构函数，然后释放分配的内存。 若要删除数组，必须调用<code>delete[]</code>运算符（对于数组称为<code>delete</code>运算符），对于数组的所有元素，将以构造函数调用的相反顺序调用析构函数，然后释放分配的内存。 </p><br><p> 注意！ 您必须根据<code>delete</code>单个对象还是数组来调用<code>delete</code>运算符的正确形式。 必须严格遵守此规则，否则您将获得未定义的行为，即可能发生任何事情：内存泄漏，崩溃等。 有关详细信息，请参见[Meyers2]。 </p><br><p> 标准内存分配函数<code>std::bad_alloc</code>满足请求，并抛出<code>std::bad_alloc</code>类型的异常。 </p><br><p> 将任何形式的<code>delete</code>运算符应用于空指针都是安全的。 </p><br><p> 在以上描述中，需要进行澄清。 对于所谓的琐碎类型（内置类型，C样式结构），可能不会调用构造函数，并且析构函数在任何情况下均不执行任何操作。 另请参阅第1.6节。 </p><br><a name="id-1-3"></a><br><h2>  1.3。 析构函数访问级别 </h2><br><p> 当将<code>delete</code>运算符应用于指向类的指针时，该类的析构函数必须在<code>delete</code>调用点可用。  （此规则有一些例外，将在1.6节中讨论。）因此，通过使析构函数安全或关闭，程序员可以在析构函数不可用的情况下禁止使用<code>delete</code>运算符。 回想一下，如果在类中未定义析构函数，则编译器将自行执行此操作，并且此析构函数将打开（请参见1.1节）。 </p><br><a name="id-1-4"></a><br><h2>  1.4。 在一个模块中创建和删除 </h2><br><p> 如果<code>new</code>运算符创建了一个对象，则<code>delete</code>运算符必须在同一模块中才能<code>delete</code>它。 形象地说，“把它放到哪里去”。 该规则是众所周知的；例如，参见[Sutter / Alexandrescu]。 如果违反此规则，则可能会发生分配和释放内存的功能“不匹配”，这通常会导致程序崩溃。 </p><br><a name="id-1-5"></a><br><h2>  1.5。 多态删除 </h2><br><p> 如果要设计类的多态层次结构，其类的实例使用<code>delete</code>运算符<code>delete</code> ，则在基类中必须有一个开放的虚拟析构函数，这可确保在将<code>delete</code>运算符应用于指向基类的指针时， <code>delete</code>调用对象实际类型的析构函数。 如果违反此规则，则可能会发生对基类析构函数的调用，这可能导致资源泄漏。 </p><br><a name="id-1-6"></a><br><h2>  1.6。 类声明不完整时删除 </h2><br><p>  <code>delete</code>运算符的杂项性可能会导致某些问题；可以将其应用于<code>void*</code>类型的指针或具有不完整（抢先）声明的类的指针。 在这种情况下，不会发生错误，只是跳过对析构函数的调用，仅调用释放内存的函数。 考虑一个例子： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//   X* CreateX(); void Foo() {    X* p = CreateX();    delete p; }</span></span></code> </pre> <br><p> 即使完整的<code>X</code>类声明在<code>delete</code>拨号对等方不可用，该代码也会编译。 是的，在编译（Visual Studio）时会发出警告： </p><br><p> <code>warning C4150: deletion of pointer to incomplete type 'X'; no destructor called</code> </p> <br><p> 如果存在<code>X</code>和<code>CreateX()</code> ，则将<code>CreateX()</code>代码，如果<code>CreateX()</code>返回指向由<code>new</code>运算符创建的对象的指针，则调用<code>Foo()</code>成功执行，则不调用析构函数。 显然，这可能会导致资源的消耗，因此，再次需要注意警告。 </p><br><p> 这种情况并非易事，当使用诸如智能指针或描述符类之类的类时，很容易出现这种情况。  Scott Meyers在[Meyers3]中处理了此问题。 </p><br><a name="id-2"></a><br><h1>  2.纯粹的虚函数和抽象类 </h1><br><p> 接口类的概念基于纯虚拟函数和抽象类等C ++概念。 </p><br><a name="id-2-1"></a><br><h2>  2.1。 纯虚拟功能 </h2><br><p> 使用<code>"=0"</code>构造声明的虚函数称为纯虚函数。 </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ...    virtual void Foo() = 0; };</span></span></code> </pre> <br><p> 与常规虚函数不同，纯虚函数无法定义（析构函数除外，请参见第2.3节），但必须在派生类之一中对其进行重新定义。 </p><br><p> 可以定义纯虚函数。  Emblem Sutter为此功能提供了一些有用的用途[Shutter]。 </p><br><a name="id-2-2"></a><br><h2>  2.2。 抽象类 </h2><br><p> 抽象类是至少具有一个纯虚函数的类。 从抽象类派生并且不覆盖至少一个纯虚函数的类也将是抽象的。  C ++标准禁止创建抽象类的实例；您只能创建非抽象类的派生实例。 因此，创建了一个抽象类以用作基类。 因此，如果在抽象类中定义了构造函数，则将其打开是没有意义的，必须对其进行保护。 </p><br><a name="id-2-3"></a><br><h2>  2.3。 纯虚拟析构函数 </h2><br><p> 在某些情况下，建议制作一个纯虚拟析构函数。 但是此解决方案具有两个功能。 </p><br><ol><li> 必须定义一个纯虚拟的析构函数。  （通常使用默认定义，即使用<code>"=default"</code>构造。）派生类析构函数沿整个继承链调用基类析构函数，因此，可以确保队列到达根-纯虚拟析构函数。 </li><li> 如果程序员没有在派生类中重新定义纯虚拟析构函数，则编译器将为他做这件事（请参见1.1节）。 因此，从具有纯虚拟析构函数的抽象类派生的类可能会失去其抽象性，而不会显式覆盖析构函数。 </li></ol><br><p> 在第4.4节中可以找到使用纯虚拟析构函数的示例。 </p><br><a name="id-3"></a><br><h1>  3.接口类 </h1><br><p> 接口类是没有数据的抽象类，主要由纯虚函数组成。 这样的类可以具有普通的虚函数（不是纯虚函数），例如析构函数。 也可能有静态成员函数，例如工厂函数。 </p><br><a name="id-3-1"></a><br><h2>  3.1。 实作 </h2><br><p> 接口类的实现将称为派生类，在派生类中将重新定义纯虚函数。 同一接口类可以有多种实现，并且有两种方案是可能的：水平（当几个不同的类继承相同的接口类时）和垂直（当接口类是多态层次结构的根时）。 当然，可能会有杂种。 </p><br><p> 接口类概念的关键是接口与实现的完全隔离-客户端仅与接口类一起使用，实现不可用。 </p><br><a name="id-3-2"></a><br><h2>  3.2。 对象创建 </h2><br><p> 实现类的不可访问性在创建对象时引起某些问题。 客户端必须创建实现类的实例，并获得指向将通过其访问对象的接口类的指针。 由于实现类不可用，因此无法使用构造函数，因此，将使用在实现端定义的工厂函数。 此函数通常使用<code>new</code>运算符创建一个对象，并返回指向创建的对象的指针，并将其转换为指向接口类的指针。 工厂函数可以是接口类的静态成员，但不是必须的，例如，它可以是特殊工厂类（本身又可以是接口类）的成员或自由函数。 工厂函数不能返回指向接口类的原始指针，而可以返回智能指针。 此选项在3.3.4和4.3.2节中讨论。 </p><br><a name="id-3-3"></a><br><h2>  3.3。 删除物件 </h2><br><p> 移除对象是非常关键的操作。 错误会导致内存泄漏或双重删除，通常会导致程序崩溃。 下面的问题被认为是尽可能详细的，并且要特别注意防止错误的客户行为。 </p><br><p> 有四个主要选项： </p><br><ol><li> 使用<code>delete</code>运算符。 </li><li> 使用特殊的虚拟功能。 </li><li> 使用外部功能。 </li><li> 使用智能指针自动删除。 </li></ol><br><a name="id-3-3-1"></a><br><h3>  3.3.1。 使用<code>delete</code>运算符 <br></h3><br><p> 为此，您必须在接口类中有一个开放的虚拟析构函数。 在这种情况下，需要在客户端上调用指向接口类的指针的<code>delete</code>操作符提供对实现类的析构函数的调用。 此选项可能有效，但很难将其识别为成功。 我们在“屏障”的不同侧收到<code>new</code>和<code>delete</code>运算符的调用，在实现侧是<code>delete</code> ，在客户端是<code>delete</code> 。 而且，如果接口类的实现是在单独的模块中完成的（这是很常见的事情），那么我们将违反第1.4节中的规则。 </p><br><a name="id-3-3-2"></a><br><h3>  3.3.2。 使用特殊的虚拟功能 </h3><br><p> 更具进步性的另一个选择是：接口类必须具有删除对象的特殊虚函数。 最终，这样的功能归结为调用<code>delete this</code> ，但这已经在实现方面发生。 可以以不同的方式调用此函数，例如<code>Delete()</code> ，但也使用其他选项： <code>Release()</code> ， <code>Destroy()</code> ， <code>Dispose()</code> ， <code>Free()</code> ， <code>Close()</code>等。 除了遵守第1.4节中的规则之外，此选项还具有其他一些优点。 </p><br><ol><li> 允许您将用户定义的内存分配/释放函数用于实现类。 </li><li> 允许您实现更复杂的方案来控制实现对象的生存期，例如使用引用计数器。 </li></ol><br><p> 在该实施例中，可以编译甚至执行使用<code>delete</code>操作符删除对象的尝试，但这是错误的。 为了防止在接口类中使用它，只要有一个空的或纯虚拟的受保护的析构函数就足够了（请参阅第1.3节）。 请注意， <code>delete</code>操作符的使用可能被掩盖了，例如，默认情况下，标准智能指针使用<code>delete</code>操作符删除对象，并且相应的代码已深深地埋在其实现中。 受保护的析构函数使您可以在编译阶段检测所有此类尝试。 </p><br><a name="id-3-3-3"></a><br><h3>  3.3.3。 使用外部功能 </h3><br><p> 此选项可能会吸引创建和删除对象的过程的某种对称性，但实际上，它比以前的版本没有优势，但是还有许多其他问题。 不建议使用此选项，以后也不会考虑使用此选项。 </p><br><a name="id-3-3-4"></a><br><h3>  3.3.4。 使用智能指针自动删除 </h3><br><p> 在这种情况下，工厂函数不会返回指向接口类的原始指针，而是返回对应的智能指针。 该智能指针在实现侧创建，并封装删除对象，当智能指针（或其最后一个副本）超出客户端范围时，删除对象将自动删除实现对象。 在这种情况下，可能不需要用于删除实现对象的特殊虚拟函数，但是仍然需要一个受保护的析构函数，因此必须防止错误使用<code>delete</code>运算符。  （正确的是，应该显着降低此类错误的可能性。）此选项在4.3.2节中有更详细的讨论。 </p><br><a name="id-3-4"></a><br><h2>  3.4。 其他用于管理实现类实例的生存期的选项 </h2><br><p> 在某些情况下，客户端可能会收到指向该接口类的指针，但不是该接口类的拥有者。 实现对象生命周期的管理完全在实现方面。 例如，对象可以是静态单例对象（此解决方案对于工厂来说是典型的）。 另一个示例与双向交互有关，请参见第3.7节。 客户端不应删除此类对象，但是需要此类接口类的受保护析构函数，因此有必要防止错误使用<code>delete</code>运算符。 </p><br><a name="id-3-5"></a><br><h2>  3.5。 复制语义 </h2><br><p> 对于接口类，无法使用copy构造函数创建实现对象的副本，因此，如果需要复制，则该类必须具有一个虚拟函数，该函数创建实现对象的副本并返回指向接口类的指针。 此类函数通常称为虚拟构造函数，其传统名称为<code>Clone()</code>或<code>Duplicate()</code> 。 </p><br><p> 禁止使用副本分配运算符，但不能认为这是一个好主意。 复制分配运算符始终配对；它必须与复制构造函数配对。 默认编译器生成的运算符是没有意义的；它什么也不做。 从理论上讲，可以在随后的重新定义中声明一个纯虚拟的赋值运算符，但不建议使用虚拟赋值；有关详细信息，请参见[Meyers1]。 而且，分配看起来非常不自然：通常通过指向接口类的指针来访问实现类的对象，因此分配看起来像这样： </p><br><pre> <code class="cpp hljs">* = *;</code> </pre> <br><p> 最好禁止赋值运算符，并且在必要时，此类语义在接口类中具有对应的虚函数。 </p><br><p> 有两种禁止分配的方法。 </p><br><ol><li> 声明分配运算符已删除（ <code>=delete</code> ）。 如果接口类形成层次结构，则足以在基类中完成。 这种方法的缺点是它影响实现类，该禁令也适用于它。 </li><li> 用默认定义（ <code>=default</code> ）声明一个受保护的赋值语句。 这不会影响实现类，但是在接口类层次结构的情况下，必须在每个类中进行此类声明。 </li></ol><br><a name="id-3-6"></a><br><h2>  3.6。 接口类构造函数 </h2><br><p> 通常，不声明接口类的构造函数。 在这种情况下，编译器会生成实现继承所需的默认构造函数（请参见1.1节）。 该构造函数是开放的，尽管足够安全。 如果在接口类中将复制的构造函数声明为delete（ <code>=delete</code> ），则默认情况下禁止该构造函数的编译器生成，并且必须显式声明此类构造函数。 使用默认定义（ <code>=default</code> ）使其安全是很自然的。 原则上，这样受保护的构造函数的声明总是可以完成的。 第4.4节提供了一个示例。 </p><br><a name="id-3-7"></a><br><h2>  3.7。 双向互动 </h2><br><p> 接口类对于使用双向通信很方便。 如果可以通过接口类访问某些模块，则客户端还可以创建某些接口类的实现，并在模块中传递指向它们的指针。 通过这些指针，模块可以从客户端接收服务，还可以向客户端发送数据或通知。 </p><br><a name="id-3-8"></a><br><h2>  3.8。 智能指针 </h2><br><p> 由于通常通过指针来访问实现类的对象，因此使用智能指针来控制其生命周期是很自然的。 但是应该记住，如果使用了第二种删除对象的选项，那么使用标准的智能指针，就必须传输用户删除器（类型）或这种类型的实例。 如果不这样做，那么智能指针将使用<code>delete</code>运算符删除该对象，并且代码将根本无法编译（由于受保护的析构函数）。 在[Josuttis]，[Meyers3]中详细讨论了标准智能指针（包括自定义删除器的使用）。 在第4.3.1节中可以找到使用自定义卸妆的示例。 </p><br><p>      ,       ,      ,    . </p><br><a name="id-3-9"></a><br><h2>  3.9。  - </h2><br><p>     -    const.              ,  ,    -,       . </p><br><a name="id-3-10"></a><br><h2>  3.10。 COM- </h2><br><p> COM-    ,     ,  COM —      ,  COM-     ,   C,    ,   .  COM-  C++      ,   COM. </p><br><a name="id-3-11"></a><br><h2>  3.11。     </h2><br><p>         (API)    (SDK).       .    -,      -,           .     ,     (Windows DLL),     :  -.          .        ,  ,       .     <code>LoadLibrary()</code>      ,    -,       . </p><br><a name="id-4"></a><br><h1> 4.       </h1><br><a name="id-4-1"></a><br><h2> 4.1.   </h2><br><p>       ,      . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBase</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IBase() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   public:    virtual void Delete() = 0; //      IBase&amp; operator=(const IBase&amp;) = delete; //   };</span></span></code> </pre> <br><p>    . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IActivatable</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IBase { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    ~IActivatable() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   public:    virtual void Activate(bool activate) = 0;    static IActivatable* CreateInstance(); // - };</span></span></code> </pre> <br><p> ,         ,     .     ,           <code>IBase</code> .     ,            (.  1.3).       ,       . </p><br><a name="id-4-2"></a><br><h2> 4.2.   </h2><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activator</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IActivatable { <span class="hljs-comment"><span class="hljs-comment">// ... private:    Activator(); protected:    ~Activator(); public:    void Delete() override;    void Activate(bool activate) override;    friend IActivatable* IActivatable::CreateInstance(); }; Activator::Activator() {/* ... */} Activator::~Activator() {/* ... */} void Activator::Delete() { delete this; } void Activator::Activate(bool activate) {/* ... */} IActivatable* IActivatable::CreateInstance() {    return static_cast&lt;IActivatable*&gt;(new Activator()); }</span></span></code> </pre> <br><p>      , ,        ,  -  ,         . </p><br><a name="id-4-3"></a><br><h2>  4.3。    </h2><br><a name="id-4-3-1"></a><br><h3> 4.3.1.     </h3><br><p>           . -   (     <code>IBase</code> ): </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseDeleter</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IBase* p)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ p-&gt;Delete(); } };</code> </pre> <br><p>  <code>std::unique_ptr&lt;&gt;</code> -   : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">&gt; // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class"> —  </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBase</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UniquePtr</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;I, BaseDeleter&gt;;</code> </pre> <br><p> ,   ,  -   ,  <code>UniquePtr</code>    . </p><br><p>   -: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">&gt; // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class"> —  - </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreateInstance</span></span></span><span class="hljs-class">() </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UniquePtr</span></span></span><span class="hljs-class">&lt;I&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreateInstance</span></span></span><span class="hljs-class">() {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UniquePtr&lt;I&gt;(I::CreateInstance()); }</code> </pre> <br><p>        : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">&gt; // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class"> —  </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBase</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UniquePtr</span></span></span><span class="hljs-class">&lt;I&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToPtr</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">) {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UniquePtr&lt;I&gt;(p); }</code> </pre> <br><p>  <code>std::shared_ptr&lt;&gt;</code>    <code>std::unique_ptr&lt;&gt;</code> ,   ,  <code>std::shared_ptr&lt;&gt;</code>   .      <code>Activator</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> un1 = CreateInstance&lt;IActivatable&gt;(); un1-&gt;Activate(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> un2 = ToPtr(IActivatable::CreateInstance()); un2-&gt;Activate(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;IActivatable&gt; sh = CreateInstance&lt;IActivatable&gt;(); sh-&gt;Activate(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br><p>          (     — -): </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;IActivatable&gt; sh2(IActivatable::CreateInstance());</code> </pre> <br><p>     <code>std::make_shared&lt;&gt;()</code> ,      (    ). </p><br><p>    :          ,     .     :     ,  - .     4.4. </p><br><a name="id-4-3-2"></a><br><h3> 4.3.2.     </h3><br><p>       .           -.   <code>std::shared_ptr&lt;&gt;</code>         ,    ,      (         ).     <code>std::shared_ptr&lt;&gt;</code> (  )  -  ,           <code>delete</code>     .  <code>std::shared_ptr&lt;&gt;</code> -       (   )   -      .        . </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class IActivatable; using ActPtr = std::shared_ptr&lt;IActivatable&gt;; //   class IActivatable { protected:    virtual ~IActivatable() = default; //      IActivatable&amp; operator=(const IActivatable&amp;) = default; //   public:    virtual void Activate(bool activate) = 0;    static ActPtr CreateInstance(); // - }; //   class Activator : public IActivatable { // ... public:    Activator();  //      ~Activator(); //      void Activate(bool activate) override; }; Activator::Activator() {/* ... */} Activator::~Activator() {/* ... */} void Activator::Activate(bool activate) {/* ... */} ActPtr IActivatable::CreateInstance() {    return ActPtr(new Activator()); }</span></span></span></span></code> </pre> <br><p>  -        <code>std::make_shared&lt;&gt;()</code> : </p><br><pre> <code class="cpp hljs">ActPtr IActivatable::CreateInstance() {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;Activator&gt;(); }</code> </pre> <br><p>      <code>std::unique_ptr&lt;&gt;</code> ,        , -   ,        . </p><br><a name="id-4-4"></a><br><h2>  4.4。     </h2><br><p>    C#  Java  C++    «»,       .        .      <code>IBase</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBase</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    IBase() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IBase() = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ,       virtual void Delete(); //   public:    IBase(const IBase&amp;) = delete;            //      IBase&amp; operator=(const IBase&amp;) = delete; //      struct Deleter        // -    {        void operator()(IBase* p) const { p-&gt;Delete(); }    };    friend struct IBase::Deleter; };</span></span></code> </pre> <br><p>     , <code>Delete()</code>    ,     . </p><br><pre> <code class="cpp hljs">IBase::~IBase() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IBase::Delete() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br><p>      <code>IBase</code> .         <code>Delete()</code> ,              . -      <code>IBase</code> . <code>Delete()</code>  , - .     <code>Delete()</code>         ,    .       ,    4.3.1. </p><br><a name="id-5"></a><br><h1> 5.   ,      </h1><br><a name="id-5-1"></a><br><h2> 5.1  </h2><br><p>  ,    ,   ,      ,        . </p><br><p>   ,  ,    <code>IException</code>    <code>Exception</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IException</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class">;</span></span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> IException* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IException() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">What</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    IException&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IException&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class"> {</span></span>    IException* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> m_Ptr; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    Exception(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* what, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code);    Exception(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Exception&amp; src) : m_Ptr(src.m_Ptr-&gt;Clone()) {}    ~Exception() { m_Ptr-&gt;Delete(); }    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> IException* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ptr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_Ptr; } };</code> </pre> <br><p>         <code>Exception</code> ,            <code>IException</code> .       ,    <code>throw</code> ,   .    <code>Exception</code>      ,      .  -      ,   . </p><br><p>  <code>Exception</code> , ,  . </p><br><p>   <code>IException</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExcImpl</span></span></span><span class="hljs-class"> :</span></span> IException {    <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class">;</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_What;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_Code;    ExcImpl(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* what, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code);    ExcImpl(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ExcImpl&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;    <span class="hljs-function"><span class="hljs-function">IException* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    ~ExcImpl() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">What</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>; }; ExcImpl::ExcImpl(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* what, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code)    : m_What(what), m_Code(code) {} IException* ExcImpl::Clone() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExcImpl(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ExcImpl::Delete() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* ExcImpl::What() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_What.c_str(); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ExcImpl::Code() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_Code; }</code> </pre> <br><p>   <code>Exception</code> : </p><br><pre> <code class="cpp hljs">Exception::Exception(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* what, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code)    : m_Ptr(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExcImpl(what, code)) {}</code> </pre> <br><p>    ,       — .NET —  , —          ,     C++/CLI.  ,        ,     ,   C++/CLI. </p><br><a name="id-5-2"></a><br><h2> 5.2  </h2><br><p>   -    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ICollect</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~ICollect() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ICollect&lt;T&gt;* Clone() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsEmpty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ind)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ind)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    ICollect&lt;T&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ICollect&lt;T&gt;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; };</code> </pre> <br><p>        ,             -,        . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ICollect</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterator</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Contain</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> ICollect&lt;T&gt; CollType;    CollType* m_Coll; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> T value_type;    Contain(CollType* coll);    ~Contain(); <span class="hljs-comment"><span class="hljs-comment">//     Contain(const Contain&amp; src);    Contain&amp; operator=(const Contain&amp; src); //     Contain(Contain&amp;&amp; src);    Contain&amp; operator=(Contain&amp;&amp; src);    bool mpty() const;    int size() const;    T&amp; operator[](int ind);    const T&amp; operator[](int ind) const;    Iterator&lt;T&gt; begin();    Iterator&lt;T&gt; end(); };</span></span></code> </pre> <br><p>      .   ,       . ,      ,    ,     ,    - <code>begin()</code>  <code>end()</code> ,   .           (. [Josuttis]),         <code>for</code>   .                .            , ,      . </p><br><a name="id-6"></a><br><h1> 6.    - </h1><br><p>       .         -,      .          .   ,         ++.              ,   .NET, Java  Pyton.              .      ,  ,         .   .NET Framework     C++/CLI          C++.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> . </p><br><a name="id-conclusion"></a><br><h1> 7.  </h1><br><p>      -,         . </p><br><p>         . </p><br><ol><li>   <code>delete</code> . </li><li>    . </li><li>      . </li></ol><br><p>          . </p><br><p>         ,       <code>delete</code> .                ,      . </p><br><p>    -   ,           .             ,    ,      <code>delete</code> . </p><br><p>             . </p><br><p>      ,          ,     ,  ,       . </p><br><br><a name="id-refs"></a><br><h1>   </h1><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><p> [GoF] <br>  .,  .,  .,  .  - .  .: .  . — .: , 2001. </p><br><p> [Josuttis] <br> ,  .   C++:  , 2- .: .  . — .:  «.. », 2014. </p><br><p> [Dewhurst] <br> ,  .   C++.         .: .  . — .:  , 2012. </p><br><p> [Meyers1] <br> , .    C++. 35        .: .  . — .:  , 2000. </p><br><p> [Meyers2] <br> , .   C++. 55        .: .  . — .:  , 2014. </p><br><p> [Meyers3] <br> , .    C++: 42    C++11  C++14.: .  . — .:  «.. », 2016. </p><br><p> [Sutter] <br> , .     C++.: .  . — :  «.. », 2015. </p><br><p> [Sutter/Alexandrescu] <br> , . , .    ++.: .  . — .:  «.. », 2015. </p><br></div></div><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN427281/">https://habr.com/ru/post/zh-CN427281/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN427271/index.html">使用机器翻译的历史和经验。 Yandex讲座</a></li>
<li><a href="../zh-CN427273/index.html">人工智能可以使庄家失去工作吗？</a></li>
<li><a href="../zh-CN427275/index.html">互联网信息架构第3部分</a></li>
<li><a href="../zh-CN427277/index.html">在素的分布中发现了衍射图，类似于准晶体</a></li>
<li><a href="../zh-CN427279/index.html">合作实验室：Android之夜#Apple</a></li>
<li><a href="../zh-CN427283/index.html">如何确保Kubernetes的高可用性</a></li>
<li><a href="../zh-CN427285/index.html">关于数字电路基础的学校：新西伯利亚-好，克拉斯诺亚尔斯克-准备</a></li>
<li><a href="../zh-CN427289/index.html">阿美创新的3D地质建模，测井和技术</a></li>
<li><a href="../zh-CN427291/index.html">最小化ASP.NET Web窗体，可单击的div和定期服务器轮询中的流量</a></li>
<li><a href="../zh-CN427293/index.html">JavaScript设计模式</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>