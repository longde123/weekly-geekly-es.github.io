<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüé§ ‚õ≥Ô∏è üçÅ Beberapa Tips Sudut üçΩÔ∏è üöô üï∫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Waktu yang cukup telah berlalu sejak rilis Angular yang diperbarui. Saat ini, banyak proyek telah selesai. Dari "memulai" banyak pengembang telah pind...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Beberapa Tips Sudut</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425959/"><p>  Waktu yang cukup telah berlalu sejak rilis Angular yang diperbarui.  Saat ini, banyak proyek telah selesai.  Dari "memulai" banyak pengembang telah pindah ke penggunaan yang berarti dari kerangka kerja ini, kemampuannya, dan belajar cara melewati jebakan.  Setiap pengembang dan / atau tim telah membentuk panduan gaya dan praktik terbaik mereka sendiri, atau mereka menggunakan yang lain.  Tetapi pada saat yang sama, Anda sering harus berurusan dengan banyak kode Angular, yang tidak menggunakan banyak fitur dari kerangka kerja ini dan / atau ditulis dalam gaya AngularJS. </p><br><p>  Artikel ini menyajikan beberapa fitur dan fitur menggunakan kerangka Angular, yang, menurut pendapat sederhana penulis, tidak tercakup secara memadai dalam manual atau tidak digunakan oleh pengembang. <a name="habracut"></a>  Artikel ini membahas penggunaan permintaan HTTP "Interceptors", penggunaan Route Guard untuk membatasi akses ke pengguna.  Beberapa rekomendasi untuk menggunakan RxJS dan mengelola status aplikasi diberikan.  Juga disajikan beberapa rekomendasi tentang desain kode proyek, yang mungkin akan membuat kode proyek lebih bersih dan lebih mudah dipahami.  Penulis berharap artikel ini bermanfaat tidak hanya bagi pengembang yang baru mulai berkenalan dengan Angular, tetapi juga bagi pengembang yang berpengalaman. </p><br><h2 id="rabota-s-http">  Bekerja dengan HTTP </h2><br><p>  Pembangunan aplikasi Web klien apa pun dilakukan berdasarkan permintaan HTTP ke server.  Bagian ini membahas beberapa fitur dari kerangka Angular untuk bekerja dengan permintaan HTTP. </p><br><h3 id="ispolzuem-interceptors">  Menggunakan Interceptor </h3><br><p>  Dalam beberapa kasus, mungkin perlu memodifikasi permintaan sebelum mencapai server.  Atau Anda perlu mengubah setiap jawaban.  Dimulai dengan Angular 4.3, HttpClient baru telah dirilis.  Itu menambahkan kemampuan untuk mencegat permintaan menggunakan pencegat (Ya, mereka akhirnya dikembalikan hanya dalam versi 4.3!, Ini adalah salah satu fitur yang hilang dari AngularJs yang diharapkan tidak bermigrasi ke Angular).  Ini adalah semacam middleware antara http-api dan permintaan aktual. </p><br><p>  Satu kasus penggunaan umum mungkin otentikasi.  Untuk mendapatkan respons dari server, Anda sering perlu menambahkan semacam mekanisme otentikasi ke permintaan.  Tugas ini menggunakan pencegat diselesaikan cukup sederhana: </p><br><pre><code class="hljs actionscript"><span class="hljs-meta"><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> { Injectable } from "@angular/core";</span></span> <span class="hljs-meta"><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> { Observable } from "rxjs/Observable";</span></span> <span class="hljs-meta"><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> { HttpEvent, HttpInterceptor, HttpHandler, HttpRequest } from @angular/common/http";</span></span> @Injectable() export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JWTInterceptor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpInterceptor</span></span></span><span class="hljs-class"> </span></span>{ intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; { req = req.clone({ setHeaders: { authorization: localStorage.getItem(<span class="hljs-string"><span class="hljs-string">"token"</span></span>) } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next.handle(req); } }</code> </pre> <br><p>  Karena aplikasi dapat memiliki beberapa pencegat, mereka disusun dalam sebuah rantai.  Elemen pertama disebut dengan kerangka Angular itu sendiri.  Selanjutnya, kami bertanggung jawab untuk mengirimkan permintaan ke pencegat berikutnya.  Untuk melakukan ini, kami memanggil metode pegangan elemen berikutnya dalam rantai segera setelah kami selesai.  Kami menghubungkan interceptor: </p><br><pre> <code class="hljs powershell">import { BrowserModule } from <span class="hljs-string"><span class="hljs-string">"@angular/platform-browser"</span></span>; import { NgModule } from <span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>; import { AppComponent } from <span class="hljs-string"><span class="hljs-string">"./app.component"</span></span>; import { HttpClientModule } from <span class="hljs-string"><span class="hljs-string">"@angular/common/http"</span></span>; import { HTTP_INTERCEPTORS } from <span class="hljs-string"><span class="hljs-string">"@angular/common/http"</span></span>; @NgModule({ declarations: [<span class="hljs-type"><span class="hljs-type">AppComponent</span></span>], imports: [<span class="hljs-type"><span class="hljs-type">BrowserModule</span></span>, <span class="hljs-type"><span class="hljs-type">HttpClientModule</span></span>], providers: [ { <span class="hljs-type"><span class="hljs-type">provide</span></span>: <span class="hljs-type"><span class="hljs-type">HTTP_INTERCEPTORS</span></span>, <span class="hljs-type"><span class="hljs-type">useClass</span></span>: <span class="hljs-type"><span class="hljs-type">JWTInterceptor</span></span>, <span class="hljs-type"><span class="hljs-type">multi</span></span>: <span class="hljs-type"><span class="hljs-type">true</span></span> } ], bootstrap: [<span class="hljs-type"><span class="hljs-type">AppComponent</span></span>] }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span></span> {}</code> </pre> <br><p>  Seperti yang Anda lihat, koneksi dan implementasi interceptor cukup sederhana. </p><br><h3 id="otslezhivanie-progressa">  Pelacakan kemajuan </h3><br><p>  Salah satu fitur dari <code>HttpClient</code> adalah kemampuan untuk melacak kemajuan permintaan.  Misalnya, jika Anda perlu mengunduh file besar, maka Anda mungkin ingin melaporkan perkembangan unduhan ke pengguna.  Untuk mendapatkan kemajuan, Anda harus mengatur properti <code>reportProgress</code> dari objek <code>HttpRequest</code> menjadi <code>true</code> .  Contoh layanan yang mengimplementasikan pendekatan ini: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"rxjs/Observable"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { HttpClient } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/common/http"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Injectable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { HttpRequest } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/common/http"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Subject } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"rxjs/Subject"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { HttpEventType } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/common/http"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { HttpResponse } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/common/http"</span></span>; @Injectable() <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileUploadService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private http: HttpClient) {} public post(url: string, <span class="hljs-attr"><span class="hljs-attr">file</span></span>: File): Observable&lt;number&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subject&lt;number&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> req = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpRequest(<span class="hljs-string"><span class="hljs-string">"POST"</span></span>, url, file, { <span class="hljs-attr"><span class="hljs-attr">reportProgress</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient.request(req).subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event.type === HttpEventType.UploadProgress) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> percent = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round((<span class="hljs-number"><span class="hljs-number">100</span></span> * event.loaded) / event.total); subject.next(percent); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> HttpResponse) { subject.complete(); } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> subject.asObservable(); } }</code> </pre> <br><p>  Metode posting mengembalikan <code>Observable</code> yang mewakili kemajuan pengunduhan.  Yang diperlukan sekarang adalah menampilkan progres pemuatan di dalam komponen. </p><br><h2 id="marshrutizaciya-ispolzuem-route-guard">  Routing  Menggunakan Route Guard </h2><br><p>  Routing memungkinkan Anda memetakan permintaan aplikasi ke sumber daya tertentu dalam aplikasi.  Cukup sering perlu untuk memecahkan masalah membatasi visibilitas jalur di mana komponen tertentu berada, tergantung pada beberapa kondisi.  Dalam kasus ini, Angular memiliki mekanisme pembatasan transisi.  Sebagai contoh, ada layanan yang akan menerapkan penjaga rute.  Misalkan dalam aplikasi otentikasi pengguna diimplementasikan menggunakan JWT.  Versi layanan yang disederhanakan yang memeriksa apakah pengguna berwenang dapat direpresentasikan sebagai: </p><br><pre> <code class="hljs java"><span class="hljs-meta"><span class="hljs-meta">@Injectable</span></span>() export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthService</span></span></span><span class="hljs-class"> </span></span>{ constructor(<span class="hljs-keyword"><span class="hljs-keyword">public</span></span> jwtHelper: JwtHelperService) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAuthenticated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> token = localStorage.getItem(<span class="hljs-string"><span class="hljs-string">"token"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//        return !this.jwtHelper.isTokenExpired(token); } }</span></span></code> </pre> <br><p>  Untuk menerapkan penjaga rute, Anda harus mengimplementasikan antarmuka <code>CanActivate</code> , yang terdiri dari satu fungsi <code>canActivate</code> . </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Injectable()</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthGuardService</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CanActivate</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">public</span></span> auth: AuthService, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> router: Router) {} canActivate(): boolean { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.auth.isAuthenticated()) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.router.navigate([<span class="hljs-string"><span class="hljs-string">"login"</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  Implementasi <code>AuthGuardService</code> menggunakan <code>AuthGuardService</code> dijelaskan di atas untuk memverifikasi otorisasi pengguna.  Metode <code>canActivate</code> mengembalikan nilai boolean yang dapat digunakan dalam kondisi aktivasi rute. </p><br><p>  Sekarang kita bisa menerapkan Penjaga Rute yang dibuat untuk rute atau jalur apa pun.  Untuk melakukan ini, ketika mendeklarasikan <code>Routes</code> kami menentukan layanan kami, yang mewarisi antarmuka <code>CanActivate</code> , di bagian <code>canActivate</code> : </p><br><pre> <code class="hljs powershell">export const ROUTES: Routes = [ { <span class="hljs-type"><span class="hljs-type">path</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-type"><span class="hljs-type">component</span></span>: <span class="hljs-type"><span class="hljs-type">HomeComponent</span></span> }, { <span class="hljs-type"><span class="hljs-type">path</span></span>: <span class="hljs-string"><span class="hljs-string">"profile"</span></span>, <span class="hljs-type"><span class="hljs-type">component</span></span>: <span class="hljs-type"><span class="hljs-type">UserComponent</span></span>, <span class="hljs-type"><span class="hljs-type">canActivate</span></span>: [<span class="hljs-type"><span class="hljs-type">AuthGuardService</span></span>] }, { <span class="hljs-type"><span class="hljs-type">path</span></span>: <span class="hljs-string"><span class="hljs-string">"**"</span></span>, <span class="hljs-type"><span class="hljs-type">redirectTo</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } ];</code> </pre> <br><p>  Dalam kasus ini, rute <code>/profile</code> memiliki nilai konfigurasi opsional <code>canActivate</code> .  <code>AuthGuard</code> dijelaskan sebelumnya dilewatkan sebagai argumen untuk properti <code>canActivate</code> ini.  Selanjutnya, metode <code>canActivate</code> akan dipanggil setiap kali seseorang mencoba mengakses jalur <code>/profile</code> .  Jika pengguna diotorisasi, ia akan mendapatkan akses ke jalur <code>/profile</code> , jika tidak ia akan diarahkan ke jalur <code>/login</code> . </p><br><p>  Anda harus menyadari bahwa <code>canActivate</code> masih memungkinkan Anda untuk mengaktifkan komponen di jalur ini, tetapi tidak memungkinkan Anda untuk beralih ke komponen itu.  Jika Anda perlu melindungi aktivasi dan pemuatan komponen, maka untuk kasus ini kita dapat menggunakan <code>canLoad</code> .  Implementasi <code>CanLoad</code> dapat dilakukan dengan analogi. </p><br><h2 id="gotovim-rxjs">  Memasak RxJS </h2><br><p>  Angular dibangun di atas RxJS.  RxJS adalah perpustakaan untuk bekerja dengan aliran data asinkron dan berbasis peristiwa menggunakan urutan yang dapat diamati.  RxJS adalah implementasi JavaScript dari ReactiveX API.  Sebagian besar, kesalahan yang terjadi ketika bekerja dengan perpustakaan ini terkait dengan pengetahuan dasar tentang penerapannya. </p><br><h3 id="ispolzuem-async-vmesto-podpisyvaniya-na-sobytiya">  Menggunakan async alih-alih mendaftar untuk acara </h3><br><p>  Sejumlah besar pengembang yang baru saja menggunakan kerangka Angular menggunakan fungsi <code>subscribe</code> <code>Observable</code> untuk menerima dan menyimpan data dalam komponen: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"my-component"</span></span></span><span class="hljs-meta">, template: ` &lt;span&gt;{{localData.name}} : {{localData.value}}&lt;/span&gt;` })</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span></span>{ localData; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(http: HttpClient) { http.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"api/data"</span></span>).subscribe(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.localData = <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>; }); } }</code> </pre> <br><p>  Sebagai gantinya, kita dapat berlangganan melalui templat menggunakan pipa async: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"my-component"</span></span></span><span class="hljs-meta">, template: ` &lt;p&gt;{{data.name | async}} : {{data.value | async}}&lt;/p&gt;` })</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(http: HttpClient) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = http.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"api/data"</span></span>); } }</code> </pre> <br><p>  Dengan berlangganan melalui templat, kami menghindari kebocoran memori karena Angular secara otomatis berhenti berlangganan dari <code>Observable</code> ketika komponen rusak.  Dalam hal ini, untuk permintaan HTTP, menggunakan pipa async secara praktis tidak memberikan manfaat apa pun, kecuali satu - async akan membatalkan permintaan jika data tidak lagi diperlukan, dan tidak akan menyelesaikan pemrosesan permintaan. </p><br><p>  Banyak fitur <code>Observables</code> tidak digunakan saat berlangganan secara manual.  Perilaku yang dapat <code>Observables</code> dapat diperpanjang dengan mengulangi (misalnya, coba lagi dalam permintaan http), pembaruan berbasis waktu, atau pra-caching. </p><br><h3 id="ispolzuem--dlya-oboznacheniya-observables">  Gunakan <code>$</code> untuk menunjukkan yang bisa diamati </h3><br><p>  Paragraf berikutnya terkait dengan desain kode sumber aplikasi dan mengikuti dari paragraf sebelumnya.  Untuk membedakan <code>Observable</code> dari variabel sederhana, cukup sering Anda dapat mendengar saran untuk menggunakan tanda " <code>$</code> " atas nama variabel atau bidang.  Trik sederhana ini akan menghilangkan kebingungan dalam variabel saat menggunakan async. </p><br><pre> <code class="hljs cs">import { Component } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>; import { Observable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"rxjs/Rx"</span></span>; import { UserClient } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../services/user.client"</span></span>; import { User } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../services/user"</span></span>; @Component({ selector: <span class="hljs-string"><span class="hljs-string">"user-list"</span></span>, template: ` &lt;ul <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"user_list"</span></span> *ngIf=<span class="hljs-string"><span class="hljs-string">"(users$ | async).length"</span></span>&gt; &lt;li <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"user"</span></span> *ngFor=<span class="hljs-string"><span class="hljs-string">"let user of users$ | async"</span></span>&gt; {{ user.name }} - {{ user.birth_date }} &lt;/li&gt; &lt;/ul&gt;` }) export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">UserList</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> users$: Observable&lt;User[]&gt;; constructor(<span class="hljs-keyword"><span class="hljs-keyword">public</span></span> userClient: UserClient) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ngOnInit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.users$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client.getUsers(); } }</code> </pre> <br><h3 id="kogda-nuzhno-otpisyvatsya-unsubscribe">  Kapan berhenti berlangganan (berhenti berlangganan) </h3><br><p>  Pertanyaan paling umum yang dimiliki pengembang saat mengenal Angular secara singkat adalah kapan Anda masih harus berhenti berlangganan, dan kapan tidak.  Untuk menjawab pertanyaan ini, Anda harus memutuskan jenis <code>Observable</code> yang saat ini digunakan.  Dalam Angular ada 2 jenis yang <code>Observable</code> - terbatas dan tak terbatas, beberapa menghasilkan terbatas, yang lain, masing-masing, jumlah nilai tak terbatas. </p><br><p>  <code>Http</code> <code>Observable</code> kompak, dan pendengar / pendengar acara DOM yang tak terbatas <code>Observable</code> . </p><br><p>  Jika berlangganan nilai-nilai infinite <code>Observable</code> dilakukan secara manual (tanpa menggunakan pipa async), maka balasan harus dilakukan tanpa gagal.  Jika kita berlangganan secara manual ke Observable yang terbatas, maka tidak perlu berhenti berlangganan, RxJS akan mengurus ini.  Dalam hal Compact <code>Observables</code> kita dapat berhenti berlangganan jika <code>Observable</code> memiliki waktu eksekusi yang lebih lama daripada yang diperlukan, misalnya, beberapa permintaan HTTP. </p><br><p>  Contoh <code>Observables</code> ringkas: </p><br><pre> <code class="hljs kotlin">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> http: HttpClient) { } ngOnInit() { Observable.timer(<span class="hljs-number"><span class="hljs-number">1000</span></span>).subscribe(...); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.http.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"http://api.com"</span></span>).subscribe(...); } }</code> </pre> <br><p>  Contoh Pengamatan Tak Terbatas </p><br><pre> <code class="hljs kotlin">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> element : ElementRef) { } interval: Subscription; click: Subscription; ngOnInit() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.interval = Observable.interval(<span class="hljs-number"><span class="hljs-number">1000</span></span>).subscribe(...); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.click = Observable.fromEvent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element.nativeElement, <span class="hljs-string"><span class="hljs-string">"click"</span></span>).subscribe(...); } ngOnDestroy() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.interval.unsubscribe(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.click.unsubscribe(); } }</code> </pre> <br><p>  Di bawah, secara lebih rinci adalah kasus di mana Anda harus berhenti berlangganan </p><br><ol><li>  Anda harus berhenti berlangganan dari formulir dan dari kontrol individual yang telah Anda langgani: </li></ol><br><pre> <code class="hljs kotlin">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{ ngOnInit() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.form = new FormGroup({...}); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.valueChangesSubs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.form.valueChanges.subscribe(...); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.statusChangesSubs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.form.statusChanges.subscribe(...); } ngOnDestroy() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.valueChangesSubs.unsubscribe(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.statusChangesSubs.unsubscribe(); } }</code> </pre> <br><ol><li>  Router  Menurut dokumentasi, Angular harus berhenti berlangganan sendiri, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">namun ini tidak terjadi</a> .  Karena itu, untuk menghindari masalah lebih lanjut, kami menulis sendiri: </li></ol><br><pre> <code class="hljs kotlin">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> route: ActivatedRoute, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> router: Router) { } ngOnInit() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.route.params.subscribe(..); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.route.queryParams.subscribe(...); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.route.fragment.subscribe(...); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.route.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.subscribe(...); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.route.url.subscribe(..); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.router.events.subscribe(...); } ngOnDestroy() { <span class="hljs-comment"><span class="hljs-comment">//        observables } }</span></span></code> </pre> <br><ol><li>  Urutan tanpa akhir.  Contohnya adalah urutan yang dibuat menggunakan <code>interva()</code> atau pendengar acara <code>(fromEvent())</code> : </li></ol><br><pre> <code class="hljs kotlin">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> element : ElementRef) { } interval: Subscription; click: Subscription; ngOnInit() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.intervalSubs = Observable.interval(<span class="hljs-number"><span class="hljs-number">1000</span></span>).subscribe(...); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.clickSubs = Observable.fromEvent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element.nativeElement, <span class="hljs-string"><span class="hljs-string">"click"</span></span>).subscribe(...); } ngOnDestroy() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.intervalSubs.unsubscribe(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.clickSubs.unsubscribe(); } }</code> </pre> <br><h3 id="takeuntil-i-takewhile">  takeUntil dan takeWhile </h3><br><p>  Untuk menyederhanakan pekerjaan dengan <code>Observables</code> tak terbatas di RxJS, ada dua fungsi yang mudah digunakan - <code>takeUntil</code> dan <code>takeWhile</code> .  Mereka melakukan tindakan yang sama - berhenti berlangganan dari <code>Observable</code> pada akhir kondisi tertentu, perbedaannya hanya pada nilai yang diterima.  <code>takeWhile</code> menerima <code>boolean</code> , dan <code>takeUntil</code> <code>Subject</code> . <br>  Contoh <code>takeWhile</code> : </p><br><pre> <code class="hljs java">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnDestroy</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnInit</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> user: User; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> alive: <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ngOnInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.userService .authenticate(email, password) .takeWhile(() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.alive) .subscribe(user =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.user = user; }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ngOnDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.alive = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br><p>  Dalam hal ini, ketika bendera <code>alive</code> diubah, <code>Observable</code> akan berhenti berlangganan.  Dalam contoh ini, berhenti berlangganan ketika komponen dihancurkan. <br>  <code>takeUntil</code> contoh: </p><br><pre> <code class="hljs java">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnDestroy</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnInit</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> user: User; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> unsubscribe: Subject&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subject(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ngOnInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.userService.authenticate(email, password) .takeUntil(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.unsubscribe) .subscribe(user =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.user = user; }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ngOnDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.unsubscribe.next(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.unsubscribe.complete(); } }</code> </pre> <br><p>  Dalam hal ini, untuk berhenti berlangganan dari <code>Observable</code> kami melaporkan bahwa <code>subject</code> mengambil nilai berikutnya dan melengkapinya. </p><br><p>  Menggunakan fungsi-fungsi ini akan menghindari kebocoran dan menyederhanakan pekerjaan dengan berhenti berlangganan data.  Fungsi mana yang digunakan?  Jawaban atas pertanyaan ini harus dipandu oleh preferensi pribadi dan persyaratan saat ini. </p><br><h2 id="upravlenie-sostoyaniem-v-angular-prilozheniyah-ngrxstore">  Manajemen negara dalam aplikasi Angular, @ ngrx / store </h2><br><p>  Cukup sering, ketika mengembangkan aplikasi yang kompleks, kita dihadapkan dengan kebutuhan untuk menyimpan keadaan dan menanggapi perubahannya.  Ada banyak perpustakaan untuk aplikasi yang dikembangkan pada kerangka kerja ReactJs yang memungkinkan Anda untuk mengontrol keadaan aplikasi dan merespons perubahannya - Fluks, Redux, Redux-saga, dll.  Untuk aplikasi Angular, ada wadah negara berbasis RxJS yang terinspirasi oleh Redux - @ ngrx / store.  Pengelolaan kondisi aplikasi yang tepat akan menyelamatkan pengembang dari banyak masalah saat aplikasi diperluas. </p><br><p>  Mengapa Redux <br>  Redux memposisikan dirinya sebagai wadah keadaan yang dapat diprediksi untuk aplikasi JavaScript.  Redux terinspirasi oleh Flux dan Elm. </p><br><p>  Redux menyarankan untuk memikirkan aplikasi sebagai keadaan awal yang dapat dimodifikasi dengan serangkaian tindakan, yang dapat menjadi pendekatan yang baik untuk membangun aplikasi web yang kompleks. </p><br><p>  Redux tidak terkait dengan kerangka kerja tertentu, dan meskipun dikembangkan untuk Bereaksi, ia dapat digunakan dengan Angular atau jQuery. </p><br><p>  Postulat utama Redux: </p><br><ul><li>  satu repositori untuk seluruh status aplikasi </li><li>  negara hanya baca </li><li>  perubahan dilakukan oleh fungsi "murni", yang tunduk pada persyaratan berikut: </li><li>  tidak boleh membuat panggilan eksternal melalui jaringan atau database; </li><li>  mengembalikan nilai yang hanya bergantung pada parameter yang diteruskan; </li><li>  argumen tidak dapat diubah, mis.  fungsi seharusnya tidak mengubahnya; </li><li>  memanggil fungsi murni dengan argumen yang sama selalu menghasilkan hasil yang sama; </li></ul><br><p>  Contoh fungsi manajemen negara: </p><br><pre> <code class="hljs julia">// counter.ts <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ActionReducer, Action } from <span class="hljs-string"><span class="hljs-string">"@ngrx/store"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> INCREMENT = <span class="hljs-string"><span class="hljs-string">"INCREMENT"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DECREMENT = <span class="hljs-string"><span class="hljs-string">"DECREMENT"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RESET = <span class="hljs-string"><span class="hljs-string">"RESET"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> counterReducer(state: number = <span class="hljs-number"><span class="hljs-number">0</span></span>, action: Action) { switch (action.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>) { case INCREMENT: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state + <span class="hljs-number"><span class="hljs-number">1</span></span>; case DECREMENT: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state - <span class="hljs-number"><span class="hljs-number">1</span></span>; case RESET: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; } }</code> </pre> <br><p>  Reducer diimpor dalam modul utama aplikasi dan menggunakan fungsi <code>StoreModule.provideStore(reducers)</code> kami sediakan untuk injector Angular: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> app.<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.ts <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { NgModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { StoreModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@ngrx/store"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { counterReducer } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./counter"</span></span>; @NgModule({ imports: [ BrowserModule, StoreModule.provideStore({ counter: counterReducer }) ] }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span><span class="hljs-class"> { }</span></span></code> </pre> <br><p>  Selanjutnya, layanan <code>Store</code> diperkenalkan ke dalam komponen dan layanan yang diperlukan.  Fungsi store.select () digunakan untuk memilih status "slice": </p><br><pre> <code class="hljs django"><span class="xml"><span class="xml">// app.component.ts ... interface AppState { counter: number; } @Component({ selector: "my-app", template: ` </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span></span><span class="xml"><span class="hljs-tag">)=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"increment()"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Increment</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Current Count: </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ counter | async }}</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span></span><span class="xml"><span class="hljs-tag">)=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"decrement()"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Decrement</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span></span><span class="xml"><span class="hljs-tag">)=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"reset()"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Reset Counter</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">` }) class AppComponent { counter: Observable</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">number</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">; constructor(private store: Store</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">AppState</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">) { this.counter = store.select("counter"); } increment() { this.store.dispatch({ type: INCREMENT }); } decrement() { this.store.dispatch({ type: DECREMENT }); } reset() { this.store.dispatch({ type: RESET }); } }</span></span></code> </pre> <br><h3 id="ngrxrouter-store">  @ ngrx / router-store </h3><br><p>  Dalam beberapa kasus, akan lebih mudah untuk mengaitkan keadaan aplikasi dengan rute aplikasi saat ini.  Untuk kasus-kasus ini, modul @ ngrx / router-store ada.  Agar aplikasi dapat menggunakan <code>router-store</code> untuk menghemat keadaan, cukup sambungkan <code>routerReducer</code> dan tambahkan panggilan ke <code>RouterStoreModule.connectRoute</code> di modul utama aplikasi: </p><br><pre> <code class="hljs powershell">import { StoreModule } from <span class="hljs-string"><span class="hljs-string">"@ngrx/store"</span></span>; import { routerReducer, RouterStoreModule } from <span class="hljs-string"><span class="hljs-string">"@ngrx/router-store"</span></span>; @NgModule({ imports: [ <span class="hljs-type"><span class="hljs-type">BrowserModule</span></span>, <span class="hljs-type"><span class="hljs-type">StoreModule.provideStore</span></span>({ <span class="hljs-type"><span class="hljs-type">router</span></span>: <span class="hljs-type"><span class="hljs-type">routerReducer</span></span> }), <span class="hljs-type"><span class="hljs-type">RouterStoreModule.connectRouter</span></span>() ], bootstrap: [<span class="hljs-type"><span class="hljs-type">AppComponent</span></span>] }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span></span> { }</code> </pre> <br><p>  Sekarang tambahkan <code>RouterState</code> ke status utama aplikasi: </p><br><pre> <code class="hljs cs">import { RouterState } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@ngrx/router-store"</span></span>; export <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">AppState</span></span> { ... router: RouterState; };</code> </pre> <br><p>  Selain itu, kami dapat menunjukkan status awal aplikasi saat mendeklarasikan toko: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">StoreModule</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.provideStore</span></span>( { <span class="hljs-attribute"><span class="hljs-attribute">router</span></span>: routerReducer }, { <span class="hljs-attribute"><span class="hljs-attribute">router</span></span>: { path: window.location.pathname + window.location.search } } );</code> </pre> <br><p>  Tindakan yang didukung: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { go, replace, <span class="hljs-keyword"><span class="hljs-keyword">search</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">show</span></span>, back, forward } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "@ngrx/router-store"; //      store.dispatch(go(["/path", { routeParam: <span class="hljs-number"><span class="hljs-number">1</span></span> }], { query: "string" })); //        store.dispatch(replace(["/path"], { query: "string" })); //        store.dispatch(<span class="hljs-keyword"><span class="hljs-keyword">show</span></span>(["/path"], { query: "string" })); //       store.dispatch(<span class="hljs-keyword"><span class="hljs-keyword">search</span></span>({ query: "string" })); //   store.dispatch(back()); //   store.dispatch(forward());</code> </pre> <br><p>  UPD: Komentar menyarankan bahwa tindakan ini tidak akan tersedia di @ngrx versi baru, untuk versi baru <a href="">https://github.com/ngrx/platform/blob/master/MIGRATION.md#ngrxrouter-store</a> </p><br><p>  Menggunakan wadah negara akan menghilangkan banyak masalah saat mengembangkan aplikasi yang kompleks.  Namun, penting untuk membuat manajemen negara sesederhana mungkin.  Cukup sering, kita harus berurusan dengan aplikasi di mana ada negara bersarang berlebihan, yang hanya mempersulit pemahaman aplikasi. </p><br><h2 id="organizaciya-koda">  Organisasi Kode </h2><br><h3 id="izbavlyaemsya-ot-gromozdkih-vyrazheniy-v-import">  Menyingkirkan ekspresi besar di <code>import</code> </h3><br><p>  Banyak pengembang menyadari situasi di mana ekspresi dalam <code>import</code> agak rumit.  Ini terutama terlihat dalam aplikasi besar di mana ada banyak perpustakaan yang dapat digunakan kembali. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { SomeService } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "../../../core/subpackage1/subpackage2/some.service";</code> </pre> <br><p>  Apa lagi yang buruk dalam kode ini?  Jika Anda perlu mentransfer komponen kami ke direktori lain, ekspresi dalam <code>import</code> tidak akan valid. </p><br><p>  Dalam hal ini, menggunakan alias akan membuat kami dapat melepaskan diri dari ekspresi besar di <code>import</code> dan membuat kode kami jauh lebih bersih.  Untuk menyiapkan proyek untuk menggunakan alias, Anda perlu menambahkan properti baseUrl dan path di <code>tsconfig.json</code> : </p><br><pre> <code class="hljs perl">/ tsconfig.json { <span class="hljs-string"><span class="hljs-string">"compilerOptions"</span></span>: { ... <span class="hljs-string"><span class="hljs-string">"baseUrl"</span></span>: <span class="hljs-string"><span class="hljs-string">"src"</span></span>, <span class="hljs-string"><span class="hljs-string">"paths"</span></span>: { <span class="hljs-string"><span class="hljs-string">"@app/*"</span></span>: [<span class="hljs-string"><span class="hljs-string">"app/*"</span></span>], <span class="hljs-string"><span class="hljs-string">"@env/*"</span></span>: [<span class="hljs-string"><span class="hljs-string">"environments/*"</span></span>] } } }</code> </pre> <br><p>  Dengan perubahan ini, cukup mudah untuk mengelola plug-in: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Component, OnInit } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"rxjs/Observable"</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { SomeService } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@app/core"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { environment } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@env/environment"</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { LocalService } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./local.service"</span></span>; @Component({ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExampleComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnInit</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( private someService: SomeService, private localService: LocalService ) { } }</code> </pre> <br><p>  Dalam contoh ini, <code>SomeService</code> diimpor langsung dari <code>@app/core</code> bukan ekspresi besar (mis. <code>@app/core/some-package/some.service</code> ).  Ini dimungkinkan berkat re-ekspor komponen publik di file <code>index.ts</code> utama.  Dianjurkan untuk membuat file <code>index.ts</code> untuk setiap paket di mana Anda perlu mengekspor kembali semua modul publik: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> index.ts <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./core.module"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./auth/auth.service"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./user/user.service"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./some-service/some.service"</span></span>;</code> </pre> <br><h3 id="core-shared-i-feature-moduli">  Modul Inti, Bersama, dan Fitur </h3><br><p>  Untuk manajemen komponen aplikasi yang lebih fleksibel, cukup sering direkomendasikan dalam literatur dan berbagai sumber daya Internet untuk menyebarkan visibilitas komponennya.  Dalam hal ini, pengelolaan komponen aplikasi disederhanakan.  Pemisahan berikut ini paling umum digunakan: Modul Core, Shared, dan Feature. </p><br><h4 id="coremodule">  Coremodule </h4><br><p>  Tujuan utama CoreModule adalah untuk menggambarkan layanan yang akan memiliki satu contoh untuk seluruh aplikasi (mis., Menerapkan pola tunggal).  Ini sering termasuk layanan otorisasi atau layanan untuk mendapatkan informasi pengguna.  Contoh CoreModule: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { NgModule, Optional, SkipSelf } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { CommonModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/common"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { HttpClientModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/common/http"</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { SomeSingletonService } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./some-singleton/some-singleton.service"</span></span>; @NgModule({ <span class="hljs-attr"><span class="hljs-attr">imports</span></span>: [CommonModule, HttpClientModule], <span class="hljs-attr"><span class="hljs-attr">declarations</span></span>: [], <span class="hljs-attr"><span class="hljs-attr">providers</span></span>: [SomeSingletonService] }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoreModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   CoreModule    NgModule the AppModule */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( @Optional() @SkipSelf() parentModule: CoreModule ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentModule) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"CoreModule is already loaded. Import only in AppModule"</span></span>); } } }</code> </pre> <br><h4 id="sharedmodule">  Sharedmodule </h4><br><p>  Modul ini menjelaskan komponen-komponen sederhana.  Komponen-komponen ini tidak mengimpor atau menyuntikkan dependensi dari modul lain ke dalam konstruktornya.  Mereka harus menerima semua data melalui atribut dalam templat komponen.  <code>SharedModule</code> tidak memiliki ketergantungan pada sisa aplikasi kami, juga merupakan tempat yang ideal untuk mengimpor dan mengekspor kembali komponen Bahan Sudut atau pustaka UI lainnya. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { NgModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { CommonModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/common"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { FormsModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/forms"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { MdButtonModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/material"</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { SomeCustomComponent } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./some-custom/some-custom.component"</span></span>; @NgModule({ <span class="hljs-attr"><span class="hljs-attr">imports</span></span>: [CommonModule, FormsModule, MdButtonModule], <span class="hljs-attr"><span class="hljs-attr">declarations</span></span>: [SomeCustomComponent], <span class="hljs-attr"><span class="hljs-attr">exports</span></span>: [ <span class="hljs-comment"><span class="hljs-comment">/*  Angular Material*/</span></span> CommonModule, FormsModule, MdButtonModule, <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> SomeCustomComponent ] }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SharedModule</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br><h4 id="featuremodule">  Kode fitur </h4><br><p>  Di sini Anda dapat mengulangi panduan gaya Angular.  FeatureModule terpisah dibuat untuk setiap fungsi aplikasi independen.  FeatureModule harus mengimpor layanan hanya dari <code>CoreModule</code> .  Jika beberapa modul perlu mengimpor layanan dari modul lain, ada kemungkinan bahwa layanan ini harus dipindahkan ke <code>CoreModule</code> . </p><br><p>  Dalam beberapa kasus, ada kebutuhan untuk menggunakan layanan hanya oleh beberapa modul dan tidak perlu mengekspornya ke <code>CoreModule</code> .  Dalam hal ini, Anda dapat membuat <code>SharedModule</code> khusus, yang hanya akan digunakan dalam modul ini. <br>  ,     ‚Äî   ,     -  ,    ,  <code>CoreModule</code>  ,  <code>SharedModule</code> . </p><br><p>        ,     .    ,   .    ,   ,             . </p><br><h3 id="spisok-literatury">  Referensi </h3><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/ngrx/store</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://stepansuvorov.com/blog/2017/06/angular-rxjs-unsubscribe-or-not-unsubscribe/</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://medium.com/@tomastrajan/6-best-practices-pro-tips-for-angular-cli-better-developer-experience-7b328bc9db81</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://habr.com/post/336280/</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://angular.io/docs</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425959/">https://habr.com/ru/post/id425959/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425947/index.html">Corporate Ratatouille</a></li>
<li><a href="../id425951/index.html">Cara meretas blockchain dan cryptocurrency: 6 serangan sukses ‚Äú51 persen‚Äù</a></li>
<li><a href="../id425953/index.html">Stasiun cuaca di Arduino dari A hingga Z. Bagian 3</a></li>
<li><a href="../id425955/index.html">8 bug iOS 12 beta yang menarik dan bagaimana kami mencarinya</a></li>
<li><a href="../id425957/index.html">Sepeda gas atau pencarian produk aneh (e-commerce)</a></li>
<li><a href="../id425961/index.html">‚ÄúBelajar Spring adalah pelajaran yang tidak masuk akal‚Äù - Josh Long, penginjil utama Spring di dapur interior proyek</a></li>
<li><a href="../id425963/index.html">Stasiun cuaca di Arduino dari A hingga Z. Bagian 4</a></li>
<li><a href="../id425965/index.html">SAP Data Management Suite sebagai kompleks untuk bekerja dengan Big Data di perusahaan</a></li>
<li><a href="../id425967/index.html">Chainsaw Silicon Massacre</a></li>
<li><a href="../id425969/index.html">Bagaimana saya akan menjadi pengembang web ... dan akankah saya?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>