<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéπ üë®‚Äçüëß‚Äçüë¶ üßòüèª Gonkey - Microservice Testing Tool üò§ üåØ üëå</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gonkey testet unsere Microservices in Lamoda, und wir dachten, er k√∂nnte auch Ihre testen, also haben wir sie in Open Source ver√∂ffentlicht . Wenn die...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gonkey - Microservice Testing Tool</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lamoda/blog/463301/"><p>  Gonkey testet unsere Microservices in Lamoda, und wir dachten, er k√∂nnte auch Ihre testen, also haben wir sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Open Source ver√∂ffentlicht</a> .  Wenn die Funktionalit√§t Ihrer Dienste haupts√§chlich √ºber die API implementiert wird und JSON f√ºr den Datenaustausch verwendet wird, ist Gonkey mit ziemlicher Sicherheit f√ºr Sie geeignet. </p><br><p><img src="https://habrastorage.org/webt/dz/ie/4z/dzie4z9vcjyrtf_n3mhfdistusm.jpeg" alt="Bild"></p><br><p>  Im Folgenden werde ich ausf√ºhrlicher darauf eingehen und anhand konkreter Beispiele zeigen, wie man es benutzt. </p><a name="habracut"></a><br><h3 id="kak-rodilsya-gonkey">  Wie Gonkey geboren wurde </h3><br><p>  Wir haben mehr als hundert Mikrodienste, von denen jeder eine bestimmte Aufgabe l√∂st.  Alle Dienste haben eine API.  Nat√ºrlich sind einige von ihnen auch eine Benutzeroberfl√§che, aber ihre Hauptaufgabe besteht darin, eine Datenquelle f√ºr eine Site, mobile Anwendungen oder andere interne Dienste zu sein und daher eine <em>Softwareschnittstelle bereitzustellen</em> . </p><br><p>  Als wir feststellten, dass es viele Services gab und es dann noch mehr davon geben w√ºrde, entwickelten wir ein internes Dokument, das den Standardansatz f√ºr das API-Design beschreibt, und nahmen Swagger als Beschreibungstool (und schrieben sogar Dienstprogramme zum Generieren von Code basierend auf der Swagger-Spezifikation).  Wenn Sie mehr dar√ºber erfahren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">m√∂chten, lesen</a> Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andrews Vortrag mit Highload ++.</a> </p><br><p>  Der Standardansatz f√ºr das API-Design f√ºhrte nat√ºrlich zur Idee eines Standardansatzes f√ºr das Testen.  Folgendes wollte ich erreichen: </p><br><ol><li>  <em>Testen Sie Dienste √ºber die API</em> , da fast alle Funktionen des Dienstes √ºber diese <em>API</em> implementiert werden </li><li>  <em>Die M√∂glichkeit, den Start von Tests zu automatisieren, um</em> sie in unseren CI / CD-Prozess zu integrieren, wie sie sagen: "Run by Button" </li><li>  <em>Das Schreiben von Tests sollte ver√§u√üerlich sein</em> , das hei√üt, damit nicht nur ein Programmierer Tests schreiben kann, idealerweise eine Person, die mit dem Programmieren nicht vertraut ist. </li></ol><br><p>  Also wurde Gonkey geboren. </p><br><h3 id="itak-chto-zhe-eto">  Was ist das? </h3><br><p> Gonkey ist eine <em>Bibliothek</em> (f√ºr Projekte in Golang) und ein <em>Konsolendienstprogramm</em> (f√ºr Projekte in allen Sprachen und Technologien), mit dem Sie <em>Funktions- und Regressionstests von Diensten durchf√ºhren k√∂nnen,</em> indem Sie gem√§√ü einem vordefinierten Skript auf deren API zugreifen.  Testskripte werden in YAML-Dateien beschrieben. </p><br><p>  Einfach ausgedr√ºckt, Gonkey kann: </p><br><ul><li>  Bombardieren Sie Ihren Dienst mit HTTP-Anfragen und stellen Sie sicher, dass die Antworten wie erwartet sind.  Es wird davon ausgegangen, dass JSON in Anfragen und Antworten verwendet wird, aber h√∂chstwahrscheinlich funktioniert es in einfachen F√§llen mit Antworten in einem anderen Format. </li><li>  Bereiten Sie die Datenbank f√ºr den Test vor, indem Sie sie mit Daten von Fixtures f√ºllen (auch in YAML-Dateien angegeben). </li><li>  Imitieren Sie die Antworten externer Dienste mithilfe von Mocks (diese Funktion ist nur verf√ºgbar, wenn Sie Gonkey als Bibliothek verbinden). </li><li>  Geben Sie der Konsole Testergebnisse oder generieren Sie einen Allure-Bericht. </li></ul><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projekt-Repository</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker-Bild</a> </p><br><h3 id="primer-testirovaniya-servisa-s-gonkey">  Beispiel f√ºr einen Servicetest mit Gonkey </h3><br><p>  Um Sie nicht mit Text zu belasten, m√∂chte ich hier von W√∂rtern zu Taten wechseln und einige APIs testen und dabei erz√§hlen und zeigen, wie Testskripte geschrieben werden. </p><br><p>  Lassen Sie uns einen kleinen Service auf Go skizzieren, der die Arbeit einer Ampel simuliert.  Es speichert die Farbe des aktuellen Signals: rot, gelb oder gr√ºn.  Sie k√∂nnen die aktuelle Signalfarbe abrufen oder √ºber die API eine neue festlegen. </p><br><pre><code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//    const ( lightRed = "red" lightYellow = "yellow" lightGreen = "green" ) //      type trafficLights struct { currentLight string `json:"currentLight"` mutex sync.RWMutex `json:"-"` } //   var lights = trafficLights{ currentLight: lightRed, } func main() { //       http.HandleFunc("/light/get", func(w http.ResponseWriter, r *http.Request) { lights.mutex.RLock() defer lights.mutex.RUnlock() resp, err := json.Marshal(lights) if err != nil { log.Fatal(err) } w.Write(resp) }) //       http.HandleFunc("/light/set", func(w http.ResponseWriter, r *http.Request) { lights.mutex.Lock() defer lights.mutex.Unlock() request, err := ioutil.ReadAll(r.Body) if err != nil { log.Fatal(err) } var newTrafficLights trafficLights if err := json.Unmarshal(request, &amp;newTrafficLights); err != nil { http.Error(w, err.Error(), http.StatusBadRequest) return } if err := validateRequest(&amp;newTrafficLights); err != nil { http.Error(w, err.Error(), http.StatusBadRequest) return } lights = newTrafficLights }) //   () log.Fatal(http.ListenAndServe(":8080", nil)) } func validateRequest(lights *trafficLights) error { if lights.currentLight != lightRed &amp;&amp; lights.currentLight != lightYellow &amp;&amp; lights.currentLight != lightGreen { return fmt.Errorf("incorrect current light: %s", lights.currentLight) } return nil }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der vollst√§ndige Quellcode f√ºr main.go ist hier</a> . </p><br><p>  F√ºhren Sie das Programm aus: </p><br><pre> <code class="plaintext hljs">go run .</code> </pre> <br><p>  Sehr schnell in 15 Minuten skizziert!  Sicherlich hat er sich irgendwo geirrt, also werden wir einen Test schreiben und pr√ºfen. </p><br><p>  Laden Sie Gonkey herunter und f√ºhren Sie es aus: </p><br><pre> <code class="plaintext hljs">mkdir -p tests/cases docker run -it -v $(pwd)/tests:/tests lamoda/gonkey -tests tests/cases -host host.docker.internal:8080</code> </pre> <br><p>  Dieser Befehl startet das Image mit gonkey √ºber das Docker, stellt das Verzeichnis tests / case im Container bereit und startet gonkey mit den Parametern -tests tests / case / -host. </p><br><p>  Wenn Ihnen der Docker-Ansatz nicht gef√§llt, besteht eine Alternative zu einem solchen Befehl darin, Folgendes zu schreiben: </p><br><pre> <code class="plaintext hljs">go get github.com/lamoda/gonkey go run github.com/lamoda/gonkey -tests tests/cases -host localhost:8080</code> </pre> <br><p>  Gestartet und bekam das Ergebnis: </p><br><pre> <code class="plaintext hljs">Failed tests: 0/0</code> </pre> <br><p>  Keine Tests - nichts zu √ºberpr√ºfen.  Schreiben wir den ersten Test.  Erstellen Sie eine Datei tests / case / light_get.yaml mit dem Mindestinhalt: </p><br><pre> <code class="plaintext hljs">- name: WHEN currentLight is requested MUST return red method: GET path: /light/get response: 200: &gt; { "currentLight": "red" }</code> </pre> <br><p>  Auf der ersten Ebene befindet sich eine Liste.  Dies bedeutet, dass wir einen Testfall beschrieben haben, aber es k√∂nnen viele davon in der Datei sein.  Zusammen bilden sie das Testszenario.  Also eine Datei - ein Skript.  Sie k√∂nnen mit Testskripten beliebig viele Dateien erstellen und diese gegebenenfalls in Unterverzeichnissen anordnen. Gonkey liest alle yaml- und yml-Dateien aus dem √ºbertragenen Verzeichnis und ist tiefer rekursiv. </p><br><p>  In der folgenden Datei werden die Details der Anforderung beschrieben, die an den Server gesendet wird: Methode, Pfad.  Noch niedriger ist der Antwortcode (200) und der Antworttext, den wir vom Server erwarten. </p><br><p>  Das vollst√§ndige Dateiformat ist <a href="">in README beschrieben</a> . </p><br><p>  Wieder ausf√ºhren: </p><br><pre> <code class="plaintext hljs">docker run -it -v $(pwd)/tests:/tests lamoda/gonkey -tests tests/cases -host host.docker.internal:8080</code> </pre> <br><p>  Ergebnis: </p><br><pre> <code class="plaintext hljs"> Name: WHEN currentlight is requested MUST return red Request: Method: GET Path: /light/get Query: Body: &lt;no body&gt; Response: Status: 200 OK Body: {} Result: ERRORS! Errors: 1) at path $ values do not match: expected: { "currentLight": "red" } actual: {} Failed tests: 1/1</code> </pre> <br><p>  Fehler!  Eine Struktur mit dem Feld currentLight wurde erwartet und eine leere Struktur zur√ºckgegeben.  Das ist schlecht.  Das erste Problem ist, dass das Ergebnis als Zeichenfolge interpretiert wurde. Dies wird durch die Tatsache angezeigt, dass Gonkey als Problemstelle die gesamte Antwort ohne Details hervorgehoben hat: </p><br><pre> <code class="plaintext hljs"> expected: { "currentLight": "red" }</code> </pre> <br><p>  Der Grund ist einfach: Ich habe vergessen zu schreiben, damit der Dienst in der Antwort den Inhaltstyp application / json angibt.  Wir beheben: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//       http.HandleFunc("/light/get", func(w http.ResponseWriter, r *http.Request) { lights.mutex.RLock() defer lights.mutex.RUnlock() resp, err := json.Marshal(lights) if err != nil { log.Fatal(err) } w.Header().Add("Content-Type", "application/json") // &lt;--  w.Write(resp) })</span></span></code> </pre> <br><p>  Wir starten den Dienst neu und f√ºhren die Tests erneut aus: </p><br><pre> <code class="plaintext hljs"> Name: WHEN currentlight is requested MUST return red Request: Method: GET Path: /light/get Query: Body: &lt;no body&gt; Response: Status: 200 OK Body: {} Result: ERRORS! Errors: 1) at path $ key is missing: expected: currentLight actual: &lt;missing&gt;</code> </pre> <br><p>  Gro√üartig, es gibt Fortschritte.  Gonkey erkennt jetzt die Struktur, aber es ist immer noch falsch: Die Antwort ist leer.  Der Grund ist, dass ich in der Typdefinition ein nicht exportierbares Feld currentLight verwendet habe: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//      type trafficLights struct { currentLight string `json:"currentLight"` mutex sync.RWMutex `json:"-"` }</span></span></code> </pre> <br><p>  In Go wird ein Strukturfeld mit einem Kleinbuchstaben als nicht exportierbar betrachtet, dh von anderen Paketen aus nicht zug√§nglich.  Der JSON-Serializer sieht es nicht und kann es nicht in die Antwort aufnehmen.  Wir korrigieren: Wir machen das Feld mit einem Gro√übuchstaben, was bedeutet, dass es exportiert wird: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//      type trafficLights struct { urrentLight string `json:"currentLight"` // &lt;--   mutex sync.RWMutex `json:"-"` }</span></span></code> </pre> <br><p>  Starten Sie den Dienst neu.  F√ºhren Sie die Tests erneut aus. </p><br><pre> <code class="plaintext hljs">Failed tests: 0/1</code> </pre> <br><p>  Die Tests haben bestanden! </p><br><p>  Wir werden ein weiteres Skript schreiben, das die festgelegte Methode testet.  F√ºllen Sie die Datei tests / case / light_set.yaml mit folgendem Inhalt: </p><br><pre> <code class="plaintext hljs">- name: WHEN set is requested MUST return no response method: POST path: /light/set request: &gt; { "currentLight": "green" } response: 200: '' - name: WHEN get is requested MUST return green method: GET path: /light/get response: 200: &gt; { "currentLight": "green" }</code> </pre> <br><p>  Der erste Test legt einen neuen Wert f√ºr das Verkehrssignal fest und der zweite pr√ºft den Status, um sicherzustellen, dass er sich ge√§ndert hat. </p><br><p>  F√ºhren Sie die Tests mit demselben Befehl aus: </p><br><pre> <code class="plaintext hljs">docker run -it -v $(pwd)/tests:/tests lamoda/gonkey -tests tests/cases -host host.docker.internal:8080</code> </pre> <br><p>  Ergebnis: </p><br><pre> <code class="plaintext hljs">Failed tests: 0/3</code> </pre> <br><p>  Ein erfolgreiches Ergebnis, aber wir hatten Gl√ºck, dass die Skripte in der von uns ben√∂tigten Reihenfolge ausgef√ºhrt wurden: zuerst light_get und dann light_set.  Was w√ºrde passieren, wenn sie das Gegenteil tun w√ºrden?  Lassen Sie uns umbenennen: </p><br><pre> <code class="plaintext hljs">mv tests/cases/light_set.yaml tests/cases/_light_set.yaml</code> </pre> <br><p>  Und wieder laufen: </p><br><pre> <code class="plaintext hljs">Errors: 1) at path $.currentLight values do not match: expected: red actual: green Failed tests: 1/3</code> </pre> <br><p>  Zuerst wurde das Set ausgef√ºhrt und die Ampel im gr√ºnen Zustand belassen, sodass beim n√§chsten Testlauf ein Fehler festgestellt wurde - er wartete auf Rot. </p><br><p>  Eine M√∂glichkeit, die Tatsache zu beseitigen, dass der Test vom Kontext abh√§ngt, besteht darin, den Dienst am Anfang des Skripts (dh am Anfang der Datei) zu initialisieren, was wir normalerweise im Set-Test tun. Zuerst setzen wir den bekannten Wert, der einen bekannten Effekt erzeugen soll. und √ºberpr√ºfen Sie dann, ob der Effekt einen Effekt hatte. </p><br><p>  Eine andere M√∂glichkeit, den Ausf√ºhrungskontext vorzubereiten, wenn der Dienst die Datenbank verwendet, besteht darin, Fixtures mit Daten zu verwenden, die zu Beginn des Skripts in die Datenbank geladen werden, wodurch ein vorhersagbarer Status des Dienstes gebildet wird, der √ºberpr√ºft werden kann.  Die Beschreibung und Beispiele f√ºr die Arbeit mit Fixtures in Gonkey m√∂chte ich in einem separaten Artikel ver√∂ffentlichen. </p><br><p>  In der Zwischenzeit schlage ich folgende L√∂sung vor.  Da wir im Set-Skript sowohl die Light / Set-Methode als auch die Light / Get-Methode testen, ben√∂tigen wir einfach nicht das Light_get-Skript, das kontextsensitiv ist.  Ich l√∂sche es und benenne das verbleibende Skript um, damit der Name die Essenz widerspiegelt. </p><br><pre> <code class="plaintext hljs">rm tests/cases/light_get.yaml mv tests/cases/_light_set.yaml tests/cases/light_set_get.yaml</code> </pre> <br><p>  Als n√§chsten Schritt m√∂chte ich einige negative Szenarien f√ºr die Arbeit mit unserem Service √ºberpr√ºfen. Funktioniert dies beispielsweise ordnungsgem√§√ü, wenn ich eine falsche Signalfarbe sende?  Oder √ºberhaupt keine Farbe senden? </p><br><p>  Erstellen Sie ein neues Skript tests / case / light_set_get_negative.yaml: </p><br><pre> <code class="plaintext hljs">- name: WHEN set is requested MUST return no response method: POST path: /light/set request: &gt; { "currentLight": "green" } response: 200: '' - name: WHEN incorrect color is passed MUST return error method: POST path: /light/set request: &gt; { "currentLight": "blue" } response: 400: &gt; incorrect current light: blue - name: WHEN color is missing MUST return error method: POST path: /light/set request: &gt; {} response: 400: &gt; incorrect current light: - name: WHEN get is requested MUST have color untouched method: GET path: /light/get response: 200: &gt; { "currentLight": "green" }</code> </pre> <br><p>  Er pr√ºft das: </p><br><ul><li>  Wenn die falsche Farbe √ºbertragen wird, tritt ein Fehler auf. </li><li>  Wenn die Farbe nicht √ºbertragen wird, tritt ein Fehler auf. </li><li>  Eine falsche Farb√ºbertragung √§ndert den internen Zustand der Ampel nicht. </li></ul><br><p>  Ausf√ºhren: </p><br><pre> <code class="plaintext hljs">Failed tests: 0/6</code> </pre> <br><p>  Alles in Ordnung ist :) </p><br><h3 id="podklyuchaem-gonkey-kak-biblioteku">  Gonkey als Bibliothek verbinden </h3><br><p>  Wie Sie bemerkt haben, testen wir die Service-API vollst√§ndig von der Sprache und den Technologien, in denen sie geschrieben ist.  Auf die gleiche Weise k√∂nnten wir jede √∂ffentliche API testen, f√ºr die wir keinen Zugriff auf die Quellcodes haben - es reicht aus, Anfragen zu senden und Antworten zu erhalten. </p><br><p>  F√ºr unsere eigenen Anwendungen, die in go geschrieben wurden, gibt es eine bequemere M√∂glichkeit, gonkey auszuf√ºhren - es als Bibliothek mit dem Projekt zu verbinden.  Auf diese Weise k√∂nnen Sie den Test ausf√ºhren, ohne vorher etwas zu kompilieren - weder Gonkey noch das Projekt selbst -, indem Sie einfach <code>go test</code> ausf√ºhren. </p><br><p>  Mit diesem Ansatz scheinen wir einen Komponententest zu schreiben, und im Hauptteil des Tests f√ºhren wir Folgendes aus: </p><br><ul><li>  Initialisieren Sie den Webserver auf die gleiche Weise wie beim Start des Dienstes. </li><li>  F√ºhren Sie den Testanwendungsserver auf localhost und zuf√§lligem Port aus. </li><li>  Wir rufen die Funktion aus der Gonkey-Bibliothek auf und √ºbergeben ihr die Adresse des Testservers und andere Parameter.  Im Folgenden werde ich dies veranschaulichen. </li></ul><br><p>  Dazu muss unsere Anwendung ein wenig √ºberarbeitet werden.  Der entscheidende Punkt ist, die Erstellung des Servers zu einer separaten Funktion zu machen, da wir diese Funktion jetzt an zwei Stellen ben√∂tigen: beim Starten des Dienstes und sogar beim Ausf√ºhren der Gonkey-Tests. </p><br><p>  Ich habe den folgenden Code in eine separate Funktion eingef√ºgt: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//       http.HandleFunc("/light/get", func(w http.ResponseWriter, r *http.Request) { //   }) //       http.HandleFunc("/light/set", func(w http.ResponseWriter, r *http.Request) { //   }) }</span></span></code> </pre> <br><p>  Die Hauptfunktion lautet dann wie folgt: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { initServer() <span class="hljs-comment"><span class="hljs-comment">//   () log.Fatal(http.ListenAndServe(":8080", nil)) }</span></span></code> </pre> <br><p>  <a href="">Die ge√§nderte Haupt-Go-Datei ist vollst√§ndig</a> . </p><br><p>  Dies hat unsere H√§nde befreit, also fangen wir an, einen Test zu schreiben.  Ich erstelle eine func_test.go-Datei: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test_API</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { initServer() srv := httptest.NewServer(<span class="hljs-literal"><span class="hljs-literal">nil</span></span>) runner.RunWithTesting(t, &amp;runner.RunWithTestingParams{ Server: srv, TestsDir: <span class="hljs-string"><span class="hljs-string">"tests/cases"</span></span>, }) }</code> </pre> <br><p>  <a href="">Hier ist die vollst√§ndige Datei func_test.go</a> . </p><br><p>  Das ist alles!  Wir pr√ºfen: </p><br><pre> <code class="plaintext hljs">go test ./...</code> </pre> <br><p>  Ergebnis: </p><br><pre> <code class="plaintext hljs">ok github.com/lamoda/gonkey/examples/traffic-lights-demo 0.018s</code> </pre> <br><p>  Die Tests sind bestanden.  Wenn ich sowohl Unit-Tests als auch Gonkey-Tests habe, werden sie alle zusammen ausgef√ºhrt - ganz bequem. </p><br><h3 id="formiruem-otchet-allure">  Generieren Sie einen Allure-Bericht </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Allure</a> ist ein Testberichtformat, mit dem die Ergebnisse klar und sch√∂n angezeigt werden k√∂nnen.  Gonkey kann Testergebnisse in diesem Format aufzeichnen.  Allure zu aktivieren ist sehr einfach: </p><br><pre> <code class="plaintext hljs">docker run -it -v $(pwd)/tests:/tests -w /tests lamoda/gonkey -tests cases/ -host host.docker.internal:8080 -allure</code> </pre> <br><p>  Der Bericht wird im Unterverzeichnis allure-results des aktuellen Arbeitsverzeichnisses abgelegt (deshalb habe ich -w / tests angegeben). </p><br><p>  Wenn Sie gonkey als Bibliothek verbinden, wird der Allure-Bericht durch Festlegen einer zus√§tzlichen Umgebungsvariablen GONKEY_ALLURE_DIR aktiviert: </p><br><pre> <code class="plaintext hljs">GONKEY_ALLURE_DIR="tests/allure-results" go test ./‚Ä¶</code> </pre> <br><p>  Die in Dateien aufgezeichneten Testergebnisse werden durch die folgenden Befehle in einen interaktiven Bericht konvertiert: </p><br><pre> <code class="plaintext hljs">allure generate allure serve</code> </pre> <br><p>  Wie der Bericht aussieht: <br><img src="https://habrastorage.org/webt/bq/z-/ds/bqz-dsu89nodwlzi_im5nxr0t-k.png" alt="Bild"></p><br><h3 id="zaklyuchenie">  Fazit </h3><br><p>  In den folgenden Artikeln werde ich mich mit der Verwendung von Fixtures in Gonkey und der Nachahmung der Reaktionen anderer Dienste unter Verwendung von Mocks befassen. </p><br><p>  Ich lade Sie ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, gonkey</a> in Ihren Projekten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auszuprobieren</a> , an seiner Entwicklung teilzunehmen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Poolanfragen</a> sind willkommen!) Oder es mit einem Sternchen auf dem Github zu markieren, wenn dieses Projekt f√ºr Sie in Zukunft n√ºtzlich sein kann. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463301/">https://habr.com/ru/post/de463301/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463291/index.html">W√ºrfel oder Knochen</a></li>
<li><a href="../de463293/index.html">M√ºllsammler. Voller Kurs + Transfer von BOTR</a></li>
<li><a href="../de463295/index.html">C ++ und CMake - Brothers Forever, Teil II</a></li>
<li><a href="../de463297/index.html">Loyalit√§t nach Ihrem Geschmack</a></li>
<li><a href="../de463299/index.html">Tipps und Tricks von Kubernetes: So steigern Sie die Produktivit√§t</a></li>
<li><a href="../de463303/index.html">Facebook h√∂rt schlie√ülich auf, Anzeigen f√ºr Telefonnummern zu schalten, die f√ºr 2FA eingegeben werden</a></li>
<li><a href="../de463305/index.html">Tools zum Analysieren und Debuggen von .NET-Anwendungen</a></li>
<li><a href="../de463307/index.html">Fallstudie zur Kommunikation mit einem ‚Äûschweren‚Äú Kunden</a></li>
<li><a href="../de463311/index.html">CTT in Serverl√∂sungen. Die zweite Version + die Ank√ºndigung der dritten, mit der F√§higkeit zu ber√ºhren</a></li>
<li><a href="../de463313/index.html">Ein alternativer Ansatz zum Abonnieren von Ereignissen, oder ist EventObject wirklich notwendig?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>