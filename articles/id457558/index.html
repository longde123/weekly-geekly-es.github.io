<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëçüèø ü§ê üëêüèæ Analisis Kerentanan EvilParcel üóæ üë† üßíüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Pada pertengahan April, kami menerbitkan berita tentang Trojan Android.InfectionAds.1 , yang mengeksploitasi beberapa kerentanan kritis ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analisis Kerentanan EvilParcel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/drweb/blog/457558/"><h3>  Pendahuluan </h3><br>  Pada pertengahan April, kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menerbitkan berita</a> tentang Trojan <b>Android.InfectionAds.1</b> , yang mengeksploitasi beberapa kerentanan kritis dalam OS Android.  Salah satunya - CVE-2017-13156 (juga dikenal sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Janus</a> ) - memungkinkan program jahat menginfeksi file APK tanpa merusak tanda tangan digital mereka. <br><br>  Yang lainnya adalah CVE-2017-13315.  Ini memberi Trojan hak istimewa tingkat lanjut, dan dapat secara mandiri menginstal dan mencopot aplikasi.  Analisis terperinci tentang <b>Android.InfectionAds.1</b> tersedia di perpustakaan virus kami, dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Kami akan membahas kerentanan CVE-2017-13315 lebih terinci dan melihat seperti apa rasanya. <br><a name="habracut"></a><br>  CVE-2017-13315 termasuk dalam kelompok kerentanan yang menerima nama umum EvilParcel.  Mereka ditemukan di berbagai kelas sistem OS Android.  Karena kesalahan dalam yang terakhir ketika bertukar data antara aplikasi dan sistem, menjadi mungkin untuk mengganti data ini.  Program jahat yang mengeksploitasi kerentanan EvilParcel menerima hak istimewa yang lebih tinggi dan dapat melakukan hal berikut dengan bantuan mereka: <br><br><ul><li>  instal dan hapus instalasi aplikasi dengan izin apa pun tanpa konfirmasi pengguna; </li><li>  ketika digunakan bersama dengan kerentanan lain, menginfeksi program yang diinstal pada perangkat dan mengganti "bersih" dokumen asli dengan salinan yang terinfeksi; </li><li>  Setel ulang kode kunci layar untuk perangkat Android </li><li>  Setel ulang PIN layar kunci perangkat Android. </li></ul><br>  Saat ini ada 7 kerentanan yang diketahui dari jenis ini: <br><br><ul><li>  CVE-2017-0806 (kesalahan di kelas GateKeeperResponse), diterbitkan pada Oktober 2017; </li><li>  CVE-2017-13286 (kesalahan di kelas OutputConfiguration, diterbitkan pada April 2018; </li><li>  CVE-2017-13287 (kesalahan dalam kelas VerifyCredentialResponse), diterbitkan pada April 2018; </li><li>  CVE-2017-13288 (kesalahan dalam kelas PeriodicAdvertizingReport), diterbitkan pada April 2018; </li><li>  CVE-2017-13289 (bug di kelas ParcelableRttResults), diterbitkan pada bulan April 2018; </li><li>  CVE-2017-13311 (bug di kelas SparseMappingTable), diterbitkan pada Mei 2018; </li><li>  CVE-2017-13315 (kesalahan dalam kelas DcParamObject), diterbitkan pada Mei 2018. </li></ul><br>  Semuanya mengancam perangkat yang menjalankan OS Android versi 5.0 - 8.1 yang tidak memiliki pembaruan keamanan Mei 2018 dan yang lebih baru. <br><br><h3>  Prasyarat untuk Kerentanan EvilParcel </h3><br>  Mari kita lihat bagaimana kerentanan EvilParcel muncul.  Pertama-tama, kita akan melihat beberapa fitur aplikasi Android.  Di Android OS, semua program berinteraksi satu sama lain, serta dengan sistem operasi itu sendiri, dengan mengirim dan menerima objek bertipe Intent.  Objek-objek ini dapat berisi jumlah pasangan kunci-nilai yang sewenang-wenang di dalam objek tipe Bundle. <br><br>  Saat mentransmisikan Intent, objek Bundle dikonversi (serial) ke array byte yang dibungkus Parcel, dan ketika membaca kunci dan nilai-nilai dari Bundel serial, objek akan secara otomatis di-deserialisasi. <br><br>  Di Bundle, string adalah kuncinya, dan nilainya bisa hampir apa saja.  Misalnya, tipe, string, atau wadah primitif yang mengandung tipe atau string primitif.  Selain itu, bisa menjadi objek bertipe Parcelable. <br><br>  Dengan demikian, di Bundle, Anda dapat menempatkan objek jenis apa pun yang mengimplementasikan antarmuka Parcelable.  Untuk melakukan ini, Anda perlu mengimplementasikan metode writeToParcel () dan createFromParcel () untuk membuat cerita bersambung dan melakukan deserialisasi objek. <br><br>  Sebagai contoh yang baik, mari kita buat bundel berseragam sederhana.  Mari kita menulis kode yang menempatkan tiga pasangan nilai kunci di Bundle dan membuat serialisasi: <br><br>  Bundel demo = Bundel baru (); <br>  demo.putString ("String", "Hello, World!"); <br>  demo.putInt ("Integer", 42); <br>  demo.putByteArray ("ByteArray", byte baru [] {1, 2, 3, 4, 5, 6, 7, 8}); <br>  Parcel parcel = Parcel.obtain (); <br>  parcel.writeBundle (demo); <br><br>  Setelah mengeksekusi kode ini, kami mendapatkan bundel dari formulir berikut: <br><br><img src="https://habrastorage.org/webt/53/gn/x5/53gnx5bjhjfdaqjr5isxgva6fzg.png"><br><br>  <b>Gambar 1.</b> Struktur objek Bundel berseri. <br><br>  Mari kita perhatikan fitur-fitur berikut dari serialisasi Bundle: <br><br><ul><li>  semua pasangan kunci-nilai ditulis satu demi satu; </li><li>  sebelum setiap nilai tipenya ditunjukkan (13 untuk array byte, 1 untuk Integer, 0 untuk string, dan sebagainya); </li><li>  sebelum data panjang variabel, ukurannya ditunjukkan (panjang untuk string, jumlah byte untuk array); </li><li>  semua nilai ditulis dengan pelurusan 4 byte. </li></ul><br>  Karena kenyataan bahwa semua kunci dan nilai dalam Bundle ditulis secara berurutan, ketika mengakses kunci atau nilai objek Bundel berserialisasi, yang terakhir dideserialisasi sepenuhnya, termasuk menginisialisasi semua objek Parcelable yang terkandung di dalamnya. <br><br>  Tampaknya, apa masalahnya?  Dan itu adalah bahwa dalam beberapa kelas sistem yang mengimplementasikan Parcelable, metode createFromParcel () dan writeToParcel () mungkin mengalami kesalahan.  Di kelas-kelas ini, jumlah byte yang dibaca dalam metode createFromParcel () akan berbeda dari jumlah byte yang ditulis dalam metode writeToParcel ().  Jika Anda menempatkan objek kelas semacam itu di dalam Bundel, batas-batas objek di dalam Bundel akan berubah setelah serialisasi ulang.  Dan di sinilah kondisi untuk mengeksploitasi kerentanan EvilParcel dibuat. <br><br>  Berikut adalah contoh kelas dengan kesalahan yang sama: <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parcelable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Demo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Demo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Parcel in)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = in.readInt(); data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[length]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { in.readByteArray(data); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Creator&lt;Demo&gt; CREATOR = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Creator&lt;Demo&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Demo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createFromParcel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Parcel in)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Demo(in); } }; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeToParcel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Parcel parcel, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ parcel.writeInt(data.length); parcel.writeByteArray(data); } }</code> </pre> <br>  Jika ukuran array data adalah 0, maka saat membuat objek di createFromParcel () satu int (4 byte) akan dibaca, dan dua int (8 byte) akan ditulis dalam writeToParcel ().  Int pertama akan ditulis dalam panggilan eksplisit ke writeInt.  Int kedua akan ditulis ketika writeByteArray () dipanggil, karena panjangnya selalu ditulis ke array sebelum Parcel (lihat Gambar 1). <br><br>  Situasi ketika ukuran array data 0 jarang terjadi.  Tetapi bahkan ketika ini terjadi, program masih terus bekerja jika hanya satu objek yang ditransmisikan dalam bentuk serial pada suatu waktu (dalam contoh kita, objek Demo).  Oleh karena itu, kesalahan tersebut, sebagai suatu peraturan, tidak diketahui. <br><br>  Sekarang mari kita coba menempatkan objek Demo dengan panjang array nol di Bundel: <br><br><img src="https://habrastorage.org/webt/2y/2v/i0/2y2vi0ftdkartg9i01cc-b858g0.png"><br>  <b>Gambar 2.</b> Hasil menambahkan objek Demo dengan panjang array nol ke Bundel. <br><br>  Kami cerita bersambung objek: <br><br><img src="https://habrastorage.org/webt/hv/tw/if/hvtwifj9curkc7ip6jplbdlk-yc.png"><br>  <b>Gambar 3.</b> Bundel objek setelah serialisasi. <br><br>  Mari kita coba deserialize: <br><br><img src="https://habrastorage.org/webt/_u/a1/k4/_ua1k4hp34wknsvnppv8zla0jei.png"><br>  <b>Gambar 4.</b> Setelah deserializing objek Bundle. <br><br>  Apa hasilnya?  Pertimbangkan cuplikan Parcel: <br><br><img src="https://habrastorage.org/webt/g0/qs/y4/g0qsy4cigykwv2gxgpizo2qsu7u.png"><br>  <b>Gambar 5.</b> Struktur parsel setelah deserialisasi bundel. <br><br>  Dari Gambar 4 dan 5, kita melihat bahwa selama deserialisasi, satu int dibaca dalam metode createFromParcel alih-alih dua yang ditulis sebelumnya.  Oleh karena itu, semua nilai selanjutnya dari Bundel tidak dibaca dengan benar.  Nilai 0x0 pada alamat 0x60 dibaca sebagai panjang kunci berikutnya.  Dan nilai 0x1 pada alamat 0x64 dibaca sebagai kunci.  Dalam hal ini, nilai 0x31 pada alamat 0x68 dibaca sebagai jenis nilai.  Tidak ada nilai di Parcel yang tipenya 0x31, jadi readFromParcel () dengan setia melaporkan kesalahan (pengecualian). <br><br>  Bagaimana ini bisa digunakan dalam praktik dan menjadi kerentanan?  Ayo lihat!  Kesalahan yang dijelaskan di atas dalam kelas sistem Parcelable memungkinkan Anda untuk membangun Bundle, yang mungkin berbeda selama deserialisasi yang pertama dan berulang.  Untuk menunjukkan ini, modifikasi contoh sebelumnya: <br><br><pre> <code class="java hljs">Parcel data = Parcel.obtain(); data.writeInt(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 3 entries data.writeString("vuln_class"); data.writeInt(4); // value is Parcelable data.writeString("com.drweb.testbundlemismatch.Demo"); data.writeInt(0); // data.length data.writeInt(1); // key length -&gt; key value data.writeInt(6); // key value -&gt; value is long data.writeInt(0xD); // value is bytearray -&gt; low(long) data.writeInt(-1); // bytearray length dummy -&gt; high(long) int startPos = data.dataPosition(); data.writeString("hidden"); // bytearray data -&gt; hidden key data.writeInt(0); // value is string data.writeString("Hi there"); // hidden value int endPos = data.dataPosition(); int triggerLen = endPos - startPos; data.setDataPosition(startPos - 4); data.writeInt(triggerLen); // overwrite dummy value with the real value data.setDataPosition(endPos); data.writeString("A padding"); data.writeInt(0); // value is string data.writeString("to match pair count"); int length = data.dataSize(); Parcel bndl = Parcel.obtain(); bndl.writeInt(length); bndl.writeInt(0x4C444E42); // bundle magic bndl.appendFrom(data, 0, length); bndl.setDataPosition(0);</span></span></code> </pre> <br>  Kode ini menciptakan bundel berseri yang berisi kelas rentan.  Mari kita lihat hasil dari mengeksekusi kode ini: <br><br><img src="https://habrastorage.org/webt/tc/ke/wf/tckewffnaop28wllxnrt7pagdvs.png"><br>  <b>Gambar 6.</b> Membuat Bundel dengan kelas rentan. <br><br>  Setelah deserialisasi pertama, bundel ini akan berisi kunci-kunci berikut: <br><br><img src="https://habrastorage.org/webt/cj/si/l0/cjsil0--g_jsoew8ht-oxely1u4.png"><br>  <b>Gambar 7.</b> Hasil deserializing Bundle dengan kelas rentan. <br><br>  Sekarang lagi buat serial tentang Bundel yang dihasilkan, lalu deserialisasi lagi dan lihat daftar kunci: <br><br><img src="https://habrastorage.org/webt/uw/e1/mj/uwe1mjdtywr59oyshaah2q1gkus.png"><br>  <b>Gambar 8.</b> Hasil serialisasi ulang dan deserialisasi bundel dengan kelas rentan. <br><br>  Apa yang kita lihat  Kunci tersembunyi (dengan nilai string "Hai di sana!") Muncul di Bundle, yang sebelumnya tidak ada.  Pertimbangkan potongan Parcel Bundel ini untuk memahami mengapa ini terjadi: <br><br><img src="https://habrastorage.org/webt/cx/za/dz/cxzadza4tugyeemlefk1lmlkdbu.png"><br>  <b>Gambar 9.</b> Struktur paket objek Bundle dengan kelas rentan setelah dua siklus serialisasi-deserialisasi. <br><br>  Di sini esensi kerentanan EvilParcel menjadi lebih jelas.  Dimungkinkan untuk membuat Bundle yang dibentuk secara khusus yang akan berisi kelas yang rentan.  Mengubah batas-batas kelas ini akan memungkinkan Anda untuk menempatkan objek apa pun di dalam Bundel ini - misalnya, Intent, yang akan muncul dalam Bundel hanya setelah deserialisasi kedua.  Ini akan memungkinkannya untuk menyembunyikan Intent dari mekanisme perlindungan sistem operasi. <br><br><h3>  Operasi EvilParcel </h3><br>  Android.InfectionAds.1 menggunakan CVE-2017-13315 menginstal dan menghapus program sendiri tanpa intervensi dari pemilik perangkat yang terinfeksi.  Tapi bagaimana kabarnya? <br><br>  Pada 2013, kesalahan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">7699048</a> juga ditemukan, juga dikenal sebagai Launch AnyWhere.  Itu memungkinkan aplikasi pihak ketiga untuk menjalankan aktivitas sewenang-wenang atas nama sistem pengguna yang lebih istimewa.  Diagram di bawah ini menunjukkan mekanisme kerjanya: <br><br><img src="https://habrastorage.org/webt/dg/no/n9/dgnon92txtobknvvgr5eo2cmi54.png"><br>  <b>Gambar 10.</b> Skema kesalahan 7699048. <br><br>  Dengan kerentanan ini, aplikasi eksploit dapat mengimplementasikan layanan AccountAuthenticator, yang dirancang untuk menambahkan akun baru ke sistem operasi.  Berkat bug 7699048, exploit dapat menjalankan aktivitas untuk menginstal, mencopot, mengganti aplikasi, mengatur ulang PIN atau Pattern Lock, dan melakukan hal-hal tidak menyenangkan lainnya. <br><br>  Google telah memperbaiki celah ini dengan melarang peluncuran aktivitas sewenang-wenang dari AccountManager.  Sekarang Manajer Akun hanya memungkinkan peluncuran kegiatan yang berasal dari aplikasi yang sama.  Untuk melakukan ini, ia memeriksa dan membandingkan tanda tangan digital dari program yang memulai awal kegiatan dengan tanda tangan aplikasi di mana aktivitas yang diluncurkan berada.  Ini terlihat seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; (intent = result.getParcelable(AccountManager.KEY_INTENT)) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* * The Authenticator API allows third party authenticators to * supply arbitrary intents to other apps that they can run, * this can be very bad when those apps are in the system like * the System Settings. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> authenticatorUid = Binder.getCallingUid(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> bid = Binder.clearCallingIdentity(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { PackageManager pm = mContext.getPackageManager(); ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, <span class="hljs-number"><span class="hljs-number">0</span></span>, mAccounts.userId); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetUid = resolveInfo.activityInfo.applicationInfo.uid; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PackageManager.SIGNATURE_MATCH != pm.checkSignatures(authenticatorUid, targetUid)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecurityException( <span class="hljs-string"><span class="hljs-string">"Activity to be started with KEY_INTENT must "</span></span> + <span class="hljs-string"><span class="hljs-string">"share Authenticator's signatures"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { Binder.restoreCallingIdentity(bid); } }</code> </pre><br>  Tampaknya masalah telah diselesaikan, tetapi tidak semua yang ada di sini lancar.  Ternyata perbaikan ini dapat dicegah menggunakan kerentanan EvilParcel CVE-2017-13315 yang terkenal!  Seperti yang sudah kita ketahui, setelah memperbaiki Launch AnyWhere, sistem memeriksa tanda tangan digital aplikasi.  Jika pemeriksaan ini berhasil, Bundel diteruskan ke IAccountManagerResponse.onResult ().  Pada saat yang sama, onResult () dipanggil melalui mekanisme IPC, sehingga Bundle diserialisasi lagi.  Dalam implementasi onResult (), berikut ini terjadi: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** Handles the responses from the AccountManager */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Response</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IAccountManagerResponse</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stub</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle bundle)</span></span></span><span class="hljs-function"> </span></span>{ Intent intent = bundle.getParcelable(KEY_INTENT); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (intent != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; mActivity != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// since the user provided an Activity we will silently start intents // that we see mActivity.startActivity(intent); // leave the Future running to wait for the real response to this request } //&lt;.....&gt; } //&lt;.....&gt; }</span></span></code> </pre><br>  Selanjutnya, Bundel diekstraksi kunci niat dan aktivitas diluncurkan tanpa pemeriksaan.  Akibatnya, untuk memulai aktivitas sewenang-wenang dengan hak sistem, cukup untuk membangun Bundle sedemikian rupa sehingga bidang maksud disembunyikan pada deserialisasi pertama, dan muncul pada deserialisasi kedua.  Dan, seperti yang telah kita lihat, justru tugas inilah yang dipenuhi kerentanan EvilParcel. <br><br>  Saat ini, semua kerentanan yang diketahui dari tipe ini diperbaiki oleh perbaikan di kelas Parcelable yang rentan itu sendiri.  Namun, kemunculan kembali kelas-kelas rentan di masa depan tidak dapat dikesampingkan.  Implementasi Bundle dan mekanisme untuk menambah akun baru masih sama seperti sebelumnya.  Mereka masih memungkinkan Anda untuk membuat exploit yang persis sama ketika Anda menemukan (atau baru) kelas Parcelable yang rentan.  Terlebih lagi, implementasi kelas-kelas ini masih dilakukan secara manual, dan programmer harus mengawasi panjang konstan objek Parcelable berseri.  Dan ini adalah faktor manusia dengan segala konsekuensinya.  Namun, kami berharap bahwa kesalahan seperti itu akan sesedikit mungkin, dan kerentanan EvilParcel tidak akan mengganggu pengguna perangkat Android. <br><br>  Anda dapat memeriksa kerentanan perangkat seluler EvilParcel Anda menggunakan antivirus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dr.Web Security Space kami</a> .  "Auditor Keamanan" yang terintegrasi akan melaporkan masalah yang diidentifikasi dan memberikan rekomendasi untuk menyelesaikannya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id457558/">https://habr.com/ru/post/id457558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id457542/index.html">Meretas dan melindungi drive enkripsi LUKS</a></li>
<li><a href="../id457546/index.html">Demo Day: mengapa semuanya dan bagaimana melakukannya UPD + Broadcast</a></li>
<li><a href="../id457548/index.html">Generasi sinyal PWM multifase pada TMS320F28027</a></li>
<li><a href="../id457550/index.html">Apa yang harus dilindungi oleh industri digital</a></li>
<li><a href="../id457552/index.html">Pendaki di Zafasadia. Bagaimana promalps di menara Lakhta Center bekerja</a></li>
<li><a href="../id457560/index.html">Saham Tokenized: Cara Menjadi Investor Gett Sebelum Pergi IPO</a></li>
<li><a href="../id457562/index.html">Ivideon Counter 3D: siapa, bagaimana dan mengapa menghitung pengunjung</a></li>
<li><a href="../id457564/index.html">Memperkirakan biaya sistem TI perusahaan</a></li>
<li><a href="../id457566/index.html">Tekanan OK: Mengapa pusat data perlu kontrol tekanan udara?</a></li>
<li><a href="../id457568/index.html">Kongres Futurologis: pilihan kisah para penginjil masa depan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>