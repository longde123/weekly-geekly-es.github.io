<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçüíª üôé üë©üèø‚Äçüî¨ Grundlegendes zum POCSAG-Paging-Protokoll üêæ üïå üéª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor langer Zeit, als ein Mobiltelefon etwa 2000 US-Dollar kostete und eine Minute Sprachanruf 50 Cent kostete, waren Pager sehr beliebt. Sp√§ter wurden...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Grundlegendes zum POCSAG-Paging-Protokoll</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438906/">  Vor langer Zeit, als ein Mobiltelefon etwa 2000 US-Dollar kostete und eine Minute Sprachanruf 50 Cent kostete, waren Pager sehr beliebt.  Sp√§ter wurden Mobiltelefone billiger, Anrufe und SMS-Preise wurden niedriger und schlie√ülich verschwanden die Pager gr√∂√ütenteils. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8t/7j/xw/8t7jxwauxqbonmzwmweakgmwpvw.jpeg"></div><br>  F√ºr Personen, die zuvor einen Pager besessen haben und wissen m√∂chten, wie er funktioniert, ist dieser Artikel hilfreich. <br><a name="habracut"></a><br><h2>  Hauptinfo </h2><br>  F√ºr Leute, die die Prinzipien vergessen haben oder nach 2000x geboren wurden, werde ich kurz an die Hauptideen erinnern. <br><br>  Das Paging-Kommunikationsnetz hat einige Vorteile, die manchmal schon jetzt wichtig sind: <br><br>  - Es handelt sich um eine einseitige Kommunikation ohne jegliche Best√§tigung, sodass das Netzwerk nicht √ºberlastet werden kann. Es h√§ngt nur nicht von einer Reihe von Benutzern ab.  Nachrichten werden kontinuierlich "wie sie sind" nacheinander √ºbertragen, und der Pager erh√§lt die Nachricht, wenn seine Nummer (sogenannter Capcode) der internen Nummer des Ger√§ts entspricht. <br><br>  - Der Empf√§nger ist sehr leicht (sowohl w√∂rtlich als auch elektronisch) und kann mit 2 AA-Batterien bis zu einem Monat arbeiten. <br><br>  Es gibt zwei grundlegende Standards f√ºr die Nachrichten√ºbertragung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">POCSAG</a> (Post Office Code Standardization Advisory Group) und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FLEX</a> .  Beide Standards sind ziemlich alt, POCSAG wurde 1982 hergestellt und unterst√ºtzt Geschwindigkeiten von 512, 1200 und 2400 Bit / s.  Zur √úbertragung wird das FSK-Verfahren (Frequency Shift Keying) mit einer Frequenztrennung von 4,5 kHz verwendet.  FLEX ist etwas neuer (wurde von Motorola im Jahr 90 hergestellt), kann mit einer Geschwindigkeit von bis zu 6400 Bit / s arbeiten und sowohl FSK2 als auch FSK4 verwenden. <br><br>  Beide Protokolle sind im Allgemeinen sehr einfach, und vor etwa 20 Jahren wurden PC-Decoder hergestellt, die Nachrichten von einer seriellen Schnittstelle einer Soundkarte decodieren k√∂nnen (es wird keine Verschl√ºsselung unterst√ºtzt, sodass alle Nachrichten von jedem gelesen werden k√∂nnen). <br><br>  Schauen wir uns an, wie es funktioniert. <br><br><h2>  Ein Signal empfangen </h2><br>  Zun√§chst ben√∂tigen wir ein Signal zum Decodieren.  Nehmen wir einen Laptop, einen RTL-SDR-Empf√§nger und holen ihn uns. <br><br><img src="https://habrastorage.org/webt/vj/ba/2g/vjba2gslgleejthwn_m8ccsvf00.jpeg"><br><br>  Die Frequenzumtastung wird verwendet, daher stellen wir FM ein.  Mit HDSDR speichern wir ein Signal im WAV-Format. <br><br>  √úberpr√ºfen wir, was wir bekommen.  Laden der WAV-Datei als Python-Datenarray: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.io <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> wavfile <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt fs, data = wavfile.read(<span class="hljs-string"><span class="hljs-string">"pocsag.wav"</span></span>) plt.plot(data) plt.show()</code> </pre> <br>  Ausgabe (manuell hinzugef√ºgte Bits): <br><br><img src="https://habrastorage.org/webt/pm/ss/y7/pmssy79glsbnfsgxogjd93ylqre.jpeg"><br><br>  Wie wir sehen k√∂nnen, ist es einfach und sogar "mit blo√üem Auge" k√∂nnen wir Bits in Paint zeichnen. Es ist leicht zu unterscheiden, wo "0" und wo "1" ist.  Es wird jedoch zu lange dauern, dies manuell zu tun. Es ist an der Zeit, den Prozess zu automatisieren. <br><br>  Nach dem Vergr√∂√üern des Diagramms k√∂nnen wir sehen, dass jedes Bit eine Breite von 20 Abtastwerten hat.  Wir haben 24000 Samples pro Sekunde Bitrate-WAV-Datei, daher betr√§gt die Schl√ºsselgeschwindigkeit 1200 Bit / s.  Finden wir eine Nulldurchgangsposition - dies ist der Beginn der Bitsequenz.  F√ºgen Sie auch Markierungen hinzu, um zu √ºberpr√ºfen, ob sich alle Bits an den richtigen Stellen befinden. <br><br><pre> <code class="python hljs">speed = <span class="hljs-number"><span class="hljs-number">1200</span></span> fs = <span class="hljs-number"><span class="hljs-number">24000</span></span> cnt = int(fs/speed) start = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">2</span></span>*cnt): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[p] &lt; - <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> data[p+<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">50</span></span>: start = p <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-comment"><span class="hljs-comment"># Bits frame bits = np.zeros(data.size) for p in range(0, data.size - cnt, cnt): bits[start + p] = 500 plt.plot(bits)</span></span></code> </pre><br>  Wie wir sehen k√∂nnen, stimmt es nicht perfekt √ºberein (Sender und Empf√§nger haben leicht unterschiedliche Frequenzen), aber es reicht definitiv zum Decodieren aus. <br><br><img src="https://habrastorage.org/webt/hc/s1/lf/hcs1lfxgchl-ngpkyeemhhsgrly.jpeg"><br><br>  F√ºr lange Signale ben√∂tigen wir wahrscheinlich einen automatischen Frequenzkorrekturalgorithmus, aber f√ºr diese Art von Signalen ist dies nicht kritisch. <br><br>  Der letzte Schritt - wir m√ºssen die WAV-Datei in die Bitfolge √ºbersetzen.  Es ist auch einfach, wir kennen die L√§nge jedes Bits. Wenn die Datensumme positiv ist, addieren wir "1", andernfalls "0" (schlie√ülich wurde festgestellt, dass ein Signal zur√ºckgesetzt werden muss, sodass 0 und 1 ersetzt wurden). . <br><br><pre> <code class="python hljs">bits_str = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, data.size - cnt, cnt): s = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(p, p+cnt): s += data[p] bits_str += <span class="hljs-string"><span class="hljs-string">"1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-string"><span class="hljs-string">"0"</span></span> print(<span class="hljs-string"><span class="hljs-string">"Bits"</span></span>) print(bits_str)</code> </pre><br>  Ausgabe - richtige Bitfolge (in einem Zeichenfolgenformat), die unsere Nachricht enth√§lt. <br><br> <code>101010101010101010101010101010101010101010101010101010101010101010101010101 <br> 010101010101010101010101010101010101010101010100111110011010010000101001101 <br> 100001111010100010011100000110010111011110101000100111000001100101110111101 <br> 010001001110000011001011101111010100010011100000110010111011110101000100111 <br> 000001100101110111101010001001110000011001011101111010100010011100000110010 <br> 011011110101000100111000001100101110111101010001001110000011001011101111010 <br> 100010011100000110010111011110101000100111000001100101110111101010001001110 <br> ... <br> 111101111</code> <br> <br><h2>  Nur numerische Nachrichten dekodieren </h2><br>  Eine Bitfolge ist viel praktischer als eine WAV-Datei, wir k√∂nnen Daten daraus extrahieren.  Lassen Sie uns zun√§chst die Daten in 4-Byte-Bl√∂cke aufteilen. <br><br> <code>10101010101010101010101010101010 <br> 10101010101010101010101010101010 <br> 10101010101010101010101010101010 <br> 10101010101010101010101010101010 <br> <br> 01111100110100100001010011011000 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 00001000011011110100010001101000 <br> 10000011010000010101010011010100 <br> <br> 01111100110100100001010111011000 <br> 11110101010001000001000000111000 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 00100101101001011010010100101111</code> <br> <br>  Wir k√∂nnen definitiv ein Muster sehen.  Jetzt m√ºssen wir herausfinden, was jeder Teil bedeutet.  Das POCSAG-Handbuch ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im PDF-Format</a> verf√ºgbar. Hier k√∂nnen Sie die Beschreibung der Datenstrukturen √ºberpr√ºfen. <br><br><img src="https://habrastorage.org/webt/3k/yt/dc/3kytdccgmehfmqstxxli1nt3fpa.png"><br><br>  Es ist jetzt viel klarer.  Der Header enth√§lt einen langen Block "10101010101", mit dem der Pager aus dem Ruhemodus "geweckt" wird.  Die Nachricht selbst enth√§lt die Bl√∂cke Batch-1 ... Batch-N, jeder Block beginnt mit der eindeutigen Sequenz FSC.  Wie wir im Handbuch sehen k√∂nnen, enth√§lt die Zeichenfolge, wenn sie bei "0" beginnt, die Empf√§ngeradresse.  Die gespeicherte Adresse selbst (Capcode) ist der Pager. Wenn sie nicht √ºbereinstimmt, ignoriert der Pager die Nachricht.  Wenn eine Zeichenfolge bei "1" beginnt, enth√§lt sie den Nachrichtentext.  In unserem Beispiel haben wir 2 Zeichenfolgen dieses Typs. <br><br>  √úberpr√ºfen wir nicht jeden Block.  Wir k√∂nnen auch Leerlaufcodes sehen - leere Bl√∂cke 01111 ... 0111, sie haben keine n√ºtzlichen Informationen.  Nachdem wir sie entfernt haben, erhalten wir nur Folgendes: <br><br> <code>01111100110100100001010011011000 - Frame Sync <br> 00001000011011110100010001101000 - Address <br> 10000011010000010101010011010100 - Message <br> <br> 01111100110100100001010111011000 - Frame Sync <br> 11110101010001000001000000111000 - Message <br> 00100101101001011010010100101111 - Address</code> <br> <br>  Wir m√ºssen herausfinden, was drin ist. <br><br>  Nach Durchsicht des Handbuchs ist klar, dass es zwei Arten von Nachrichten gibt - nur <b>numerische</b> und <b>alphanumerische</b> .  Nur numerische Nachrichten werden als 4-Bit-BCD-Codes gespeichert, sodass 20 Bit 5 Symbole enthalten k√∂nnen (es gibt auch CRC-Bits, die wir derzeit nicht verwenden).  Wenn die Nachricht alphanumerisch ist, wird eine 7-Bit-ASCII-Codierung verwendet.  Diese Nachricht ist zu kurz, daher kann es sich nur um eine reine numerische Nachricht handeln. <br><br>  Aus den Zeichenfolgen 10000011010000010101010011010100 und 11110101010001000001000000111000 k√∂nnen wir diese 4-Bit-Sequenzen erhalten: <br>  <i>1 0000 0110 1000 0010 10101 0011010100</i> - 0h 6h 8h 2h Ah <br>  <i>1 1110 1010 1000 1000 00100 0000111000</i> - Eh Ah 8h 8h 2h <br><br>  Der n√§chste Schritt besteht darin, die Dekodierungstabelle aus dem Handbuch abzurufen: <br><br><img src="https://habrastorage.org/webt/vb/sj/zl/vbsjzluxbhaeuy_zrefccmqhogw.jpeg"><br><br>  Es ist offensichtlich, dass eine nur numerische Nachricht die Ziffern 0-9, den Buchstaben U ("ugrent"), ein Leerzeichen und zwei Klammern enthalten kann.  Schreiben wir eine kleine Methode, um sie zu dekodieren: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># 16 lines in a batch, each block has a length 32 bits for cw in range(16): cws = block[32 * cw:32 * (cw + 1)] if cws[0] == "0": addr = cws[1:19] print(" Addr:" + addr) else: msg = cws[1:21] print(" Msg: " + msg) size = 4 s = "" for ind in range(0, len(msg), size): bcd_s = msg[ind:ind + size] value = int(bcd_s, 2) symbols = "0123456789*U -)(" s += symbols[value] print(" ", s) print()</span></span></code> </pre><br>  Schlie√ülich erhalten wir eine Nachricht "0682 *) * 882". <br><br>  Es ist schwer zu sagen, was es bedeutet, aber wenn die nur numerischen Nachrichten verwendet werden, braucht es wahrscheinlich jemand. <br><br><h2>  Dekodieren von alphanumerischen Nachrichten </h2><br>  Der n√§chste und interessantere Schritt besteht darin, alphanumerische Nachrichten zu dekodieren.  Es ist interessanter, weil wir als Ausgabe den vom Menschen lesbaren Text erhalten sollten. <br><br>  Zuerst m√ºssen wir eine Nachricht erneut aufzeichnen, wir werden HDSDR verwenden.  Wir kennen keinen Nachrichtentyp vor dem Dekodieren, daher zeichnen wir nur eine l√§ngste Nachricht auf, die wir erhalten k√∂nnen, und hoffen, dass sie Text enth√§lt. <br><br><img src="https://habrastorage.org/webt/lu/ue/sk/luuesk79iv_yalka_pchncpwzoi.jpeg"><br><br>  Nach der Konvertierung von WAV in eine Bitsequenz (siehe Python-Code oben) erhalten wir Folgendes: <br><br><img src="https://habrastorage.org/webt/qb/wt/ud/qbwtud3zptfcwxw3xs0pam7pkr4.jpeg"><br><br>  Einige interessante Dinge, die wir sofort mit blo√üem Auge sehen k√∂nnen - zum Beispiel wiederholt sich die Startsequenz 01010101010101 zweimal.  Somit ist diese Nachricht nicht nur l√§nger, sie enth√§lt buchst√§blich zwei Nachrichten, die zusammengef√ºhrt werden (ein Standard leugnet dies √ºbrigens nicht). <br><br>  Wie wir zuvor festgestellt haben, beginnt jeder Datenblock mit einer Sequenz namens Frame Sync Code (01111100 ...), nachdem 32-Bit-Bl√∂cke gesendet wurden.  Jeder Block kann entweder die Adresse oder den Nachrichtentext speichern. <br><br>  Fr√ºher haben wir nur numerische Nachrichten erhalten, jetzt m√∂chten wir ASCII-Nachrichten lesen.  Zuerst m√ºssen wir sie unterscheiden.  Diese Daten werden in einem Feld "Funktionsbits" (Bits 20-21) gespeichert. Wenn beide Bits 00 sind, handelt es sich um eine rein numerische Nachricht. Wenn die Bits 11 sind, handelt es sich um eine Textnachricht. <br><br>  Interessanterweise ist dieses Nachrichtenfeld 20 Bit lang, daher ist es ideal, dort bei einer nur numerischen Nachricht f√ºnf 4-Bit-Bl√∂cke zu platzieren.  Wenn wir jedoch eine 7-Bit-ASCII-Nachricht haben, k√∂nnen wir 20 nicht auf 7 teilen. Es ist m√∂glich vorherzusagen, dass die erste Protokollversion nur numerische Nachrichten unterst√ºtzt (vergessen Sie nicht, dass sie 1982 erstellt wurde <s>und wahrscheinlich die ersten Nixie-Tube-Pager konnten nicht mehr anzeigen</s> ), und erst sp√§ter wurde die Unterst√ºtzung f√ºr ASCII-Nachrichten hinzugef√ºgt.  Aus den alten Gr√ºnden wurde der Framing-Standard nicht ge√§ndert, und die Entwickler verwendeten den einfachen Ansatz - sie kombinierten die Bits einfach "wie sie sind" nacheinander.  Von jeder Nachricht m√ºssen wir 20 Bits nehmen und zur n√§chsten zusammenf√ºhren, schlie√ülich k√∂nnen wir den Nachrichtentext dekodieren. <br><br>  Sehen wir uns einen Block unserer Nachricht an (Leerzeichen waren Addierer, um das Lesen zu erleichtern): <br><br> <code>0 0001010011100010111111110010010 <br> 1 00010100000110110011 11100111001 <br> 1 01011010011001110100 01111011100 <br> 1 11010001110110100100 11011000100 <br> 1 11000001101000110100 10011110111 <br> 1 11100000010100011011 11101110000 <br> 1 00110010111011001101 10011011010 <br> 1 00011001011100010110 10011000010 <br> 1 10101100000010010101 10110000101 <br> 1 00010110111011001101 00000011011 <br> 1 10100101000000101000 11001010100 <br> 1 00111101010101101100 11011111010</code> <br> <br>  "0" -Bit In der ersten Zeichenfolge wird angezeigt, dass es sich um das Adressfeld handelt, und "11" in 20 bis 21 Bit zeigt an, dass die Nachricht wirklich alphanumerisch ist.  Dann nehmen wir einfach 20 Bit von jedem String und f√ºhren ihn zusammen. <br><br>  Dies ist unsere Bitfolge: <br><br> <code>00010100000110110011010110100110011101001101000111011010010011000001101000 <br> 11010011100000010100011011001100101110110011010001100101110001011010101100 <br> 000010010101000101101110110011011010010100000010100000111101010101101</code> <br> <br>  In POCSAG wird 7-Bit-ASCII-Code verwendet, daher wird eine Zeichenfolge in 7 Zeichenbl√∂cke aufgeteilt: <br><br> <code>0001010 0000110 1100110 1011010 0110011 1010011 ...</code> <br> <br>  Nachdem wir versucht haben, es zu dekodieren (ASCII-Tabelle kann leicht im Internet gefunden werden), bekommen wir ... einfach nichts.  √úberpr√ºfen Sie das Handbuch erneut, und hier ist der kleine Satz "ASCII-Zeichen werden von links nach rechts platziert (MSB zu LSB).  Das LSB sendet zuerst. "  Das niedrige Bit sendet also zuerst - f√ºr eine korrekte Decodierung m√ºssen alle Zeichenfolgen umgekehrt werden. <br><br>  Es ist zu langweilig, um es manuell zu machen, also schreiben wir einen Python-Code: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block)</span></span></span><span class="hljs-function">:</span></span> msgs = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> cw <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">16</span></span>): cws = block[<span class="hljs-number"><span class="hljs-number">32</span></span> * cw:<span class="hljs-number"><span class="hljs-number">32</span></span> * (cw + <span class="hljs-number"><span class="hljs-number">1</span></span>)] <span class="hljs-comment"><span class="hljs-comment"># Skip the idle word if cws.startswith("0111101010"): continue if cws[0] == "0": addr, type = cws[1:19], cws[19:21] print(" Addr:" + addr, type) else: msg = cws[1:21] print(" Msg: " + msg) msgs += msg # Split long string to 7 chars blocks bits = [msgs[i:i+7] for i in range(0, len(msgs), 7)] # Get the message msg = "" for b in bits: b1 = b[::-1] # Revert string value = int(b1, 2) msg += chr(value) print("Msg:", msg) print()</span></span></code> </pre><br>  Schlie√ülich erhalten wir diese Sequenz (Bits, Symbolcodes und ASCII-Symbole): <br><br><pre> <code class="plaintext hljs">0101000 40 ( 0110000 48 0 0110011 51 3 0101101 45 - 1100110 102 f 1100101 101 e 1100010 98 b 0101101 45 - 0110010 50 2 0110000 48 0 0110001 49 1 0111001 57 9 0100000 32 0110001 49 1 0110011 51 3 0111010 58 : 0110011 51 3 0110001 49 1 0111010 58 : 0110100 52 4 0110101 53 5 0100000 32 0101010 42 * 0110100 52 4 0110111 55 7 0110110 54 6 0101001 41 ) 0100000 32 1000001 65 A 1010111 87 W 1011010 90 Z</code> </pre><br>  Nach dem Zusammenf√ºhren erhalten wir die Zeichenfolge: "(03-feb-2019 13:31:45 * 476) AWZ".  Wie versprochen, ist es ziemlich menschlich lesbar. <br><br>  Es ist √ºbrigens interessant zu erw√§hnen, dass 7-Bit-ASCII-Codes verwendet werden.  Symbole einiger Alphabete (Deutsch, Kyrillisch usw.) k√∂nnen nicht richtig in 7 Bit codiert werden.  Warum 7 Bits?  Wahrscheinlich hatten die Ingenieure entschieden, dass "7 Bits f√ºr alle ausreichen", wer wei√ü ... <br><br><h2>  Fazit </h2><br>  Es war wirklich interessant zu untersuchen, wie POCSAG funktioniert.  Es ist eines der seltenen Protokolle, die bisher verwendet werden und die buchst√§blich auf dem Blatt Papier dekodiert werden k√∂nnen (und ich werde dies definitiv nicht mit TETRA oder GSM versuchen). <br><br>  Nat√ºrlich wird das POCSAG-Protokoll hier nicht vollst√§ndig beschrieben.  Der wichtigste und interessanteste Teil ist erledigt, andere Sachen sind nicht so aufregend.  Zumindest gibt es keine Capcode-Decodierung und keinen Fehlerkorrekturcode (BCH Check Bits) - es k√∂nnen bis zu 2 falsche Bits in der Nachricht behoben werden.  Aber es gab kein Ziel, hier einen anderen POCSAG-Decoder zu schreiben, es gibt bereits genug davon. <br><br>  F√ºr diejenigen, die echte Dekodierung mit rtl-sdr testen m√∂chten, kann eine Freeware- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PDW-Anwendung</a> verwendet werden.  Es ist keine Installation erforderlich, es reicht nur aus, um den Ton von HDSDR √ºber die Virtual Audio Cable-Anwendung an PDW weiterzuleiten. <br><br>  Das Ergebnis sieht folgenderma√üen aus: <br><br><img src="https://habrastorage.org/webt/-7/g-/ka/-7g-kalvhmaqlv79qju-wmgpglg.jpeg"><br><br>  (Bitte beachten Sie, dass das Dekodieren von √∂ffentlich-rechtlichen Nachrichten in einigen L√§ndern illegal sein kann und trotzdem die Privatsph√§re der Empf√§nger respektiert.) <br><br>  Wenn jemand mehr Informationen zu diesem Thema erhalten m√∂chte, stehen Quellen des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Multimon-ng-</a> Decoders zur Verf√ºgung, der viele Protokolle dekodieren kann, auch POCSAG und FLEX. <br><br>  Danke f√ºrs Lesen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438906/">https://habr.com/ru/post/de438906/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438894/index.html">Warum Webentwicklung auf Go sch√∂ner ist als auf PHP</a></li>
<li><a href="../de438896/index.html">Weinen Sie nicht Gesch√§ft</a></li>
<li><a href="../de438898/index.html">Chrome Reverse und Extension Installation</a></li>
<li><a href="../de438900/index.html">Auf dem Weg zu den physikalischen Prinzipien der biologischen Evolution. Ende + Volltext der √úbersetzung</a></li>
<li><a href="../de438902/index.html">Verwenden von DBREPLICATION beim Reduzieren von Datenbanken unter Microsoft SQL Server</a></li>
<li><a href="../de438908/index.html">Schulung Cisco 200-125 CCNA v3.0. Cisco Certified Network Specialist (CCNA). Tag 1. Netzwerkgrundlagen</a></li>
<li><a href="../de438910/index.html">Samba als ADDC in Solaris 11.4</a></li>
<li><a href="../de438916/index.html">Notizen eines Phytochemikers. Die Kartoffel. Teil drei. "Bullet Fugu" oder SOLANIN</a></li>
<li><a href="../de438920/index.html">Avalonia: erstes Treffen</a></li>
<li><a href="../de438922/index.html">Verkehrsverschl√ºsselung in Direct Connect, Teil 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>