<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍💻 🙎 👩🏿‍🔬 Grundlegendes zum POCSAG-Paging-Protokoll 🐾 🕌 🎻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor langer Zeit, als ein Mobiltelefon etwa 2000 US-Dollar kostete und eine Minute Sprachanruf 50 Cent kostete, waren Pager sehr beliebt. Später wurden...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Grundlegendes zum POCSAG-Paging-Protokoll</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438906/">  Vor langer Zeit, als ein Mobiltelefon etwa 2000 US-Dollar kostete und eine Minute Sprachanruf 50 Cent kostete, waren Pager sehr beliebt.  Später wurden Mobiltelefone billiger, Anrufe und SMS-Preise wurden niedriger und schließlich verschwanden die Pager größtenteils. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8t/7j/xw/8t7jxwauxqbonmzwmweakgmwpvw.jpeg"></div><br>  Für Personen, die zuvor einen Pager besessen haben und wissen möchten, wie er funktioniert, ist dieser Artikel hilfreich. <br><a name="habracut"></a><br><h2>  Hauptinfo </h2><br>  Für Leute, die die Prinzipien vergessen haben oder nach 2000x geboren wurden, werde ich kurz an die Hauptideen erinnern. <br><br>  Das Paging-Kommunikationsnetz hat einige Vorteile, die manchmal schon jetzt wichtig sind: <br><br>  - Es handelt sich um eine einseitige Kommunikation ohne jegliche Bestätigung, sodass das Netzwerk nicht überlastet werden kann. Es hängt nur nicht von einer Reihe von Benutzern ab.  Nachrichten werden kontinuierlich "wie sie sind" nacheinander übertragen, und der Pager erhält die Nachricht, wenn seine Nummer (sogenannter Capcode) der internen Nummer des Geräts entspricht. <br><br>  - Der Empfänger ist sehr leicht (sowohl wörtlich als auch elektronisch) und kann mit 2 AA-Batterien bis zu einem Monat arbeiten. <br><br>  Es gibt zwei grundlegende Standards für die Nachrichtenübertragung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">POCSAG</a> (Post Office Code Standardization Advisory Group) und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FLEX</a> .  Beide Standards sind ziemlich alt, POCSAG wurde 1982 hergestellt und unterstützt Geschwindigkeiten von 512, 1200 und 2400 Bit / s.  Zur Übertragung wird das FSK-Verfahren (Frequency Shift Keying) mit einer Frequenztrennung von 4,5 kHz verwendet.  FLEX ist etwas neuer (wurde von Motorola im Jahr 90 hergestellt), kann mit einer Geschwindigkeit von bis zu 6400 Bit / s arbeiten und sowohl FSK2 als auch FSK4 verwenden. <br><br>  Beide Protokolle sind im Allgemeinen sehr einfach, und vor etwa 20 Jahren wurden PC-Decoder hergestellt, die Nachrichten von einer seriellen Schnittstelle einer Soundkarte decodieren können (es wird keine Verschlüsselung unterstützt, sodass alle Nachrichten von jedem gelesen werden können). <br><br>  Schauen wir uns an, wie es funktioniert. <br><br><h2>  Ein Signal empfangen </h2><br>  Zunächst benötigen wir ein Signal zum Decodieren.  Nehmen wir einen Laptop, einen RTL-SDR-Empfänger und holen ihn uns. <br><br><img src="https://habrastorage.org/webt/vj/ba/2g/vjba2gslgleejthwn_m8ccsvf00.jpeg"><br><br>  Die Frequenzumtastung wird verwendet, daher stellen wir FM ein.  Mit HDSDR speichern wir ein Signal im WAV-Format. <br><br>  Überprüfen wir, was wir bekommen.  Laden der WAV-Datei als Python-Datenarray: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.io <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> wavfile <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt fs, data = wavfile.read(<span class="hljs-string"><span class="hljs-string">"pocsag.wav"</span></span>) plt.plot(data) plt.show()</code> </pre> <br>  Ausgabe (manuell hinzugefügte Bits): <br><br><img src="https://habrastorage.org/webt/pm/ss/y7/pmssy79glsbnfsgxogjd93ylqre.jpeg"><br><br>  Wie wir sehen können, ist es einfach und sogar "mit bloßem Auge" können wir Bits in Paint zeichnen. Es ist leicht zu unterscheiden, wo "0" und wo "1" ist.  Es wird jedoch zu lange dauern, dies manuell zu tun. Es ist an der Zeit, den Prozess zu automatisieren. <br><br>  Nach dem Vergrößern des Diagramms können wir sehen, dass jedes Bit eine Breite von 20 Abtastwerten hat.  Wir haben 24000 Samples pro Sekunde Bitrate-WAV-Datei, daher beträgt die Schlüsselgeschwindigkeit 1200 Bit / s.  Finden wir eine Nulldurchgangsposition - dies ist der Beginn der Bitsequenz.  Fügen Sie auch Markierungen hinzu, um zu überprüfen, ob sich alle Bits an den richtigen Stellen befinden. <br><br><pre> <code class="python hljs">speed = <span class="hljs-number"><span class="hljs-number">1200</span></span> fs = <span class="hljs-number"><span class="hljs-number">24000</span></span> cnt = int(fs/speed) start = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">2</span></span>*cnt): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[p] &lt; - <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> data[p+<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">50</span></span>: start = p <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-comment"><span class="hljs-comment"># Bits frame bits = np.zeros(data.size) for p in range(0, data.size - cnt, cnt): bits[start + p] = 500 plt.plot(bits)</span></span></code> </pre><br>  Wie wir sehen können, stimmt es nicht perfekt überein (Sender und Empfänger haben leicht unterschiedliche Frequenzen), aber es reicht definitiv zum Decodieren aus. <br><br><img src="https://habrastorage.org/webt/hc/s1/lf/hcs1lfxgchl-ngpkyeemhhsgrly.jpeg"><br><br>  Für lange Signale benötigen wir wahrscheinlich einen automatischen Frequenzkorrekturalgorithmus, aber für diese Art von Signalen ist dies nicht kritisch. <br><br>  Der letzte Schritt - wir müssen die WAV-Datei in die Bitfolge übersetzen.  Es ist auch einfach, wir kennen die Länge jedes Bits. Wenn die Datensumme positiv ist, addieren wir "1", andernfalls "0" (schließlich wurde festgestellt, dass ein Signal zurückgesetzt werden muss, sodass 0 und 1 ersetzt wurden). . <br><br><pre> <code class="python hljs">bits_str = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, data.size - cnt, cnt): s = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(p, p+cnt): s += data[p] bits_str += <span class="hljs-string"><span class="hljs-string">"1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-string"><span class="hljs-string">"0"</span></span> print(<span class="hljs-string"><span class="hljs-string">"Bits"</span></span>) print(bits_str)</code> </pre><br>  Ausgabe - richtige Bitfolge (in einem Zeichenfolgenformat), die unsere Nachricht enthält. <br><br> <code>101010101010101010101010101010101010101010101010101010101010101010101010101 <br> 010101010101010101010101010101010101010101010100111110011010010000101001101 <br> 100001111010100010011100000110010111011110101000100111000001100101110111101 <br> 010001001110000011001011101111010100010011100000110010111011110101000100111 <br> 000001100101110111101010001001110000011001011101111010100010011100000110010 <br> 011011110101000100111000001100101110111101010001001110000011001011101111010 <br> 100010011100000110010111011110101000100111000001100101110111101010001001110 <br> ... <br> 111101111</code> <br> <br><h2>  Nur numerische Nachrichten dekodieren </h2><br>  Eine Bitfolge ist viel praktischer als eine WAV-Datei, wir können Daten daraus extrahieren.  Lassen Sie uns zunächst die Daten in 4-Byte-Blöcke aufteilen. <br><br> <code>10101010101010101010101010101010 <br> 10101010101010101010101010101010 <br> 10101010101010101010101010101010 <br> 10101010101010101010101010101010 <br> <br> 01111100110100100001010011011000 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 00001000011011110100010001101000 <br> 10000011010000010101010011010100 <br> <br> 01111100110100100001010111011000 <br> 11110101010001000001000000111000 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 00100101101001011010010100101111</code> <br> <br>  Wir können definitiv ein Muster sehen.  Jetzt müssen wir herausfinden, was jeder Teil bedeutet.  Das POCSAG-Handbuch ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im PDF-Format</a> verfügbar. Hier können Sie die Beschreibung der Datenstrukturen überprüfen. <br><br><img src="https://habrastorage.org/webt/3k/yt/dc/3kytdccgmehfmqstxxli1nt3fpa.png"><br><br>  Es ist jetzt viel klarer.  Der Header enthält einen langen Block "10101010101", mit dem der Pager aus dem Ruhemodus "geweckt" wird.  Die Nachricht selbst enthält die Blöcke Batch-1 ... Batch-N, jeder Block beginnt mit der eindeutigen Sequenz FSC.  Wie wir im Handbuch sehen können, enthält die Zeichenfolge, wenn sie bei "0" beginnt, die Empfängeradresse.  Die gespeicherte Adresse selbst (Capcode) ist der Pager. Wenn sie nicht übereinstimmt, ignoriert der Pager die Nachricht.  Wenn eine Zeichenfolge bei "1" beginnt, enthält sie den Nachrichtentext.  In unserem Beispiel haben wir 2 Zeichenfolgen dieses Typs. <br><br>  Überprüfen wir nicht jeden Block.  Wir können auch Leerlaufcodes sehen - leere Blöcke 01111 ... 0111, sie haben keine nützlichen Informationen.  Nachdem wir sie entfernt haben, erhalten wir nur Folgendes: <br><br> <code>01111100110100100001010011011000 - Frame Sync <br> 00001000011011110100010001101000 - Address <br> 10000011010000010101010011010100 - Message <br> <br> 01111100110100100001010111011000 - Frame Sync <br> 11110101010001000001000000111000 - Message <br> 00100101101001011010010100101111 - Address</code> <br> <br>  Wir müssen herausfinden, was drin ist. <br><br>  Nach Durchsicht des Handbuchs ist klar, dass es zwei Arten von Nachrichten gibt - nur <b>numerische</b> und <b>alphanumerische</b> .  Nur numerische Nachrichten werden als 4-Bit-BCD-Codes gespeichert, sodass 20 Bit 5 Symbole enthalten können (es gibt auch CRC-Bits, die wir derzeit nicht verwenden).  Wenn die Nachricht alphanumerisch ist, wird eine 7-Bit-ASCII-Codierung verwendet.  Diese Nachricht ist zu kurz, daher kann es sich nur um eine reine numerische Nachricht handeln. <br><br>  Aus den Zeichenfolgen 10000011010000010101010011010100 und 11110101010001000001000000111000 können wir diese 4-Bit-Sequenzen erhalten: <br>  <i>1 0000 0110 1000 0010 10101 0011010100</i> - 0h 6h 8h 2h Ah <br>  <i>1 1110 1010 1000 1000 00100 0000111000</i> - Eh Ah 8h 8h 2h <br><br>  Der nächste Schritt besteht darin, die Dekodierungstabelle aus dem Handbuch abzurufen: <br><br><img src="https://habrastorage.org/webt/vb/sj/zl/vbsjzluxbhaeuy_zrefccmqhogw.jpeg"><br><br>  Es ist offensichtlich, dass eine nur numerische Nachricht die Ziffern 0-9, den Buchstaben U ("ugrent"), ein Leerzeichen und zwei Klammern enthalten kann.  Schreiben wir eine kleine Methode, um sie zu dekodieren: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># 16 lines in a batch, each block has a length 32 bits for cw in range(16): cws = block[32 * cw:32 * (cw + 1)] if cws[0] == "0": addr = cws[1:19] print(" Addr:" + addr) else: msg = cws[1:21] print(" Msg: " + msg) size = 4 s = "" for ind in range(0, len(msg), size): bcd_s = msg[ind:ind + size] value = int(bcd_s, 2) symbols = "0123456789*U -)(" s += symbols[value] print(" ", s) print()</span></span></code> </pre><br>  Schließlich erhalten wir eine Nachricht "0682 *) * 882". <br><br>  Es ist schwer zu sagen, was es bedeutet, aber wenn die nur numerischen Nachrichten verwendet werden, braucht es wahrscheinlich jemand. <br><br><h2>  Dekodieren von alphanumerischen Nachrichten </h2><br>  Der nächste und interessantere Schritt besteht darin, alphanumerische Nachrichten zu dekodieren.  Es ist interessanter, weil wir als Ausgabe den vom Menschen lesbaren Text erhalten sollten. <br><br>  Zuerst müssen wir eine Nachricht erneut aufzeichnen, wir werden HDSDR verwenden.  Wir kennen keinen Nachrichtentyp vor dem Dekodieren, daher zeichnen wir nur eine längste Nachricht auf, die wir erhalten können, und hoffen, dass sie Text enthält. <br><br><img src="https://habrastorage.org/webt/lu/ue/sk/luuesk79iv_yalka_pchncpwzoi.jpeg"><br><br>  Nach der Konvertierung von WAV in eine Bitsequenz (siehe Python-Code oben) erhalten wir Folgendes: <br><br><img src="https://habrastorage.org/webt/qb/wt/ud/qbwtud3zptfcwxw3xs0pam7pkr4.jpeg"><br><br>  Einige interessante Dinge, die wir sofort mit bloßem Auge sehen können - zum Beispiel wiederholt sich die Startsequenz 01010101010101 zweimal.  Somit ist diese Nachricht nicht nur länger, sie enthält buchstäblich zwei Nachrichten, die zusammengeführt werden (ein Standard leugnet dies übrigens nicht). <br><br>  Wie wir zuvor festgestellt haben, beginnt jeder Datenblock mit einer Sequenz namens Frame Sync Code (01111100 ...), nachdem 32-Bit-Blöcke gesendet wurden.  Jeder Block kann entweder die Adresse oder den Nachrichtentext speichern. <br><br>  Früher haben wir nur numerische Nachrichten erhalten, jetzt möchten wir ASCII-Nachrichten lesen.  Zuerst müssen wir sie unterscheiden.  Diese Daten werden in einem Feld "Funktionsbits" (Bits 20-21) gespeichert. Wenn beide Bits 00 sind, handelt es sich um eine rein numerische Nachricht. Wenn die Bits 11 sind, handelt es sich um eine Textnachricht. <br><br>  Interessanterweise ist dieses Nachrichtenfeld 20 Bit lang, daher ist es ideal, dort bei einer nur numerischen Nachricht fünf 4-Bit-Blöcke zu platzieren.  Wenn wir jedoch eine 7-Bit-ASCII-Nachricht haben, können wir 20 nicht auf 7 teilen. Es ist möglich vorherzusagen, dass die erste Protokollversion nur numerische Nachrichten unterstützt (vergessen Sie nicht, dass sie 1982 erstellt wurde <s>und wahrscheinlich die ersten Nixie-Tube-Pager konnten nicht mehr anzeigen</s> ), und erst später wurde die Unterstützung für ASCII-Nachrichten hinzugefügt.  Aus den alten Gründen wurde der Framing-Standard nicht geändert, und die Entwickler verwendeten den einfachen Ansatz - sie kombinierten die Bits einfach "wie sie sind" nacheinander.  Von jeder Nachricht müssen wir 20 Bits nehmen und zur nächsten zusammenführen, schließlich können wir den Nachrichtentext dekodieren. <br><br>  Sehen wir uns einen Block unserer Nachricht an (Leerzeichen waren Addierer, um das Lesen zu erleichtern): <br><br> <code>0 0001010011100010111111110010010 <br> 1 00010100000110110011 11100111001 <br> 1 01011010011001110100 01111011100 <br> 1 11010001110110100100 11011000100 <br> 1 11000001101000110100 10011110111 <br> 1 11100000010100011011 11101110000 <br> 1 00110010111011001101 10011011010 <br> 1 00011001011100010110 10011000010 <br> 1 10101100000010010101 10110000101 <br> 1 00010110111011001101 00000011011 <br> 1 10100101000000101000 11001010100 <br> 1 00111101010101101100 11011111010</code> <br> <br>  "0" -Bit In der ersten Zeichenfolge wird angezeigt, dass es sich um das Adressfeld handelt, und "11" in 20 bis 21 Bit zeigt an, dass die Nachricht wirklich alphanumerisch ist.  Dann nehmen wir einfach 20 Bit von jedem String und führen ihn zusammen. <br><br>  Dies ist unsere Bitfolge: <br><br> <code>00010100000110110011010110100110011101001101000111011010010011000001101000 <br> 11010011100000010100011011001100101110110011010001100101110001011010101100 <br> 000010010101000101101110110011011010010100000010100000111101010101101</code> <br> <br>  In POCSAG wird 7-Bit-ASCII-Code verwendet, daher wird eine Zeichenfolge in 7 Zeichenblöcke aufgeteilt: <br><br> <code>0001010 0000110 1100110 1011010 0110011 1010011 ...</code> <br> <br>  Nachdem wir versucht haben, es zu dekodieren (ASCII-Tabelle kann leicht im Internet gefunden werden), bekommen wir ... einfach nichts.  Überprüfen Sie das Handbuch erneut, und hier ist der kleine Satz "ASCII-Zeichen werden von links nach rechts platziert (MSB zu LSB).  Das LSB sendet zuerst. "  Das niedrige Bit sendet also zuerst - für eine korrekte Decodierung müssen alle Zeichenfolgen umgekehrt werden. <br><br>  Es ist zu langweilig, um es manuell zu machen, also schreiben wir einen Python-Code: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block)</span></span></span><span class="hljs-function">:</span></span> msgs = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> cw <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">16</span></span>): cws = block[<span class="hljs-number"><span class="hljs-number">32</span></span> * cw:<span class="hljs-number"><span class="hljs-number">32</span></span> * (cw + <span class="hljs-number"><span class="hljs-number">1</span></span>)] <span class="hljs-comment"><span class="hljs-comment"># Skip the idle word if cws.startswith("0111101010"): continue if cws[0] == "0": addr, type = cws[1:19], cws[19:21] print(" Addr:" + addr, type) else: msg = cws[1:21] print(" Msg: " + msg) msgs += msg # Split long string to 7 chars blocks bits = [msgs[i:i+7] for i in range(0, len(msgs), 7)] # Get the message msg = "" for b in bits: b1 = b[::-1] # Revert string value = int(b1, 2) msg += chr(value) print("Msg:", msg) print()</span></span></code> </pre><br>  Schließlich erhalten wir diese Sequenz (Bits, Symbolcodes und ASCII-Symbole): <br><br><pre> <code class="plaintext hljs">0101000 40 ( 0110000 48 0 0110011 51 3 0101101 45 - 1100110 102 f 1100101 101 e 1100010 98 b 0101101 45 - 0110010 50 2 0110000 48 0 0110001 49 1 0111001 57 9 0100000 32 0110001 49 1 0110011 51 3 0111010 58 : 0110011 51 3 0110001 49 1 0111010 58 : 0110100 52 4 0110101 53 5 0100000 32 0101010 42 * 0110100 52 4 0110111 55 7 0110110 54 6 0101001 41 ) 0100000 32 1000001 65 A 1010111 87 W 1011010 90 Z</code> </pre><br>  Nach dem Zusammenführen erhalten wir die Zeichenfolge: "(03-feb-2019 13:31:45 * 476) AWZ".  Wie versprochen, ist es ziemlich menschlich lesbar. <br><br>  Es ist übrigens interessant zu erwähnen, dass 7-Bit-ASCII-Codes verwendet werden.  Symbole einiger Alphabete (Deutsch, Kyrillisch usw.) können nicht richtig in 7 Bit codiert werden.  Warum 7 Bits?  Wahrscheinlich hatten die Ingenieure entschieden, dass "7 Bits für alle ausreichen", wer weiß ... <br><br><h2>  Fazit </h2><br>  Es war wirklich interessant zu untersuchen, wie POCSAG funktioniert.  Es ist eines der seltenen Protokolle, die bisher verwendet werden und die buchstäblich auf dem Blatt Papier dekodiert werden können (und ich werde dies definitiv nicht mit TETRA oder GSM versuchen). <br><br>  Natürlich wird das POCSAG-Protokoll hier nicht vollständig beschrieben.  Der wichtigste und interessanteste Teil ist erledigt, andere Sachen sind nicht so aufregend.  Zumindest gibt es keine Capcode-Decodierung und keinen Fehlerkorrekturcode (BCH Check Bits) - es können bis zu 2 falsche Bits in der Nachricht behoben werden.  Aber es gab kein Ziel, hier einen anderen POCSAG-Decoder zu schreiben, es gibt bereits genug davon. <br><br>  Für diejenigen, die echte Dekodierung mit rtl-sdr testen möchten, kann eine Freeware- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PDW-Anwendung</a> verwendet werden.  Es ist keine Installation erforderlich, es reicht nur aus, um den Ton von HDSDR über die Virtual Audio Cable-Anwendung an PDW weiterzuleiten. <br><br>  Das Ergebnis sieht folgendermaßen aus: <br><br><img src="https://habrastorage.org/webt/-7/g-/ka/-7g-kalvhmaqlv79qju-wmgpglg.jpeg"><br><br>  (Bitte beachten Sie, dass das Dekodieren von öffentlich-rechtlichen Nachrichten in einigen Ländern illegal sein kann und trotzdem die Privatsphäre der Empfänger respektiert.) <br><br>  Wenn jemand mehr Informationen zu diesem Thema erhalten möchte, stehen Quellen des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Multimon-ng-</a> Decoders zur Verfügung, der viele Protokolle dekodieren kann, auch POCSAG und FLEX. <br><br>  Danke fürs Lesen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438906/">https://habr.com/ru/post/de438906/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438894/index.html">Warum Webentwicklung auf Go schöner ist als auf PHP</a></li>
<li><a href="../de438896/index.html">Weinen Sie nicht Geschäft</a></li>
<li><a href="../de438898/index.html">Chrome Reverse und Extension Installation</a></li>
<li><a href="../de438900/index.html">Auf dem Weg zu den physikalischen Prinzipien der biologischen Evolution. Ende + Volltext der Übersetzung</a></li>
<li><a href="../de438902/index.html">Verwenden von DBREPLICATION beim Reduzieren von Datenbanken unter Microsoft SQL Server</a></li>
<li><a href="../de438908/index.html">Schulung Cisco 200-125 CCNA v3.0. Cisco Certified Network Specialist (CCNA). Tag 1. Netzwerkgrundlagen</a></li>
<li><a href="../de438910/index.html">Samba als ADDC in Solaris 11.4</a></li>
<li><a href="../de438916/index.html">Notizen eines Phytochemikers. Die Kartoffel. Teil drei. "Bullet Fugu" oder SOLANIN</a></li>
<li><a href="../de438920/index.html">Avalonia: erstes Treffen</a></li>
<li><a href="../de438922/index.html">Verkehrsverschlüsselung in Direct Connect, Teil 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>