<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêÅ üî™ üë©‚Äçüë©‚Äçüë¶ Cara praktis untuk memetakan data di Kotlin üîÖ üåó üö¥üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pemetaan data adalah salah satu cara untuk memisahkan kode aplikasi menjadi beberapa lapisan. Pemetaan banyak digunakan dalam aplikasi Android. Contoh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara praktis untuk memetakan data di Kotlin</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485416/"><p>  Pemetaan data adalah salah satu cara untuk memisahkan kode aplikasi menjadi beberapa lapisan.  Pemetaan banyak digunakan dalam aplikasi Android.  Contoh populer dari arsitektur aplikasi mobile Android-CleanArchitecture menggunakan pemetaan baik dalam <a href="https://github.com/android10/Android-CleanArchitecture">versi asli</a> ( <a href="">contoh mapper dari CleanArchitecture</a> ) dan di <a href="https://github.com/android10/Android-CleanArchitecture-Kotlin">versi Kotlin</a> baru ( <a href="">contoh mapper</a> ). </p><br><p>  Pemetaan memungkinkan Anda untuk membuka lapisan-lapisan aplikasi (misalnya, menyingkirkan API), menyederhanakan dan membuat kode lebih visual. </p><br><p>  Contoh pemetaan bermanfaat ditunjukkan pada diagram: </p><br><p><img src="https://habrastorage.org/webt/pf/9e/ew/pf9eewmfjrsylnl1sggjcnermwa.png"></p><a name="habracut"></a><br><p> Tidak perlu untuk mentransfer semua bidang model <code>Person</code> jika di bagian aplikasi yang menarik bagi kita, kita hanya perlu dua bidang: <code>login</code> dan <code>password</code> .  Jika lebih nyaman bagi kita untuk menganggap <code>Person</code> sebagai pengguna aplikasi, setelah peta kita dapat dengan mudah menggunakan model dengan nama yang kita pahami. </p><br><p>  Mari kita pertimbangkan metode pemetaan data yang nyaman dan praktis dengan menggunakan contoh konversi dua model <code>Person</code> dan <code>Salary</code> dari layer <code>Source</code> ke model layer <code>Destination</code> . </p><br><p><img src="https://habrastorage.org/webt/ku/j5/0j/kuj50jhepd2ovlimkbldp0c1ptk.png"></p><br><p>  Sebagai contoh, model disederhanakan.  <code>Person</code> berisi <code>Salary</code> di kedua lapisan aplikasi. </p><br><p>  Dalam kode ini, jika Anda memiliki model yang sama, mungkin ada baiknya merevisi lapisan aplikasi dan tidak menggunakan pemetaan. </p><br><h1 id="metod-1-metody-mappery">  Metode # 1: Metode Mapper </h1><br><p>  Contoh: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonSrc</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> salary: SalarySrc ) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapToDestination</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = PersonDst( name, salary.mapToDestination() <span class="hljs-comment"><span class="hljs-comment">//    Salary ) } class SalarySrc( private val amount: Int ) { fun mapToDestination() = SalaryDst(amount) }</span></span></code> </pre> <br><p>  Metode tercepat dan termudah.  Dialah yang digunakan di CleanArchitecture Kotlin ( <a href="">contoh pemetaan</a> ). </p><br><p>  Nilai plus adalah kemampuan untuk menyembunyikan bidang.  Bidang di <code>PersonSrc</code> bisa bersifat <code>private</code> , kode yang menggunakan kelas <code>PersonSrc</code> tidak tergantung pada mereka, yang berarti bahwa koherensi kode berkurang. </p><br><p>  Kode semacam itu lebih cepat ditulis dan lebih mudah dimodifikasi - deklarasi lapangan dan penggunaannya ada di satu tempat.  Tidak perlu menjalankan proyek dan memodifikasi file yang berbeda saat mengubah bidang kelas. </p><br><p>  Namun, opsi ini lebih sulit untuk diuji.  Metode mapper dari kelas PersonSrc <code>PersonSrc</code> panggilan ke metode mapper, <code>SalarySrc</code> .  Jadi menguji hanya pemetaan <code>Person</code> tanpa pemetaan <code>Salary</code> akan lebih sulit.  Anda harus menggunakan moki untuk ini. </p><br><p>  Masalah lain mungkin muncul jika, sesuai dengan persyaratan arsitektur, lapisan aplikasi tidak dapat saling mengetahui: i.e.  dalam kelas lapisan <code>Src</code> , Anda tidak dapat bekerja dengan lapisan <code>Dst</code> dan sebaliknya.  Dalam hal ini, versi pemetaan ini tidak dapat digunakan. </p><br><p>  Dalam contoh yang dipertimbangkan, lapisan <code>Src</code> bergantung pada lapisan <code>Dst</code> dan dapat membuat kelas-kelas dari lapisan ini.  Untuk situasi yang berlawanan (ketika <code>Dst</code> tergantung pada <code>Src</code> ), opsi dengan metode pabrik statis cocok: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonDst</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> salary: SalaryDst ) { <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( src: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">PersonSrc</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span> = PersonDst(src.name, SalaryDst.fromSource(src.salary)) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SalaryDst</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> amount: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">SalarySrc</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = SalaryDst(src.amount) } }</code> </pre> <br><p>  Pemetaan ada di dalam kelas-kelas lapisan <code>Dst</code> , yang berarti kelas-kelas ini tidak mengungkapkan semua properti dan strukturnya ke kode yang menggunakannya. </p><br><p>  Jika dalam aplikasi satu lapisan bergantung pada yang lain dan data ditransfer antara lapisan aplikasi di kedua arah, logis untuk menggunakan metode pabrik statis bersama dengan metode mapper. </p><br><p>  Ringkasan Metode Pemetaan: </p><br><p>  <code>+</code> Cepat menulis kode, pemetaan selalu ada <br>  <code>+</code> Modifikasi mudah <br>  <code>+</code> Konektivitas kode rendah <br>  <code>-</code> Pengujian Unit Sulit (diperlukan moki) <br>  <code>-</code> Tidak selalu diizinkan oleh arsitektur </p><br><h1 id="metod-2-funkcii-mappery">  Metode 2: Fungsi Mapper </h1><br><p>  Model: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonSrc</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> salary: SalarySrc ) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SalarySrc</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> amount: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonDst</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> salary: SalaryDst ) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SalaryDst</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> amount: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>)</code> </pre> <br><p>  Pemeta: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapPerson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( src: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">PersonSrc</span></span></span></span><span class="hljs-function"><span class="hljs-params">, salaryMapper: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">SalarySrc</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; SalaryDst = ::mapSalary <span class="hljs-comment"><span class="hljs-comment">//  - ) = PersonDst( src.name, salaryMapper.invoke(src.salary) ) fun mapSalary(src: SalarySrc) = SalaryDst(src.amount)</span></span></code> </pre> <br><p>  Dalam contoh ini, <code>mapPerson</code> adalah fungsi urutan yang lebih tinggi sejak itu  dia mendapat mapper untuk model <code>Salary</code> .  Fitur menarik dari contoh spesifik adalah argumen default untuk fungsi ini.  Pendekatan ini memungkinkan kita untuk menyederhanakan kode panggilan dan pada saat yang sama dengan mudah mendefinisikan kembali mapper dalam unit test.  Anda dapat menggunakan metode pemetaan ini tanpa metode default, meneruskannya selalu dalam kode panggilan. </p><br><p>  Menempatkan mapper dan kelas yang digunakannya di berbagai tempat proyek tidak selalu nyaman.  Dengan modifikasi kelas yang sering, Anda harus mencari dan memodifikasi file yang berbeda di tempat yang berbeda. </p><br><p>  Metode pemetaan ini mengharuskan semua properti dengan data kelas dapat dilihat oleh mapper, yaitu  visibilitas <code>private</code> tidak dapat digunakan untuk mereka. </p><br><p>  Ringkasan Metode Pemetaan: </p><br><p>  <code>+</code> Pengujian Unit Sederhana <br>  <code>-</code> Modifikasi yang sulit <br>  <code>-</code> Membutuhkan bidang terbuka untuk kelas data </p><br><h1 id="metod--3-funkcii-rasshireniya">  Metode 3: Fungsi Ekstensi </h1><br><p>  Pemeta: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> PersonSrc.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toDestination</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( salaryMapper: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">SalarySrc</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; SalaryDst = SalarySrc::toDestination ): PersonDst { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PersonDst(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name, salaryMapper.invoke(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.salary)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> SalarySrc.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toDestination</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: SalaryDst { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SalaryDst(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.amount) }</code> </pre> <br><p>  Secara umum, sama seperti fungsi mapper, tetapi sintaks dari panggilan mapper lebih sederhana: <code>.toDestination()</code> . </p><br><p>  Perlu dicatat bahwa fungsi ekstensi dapat menyebabkan perilaku yang tidak terduga karena sifatnya yang statis: <a href="https://kotlinlang.org/docs/reference/extensions.html">https://kotlinlang.org/docs/reference/extensions.html#extensions-are-resolved-statically</a> </p><br><p>  Ringkasan Metode Pemetaan: </p><br><p>  <code>+</code> Pengujian Unit Sederhana <br>  <code>-</code> Modifikasi yang sulit <br>  <code>-</code> Membutuhkan bidang terbuka untuk kelas data </p><br><h1 id="metod-4-klassy-mappery-s-interfeysom">  Metode 4: Kelas Mapper dengan Antarmuka </h1><br><p>  Contoh fungsi memiliki kelemahan.  Mereka memungkinkan Anda untuk menggunakan fungsi apa pun dengan tanda tangan <code>(SalarySrc) -&gt; SalaryDst</code> .  Kehadiran antarmuka <code>Mapper&lt;SRC, DST&gt;</code> akan membantu membuat kode lebih jelas. </p><br><p>  Contoh: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mapper</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SRC, DST</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">data</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">SRC</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: DST } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonMapper</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> salaryMapper: Mapper&lt;SalarySrc, SalaryDst&gt; ) : Mapper&lt;PersonSrc, PersonDst&gt; { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">PersonSrc</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = PersonDst( src.name, salaryMapper.transform(src.salary) ) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SalaryMapper</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Mapper</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SalarySrc, SalaryDst</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">SalarrSrc</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = SalaryDst( src.amount ) }</code> </pre> <br><p>  Dalam contoh ini, <code>SalaryMapper</code> adalah ketergantungan <code>PersonMapper</code> .  Ini memungkinkan Anda mengganti mapper <code>Salary</code> untuk unit test. </p><br><p>  Mengenai pemetaan dalam fungsi, contoh ini hanya memiliki satu kelemahan - kebutuhan untuk menulis kode lebih sedikit. </p><br><p>  Ringkasan Metode Pemetaan: </p><br><p>  <code>+</code> Mengetik lebih baik <br>  <code>-</code> Lebih banyak kode </p><br><p>  Seperti fungsi mapper: </p><br><p>  <code>+</code> Pengujian Unit Sederhana <br>  <code>-</code> Modifikasi yang sulit <br>  <code>-</code> Membutuhkan bidang terbuka untuk kelas data </p><br><h1 id="metod-5-refleksiya">  Metode 5: Refleksi </h1><br><p>  Metode ilmu hitam.  Pertimbangkan metode ini pada model lain. </p><br><p>  Model: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EmployeeSrc</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> <span class="hljs-comment"><span class="hljs-comment">//    ) data class EmployeeDst( val name: String, //  ,    val age: Int //    )</span></span></code> </pre> <br><p>  Mapper: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> EmployeeSrc.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapWithRef</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = with(::EmployeeDst) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> propertiesByName = EmployeeSrc::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">memberProperties</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">associateBy</span></span></span><span class="hljs-class"> </span></span>{ it.name } callBy(parameters.associateWith { parameter -&gt; <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (parameter.name) { EmployeeDst::name.name -&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$firstName</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$lastName</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-comment"><span class="hljs-comment">//    name else -&gt; propertiesByName[parameter.name]?.get(this@mapWithRef) //     } }) }</span></span></code> </pre> <br><p>  Contoh dimata-matai di <a href="https://www.baeldung.com/kotlin-data-objects">sini</a> . </p><br><p>  Dalam contoh ini, <code>EmployeeSrc</code> dan <code>EmployeeDst</code> menyimpan nama dalam format yang berbeda.  Mapper hanya perlu membuat nama untuk model baru.  Kolom yang tersisa diproses secara otomatis, tanpa menulis kode (pilihan <code>else</code> adalah <code>when</code> ). </p><br><p>  Metode ini dapat berguna, misalnya, jika Anda memiliki model besar dengan sekelompok bidang dan bidang pada dasarnya bertepatan untuk model yang sama dari lapisan yang berbeda. </p><br><p>  Masalah besar akan muncul, misalnya, jika Anda menambahkan bidang yang diperlukan ke Dst dan itu tidak terjadi di <code>Src</code> atau di mapper secara tidak sengaja: <code>IllegalArgumentException</code> dalam runtime.  Refleksi juga memiliki masalah kinerja. </p><br><p>  Ringkasan Metode Pemetaan: </p><br><p>  <code>+</code> lebih sedikit kode <br>  <code>+</code> pengujian unit sederhana <br>  <code>-</code> berbahaya <br>  <code>-</code> dapat mempengaruhi kinerja </p><br><h1 id="vyvody">  Kesimpulan </h1><br><p>  Kesimpulan semacam itu dapat diambil dari pertimbangan kami: </p><br><p>  <strong>Metode Mapper</strong> - kode yang jelas, lebih cepat untuk menulis dan memelihara </p><br><p>  <strong>Fungsi</strong> <strong>Mapper</strong> dan <strong>fungsi ekstensi</strong> - hanya menguji pemetaan. </p><br><p>  <strong>Kelas Mapper dengan antarmuka</strong> - hanya menguji pemetaan dan kode yang lebih jelas. </p><br><p>  <strong>Refleksi</strong> - cocok untuk situasi yang tidak standar. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id485416/">https://habr.com/ru/post/id485416/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id485392/index.html">Bot telegram yang memonitor domain</a></li>
<li><a href="../id485394/index.html">Bagaimana infrastruktur Internet lahir</a></li>
<li><a href="../id485396/index.html">Pemeriksaan Kesehatan Regu: Mengukur Kesehatan Tim</a></li>
<li><a href="../id485398/index.html">PostgreSQL Antipatterns: tekan kamus di JOIN berat</a></li>
<li><a href="../id485404/index.html">Kami menyadari efek visual dari film "The Matrix"</a></li>
<li><a href="../id485418/index.html">PHPUnit. "Bagaimana cara menguji controller sialanku", atau menguji keraguan</a></li>
<li><a href="../id485424/index.html">Bagaimana Saya Mengajari Anak-Anak Python</a></li>
<li><a href="../id485426/index.html">Mobil di Belanda: statistik dan informasi untuk 2019</a></li>
<li><a href="../id485428/index.html">Program LyX yang misterius. Bagian 5</a></li>
<li><a href="../id485430/index.html">Editor teks multi-pengguna yang sederhana dengan enkripsi ujung ke ujung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>