<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🎓 👤 🐁 Apa yang saya pelajari dari pengalaman pahit saya (lebih dari 30 tahun dalam pengembangan perangkat lunak) 👩‍❤️‍💋‍👨 👈🏾 🧔🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini adalah kumpulan klinis yang sinis dari apa yang saya pelajari selama 30 tahun dalam pengembangan perangkat lunak. Saya ulangi, beberapa hal sangat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apa yang saya pelajari dari pengalaman pahit saya (lebih dari 30 tahun dalam pengembangan perangkat lunak)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/456862/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ar/g5/ij/arg5ijvdcrjk8bbeulwpruimftq.jpeg" alt="gambar"></div><br>  Ini adalah kumpulan klinis yang sinis dari apa yang saya pelajari selama 30 tahun dalam pengembangan perangkat lunak.  Saya ulangi, beberapa hal sangat sinis, dan sisanya adalah hasil pengamatan panjang di berbagai tempat kerja. <br><a name="habracut"></a><br><h2>  Pengembangan perangkat lunak </h2><br><h4>  Spesifikasi pertama, lalu kode </h4><br>  Jika Anda tidak tahu persis apa yang Anda coba selesaikan, maka Anda tidak tahu kode apa yang harus ditulis. <br>  Pertama, jelaskan bagaimana aplikasi Anda bekerja sebelum Anda memulai pemrograman. <br><br>  <i>"Tanpa persyaratan atau proyek, pemrograman adalah seni menambahkan bug ke file teks kosong." - Louis Sraigley</i> <br><br>  Kadang-kadang bahkan "presentasi singkat" sudah cukup - tidak lebih dari dua paragraf yang menggambarkan apa yang aplikasi Anda lakukan. <br><br>  Ada saat-saat ketika, karena langkah-langkah tidak tertulis, saya menghabiskan lebih banyak waktu melihat kode dan bertanya-tanya apa yang harus dilakukan selanjutnya.  Ini pertanda baik bahwa ini saatnya untuk berhenti dan mendiskusikan situasi dengan rekan kerja.  Atau mungkin memikirkan kembali keputusan itu. <br><br><h4>  Jelaskan langkah-langkahnya sebagai komentar </h4><br>  Jika Anda tidak tahu bagaimana memulainya, jelaskan aliran data tingkat atas di aplikasi Anda, cukup dalam bahasa ibu Anda.  Dan kemudian mengisi kode kosong di antara komentar. <br><br>  Atau bahkan lebih baik: baca setiap komentar sebagai fungsi, lalu tulis fungsi yang melakukan hal itu. <br><br><h4>  Gherkin membantu Anda mewujudkan harapan </h4><br>  Gherkin adalah format deskripsi tes yang prinsipnya berbunyi: "Mengingat bahwa sistem berada dalam keadaan tertentu, jika sesuatu terjadi, maka ini diharapkan."  Jika Anda tidak menggunakan alat pengujian yang memahami Gherkin, itu akan memberi Anda ide bagus tentang apa yang diharapkan dari aplikasi. <br><br><h4>  Tes unit baik, tes integrasi bahkan lebih baik </h4><br>  Di pekerjaan saya saat ini, kami hanya menguji modul dan kelas.  Sebagai contoh, kami menulis tes hanya untuk level presentasi, kemudian kami menulis tes hanya untuk level controller, dan seterusnya.  Ini membantu kita untuk memahami apakah semuanya beres, tetapi tidak memungkinkan kita untuk melihat gambaran keseluruhan dari apa yang terjadi - untuk ini, tes integrasi yang memeriksa perilaku seluruh sistem jauh lebih berguna. <br><br><h4>  Tes Meningkatkan API </h4><br>  Kami memprogram dalam kerangka level: ada tingkat penyimpanan yang harus membuat data kami abadi;  ada tingkat pemrosesan yang entah bagaimana harus mengubah data yang disimpan;  ada lapisan presentasi yang berisi informasi tentang penyajian data, dll. <br><br>  Seperti yang saya katakan, tes integrasi lebih baik, tetapi menguji level itu sendiri memungkinkan Anda untuk lebih memahami bagaimana API mereka terlihat.  Maka Anda akan lebih memahami situasi dengan panggilan sesuatu: apakah API terlalu rumit?  Apakah saya perlu menyimpan begitu banyak data di dekat saya untuk melakukan satu panggilan? <br><br><h4>  Lakukan tes yang dapat Anda jalankan dari baris perintah </h4><br>  Maksud saya, bukan baris perintah itu sendiri yang penting untuk objek apa pun, tetapi pengetahuan Anda tentang perintah untuk menjalankan tes, kemampuan Anda untuk mengotomatisasi eksekusi mereka, yang kemudian dapat Anda terapkan dalam alat integrasi berkelanjutan. <br><br><h4>  Bersiaplah untuk mengirim kode Anda ke keranjang </h4><br>  Banyak dari mereka yang mulai mengembangkan berdasarkan pengujian (TDD) kesal ketika Anda memberi tahu mereka bahwa Anda mungkin perlu menulis ulang banyak kode mereka, termasuk apa yang Anda tulis sendiri. <br><br>  TDD <b>diciptakan</b> untuk melempar kode: semakin banyak Anda mempelajari masalah, semakin Anda memahami bahwa apa yang Anda tulis tidak akan menyelesaikannya dalam jangka panjang. <br><br>  Jangan khawatir tentang ini.  Kode Anda bukan tembok: jika Anda selalu harus membuangnya, ini bukan pemborosan.  Tentu saja, Anda kehilangan waktu menulis kode, tetapi sekarang Anda lebih memahami masalahnya. <br><br><h4>  Bahasa yang baik memiliki tes terintegrasi </h4><br>  Saya yakinkan Anda: jika perpustakaan bahasa standar memiliki kerangka kerja pengujian - meskipun minimal - maka dalam ekosistem terkait tes akan lebih baik daripada dalam bahasa yang tidak memiliki kerangka kerja seperti itu, terlepas dari manfaat kerangka pengujian eksternal untuk bahasa ini. <br><br><h4>  Memikirkan masa depan berarti membuang energi Anda </h4><br>  Ketika pengembang mencoba memecahkan masalah, kadang-kadang mereka mencoba menemukan cara yang akan menyelesaikan semua masalah, termasuk yang mungkin muncul di masa depan. <br><br>  Saya akan memberi tahu Anda satu hal: masalah-masalah masa depan ini tidak akan pernah muncul, dan Anda harus menemani setumpuk besar kode yang tidak akan digunakan secara keseluruhan, atau Anda harus menulis ulang semuanya karena tumpukan thuy kode yang tidak digunakan. <br><br>  Selesaikan masalahnya sekarang.  Kemudian putuskan yang berikut ini.  Lalu yang berikutnya.  Setelah Anda melihat pola yang muncul berdasarkan keputusan ini, dan baru <b>setelah</b> itu Anda akan menemukan "solusi universal" Anda. <br><br><h4>  Dokumentasi adalah pesan cinta masa depan untuk Anda sendiri </h4><br>  Kita semua tahu seperti apa pendarahan itu untuk menulis dokumentasi terkutuk tentang fungsi, kelas, dan modul.  Tetapi memahami jalan pikiran Anda ketika Anda menulis fungsi ini atau itu dapat menyelamatkan pantat Anda di masa depan. <br><br><h4>  Dokumentasi fungsi adalah kontraknya </h4><br>  Mulai menulis dokumentasi, Anda sebenarnya membuat kontrak (mungkin dengan diri Anda sendiri): "Saya mengklaim bahwa fungsi <b>ini</b> melakukan <b>ini</b> , dan itulah fungsinya." <br><br>  Jika nanti Anda menemukan bahwa kode Anda tidak sesuai dengan dokumentasi, maka ini akan menjadi masalah kode, bukan dokumentasi. <br><br><h4>  Jika deskripsi fungsi memiliki "dan", maka ini buruk </h4><br>  Suatu fungsi seharusnya hanya melakukan satu hal.  Ketika Anda menulis dokumentasi untuk itu dan melihat bahwa Anda telah menambahkan "dan", itu berarti bahwa fungsi melakukan sesuatu yang lain.  Bagilah menjadi dua fungsi dan singkirkan "dan". <br><br><h4>  Jangan gunakan nilai boolean sebagai parameter </h4><br>  Saat mengembangkan fungsi, Anda mungkin tergoda untuk menambahkan bendera.  Jangan lakukan ini. <br>  Izinkan saya menjelaskan dengan sebuah contoh: katakanlah Anda memiliki sistem <code>getUserMessages</code> pesan, dan ada fungsi <code>getUserMessages</code> yang mengembalikan semua pesan ke pengguna.  Tetapi ada situasi di mana Anda harus mengembalikan ringkasan singkat dari setiap pesan (misalnya, paragraf pertama), atau seluruh pesan.  Oleh karena itu, Anda menambahkan parameter dalam bentuk flag atau nilai Boolean yang Anda panggil <code>retrieveFullMessage</code> . <br><br>  Sekali lagi, jangan lakukan ini. <br><br>  Karena mereka yang membaca kode Anda akan melihat <code>getUserMessage(userId, true)</code> dan bertanya-tanya tentang apa semua ini? <br><br>  Atau Anda dapat mengubah nama fungsi <code>getUserMessageSummaries</code> dan memasukkan <code>getUserMessagesFull</code> , atau yang serupa, tetapi setiap fungsi hanya akan memanggil <code>getUserMessage</code> asli dengan <code>true</code> atau <code>false</code> - tetapi antarmuka di luar kelas / modul Anda akan jelas. <br>  Tetapi jangan menambahkan flag atau parameter Boolean ke fungsi. <br><br><h4>  Waspadalah terhadap perubahan antarmuka </h4><br>  Dalam paragraf sebelumnya, saya menyebutkan penggantian nama fungsi.  Jika Anda mengontrol sumber tempat fungsi digunakan, maka ini bukan masalah, itu hanya masalah pencarian dan penggantian.  Tetapi jika fungsi ini disediakan oleh perpustakaan, maka Anda tidak perlu mengubah nama sesuai keinginan Anda sendiri.  Ini akan merusak banyak aplikasi lain yang tidak Anda kendalikan dan membuat marah banyak orang. <br><br>  Anda dapat membuat fungsi baru dan menandai fungsi saat ini sebagai yang tidak diinginkan dalam dokumen atau melalui kode.  Dan setelah beberapa rilis Anda akhirnya bisa membunuhnya. <br><br>  Solusi jelek: buat fungsi-fungsi baru, tandai yang saat ini tidak diinginkan dan <b>tambahkan <code>sleep</code> ke awal fungsi</b> untuk memaksa mereka yang menggunakan fungsi lama diperbarui. <br><br><h4>  Bahasa yang baik memiliki dokumentasi bawaan </h4><br>  Jika bahasa menggunakan caranya sendiri mendokumentasikan fungsi, kelas, modul, dan segala sesuatu yang lain, dan bahkan ada generator dokumentasi sederhana, maka semua yang disebutkan akan didokumentasikan dengan baik (tidak hebat, tapi setidaknya bagus). <br><br>  Dan bahasa yang tidak memiliki dokumentasi bawaan sering kali tidak didokumentasikan dengan baik. <br><br><h4>  Bahasa lebih dari sekedar bahasa </h4><br>  Anda menulis dalam bahasa pemrograman dan membuat hal-hal "bekerja".  Tetapi ada jauh dari hanya kata-kata khusus di dalamnya: bahasa memiliki sistem perakitan, sistem manajemen ketergantungan, alat untuk berinteraksi alat, perpustakaan dan kerangka kerja, ada komunitas, ada cara untuk berinteraksi dengan orang-orang. <br><br>  Jangan pilih bahasa untuk kemudahan penggunaan.  Ingatlah bahwa Anda dapat menemukan sintaksisnya sederhana, tetapi dengan memilih bahasa ini, Anda juga memilih cara pembuat bahasa berkomunikasi dengan komunitasnya. <br><br><h4>  Terkadang lebih baik membiarkan aplikasi macet daripada tidak melakukan apa-apa. </h4><br>  Meskipun ini terdengar aneh, lebih baik tidak menambahkan penanganan kesalahan daripada menangkapnya diam-diam dan tidak melakukan apa pun. <br><br>  Jawa memiliki pola yang sangat umum: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { something_that_can_raise_exception() } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { System.out.println(ex); }</code> </pre> <br>  Tidak ada yang dilakukan dengan pengecualian di sini, hanya pesan yang ditampilkan. <br><br>  Jika Anda tidak tahu cara menangani kesalahan, biarkan itu terjadi, jadi setidaknya Anda bisa mengetahui <b>kapan</b> itu terjadi. <br><br><h4>  Jika Anda tahu cara memprosesnya, lakukanlah </h4><br>  Berbeda dengan paragraf sebelumnya: jika Anda tahu kapan pengecualian, kesalahan atau hasil muncul, dan Anda tahu cara menanganinya, maka lakukanlah.  Tampilkan pesan kesalahan, coba simpan data di suatu tempat, buang data yang dimasukkan oleh pengguna untuk digunakan nanti dalam log - cukup <b>proseskan</b> . <br><br><h4>  Jenis berbicara tentang data apa yang Anda miliki </h4><br>  Memori hanyalah urutan byte.  Bytes hanyalah angka dari 0 hingga 255. Yang dimaksud angka-angka ini dijelaskan dalam sistem jenis bahasa. <br><br>  Misalnya, dalam C, tipe karakter (tipe char) dengan nilai 65 mungkin akan menjadi huruf "A", dan int dengan nilai 65 akan menjadi angka 65. <br><br>  Ingatlah hal ini saat bekerja dengan data Anda. <br><br>  Saat menambahkan Booleans, banyak yang lupa memeriksa jumlah nilai <code>True</code> .  Baru-baru ini saya menemukan contoh ini JavaScript: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-literal"><span class="hljs-literal">true</span></span>+<span class="hljs-literal"><span class="hljs-literal">true</span></span> === <span class="hljs-number"><span class="hljs-number">2</span></span>); &gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-literal"><span class="hljs-literal">true</span></span> === <span class="hljs-number"><span class="hljs-number">1</span></span>); &gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br><h4>  Jika data Anda memiliki skema, simpan sebagai struktur </h4><br>  Jika datanya sederhana, misalnya, hanya dua bidang, maka Anda dapat menyimpannya dalam daftar (atau tupel jika bahasa Anda memungkinkan).  Tetapi jika data memiliki skema - format tetap - maka selalu gunakan beberapa struktur atau kelas untuk menyimpannya. <br><br><h4>  Kenali dan jauhi kultus kargo </h4><br>  Gagasan "pemujaan kargo" adalah bahwa jika seseorang melakukannya, maka kita bisa.  Paling sering, kultus kargo hanyalah "pelarian yang mudah" dari masalah: mengapa kita harus berpikir tentang cara menyimpan data pengguna dengan benar jika X telah melakukan ini? <br><br>  "Jika Perusahaan Besar menyimpan data dengan cara ini, maka kita bisa." <br><br>  "Jika Perusahaan Besar menggunakannya, maka itu bagus." <br><br><h4>  "Alat yang tepat untuk tugas itu" adalah cara untuk memaksakan pendapat Anda </h4><br>  Ungkapan "alat yang tepat untuk tugas itu" harus berarti bahwa ada alat yang benar dan salah untuk sesuatu.  Misalnya, menggunakan bahasa atau kerangka kerja tertentu alih-alih bahasa atau kerangka kerja saat ini. <br><br>  Tetapi setiap kali saya mendengar ungkapan ini dari seseorang, orang mendorong bahasa / kerangka kerja favorit mereka dengan cara ini, alih-alih, katakanlah, bahasa / kerangka kerja yang benar. <br><br><h4>  "Alat yang tepat" lebih jelas daripada yang Anda pikirkan </h4><br>  Mungkin sekarang Anda berpartisipasi dalam proyek di mana Anda ingin memproses beberapa teks.  Anda mungkin ingin mengatakan, "Mari kita gunakan Perl karena semua orang tahu bahwa Perl sangat pandai memproses teks." <br><br>  Apa yang Anda lupa: tim Anda berspesialisasi dalam C. Semua orang tahu C, bukan Perl. <br><br>  Tentu saja, jika ini adalah proyek kecil "di lutut", maka dimungkinkan pada Perl.  Dan jika proyek itu penting bagi perusahaan, lebih baik menuliskannya dalam C. <br><br>  PS: Proyek heroik Anda (lebih lanjut tentang ini di bawah) mungkin gagal karena ini. <br><br><h4>  Jangan cocok dengan apa yang ada di luar proyek Anda </h4><br>  Terkadang, alih-alih menggunakan alat ekstensi yang sesuai, orang-orang mulai mengubah pustaka dan kerangka kerja eksternal.  Misalnya, buat perubahan langsung ke WordPress atau Django. <br><br>  Dengan demikian, Anda dapat dengan mudah dan sangat cepat membuat proyek tidak cocok untuk pemeliharaan.  Segera setelah versi baru dirilis, Anda harus menyinkronkan perubahan dengan proyek utama, dan segera Anda akan menemukan bahwa Anda tidak dapat menerapkan perubahan lagi, dan meninggalkan versi lama alat eksternal penuh dengan lubang keamanan. <br><br><h4>  Aliran data mengalahkan pola </h4><br>  Ini pendapat pribadi saya.  Jika Anda memahami bagaimana data harus melalui kode Anda, maka itu akan lebih baik baginya daripada jika Anda menggunakan banyak pola desain. <br><br><h4>  Pola desain digunakan untuk menggambarkan solusi, bukan untuk menemukannya. </h4><br>  Lagi-lagi pendapat pribadi saya.  Menurut pengamatan saya, pola desain yang paling sering digunakan untuk menemukan solusi.  Dan sebagai hasilnya, solusi - dan kadang-kadang masalah itu sendiri - terdistorsi agar sesuai dengan pola. <br><br>  Pertama, selesaikan masalah Anda.  Temukan solusi yang baik, lalu cari di antara pola untuk mengetahui apa yang disebut solusi Anda. <br><br>  Saya telah melihat ini berkali-kali: kita memiliki masalah, polanya dekat dengan solusi yang benar, mari kita gunakan polanya, sekarang kita perlu menambahkan banyak semuanya ke solusi yang benar, sehingga cocok dengan polanya. <br><br><h4>  Pelajari dasar-dasar pemrograman fungsional </h4><br>  Anda tidak perlu mempelajari secara mendalam pertanyaan "apa itu monad" atau "apakah itu berfungsi".  Tapi ingat: Anda tidak harus selalu mengubah data;  buat elemen baru dengan nilai baru (anggap data tidak dapat diubah);  sejauh mungkin, lakukan fungsi dan kelas yang tidak menyimpan status internal (fungsi dan kelas murni). <br><br><h4>  Upaya kognitif adalah musuh keterbacaan. </h4><br>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Disonansi kognitif</a> " adalah ungkapan terselubung "untuk memahami hal ini, saya harus secara bersamaan mengingat dua (atau lebih) hal yang berbeda."  Dan semakin tidak langsung informasi ini, semakin banyak upaya yang Anda perlu habiskan untuk menyimpannya di kepala Anda. <br><br>  Misalnya, menambahkan Boolean untuk menghitung nilai <code>True</code> adalah versi ringan dari disonansi kognitif.  Jika Anda membaca kode dan melihat fungsi <code>sum()</code> , yang, seperti yang Anda tahu, menambahkan semua angka dalam daftar, maka Anda mengharapkan untuk melihat daftar angka;  dan saya bertemu orang-orang yang menggunakan <code>sum()</code> untuk menghitung nilai <code>True</code> dalam daftar Boolean, yang benar-benar membingungkan. <br><br><h4>  Angka ajaib tujuh plus atau minus dua </h4><br>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Angka ajaib</a> " adalah artikel dalam psikologi yang menjelaskan jumlah elemen yang dapat disimpan secara bersamaan dalam memori jangka pendek. <br><br>  Jika Anda memiliki fungsi yang memanggil fungsi yang memanggil fungsi yang memanggil fungsi yang memanggil fungsi yang memanggil fungsi, maka ini hanya neraka bagi pembaca kode Anda. <br><br>  Coba pikirkan: Saya akan mendapatkan hasil dari fungsi ini, meneruskannya ke fungsi kedua, mendapatkan hasilnya, melewati yang ketiga, dll. <br><br>  Selain itu, psikolog saat ini lebih sering berbicara tentang angka ajaib EMPAT, daripada tujuh. <br>  Pikirkan dalam kategori "komposisi fungsi" (misalnya, "Saya akan memanggil fungsi ini, lalu itu, lalu ada ..."), dan bukan dalam kategori "panggilan fungsi" (misalnya, "fungsi ini akan memanggil itu, ia akan memanggil itu. .. "). <br><br><h4>  Pemotongan itu bagus, tetapi hanya dalam jangka pendek </h4><br>  Banyak bahasa, perpustakaan, dan kerangka kerja menawarkan metode pintasan untuk mengurangi jumlah karakter yang Anda ketikkan. <br><br>  Tapi nanti itu kembali kepada Anda, dan Anda akan dipaksa untuk menghapus singkatan dan menulis semuanya secara keseluruhan. <br>  Jadi pertama-tama cari tahu apa yang dilakukan singkatan tertentu sebelum menggunakannya. <br>  Anda tidak perlu menulis semuanya pada awalnya, dan kemudian mengubahnya menjadi singkatan: lakukan apa yang dilakukan singkatan untuk Anda, dan setidaknya Anda akan mengerti apa yang salah, atau bagaimana mengganti sesuatu dengan versi yang tidak disusun. <br><br><h4>  Tahan godaan "mudah" </h4><br>  Tentu saja, IDE akan membantu Anda menyelesaikan secara otomatis banyak hal dan membuatnya mudah untuk membangun sebuah proyek, tetapi apakah Anda bahkan mengerti apa yang terjadi di sana? <br><br>  Apakah Anda tahu cara kerja sistem build Anda?  Jika Anda harus menjalankannya tanpa IDE, dapatkah Anda melakukannya? <br><br>  Apakah Anda ingat nama fungsi tanpa penyelesaian otomatis?  Apakah mungkin untuk memecahkan sesuatu atau mengganti nama sehingga lebih mudah dipahami? <br><br>  Perhatikan apa yang terjadi di bawah tenda. <br><br><h4>  SELALU menggunakan zona waktu dalam tanggal </h4><br>  Saat bekerja dengan tanggal, <b>selalu</b> tambahkan zona waktu.  Anda akan <b>selalu</b> mengalami masalah dengan ketidakcocokan zona waktu di komputer dan di server, dan Anda akan kehilangan banyak waktu untuk debugging, mencoba memahami mengapa antarmuka menampilkan waktu yang salah. <br><br><h4>  SELALU menggunakan UTF-8 </h4><br>  Anda akan memiliki masalah yang sama dengan pengkodean dengan tanggal.  Oleh karena itu, selalu konversikan nilai string ke UTF-8, simpan dalam database di UTF-8, dan kembali dari API Anda ke UTF-8. <br><br>  Anda dapat mengonversi ke penyandian lain, tetapi UTF-8 mengalahkan perang penyandian, jadi cara termudah untuk tetap melakukannya. <br><br><h4>  Mulai bodoh </h4><br>  Salah satu cara untuk melepaskan diri dari IDE adalah dengan "memulai dengan cara bodoh": ambil saja kompiler, editor APAPUN dengan penyorotan kode dan - program, bangun, jalankan. <br><br>  Ya itu tidak mudah.  Tetapi ketika nanti Anda menggunakan semacam IDE, Anda hanya akan memikirkan tombol “Ya, itu meluncurkan itu.”  Inilah yang dilakukan oleh IDE. <br><br><h4>  Log adalah untuk acara, bukan untuk antarmuka pengguna. </h4><br>  Untuk waktu yang lama saya menggunakan log untuk menunjukkan kepada pengguna apa yang terjadi dengan aplikasi tersebut.  Anda tahu, karena lebih mudah menggunakan satu hal daripada dua. <br><br>  Untuk memberi tahu pengguna tentang acara, gunakan formulir keluaran standar.  Untuk pelaporan kesalahan, pesan kesalahan standar.  Dan gunakan log hanya untuk menyimpan data yang dapat Anda proses dengan mudah nanti. <br><br>  Log bukan antarmuka pengguna, tetapi entitas yang harus Anda parsing untuk mengambil informasi pada waktu yang tepat.  Log seharusnya tidak dapat dibaca manusia. <br><br><h4>  Debuggers Berlebihan </h4><br>  Saya telah mendengar keluhan dari banyak editor kode bahwa tanpa debugger itu mengerikan, justru karena mereka tidak punya debugger. <br><br>  Tetapi ketika kode Anda sedang beroperasi, Anda <b>tidak dapat</b> menjalankan debugger favorit Anda.  Sial, Anda bahkan tidak dapat menjalankan IDE favorit Anda.  Tapi penjurnalan ... itu bekerja di mana-mana.  Anda mungkin tidak memiliki informasi yang diinginkan pada saat musim gugur (misalnya, karena tingkat penebangan yang berbeda), tetapi Anda <b>dapat</b> mengaktifkan pencatatan untuk mengetahui alasannya nanti. <br><br>  Saya bungkam tentang fakta bahwa debuggers itu sendiri buruk, mereka hanya tidak memberikan bantuan yang banyak diharapkan dari mereka. <br><br><h4>  Selalu gunakan sistem versi </h4><br>  "Ini hanya aplikasi bodoh saya yang ingin saya pelajari sesuatu" - ini tidak membenarkan kurangnya sistem versi. <br><br>  Jika Anda menggunakan sistem seperti itu sejak awal, akan lebih mudah untuk memutar kembali ketika Anda melakukan kesalahan. <br><br><h4>  Satu perubahan per komit </h4><br>  Saya bertemu orang-orang yang menulis pesan berikut dalam komit: "Memperbaiki masalah 1, 2 dan 3".  Kecuali jika semua masalah ini saling menduplikasi - di mana dua harus sudah ditutup - harus ada tiga komit bukan satu. <br><br>  Patuhi prinsip "satu perubahan per komit."  Dan dengan perubahan yang saya maksud adalah perubahan dalam satu file.  Jika Anda perlu mengubah tiga file, lakukan bersama file-file ini.  Tanyakan kepada diri sendiri: "jika saya membatalkan perubahan ini, apa yang harus hilang?" <br><br><h4>  "Git add -p" akan membantu Anda dengan banyak perubahan </h4><br>  Ini hanya berlaku untuk Git.  Ini memungkinkan Anda untuk menggabungkan sebagian file menggunakan parameter "-p", sehingga Anda hanya dapat memilih perubahan yang terkait satu sama lain, meninggalkan yang lain untuk komit baru. <br><br><h4>  Struktur proyek berdasarkan data atau tipe, bukan fungsionalitas </h4><br>  Sebagian besar proyek menggunakan struktur berikut: <br><br><pre> <code class="plaintext hljs">. +-- IncomingModels | +-- DataTypeInterface | +-- DataType1 | +-- DataType2 | +-- DataType3 +-- Filters | +-- FilterInterface | +-- FilterValidDataType2 +-- Processors | +-- ProcessorInterface | +-- ConvertDataType1ToDto1 | +-- ConvertDataType2ToDto2 +-- OutgoingModels +-- DtoInterface +-- Dto1 +-- Dto2</code> </pre> <br>  Artinya, data terstruktur berdasarkan fungsionalitas (semua model input berada dalam satu direktori atau paket, semua filter berada di direktori atau paket lain, dll.). <br><br>  Ini bekerja dengan baik.  Tetapi ketika Anda menyusun menurut data, jauh lebih mudah untuk membagi proyek menjadi yang lebih kecil, karena pada titik tertentu Anda mungkin perlu melakukan hampir semuanya sama seperti sekarang, dengan hanya perbedaan kecil. <br><br><pre> <code class="plaintext hljs">. +-- Base | +-- IncomingModels | | +-- DataTypeInterface | +-- Filters | | +-- FilterInterface | +-- Processors | | +-- ProcessorInterface | +-- OutgoingModels | +-- DtoInterface +-- Data1 | +-- IncomingModels | | +-- DataType1 | +-- Processors | | +-- ConvertDataType1ToDto1 | +-- OutgoingModels | +-- Dto1 ...</code> </pre> <br>  Sekarang Anda dapat membuat modul yang <b>hanya</b> berfungsi dengan Data1, modul lain yang hanya berfungsi dengan Data2, dll.  Dan kemudian Anda dapat memisahkannya menjadi modul yang terisolasi. <br><br>  Dan ketika Anda perlu membuat proyek lain, juga berisi Data1 dan bekerja dengan Data3, Anda dapat menggunakan kembali sebagian besar kode dalam modul Data1. <br><br><h4>  Buat perpustakaan </h4><br>  Saya sering melihat bagaimana pengembang membuat repositori mega dengan proyek yang berbeda, atau mempertahankan cabang yang berbeda, tidak sehingga mereka adalah lingkungan sementara untuk kemudian bergabung dengan bagian utama, tetapi hanya untuk membagi proyek menjadi bagian-bagian yang lebih kecil (berbicara tentang pemisahan menjadi modul, bayangkan bahwa alih-alih membangun proyek baru yang menggunakan kembali tipe Data1, saya menggunakan cabang dengan fungsi utama yang sama sekali berbeda dan tipe Data3). <br><br>  Mengapa tidak mengalokasikan bagian yang sering digunakan ke perpustakaan yang dapat dihubungkan di proyek yang berbeda? <br><br>  Paling sering, alasannya adalah bahwa orang tidak tahu cara membuat perpustakaan, atau khawatir tentang cara "menerbitkan" perpustakaan ini ke sumber ketergantungan tanpa memberikannya (jadi bukankah lebih baik untuk memahami bagaimana alat manajemen proyek Anda mendapatkan dependensi sehingga Anda dapat membuat repositori dependensi Anda sendiri?). <br><br><h4>  Belajar memantau </h4><br>  Dalam kehidupan sebelumnya, saya menambahkan banyak metrik untuk memahami bagaimana sistem berperilaku: seberapa cepat datang, seberapa cepat, berapa banyak antara input dan output, berapa banyak tugas yang diproses ... <br><br>  Ini benar-benar memberikan ide bagus tentang perilaku sistem.  Apakah kecepatan berkurang?  Untuk memahami, saya dapat memeriksa data apa yang masuk ke sistem.  Apakah pengurangan kecepatan normal di beberapa titik? <br><br>  Faktanya adalah bahwa tanpa pemantauan lebih lanjut, agak aneh untuk mencoba mencari tahu seberapa "sehat" sistem itu.  Pemeriksaan kesehatan dengan gaya "Apakah itu menanggapi permintaan" tidak lagi cocok. <br>  Menambahkan pemantauan dini akan membantu Anda memahami bagaimana sistem berperilaku. <br><br><h4>  Gunakan file konfigurasi </h4><br>  Bayangkan: Anda menulis fungsi yang harus Anda berikan nilai agar dapat mulai memproses (katakanlah, ID akun di Twitter).  Tetapi kemudian Anda perlu melakukan ini dengan dua nilai, dan Anda cukup memanggil fungsi itu lagi dengan nilai yang berbeda. <br><br>  Lebih baik menggunakan file konfigurasi dan menjalankan aplikasi dua kali, dengan dua konfigurasi yang berbeda. <br><br><h4>  Opsi baris perintah terlihat aneh, tetapi mereka berguna </h4><br>  Jika Anda mentransfer sesuatu ke file konfigurasi, Anda dapat membuat hidup Anda lebih mudah dan menambahkan kemampuan untuk memilih dan membuka file. <br><br>  Hari ini, untuk setiap bahasa, ada perpustakaan yang bekerja dengan opsi untuk baris perintah.  Mereka akan membantu Anda membuat utilitas yang baik dengan menyediakan antarmuka pengguna standar untuk semuanya. <br><br><h4>  Bukan hanya komposisi fungsi, tetapi komposisi aplikasi </h4><br>  Unix menggunakan konsep ini: "aplikasi yang melakukan satu hal dan melakukannya dengan baik." <br><br>  Saya mengatakan bahwa Anda dapat menggunakan satu aplikasi dengan dua file konfigurasi.  Dan jika Anda membutuhkan hasil dari kedua aplikasi?  Kemudian Anda dapat menulis aplikasi yang membaca hasil yang kedua, dan menggabungkan semuanya menjadi hasil yang umum. <br><br><h4>  Bahkan ketika menggunakan komposisi aplikasi, mulailah bodoh </h4><br>  Komposisi aplikasi dapat berkembang menjadi layanan mikro (yang bagus), tetapi mereka membutuhkan pemahaman tentang bagaimana aplikasi "berkomunikasi" satu sama lain melalui jaringan (protokol dan sejenisnya). <br>  Tidak perlu mulai dari ini.  Aplikasi dapat menulis dan membaca dari file, jadi lebih mudah.       ,     . <br><br><h4>    </h4><br> ,    .       «,       »,  , «    ,   ». <br><br>   <b></b> ,   .       ,           . <br><br>     ,      <b></b>   ,  ,    .    ,    . .    .              ,    . <br><br><h4>   </h4><br>  ,           ,    .    Lisp,        .  ,  Python   <code>yield</code> ,         ,      ,     .     ,   ,      ,   ,  . <br><br><h2>      </h2><br><h4>        </h4><br>     ,       ,      .    ,     «     », «   »  .. <br><br>     <b></b>     ,        . <br><br><h4>        ,     </h4><br>        ,           . <br><br> ,    ,    «»: , ,     ,  . ,    ,     . ,      ,       ,     . <br><br>       ,     ,      . ,    . <br><br><h4>    </h4><br>        ,    .      («         ?»),     . <br><br><h4> …     Google </h4><br>   ,   .  ,  Google     ,  .         ,    , Google        ,    . <br><br><h4>  C/C++      — K&amp;R </h4><br>    .     :) <br><br><h4>  Python      — PEP8 </h4><br>       PEP8.  ,        . <br><br><h4>    </h4><br> ,      ? <code>sleep()</code> . <br><br>    ?     ? <br><br>  ,   .  <code>sleepForSecs</code>  <code>sleepForMs</code>  ,   ,  <code>sleep</code> . <br><br>   ,          . <br><br>       «Zen of Python»,      . <br><br><h4>   ,     </h4><br>       ,      .      ,     - .   -     ,      ,    ,       . <br><br> <i>«   ,        » —  .</i> <br><br>      :      ,    —  .      ,        . <br><br>  ,   Java  ,     Rust.  ,   Spring   ,      ++. <br><br><h4>    </h4><br>   ,        —    ,  «»  . <br><br>  ,      . <br><br><h4>        —    </h4><br>  ,   , -      . <br><br>        —    , —       . <br><br><h4>    « ,        » </h4><br>       «  »  « ».    ,         ,   ,        ,      . <br><br>       ,               . <br><br><h4>       ,    </h4><br>    ,        , ,   ,       . <br><br>     . <br><br>         (      «»),  ,    ,   . ,    AWS SQS (  ),  ,     ,          RabbitMQ. <br><br>    -  ,     ,    ,       . <br><br><h2>  </h2><br><h4>   ,   </h4><br> ,       . ,       .   ,   . <br><br>        ( ,    ).   ,    ,     ,     . <br><br><h4>    ,    </h4><br>   - ,   ,     .  ,       ,   <b></b>    ,       ,   . <br><br>     ,      .   ,        ,  ,    « »   « ,    ». <br><br>  ,            . <br><br><h4>   </h4><br>    «». ,     . ,      . ,   ,    . ,     . <br><br>       : «,  ,   ,     ,   ».       ,   . <br><br><h4>      . </h4><br>  . - .      «»  «». <br><br>     ,  ,  ,        .     ,     . <br><br><h4>  ,   ,     </h4><br>          .  ,     ,  -   ,   . <br><br>  Jangan lakukan ini. <br><br> -           ,   <b> </b> . <br><br><h4>       </h4><br>   - ,   .    ,    . <br><br>    ,    .     . <br><br><h4>      -   ,       </h4><br>     :   - ,        .  ,      . <br><br> «,      ,      » —      ,      . <br><br><h4>     </h4><br>    , ,   .     .  ,      -   .   .  . <br><br>     ,   ,   . ,   ,  ,   -  .  ,  ,       . <br><br><h4>    ,      </h4><br>    « ». <br><br>    - ,    ,    ,    .    : «   ,   ,   ». <br><br>  <b></b>     . <br><br><h4>          </h4><br>    ,      ,     ,        .    . <br><br>   ,      . <br><br><h4>  «» </h4><br> «» —      . ,  -   « »,          - . <br><br>    ,     ,   ,     .      ,    ,    ,    . <br><br>          . <br><br><h4> ,   ,    «» </h4><br>  . - : «,      ,    ?» <br><br>  ,   .      ,     ,    (,    ,   ). <br><br><h4>     ,    —   </h4><br>    ,          -,   ,     ,  ,   (   ). <br><br> …   ,     - ,   ,  « <b></b>  !». <br><br><h4>  :      </h4><br> «»   ,     , ,    ,      .     ,  ,    . <br><br>         ,   /,     . <br><br>   ,   . <br><br>      -   . <br><br><h4>   « »  « » </h4><br>     : - ,     ,   ,       . <br><br>  « » —  ,       . <br><br>   . <br><br><h4> ,    </h4><br>   ,    ,  - ,     . <br><br> -     . <br><br>      ,        . <br><br>   ,    ,    . <br><br> ,    ,    ,        . <br><br> …              . <br><br><h4>  IT   </h4><br>     . <br><br> ,     ,     15 ,      3-4  . <br><br>         . <br><br>      . <br><br>  ,     ,  , -        ,     ,       ,   ,        ,      ,         . <br><br><h4>     </h4><br>        .     ,          ,    URL,     . <br><br><h4> Trello —     ,    </h4><br>      «  ,  »,       . <br><br><h4>        ,   </h4><br>   ,   «   ,    »,  «  ,      ». <br><br>  .     .    ,  - . <br><br>        ,   . <br><br>   . <br><br>  ,          ,   . <br><br><h4> …    </h4><br>      ,      . , « ». -  « »,  ,        . <br><br>  .     . <br><br><h4>       </h4><br>    Github   «,  » .   ,  -  . <br><br>       . <br><br>      :           Python,   ,    Java  Python,    . <br><br><h4>   «,    » </h4><br>   ,  ,  ,  «,    ». <br><br>    -        ,  ,    -    .      ,     . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456862/">https://habr.com/ru/post/id456862/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456852/index.html">Sederhanakan menggambar Bendera Enum dalam Persatuan</a></li>
<li><a href="../id456854/index.html">Dari UI-kit hingga sistem desain</a></li>
<li><a href="../id456856/index.html">Cara memilih tempat terbaik untuk membuka cabang dan memvisualisasikan hasil di peta</a></li>
<li><a href="../id456858/index.html">Ansible: pembaruan dalam solusi utama untuk mengotomatisasi dunia Anda</a></li>
<li><a href="../id456860/index.html">Sakelar Wawasan Jaringan Ekstrim Atau mengapa pada switch mesin virtual</a></li>
<li><a href="../id456866/index.html">Ketika mereka akan membuat "cheburnet" dari Internet: ikhtisar proyek</a></li>
<li><a href="../id456868/index.html">3CX SBC Remote Connection Manager baru di V16 Perbarui 2 Beta</a></li>
<li><a href="../id456870/index.html">Cara menghasilkan uang dari saham tanpa spekulasi: 5 perusahaan dengan dividen tinggi</a></li>
<li><a href="../id456872/index.html">Menyaring perangkat elektronik di perbatasan - kebutuhan atau pelanggaran hak asasi manusia?</a></li>
<li><a href="../id456876/index.html">Sertifikasi ISTQB: Manfaat dan Fitur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>