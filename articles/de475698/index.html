<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍒 🚏 ✍🏼 Down the Rabbit Hole: Eine Geschichte von einem Varnishreload-Fehler - Teil 1 🤷 ⬛️ 👨🏻‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nachdem er in den letzten 20 Minuten die Tastatur gedrückt hat, als würde er für sein Leben tippen, dreht sich Ghostinushanka mit einem halb verrückte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Down the Rabbit Hole: Eine Geschichte von einem Varnishreload-Fehler - Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475698/"><p> Nachdem er in den letzten 20 Minuten die Tastatur gedrückt hat, als würde er für sein Leben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">tippen,</a> dreht sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Ghostinushanka</a> mit einem halb verrückten Blick in den Augen und einem schlauen Lächeln zu mir. „Alter, ich glaube, ich habe es verstanden. </p><br><p> Sehen Sie sich das an “- als er auf eines der Zeichen auf dem Bildschirm zeigt -„ Ich wette, mein roter Hut, wenn wir hinzufügen, was ich Ihnen gerade hierher geschickt habe “- als er auf eine andere Stelle im Code zeigt -„ wird es geben kein Fehler mehr. " <br>  Etwas verwirrt und müde <code>systemctl varnish reload</code> ich den Sed-Ausdruck, den wir seit einiger Zeit herausfinden, speichere die Datei und <code>systemctl varnish reload</code> das <code>systemctl varnish reload</code> .  Fehlermeldung weg ... </p><br><p>  "Diese E-Mails, die ich mit dem Kandidaten ausgetauscht habe", fährt mein Kollege fort, während sich sein Lächeln in ein breites und echtes Grinsen verwandelt. "Mir ist plötzlich aufgefallen, dass dies genau dasselbe Problem ist!" </p><a name="habracut"></a><br><h3 id="how-it-all-began">  Wie alles begann </h3><br><p>  <em>Dieser Artikel setzt voraus, dass Sie mit bash, awk und systemd vertraut sind.</em>  <em>Einige Lackkenntnisse sind von Vorteil, aber nicht erforderlich.</em> <em><br></em>  <em>Zeitstempel in Beispiel-Snippets wurden überarbeitet.</em> <em><br></em>  <em>Zusammen mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">ghostinushanka</a> verfasst.</em> </p><br><p>  An einem weiteren warmen Herbstmorgen scheint die Sonne durch die wandgroßen Fenster, eine Tasse frisch gebrühte koffeinhaltige Flüssigkeit steht neben der Tastatur, Kopfhörer sprechen die geliebte Symphonie von Klängen, die das Rascheln mechanischer Tastaturen überdecken, und der erste Eintrag im Rückstand auf der Kanbantafel wird spielerisch der Titel des schicksalhaften Tickets angezeigt <code>sh: echo: I/O error</code> „Untersuche das Laden von Daten <code>sh: echo: I/O error</code> bei der Bereitstellung“.  Immer wenn es um Lack geht, gibt es keinen Platz für Fehler, auch wenn dieser keine wirklichen Probleme zu verursachen schien. </p><br><p>  Für diejenigen unter Ihnen, die mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">varnishreload</a> nicht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vertraut sind</a> , ist es einfach ein Shell-Skript, das zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erneuten</a> Laden der Konfiguration - auch VCL genannt - des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Varnish-Caching-Servers verwendet wird</a> . </p><br><p>  Wie der Titel des Tickets andeutet, ist der Fehler auf einem der Staging-Computer aufgetreten, und ich war mir ziemlich sicher, dass das Varnish-Routing in der Staging-Umgebung funktioniert. Daher war meine Annahme, dass dies ein geringfügiges Problem sein muss.  Nur eine benutzerfreundliche Ausgabenachricht, die in einen geschlossenen Stream geschrieben wird.  Ich greife nach dem Ticket und bin fest davon überzeugt, dass ich es in weniger als 30 Minuten als erledigt markieren kann. Ich klopfe mir auf den Rücken, um eine weitere weltliche Aufgabe zu erledigen und mich wieder wichtigeren Dingen zuzuwenden. </p><br><h3 id="hitting-the-wall-at-200kph">  Mit 200 km / h gegen die Wand </h3><br><p>  Beim Öffnen der Datei <code>varnishreload</code> auf einem der betroffenen Server unter Debian Stretch <code>varnishreload</code> ich fest, dass ein Shell-Skript weniger als 200 Zeilen lang ist.  Wenn ich es kurz durchlese, sehe ich nichts Gefährliches, das mich daran hindern würde, das Skript immer wieder vom Terminal aus auszuführen.  Immerhin ist dies eine Inszenierung, auch wenn sie kaputt geht, niemand wird sich beschweren, na ja ... nicht zu viel.  Ich starte das Skript und beobachte, nur um herauszufinden, dass keine Fehler zu sehen sind.  Ein paar weitere Durchläufe stellen sicher, dass ich den Fehler nicht ohne zusätzlichen Aufwand reproduzieren kann, und ich beginne Pläne zu entwickeln, um die Umgebung des Skripts zu optimieren und zu verbessern.  Hilft es überhaupt, STDOUT für das Skript zu schließen (mit <code>&gt; &amp;-</code> )?  Oder stderr?  Weder noch. </p><br><p>  Offensichtlich beeinträchtigt systemd die Umwelt auf irgendeine Weise, aber wie und warum?  Ich <code>varnishreload</code> vim und bearbeite das <code>varnishreload</code> des Systems, <code>varnishreload</code> <code>set -x</code> direkt unter dem <code>varnishreload</code> hinzu und hoffe, dass die detaillierte Skriptausgabe etwas Licht ins Dunkel bringt. </p><br><p>  Da die Datei gepatcht ist, lade ich den Firnis neu, nur um zu sehen, dass die Änderung das Skript vollständig zerstört hat ... Die Ausgabe ist ein komplettes Durcheinander, in dem jede Menge C-Code angezeigt wird und der standardmäßige Scrollback-Puffer nicht ausreicht, um herauszufinden, woher er kommt.  Ich fühle mich verwirrt.  Könnte das Festlegen der Debug-Option für das Shell-Skript das aufgerufene Programm beschädigen?  Nein, kann nicht sein.  Ein Fehler in der Shell?  In meinem Kopf laufen mehrere mögliche Szenarien wild in verschiedene Richtungen.  Eine Tasse koffeinhaltiges Getränk ist sofort fertig, schnelle Fahrt in die Küche zum Nachfüllen und schon geht es wieder los.  Ich öffne die Datei und schaue mir den shebang genau an: <code>#!/bin/sh</code> . </p><br><p>  Aber <code>/bin/sh</code> ist sicherlich nur ein Symlink zu bash, so dass das Skript im POSIX-kompatiblen Modus interpretiert wird, oder?  Falsch!  Die nicht interaktive Standard-Shell unter Debian ist dash, und genau darauf zeigt <code>/bin/sh</code> . </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ls -l /bin/sh lrwxrwxrwx 1 root root 4 Jan 24 2017 /bin/sh -&gt; dash</span></span></code> </pre> <br><p>  Wenn auch nur zum Debuggen, habe ich den shebang in <code>#!/bin/bash</code> geändert, die <code>set -x</code> und es erneut versucht.  Zum Schluss noch ein vernünftiger Fehler beim nächsten Nachladen des Lacks: </p><br><pre> <code class="bash hljs">Jan 01 12:00:00 hostname varnishreload[32604]: /usr/sbin/varnishreload: line 124: <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span>: write error: Broken pipe Jan 01 12:00:00 hostname varnishreload[32604]: VCL <span class="hljs-string"><span class="hljs-string">'reload_20190101_120000_32604'</span></span> compiled</code> </pre> <br><p>  Linie 124, jetzt reden wir! </p><br><pre> <code class="bash hljs">114 <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_vcl_file</span></span></span></span>() { 115 VCL_SHOW=$(varnishadm vcl.show -v <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$VCL_NAME</span></span></span><span class="hljs-string">"</span></span> 2&gt;&amp;1) || : 116 VCL_FILE=$( 117 <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$VCL_SHOW</span></span></span><span class="hljs-string">"</span></span> | 118 awk <span class="hljs-string"><span class="hljs-string">'$1 == "//" &amp;&amp; $2 == "VCL.SHOW" {print; exit}'</span></span> | { 119 <span class="hljs-comment"><span class="hljs-comment"># all this ceremony to handle blanks in FILE 120 read -r DELIM VCL_SHOW INDEX SIZE FILE 121 echo "$FILE" 122 } 123 ) || : 124 125 if [ -z "$VCL_FILE" ] 126 then 127 echo "$VCL_SHOW" &gt;&amp;2 128 fail "failed to get the VCL file name" 129 fi 130 131 echo "$VCL_FILE" 132 }</span></span></code> </pre> <br><p>  Aber wie sich herausstellt, ist die Linie 124 ziemlich ereignislos.  Ich konnte nur vermuten, dass der Fehler als Teil des in Zeile 116 ausgeführten mehrzeiligen Befehls erzeugt wurde. </p><br><p>  Was erzeugt die obige Subshell überhaupt, um sie in der Variablen VCL_FILE zu speichern?  Im ersten Teil sendet es den Inhalt der <code>VCL_SHOW</code> Variablen, die in der Zeile 115 erstellt wurde, in die Pipe.  Was passiert dann dort? </p><br><p>  Zunächst wird <code>varnishadm</code> , ein Standardbestandteil einer Varnish-Installation, mit der Varnish konfiguriert wird, ohne dass ein Neustart erforderlich ist.  Mit dem Unterbefehl <code>vcl.show -v</code> wird die gesamte durch <code>${VCL_NAME}</code> angegebene VCL-Konfiguration an <code>${VCL_NAME}</code> ausgegeben. </p><br><p>  Um die aktuell aktive VCL-Konfiguration sowie mehrere frühere Versionen des <code>varnishadm vcl.list</code> , die sich noch im Speicher befinden, können Sie einen anderen Befehl <code>varnishadm vcl.list</code> , dessen Ausgabe der folgenden ähnelt: </p><br><pre> <code class="plaintext hljs">discarded cold/busy 1 reload_20190101_120000_11903 discarded cold/busy 2 reload_20190101_120000_12068 discarded cold/busy 16 reload_20190101_120000_12259 discarded cold/busy 16 reload_20190101_120000_12299 discarded cold/busy 28 reload_20190101_120000_12357 active auto/warm 32 reload_20190101_120000_12397 available auto/warm 0 reload_20190101_120000_12587</code> </pre> <br><p>  Die Variable <code>${VCL_NAME}</code> wird an anderer Stelle im <code>varnishreload</code> Skript auf den Namen der derzeit aktiven VCL gesetzt, sofern vorhanden.  In diesem Fall wäre das "reload_20190101_120000_12397". </p><br><p>  Toll, also enthält <code>${VCL_SHOW}</code> jetzt eine vollständige Konfiguration für Varnish, die bisher <code>${VCL_SHOW}</code> einfach war.  Jetzt habe ich endlich verstanden, warum die Dash-Ausgabe mit <code>set -x</code> so kaputt zu sein schien - sie enthielt den Inhalt der resultierenden Lackkonfiguration. </p><br><p>  Wichtig hierbei ist, dass die vollständige VCL-Konfiguration häufig aus mehreren Dateien zusammengefügt wird.  Mit Kommentaren im C-Stil wird festgelegt, wo Konfigurationsdateien in andere Konfigurationsdateien eingefügt wurden. Genau darum geht es in der nächsten Zeile des Code-Snippets. </p><br><p>  Die Syntax der dateibezogenen Kommentare hat das folgende Format </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// VCL.SHOW &lt;NUM&gt; &lt;NUM&gt; &lt;FILENAME&gt;</span></span></code> </pre> <br><p>  Die Zahlen sind hier nicht wichtig, was uns interessiert, ist der Dateiname. </p><br><p>  Was in aller Welt passiert also in der Menge der Befehle, die in Zeile 116 beginnen? <br>  Lass es uns auseinander nehmen. <br>  Der Befehl besteht aus vier Teilen: </p><br><ol><li>  Ein einfaches <code>echo</code> , das den Wert von <code>${VCL_SHOW}</code> <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$VCL_SHOW</span></span></span><span class="hljs-string">"</span></span></code> </pre> </li><li>  <code>awk</code> sucht nach einer Zeile (Datensatz), in der das erste Feld '//' und das zweite "VCL.SHOW" ist. <br>  Awk wird angewiesen, die erste Zeile zu drucken, die mit diesen Mustern übereinstimmt, und die Verarbeitung dann sofort zu beenden. <br><pre> <code class="bash hljs">awk <span class="hljs-string"><span class="hljs-string">'$1 == "//" &amp;&amp; $2 == "VCL.SHOW" {print; exit}'</span></span></code> </pre> </li><li>  Ein Codeblock, der die durch Leerzeichen getrennten Felder in fünf Variablen einliest.  Die fünfte Variable FILE erhält den Rest der Zeile.  Schließlich gibt ein letztes Echo den Inhalt der Variablen <code>${FILE}</code> . <br><pre> <code class="bash hljs">{ <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> -r DELIM VCL_SHOW INDEX SIZE FILE; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$FILE</span></span></span><span class="hljs-string">"</span></span> }.</code> </pre> </li><li>  Da die Schritte 1 bis 3 alle in eine Subshell eingeschlossen sind, wird die Ausgabe von <code>$FILE</code> in der Variablen <code>VCL_FILE</code> . </li></ol><br><p>  Wie aus dem Kommentar in Zeile 119 hervorgeht, dient diese Vorgehensweise einem einzigen Zweck: dem zuverlässigen Behandeln des Falls, in dem VCL auf Dateinamen mit Leerzeichen verweist. </p><br><p>  Ich habe die ursprüngliche Verarbeitungslogik für <code>${VCL_FILE}</code> und versucht, die Befehlskette zu optimieren, aber ohne vernünftiges Ende.  Alles hat in meiner Shell funktioniert, aber nie als Dienst ausgeführt. </p><br><p>  Es scheint, dass der Fehler bei meiner Ausführung überhaupt nicht reproduzierbar ist - mittlerweile sind die geschätzten 30 Minuten sechs Mal vergangen, und eine neue Aufgabe mit hoher Priorität hat alles beiseite gelegt.  Der Rest der Woche war ziemlich voll mit verschiedenen Aufgaben, die beiden Ausnahmen waren ein internes Gespräch unseres Teams über die Verwendung von <code>sed</code> und ein Interview mit einem vielversprechenden Kandidaten.  Das Problem, dass der <code>varnishreload</code> Fehler verschwunden ist, ist für die ganze Zeit verloren gegangen. </p><br><h3 id="your-so-called-sed-fu-is-really-quite-pathetic">  Dein sogenanntes Sed-Fu ... ist wirklich ... ziemlich erbärmlich </h3><br><p>  Einer der folgenden Wochentage war ziemlich frei, also nahm ich die Aufgabe wieder auf.  Ich hatte gehofft, dass vielleicht immer noch ein Hintergrundprozess in meinem Gehirn das Problem in den Griff bekommt und ich es endlich knacken kann. </p><br><p>  Da das letzte Mal das Verbiegen des Codes nicht geholfen hat, habe ich mich für eine Neufassung von Zeile 116 entschieden. Der vorhandene Code war sowieso verrückt.  Es ist absolut nicht nötig, hier zu <code>read</code> . </p><br><p>  Schauen Sie sich den Fehler noch einmal an: <br>  <code>sh: echo: broken pipe</code> - Echo ist an zwei Stellen in diesem Befehl, aber ich vermute, dass der erste ein wahrscheinlicherer Täter (oder Komplize) ist.  Awk schafft auch kein Vertrauen.  Nun, falls es sich wirklich um die <code>awk | {read; echo}</code> <code>awk | {read; echo}</code>  <code>awk | {read; echo}</code> construct verursacht all diese Probleme, warum nicht etwas anderes verwenden?  Awk ist auf diesem Einzeiler nicht wirklich voll ausgelastet, und dann ist da noch dieser Überschuss. </p><br><p>  Da wir in der <code>sed</code> Woche ein internes Gespräch über <code>sed</code> , wollte ich meine neu erworbenen Fähigkeiten ausprobieren und das <code>echo | awk | { read; echo }</code> optimieren <code>echo | awk | { read; echo }</code>  in ein einfacheres <code>echo | sed</code>  <code>echo | sed</code> .  Obwohl dies definitiv nicht der richtige Weg ist, um das Debuggen in Angriff zu nehmen, dachte ich, ich würde zumindest mein Sed-Fu ausprobieren und vielleicht etwas Neues über das Problem in diesem Prozess erfahren.  Dabei habe ich meinen Kollegen - den Autor des Sed-Talks - gebeten, mir zu helfen, einen effizienteren Sed-Befehl zu entwickeln. </p><br><p>  Ich habe die Datei <code>varnishadm vcl.show -v "$VCL_NAME"</code> in eine Datei geschrieben, damit ich mich auf das Schreiben von sed konzentrieren kann, ohne den ganzen Aufwand für das Neuladen von Diensten. </p><br><p>  Eine kurze Einführung, wie genau sed Prozesse eingegeben werden, findet sich in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">seinem GNU-Handbuch</a> .  In sed sources wird das Zeichen <code>\n</code> explizit als Zeilentrennzeichen angegeben. </p><br><p>  Nach mehreren Iterationen und Eingaben meines Kollegen haben wir einen sed-Ausdruck erstellt, der genau das gleiche Ergebnis wie die ursprüngliche Zeile 116 liefert. </p><br><p>  Lassen Sie uns hier eine Beispiel-Eingabedatei erstellen, </p><br><pre> <code class="bash hljs">&gt; cat vcl-example.vcl Text // VCL.SHOW 0 1578 file with 3 spaces.vcl More text // VCL.SHOW 0 1578 file.vcl Even more text // VCL.SHOW 0 1578 file with TWOspaces.vcl Final text</code> </pre> <br><p>  Es ist aus der obigen Beschreibung möglicherweise nicht ersichtlich, aber wir interessieren uns nur für den ersten <code>// VCL.SHOW</code> Kommentar, und bei der Eingabe sind möglicherweise mehrere vorhanden.  Genau deshalb gibt awk nach dem ersten Match auf. </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># step 1, capture just the comment lines # using sed capability to specify delimiter character with '\#' instead of the commonly used '/' so there is no need to escape slashes themselves # and the “address” capability defined as regex “// VCL.SHOW” to search for lines with specific pattern # -n flag makes sure that the sed does not print all as it does by default (see above link) # -E switches to the extended regex &gt; cat vcl-processor-1.sed \#// VCL.SHOW#p &gt; sed -En -f vcl-processor-1.sed vcl-example.vcl // VCL.SHOW 0 1578 file with 3 spaces.vcl // VCL.SHOW 0 1578 file.vcl // VCL.SHOW 0 1578 file with TWOspaces.vcl # step 2, only print out the file name # using the “substitute” command with regex capture groups to print just that group # and this is done only for the matches of the previous search &gt; cat vcl-processor-2.sed \#// VCL.SHOW# { s#.* [0-9]+ [0-9]+ (.*)$#\1# p } &gt; sed -En -f vcl-processor-2.sed vcl-example.vcl file with 3 spaces.vcl file.vcl file with TWOspaces.vcl # step 3, make sure to only get the first result # same as with the awk before, add an immediate exit after the first processed match is printed &gt; cat vcl-processor-3.sed \#// VCL.SHOW# { s#.* [0-9]+ [0-9]+ (.*)$#\1# p q } &gt; sed -En -f vcl-processor-3.sed vcl-example.vcl file with 3 spaces.vcl # step 4, wrap it up into a one-liner using the colon to separate commands &gt; sed -En -e '\#// VCL.SHOW#{s#.* [0-9]+ [0-9]+ (.*)$#\1#p;q;}' vcl-example.vcl file with 3 spaces.vcl</span></span></code> </pre> <br><p>  Der Inhalt des varnishreload-Skripts würde also ungefähr so ​​aussehen: </p><br><pre> <code class="bash hljs">VCL_FILE=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(echo "$VCL_SHOW" | sed -En '\#// VCL.SHOW#{s#.*[0-9]+ [0-9]+ (.*)</span></span></span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$#</span></span></span><span class="hljs-string">\1#p;q;};')"</span></span></code> </pre> <br><p>  Die obige Logik kann prägnant ausgedrückt werden durch: <br>  Wenn eine Zeile mit dem <code>// VCL.SHOW</code> , <code>// VCL.SHOW</code> gierig mit dem Text einschließlich der beiden Zahlen in dieser Zeile <code>// VCL.SHOW</code> , und erfassen Sie, was danach kommt.  Capture ausgeben und beenden. </p><br><p>  Einfach, nicht wahr? </p><br><p>  Wir waren mit dem sed-Skript und der Tatsache, welchen Originalcode es ersetzt, zufrieden. Alle von mir durchgeführten <code>varnishreload</code> ergaben die gewünschten Ergebnisse. <code>varnishreload</code> habe ich den <code>varnishreload</code> auf dem Server geändert und den <code>systemctl reload varnish</code> erneut <code>systemctl reload varnish</code> .  Das gefürchtete <code>echo: write error: Broken pipe</code> lächelte in unseren Gesichtern.  Der blinkende Cursor erwartete eine neue Befehlseingabe in der dunklen Leere des Terminals ... </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de475698/">https://habr.com/ru/post/de475698/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de475684/index.html">@Pythonetc-Zusammenstellung, Oktober 2019</a></li>
<li><a href="../de475686/index.html">Tipps und Tricks aus meinem Telegrammkanal @pythonetc, Oktober 2019</a></li>
<li><a href="../de475688/index.html">Wer ist wer in der IT?</a></li>
<li><a href="../de475694/index.html">Fehler von Lehrbüchern und Kuriositäten des Studiums</a></li>
<li><a href="../de475696/index.html">Samodelkin - georgisch oder russisch?</a></li>
<li><a href="../de475702/index.html">Aufzeichnungen von Berichten ca. Tech: Data Explanation # 3</a></li>
<li><a href="../de475708/index.html">Künstliche Intelligenz - Sprachinterpreter</a></li>
<li><a href="../de475712/index.html">Zero-Click-Lieferung und On SERP SEO: So erreichen Sie die Nullposition in Yandex und Google</a></li>
<li><a href="../de475720/index.html">Die 8 besten Trends der Internationalen Konferenz für lernende Repräsentationen (ICLR) 2019</a></li>
<li><a href="../de475728/index.html">Was ist das nächste Mitglied ...? - Wir suchen nach einer Formel für den n-ten Term der Sequenz, die Funktionen und die Z-Transformation generiert</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>