<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçí üöè ‚úçüèº Down the Rabbit Hole: Eine Geschichte von einem Varnishreload-Fehler - Teil 1 ü§∑ ‚¨õÔ∏è üë®üèª‚Äçüîß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nachdem er in den letzten 20 Minuten die Tastatur gedr√ºckt hat, als w√ºrde er f√ºr sein Leben tippen, dreht sich Ghostinushanka mit einem halb verr√ºckte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Down the Rabbit Hole: Eine Geschichte von einem Varnishreload-Fehler - Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475698/"><p> Nachdem er in den letzten 20 Minuten die Tastatur gedr√ºckt hat, als w√ºrde er f√ºr sein Leben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">tippen,</a> dreht sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Ghostinushanka</a> mit einem halb verr√ºckten Blick in den Augen und einem schlauen L√§cheln zu mir. ‚ÄûAlter, ich glaube, ich habe es verstanden. </p><br><p> Sehen Sie sich das an ‚Äú- als er auf eines der Zeichen auf dem Bildschirm zeigt -‚Äû Ich wette, mein roter Hut, wenn wir hinzuf√ºgen, was ich Ihnen gerade hierher geschickt habe ‚Äú- als er auf eine andere Stelle im Code zeigt -‚Äû wird es geben kein Fehler mehr. " <br>  Etwas verwirrt und m√ºde <code>systemctl varnish reload</code> ich den Sed-Ausdruck, den wir seit einiger Zeit herausfinden, speichere die Datei und <code>systemctl varnish reload</code> das <code>systemctl varnish reload</code> .  Fehlermeldung weg ... </p><br><p>  "Diese E-Mails, die ich mit dem Kandidaten ausgetauscht habe", f√§hrt mein Kollege fort, w√§hrend sich sein L√§cheln in ein breites und echtes Grinsen verwandelt. "Mir ist pl√∂tzlich aufgefallen, dass dies genau dasselbe Problem ist!" </p><a name="habracut"></a><br><h3 id="how-it-all-began">  Wie alles begann </h3><br><p>  <em>Dieser Artikel setzt voraus, dass Sie mit bash, awk und systemd vertraut sind.</em>  <em>Einige Lackkenntnisse sind von Vorteil, aber nicht erforderlich.</em> <em><br></em>  <em>Zeitstempel in Beispiel-Snippets wurden √ºberarbeitet.</em> <em><br></em>  <em>Zusammen mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">ghostinushanka</a> verfasst.</em> </p><br><p>  An einem weiteren warmen Herbstmorgen scheint die Sonne durch die wandgro√üen Fenster, eine Tasse frisch gebr√ºhte koffeinhaltige Fl√ºssigkeit steht neben der Tastatur, Kopfh√∂rer sprechen die geliebte Symphonie von Kl√§ngen, die das Rascheln mechanischer Tastaturen √ºberdecken, und der erste Eintrag im R√ºckstand auf der Kanbantafel wird spielerisch der Titel des schicksalhaften Tickets angezeigt <code>sh: echo: I/O error</code> ‚ÄûUntersuche das Laden von Daten <code>sh: echo: I/O error</code> bei der Bereitstellung‚Äú.  Immer wenn es um Lack geht, gibt es keinen Platz f√ºr Fehler, auch wenn dieser keine wirklichen Probleme zu verursachen schien. </p><br><p>  F√ºr diejenigen unter Ihnen, die mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">varnishreload</a> nicht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vertraut sind</a> , ist es einfach ein Shell-Skript, das zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erneuten</a> Laden der Konfiguration - auch VCL genannt - des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Varnish-Caching-Servers verwendet wird</a> . </p><br><p>  Wie der Titel des Tickets andeutet, ist der Fehler auf einem der Staging-Computer aufgetreten, und ich war mir ziemlich sicher, dass das Varnish-Routing in der Staging-Umgebung funktioniert. Daher war meine Annahme, dass dies ein geringf√ºgiges Problem sein muss.  Nur eine benutzerfreundliche Ausgabenachricht, die in einen geschlossenen Stream geschrieben wird.  Ich greife nach dem Ticket und bin fest davon √ºberzeugt, dass ich es in weniger als 30 Minuten als erledigt markieren kann. Ich klopfe mir auf den R√ºcken, um eine weitere weltliche Aufgabe zu erledigen und mich wieder wichtigeren Dingen zuzuwenden. </p><br><h3 id="hitting-the-wall-at-200kph">  Mit 200 km / h gegen die Wand </h3><br><p>  Beim √ñffnen der Datei <code>varnishreload</code> auf einem der betroffenen Server unter Debian Stretch <code>varnishreload</code> ich fest, dass ein Shell-Skript weniger als 200 Zeilen lang ist.  Wenn ich es kurz durchlese, sehe ich nichts Gef√§hrliches, das mich daran hindern w√ºrde, das Skript immer wieder vom Terminal aus auszuf√ºhren.  Immerhin ist dies eine Inszenierung, auch wenn sie kaputt geht, niemand wird sich beschweren, na ja ... nicht zu viel.  Ich starte das Skript und beobachte, nur um herauszufinden, dass keine Fehler zu sehen sind.  Ein paar weitere Durchl√§ufe stellen sicher, dass ich den Fehler nicht ohne zus√§tzlichen Aufwand reproduzieren kann, und ich beginne Pl√§ne zu entwickeln, um die Umgebung des Skripts zu optimieren und zu verbessern.  Hilft es √ºberhaupt, STDOUT f√ºr das Skript zu schlie√üen (mit <code>&gt; &amp;-</code> )?  Oder stderr?  Weder noch. </p><br><p>  Offensichtlich beeintr√§chtigt systemd die Umwelt auf irgendeine Weise, aber wie und warum?  Ich <code>varnishreload</code> vim und bearbeite das <code>varnishreload</code> des Systems, <code>varnishreload</code> <code>set -x</code> direkt unter dem <code>varnishreload</code> hinzu und hoffe, dass die detaillierte Skriptausgabe etwas Licht ins Dunkel bringt. </p><br><p>  Da die Datei gepatcht ist, lade ich den Firnis neu, nur um zu sehen, dass die √Ñnderung das Skript vollst√§ndig zerst√∂rt hat ... Die Ausgabe ist ein komplettes Durcheinander, in dem jede Menge C-Code angezeigt wird und der standardm√§√üige Scrollback-Puffer nicht ausreicht, um herauszufinden, woher er kommt.  Ich f√ºhle mich verwirrt.  K√∂nnte das Festlegen der Debug-Option f√ºr das Shell-Skript das aufgerufene Programm besch√§digen?  Nein, kann nicht sein.  Ein Fehler in der Shell?  In meinem Kopf laufen mehrere m√∂gliche Szenarien wild in verschiedene Richtungen.  Eine Tasse koffeinhaltiges Getr√§nk ist sofort fertig, schnelle Fahrt in die K√ºche zum Nachf√ºllen und schon geht es wieder los.  Ich √∂ffne die Datei und schaue mir den shebang genau an: <code>#!/bin/sh</code> . </p><br><p>  Aber <code>/bin/sh</code> ist sicherlich nur ein Symlink zu bash, so dass das Skript im POSIX-kompatiblen Modus interpretiert wird, oder?  Falsch!  Die nicht interaktive Standard-Shell unter Debian ist dash, und genau darauf zeigt <code>/bin/sh</code> . </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ls -l /bin/sh lrwxrwxrwx 1 root root 4 Jan 24 2017 /bin/sh -&gt; dash</span></span></code> </pre> <br><p>  Wenn auch nur zum Debuggen, habe ich den shebang in <code>#!/bin/bash</code> ge√§ndert, die <code>set -x</code> und es erneut versucht.  Zum Schluss noch ein vern√ºnftiger Fehler beim n√§chsten Nachladen des Lacks: </p><br><pre> <code class="bash hljs">Jan 01 12:00:00 hostname varnishreload[32604]: /usr/sbin/varnishreload: line 124: <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span>: write error: Broken pipe Jan 01 12:00:00 hostname varnishreload[32604]: VCL <span class="hljs-string"><span class="hljs-string">'reload_20190101_120000_32604'</span></span> compiled</code> </pre> <br><p>  Linie 124, jetzt reden wir! </p><br><pre> <code class="bash hljs">114 <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_vcl_file</span></span></span></span>() { 115 VCL_SHOW=$(varnishadm vcl.show -v <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$VCL_NAME</span></span></span><span class="hljs-string">"</span></span> 2&gt;&amp;1) || : 116 VCL_FILE=$( 117 <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$VCL_SHOW</span></span></span><span class="hljs-string">"</span></span> | 118 awk <span class="hljs-string"><span class="hljs-string">'$1 == "//" &amp;&amp; $2 == "VCL.SHOW" {print; exit}'</span></span> | { 119 <span class="hljs-comment"><span class="hljs-comment"># all this ceremony to handle blanks in FILE 120 read -r DELIM VCL_SHOW INDEX SIZE FILE 121 echo "$FILE" 122 } 123 ) || : 124 125 if [ -z "$VCL_FILE" ] 126 then 127 echo "$VCL_SHOW" &gt;&amp;2 128 fail "failed to get the VCL file name" 129 fi 130 131 echo "$VCL_FILE" 132 }</span></span></code> </pre> <br><p>  Aber wie sich herausstellt, ist die Linie 124 ziemlich ereignislos.  Ich konnte nur vermuten, dass der Fehler als Teil des in Zeile 116 ausgef√ºhrten mehrzeiligen Befehls erzeugt wurde. </p><br><p>  Was erzeugt die obige Subshell √ºberhaupt, um sie in der Variablen VCL_FILE zu speichern?  Im ersten Teil sendet es den Inhalt der <code>VCL_SHOW</code> Variablen, die in der Zeile 115 erstellt wurde, in die Pipe.  Was passiert dann dort? </p><br><p>  Zun√§chst wird <code>varnishadm</code> , ein Standardbestandteil einer Varnish-Installation, mit der Varnish konfiguriert wird, ohne dass ein Neustart erforderlich ist.  Mit dem Unterbefehl <code>vcl.show -v</code> wird die gesamte durch <code>${VCL_NAME}</code> angegebene VCL-Konfiguration an <code>${VCL_NAME}</code> ausgegeben. </p><br><p>  Um die aktuell aktive VCL-Konfiguration sowie mehrere fr√ºhere Versionen des <code>varnishadm vcl.list</code> , die sich noch im Speicher befinden, k√∂nnen Sie einen anderen Befehl <code>varnishadm vcl.list</code> , dessen Ausgabe der folgenden √§hnelt: </p><br><pre> <code class="plaintext hljs">discarded cold/busy 1 reload_20190101_120000_11903 discarded cold/busy 2 reload_20190101_120000_12068 discarded cold/busy 16 reload_20190101_120000_12259 discarded cold/busy 16 reload_20190101_120000_12299 discarded cold/busy 28 reload_20190101_120000_12357 active auto/warm 32 reload_20190101_120000_12397 available auto/warm 0 reload_20190101_120000_12587</code> </pre> <br><p>  Die Variable <code>${VCL_NAME}</code> wird an anderer Stelle im <code>varnishreload</code> Skript auf den Namen der derzeit aktiven VCL gesetzt, sofern vorhanden.  In diesem Fall w√§re das "reload_20190101_120000_12397". </p><br><p>  Toll, also enth√§lt <code>${VCL_SHOW}</code> jetzt eine vollst√§ndige Konfiguration f√ºr Varnish, die bisher <code>${VCL_SHOW}</code> einfach war.  Jetzt habe ich endlich verstanden, warum die Dash-Ausgabe mit <code>set -x</code> so kaputt zu sein schien - sie enthielt den Inhalt der resultierenden Lackkonfiguration. </p><br><p>  Wichtig hierbei ist, dass die vollst√§ndige VCL-Konfiguration h√§ufig aus mehreren Dateien zusammengef√ºgt wird.  Mit Kommentaren im C-Stil wird festgelegt, wo Konfigurationsdateien in andere Konfigurationsdateien eingef√ºgt wurden. Genau darum geht es in der n√§chsten Zeile des Code-Snippets. </p><br><p>  Die Syntax der dateibezogenen Kommentare hat das folgende Format </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// VCL.SHOW &lt;NUM&gt; &lt;NUM&gt; &lt;FILENAME&gt;</span></span></code> </pre> <br><p>  Die Zahlen sind hier nicht wichtig, was uns interessiert, ist der Dateiname. </p><br><p>  Was in aller Welt passiert also in der Menge der Befehle, die in Zeile 116 beginnen? <br>  Lass es uns auseinander nehmen. <br>  Der Befehl besteht aus vier Teilen: </p><br><ol><li>  Ein einfaches <code>echo</code> , das den Wert von <code>${VCL_SHOW}</code> <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$VCL_SHOW</span></span></span><span class="hljs-string">"</span></span></code> </pre> </li><li>  <code>awk</code> sucht nach einer Zeile (Datensatz), in der das erste Feld '//' und das zweite "VCL.SHOW" ist. <br>  Awk wird angewiesen, die erste Zeile zu drucken, die mit diesen Mustern √ºbereinstimmt, und die Verarbeitung dann sofort zu beenden. <br><pre> <code class="bash hljs">awk <span class="hljs-string"><span class="hljs-string">'$1 == "//" &amp;&amp; $2 == "VCL.SHOW" {print; exit}'</span></span></code> </pre> </li><li>  Ein Codeblock, der die durch Leerzeichen getrennten Felder in f√ºnf Variablen einliest.  Die f√ºnfte Variable FILE erh√§lt den Rest der Zeile.  Schlie√ülich gibt ein letztes Echo den Inhalt der Variablen <code>${FILE}</code> . <br><pre> <code class="bash hljs">{ <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> -r DELIM VCL_SHOW INDEX SIZE FILE; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$FILE</span></span></span><span class="hljs-string">"</span></span> }.</code> </pre> </li><li>  Da die Schritte 1 bis 3 alle in eine Subshell eingeschlossen sind, wird die Ausgabe von <code>$FILE</code> in der Variablen <code>VCL_FILE</code> . </li></ol><br><p>  Wie aus dem Kommentar in Zeile 119 hervorgeht, dient diese Vorgehensweise einem einzigen Zweck: dem zuverl√§ssigen Behandeln des Falls, in dem VCL auf Dateinamen mit Leerzeichen verweist. </p><br><p>  Ich habe die urspr√ºngliche Verarbeitungslogik f√ºr <code>${VCL_FILE}</code> und versucht, die Befehlskette zu optimieren, aber ohne vern√ºnftiges Ende.  Alles hat in meiner Shell funktioniert, aber nie als Dienst ausgef√ºhrt. </p><br><p>  Es scheint, dass der Fehler bei meiner Ausf√ºhrung √ºberhaupt nicht reproduzierbar ist - mittlerweile sind die gesch√§tzten 30 Minuten sechs Mal vergangen, und eine neue Aufgabe mit hoher Priorit√§t hat alles beiseite gelegt.  Der Rest der Woche war ziemlich voll mit verschiedenen Aufgaben, die beiden Ausnahmen waren ein internes Gespr√§ch unseres Teams √ºber die Verwendung von <code>sed</code> und ein Interview mit einem vielversprechenden Kandidaten.  Das Problem, dass der <code>varnishreload</code> Fehler verschwunden ist, ist f√ºr die ganze Zeit verloren gegangen. </p><br><h3 id="your-so-called-sed-fu-is-really-quite-pathetic">  Dein sogenanntes Sed-Fu ... ist wirklich ... ziemlich erb√§rmlich </h3><br><p>  Einer der folgenden Wochentage war ziemlich frei, also nahm ich die Aufgabe wieder auf.  Ich hatte gehofft, dass vielleicht immer noch ein Hintergrundprozess in meinem Gehirn das Problem in den Griff bekommt und ich es endlich knacken kann. </p><br><p>  Da das letzte Mal das Verbiegen des Codes nicht geholfen hat, habe ich mich f√ºr eine Neufassung von Zeile 116 entschieden. Der vorhandene Code war sowieso verr√ºckt.  Es ist absolut nicht n√∂tig, hier zu <code>read</code> . </p><br><p>  Schauen Sie sich den Fehler noch einmal an: <br>  <code>sh: echo: broken pipe</code> - Echo ist an zwei Stellen in diesem Befehl, aber ich vermute, dass der erste ein wahrscheinlicherer T√§ter (oder Komplize) ist.  Awk schafft auch kein Vertrauen.  Nun, falls es sich wirklich um die <code>awk | {read; echo}</code> <code>awk | {read; echo}</code>  <code>awk | {read; echo}</code> construct verursacht all diese Probleme, warum nicht etwas anderes verwenden?  Awk ist auf diesem Einzeiler nicht wirklich voll ausgelastet, und dann ist da noch dieser √úberschuss. </p><br><p>  Da wir in der <code>sed</code> Woche ein internes Gespr√§ch √ºber <code>sed</code> , wollte ich meine neu erworbenen F√§higkeiten ausprobieren und das <code>echo | awk | { read; echo }</code> optimieren <code>echo | awk | { read; echo }</code>  in ein einfacheres <code>echo | sed</code>  <code>echo | sed</code> .  Obwohl dies definitiv nicht der richtige Weg ist, um das Debuggen in Angriff zu nehmen, dachte ich, ich w√ºrde zumindest mein Sed-Fu ausprobieren und vielleicht etwas Neues √ºber das Problem in diesem Prozess erfahren.  Dabei habe ich meinen Kollegen - den Autor des Sed-Talks - gebeten, mir zu helfen, einen effizienteren Sed-Befehl zu entwickeln. </p><br><p>  Ich habe die Datei <code>varnishadm vcl.show -v "$VCL_NAME"</code> in eine Datei geschrieben, damit ich mich auf das Schreiben von sed konzentrieren kann, ohne den ganzen Aufwand f√ºr das Neuladen von Diensten. </p><br><p>  Eine kurze Einf√ºhrung, wie genau sed Prozesse eingegeben werden, findet sich in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">seinem GNU-Handbuch</a> .  In sed sources wird das Zeichen <code>\n</code> explizit als Zeilentrennzeichen angegeben. </p><br><p>  Nach mehreren Iterationen und Eingaben meines Kollegen haben wir einen sed-Ausdruck erstellt, der genau das gleiche Ergebnis wie die urspr√ºngliche Zeile 116 liefert. </p><br><p>  Lassen Sie uns hier eine Beispiel-Eingabedatei erstellen, </p><br><pre> <code class="bash hljs">&gt; cat vcl-example.vcl Text // VCL.SHOW 0 1578 file with 3 spaces.vcl More text // VCL.SHOW 0 1578 file.vcl Even more text // VCL.SHOW 0 1578 file with TWOspaces.vcl Final text</code> </pre> <br><p>  Es ist aus der obigen Beschreibung m√∂glicherweise nicht ersichtlich, aber wir interessieren uns nur f√ºr den ersten <code>// VCL.SHOW</code> Kommentar, und bei der Eingabe sind m√∂glicherweise mehrere vorhanden.  Genau deshalb gibt awk nach dem ersten Match auf. </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># step 1, capture just the comment lines # using sed capability to specify delimiter character with '\#' instead of the commonly used '/' so there is no need to escape slashes themselves # and the ‚Äúaddress‚Äù capability defined as regex ‚Äú// VCL.SHOW‚Äù to search for lines with specific pattern # -n flag makes sure that the sed does not print all as it does by default (see above link) # -E switches to the extended regex &gt; cat vcl-processor-1.sed \#// VCL.SHOW#p &gt; sed -En -f vcl-processor-1.sed vcl-example.vcl // VCL.SHOW 0 1578 file with 3 spaces.vcl // VCL.SHOW 0 1578 file.vcl // VCL.SHOW 0 1578 file with TWOspaces.vcl # step 2, only print out the file name # using the ‚Äúsubstitute‚Äù command with regex capture groups to print just that group # and this is done only for the matches of the previous search &gt; cat vcl-processor-2.sed \#// VCL.SHOW# { s#.* [0-9]+ [0-9]+ (.*)$#\1# p } &gt; sed -En -f vcl-processor-2.sed vcl-example.vcl file with 3 spaces.vcl file.vcl file with TWOspaces.vcl # step 3, make sure to only get the first result # same as with the awk before, add an immediate exit after the first processed match is printed &gt; cat vcl-processor-3.sed \#// VCL.SHOW# { s#.* [0-9]+ [0-9]+ (.*)$#\1# p q } &gt; sed -En -f vcl-processor-3.sed vcl-example.vcl file with 3 spaces.vcl # step 4, wrap it up into a one-liner using the colon to separate commands &gt; sed -En -e '\#// VCL.SHOW#{s#.* [0-9]+ [0-9]+ (.*)$#\1#p;q;}' vcl-example.vcl file with 3 spaces.vcl</span></span></code> </pre> <br><p>  Der Inhalt des varnishreload-Skripts w√ºrde also ungef√§hr so ‚Äã‚Äãaussehen: </p><br><pre> <code class="bash hljs">VCL_FILE=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(echo "$VCL_SHOW" | sed -En '\#// VCL.SHOW#{s#.*[0-9]+ [0-9]+ (.*)</span></span></span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$#</span></span></span><span class="hljs-string">\1#p;q;};')"</span></span></code> </pre> <br><p>  Die obige Logik kann pr√§gnant ausgedr√ºckt werden durch: <br>  Wenn eine Zeile mit dem <code>// VCL.SHOW</code> , <code>// VCL.SHOW</code> gierig mit dem Text einschlie√ülich der beiden Zahlen in dieser Zeile <code>// VCL.SHOW</code> , und erfassen Sie, was danach kommt.  Capture ausgeben und beenden. </p><br><p>  Einfach, nicht wahr? </p><br><p>  Wir waren mit dem sed-Skript und der Tatsache, welchen Originalcode es ersetzt, zufrieden. Alle von mir durchgef√ºhrten <code>varnishreload</code> ergaben die gew√ºnschten Ergebnisse. <code>varnishreload</code> habe ich den <code>varnishreload</code> auf dem Server ge√§ndert und den <code>systemctl reload varnish</code> erneut <code>systemctl reload varnish</code> .  Das gef√ºrchtete <code>echo: write error: Broken pipe</code> l√§chelte in unseren Gesichtern.  Der blinkende Cursor erwartete eine neue Befehlseingabe in der dunklen Leere des Terminals ... </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de475698/">https://habr.com/ru/post/de475698/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de475684/index.html">@Pythonetc-Zusammenstellung, Oktober 2019</a></li>
<li><a href="../de475686/index.html">Tipps und Tricks aus meinem Telegrammkanal @pythonetc, Oktober 2019</a></li>
<li><a href="../de475688/index.html">Wer ist wer in der IT?</a></li>
<li><a href="../de475694/index.html">Fehler von Lehrb√ºchern und Kuriosit√§ten des Studiums</a></li>
<li><a href="../de475696/index.html">Samodelkin - georgisch oder russisch?</a></li>
<li><a href="../de475702/index.html">Aufzeichnungen von Berichten ca. Tech: Data Explanation # 3</a></li>
<li><a href="../de475708/index.html">K√ºnstliche Intelligenz - Sprachinterpreter</a></li>
<li><a href="../de475712/index.html">Zero-Click-Lieferung und On SERP SEO: So erreichen Sie die Nullposition in Yandex und Google</a></li>
<li><a href="../de475720/index.html">Die 8 besten Trends der Internationalen Konferenz f√ºr lernende Repr√§sentationen (ICLR) 2019</a></li>
<li><a href="../de475728/index.html">Was ist das n√§chste Mitglied ...? - Wir suchen nach einer Formel f√ºr den n-ten Term der Sequenz, die Funktionen und die Z-Transformation generiert</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>