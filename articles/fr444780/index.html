<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚙 🌌 🙍 Circuits auto-synchrones. Calcul des fonctions logiques directement sur le graphe des événements. Partie 3. Décomposition 🎚️ 👩🏻‍🎓 🤹🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je rappelle une conclusion importante des parties précédentes. Pour un comportement séquentiel cyclique qui ne contient pas plusieurs signaux (commuta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Circuits auto-synchrones. Calcul des fonctions logiques directement sur le graphe des événements. Partie 3. Décomposition</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444780/">  Je rappelle une conclusion importante des parties précédentes.  Pour un comportement séquentiel cyclique qui ne contient pas plusieurs signaux (commutation sur un cycle plus de deux fois), la fonction logique minimale de chaque signal peut être représentée sous la forme suivante (naturellement, en l'absence de conflits CSC): <br><br>  1) <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>x</mi><mo>=</mo><mi>a</mi><mo>&amp;#x2217;</mo><mi>b</mi><mo>&amp;#x2217;</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>&amp;#x2217;</mo><mi>c</mi><mo>+</mo><mi>x</mi><mo>&amp;#x2217;</mo><mi>f</mi><mo>+</mo><mi>g</mi><mo>+</mo><mi>h</mi><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><mi>i</mi><mo>,</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="39.23ex" height="2.419ex" viewBox="0 -780.1 16890.8 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/444780/&amp;usg=ALkJrhimeygGrQCw3n2nuFQ_AWKXZDGXnA#MJMATHI-78" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/444780/&amp;usg=ALkJrhimeygGrQCw3n2nuFQ_AWKXZDGXnA#MJMAIN-3D" x="850" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/444780/&amp;usg=ALkJrhimeygGrQCw3n2nuFQ_AWKXZDGXnA#MJMATHI-61" x="1906" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/444780/&amp;usg=ALkJrhimeygGrQCw3n2nuFQ_AWKXZDGXnA#MJMAIN-2217" x="2658" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/444780/&amp;usg=ALkJrhimeygGrQCw3n2nuFQ_AWKXZDGXnA#MJMATHI-62" x="3381" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/444780/&amp;usg=ALkJrhimeygGrQCw3n2nuFQ_AWKXZDGXnA#MJMAIN-2217" x="3810" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/444780/&amp;usg=ALkJrhimeygGrQCw3n2nuFQ_AWKXZDGXnA#MJMAIN-2E" x="4311" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/444780/&amp;usg=ALkJrhimeygGrQCw3n2nuFQ_AWKXZDGXnA#MJMAIN-2E" x="4756" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/444780/&amp;usg=ALkJrhimeygGrQCw3n2nuFQ_AWKXZDGXnA#MJMAIN-2E" x="5201" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/444780/&amp;usg=ALkJrhimeygGrQCw3n2nuFQ_AWKXZDGXnA#MJMAIN-2217" x="5646" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/444780/&amp;usg=ALkJrhimeygGrQCw3n2nuFQ_AWKXZDGXnA#MJMATHI-63" x="6147" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/444780/&amp;usg=ALkJrhimeygGrQCw3n2nuFQ_AWKXZDGXnA#MJMAIN-2B" x="6802" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/444780/&amp;usg=ALkJrhimeygGrQCw3n2nuFQ_AWKXZDGXnA#MJMATHI-78" x="7803" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/444780/&amp;usg=ALkJrhimeygGrQCw3n2nuFQ_AWKXZDGXnA#MJMAIN-2217" x="8598" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/444780/&amp;usg=ALkJrhimeygGrQCw3n2nuFQ_AWKXZDGXnA#MJMATHI-66" x="9320" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/444780/&amp;usg=ALkJrhimeygGrQCw3n2nuFQ_AWKXZDGXnA#MJMAIN-2B" x="10093" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/444780/&amp;usg=ALkJrhimeygGrQCw3n2nuFQ_AWKXZDGXnA#MJMATHI-67" x="11094" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/444780/&amp;usg=ALkJrhimeygGrQCw3n2nuFQ_AWKXZDGXnA#MJMAIN-2B" x="11797" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/444780/&amp;usg=ALkJrhimeygGrQCw3n2nuFQ_AWKXZDGXnA#MJMATHI-68" x="12797" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/444780/&amp;usg=ALkJrhimeygGrQCw3n2nuFQ_AWKXZDGXnA#MJMAIN-2B" x="13374" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/444780/&amp;usg=ALkJrhimeygGrQCw3n2nuFQ_AWKXZDGXnA#MJMAIN-2E" x="14152" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/444780/&amp;usg=ALkJrhimeygGrQCw3n2nuFQ_AWKXZDGXnA#MJMAIN-2E" x="14597" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/444780/&amp;usg=ALkJrhimeygGrQCw3n2nuFQ_AWKXZDGXnA#MJMAIN-2E" x="15043" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/444780/&amp;usg=ALkJrhimeygGrQCw3n2nuFQ_AWKXZDGXnA#MJMAIN-2B" x="15488" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/444780/&amp;usg=ALkJrhimeygGrQCw3n2nuFQ_AWKXZDGXnA#MJMATHI-69" x="16266" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/444780/&amp;usg=ALkJrhimeygGrQCw3n2nuFQ_AWKXZDGXnA#MJMAIN-2C" x="16612" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>x</mi><mo>=</mo><mi>a</mi><mo>∗</mo><mi>b</mi><mo>∗</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>∗</mo><mi>c</mi><mo>+</mo><mi>x</mi><mo>∗</mo><mi>f</mi><mo>+</mo><mi>g</mi><mo>+</mo><mi>h</mi><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><mi>i</mi><mo>,</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> x = a * b * ... * c + x * f + g + h + ... + i, </script></p><br><br>  où a * b * ... * c est l'implicant d'une ou plusieurs variables.  g + h + ... + i - il s'agit peut-être d'un ensemble vide d'implicants composé d'une variable.  x * f est un implant de 2 variables, dont la présence sous une forme minimale n'est pas nécessaire.  Toutes les variables, à l'exception de x, peuvent être incluses dans la formule sous forme directe et inverse, selon la disposition des signes des événements correspondants.  Toutes les variables sont incluses dans la formule comme arguments strictement une fois. <br><br>  Avant de poursuivre, nous allons regarder de plus près un phénomène comme la décomposition.  Tout d'abord, la décomposition présente un intérêt, ce qui préserve l'auto-synchronisation.  Lors de la décomposition d'une fonction logique NON-ET-OU, on peut distinguer comme un nouvel élément: <br><br>  a) un ou plusieurs implicants, <br>  b) plusieurs signaux (variables) d'un implant, <br>  c) un onduleur d'entrée. <br><a name="habracut"></a><br>  Pour commencer, nous considérons un cas particulier de la fonction NOR AND.  Le comportement d'une telle fonction logique (x = a + b + c + d) pour le modèle en question: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8c9/463/f89/8c9463f89baeec4c51d9fce5ac3d380d.png" alt="image"><br><br>  Elle peut distinguer plusieurs signaux comme un élément distinct. <br><br>  En fait, la sélection d'un nouvel élément lors de la décomposition est l'addition d'un nouveau signal (f).  Afin de maintenir un comportement correct, une semi-modularité et une auto-synchronisation, la commutation du signal f nouvellement ajouté doit avoir des événements de conséquence.  Puisque la décomposition affecte seulement un élément du circuit (dans ce cas, x) et n'affecte pas les éléments restants du circuit, la commutation du signal f ne peut provoquer que la commutation du signal x.  Sinon, la fonction logique d'un autre signal dépendrait du signal f.  Étant donné cette conclusion, essayons de mettre en évidence plusieurs variables à l'exception de la variable a en tant que nouvel élément f.  Prenons par exemple les variables b et c.  Ils forment l'élément logique f = b + c. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b1d/811/007/b1d81100784a6af91326863fdf66a338.png" alt="image"><br><br>  Comme on peut le voir, pour l'événement f +, il est impossible de déterminer l'événement de conséquence sans violer l'exactitude du comportement.  Tout groupe de signaux qui ne contient pas la variable a ne peut pas être alloué en tant qu'élément séparé tout en conservant l'auto-synchronisation. <br><br>  Un signal tel que dans cet exemple sera appelé mise sous tension.  Dans le cas général, le signal de commutation pour la fonction OU (ET) est un signal, sa commutation sur 1 (0) modifie la valeur de la fonction de 0 à 1 (de 1 à 0).  Pour maintenir l'auto-synchronisation pendant la décomposition de la fonction logique OU (ET) lors de la sélection d'un nouvel élément, vous devez utiliser le signal de commutation.  Lors de la sélection d'un nouvel élément, il est également nécessaire d'utiliser uniquement les signaux formant une chaîne connectée (dans l'exemple ci-dessous a + b).  x = f + c + d, f = a + b. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9a0/0fd/47b/9a00fd47b9b89ee921bf3ea9fc317511.png" alt="image"><br><br>  Lors de l'utilisation de signaux a + b + d, l'auto-synchronisation n'est pas préservée. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/213/fc8/060/213fc806050f345fc776672dfb80d9cb.png" alt="image"><br><br>  Ainsi, pour des comportements séquentiels sans signaux multiples lors de la décomposition de la fonction logique OR (I), mettre en évidence comme nouvel élément les premiers au cours du déploiement du processus de signal, à partir de la commutation, garantit l'auto-synchronisation du circuit. <br><br>  Considérons maintenant la fonction non-OU (x =! A +! B).  En tant qu'élément séparé (f) tout en conservant l'auto-synchronisation, seul l'inverseur d'entrée correspondant au signal de commutation (x = f +! B, f =! A) peut être sélectionné.  La séparation des autres onduleurs d'entrée en tant qu'élément séparé entraînera une violation de l'auto-synchronisation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/18a/176/89f/18a17689fcb462e6ceee33c7b46ba79e.png" alt="image"><br><br>  Passons à la fonction AND-OR.  De même, en tant que signal de commutation pour la fonction OU, nous définissons l'implicant de commutation pour la fonction ET-OU.  Il s'agit d'un implicant dont la modification de la valeur de 0 à 1 entraîne une modification de la valeur de la fonction de 0 à 1. De même, comme cela a été découvert pour la fonction OU, pour les comportements séquentiels sans signaux multiples lors de la décomposition de la fonction logique ET-OU, en sélectionnant les premiers comme nouvel élément en cours de déploiement, l'implicant, à commencer par l'inclusion, garantit la préservation de l'auto-synchronisation du circuit.  Sinon, l'auto-synchronisation sera interrompue.  Dans l'exemple ci-dessous, avant décomposition x = a * b + c.  Après décomposition, x = f + c, f = a * b. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/075/b37/4d5/075b374d51f073597446b3ea98991bc4.png" alt="image"><br><br>  Maintenant pour la fonction ET-OU, nous considérons la sélection comme un nouvel élément de plusieurs variables incluses dans le même implicant.  Seules les fonctions minimales sont prises en compte.  Voici toutes les options possibles pour l'exemple de la fonction x = a * b * c + d (pour l'option 4 - x = a * b * c + d + e, pour l'option 6 - x = a * b * c * d + e) .  L'élément en surbrillance est f = a * b. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d99/439/ac9/d99439ac9cb66e2cacb214028ba929c7.png" alt="image"><br><br>  Dans l'option 1, la commutation de l'un des signaux attribués (a +) est la cause de l'événement x +.  Dans l'option 2, la commutation de l'un des signaux attribués (a-) est la cause de l'événement x.  Dans les options 3 et 4, la commutation de l'un des signaux attribués (respectivement a + et a-) se situe entre les événements x + et x-, et n'est pas la cause de l'événement x-.  L'option 5 est un cas particulier de l'option 4, lorsque l'implicant, dans lequel les signaux sont attribués, est inclusif.  L'option restante 6 - toutes les commutations des signaux attribués sont situées entre les événements x- et x +, et ne sont pas les causes de l'événement x +. <br><br>  Comme vous pouvez le voir, dans les options 1 et 6, l'événement f- ne peut pas être positionné correctement.  De telles transformations ne sont pas une décomposition avec préservation de l'auto-synchronisation.  Dans les options 2, 3 et 4, l'auto-synchronisation est conservée.  Mais la valeur de la fonction x s'avère différente de f * c + d (f * c + d + e pour 4 options).  Pour 2 options - x = f * (d + c), pour 3 options x = c * x + d *! F + x *! F, pour 4 options x = (f + d) * (e + c).  De telles transformations ne sont pas des décompositions. <br><br>  Seule l'option 5 est une décomposition avec préservation de l'auto-synchronisation (x = f * c + d).  Dans ce cas, en tant qu'élément séparé dans l'implicant d'inclusion, les premiers signaux sont sélectionnés, en commençant par l'inclusion (le signal incluant l'implicant de And est le même que le signal incluant la fonction de AND).  Mais, comme indiqué ci-dessus, un résultat similaire est obtenu en deux étapes.  Tout d'abord, l'inclusion de l'implant est mise en évidence.  À la deuxième étape, les premiers signaux sont sélectionnés dans le nouvel élément, en commençant par le signal de commutation. <br><br>  Passons à la fonction NON-ET-OU.  Considérons l'onduleur d'entrée comme un élément distinct.  Le signal a correspond à l'entrée de l'élément x, à laquelle un inverseur d'entrée dédié est connecté (f =! A). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6d1/89b/6b9/6d189b6b9574dc62f0fa5a1a4b1419d1.png" alt="image"><br><br>  Options 1 et 2 - le signal de commutation a est la cause de l'événement x + (1 - x =! A + b * c, 2 - x = b *! A + c).  Options 3 et 4 - la commutation du signal a est la cause de l'événement x- (3 - x =! A + b * c, 4 - x =! A * b + c).  Options 5 et 6 - la commutation du signal a se situe entre les événements x + et x-, et n'est pas la cause de l'événement x- (5 - x = b *! A + c, 6 - x =! A * b + d + c).  L'option 7 est un cas particulier de l'option 6, lorsque le signal a est un signal de commutation comprenant des implicants (x =! A * b + c).  L'option restante 8 - tous les commutateurs de signaux a sont situés entre les événements x- et x +, et ne sont pas les causes de l'événement x + (x = c *! A * b + d). <br><br>  Comme vous pouvez le voir, les options 2, 3 et 8 ne sont pas une décomposition avec conservation de l'auto-synchronisation, car il est impossible de positionner correctement la commutation de signal f.  Pour l'option 4, après la conversion x = f * (c + b).  Pour l'option 5, après la conversion x = c *! F +! F * x + b * x.  Pour l'option 6, après la conversion x = (f + c) * (d + b).  Ces transformations (options 4, 5 et 6) ne sont pas des décompositions.  Pour l'option 7, après la conversion x = f * b + c.  L'option 7 est une décomposition avec préservation de l'auto-synchronisation.  Dans ce cas, un onduleur correspondant au signal de commutation incluant les implants est attribué en tant qu'élément séparé.  Un résultat similaire est obtenu en deux étapes en utilisant les transformations ci-dessus.  Tout d'abord, l'inclusion de l'implicant est mise en évidence, puis l'inverseur d'entrée du signal d'activation lui est alloué.  Pour l'option 1, après la conversion x = f + b * c.  L'option 1 est également une décomposition avec préservation de l'auto-synchronisation.  Il s'agit d'un cas particulier de l'option 7, lorsque l'inclusion de l'implicant consiste en un signal. <br><br>  Nous systématisons les résultats obtenus.  Pour le modèle considéré, lors de la décomposition d'une fonction logique NON-ET-OU pour maintenir l'auto-synchronisme, seules les transformations suivantes sont possibles - allocation en tant qu'élément distinct: <br><br>  1 - un ou plusieurs, à partir de l'implicatif inclusif se chevauchant (cas particulier - pour la fonction de sélection NON-OU de plusieurs signaux se chevauchant, à partir de l'inclusif); <br><br>  2 - dans l'inclusion impliquée de plusieurs, à partir de l'inclusion, des signaux se chevauchant; <br><br>  3 - onduleur d'entrée correspondant au signal de commutation, y compris les implicants (cas particulier - pour la fonction de sélection NON-OU de l'onduleur d'entrée correspondant au signal de commutation). <br><br>  Ces transformations ne permettent pas à l'implicant d'être inclusif s'il n'était pas avant la transformation.  D'où la conclusion: si une fonction logique contient un implicant, qui se compose de plusieurs signaux et n'est pas inclusif, une telle fonction ne peut pas être fragmentée à l'aide d'une décomposition qui préserve l'auto-synchronisation, jusqu'à deux éléments d'entrée.  Toute fonction logique NON-ET-OU dans laquelle plus d'une variable ne contient qu'un implicant inclusif peut être divisée en éléments à deux entrées (2I-NOT, 2OR-NOT) à l'aide d'une décomposition qui préserve l'auto-synchronisation. <br><br>  Étape 1 - si l'élément logique ne contient qu'un seul implicant (ou si tous les implicants sont constitués d'une seule variable), passez à l'étape 3, sinon passez à l'étape 2. <br>  Étape 2 - sélectionnez comme élément séparé tous les implants, sauf un, en commençant par l'inclusion.  Ensuite, nous travaillons avec l'élément nouvellement reçu.  Passez à l'étape 1. <br>  Étape 3 - si l'élément se compose de deux variables, passez à l'étape 5, sinon passez à l'étape 4. <br>  Étape 4 - nous sélectionnons comme élément séparé toutes les variables, sauf une, en commençant par l'inclusion.  Ensuite, nous travaillons avec l'élément nouvellement reçu.  Passez à l'étape 3. <br>  Étape 5 - s'applique à tous les éléments à deux entrées reçus. <br>  Étape 5.1 - si les onduleurs d'entrée sont sur les deux entrées, nous convertirons l'élément en double. <br>  Étape 5.2 - si l'onduleur d'entrée est un et correspond à un signal qui ne s'allume pas, nous convertirons l'élément en double. <br>  Étape 5.3 - l'onduleur d'entrée, le cas échéant, est mis en évidence en tant qu'élément distinct.  Concassage terminé. <br><br>  Revenons maintenant à la formule 1 au début du texte.  Si l'implicant x * f n'est pas dans l'expression logique, alors la fonction ressemble à ceci: x = a * b * c + g + h + i.  Son comportement: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec6/584/fc9/ec6584fc9b70605ee3dea2ae210ef99b.png" alt="image"><br><br>  Comme vous pouvez le voir, le seul implicant de plus d'une variable (a * b * c) est inclusif.  Et cette fonction à l'aide de la décomposition peut être fragmentée en composants minimum tout en maintenant l'auto-synchronisation. <br><br>  Si l'impliquant x * f est présent dans une expression logique, alors la fonction ressemble à ceci: x = a * b * c + x * f + g + h + i.  Son comportement: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/53f/fad/0b9/53ffad0b9835dc89518dfcff624cd9c8.png" alt="image"><br><br>  L'implicant x * f non inclus se compose de plusieurs variables.  Une telle fonction ne peut pas être fragmentée tout en conservant l'auto-synchronisation.  Mais nous appliquons une transformation qui préserve l'auto-synchronisation: ajoutez le signal y - dual au signal x.  L'ajout du signal y modifie uniquement la fonction du signal x et du signal, dont la commutation était une conséquence de l'événement x- (la variable x est remplacée par la variable y). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f7f/735/b79/f7f735b79c4dd25b76687cfa85343b0e.png" alt="image"><br><br>  Maintenant x = (f + i + h + g) * y, y = c * b * a + x.  Les implicants f + i + h + g et c * b * a comprenant et, respectivement, les fonctions x et y peuvent être fragmentés en composantes minimales tout en conservant une auto-synchronisation. <br><br>  Un modèle de comportement simplifié (sans parallélisme, choix et signaux multiples) vous permet d'identifier les propriétés naturellement inhérentes aux processus binaires.  La synthèse de circuits auto-synchrones dans une base minimale est un phénomène naturel qui ne nécessite aucune conception. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444780/">https://habr.com/ru/post/fr444780/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444768/index.html">Réduire la dépendance aux données marquées dans les réseaux génératifs-contradictoires</a></li>
<li><a href="../fr444770/index.html">Comment nous avons recherché une fuite de données dans SimilarWeb</a></li>
<li><a href="../fr444774/index.html">Erreur avec la migration des paramètres régionaux ru-RU dans Google Chrome et comment s'en débarrasser</a></li>
<li><a href="../fr444776/index.html">N'ayez pas peur d'essayer, ou comment je suis devenu programmeur à l'âge de bien plus de 18 ans</a></li>
<li><a href="../fr444778/index.html">Comment je ne suis pas devenu un spécialiste de l'apprentissage automatique</a></li>
<li><a href="../fr444782/index.html">IT Global Meetup # 14 Petersburg</a></li>
<li><a href="../fr444784/index.html">Horaires de travail flexibles. Expérience russe</a></li>
<li><a href="../fr444786/index.html">12 questions à poser aux employeurs potentiels</a></li>
<li><a href="../fr444788/index.html">Roskomnadzor a commandé un système de contrôle de moteur de recherche automatisé et un VPN</a></li>
<li><a href="../fr444790/index.html">Le concept de champ magnétique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>