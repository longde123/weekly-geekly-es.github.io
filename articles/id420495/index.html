<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👸 😢 👂🏿 Rendering air layar 🧠 😭 ⛓️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tugas terakhir saya dalam grafik teknis / rendering adalah menemukan solusi yang baik untuk rendering air. Secara khusus, rendering jet air tipis dan ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rendering air layar</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420495/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/216/ca8/1f5/216ca81f5eb506eab2dbcfc730a904b4.png" alt="gambar"></div><br>  Tugas terakhir saya dalam grafik teknis / rendering adalah menemukan solusi yang baik untuk rendering air.  Secara khusus, rendering jet air tipis dan bergerak cepat berdasarkan partikel.  Selama seminggu terakhir, saya memikirkan hasil yang baik, jadi saya akan menulis artikel tentang ini. <br><br>  Saya tidak terlalu suka pendekatan kubus voxelized / marching ketika memberikan air (lihat, misalnya, memberikan simulasi cairan di Blender).  Ketika volume air berada pada skala yang sama dengan kisi-kisi yang digunakan untuk rendering, gerakannya terasa terpisah.  Masalah ini dapat diselesaikan dengan meningkatkan resolusi grid, tetapi untuk jet tipis jarak yang relatif jauh secara real time itu tidak praktis karena sangat mempengaruhi waktu eksekusi dan memori yang ditempati.  (Ada preseden untuk menggunakan struktur voxel yang jarang untuk memperbaiki situasi. Tapi saya tidak yakin seberapa baik ini bekerja untuk sistem dinamis. Juga, ini bukan tingkat kesulitan yang ingin saya kerjakan.) <br><br>  Alternatif pertama yang saya jelajahi adalah Screen Space Meshes Müller.  Mereka menggunakan rendering partikel air ke dalam buffer kedalaman, menghaluskannya, mengenali fragmen yang terhubung dari kedalaman yang sama, dan membangun mesh dari hasilnya menggunakan marching square.  Saat ini, metode ini mungkin menjadi <i>lebih</i> dapat diterapkan daripada tahun 2007 (karena sekarang kita dapat membuat mesh dalam compute shader), tetapi masih terkait dengan tingkat kerumitan dan biaya yang lebih besar daripada yang saya inginkan. <br><br>  Pada akhirnya, saya menemukan presentasi Simon Green dengan GDC 2010, Screen Space Fluid Rendering For Games.  Ini dimulai dengan cara yang persis sama dengan Screen Space Meshes: dengan merender partikel ke dalam buffer kedalaman dan menghaluskannya.  Tetapi alih-alih membangun mesh, buffer yang dihasilkan digunakan untuk menaungi dan menyusun cairan dalam adegan utama (dengan secara eksplisit merekam kedalaman). Saya memutuskan untuk mengimplementasikan sistem seperti itu. <br><a name="habracut"></a><br><h3>  Persiapan </h3><br>  Beberapa proyek Unity sebelumnya mengajarkan saya untuk tidak berurusan dengan keterbatasan rendering mesin.  Oleh karena itu, buffer cairan dirender oleh kamera kedua dengan kedalaman bidang yang lebih dangkal sehingga membuatnya di depan adegan utama.  Setiap sistem fluida ada pada lapisan rendering yang terpisah;  ruang utama tidak termasuk lapisan air, dan ruang kedua hanya menghasilkan air.  Kedua kamera adalah anak-anak dari objek kosong untuk memastikan orientasi relatif mereka. <br><br>  Skema seperti itu berarti bahwa saya dapat membuat hampir semua hal dalam lapisan cair, dan akan terlihat seperti yang saya harapkan.  Dalam konteks adegan demo saya, ini berarti bahwa beberapa jet dan percikan dari sub-emitter dapat bergabung bersama.  Selain itu, ini akan memungkinkan pencampuran sistem air lainnya, misalnya, volume berdasarkan bidang ketinggian, yang kemudian dapat dibuat sama.  (Saya belum menguji ini.) <br><br>  Sumber air dalam adegan saya adalah sistem partikel standar.  Faktanya, tidak ada simulasi fluida yang dilakukan.  Ini, pada gilirannya, berarti bahwa partikel tidak saling tumpang tindih dengan cara yang sepenuhnya fisik, tetapi hasil akhirnya tampaknya dapat diterima dalam praktiknya. <br><br><h3>  Render buffer cairan </h3><br>  Langkah pertama dalam teknik ini adalah membuat buffer fluida dasar.  Ini adalah penyangga di luar layar yang berisi (pada tahap implementasi saya saat ini) sebagai berikut: lebar fluida, vektor gerak di ruang layar dan nilai noise.  Selain itu, kami membuat buffer kedalaman dengan secara eksplisit merekam kedalaman dari shader fragmen untuk mengubah setiap segi empat dari partikel menjadi "bola" bola (well, sebenarnya elips). <br><br>  Perhitungan kedalaman dan lebar cukup sederhana: <br><br><pre><code class="cpp hljs">frag_out o; float3 N; N.xy = i.uv*<span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> r2 = dot(N.xy, N.xy); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r2 &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>) discard; Nz = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - r2); float4 pixel_pos = float4(i.view_pos + N * i.size, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); float4 clip_pos = mul(UNITY_MATRIX_P, pixel_pos); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> depth = clip_pos.z / clip_pos.w; o.depth = depth; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> thick = Nz * i.size * <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br>  (Tentu saja, perhitungan kedalaman dapat disederhanakan; dari posisi klip kita hanya perlu z dan w.) <br><br>  Beberapa saat kemudian, kita akan kembali ke shader fragmen untuk vektor gerakan dan derau. <br><br>  Kegembiraan dimulai dari vertex shader, dan di sinilah saya menyimpang dari teknik Green.  Tujuan proyek ini adalah membuat pancaran air berkecepatan tinggi;  itu dapat diwujudkan dengan bantuan partikel bola, tetapi sejumlah besar dari mereka akan diperlukan untuk membuat jet kontinu.  Sebagai gantinya, saya akan meregangkan segi empat partikel berdasarkan kecepatannya, yang pada gilirannya meregangkan bola-bola kedalaman, membuat mereka tidak berbentuk bola, tetapi berbentuk bulat panjang.  (Karena perhitungan kedalaman didasarkan pada UV, yang tidak berubah, semuanya hanya berfungsi.) <br><br>  Pengguna Unity yang berpengalaman mungkin bertanya-tanya mengapa saya tidak menggunakan mode Built-in Billboard yang tersedia di sistem partikel Unity.  Membentang Billboard melakukan peregangan tanpa syarat sepanjang vektor kecepatan di ruang dunia.  Dalam kasus umum, ini sangat cocok, tetapi mengarah ke masalah yang sangat nyata ketika vektor kecepatan diarahkan bersama dengan vektor kamera yang menghadap ke depan (atau sangat dekat dengannya).  Billboard membentang di layar, yang membuat sifat dua dimensinya sangat terlihat. <br><br>  Sebagai gantinya, saya menggunakan papan iklan yang diarahkan ke kamera dan memproyeksikan vektor kecepatan ke bidang partikel, menggunakannya untuk meregangkan segi empat.  Jika vektor kecepatan tegak lurus terhadap bidang (diarahkan ke layar atau menjauh darinya), maka partikel tetap tidak terentang dan bulat, sebagaimana mestinya, dan ketika dimiringkan, partikel direntangkan ke arah ini, yang merupakan apa yang kita butuhkan. <br><br>  Mari kita tinggalkan penjelasan panjang, berikut ini fungsi yang cukup sederhana: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ComputeStretchedVertex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 p_world, float3 c_world, float3 vdir_world, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> stretch_amount)</span></span></span><span class="hljs-function"> </span></span>{ float3 center_offset = p_world - c_world; float3 stretch_offset = dot(center_offset, vdir_world) * vdir_world; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p_world + stretch_offset * lerp(<span class="hljs-number"><span class="hljs-number">0.25f</span></span>, <span class="hljs-number"><span class="hljs-number">3.0f</span></span>, stretch_amount); }</code> </pre> <br>  Untuk menghitung vektor gerak ruang layar, kami menghitung dua set posisi vektor: <br><br><pre> <code class="cpp hljs">float3 vp1 = ComputeStretchedVertex( vertex_wp, center_wp, velocity_dir_w, rand); float3 vp0 = ComputeStretchedVertex( vertex_wp - velocity_w * unity_DeltaTime.x, center_wp - velocity_w * unity_DeltaTime.x, velocity_dir_w, rand); o.motion_0 = mul(_LastVP, float4(vp0, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); o.motion_1 = mul(_CurrVP, float4(vp1, <span class="hljs-number"><span class="hljs-number">1.0</span></span>));</code> </pre> <br>  Perhatikan bahwa karena kita menghitung vektor gerak di bagian utama dan bukan di bagian vektor kecepatan, Unity tidak memberi kita proyeksi arus sebelumnya atau tidak terdistorsi dari pandangan.  Untuk memperbaikinya, saya menambahkan skrip sederhana ke sistem partikel yang sesuai: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ScreenspaceLiquidRenderer</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Camera LiquidCamera; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ParticleSystemRenderer m_ParticleRenderer; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_First; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Matrix4x4 m_PreviousVP; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { m_ParticleRenderer = GetComponent(); m_First = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnWillRenderObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Matrix4x4 current_vp = LiquidCamera.nonJitteredProjectionMatrix * LiquidCamera.worldToCameraMatrix; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_First) { m_PreviousVP = current_vp; m_First = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } m_ParticleRenderer.material.SetMatrix(<span class="hljs-string"><span class="hljs-string">"_LastVP"</span></span>, GL.GetGPUProjectionMatrix(m_PreviousVP, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)); m_ParticleRenderer.material.SetMatrix(<span class="hljs-string"><span class="hljs-string">"_CurrVP"</span></span>, GL.GetGPUProjectionMatrix(current_vp, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)); m_PreviousVP = current_vp; } }</code> </pre> <br>  Saya cache matriks sebelumnya secara manual karena Camera.previousViewProjectionMatrix memberikan hasil yang salah. <br><br>  ¯ \ _ (ツ) _ / ¯ <br><br>  (Juga, metode ini melanggar rendering rendering; mungkin lebih bijaksana untuk menetapkan konstanta matriks global dalam praktik daripada menggunakannya untuk setiap materi.) <br><br>  Mari kita kembali ke shader fragmen: kita menggunakan posisi yang diproyeksikan untuk menghitung vektor gerak ruang layar: <br><br><pre> <code class="cpp hljs">float3 hp0 = i.motion_0.xyz / i.motion_0.w; float3 hp1 = i.motion_1.xyz / i.motion_1.w; float2 vp0 = (hp0.xy + <span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>; float2 vp1 = (hp1.xy + <span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> UNITY_UV_STARTS_AT_TOP vp0.y = 1.0 - vp0.y; vp1.y = 1.0 - vp1.y; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> float2 vel = vp1 - vp0;</span></span></code> </pre> <br>  (Perhitungan vektor gerakan hampir tidak berubah diambil dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">https://github.com/keijiro/ParticleMotionVector/blob/master/Assets/ParticleMotionVector/Shaders/Motion.cginc</a> ) <br><br>  Akhirnya, nilai terakhir dalam buffer cairan adalah noise.  Saya menggunakan angka acak yang stabil untuk setiap partikel untuk memilih satu dari empat suara (dikemas dalam satu tekstur tunggal).  Kemudian diskalakan dengan kecepatan dan kesatuan minus ukuran partikel (oleh karena itu, partikel cepat dan kecil lebih berisik).  Nilai noise ini digunakan dalam shading pass untuk mendistorsi normals dan menambahkan lapisan busa.  Karya Green menggunakan noise putih tiga saluran, tetapi karya yang lebih baru (Screen Space Fluid Rendering with Curvature Flow) mengusulkan untuk menggunakan noise Perlin.  Saya menggunakan noise Voronoi / noise sel dengan skala yang berbeda: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/743/9f4/c0b/7439f4c0beebbc16cbfa536c516b2fcf.png"></div><br><h3>  Mencampur Masalah (dan Penanganan Masalah) </h3><br>  Dan di sini masalah pertama implementasi saya muncul.  Untuk perhitungan yang benar dari ketebalan partikel dicampur secara aditif.  Karena pencampuran mempengaruhi semua keluaran, ini berarti vektor noise dan gerakan juga tercampur secara aditif.  Aditif suara cukup cocok untuk kita, tetapi bukan vektor aditif, dan jika kamu membiarkannya apa adanya, kamu akan mendapatkan waktu anti-aliasing (TAA) dan motion blur yang menjijikkan.  Untuk mengatasi masalah ini, saat merender penyangga fluida, saya cukup mengalikan vektor gerakan dengan ketebalan dan membaginya dengan ketebalan total dalam lintasan bayangan.  Ini memberi kita vektor gerakan rata-rata tertimbang untuk semua partikel yang tumpang tindih;  tidak cukup apa yang kita butuhkan (artefak aneh dibuat ketika beberapa jet berpotongan), tetapi cukup dapat diterima. <br><br>  Masalah yang lebih kompleks adalah kedalaman;  Untuk rendering kedalaman yang tepat, kita harus memiliki rekaman kedalaman dan pemeriksaan kedalaman yang aktif.  Ini dapat menyebabkan masalah jika partikel tidak diurutkan (karena perbedaan dalam urutan rendering dapat menyebabkan output partikel yang tumpang tindih oleh orang lain menjadi terpotong).  Karena itu, kami memesan sistem partikel Unity untuk mengurutkan partikel berdasarkan kedalaman, dan kemudian kami menyilangkan jari dan harapan kami.  sistem itu juga akan menyajikan secara mendalam.  Kami akan * memiliki * kasus sistem yang tumpang tindih (misalnya, persimpangan dua jet partikel) yang tidak diproses dengan benar, yang akan menyebabkan ketebalan yang lebih kecil.  Tapi ini tidak terlalu sering terjadi, dan tidak terlalu memengaruhi penampilan. <br><br>  Kemungkinan besar, pendekatan yang benar adalah membuat kedalaman dan penyangga warna benar-benar terpisah;  pengembalian untuk ini adalah rendering dua-pass.  Ada baiknya mengeksplorasi masalah ini ketika mengatur sistem. <br><br><h3>  Kedalaman penghalusan </h3><br>  Akhirnya, hal terpenting dalam teknik Hijau.  Kami membuat sekelompok bola bundar ke dalam buffer kedalaman, tetapi pada kenyataannya, air tidak terdiri dari "bola".  Jadi sekarang kita ambil perkiraan ini dan mengaburkannya agar lebih seperti permukaan cairan. <br><br>  Pendekatan naif adalah dengan hanya menerapkan kedalaman noise Gaussian ke seluruh buffer.  Ini menciptakan hasil yang aneh - itu menghaluskan titik jauh lebih dari yang dekat, dan mengaburkan tepi siluet.  Sebagai gantinya, kita dapat mengubah radius blur secara mendalam, dan menggunakan blur dua sisi untuk menghemat tepinya. <br><br>  Hanya satu masalah muncul di sini: perubahan seperti itu membuat blur tidak bisa dibedakan.  Blur bersama dapat dilakukan dalam dua lintasan: blur secara horizontal, dan kemudian secara vertikal.  Pengaburan yang tidak bisa dibedakan dilakukan dalam satu pass.  Perbedaan ini penting karena skala blur yang dibagi secara linear (O (w) + O (h)), dan skala blur yang tidak dibagi secara tepat (O (w * h)).  Pengaburan dalam skala besar dan tidak dibagi dengan cepat menjadi tidak berlaku dalam praktik. <br><br>  Sebagai orang dewasa, pengembang yang bertanggung jawab, kita dapat membuat langkah yang jelas: tutup mata, berpura-pura bahwa kebisingan dua arah * dibagikan *, dan masih menerapkannya dengan lorong horizontal dan vertikal yang terpisah. <br><br>  Green dalam presentasinya menunjukkan bahwa meskipun pendekatan ini <i>menciptakan</i> artefak dalam hasil yang dihasilkan (terutama ketika merekonstruksi normals), tahap naungan menyembunyikannya dengan baik.  Ketika bekerja dengan aliran air yang lebih sempit yang saya buat, artefak ini bahkan kurang terlihat dan tidak terlalu mempengaruhi hasilnya. <br><br><h3>  Shading </h3><br>  Kami akhirnya selesai bekerja dengan buffer cairan.  Sekarang mari kita beralih ke bagian kedua dari efek: naungan dan penggabungan gambar utama. <br><br>  Di sini kita menemukan banyak pembatasan rendering Persatuan.  Saya memutuskan untuk menyinari air hanya dengan cahaya matahari dan skybox;  Mendukung sumber pencahayaan tambahan memerlukan beberapa lintasan (ini boros!) Atau membangun struktur pencarian pencahayaan di sisi GPU (mahal dan agak rumit).  Selain itu, karena Unity tidak menyediakan akses ke peta bayangan, dan lampu arah menggunakan bayangan ruang layar (berdasarkan buffer kedalaman yang dihasilkan oleh geometri buram), kami tidak memiliki akses ke informasi tentang bayangan dari sumber cahaya matahari.  Anda dapat melampirkan buffer perintah ke sumber cahaya matahari untuk membuat peta bayangan ruang layar khusus untuk air, tetapi sejauh ini saya belum melakukannya. <br><br>  Tahap terakhir naungan dikontrol melalui skrip, dan menggunakan buffer perintah untuk mengirim panggilan draw.  Ini <i>diperlukan</i> karena tekstur vektor gerak (digunakan untuk anti-aliasing sementara (TAA) dan blur gerak) tidak dapat digunakan untuk rendering langsung menggunakan Graphics.SetRenderTarget ().  Dalam skrip yang dilampirkan ke kamera utama, kami menulis yang berikut ini: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... m_QuadMesh = new Mesh(); m_QuadMesh.subMeshCount = 1; m_QuadMesh.vertices = new Vector3[] { new Vector3(0, 0, 0.1f), new Vector3(1, 0, 0.1f), new Vector3(1, 1, 0.1f), new Vector3(0, 1, 0.1f), }; m_QuadMesh.uv = new Vector2[] { new Vector2(0, 0), new Vector2(1, 0), new Vector2(1, 1), new Vector2(0, 1), }; m_QuadMesh.triangles = new int[] { 0, 1, 2, 0, 2, 3, }; m_QuadMesh.UploadMeshData(false); m_CommandBuffer = new CommandBuffer(); m_CommandBuffer.Clear(); m_CommandBuffer.SetProjectionMatrix( GL.GetGPUProjectionMatrix( Matrix4x4.Ortho(0, 1, 0, 1, -1, 100), false)); m_CommandBuffer.SetRenderTarget( BuiltinRenderTextureType.CameraTarget, BuiltinRenderTextureType.CameraTarget); m_CommandBuffer.DrawMesh( m_QuadMesh, Matrix4x4.identity, m_Mat, 0, m_Mat.FindPass("LIQUIDCOMPOSITE")); m_CommandBuffer.SetRenderTarget( BuiltinRenderTextureType.MotionVectors, BuiltinRenderTextureType.Depth); m_CommandBuffer.DrawMesh( m_QuadMesh, Matrix4x4.identity, m_Mat, 0, m_Mat.FindPass("MOTION")); }</span></span></code> </pre> <br>  Buffer warna dan vektor gerakan tidak dapat dirender secara bersamaan dengan MRT (target multi render).  Saya tidak dapat menemukan alasannya.  Selain itu, mereka membutuhkan pengikatan ke buffer kedalaman yang berbeda.  Untungnya, kami menulis kedalaman untuk <i>kedua</i> buffer kedalaman ini, jadi memproyeksikan ulang anti-aliasing sementara berfungsi dengan baik (oh, senang bekerja dengan mesin "kotak hitam"). <br><br>  Di setiap bingkai, kami membuang render gabungan dari OnPostRender (): <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">RenderTexture </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateRefractionTexture</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RenderTexture result = RenderTexture.GetTemporary(m_MainCamera.activeTexture.descriptor); Graphics.Blit(m_MainCamera.activeTexture, result); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPostRender</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ScreenspaceLiquidCamera &amp;&amp; ScreenspaceLiquidCamera.IsReady()) { RenderTexture refraction_texture = GenerateRefractionTexture(); m_Mat.SetTexture(<span class="hljs-string"><span class="hljs-string">"_MainTex"</span></span>, ScreenspaceLiquidCamera.GetColorBuffer()); m_Mat.SetVector(<span class="hljs-string"><span class="hljs-string">"_MainTex_TexelSize"</span></span>, ScreenspaceLiquidCamera.GetTexelSize()); m_Mat.SetTexture(<span class="hljs-string"><span class="hljs-string">"_LiquidRefractTexture"</span></span>, refraction_texture); m_Mat.SetTexture(<span class="hljs-string"><span class="hljs-string">"_MainDepth"</span></span>, ScreenspaceLiquidCamera.GetDepthBuffer()); m_Mat.SetMatrix(<span class="hljs-string"><span class="hljs-string">"_DepthViewFromClip"</span></span>, ScreenspaceLiquidCamera.GetProjection().inverse); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SunLight) { m_Mat.SetVector(<span class="hljs-string"><span class="hljs-string">"_SunDir"</span></span>, transform.InverseTransformVector(-SunLight.transform.forward)); m_Mat.SetColor(<span class="hljs-string"><span class="hljs-string">"_SunColor"</span></span>, SunLight.color * SunLight.intensity); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { m_Mat.SetVector(<span class="hljs-string"><span class="hljs-string">"_SunDir"</span></span>, transform.InverseTransformVector(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>))); m_Mat.SetColor(<span class="hljs-string"><span class="hljs-string">"_SunColor"</span></span>, Color.white); } m_Mat.SetTexture(<span class="hljs-string"><span class="hljs-string">"_ReflectionProbe"</span></span>, ReflectionProbe.defaultTexture); m_Mat.SetVector(<span class="hljs-string"><span class="hljs-string">"_ReflectionProbe_HDR"</span></span>, ReflectionProbe.defaultTextureHDRDecodeValues); Graphics.ExecuteCommandBuffer(m_CommandBuffer); RenderTexture.ReleaseTemporary(refraction_texture); } }</code> </pre> <br>  Dan di sinilah partisipasi CPU berakhir, kemudian hanya shader pergi. <br><br>  Mari kita mulai dengan berjalannya vektor gerakan.  Beginilah keseluruhan bentuk shader: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"UnityCG.cginc"</span></span></span><span class="hljs-meta"> sampler2D _MainDepth; sampler2D _MainTex; struct appdata { float4 vertex : POSITION; float2 uv : TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD0; float4 vertex : SV_POSITION; }; v2f vert(appdata v) { v2f o; o.vertex = mul(UNITY_MATRIX_P, v.vertex); o.uv = v.uv; return o; } struct frag_out { float4 color : SV_Target; float depth : SV_Depth; }; frag_out frag(v2f i) { frag_out o; float4 fluid = tex2D(_MainTex, i.uv); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (fluid.a == 0) discard; o.depth = tex2D(_MainDepth, i.uv).r; float2 vel = fluid.gb / fluid.a; o.color = float4(vel, 0, 1); return o; }</span></span></code> </pre> <br>  Kecepatan dalam ruang layar disimpan dalam saluran hijau dan biru dari buffer fluida.  Karena kami meningkatkan kecepatan dengan ketebalan saat merender buffer, kami membagi lagi ketebalan total (yang terletak di saluran alpha) untuk mendapatkan kecepatan rata-rata tertimbang. <br><br>  Perlu dicatat bahwa ketika bekerja dengan volume air yang besar, metode lain untuk memproses buffer kecepatan mungkin diperlukan.  Karena kita membuat tanpa pencampuran, vektor gerakan untuk semua yang ada di <i>belakang</i> air hilang, menghancurkan TAA dan mengaburkan gerakan dari benda-benda ini.  Saat bekerja dengan aliran air yang tipis, ini bukan masalah, tapi itu bisa mengganggu saat bekerja dengan kolam atau danau ketika kita membutuhkan TAA atau benda buram gerak agar terlihat jelas melalui permukaan. <br><br>  Lebih menarik adalah lulus naungan utama.  Prioritas pertama kami setelah penutupan dengan ketebalan cairan adalah merekonstruksi posisi dan ruang tampilan normal (ruang tampilan). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ViewPosition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 uv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> clip_z = tex2D(_MainDepth, uv).r; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> clip_x = uv.x * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> clip_y = <span class="hljs-number"><span class="hljs-number">1.0</span></span> - uv.y * <span class="hljs-number"><span class="hljs-number">2.0</span></span>; float4 clip_p = float4(clip_x, clip_y, clip_z, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); float4 view_p = mul(_DepthViewFromClip, clip_p); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (view_p.xyz / view_p.w); } <span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReconstructNormal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 uv, float3 vp11)</span></span></span><span class="hljs-function"> </span></span>{ float3 vp12 = ViewPosition(uv + _MainTex_TexelSize.xy * float2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)); float3 vp10 = ViewPosition(uv + _MainTex_TexelSize.xy * float2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>)); float3 vp21 = ViewPosition(uv + _MainTex_TexelSize.xy * float2(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); float3 vp01 = ViewPosition(uv + _MainTex_TexelSize.xy * float2(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); float3 dvpdx0 = vp11 - vp12; float3 dvpdx1 = vp10 - vp11; float3 dvpdy0 = vp11 - vp21; float3 dvpdy1 = vp01 - vp11; <span class="hljs-comment"><span class="hljs-comment">// Pick the closest float3 dvpdx = dot(dvpdx0, dvpdx0) &gt; dot(dvpdx1, dvpdx1) ? dvpdx1 : dvpdx0; float3 dvpdy = dot(dvpdy0, dvpdy0) &gt; dot(dvpdy1, dvpdy1) ? dvpdy1 : dvpdy0; return normalize(cross(dvpdy, dvpdx)); }</span></span></code> </pre> <br>  Ini adalah cara yang mahal untuk merekonstruksi posisi ruang tampilan: kami mengambil posisi di ruang klip dan melakukan operasi proyeksi terbalik. <br><br>  Setelah kami mendapatkan cara untuk merekonstruksi posisi, normalnya lebih sederhana: kami menghitung posisi titik-titik tetangga di buffer kedalaman dan membangun basis garis singgung dari mereka.  Untuk bekerja dengan tepi siluet, kami mengambil sampel di kedua arah dan memilih titik terdekat dengan ruang tampilan untuk merekonstruksi yang normal.  Metode ini bekerja sangat baik dan menyebabkan masalah hanya pada benda yang sangat tipis. <br><br>  Ini berarti bahwa kami melakukan lima operasi proyeksi mundur terpisah per piksel (untuk titik saat ini dan empat yang berdekatan).  Ada cara yang lebih murah, tetapi posting ini sudah terlalu lama, jadi saya akan meninggalkannya untuk nanti. <br><br>  Normal yang dihasilkan adalah: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2c/0ed/7f6/b2c0ed7f6cfcc66473ff4e5380c46894.png"></div><br>  Saya mendistorsi normal yang dihitung ini menggunakan turunan dari nilai kebisingan dari buffer fluida, diskalakan oleh parameter gaya dan dinormalisasi dengan membaginya dengan ketebalan jet (untuk alasan yang sama seperti untuk kecepatan): <br><br><pre> <code class="cpp hljs">N.xy += NoiseDerivatives(i.uv, fluid.r) * (_NoiseStrength / fluid.a); N = normalize(N);</code> </pre> <br>  Kami akhirnya dapat melanjutkan dengan naungan itu sendiri.  Naungan air terdiri dari tiga bagian utama: refleksi specular, refraksi specular dan busa. <br><br>  Refleksi adalah GGX standar yang diambil seluruhnya dari standar Unity shader.  (Dengan satu koreksi, F0 2% yang benar digunakan untuk air.) <br><br>  Dengan pembiasan, semuanya jadi lebih menarik.  Pembiasan yang benar membutuhkan raytracing (atau raymarching untuk hasil perkiraan).  Untungnya, pembiasan kurang intuitif untuk mata daripada refleksi, dan karena itu hasil yang salah tidak begitu terlihat.  Oleh karena itu, kami menggeser sampel UV untuk tekstur bias dengan normals x dan y, diskalakan oleh parameter tebal dan gaya: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> aspect = _MainTex_TexelSize.y * _MainTex_TexelSize.z; float2 refract_uv = (i.grab_pos.xy + N.xy * float2(<span class="hljs-number"><span class="hljs-number">1</span></span>, -aspect) * fluid.a * _RefractionMultiplier) / i.grab_pos.w; float4 refract_color = tex2D(_LiquidRefractTexture, refract_uv);</code> </pre> <br>  (Perhatikan bahwa koreksi korelasi digunakan; ini <i>opsional</i> - setelah semua, itu hanya perkiraan, tetapi menambahkannya cukup sederhana.) <br><br>  Cahaya yang dibiaskan ini melewati cairan, sehingga sebagian diserap: <br><br><pre> <code class="cpp hljs">float3 water_color = _AbsorptionColor.rgb * _AbsorptionIntensity; refract_color.rgb *= <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(-water_color * fluid.a);</code> </pre> <br>  Perhatikan bahwa _AbsorptionColor ditentukan dengan kebalikan dari cara yang diharapkan: nilai dari masing-masing saluran menunjukkan jumlah cahaya yang <i>diserap</i> daripada cahaya yang ditransmisikan.  Oleh karena itu, _AbsorptionColor dengan nilai (1, 0, 0) tidak memberikan warna merah, tetapi warna pirus (teal). <br><br>  Refleksi dan refraksi dicampur menggunakan koefisien Fresnel: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> spec_blend = lerp(<span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - ldoth, <span class="hljs-number"><span class="hljs-number">5</span></span>)); float4 clear_color = lerp(refract_color, spec, spec_blend);</code> </pre> <br>  Sampai saat itu, kami bermain sesuai aturan (kebanyakan) dan menggunakan naungan fisik. <br><br>  Dia cukup baik, tetapi dia memiliki masalah dengan air.  Agak sulit dilihat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff2/4f2/ba2/ff24f2ba2dad5dc6fe7714ad3fd55124.png"></div><br>  Untuk memperbaikinya, mari tambahkan busa. <br><br>  Busa muncul ketika air bergolak dan udara bercampur dengan air untuk membentuk gelembung.  Gelembung semacam itu menciptakan semua jenis variasi refleksi dan pembiasan, yang memberi semua air rasa pencahayaan yang menyebar.  Saya akan memodelkan perilaku ini dengan cahaya sekitar yang dibungkus: <br><br><pre> <code class="cpp hljs">float3 foam_color = _SunColor * saturate((dot(N, L)*<span class="hljs-number"><span class="hljs-number">0.25f</span></span> + <span class="hljs-number"><span class="hljs-number">0.25f</span></span>));</code> </pre> <br>  Ini ditambahkan ke warna akhir menggunakan faktor khusus, tergantung pada kebisingan cairan dan koefisien Fresnel melunak: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> foam_blend = saturate(fluid.r * _NoiseStrength) * lerp(<span class="hljs-number"><span class="hljs-number">0.05f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(<span class="hljs-number"><span class="hljs-number">1.0f</span></span> - ndotv, <span class="hljs-number"><span class="hljs-number">3</span></span>)); clear_color.rgb += foam_color * saturate(foam_blend);</code> </pre> <br>  Pencahayaan ambient yang dibungkus dinormalisasi untuk menghemat energi sehingga dapat digunakan sebagai perkiraan difusi.  Pencampuran warna busa lebih terlihat.  Ini merupakan pelanggaran yang cukup jelas terhadap hukum konservasi energi. <br><br>  Namun secara umum, semuanya terlihat bagus dan membuat aliran lebih terlihat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/216/ca8/1f5/216ca81f5eb506eab2dbcfc730a904b4.png"></div><br><h3>  Pekerjaan dan perbaikan lebih lanjut </h3><br>  Dalam sistem yang dibuat, banyak yang bisa diperbaiki. <br><br><ul><li>  Menggunakan banyak warna.  Saat ini, penyerapan dihitung hanya pada tahap terakhir naungan dan menggunakan warna dan kecerahan konstan untuk semua cairan pada layar.  Dukungan untuk warna yang berbeda dimungkinkan, tetapi membutuhkan buffer warna kedua dan solusi integral penyerapan untuk setiap partikel dalam proses rendering buffer fluida dasar.  Ini berpotensi menjadi operasi yang mahal. </li><li>  Cakupan penuh.  Memiliki akses ke struktur pencarian pencahayaan di sisi GPU (baik dibangun dengan tangan, atau berkat ikatan dengan pipa render Unity HD yang baru), kami dapat menerangi air dengan baik dengan sejumlah sumber cahaya dan menciptakan pencahayaan sekitar yang tepat. </li><li>  Perbaikan refraksi.  Dengan tekstur mip buram dari tekstur latar belakang, kita dapat mensimulasikan dengan lebih baik refraksi untuk permukaan kasar.  Dalam praktiknya, ini tidak terlalu berguna untuk semprotan cairan kecil, tetapi mungkin berguna untuk volume yang lebih besar. </li></ul><br>  Jika saya memiliki kesempatan, saya akan meningkatkan sistem ini hingga kehilangan denyut nadi, tetapi saat ini dapat disebut lengkap. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420495/">https://habr.com/ru/post/id420495/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420479/index.html">Ketergantungan injeksi dalam layanan Apache Ignite.NET</a></li>
<li><a href="../id420487/index.html">Bisnis meminta hak untuk data pribadi pengguna</a></li>
<li><a href="../id420489/index.html">Prosesor ARM baru dapat bersaing dengan Core i5</a></li>
<li><a href="../id420491/index.html">Caraku seorang pejuang, atau bagaimana aku menyiapkan aplikasi untuk hidup di Sailfish</a></li>
<li><a href="../id420493/index.html">Bisakah layanan pemesanan makanan Amerika menjadi Amazon di dunia restoran</a></li>
<li><a href="../id420497/index.html">Singularity Sayuran: Kroger Meluncurkan Robocouriers untuk Pelanggan Buah dan Sayuran di Arizona</a></li>
<li><a href="../id420499/index.html">Anatomi sistem rekomendasi. Bagian satu</a></li>
<li><a href="../id420501/index.html">Linux dalam RAM: cara debirf 2018</a></li>
<li><a href="../id420503/index.html">Hari Pengembang JS, berbagai kota dan komunitas - satu hari libur</a></li>
<li><a href="../id420505/index.html">Akankah OpenAI Five memenangkan tim profesional di The International</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>