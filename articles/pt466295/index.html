<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì® üëÜüèº üóÇÔ∏è Cache de reserva indolor no Scala ‚õπüèø üíõ ü§µüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em arquiteturas grandes ou de microsservi√ßos, o servi√ßo mais importante nem sempre √© o mais produtivo e, √†s vezes, n√£o se destina a carga alta. Estamo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cache de reserva indolor no Scala</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/466295/"> Em arquiteturas grandes ou de microsservi√ßos, o servi√ßo mais importante nem sempre √© o mais produtivo e, √†s vezes, n√£o se destina a carga alta.  Estamos falando sobre o back-end.  Funciona devagar - perde tempo no processamento de dados e aguarda uma resposta entre ele e o DBMS e n√£o √© escal√°vel.  Mesmo que o pr√≥prio aplicativo seja dimensionado com facilidade, esse gargalo n√£o ser√° dimensionado.  Como resolver esse problema e garantir alto desempenho?  Como fornecer uma resposta do sistema quando fontes importantes de informa√ß√£o est√£o silenciosas? <br><br><img src="https://habrastorage.org/webt/tw/3o/ti/tw3otiqpnki3jcwa8ittvdrpzoc.jpeg"><br><br>  Se sua arquitetura estiver em total conformidade com o manifesto Reativo, os componentes do aplicativo ser√£o escalados indefinidamente com o aumento da carga independentemente um do outro e suportar√£o a queda de qualquer n√≥ - voc√™ sabe a resposta.  Mas, se n√£o, <b>Oleg Nizhnikov</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Odomontois</a> ) dir√° como o problema de escalabilidade foi resolvido em Tinkoff, criando seu indolor Fallback Cache no Scala sem reescrever o aplicativo. <br><br>  <i>Nota</i>  <i>O artigo ter√° um m√≠nimo de c√≥digo Scala e um m√°ximo de princ√≠pios e id√©ias gerais.</i> <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/p9j6_nOP4Kk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  Back-end inst√°vel ou lento </h2><br>  Ao interagir com o back-end, o aplicativo m√©dio √© r√°pido.  Mas o back-end faz a maior parte do trabalho e m√≥i a maioria dos dados internamente - leva mais tempo.  Perde-se tempo extra aguardando uma resposta de back-end e DBMS.  Mesmo que o pr√≥prio aplicativo seja dimensionado com facilidade, esse gargalo n√£o ser√° dimensionado.  Como aliviar a carga no back-end e resolver o problema? <br><div class="scrollable-table"><table><tbody><tr><td></td><td>  <b>Seu servi√ßo</b> <br></td><td>  <b>Backend</b> <br></td></tr><tr><td>  Tempo l√≠quido de trabalho em cada resposta: (des) serializa√ß√£o, verifica√ß√µes, l√≥gica, custos de assincronia <br></td><td>  53 ms <br></td><td>  785ms <br></td></tr><tr><td>  Aguardando back-end e DBMS <br></td><td>  3015 ms <br></td><td>  1932 ms <br></td></tr><tr><td>  N√∫mero de n√≥s <br></td><td>  32. <br></td><td>  2 <br></td></tr><tr><td>  Resposta resumida <br></td><td>  3070 ms <br></td><td>  2702 ms <br></td></tr></tbody></table></div><br><h3>  Cache incorporado </h3><br>  A primeira id√©ia √© levar os dados para leitura, solicita√ß√µes que recebem dados e configurar o cache no n√≠vel de cada n√≥ da mem√≥ria. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e98/e7d/18f/e98e7d18f9f43d97f36941011d82b3b4.jpg"><br><br>  O cache permanece at√© que o n√≥ reinicie e armazene apenas a √∫ltima parte de dados.  Se o aplicativo travar e novos usu√°rios que n√£o estiveram na √∫ltima hora, dia ou semana entrarem, o aplicativo n√£o poder√° fazer nada a respeito. <br><br><h3>  Proxy </h3><br>  A segunda op√ß√£o √© um proxy, que assume parte das solicita√ß√µes ou modifica o aplicativo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ff/817/a49/7ff817a49b919c269c55e9995eaca4f0.jpg"><br><br>  Mas no proxy, voc√™ n√£o pode fazer todo o trabalho para o pr√≥prio aplicativo. <br><br><h3>  Banco de dados em cache </h3><br>  A terceira op√ß√£o √© complicada quando a parte dos dados retornados pelo back-end pode ser armazenada por um longo tempo.  Quando eles s√£o necess√°rios, mostramos ao cliente, mesmo que eles n√£o sejam mais relevantes.  Isso √© melhor que nada. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/024/8a3/72f/0248a372f78828298f116a711321a55f.jpg"><br><br>  Esta decis√£o ser√° discutida. <br><br><h2>  Cache de fallback </h2><br>  Esta √© a nossa biblioteca.  Ele √© incorporado ao aplicativo e se comunica com o back-end.  Com um refinamento m√≠nimo, ele analisa a estrutura dos dados, gera formatos de serializa√ß√£o e, com a ajuda do algoritmo do disjuntor, aumenta a toler√¢ncia a falhas.  A serializa√ß√£o eficaz pode ser implementada em qualquer idioma em que os tipos possam ser analisados ‚Äã‚Äãcom anteced√™ncia se forem definidos estritamente o suficiente. <br><br><h3>  Componentes </h3><br>  Nossa biblioteca se parece com isso. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/906/57c/ce0/90657cce0e43cbaf09ba1a38b3e8eaff.jpg"><br><br>  A parte esquerda √© dedicada √† intera√ß√£o com este reposit√≥rio, que inclui dois componentes importantes: <br><br><ul><li>  o componente respons√°vel pelo processo de inicializa√ß√£o - a√ß√µes preliminares com o DBMS antes de usar o Cache de Fallback; <br></li><li>  m√≥dulo de gera√ß√£o de serializa√ß√£o autom√°tica. <br></li></ul><br>  O lado direito √© a funcionalidade geral relacionada ao Fallback. <br><br>  Como tudo isso funciona?  Existem consultas no meio do aplicativo e tipos intermedi√°rios para armazenar o estado.  Este formul√°rio expressa os dados que recebemos do back-end para uma ou mais solicita√ß√µes.  Enviamos os par√¢metros para o nosso m√©todo e obtemos os dados a partir da√≠.  Esses dados precisam ser serializados de alguma forma para serem armazenados, portanto, agrupamos-os no c√≥digo.  Um m√≥dulo separado √© respons√°vel por isso.  Utilizamos o padr√£o do disjuntor. <br><br><h3>  Requisitos de armazenamento </h3><br>  <b>Vida √∫til longa - 30-500 dias</b> .  Algumas a√ß√µes podem levar muito tempo e todo esse tempo √© necess√°rio para armazenar dados.  Portanto, queremos um armazenamento que possa armazenar dados por um longo tempo.  A mem√≥ria n√£o √© adequada para isso. <br><br>  <b>Grande volume de dados - 100 GB-20 TB</b> .  Queremos armazenar dezenas de terabytes de dados no cache e ainda mais devido ao crescimento.  Manter tudo isso na mem√≥ria √© ineficiente - a maioria dos dados n√£o √© solicitada constantemente.  Eles ficam muito tempo esperando o usu√°rio, que entra e pergunta.  A mem√≥ria n√£o se enquadra nesses requisitos. <br><br>  <b>Alta disponibilidade de dados</b> .  Tudo pode acontecer com o servi√ßo, mas queremos que o DBMS permane√ßa dispon√≠vel o tempo todo. <br><br>  <b>Baixos custos de armazenamento</b> .  Enviamos dados adicionais para o cache.  Como resultado, ocorre sobrecarga.  Ao implementar nossa solu√ß√£o, queremos minimiz√°-la. <br><br>  <b>Suporte para consultas em intervalos</b> .  Nosso banco de dados deveria ter sido capaz de extrair um dado n√£o apenas em sua totalidade, mas a intervalos: uma lista de a√ß√µes, o hist√≥rico de um usu√°rio por um determinado per√≠odo.  Portanto, um valor de chave puro n√£o √© adequado. <br><br><h3>  Pressupostos </h3><br>  Os requisitos restringem a lista de candidatos.  Assumimos que implementamos o restante e fazemos as seguintes suposi√ß√µes, sabendo por que exatamente precisamos do Cache de Fallback. <br><br>  <b>A integridade dos dados entre duas solicita√ß√µes GET diferentes n√£o √© necess√°ria</b> .  Portanto, se eles exibirem dois estados diferentes que n√£o s√£o consistentes um com o outro, vamos tolerar isso. <br><br>  <b>A relev√¢ncia e a invalida√ß√£o de dados n√£o s√£o necess√°rias</b> .  No momento da solicita√ß√£o, presume-se que tenhamos a vers√£o mais recente que estamos mostrando. <br><br>  Enviamos e recebemos dados do back-end.  <b>A estrutura desses dados √© conhecida antecipadamente</b> . <br><br><h2>  Sele√ß√£o de armazenamento </h2><br>  Como alternativas, consideramos tr√™s op√ß√µes principais. <br><br>  O primeiro √© <b>Cassandra</b> .  Vantagens: alta disponibilidade, f√°cil escalabilidade e mecanismo de serializa√ß√£o integrado com a cole√ß√£o UDT. <br><br>  <b>UDT</b> ou <b>tipos definidos pelo usu√°rio</b> , significa algum tipo.  Eles permitem que voc√™ empilhe com efici√™ncia tipos estruturados.  Os campos de tipo s√£o conhecidos antecipadamente.  Esses campos de serializa√ß√£o s√£o marcados com tags separadas, como em Buffers de protocolo.  Depois de ler essa estrutura, √© poss√≠vel entender quais campos existem com base em tags.  Metadados suficientes para descobrir seu nome e tipo. <br><br>  Outra vantagem do Cassandra √© que, al√©m da chave de parti√ß√£o, ela possui uma <b>chave de cluster</b> adicional.  Essa √© uma chave especial, devido √† qual os dados s√£o ordenados em um n√≥.  Isso permite implementar uma op√ß√£o, como consultas com intervalo. <br><br>  O Cassandra existe h√° um tempo relativamente longo, existem <b>muitas solu√ß√µes de monitoramento</b> e <b>um deles √© a JVM</b> .  Essa n√£o √© a op√ß√£o mais produtiva para plataformas nas quais voc√™ pode gravar um DBMS.  A JVM tem problemas com coleta de lixo e sobrecarga. <br><br>  A segunda op√ß√£o √© o <b>CouchBase</b> .  Vantagens: acessibilidade, escalabilidade e esquemas de dados. <br><br>  Com o CouchBase, voc√™ precisa pensar menos sobre serializa√ß√£o.  Isso √© positivo e negativo - n√£o precisamos controlar o esquema de dados.  Existem √≠ndices globais que permitem executar consultas de intervalo globalmente em um cluster. <br><br>  O CouchBase √© um h√≠brido no qual o <b>Memcache √©</b> adicionado a um DBMS comum <b>- cache r√°pido</b> .  Ele permite armazenar em cache automaticamente todos os dados no n√≥ - o mais quente, com disponibilidade muito alta.  Gra√ßas ao seu cache, o CouchBase pode ser r√°pido se os mesmos dados forem solicitados com muita frequ√™ncia. <br><br>  <b>Schemaless</b> e <b>JSON</b> tamb√©m podem ser um <b>sinal de</b> menos.  Os dados podem ser armazenados por tanto tempo que o aplicativo tem tempo para mudar.  Nesse caso, a estrutura de dados que o CouchBase vai armazenar e ler tamb√©m ser√° alterada.  A vers√£o anterior pode n√£o ser compat√≠vel.  Voc√™ s√≥ aprender√° sobre isso ao ler, e n√£o ao desenvolver dados, quando estiverem em algum lugar da produ√ß√£o.  Temos que pensar na migra√ß√£o adequada, e √© exatamente isso que n√£o queremos fazer. <br><br>  A terceira op√ß√£o √© <b>Tarantool</b> .  √â famoso por sua super velocidade.  Ele possui um maravilhoso mecanismo LUA que permite escrever um monte de l√≥gica que ser√° executada diretamente no servidor no LuaJit. <br><br>  Por outro lado, esse √© um valor de chave modificado.  Os dados s√£o armazenados em tuplas.  Precisamos pensar por n√≥s mesmos na serializa√ß√£o correta, isso nem sempre √© uma tarefa √≥bvia.  O Tarantool tamb√©m possui uma abordagem espec√≠fica para <b>escalabilidade</b> .  O que h√° de errado com ele, discutiremos mais adiante. <br><br><h3>  Fragmento / replica√ß√£o </h3><br>  Talvez nosso aplicativo precise de <b>Sharding / Replication</b> .  Tr√™s reposit√≥rios os implementam de maneira diferente. <br><br>  Cassandra sugere uma estrutura que geralmente √© chamada de "anel". <br><br><img src="https://habrastorage.org/getpro/habr/post_images/387/b22/828/387b228289ece281dd70ecea2ded8890.jpg"><br><br>  Muitos n√≥s est√£o dispon√≠veis.  Cada um deles armazena seus dados e dados dos n√≥s mais pr√≥ximos como r√©plicas.  Se um cair, os n√≥s pr√≥ximos a ele poder√£o servir parte de seus dados at√© que o dropout aumente. <br><br>  Sharding \ Replication √© respons√°vel pela mesma estrutura.  Para descompactar em 10 partes e no fator de replica√ß√£o 3, 10 n√≥s s√£o suficientes.  Cada um dos n√≥s armazenar√° 2 r√©plicas dos vizinhos. <br><br>  No CouchBase, a estrutura de intera√ß√£o entre n√≥s √© estruturada da mesma forma: <br><br><ul><li>  existem dados marcados como ativos, pelos quais o pr√≥prio n√≥ √© respons√°vel; <br></li><li>  Existem r√©plicas de n√≥s vizinhos que o CouchBase armazena. <br></li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/296/09a/1c8/29609a1c8391653566cb36ab9434da21.jpg"><br><br>  Se um n√≥ cair, os vizinhos, compartilhados, assumir√£o a responsabilidade pela manuten√ß√£o dessa parte das chaves. <br><br>  No Tarantool, a arquitetura √© semelhante ao MongoDB.  Mas com uma nuance: existem grupos de sharding replicados entre si. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e81/5f8/5a5/e815f85a59d330b8250071def6cc0d25.jpg"><br><br>  Para as duas arquiteturas anteriores, se queremos criar 4 shards e o fator de replica√ß√£o 3, s√£o necess√°rios 4 n√≥s.  Para Tarantool - 12!  Mas a desvantagem √© compensada pela velocidade que o Tarantool garante. <br><br><h2>  Cassandra </h2><br>  M√≥dulos opcionais para fragmenta√ß√£o em Tarantool apareceram apenas recentemente.  Portanto, escolhemos o DBMS Cassandra como candidato principal.  Lembre-se de que falamos sobre sua serializa√ß√£o espec√≠fica. <br><br><h3>  Serializa√ß√£o autom√°tica </h3><br><blockquote>  O protocolo SQL pressup√µe que voc√™ seja bastante livre para definir um esquema de dados. </blockquote><br>  Voc√™ pode usar isso como uma vantagem.  Por exemplo, serialize dados para que os nomes extensos de campos de nossas estruturas frondosas n√£o sejam armazenados sempre em nossos valores.  Nesse caso, teremos alguns metadados que descrevem o dispositivo de dados.  As pr√≥prias UDTs tamb√©m informam quais campos correspondem a r√≥tulos e tags. <br><br>  Portanto, a serializa√ß√£o gerada automaticamente ocorre aproximadamente da mesma maneira.  Se tivermos um dos tipos b√°sicos que podem corresponder ao tipo do banco de dados de um para um, faremos isso.  Um conjunto de tipos Int, Long, String, Double tamb√©m est√° em Cassandra. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Tipo de Dados do Aplicativo</b> <br></td><td>  <b>Tipo de dados em cassandra</b> <br></td></tr><tr><td>  Tipo primitivo <br>  (Int, Longo, String, Duplo, BigDecimal) <br></td><td>  Tipo primitivo <br>  (int, biging, texto, duplo, decimal) <br></td></tr></tbody></table></div><br>  Se um campo opcional for encontrado em alguma estrutura, n√£o faremos nada extra.  Indicamos para ele o tipo em que esse campo deve se transformar.  A estrutura armazenar√° nulo.  Se encontrarmos nulo na estrutura no n√≠vel de desserializa√ß√£o, assumimos que esse n√£o √© o valor. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Tipo de Dados do Aplicativo</b> <br></td><td>  <b>Tipo de dados em cassandra</b> <br></td></tr><tr><td>  Op√ß√£o [A] <br></td><td>  a <br></td></tr></tbody></table></div><br>  Todos os tipos de cole√ß√£o da cole√ß√£o no Scala s√£o convertidos em lista de tipos.  Essas s√£o cole√ß√µes ordenadas que possuem um elemento correspondente ao √≠ndice. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Tipo de Dados do Aplicativo</b> <br></td><td>  <b>Tipo de dados em cassandra</b> <br></td></tr><tr><td>  Seq [A], Lista [A], Fluxo [A], Vetor [A] <br></td><td>  congelado &lt;lista "a"&gt; <br></td></tr></tbody></table></div><br>  Cole√ß√µes de conjuntos n√£o ordenados garantem que exista exatamente um elemento com cada valor.  Cassandra tamb√©m tem um tipo de conjunto especial para eles. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Tipo de Dados do Aplicativo</b> <br></td><td>  <b>Tipo de dados em cassandra</b> <br></td></tr><tr><td>  Defina [A] <br></td><td>  congelado &lt;conjunto "a"&gt; <br></td></tr></tbody></table></div><br>  Provavelmente, teremos muito mapeamento (), especialmente com chaves de string.  Cassandra tem um tipo de mapa especial para eles.  Tamb√©m √© digitado e possui dois par√¢metros de tipo.  Para que possamos criar um tipo apropriado para qualquer chave <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Tipo de Dados do Aplicativo</b> <br></td><td>  <b>Tipo de dados em cassandra</b> <br></td></tr><tr><td>  Mapa [K, V] <br></td><td>  congelado &lt;mapa "k, v"&gt; <br></td></tr></tbody></table></div><br>  Existem tipos de dados que nos definimos em nosso aplicativo.  Em muitos idiomas, eles s√£o chamados de <b>tipos de dados alg√©bricos</b> .  Eles s√£o definidos pela defini√ß√£o de um produto nomeado de tipos, ou seja, uma estrutura.  Atribu√≠mos essa estrutura ao tipo definido pelo usu√°rio.  Cada campo da estrutura corresponder√° a um campo na UDT. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Tipo de Dados do Aplicativo</b> <br></td><td>  <b>Tipo de dados em cassandra</b> <br></td></tr><tr><td>  Tipo Produto: classe de caso <br></td><td>  UDT <br></td></tr></tbody></table></div><br>  O segundo tipo √© a <b>soma alg√©brica de tipos</b> .  Nesse caso, o tipo corresponde a v√°rios subtipos ou subesp√©cies anteriormente conhecidas.  Al√©m disso, de certa maneira, atribu√≠mos uma estrutura a ela. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Tipo de Dados do Aplicativo</b> <br></td><td>  <b>Tipo de dados em cassandra</b> <br></td></tr><tr><td>  Tipo Soma: caracter√≠stica selada \ classe <br></td><td>  UDT <br></td></tr></tbody></table></div><br><h3>  Resumo Tipo de Dados traduzir para UDT </h3><br>  Temos uma estrutura e a exibimos um a um - para cada campo, definimos o campo na UDT criada no Cassandra: <br><br><pre><code class="plaintext hljs">case class Account ( id: Long, tags: List[String], user: User, finData: Option[FinData] ) create type account ( id bigint, tags: frozen&lt;list&lt;text&gt;&gt;, user frozen&lt;user&gt;, fin_data frozen&lt;fin_data&gt; )</code> </pre> <br>  Tipos primitivos se transformam em tipos primitivos.  Um link para um tipo predefinido antes de congelar.  Este √© um inv√≥lucro especial no Cassandra, o que significa que voc√™ n√£o pode ler este campo, pe√ßa por pe√ßa.  O wrapper √© "congelado" nesse estado.  S√≥ podemos ler ou salvar o usu√°rio, ou a lista, como no caso de tags. <br><br>  Se encontrarmos um campo opcional, descartamos essa caracter√≠stica.  Tomamos apenas o tipo de dados correspondente ao tipo de campo que ser√°.  Se encontrarmos n√£o aqui - a aus√™ncia de um valor -, escreveremos nulo no campo correspondente.  Ao ler, tamb√©m aceitaremos correspond√™ncia n√£o nula. <br><br>  Se encontrarmos um tipo que possui v√°rias alternativas pr√©-conhecidas, tamb√©m definiremos um novo tipo de dados no Cassandra.  Para cada alternativa, um campo em nosso tipo de dados na UDT. <br><br>  Como resultado, nessa estrutura, apenas um dos campos em um determinado momento n√£o ser√° nulo.  Se voc√™ conheceu algum tipo de usu√°rio e acabou sendo uma inst√¢ncia de um moderador em tempo de execu√ß√£o, o campo do moderador conter√° algum valor, o restante ser√° nulo.  Para admin - admin, o resto - null. <br><br>  Isso permite que voc√™ codifique a estrutura da seguinte forma: temos 4 campos opcionais, garantimos que apenas um ser√° escrito a partir deles.  Cassandra usa apenas uma tag para identificar a presen√ßa de um campo espec√≠fico na estrutura.  Gra√ßas a isso, obtemos uma estrutura de armazenamento sem sobrecarga. <br><br>  De fato, para salvar o tipo de usu√°rio, se for um moderador, ser√° necess√°rio o mesmo n√∫mero de bytes necess√°rios para armazenar o moderador.  Mais um byte para mostrar qual alternativa espec√≠fica est√° presente aqui. <br><br><h3>  Inicializa√ß√£o </h3><br><blockquote>  A inicializa√ß√£o √© um procedimento preliminar que deve ser conclu√≠do antes que possamos usar nosso fallback. </blockquote><br>  Como esse processo funciona? <br><br><ul><li>  Em cada n√≥, geramos defini√ß√µes de tabelas, tipos e textos de consulta com base nos tipos que s√£o apresentados. <br></li><li>  Leia o esquema atual do DBMS.  No Cassandra, isso √© f√°cil, basta conectar-se a ele.  Quando conectado, em quase todos os drivers, o pr√≥prio objeto "sess√£o" bombeia os metadados do espa√ßo principal aos quais est√° conectado.  Ent√£o voc√™ pode ver o que eles t√™m. <br></li><li>  Analisamos os metadados, comparamos e verificamos que tudo o que queremos criar √© permitido e que a migra√ß√£o incremental √© poss√≠vel. <br></li><li>  Se tudo estiver normal e a inicializa√ß√£o for poss√≠vel, realizamos a migra√ß√£o. <br></li><li>  Estamos preparando pedidos. <br></li></ul><br><pre> <code class="plaintext hljs">sealed trait User case class Anonymous extends User case class Registered extends User case class Moderator extends User case class Admin extends User create type user ( anonymous frozen&lt;anonymous&gt;, registered frozen&lt;registered&gt;, moderator frozen&lt;moderator&gt;, admin frozen&lt;admin&gt; )</code> </pre> <br>  Isso acontece assim.  Temos <b>tipos</b> , <b>tabelas</b> e <b>consultas</b> .  Tipos dependem de outros tipos, aqueles de outros.  As tabelas dependem desses tipos.  As consultas j√° dependem das tabelas das quais eles l√™em dados.  A inicializa√ß√£o verificar√° todas essas depend√™ncias e criar√° no DBMS tudo o que ele pode criar, de acordo com certas regras. <br><br><h3>  Migra√ß√£o de tipo </h3><br>  Como determinar que um tipo pode ser migrado incrementalmente? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/105/eeb/554/105eeb554bcc5eadaf10753f8c150531.jpg"><br><br><ul><li>  Lemos como esse tipo √© definido no DBMS. <br></li><li>  Se n√£o existe esse tipo, ou seja, criamos um novo - n√≥s o criamos. <br></li><li>  Se esse tipo j√° existe, estamos tentando comparar campo a campo a defini√ß√£o existente com a defini√ß√£o que queremos atribuir a esse tipo. <br></li><li>  Se queremos adicionar apenas alguns campos que n√£o existem mais, o fazemos.  Crie uma lista de opera√ß√µes ALTER TYPE mutantes e inicie-as. <br></li><li>  Se houver algum tipo de campo que seja de um tipo diferente - geraremos um erro.  Por exemplo, havia lista - tornou-se mapa ou havia um link para um tipo definido pelo usu√°rio, e estamos tentando torn√°-lo diferente. <br></li></ul><br>  O desenvolvedor pode ver esse erro antes mesmo de iniciar a funcionalidade na produ√ß√£o.  Suponho que exatamente o mesmo esquema de dados esteja em seu ambiente de desenvolvimento.  Ele v√™ que de alguma forma criou um esquema de dados n√£o migr√°vel e, para evitar esses erros, ele pode substituir a serializa√ß√£o gerada automaticamente, adicionar op√ß√µes, renomear campos ou todos os tipos e tabelas como um todo. <br><br><h3>  Inicializa√ß√£o: Tipos </h3><br>  Imagine que existem v√°rios tipos de defini√ß√µes: <br><br><pre> <code class="plaintext hljs">case class Product (id: Long, name: ctring, price: BigDecimal) case class UserOffers (valiDate: LocalDate, offers: Seq[Products]) case class UserProducts (user User, products: Map[Date, Product]) case class UserInfo: UserOffers, products: UserProducts)</code> </pre> <br>  <b>Case class</b> - uma classe que cont√©m um conjunto de campos.  Este √© um an√°logo da estrutura em Rust. <br><br>  Geraremos aproximadamente essas defini√ß√µes de dados para cada um dos quatro tipos - o que queremos eventualmente p√¥r em marcha: <br><br><pre> <code class="plaintext hljs">CREATE TYPE product (id bigint, name text, price decimal); CREATE TYPE user_offers (valid_date date, offers frozen&lt;list&lt;frozen&lt;offer&gt;&gt;&gt;); CREATE TYPE user_products (user frozen&lt;user&gt;, products frozen&lt;map&lt;date, frozen&lt;product&gt;&gt;); CREATE TYPE user_jnfo (offers: frozen&lt;user_offers&gt;, products: frozen&lt;user_products&gt;);</code> </pre> <br>  O tipo de user_offers depende do tipo de oferta, user_products depende do tipo de produto, user_info no segundo e terceiro tipos. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5bb/e3b/e9d/5bbe3be9d2694677b42b59613305752b.jpg"><br><br>  Temos uma depend√™ncia entre tipos e queremos inicializ√°-la corretamente.  O diagrama mostra que inicializaremos user_offers e user_products em paralelo.  Isso n√£o significa que lan√ßaremos duas opera√ß√µes paralelas.  N√£o, iniciamos todas as instru√ß√µes, todas as an√°lises sequencialmente, para n√£o criar acidentalmente o mesmo tipo em dois threads paralelos. <br><br>  Mas h√° algum paralelismo no n√≠vel da corre√ß√£o de erros.  Se ocorrer um erro de tipo, tudo o que depende dele puxar√° o erro original. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/122/93f/0ba/12293f0bab8bd0a8b7e12d092380a5c5.jpg"><br><br>  Se um erro for gerado por qualquer uma das ramifica√ß√µes paralelas, tudo o que depende dos dados normalmente migrados ser√° gerado sem erro.  Se houver mais defini√ß√µes de tabelas, instru√ß√µes preparadas a partir delas, podemos inicializar com seguran√ßa essa parte do nosso Cache de Fallback.  A comunica√ß√£o ser√° perdida apenas com alguma parte dos back-end ou com alguma funcionalidade.  Os restantes s√£o inicializados. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a8d/5ec/3a2/a8d5ec3a2483d899c7db16ac56974fe9.jpg"><br><br>  Pode acontecer que dois tipos inicializados simultaneamente gerem erros diferentes.  Nesse caso, a funcionalidade que depende dos dois tipos produzir√° um tipo de erro de soma.  O desenvolvedor, inicializando seu Fallback no ambiente de desenvolvimento, receber√° uma lista completa de dados com erros.  Naturalmente, ele pode corrigi-lo aqui e obter o erro ainda mais.  Mas n√£o ser√° tal que um ramo completamente independente feche os erros que poder√≠amos obter, independentemente desse ramo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d08/e94/4ba/d08e944ba9b210d16f6f6c0b57048051.jpg"><br><br><h3>  Inicializa√ß√£o: Tabelas </h3><br>  Em seguida, criamos as tabelas. <br><br><pre> <code class="plaintext hljs">def getOffer (user: User, number: Long): Future[OfferData] create table get_offer( key frozen&lt;tuple&lt;frozen&lt;user&gt;, bigint&gt;&gt;PRIMARY KEY, value frozen&lt;friend_data&gt; )</code> </pre> <br>  Essa solicita√ß√£o pode iniciar diretamente uma solicita√ß√£o REST ou SOAP, criar opera√ß√µes adicionais internas ou at√© executar v√°rias solicita√ß√µes.  Tudo depende do seu c√≥digo - como voc√™ organizou o c√≥digo.  O fallback n√£o analisa completamente o que acontece dentro do m√©todo no qual voc√™ pendura esse esbo√ßo. <br><br><blockquote>  O m√©todo deve ser ass√≠ncrono, porque o Fallback √© o mesmo. </blockquote><br>  No Scala, isso √© marcado com um tipo especial de Futuro.  Isso significa que o resultado retornar√° um dia.  Quando exatamente - √© desconhecido: talvez imediatamente, ou talvez n√£o. <br><br>  Para o m√©todo, crie uma tabela.  A chave na tabela √© uma tupla de todos os tipos que correspondem aos par√¢metros deste m√©todo.  O valor n√£o chave √© o resultado, retornado de forma ass√≠ncrona.  Para cada tabela, preparamos duas consultas param√©tricas com anteced√™ncia: inserir dados e ler dados. <br><br><pre> <code class="plaintext hljs">insert into get_offer(key, value) values (?key, ?value); select value from get_offer where key = ?key;</code> </pre> <br>  Tudo est√° pronto para interagir com o DBMS.  Resta descobrir como vamos ler os dados do Fallback. <br><br><h3>  Disjuntor </h3><br>  Aqui, a responsabilidade passa para a zona do famoso padr√£o do disjuntor. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5c0/de1/91c/5c0de191c5c1699cc8f324f38d62b6ee.jpg"><br><br>  Um disjuntor t√≠pico inclui tr√™s estados. <br><br>  <b>Fechado - o estado fechado padr√£o</b> que fecha nosso back-end.  O princ√≠pio √© que lemos os dados primeiro no back-end e, somente se n√£o pud√©ssemos obt√™-los, vamos para Fallback.  Se conseguimos obter os dados, n√£o procuramos no Fallback, mas salvamos os dados e nada acontece. <br><br>  Se os problemas ocorrerem um ap√≥s o outro, assumimos que o back-end est√° mentindo.  Para n√£o envi√°-lo por spam com uma quantidade gigantesca de novas solicita√ß√µes, mudamos para <b>Aberto - em um estado fragmentado</b> .  Nele, estamos tentando ler dados apenas do Fallback.  Se n√£o der certo, retornamos imediatamente um erro e nem tocamos no back-end principal. <br><br>  Depois de um tempo, decidimos descobrir se o back-end acordou e tentamos redefinir o <b>estado Half-Open - um estado de curta dura√ß√£o</b> .  Seu tempo de vida √© um pedido. <br><br>  No estado de vida curta, optamos por fechar novamente ou abrir por um tempo ainda maior.  Se no estado Semiaberto chegarmos com √™xito ao Fallback e recebermos a pr√≥xima solicita√ß√£o, iremos para o estado Fechado.  Se n√£o conseguimos, voltamos ao Open, mas por um longo tempo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9ad/92e/4a4/9ad92e4a417201c8655ed4785ae21dfc.jpg"><br><br>  Adicionamos dois estados adicionais que claramente n√£o est√£o relacionados ao circuito do disjuntor: <br><br><ul><li>  For√ßado - estado fechado √† for√ßa; <br></li><li>  Invertida - prioridade para estado aberto e fechado invertido. <br></li></ul><br>  Vamos ver o que eles fazem. <br><br><h3>  O princ√≠pio de opera√ß√£o dos estados </h3><br>  <b>Fechado</b>  O esquema √© grande, mas basta entender o princ√≠pio geral.  Mantemos o Fallback paralelo √† forma como retornamos o resultado do back-end, se tudo correu bem l√° e lemos no Fallback.  Se estiver ruim em qualquer lugar, retornamos a prioridade do erro. <br><br><blockquote>  Dos dois erros, selecione o erro de back-end. </blockquote><br><img src="https://habrastorage.org/getpro/habr/post_images/5b7/541/f99/5b7541f99197cc1730c6a934cebe6516.jpg"><br><br>  Se n√£o houver erros, incrementamos o contador em paralelo com isso e entramos no estado aberto quando h√° muitas solicita√ß√µes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/182/18f/25d/18218f25de112cf7f6a88291fccbe72f.jpg"><br><br>  <b>Aberto</b>  O estado aberto do Open √© mais simples - lemos constantemente o Fallback, n√£o importa o que aconte√ßa, e depois de um tempo tentamos mudar para o estado Half-Open. <br><br>  <b>Semiaberto</b> .  O estado na estrutura √© semelhante a Fechado.  A diferen√ßa √© que, no caso de uma resposta bem-sucedida, entramos em um estado fechado.  Em caso de falha - retornamos ao aberto com um intervalo estendido. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b82/a1e/7c8/b82a1e7c89774bbe327613b51f50f5c0.jpg"><br><br>  <b>For√ßado √© um estado extra para aquecer o cache</b> .  Quando o preenchemos com dados, ele nunca tenta ler no Fallback, mas apenas adiciona registros. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bdc/8e3/b33/bdc8e3b335750b826fdd21db6c0f0ac7.jpg"><br><br>  <b>Invertido √© um segundo estado rebuscado</b> .  Funciona como um cache persistente.  Ativamos o estado quando queremos remover permanentemente a carga do back-end, mesmo que os dados sejam irrelevantes.  Primeiras pesquisas invertidas no Fallback e, se a pesquisa falhar, ela vai para o back-end e lida com isso. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/618/0da/8ed/6180da8edf69398780bd37fae9bc8ba7.jpg"><br><br><h3>  Os problemas </h3><br>  Com todo esse esquema, tivemos v√°rios problemas.  O mais s√©rio √© entender como as <b>declara√ß√µes preparadas</b> funcionam em Cassandra.  Esse problema foi corrigido na vers√£o 4.0, que ainda n√£o foi lan√ßada, por isso vou lhe dizer. <br><br>  O Cassandra foi projetado para conectar milh√µes de clientes a ele ao mesmo tempo, e todos est√£o tentando preparar suas declara√ß√µes preparadas.  Naturalmente, Cassandra n√£o prepara todas as declara√ß√µes preparadas, caso contr√°rio, ficar√° sem mem√≥ria.  Ele calcula o par√¢metro MD5 com base nas op√ß√µes de texto, espa√ßo da chave e consulta.  Se ela receber exatamente a mesma solicita√ß√£o com exatamente o mesmo MD5, ela aceitar√° a solicita√ß√£o j√° preparada.  Ele j√° possui informa√ß√µes sobre metadados e como lidar com eles. <br><br>  Mas h√° problemas de vers√£o.  Estamos lan√ßando uma nova vers√£o, ela rolou migra√ß√µes com sucesso, adicionou campos em tipos e executou instru√ß√µes preparadas.  Eles retornam com a vers√£o anterior do nosso estado e metadados - com tipos sem campos.  No momento da leitura dos dados, estamos tentando escrever suas novas colunas necess√°rias e nos deparamos com o fato de que elas simplesmente n√£o existem!  Cassandra diz que esse geralmente √© um tipo diferente que ela n√£o conhece. <br><br>  Lidamos com esse problema da seguinte maneira: <b>adicionamos um texto exclusivo a cada uma de nossas solicita√ß√µes preparadas</b> . <br><br><pre> <code class="plaintext hljs">create table get_offer( key frozen&lt;tuple&lt;frozen&lt;user&gt;, bigint&gt;&gt; PRIMARY KEY, value frozen&lt;friend_data&gt;, query_tag text ) insert into get_offer (key, value, query_tag) values (?key, ?value, 'tag_123'); select value as tag_123 from get_offer where key = ?key;</code> </pre> <br>  N√£o teremos milh√µes de clientes conectados, mas apenas uma sess√£o para cada n√≥ que possui v√°rias conex√µes.  Para cada declara√ß√£o de prepara√ß√£o uma vez.  Assumimos que n√£o h√° problema se, para cada vers√£o do aplicativo ou para cada in√≠cio de um n√≥, um texto exclusivo for gerado, o que obviamente estar√° no texto de nossa solicita√ß√£o. <br><br>  Adicionamos um campo especial para engan√°-lo.  Ao inserir, escrevemos uma constante nesse campo.  √â exclusivo para cada vers√£o de inicializa√ß√£o ou aplicativo - isso √© configurado na biblioteca.  Ao ler, usamos esse nome como alias para o valor que obtemos.  A solicita√ß√£o √© exatamente a mesma, ainda estamos selecionando o valor, mas o texto √© diferente.  Cassandra n√£o percebe que essa √© a mesma solicita√ß√£o, calcula outro MD5 e prepara a solicita√ß√£o novamente com novos metadados. <br><br>  O segundo problema √© a <b>corrida de migra√ß√£o</b> .  Por exemplo, queremos fazer v√°rias migra√ß√µes paralelas.  Vamos come√ßar algumas anota√ß√µes e, ao mesmo tempo, iniciar√£o os c√°lculos, executar√£o criar tabelas, criar tipos.  Isso pode levar ao fato de que em cada n√≥ ou em cada um dos encadeamentos paralelos tudo ser√° bem-sucedido e duas tabelas parecer√£o criadas com √™xito.  Mas, por dentro, Cassandra fica confusa e receberemos intervalos para escrever e ler. <br><br><blockquote>  Voc√™ pode interromper o Cassandra se tentar paralelizar processos de v√°rios encadeamentos ou de v√°rios n√≥s. </blockquote><br>  Se sabemos que devemos ter a migra√ß√£o de fallback, <b>migramos de um n√≥ especial antes do lan√ßamento</b> .  Somente ent√£o iniciaremos todos os nossos n√≥s durante o lan√ßamento.  Ent√£o resolvemos esse problema. <br><br>  O terceiro problema √© a <b>falta de dados no cache de fallback</b> .  Pode ser que tenhamos "devolvido" o m√©todo, ele deve armazenar dados hist√≥ricos de um ano atr√°s, mas, na realidade, o lan√ßamos ontem. <br><br>  <b>O problema foi resolvido com o aquecimento</b> .  Usamos o estado For√ßado e lan√ßamos n√≥s especiais que n√£o se comunicam com usu√°rios reais.  Eles pegam todas as chaves poss√≠veis que assumimos e aquecem o cache em um c√≠rculo.  O aquecimento est√° indo t√£o r√°pido para n√£o matar o backend que estamos lendo. <br><br><blockquote>  Dimensionamento de aplicativos, back-end, big data e front-end - Scala √© adequado para tudo isso.  26 de novembro, estamos realizando uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">confer√™ncia</a> profissional <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">para desenvolvedores Scala</a> .  Estilos, abordagens, dezenas de solu√ß√µes para o mesmo problema, as nuances do uso de abordagens antigas e comprovadas, a pr√°tica da programa√ß√£o funcional, a teoria da cosmon√°utica funcional radical - falaremos sobre tudo isso na confer√™ncia.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Inscreva-se</a> em um relat√≥rio se quiser compartilhar sua experi√™ncia Scala antes de 26 de setembro ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reserve seus ingressos</a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt466295/">https://habr.com/ru/post/pt466295/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt466283/index.html">Opencartforum e amigos</a></li>
<li><a href="../pt466285/index.html">Um pequeno brinde: rifa combo dvr e detector de radar</a></li>
<li><a href="../pt466287/index.html">Pesquisa e Relat√≥rio de Confiabilidade dos Segmentos Nacionais da Internet de 2019</a></li>
<li><a href="../pt466289/index.html">Iniciativas legislativas. Estranho, mas apresentado √† Duma do Estado</a></li>
<li><a href="../pt466291/index.html">Pesquisa de Sustentabilidade dos Segmentos Nacionais da Internet para 2019</a></li>
<li><a href="../pt466299/index.html">Soci√≥logos russos realizaram a primeira pesquisa de chatbots do mundo</a></li>
<li><a href="../pt466301/index.html">Outra coisa: pacotes de aplicativos Haiku?</a></li>
<li><a href="../pt466305/index.html">Takashi Kokubun: como fazer com que os aplicativos Ruby sejam executados mais rapidamente</a></li>
<li><a href="../pt466307/index.html">Como fa√ßo para projetar o SCS</a></li>
<li><a href="../pt466311/index.html">Workshop SLS 6 de setembro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>