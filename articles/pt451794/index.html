<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçü§ù‚Äçüë®üèæ üé£ üì™ Pixels de recuo da textura ü¶ä üßÄ üë®üèΩ‚Äçüç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apresentamos o quarto artigo de nossa s√©rie sobre o trabalho com modelos 3D no Unity. Artigos anteriores: ‚ÄúRecursos de trabalho com o Mesh in Unity‚Äù ,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pixels de recuo da textura</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/plarium/blog/451794/">  <i>Apresentamos o quarto artigo de nossa s√©rie sobre o trabalho com modelos 3D no Unity.</i>  <i>Artigos anteriores: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">‚ÄúRecursos de trabalho com o Mesh in Unity‚Äù</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">‚ÄúUnity: edi√ß√£o procedural do Mesh‚Äù</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">‚ÄúImporta√ß√£o de modelos 3D para o Unity e armadilhas‚Äù</a> .</i> <br><br>  No artigo anterior, mencionamos a verifica√ß√£o da varredura de textura quanto √† adequa√ß√£o da indenta√ß√£o de pixels em uma determinada resolu√ß√£o de textura.  Nesta publica√ß√£o, descrevemos a ess√™ncia do problema com a observa√ß√£o da indenta√ß√£o de pixels e o algoritmo para rastrea-lo.  N√£o ser√° considerado o c√≥digo, mas precisamente o princ√≠pio que pode ser implementado em qualquer idioma e ambiente de desenvolvimento. <br><br><img src="https://habrastorage.org/webt/u_/fw/mc/u_fwmclibgkemvxya6u_lsd8tqu.jpeg"><a name="habracut"></a><br><br><h3>  Edi√ß√£o </h3><br>  Um pedido para um modelo 3D geralmente √© acompanhado por um requisito para a resolu√ß√£o da textura.  Devido √† natureza discreta da imagem raster, o artista 3D deve observar o recuo em pixels entre partes da digitaliza√ß√£o de textura.  A aus√™ncia do recuo necess√°rio leva ao fato de que o mesmo pixel √© exibido no modelo em locais completamente diferentes quando n√£o √© necess√°rio. <br><br>  √â especialmente importante rastrear um recuo suficiente nas fases iniciais do trabalho.  Na maioria das vezes, algumas pessoas est√£o envolvidas na cria√ß√£o da geometria, incluindo uma varredura de textura, e outras est√£o envolvidas no desenho de texturas.  O erro detectado pelo artista 3D causar√° menos problemas do que o que o designer de texturas encontrar√°.  Neste √∫ltimo caso, a situa√ß√£o se torna ainda mais complicada se o pacote 3D usado n√£o fornecer ferramentas para desenhar sobre geometria (por exemplo, um pincel). <br><br>  Voc√™ tamb√©m deve considerar duas nuances, pelas quais entre os elementos da varredura pode exigir mais espa√ßo.  O primeiro √© uma diminui√ß√£o na resolu√ß√£o da textura durante o mipmapping.  O segundo √© o uso de um <b>filtro de dilata√ß√£o</b> ao formar <b>um mapa de ilumina√ß√£o</b> .  Durante a tarefa de criar uma digitaliza√ß√£o <b>UV</b> , um artista 3D precisa ser guiado pelos requisitos de resolu√ß√£o de textura e tamb√©m levar em considera√ß√£o as nuances listadas acima.  No entanto, muitas defici√™ncias simplesmente n√£o podem ser percebidas sem a verifica√ß√£o automatizada. <br><br><img src="https://habrastorage.org/webt/lv/s4/xf/lvs4xfanesl_qwgtr07wluk595a.jpeg"><br>  <i>Um exemplo da apar√™ncia de artefatos com uma diminui√ß√£o nos detalhes</i> <br><br>  Para modelos simples, uma varredura de textura pode ser gerada usando ferramentas autom√°ticas.  No entanto, eles s√£o baseados em m√©tricas internas e n√£o levam em conta a indenta√ß√£o de pixels; portanto, os pixels compartilhados geralmente est√£o localizados ao longo das bordas diagonais.  A verifica√ß√£o com texturas de verificador n√£o mostra todos os erros; al√©m disso, essas texturas geralmente t√™m uma resolu√ß√£o mais alta do que aquelas que ser√£o usadas no projeto. <br><br><img src="https://habrastorage.org/webt/mt/eb/8m/mteb8mngbtpsqlng-3b2l0wcmna.jpeg"><br>  <i>Pixels compartilhados</i> <br><br>  O problema da indenta√ß√£o insuficiente de pixels na varredura <b>UV</b> √© semelhante ao problema de sobreposi√ß√µes.  Nos dois casos, pode ocorrer o chamado <b>sangramento</b> - no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo anterior</a> , descrevemos quais artefatos isso gera. <br><br>  No entanto, o problema com a indenta√ß√£o de pixels depende do requisito m√≠nimo de resolu√ß√£o de textura.  Uma √∫nica verifica√ß√£o √© suficiente para determinar as sobreposi√ß√µes, enquanto os requisitos para a resolu√ß√£o da textura podem mudar no pr√≥ximo est√°gio de desenvolvimento.  A situa√ß√£o √© complicada pelo fato de que os pacotes 3D que usamos n√£o possuem ferramentas para detectar automaticamente erros relacionados √† proximidade de partes da varredura <b>UV</b> .  E n√£o esque√ßa que, ap√≥s a opera√ß√£o do modelador autom√°tico no <b>Unity,</b> voc√™ ainda precisar√° verificar o <b>UV2</b> . <br><br>  Decidimos criar uma ferramenta que pode verificar a indenta√ß√£o em pixels e marcar os locais de poss√≠veis lacunas no modelo.  Os requisitos de indenta√ß√£o ser√£o determinados com base nos seguintes par√¢metros: <br><br><ol><li>  A resolu√ß√£o base da textura. </li><li>  A resolu√ß√£o m√≠nima da textura na qual o fluxo n√£o √© permitido. </li><li>  O recuo necess√°rio na textura m√≠nima. </li></ol><br>  Como os tamanhos das texturas que usamos s√£o iguais a dois graus, a f√≥rmula para calcular o recuo necess√°rio na resolu√ß√£o b√°sica √© bastante simples: (resolu√ß√£o b√°sica / resolu√ß√£o m√≠nima) * recuo na MinTexture. <br><br>  Obviamente, a solu√ß√£o para esse problema est√° intimamente relacionada √† rasteriza√ß√£o.  Para uma declara√ß√£o mais clara dos requisitos e o desenvolvimento de um algoritmo, apresentamos v√°rios conceitos. <br><br><h3>  Conceitos chave </h3><br>  Considere um espa√ßo <b>UV</b> e uma grade uniforme da dimens√£o NxM no intervalo de 0,0 a 1,0.  As c√©lulas com 1 / N de largura e 1 / M de altura formam uma parti√ß√£o do espa√ßo <b>UV</b> . <br><br><img src="https://habrastorage.org/webt/ue/rg/dg/uergdgc7zyh8upqr6g7dylw85r8.jpeg"><br>  <i>NxM dividindo o espa√ßo <b>UV</b></i> <br><br>  Tomamos dois pontos arbitr√°rios e denotamos Dn como o n√∫mero de pixels ocupados pela proje√ß√£o no eixo U do segmento que conecta os pontos dados.  Da mesma forma, Dm para o eixo V. Em seguida, definimos a <b>dist√¢ncia</b> do <b>pixel</b> como o m√°ximo entre Dn e Dm. <br><br><img src="https://habrastorage.org/webt/cp/an/su/cpansumym7jr8f9vw-vi0w6iyj8.jpeg"><br>  <i>Dist√¢ncia do pixel</i> <br><br>  Note-se que no espa√ßo euclidiano, opera√ß√µes de movimento como transla√ß√£o e rota√ß√£o paralelas n√£o s√£o movimentos para a malha, se a <b>dist√¢ncia</b> do <b>pixel for</b> tomada como m√©trica.  Essa nuance complicou um pouco o desenvolvimento de nossa solu√ß√£o. <br><br><img src="https://habrastorage.org/webt/it/j-/ad/itj-adzmk_tujolsfcrwvhd2nqc.jpeg"><br><br>  Chamamos um quadrado com um lado em K pixels do <b>n√∫cleo de K.</b>  Ent√£o, quaisquer dois pontos com uma <b>dist√¢ncia de pixel</b> menor que K podem ser cobertos por um n√∫cleo de K. <br><br><img src="https://habrastorage.org/webt/gs/gu/jt/gsgujtv5gbm9o07j7itsrsz4dzo.jpeg"><br>  <i>Exemplos de n√∫cleos de tamanhos diferentes</i> <br><br>  Duas arestas do pol√≠gono formam uma <b>concavidade do contorno</b> se seu ponto m√©dio (o centro de massa em quatro v√©rtices) estiver √† esquerda dessas arestas ao contornar o contorno no sentido hor√°rio.  Para a travessia no sentido anti-hor√°rio, a condi√ß√£o √© encontrar um ponto √† direita das arestas. <br><br><img src="https://habrastorage.org/webt/di/3m/ye/di3myeeyussyylggsz0bnmdosbm.jpeg"><br>  <i>Um par de costelas formando uma concavidade do contorno</i> <br><br><h3>  Solu√ß√£o </h3><br>  Agora vamos falar diretamente sobre a verifica√ß√£o do recuo do pixel.  Para implement√°-lo, criamos um algoritmo composto por tr√™s fragmentos independentes.  A ordem de execu√ß√£o n√£o √© importante.  O resultado de cada um dos fragmentos √© a matriz NxM, que √© um buffer das c√©lulas da parti√ß√£o, onde algumas c√©lulas s√£o rotuladas.  A adi√ß√£o de todos os tr√™s buffers √© o resultado geral. <br><br>  Primeiro, considere o snippet mais simples.  Tudo se resume a encontrar c√©lulas que se cruzam pr√≥ximas a tri√¢ngulos e arestas degeneradas, cujo comprimento √© menor que o lado do n√∫cleo de uma dada magnitude.  Todas essas c√©lulas s√£o marcadas no buffer. <br><br><img src="https://habrastorage.org/webt/uv/ru/v7/uvruv7eavepfqrtj-kqtah_wy_4.jpeg"><br>  <i>Resultado da verifica√ß√£o do tamanho do elemento</i> <br><br>  Antes de descrever os outros dois fragmentos, considere a l√≥gica geral de seu trabalho.  Ambos est√£o relacionados ao processamento de aglomerados de tri√¢ngulos chamados de <b>conchas</b> ou ilhas.  O shell para um artista 3D √© um conjunto conectado de pol√≠gonos, ou seja, cada pol√≠gono neste conjunto possui um vizinho com o qual compartilha v√©rtices comuns.  Tamb√©m o shell √© um campo de treinamento independente.  Al√©m disso, por concha, ilha e aglomerado queremos dizer a mesma coisa. <br><br><img src="https://habrastorage.org/webt/yv/5t/ot/yv5tot5s12wlg7np6lyq6h1196q.jpeg"><br><br>  Para encontrar todas as conchas, usamos o algoritmo de busca para todos os componentes conectados do gr√°fico, em que o v√©rtice do gr√°fico √© representado por um pol√≠gono e a aresta pela presen√ßa de v√©rtices comuns em um par de pol√≠gonos.  Como o √∫nico pol√≠gono no <b>Unity</b> √© um tri√¢ngulo definido por √≠ndices de v√©rtices, consideramos tri√¢ngulos adjacentes se pelo menos um √≠ndice do v√©rtice do primeiro coincidir com o √≠ndice de qualquer v√©rtice do segundo.  Da analogia com o gr√°fico e o m√©todo para determinar arestas, segue-se que o conjunto de √≠ndices dos v√©rtices de um cluster n√£o cruza o conjunto de v√©rtices do outro. <br><br><img src="https://habrastorage.org/webt/ug/lg/t2/uglgt2foiwbustrkinjapehyu2u.jpeg"><br><br>  Com a parte comum terminada.  O segundo fragmento, que consideraremos, determina os locais dos poss√≠veis erros associados √† proximidade ou sobreposi√ß√£o de diferentes clusters. <br><br>  Muitos clusters s√£o alimentados na entrada na forma de conjuntos de tri√¢ngulos no espa√ßo <b>UV</b> , a dimens√£o da divis√£o <b>UV</b> correspondente √† resolu√ß√£o da textura (NxM) e o valor de indenta√ß√£o P como o n√∫mero de pixels.  Para uma determinada parti√ß√£o, √© necess√°rio encontrar as √°reas nas quais a dist√¢ncia em pixels entre os clusters √© menor que o recuo necess√°rio.  Uma c√©lula na matriz de resultados √© marcada se inserir pelo menos um <b>n√∫cleo do valor K = P + 1</b> , que cruza dois clusters diferentes. <br><br>  A ess√™ncia do fragmento est√° quase definida na descri√ß√£o do resultado.  √â necess√°rio encontrar todos os <b>n√∫cleos de magnitude K</b> que se cruzam com tri√¢ngulos de diferentes conchas e, em seguida, marcar as c√©lulas desses n√∫cleos no buffer de resultados. <br><br>  Em nossa implementa√ß√£o, todos os pares de clusters s√£o considerados alternadamente.  Para cada par, √© determinada a regi√£o de interse√ß√£o dos conjuntos de <b>n√∫cleos de magnitude K</b> cobertos por esses clusters.  Escolha um par e denote um conjunto como Q. <br><br><img src="https://habrastorage.org/webt/rp/ei/vb/rpeivbpedfexfuvbdsusftpuaha.jpeg"><br><br>  Ent√£o, todos os elementos de Q devem ser verificados pelo seguinte crit√©rio: o kernel especificado cruza pelo menos um tri√¢ngulo em cada um dos clusters do par selecionado.  Nesse caso, todas as c√©lulas do kernel testado s√£o marcadas. <br><br><img src="https://habrastorage.org/webt/vz/2q/gt/vz2qgtc62bl_gk99j3b_id2rmj0.jpeg"><br><br>  O buffer com c√©lulas marcadas para todos os pares de clusters constitui o resultado. <br><br><img src="https://habrastorage.org/webt/mk/cv/h5/mkcvh5g_tms3lmej2cvpere3410.jpeg"><br>  <i>Resultado da indenta√ß√£o do cluster</i> <br><br>  Agora vamos lidar com o √∫ltimo fragmento.  Aqui voc√™ precisa processar um cluster.  A entrada √© um conjunto de tri√¢ngulos no espa√ßo <b>UV</b> , a dimens√£o da parti√ß√£o <b>UV</b> correspondente √† resolu√ß√£o da textura (NxM) e o valor de indenta√ß√£o P como o n√∫mero de pixels.  Uma c√©lula pode ser marcada em dois casos: o cluster √© inv√°lido ou possui orif√≠cios ou a dist√¢ncia em pixels entre as bordas da concavidade √© menor que o recuo necess√°rio. <br><br>  A parte interna do cluster n√£o nos interessa - para come√ßar, obteremos seu contorno representado por uma lista conectada de arestas.  Tri√¢ngulos vizinhos duplicam os √≠ndices dos v√©rtices; portanto, a aresta pertence ao contorno se um par de √≠ndices de seus v√©rtices for exclusivo para o conjunto de arestas do cluster.  Depois de descobrir quais bordas formam o contorno, √© necess√°rio compor essas bordas para obter uma lista vinculada. <br><br>  Se ap√≥s esta etapa nem todas as arestas do contorno entrarem na lista, o cluster ter√° orif√≠cios ou haver√° um erro nos dados da malha.  Nesse caso, √© necess√°rio marcar adequadamente todas as c√©lulas dos n√∫cleos interceptadas pelo cluster. <br><br>  Se o contorno for encontrado, o processamento continuar√°.  Formulamos o seguinte requisito de resultado.  Deixe o par de arestas que forma a <b>concavidade do contorno</b> cruzar o <b>n√∫cleo de K = P + 1</b> .  Ent√£o as c√©lulas do n√∫cleo devem ser marcadas se as duas partes do contorno entre as bordas ultrapassarem esse n√∫cleo. <br><br><img src="https://habrastorage.org/webt/d3/ba/en/d3baeniweyl5_l6uxvougq6__y0.jpeg"><br>  <i>Resultado do teste do recurso de cluster</i> <br><br>  Decidimos implementar esse requisito atrav√©s da compara√ß√£o pareada das arestas do contorno.  Come√ßamos com a condi√ß√£o de concavidade e, para cada par, todos os n√∫cleos que cruzam as duas arestas s√£o verificados.  Para testar o kernel, s√£o realizadas travessias de cada parte do contorno entre um par de arestas.  Se cada parte contiver pelo menos um ponto al√©m dos limites do n√∫cleo, todas as c√©lulas do n√∫cleo ser√£o marcadas. <br><br><img src="https://habrastorage.org/webt/sx/qr/8a/sxqr8aizers5pviq4exzz3sips0.jpeg"><br>  <i>A condi√ß√£o sob a qual as c√©lulas do kernel verificado s√£o marcadas</i> <br><br><h3>  Sum√°rio </h3><br>  O algoritmo acima √© muito adequado para implementa√ß√£o usando computa√ß√£o paralela.  O processamento de cada par de clusters e arestas ocorre independentemente.  Como as verifica√ß√µes se baseiam na rasteriza√ß√£o, se voc√™ come√ßar a processar n√£o com pares de arestas, mas com n√∫cleos, √© recomend√°vel usar os recursos da <b>GPU</b> . <br><br>  Transformamos o resultado do algoritmo em uma textura.  Para uma determinada resolu√ß√£o, isso permite mostrar graficamente os locais de poss√≠veis falhas na varredura <b>UV</b> .  Al√©m disso, a textura resultante pode ser aplicada ao modelo para ver marcas diretamente na geometria. <br><br>  Nos exemplos abaixo, cortamos especialmente o coelho e Suzanne com a ferramenta autom√°tica <b>Blender</b> para obter mais artefatos.  A resolu√ß√£o da textura verificada √© 256x256, o recuo necess√°rio √© 1. <br><br>  C√©lulas marcadas em clusters de capa azul com furos, bem como tri√¢ngulos e arestas muito pequenas.  Verde indica os n√∫cleos celulares com as caracter√≠sticas de cada cluster individualmente.  Os n√∫cleos nos quais o recuo entre os clusters n√£o √© observado s√£o marcados em vermelho. <br><br><div class="spoiler">  <b class="spoiler_title">Exemplos</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ui/no/lc/uinolcm0buuwdwuqbsoufhdkjvw.jpeg"><br><br><img src="https://habrastorage.org/webt/po/up/v_/poupv_vzesyw1jeer6voiu4yens.jpeg"><br></div></div><br>  No pr√≥ximo artigo, consideraremos um algoritmo para otimizar modelos 3D em uma cena, removendo a geometria invis√≠vel.  Fique conosco! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt451794/">https://habr.com/ru/post/pt451794/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt451782/index.html">Subsistema Windows para Linux (WSL) vers√£o 2: como ser√°? (FAQ)</a></li>
<li><a href="../pt451784/index.html">Unidades h√≠bridas para armazenamento corporativo. Experi√™ncia com o Seagate EXOS</a></li>
<li><a href="../pt451786/index.html">Execute testes instrumentais no Firebase Test Lab. Parte 1: projeto iOS</a></li>
<li><a href="../pt451790/index.html">Os perigos da coleta de dados no jogo</a></li>
<li><a href="../pt451792/index.html">Quatro sniffers javascript que prendem voc√™ em lojas on-line</a></li>
<li><a href="../pt451796/index.html">Escrevendo uma extens√£o segura do navegador</a></li>
<li><a href="../pt451798/index.html">Migra√ß√£o de dados com mongoDB e Spring Boot</a></li>
<li><a href="../pt451800/index.html">Fazendo um modem de sonar simples</a></li>
<li><a href="../pt451802/index.html">Comunidade .Net do Raiffeisenbank convida para a UPD mitap Broadcast</a></li>
<li><a href="../pt451806/index.html">iOS Digest No. 5 (27 de abril a 16 de maio)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>