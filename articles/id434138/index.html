<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍂 🗺️ 🏺 Kami menulis mesin virtual kami sendiri 🙌🏾 🤺 👨🏾‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam tutorial ini, saya akan menunjukkan kepada Anda cara menulis mesin virtual Anda sendiri (VM) yang dapat menjalankan program assembler seperti 20...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami menulis mesin virtual kami sendiri</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434138/"> Dalam tutorial ini, saya akan menunjukkan kepada Anda cara menulis mesin virtual Anda sendiri (VM) yang dapat menjalankan program assembler seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2048</a> (teman saya) atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Roguelike</a> (milik saya).  Jika Anda tahu cara memprogram, tetapi ingin lebih memahami apa yang terjadi di dalam komputer dan bagaimana bahasa pemrograman bekerja, maka proyek ini adalah untuk Anda.  Menulis mesin virtual Anda sendiri mungkin tampak sedikit menakutkan, tetapi saya berjanji bahwa topiknya sangat sederhana dan instruktif. <br><br>  <a href="">Kode terakhir</a> adalah sekitar 250 baris dalam C. Cukup untuk mengetahui dasar-dasar C atau C ++, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aritmatika biner</a> .  Setiap sistem Unix (termasuk macOS) cocok untuk membangun dan menjalankan.  Beberapa Unix API digunakan untuk mengonfigurasi input dan tampilan konsol, tetapi mereka tidak penting untuk kode utama.  (Implementasi dukungan Windows dihargai). <br><br><blockquote>  <b>Catatan:</b> VM ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">program yang kompeten</a> .  Artinya, Anda sudah membaca kode sumbernya sekarang!  Setiap bagian dari kode akan ditampilkan dan dijelaskan secara rinci, sehingga Anda dapat yakin bahwa tidak ada yang hilang.  Kode akhir dibuat oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pleksus</a> blok kode.  Repositori proyek di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </blockquote><a name="habracut"></a><br><a name="1"></a><h1>  1. Isi </h1><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Daftar isi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pendahuluan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Arsitektur LC-3</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh Assembler</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Eksekusi program</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Implementasi instruksi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Petunjuk Lembar Curang</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Prosedur Pemrosesan Interupsi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cheat sheet untuk rutinitas interupsi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Unduh perangkat lunak</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Register yang Dipetakan Memori</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fitur platform</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Startup mesin virtual</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Metode alternatif dalam C ++</a> </li></ol><br><a name="2"></a><h1>  2. Pendahuluan </h1><br><h3>  Apa itu mesin virtual? </h3><br>  Mesin virtual adalah program yang bertindak seperti komputer.  Ini mensimulasikan prosesor dengan beberapa komponen perangkat keras lainnya, memungkinkan Anda untuk melakukan aritmatika, membaca dari dan menulis ke memori, dan berinteraksi dengan perangkat input / output seperti komputer fisik nyata.  Yang paling penting, VM memahami bahasa mesin yang dapat Anda gunakan untuk pemrograman. <br><br>  Berapa banyak perangkat keras yang disimulasikan oleh VM tertentu tergantung pada tujuannya.  Beberapa VM mereproduksi perilaku satu komputer tertentu.  Orang tidak lagi memiliki NES, tetapi kita masih bisa bermain game untuk NES dengan mensimulasikan perangkat keras di tingkat perangkat lunak.  Emulator ini harus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">secara akurat menciptakan kembali</a> setiap <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">detail</a> dan setiap komponen perangkat keras utama dari perangkat asli. <br><br>  VM lain tidak sesuai dengan komputer tertentu, tetapi sebagian sesuai dengan beberapa sekaligus!  Ini terutama dilakukan untuk memfasilitasi pengembangan perangkat lunak.  Bayangkan Anda ingin membuat program yang berjalan di banyak arsitektur komputer.  Mesin virtual menyediakan platform standar yang menyediakan portabilitas.  Tidak perlu menulis ulang program dengan dialek assembler yang berbeda untuk setiap arsitektur.  Cukup membuat VM kecil saja di setiap bahasa.  Setelah itu, program apa pun dapat ditulis hanya sekali dalam bahasa assembly mesin virtual. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/572/1a2/c0d/5721a2c0d11e8ea27357239f7104558b.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/235/42d/699/23542d699e7f9717c0e631faebb38454.gif"></div><br><blockquote>  <b>Catatan:</b> kompiler menyelesaikan masalah dengan mengkompilasi <i>bahasa tingkat tinggi</i> standar untuk arsitektur prosesor yang berbeda.  VM menciptakan satu <i>arsitektur CPU</i> standar yang disimulasikan pada berbagai perangkat perangkat keras.  Salah satu kelebihan dari kompiler adalah tidak ada overhead run-time seperti yang dilakukan VM.  Meskipun kompiler bekerja dengan baik, menulis kompiler baru untuk banyak platform sangat sulit, sehingga VM masih berguna.  Pada kenyataannya, pada level yang berbeda, baik VM dan kompiler digunakan bersama. </blockquote><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java Virtual Machine (JVM)</a> adalah contoh yang sangat sukses.  JVM itu sendiri relatif berukuran sedang, cukup kecil untuk dipahami oleh seorang programmer.  Ini memungkinkan Anda menulis kode untuk ribuan perangkat yang berbeda, termasuk ponsel.  Setelah mengimplementasikan JVM pada perangkat baru, program Java, Kotlin atau Clojure tertulis apa pun dapat bekerja tanpa perubahan.  Satu-satunya biaya hanya akan menjadi biaya overhead untuk VM itu sendiri dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">selanjutnya abstrak</a> dari tingkat mesin.  Ini biasanya kompromi yang cukup bagus. <br><br>  VM tidak harus besar atau di mana-mana untuk memberikan manfaat serupa.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Video game yang lebih lama</a> sering menggunakan VM kecil untuk membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sistem scripting</a> sederhana. <br><br>  VM juga berguna untuk mengisolasi program dengan aman.  Salah satu aplikasi adalah pengumpulan sampah.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tidak ada cara sepele untuk</a> menerapkan pengumpulan sampah otomatis di atas C atau C ++, karena program tidak dapat melihat tumpukan atau variabel sendiri.  Namun, VM "di luar" program yang sedang berjalan dan dapat mengamati semua <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">referensi ke sel memori</a> pada stack. <br><br>  Contoh lain dari perilaku ini ditunjukkan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kontrak pintar Ethereum</a> .  Kontrak pintar adalah program kecil yang dijalankan oleh setiap simpul validasi di blockchain.  Artinya, operator mengizinkan eksekusi pada mesin mereka dari program apa pun yang ditulis oleh orang asing, tanpa kesempatan untuk mempelajarinya terlebih dahulu.  Untuk mencegah tindakan jahat, tindakan tersebut dilakukan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">VM</a> yang tidak memiliki akses ke sistem file, jaringan, disk, dll.  Ethereum juga merupakan contoh portabilitas yang baik.  Berkat VM, Anda dapat menulis kontrak pintar tanpa memperhitungkan fitur banyak platform. <br><br><a name="3"></a><h1>  3. Arsitektur LC-3 </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yb/bd/fj/ybbdfjiz00coalgzvcg24hxbqea.png"></div><br><br>  VM kami akan mensimulasikan komputer fiksi yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LC-3</a> .  Ini populer untuk mengajar assembler siswa.  Di sini, satu set perintah yang disederhanakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dibandingkan dengan x86</a> , tetapi mempertahankan semua konsep dasar yang digunakan dalam CPU modern. <br><br>  Pertama, Anda perlu mensimulasikan komponen perangkat keras yang diperlukan.  Coba pahami apa masing-masing komponen itu, tetapi jangan khawatir jika Anda tidak yakin bagaimana itu cocok dengan gambaran besarnya.  Mari kita mulai dengan membuat file dalam C. Setiap bagian kode dari bagian ini harus ditempatkan dalam lingkup global file ini. <br><br><h3>  Memori </h3><br>  LC-3 memiliki 65.536 sel memori (2 <sup>16</sup> ), yang masing-masing berisi nilai 16-bit.  Ini berarti bahwa ia hanya dapat menyimpan 128 KB - jauh lebih sedikit dari yang Anda terbiasa!  Dalam program kami, memori ini disimpan dalam array sederhana: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* 65536 locations */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> memory[UINT16_MAX];</code> </pre> <br><h3>  Daftar </h3><br>  Register adalah slot untuk menyimpan satu nilai dalam CPU.  Register seperti CPU "workbench".  Agar dapat bekerja dengan sebagian data, ia harus berada di salah satu register.  Tetapi karena hanya ada beberapa register, hanya sejumlah kecil data yang dapat diunduh pada waktu tertentu.  Program mengatasi masalah ini dengan memuat nilai dari memori ke register, menghitung nilai ke register lain, dan kemudian menyimpan hasil akhir kembali ke memori. <br><br>  Hanya ada 10 register di LC-3, masing-masing dengan 16 bit.  Sebagian besar dari mereka adalah tujuan umum, tetapi beberapa ditugaskan peran. <br><br><ul><li>  8 register tujuan umum ( <code>R0-R7</code> ) </li><li>  1 register meja tim ( <code>PC</code> ) </li><li>  1 flag flag register ( <code>COND</code> ) </li></ul><br>  Register tujuan umum dapat digunakan untuk melakukan perhitungan perangkat lunak apa pun.  Penghitung instruksi adalah integer yang tidak ditandatangani yang merupakan alamat memori dari instruksi selanjutnya yang akan dieksekusi.  Bendera kondisi memberi tahu kami informasi tentang perhitungan sebelumnya. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { R_R0 = <span class="hljs-number"><span class="hljs-number">0</span></span>, R_R1, R_R2, R_R3, R_R4, R_R5, R_R6, R_R7, R_PC, <span class="hljs-comment"><span class="hljs-comment">/* program counter */</span></span> R_COND, R_COUNT };</code> </pre> <br>  Seperti memori, kami akan menyimpan register dalam larik: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> reg[R_COUNT];</code> </pre> <br><h3>  Set instruksi </h3><br>  Instruksi adalah perintah yang memberi tahu prosesor untuk melakukan semacam tugas mendasar, misalnya, menambahkan dua angka.  Instruksi memiliki <b>opcode</b> (kode operasi) yang menunjukkan jenis tugas yang dilakukan, serta seperangkat <b>parameter</b> yang memberikan input untuk tugas yang sedang dilakukan. <br><br>  Setiap <b>opcode</b> mewakili satu tugas yang prosesor "tahu" bagaimana melakukan.  Ada 16 opcode di LC-3.  Komputer hanya dapat menghitung urutan instruksi sederhana ini.  Panjang setiap instruksi adalah 16 bit, dan 4 bit kiri menyimpan kode operasi.  Sisanya digunakan untuk menyimpan parameter. <br><br>  Nanti kita akan membahas secara terperinci apa yang dilakukan oleh setiap instruksi.  Tetapkan opcode berikut saat ini.  Pastikan Anda menyimpan pesanan ini untuk mendapatkan nilai enum yang benar: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { OP_BR = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* branch */</span></span> OP_ADD, <span class="hljs-comment"><span class="hljs-comment">/* add */</span></span> OP_LD, <span class="hljs-comment"><span class="hljs-comment">/* load */</span></span> OP_ST, <span class="hljs-comment"><span class="hljs-comment">/* store */</span></span> OP_JSR, <span class="hljs-comment"><span class="hljs-comment">/* jump register */</span></span> OP_AND, <span class="hljs-comment"><span class="hljs-comment">/* bitwise and */</span></span> OP_LDR, <span class="hljs-comment"><span class="hljs-comment">/* load register */</span></span> OP_STR, <span class="hljs-comment"><span class="hljs-comment">/* store register */</span></span> OP_RTI, <span class="hljs-comment"><span class="hljs-comment">/* unused */</span></span> OP_NOT, <span class="hljs-comment"><span class="hljs-comment">/* bitwise not */</span></span> OP_LDI, <span class="hljs-comment"><span class="hljs-comment">/* load indirect */</span></span> OP_STI, <span class="hljs-comment"><span class="hljs-comment">/* store indirect */</span></span> OP_JMP, <span class="hljs-comment"><span class="hljs-comment">/* jump */</span></span> OP_RES, <span class="hljs-comment"><span class="hljs-comment">/* reserved (unused) */</span></span> OP_LEA, <span class="hljs-comment"><span class="hljs-comment">/* load effective address */</span></span> OP_TRAP <span class="hljs-comment"><span class="hljs-comment">/* execute trap */</span></span> };</code> </pre> <br><blockquote>  <b>Catatan:</b> Arsitektur Intel x86 memiliki ratusan instruksi, sedangkan arsitektur lain seperti ARM dan LC-3 sangat sedikit.  Set instruksi kecil disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RISC</a> , sedangkan yang lebih besar disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CISC</a> .  Set instruksi besar, sebagai suatu peraturan, tidak menyediakan fitur fundamental baru, tetapi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sering menyederhanakan penulisan kode assembler</a> .  Satu instruksi CISC dapat menggantikan beberapa instruksi RISC.  Namun, prosesor CISC lebih kompleks dan mahal untuk desain dan pembuatan.  Ini dan trade-off lainnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak memungkinkan memanggil desain "optimal"</a> . </blockquote><br><h3>  Bendera kondisi </h3><br>  Register <code>R_COND</code> menyimpan flag kondisi yang memberikan informasi tentang perhitungan terakhir yang dilakukan.  Ini memungkinkan program memeriksa kondisi logis, seperti <code>if (x &gt; 0) { ... }</code> . <br><br>  Setiap prosesor memiliki banyak tanda status untuk memberi sinyal berbagai situasi.  LC-3 hanya menggunakan tiga flag kondisi yang menunjukkan tanda dari perhitungan sebelumnya. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { FL_POS = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* P */</span></span> FL_ZRO = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* Z */</span></span> FL_NEG = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* N */</span></span> };</code> </pre> <br><blockquote>  <b>Catatan:</b> (Karakter <code>&lt;&lt;</code> disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">operator shift kiri</a> . <code>(n &lt;&lt; k)</code> menggeser bit <code>n</code> kiri oleh <code>k</code> tempat. Jadi, <code>1 &lt;&lt; 2</code> sama dengan <code>4</code> Baca di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> jika Anda tidak terbiasa dengan konsep. Ini akan sangat penting). </blockquote><br>  Kami telah selesai mengonfigurasi komponen perangkat keras dari mesin virtual kami!  Setelah menambahkan inklusi standar (lihat tautan di atas), file Anda akan terlihat seperti ini: <br><br><pre> <code class="cpp hljs">{Includes, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Registers, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Opcodes, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Condition Flags, <span class="hljs-number"><span class="hljs-number">3</span></span>}</code> </pre>  <font color="gray">Berikut ini tautan ke bagian artikel bernomor, dari mana fragmen kode yang sesuai berasal.</font>  <font color="gray">Untuk daftar lengkap, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">program kerja</a> - kira-kira.</font>  <font color="gray">trans.</font> <br><br><a name="4"></a><h1>  4. Contoh Assembler </h1><br>  Sekarang, mari kita lihat program assembler LC-3 untuk mendapatkan gambaran tentang apa yang sebenarnya dilakukan oleh mesin virtual.  Anda tidak perlu tahu cara memprogram dalam assembler, atau memahami semuanya di sini.  Cobalah untuk mendapatkan gambaran umum tentang apa yang terjadi.  Ini adalah "Hello World" sederhana: <br><br><pre> <code class="plaintext hljs">.ORIG x3000 ; this is the address in memory where the program will be loaded LEA R0, HELLO_STR ; load the address of the HELLO_STR string into R0 PUTs ; output the string pointed to by R0 to the console HALT ; halt the program HELLO_STR .STRINGZ "Hello World!" ; store this string here in the program .END ; mark the end of the file</code> </pre> <br>  Seperti dalam C, program mengeksekusi satu pernyataan dari atas ke bawah.  Tetapi tidak seperti C, tidak ada area bersarang <code>{}</code> atau struktur kontrol seperti <code>if</code> atau <code>while</code> ;  hanya daftar operator sederhana.  Karena itu, jauh lebih mudah dilakukan. <br><br>  Harap perhatikan bahwa nama beberapa operator sesuai dengan opcode yang telah kami tentukan sebelumnya.  Kita tahu bahwa instruksinya 16 bit, tetapi setiap baris terlihat seperti jumlah karakter yang berbeda.  Bagaimana ketidakcocokan seperti itu mungkin terjadi? <br><br>  Ini karena kode yang kita baca ditulis dalam <b>bahasa assembly</b> - dalam bentuk teks, bentuk yang dapat dibaca dan dapat ditulis.  Alat, yang disebut <b>assembler</b> , mengubah setiap baris teks menjadi instruksi biner 16-bit yang dipahami mesin virtual.  Bentuk biner ini, yang pada dasarnya adalah array instruksi 16-bit, disebut <b>kode mesin</b> dan sebenarnya dieksekusi oleh mesin virtual. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a7/832/c48/2a7832c4840636fbba310c9e7095ee4d.gif"></div><br><blockquote>  <b>Catatan:</b> meskipun kompiler dan assembler memainkan peran yang sama dalam pengembangan, mereka tidak sama.  Assembler hanya mengkodekan apa yang ditulis programmer dalam teks, mengganti karakter dengan representasi biner mereka dan mengemasnya menjadi instruksi. </blockquote><br>  Perintah <code>.ORIG</code> dan <code>.STRINGZ</code> terlihat seperti instruksi, tetapi tidak.  Ini adalah arahan assembler yang menghasilkan bagian dari kode atau data.  Misalnya, <code>.STRINGZ</code> menyisipkan serangkaian karakter pada lokasi yang ditentukan dalam program biner. <br><br>  Loop dan kondisi dieksekusi menggunakan pernyataan seperti goto.  Berikut adalah contoh lain yang diperhitungkan menjadi 10. <br><br><pre> <code class="plaintext hljs">AND R0, R0, 0 ; clear R0 LOOP ; label at the top of our loop ADD R0, R0, 1 ; add 1 to R0 and store back in R0 ADD R1, R0, -10 ; subtract 10 from R0 and store back in R1 BRn LOOP ; go back to LOOP if the result was negative ... ; R0 is now 10!</code> </pre> <br><blockquote>  <b>Catatan:</b> tutorial ini tidak harus belajar perakitan.  Tetapi jika Anda tertarik, Anda dapat menulis dan membangun program <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LC-3</a> Anda sendiri menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LC-3 Tools</a> . </blockquote><br><a name="5"></a><h1>  5. Eksekusi program </h1><br>  Sekali lagi, contoh-contoh sebelumnya hanya memberikan gambaran tentang apa yang dilakukan VM.  Untuk menulis VM, Anda tidak perlu memahami assembler sepenuhnya.  Selama Anda mengikuti prosedur yang sesuai untuk membaca dan menjalankan instruksi, program LC-3 <i>apa pun</i> akan bekerja dengan benar, terlepas dari kerumitannya.  Secara teori, VM bahkan dapat menjalankan browser atau sistem operasi seperti Linux! <br><br>  Jika Anda berpikir mendalam, maka ini adalah ide yang sangat bagus secara filosofis.  Program itu sendiri dapat menghasilkan tindakan kompleks sewenang-wenang yang tidak pernah kita harapkan dan mungkin tidak dapat dipahami.  Tetapi pada saat yang sama, semua fungsinya terbatas pada kode sederhana, yang akan kami tulis!  Pada saat yang sama, kami tahu segalanya dan tidak tahu sama sekali tentang cara kerja setiap program.  Turing menyebutkan ide bagus ini: <br><br><blockquote>  “Pendapat bahwa mesin tidak dapat mengejutkan seseorang dengan apa pun didasarkan, saya percaya, pada satu kesalahan, yang rawan terhadap ahli matematika dan filsuf.  Maksud saya asumsi bahwa karena beberapa fakta telah menjadi milik pikiran, segera semua konsekuensi dari fakta ini akan menjadi milik pikiran. ”  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alan M. Turing</a> </blockquote><br><h3>  Prosedur </h3><br>  Berikut ini adalah deskripsi yang tepat dari prosedur penulisan: <br><br><ol><li>  Unduh satu instruksi dari memori di alamat register <code>PC</code> . </li><li>  Tambah register <code>PC</code> . </li><li>  Lihat opcode untuk menentukan jenis instruksi apa yang harus diikuti. </li><li>  Ikuti instruksi menggunakan parameternya. </li><li>  Kembali ke langkah 1. </li></ol><br>  Anda dapat mengajukan pertanyaan: "Tetapi jika loop terus menambah penghitung tanpa adanya <code>if</code> atau <code>while</code> , apakah instruksi tidak akan berakhir?"  Jawabannya adalah tidak.  Seperti yang telah kami sebutkan, beberapa instruksi mirip goto mengubah aliran eksekusi dengan melompat-lompat di sekitar <code>PC</code> . <br><br>  Kami memulai studi tentang proses ini sebagai contoh dari siklus utama: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[])</span></span></span><span class="hljs-function"> </span></span>{ {Load Arguments, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Setup, <span class="hljs-number"><span class="hljs-number">12</span></span>} <span class="hljs-comment"><span class="hljs-comment">/* set the PC to starting position */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 0x3000 is the default */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { PC_START = <span class="hljs-number"><span class="hljs-number">0x3000</span></span> }; reg[R_PC] = PC_START; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> running = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (running) { <span class="hljs-comment"><span class="hljs-comment">/* FETCH */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> instr = mem_read(reg[R_PC]++); <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> op = instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (op) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_ADD: {ADD, <span class="hljs-number"><span class="hljs-number">6</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_AND: {AND, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_NOT: {NOT, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_BR: {BR, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_JMP: {JMP, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_JSR: {JSR, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_LD: {LD, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_LDI: {LDI, <span class="hljs-number"><span class="hljs-number">6</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_LDR: {LDR, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_LEA: {LEA, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_ST: {ST, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_STI: {STI, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_STR: {STR, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_TRAP: {TRAP, <span class="hljs-number"><span class="hljs-number">8</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_RES: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_RTI: <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: {BAD OPCODE, <span class="hljs-number"><span class="hljs-number">7</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } {Shutdown, <span class="hljs-number"><span class="hljs-number">12</span></span>} }</code> </pre> <br><a name="6"></a><h1>  6. Implementasi instruksi </h1><br>  Sekarang tugas Anda adalah membuat implementasi yang benar untuk setiap opcode.  Spesifikasi terperinci dari setiap instruksi terdapat dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi proyek</a> .  Dari spesifikasi Anda perlu mengetahui cara kerja setiap instruksi dan menulis implementasi.  Ini lebih mudah daripada kedengarannya.  Di sini saya akan menunjukkan bagaimana menerapkan keduanya.  Kode untuk sisanya dapat ditemukan di bagian selanjutnya. <br><br><h3>  ADD </h3><br>  Instruksi <code>ADD</code> mengambil dua angka, menambahkannya dan menyimpan hasilnya dalam register.  Spesifikasi ini ada di dokumentasi pada halaman 526. Setiap instruksi <code>ADD</code> adalah sebagai berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68a/676/f4e/68a676f4ed10acf22a34a088e6a2edc7.gif"></div><br><br>  Ada dua baris dalam diagram, karena ada dua "mode" yang berbeda untuk instruksi ini.  Sebelum saya menjelaskan mode, mari kita coba mencari kesamaan di antara mereka.  Keduanya dimulai dengan empat bit identik <code>0001</code> .  Ini adalah nilai opcode untuk <code>OP_ADD</code> .  Tiga bit berikutnya ditandai <code>DR</code> untuk register keluaran.  Register output adalah tempat di mana jumlah disimpan.  Tiga bit berikut adalah: <code>SR1</code> .  Ini adalah register yang berisi nomor pertama yang akan ditambahkan. <br><br>  Jadi, kita tahu di mana harus menyimpan hasilnya, dan kita tahu angka pertama yang ditambahkan.  Tetap hanya untuk mengetahui nomor kedua untuk penambahan.  Di sini dua garis mulai berbeda.  Perhatikan bahwa bit ke-5 adalah 0 di bagian atas dan 1. di bagian bawah. Bit ini sesuai dengan <i>mode langsung</i> atau <i>mode register</i> .  Dalam mode register, nomor kedua disimpan dalam register, seperti yang pertama.  Itu ditandai sebagai <code>SR2</code> dan terkandung dalam bit dua hingga nol.  Bit 3 dan 4 tidak digunakan.  Dalam assembler, itu akan ditulis seperti ini: <br><br><pre> <code class="plaintext hljs">ADD R2 R0 R1 ; add the contents of R0 to R1 and store in R2.</code> </pre> <br>  Dalam mode langsung, alih-alih menambahkan konten register, nilai langsung tertanam dalam instruksi itu sendiri.  Ini nyaman karena program tidak memerlukan instruksi tambahan untuk memuat nomor ini ke register dari memori.  Sebaliknya, sudah ada di dalam instruksi ketika kita membutuhkannya.  Imbalannya adalah hanya sejumlah kecil yang dapat disimpan di sana.  Tepatnya, maksimal 2 <sup>5</sup> = 32.  Ini paling berguna untuk meningkatkan penghitung atau nilai.  Di assembler, Anda dapat menulis seperti ini: <br><br><pre> <code class="plaintext hljs">ADD R0 R0 1 ; add 1 to R0 and store back in R0</code> </pre> <br>  Berikut ini kutipan dari spesifikasinya: <br><br><blockquote>  Jika bit [5] adalah 0, maka operan sumber kedua diperoleh dari SR2.  Jika bit [5] adalah 1, maka operan sumber kedua diperoleh dengan memperluas imm5 ke 16 bit.  Dalam kedua kasus, operan sumber kedua ditambahkan ke konten SR1, dan hasilnya disimpan dalam DR.  (hal. 526) </blockquote><br>  Ini mirip dengan apa yang kita diskusikan.  Tapi apa itu "perluasan makna"?  Meskipun dalam mode langsung, nilainya hanya 5 bit, perlu ditambahkan dengan angka 16-bit.  5 bit ini harus diperluas ke 16 agar sesuai dengan nomor lain.  Untuk angka positif, kita dapat mengisi bit yang hilang dengan nol dan mendapatkan nilai yang sama.  Namun, untuk angka negatif ini tidak berfungsi.  Misalnya, −1 dalam lima bit adalah <code>1 1111</code> .  Jika Anda mengisinya dengan nol, kami mendapatkan <code>0000 0000 0001 1111</code> , yaitu 32!  Memperluas nilai mencegah masalah ini dengan mengisi bit dengan angka nol untuk angka positif dan angka untuk angka negatif. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> sign_extend(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bit_count) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x &gt;&gt; (bit_count - <span class="hljs-number"><span class="hljs-number">1</span></span>)) &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) { x |= (<span class="hljs-number"><span class="hljs-number">0xFFFF</span></span> &lt;&lt; bit_count); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; }</code> </pre> <br><blockquote>  <b>Catatan:</b> jika Anda tertarik dengan angka negatif biner, Anda dapat membaca tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode tambahan</a> .  Tetapi ini tidak penting.  Cukup salin kode di atas dan gunakan ketika spesifikasi mengatakan untuk memperluas nilainya. </blockquote><br>  Spesifikasi memiliki kalimat terakhir: <br><br><blockquote>  Kode kondisi diatur tergantung pada apakah hasilnya negatif, nol atau positif.  (hal. 526) </blockquote><br>  Sebelumnya kami mendefinisikan kondisi flag enum, dan sekarang saatnya untuk menggunakan flag ini.  Setiap kali nilai ditulis ke register, kita perlu memperbarui bendera untuk menunjukkan tandanya.  Kami menulis fungsi untuk digunakan kembali: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update_flags</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reg[r] == <span class="hljs-number"><span class="hljs-number">0</span></span>) { reg[R_COND] = FL_ZRO; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reg[r] &gt;&gt; <span class="hljs-number"><span class="hljs-number">15</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* a 1 in the left-most bit indicates negative */</span></span> { reg[R_COND] = FL_NEG; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reg[R_COND] = FL_POS; } }</code> </pre> <br>  Sekarang kita siap menulis kode untuk <code>ADD</code> : <br><br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">/* destination register (DR) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* first operand (SR1) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* whether we are in immediate mode */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> imm_flag = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (imm_flag) { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> imm5 = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1F</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); reg[r0] = reg[r1] + imm5; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r2 = instr &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; reg[r0] = reg[r1] + reg[r2]; } update_flags(r0); }</code> </pre> <br>  Bagian ini memiliki banyak informasi, jadi mari kita rangkum. <br><br><ul><li>  <code>ADD</code> mengambil dua nilai dan menyimpannya dalam register. </li><li>  Dalam mode register, nilai kedua yang akan ditambahkan adalah register. </li><li>  Dalam mode langsung, nilai kedua tertanam di 5 bit kanan instruksi. </li><li>  Nilai yang lebih pendek dari 16 bit harus diperluas. </li><li>  Setiap kali instruksi mengubah case, flag kondisi harus diperbarui. </li></ul><br>  Anda mungkin kewalahan dengan menulis 15 instruksi lagi.  Namun, informasi yang diperoleh di sini dapat digunakan kembali.  Sebagian besar instruksi menggunakan kombinasi ekspansi nilai, berbagai mode, dan pembaruan bendera. <br><br><h3>  LDI </h3><br>  LDI berarti pemuatan "tidak langsung" atau "tidak langsung" (memuat tidak langsung).  Instruksi ini digunakan untuk memuat nilai dari lokasi memori ke dalam register.  Spesifikasi pada halaman 532. <br><br>  Beginilah tata letak binernya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dba/efe/0d9/dbaefe0d919cac5489178d7707c1fe0e.gif"></div><br><br>  Tidak seperti <code>ADD</code> , tidak ada mode dan parameter yang lebih sedikit.  Kali ini, kode operasinya adalah <code>1010</code> , yang sesuai dengan nilai enum <code>OP_LDI</code> .  Sekali lagi, kita melihat <code>DR</code> tiga-bit (register keluaran) untuk menyimpan nilai yang dimuat.  Bit yang tersisa ditandai sebagai <code>PCoffset9</code> .  Ini adalah nilai langsung yang tertanam dalam instruksi (mirip dengan <code>imm5</code> ).  Karena instruksi dimuat dari memori, kita dapat menebak bahwa nomor ini adalah jenis alamat yang mengatakan dari mana nilai tersebut diambil.  Spesifikasi menjelaskan lebih terinci: <br><br><blockquote>  Alamat tersebut dihitung dengan memperluas bit nilai <code>[8:0]</code> menjadi 16 bit dan menambahkan nilai ini ke <code>PC</code> diperbesar.  Apa yang disimpan dalam memori di alamat ini adalah alamat data yang akan dimuat ke dalam <code>DR</code> .  (hal. 532) </blockquote><br>  Seperti sebelumnya, Anda perlu memperluas nilai 9-bit ini, tetapi kali ini menambahkannya ke <code>PC</code> saat ini.  (Jika Anda melihat siklus eksekusi, <code>PC</code> meningkat segera setelah memuat instruksi ini).  Jumlah yang dihasilkan adalah alamat lokasi di memori, dan alamat ini <i>berisi</i> nilai <i>lain</i> , yang merupakan alamat nilai beban. <br><br>  Ini mungkin tampak seperti cara bundaran untuk membaca dari memori, tetapi itu perlu.  Instruksi <code>LD</code> terbatas pada offset alamat 9 bit, sedangkan memori membutuhkan alamat 16 bit.  <code>LDI</code> berguna untuk memuat nilai yang disimpan di suatu tempat di luar komputer saat ini, tetapi untuk menggunakannya, alamat lokasi akhir harus disimpan di dekatnya.  Anda bisa menganggapnya sebagai variabel lokal di C, yang merupakan penunjuk ke beberapa data: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// the value of far_data is an address // of course far_data itself (the location in memory containing the address) has an address char* far_data = "apple"; // In memory it may be layed out like this: // Address Label Value // 0x123: far_data = 0x456 // ... // 0x456: string = 'a' // if PC was at 0x100 // LDI R0 0x023 // would load 'a' into R0</span></span></code> </pre> <br>  Seperti sebelumnya, setelah menulis nilai ke <code>DR</code> , flag harus diperbarui: <br><br><blockquote>  Kode kondisi diatur tergantung pada apakah hasilnya negatif, nol atau positif.  (hal. 532) </blockquote><br>  Berikut adalah kode untuk kasus ini: ( <code>mem_read</code> dibahas pada bagian selanjutnya): <br><br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">/* destination register (DR) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* PCoffset 9*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* add pc_offset to the current PC, look at that memory location to get the final address */</span></span> reg[r0] = mem_read(mem_read(reg[R_PC] + pc_offset)); update_flags(r0); }</code> </pre> <br>  Seperti yang saya katakan, untuk instruksi ini kami menggunakan bagian penting dari kode dan pengetahuan yang didapat sebelumnya ketika menulis <code>ADD</code> .  Sama dengan petunjuk lainnya. <br><br>  Sekarang Anda perlu mengimplementasikan sisa instruksi.  Ikuti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spesifikasi</a> dan gunakan kode yang sudah ditulis.  Kode untuk semua instruksi diberikan di akhir artikel.  Dua opcode yang disebutkan sebelumnya tidak akan dibutuhkan: <code>OP_RTI</code> dan <code>OP_RES</code> .  Anda dapat mengabaikan mereka atau memberikan kesalahan jika mereka dipanggil.  Setelah selesai, sebagian besar VM Anda dapat dianggap lengkap! <br><br><a name="7"></a><h1>  7. Boks sesuai instruksi </h1><br>  Bagian ini berisi implementasi lengkap dari instruksi yang tersisa jika Anda macet. <br><br><h3>  RTI &amp; RES </h3><br>  (tidak digunakan) <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>();</code> </pre> <br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sedikit "dan"</a> </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> imm_flag = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (imm_flag) { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> imm5 = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1F</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); reg[r0] = reg[r1] &amp; imm5; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r2 = instr &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; reg[r0] = reg[r1] &amp; reg[r2]; } update_flags(r0); }</code> </pre> <br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bitwise tidak</a> </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; reg[r0] = ~reg[r1]; update_flags(r0); }</code> </pre> <br><h3>  Cabang </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend((instr) &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> cond_flag = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cond_flag &amp; reg[R_COND]) { reg[R_PC] += pc_offset; } }</code> </pre> <br><h3>  Lompat </h3><br>  <code>RET</code> diindikasikan sebagai instruksi terpisah dalam spesifikasi, karena ini adalah perintah lain dalam assembler.  Ini sebenarnya adalah kasus khusus <code>JMP</code> .  <code>RET</code> terjadi setiap kali <code>R1</code> adalah 7. <br><br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">/* Also handles RET */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; reg[R_PC] = reg[r1]; }</code> </pre> <br><h3>  Langsung daftar </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> long_pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x7ff</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> long_flag = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">11</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>; reg[R_R7] = reg[R_PC]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (long_flag) { reg[R_PC] += long_pc_offset; <span class="hljs-comment"><span class="hljs-comment">/* JSR */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reg[R_PC] = reg[r1]; <span class="hljs-comment"><span class="hljs-comment">/* JSRR */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><h3>  Muat </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); reg[r0] = mem_read(reg[R_PC] + pc_offset); update_flags(r0); }</code> </pre> <br><h3>  Muat daftar </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x3F</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); reg[r0] = mem_read(reg[r1] + offset); update_flags(r0); }</code> </pre> <br><h3>  Alamat Muatan yang Efektif </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); reg[r0] = reg[R_PC] + pc_offset; update_flags(r0); }</code> </pre> <br><h3>  Toko </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); mem_write(reg[R_PC] + pc_offset, reg[r0]); }</code> </pre> <br><h3>  Toko tidak langsung </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x1ff</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); mem_write(mem_read(reg[R_PC] + pc_offset), reg[r0]); }</code> </pre> <br><h3>  Daftar toko </h3><br><pre> <code class="cpp hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> offset = sign_extend(instr &amp; <span class="hljs-number"><span class="hljs-number">0x3F</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); mem_write(reg[r1] + offset, reg[r0]); }</code> </pre> <br><a name="8"></a><h1>  8. Prosedur Penanganan Interrupt </h1><br>  LC-3 menyediakan beberapa rutinitas standar untuk melakukan tugas-tugas umum dan berinteraksi dengan perangkat I / O.  Misalnya, ada prosedur untuk menerima input keyboard dan mengeluarkan garis ke konsol.  Mereka disebut perangkap rutin, yang dapat Anda anggap sebagai sistem operasi atau API untuk LC-3.  Setiap subprogram diberi kode interupsi (trap code) yang mengidentifikasinya (mirip dengan opcode).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menjalankannya, sebuah instruksi dipanggil </font></font><code>TRAP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan kode dari subprogram yang diinginkan.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/208/93c/77c/20893c77cbe50ab9dfb7996ea3ce51b1.gif"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Setel enum untuk setiap kode interupsi: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { TRAP_GETC = <span class="hljs-number"><span class="hljs-number">0x20</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* get character from keyboard */</span></span> TRAP_OUT = <span class="hljs-number"><span class="hljs-number">0x21</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* output a character */</span></span> TRAP_PUTS = <span class="hljs-number"><span class="hljs-number">0x22</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* output a word string */</span></span> TRAP_IN = <span class="hljs-number"><span class="hljs-number">0x23</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* input a string */</span></span> TRAP_PUTSP = <span class="hljs-number"><span class="hljs-number">0x24</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* output a byte string */</span></span> TRAP_HALT = <span class="hljs-number"><span class="hljs-number">0x25</span></span> <span class="hljs-comment"><span class="hljs-comment">/* halt the program */</span></span> };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda mungkin bertanya-tanya mengapa kode interupsi tidak termasuk dalam instruksi. </font><font style="vertical-align: inherit;">Ini karena mereka sebenarnya tidak menambahkan LC-3 fungsionalitas baru, tetapi hanya menyediakan cara mudah untuk menyelesaikan tugas (seperti fungsi sistem di C). </font><font style="vertical-align: inherit;">Dalam simulator LC-3 resmi, kode interupsi </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ditulis dalam assembler</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ketika kode interupsi dipanggil, komputer pindah ke alamat kode ini. </font><font style="vertical-align: inherit;">CPU menjalankan instruksi prosedur dan, setelah selesai, </font></font><code>PC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diatur ulang ke lokasi dari mana interupsi dipanggil.</font></font><br><br><blockquote> <b>:</b>       <code>0x3000</code>  <code>0x0</code> .    ,        . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak ada spesifikasi tentang </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bagaimana</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menerapkan rutinitas interupsi: hanya apa yang harus mereka lakukan. Dalam VM kami, kami akan bertindak sedikit berbeda dengan menuliskannya dalam C. Ketika kode interupsi dipanggil, fungsi C. Akan dipanggil. Setelah operasinya, instruksi akan dilanjutkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun prosedur dapat ditulis dalam assembler dan komputer fisik LC-3 akan demikian, ini bukan pilihan terbaik untuk VM. Alih-alih menulis prosedur input-output primitif Anda sendiri, Anda dapat menggunakan prosedur yang tersedia di OS kami. Ini akan meningkatkan mesin virtual pada komputer kami, menyederhanakan kode dan memberikan tingkat abstraksi yang lebih tinggi untuk portabilitas.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Catatan:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Satu contoh spesifik adalah input keyboard. </font><font style="vertical-align: inherit;">Versi assembler menggunakan loop untuk terus memeriksa input keyboard. </font><font style="vertical-align: inherit;">Tetapi begitu banyak waktu prosesor terbuang sia-sia! </font><font style="vertical-align: inherit;">Dengan menggunakan fungsi OS yang sesuai, program dapat tidur nyenyak sebelum sinyal input.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di operator pilihan ganda untuk opcode, </font></font><code>TRAP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tambahkan sakelar lain:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instr &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_GETC: {TRAP GETC, <span class="hljs-number"><span class="hljs-number">9</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_OUT: {TRAP OUT, <span class="hljs-number"><span class="hljs-number">9</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_PUTS: {TRAP PUTS, <span class="hljs-number"><span class="hljs-number">8</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_IN: {TRAP IN, <span class="hljs-number"><span class="hljs-number">9</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_PUTSP: {TRAP PUTSP, <span class="hljs-number"><span class="hljs-number">9</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRAP_HALT: {TRAP HALT, <span class="hljs-number"><span class="hljs-number">9</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seperti dengan instruksi, saya akan menunjukkan kepada Anda bagaimana menerapkan satu prosedur, dan melakukan sisanya sendiri. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Putt </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode interrupt </font></font><code>PUTS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">digunakan untuk mengembalikan sebuah string dengan nol terminating (mirip </font></font><code>printf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di C). </font><font style="vertical-align: inherit;">Spesifikasi pada halaman 543. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menampilkan string, kita harus memberikan string interrupt untuk ditampilkan. </font><font style="vertical-align: inherit;">Ini dilakukan dengan menyimpan alamat karakter pertama </font></font><code>R0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebelum pemrosesan dimulai. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dari spesifikasi:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tampilkan string karakter ASCII di layar konsol. </font><font style="vertical-align: inherit;">Karakter terkandung dalam sel memori berturut-turut, satu karakter per sel, mulai dari alamat yang ditentukan dalam </font></font><code>R0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Output berakhir ketika nilai dijumpai dalam memori </font></font><code>x0000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">(hal. 543)</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhatikan bahwa tidak seperti string C, di sini karakter disimpan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bukan dalam satu byte, tetapi di satu lokasi di memori</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Lokasi memori LC-3 adalah 16 bit, sehingga setiap karakter dalam string adalah 16 bit. </font><font style="vertical-align: inherit;">Untuk menampilkan ini dalam fungsi C, Anda perlu mengubah setiap nilai menjadi karakter dan mencetaknya secara terpisah.</font></font><br><br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">/* one char per word */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>* c = memory + reg[R_R0]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (*c) { putc((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)*c, <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); ++c; } fflush(<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak diperlukan lagi untuk prosedur ini. </font><font style="vertical-align: inherit;">Rutin interupsi cukup mudah jika Anda tahu C. Sekarang kembali ke spesifikasi dan mengimplementasikan sisanya. </font><font style="vertical-align: inherit;">Seperti halnya instruksi, kode lengkap dapat ditemukan di akhir panduan ini.</font></font><br><br><a name="9"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9. Cheat sheet untuk rutinitas interupsi </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bagian ini berisi implementasi lengkap dari rutin interupsi yang tersisa. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entri karakter </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* read a single ASCII char */</span></span> reg[R_R0] = (<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>)getchar();</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Output karakter </font></font></h3><br><pre> <code class="cpp hljs">putc((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)reg[R_R0], <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); fflush(<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Permintaan input karakter </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Enter a character: "</span></span>); reg[R_R0] = (<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>)getchar();</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Output garis </font></font></h3><br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">/* one char per byte (two bytes per word) here we need to swap back to big endian format */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>* c = memory + reg[R_R0]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (*c) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> char1 = (*c) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; putc(char1, <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> char2 = (*c) &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (char2) putc(char2, <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); ++c; } fflush(<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pengakhiran Program </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"HALT"</span></span>); fflush(<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>); running = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><a name="10"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10. Mengunduh program </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami banyak berbicara tentang memuat dan menjalankan instruksi dari memori, tetapi bagaimana cara instruksi masuk ke memori secara umum? </font><font style="vertical-align: inherit;">Saat mengonversi program assembler ke kode mesin, hasilnya adalah file yang berisi berbagai instruksi dan data. </font><font style="vertical-align: inherit;">Itu dapat diunduh dengan hanya menyalin konten langsung ke alamat dalam memori. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16 bit pertama dari file program menunjukkan alamat di memori tempat program harus dimulai. </font><font style="vertical-align: inherit;">Alamat ini disebut </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Itu harus dibaca terlebih dahulu, setelah itu sisa data dibaca ke dalam memori dari file. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut adalah kode untuk memuat program ke dalam memori LC-3:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_image_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FILE* file)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* the origin tells us where in memory to place the image */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> origin; fread(&amp;origin, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(origin), <span class="hljs-number"><span class="hljs-number">1</span></span>, file); origin = swap16(origin); <span class="hljs-comment"><span class="hljs-comment">/* we know the maximum file size so we only need one fread */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> max_read = UINT16_MAX - origin; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>* p = memory + origin; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> read = fread(p, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>), max_read, file); <span class="hljs-comment"><span class="hljs-comment">/* swap to little endian */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (read-- &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { *p = swap16(*p); ++p; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhatikan bahwa untuk setiap nilai yang dimuat disebut </font></font><code>swap16</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Program LC-3 ditulis dalam urutan byte langsung, tetapi kebanyakan komputer modern menggunakan urutan terbalik. </font><font style="vertical-align: inherit;">Akibatnya, kita perlu membalik masing-masing yang dimuat </font></font><code>uint16</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">(Jika Anda secara tidak sengaja menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">komputer aneh</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seperti </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PPC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , maka tidak ada yang perlu diubah).</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> swap16(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | (x &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>); }</code> </pre> <br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Catatan: </font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Urutan byte</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mengacu pada bagaimana byte dari integer ditafsirkan. </font><font style="vertical-align: inherit;">Dalam urutan terbalik, byte pertama adalah digit paling signifikan, dan dalam urutan terbalik, sebaliknya. </font><font style="vertical-align: inherit;">Sejauh yang saya tahu, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebagian besar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> keputusan </font><font style="vertical-align: inherit;">arbitrer. </font><font style="vertical-align: inherit;">Perusahaan yang berbeda membuat keputusan yang berbeda, jadi sekarang kami memiliki implementasi yang berbeda. </font><font style="vertical-align: inherit;">Untuk proyek ini, Anda tidak perlu lagi tahu apa pun tentang urutan byte.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan juga fungsi yang nyaman untuk </font></font><code>read_image_file</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang mengambil jalur untuk string:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_image</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* image_path)</span></span></span><span class="hljs-function"> </span></span>{ FILE* file = fopen(image_path, <span class="hljs-string"><span class="hljs-string">"rb"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!file) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }; read_image_file(file); fclose(file); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><a name="11"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11. Register yang dipetakan </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beberapa register khusus tidak tersedia dari tabel register reguler. Sebagai gantinya, alamat khusus disediakan untuk mereka dalam memori. Untuk membaca dan menulis ke register ini, Anda cukup membaca dan menulis ke memori mereka. Mereka disebut </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">register yang dipetakan memori</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Biasanya mereka digunakan untuk berinteraksi dengan perangkat perangkat keras khusus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk LC-3 kami, kami perlu mengimplementasikan dua register yang dapat dipetakan. Ini adalah register status keyboard ( </font></font><code>KBSR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) dan register data keyboard ( </font></font><code>KBDR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Yang pertama menunjukkan apakah tombol telah ditekan, dan yang kedua menentukan tombol mana yang ditekan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun input keyboard dapat diminta menggunakan </font></font><code>GETC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, itu memblokir eksekusi sampai input diterima. </font></font><code>KBSR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>KBDR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">izinkan</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menginterogasi keadaan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> perangkat sambil terus menjalankan program, sehingga tetap responsif sambil menunggu input.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { MR_KBSR = <span class="hljs-number"><span class="hljs-number">0xFE00</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* keyboard status */</span></span> MR_KBDR = <span class="hljs-number"><span class="hljs-number">0xFE02</span></span> <span class="hljs-comment"><span class="hljs-comment">/* keyboard data */</span></span> };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Register yang dipetakan mempersulit akses memori sedikit. </font><font style="vertical-align: inherit;">Kita tidak bisa membaca dan menulis ke array memori secara langsung, tetapi sebaliknya harus memanggil fungsi khusus - setter dan pengambil. </font><font style="vertical-align: inherit;">Setelah membaca memori dari register KBSR, rajin memeriksa keyboard dan memperbarui kedua lokasi di memori.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mem_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ memory[address] = val; } <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> mem_read(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> address) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (address == MR_KBSR) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (check_key()) { memory[MR_KBSR] = (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">15</span></span>); memory[MR_KBDR] = getchar(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { memory[MR_KBSR] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> memory[address]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah komponen terakhir dari mesin virtual! </font><font style="vertical-align: inherit;">Jika Anda telah menerapkan sisa rutinitas dan instruksi interupsi, Anda hampir siap untuk mencobanya! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segala sesuatu yang ditulis harus ditambahkan ke file C dalam urutan berikut:</font></font><br><br><pre> <code class="cpp hljs">{Memory Mapped Registers, <span class="hljs-number"><span class="hljs-number">11</span></span>} {TRAP Codes, <span class="hljs-number"><span class="hljs-number">8</span></span>} {Memory Storage, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Register Storage, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Functions, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Main Loop, <span class="hljs-number"><span class="hljs-number">5</span></span>}</code> </pre> <br><a name="12"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12. Fitur Platform </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian ini berisi beberapa detail yang membosankan yang diperlukan untuk mengakses keyboard dan bekerja dengan benar. </font><font style="vertical-align: inherit;">Tidak ada yang menarik atau informatif tentang pengoperasian mesin virtual. </font><font style="vertical-align: inherit;">Rasakan copy paste gratis! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda mencoba memulai VM di sistem operasi selain Unix, seperti Windows, fungsi-fungsi ini harus diganti dengan fungsi Windows yang sesuai.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> check_key() { fd_set readfds; FD_ZERO(&amp;readfds); FD_SET(STDIN_FILENO, &amp;readfds); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeval</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeout</span></span></span><span class="hljs-class">;</span></span> timeout.tv_sec = <span class="hljs-number"><span class="hljs-number">0</span></span>; timeout.tv_usec = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> select(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;readfds, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;timeout) != <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kode untuk mengekstrak jalur dari argumen program dan menampilkan contoh penggunaan jika hilang. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (argc &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* show usage string */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"lc3 [image-file1] ...\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; argc; ++j) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!read_image(argv[j])) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"failed to load image: %s\n"</span></span>, argv[j]); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kode konfigurasi input terminal khusus unix. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">termios</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">original_tio</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">disable_input_buffering</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ tcgetattr(STDIN_FILENO, &amp;original_tio); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">termios</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new_tio</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">original_tio</span></span></span><span class="hljs-class">;</span></span> new_tio.c_lflag &amp;= ~ICANON &amp; ~ECHO; tcsetattr(STDIN_FILENO, TCSANOW, &amp;new_tio); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restore_input_buffering</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ tcsetattr(STDIN_FILENO, TCSANOW, &amp;original_tio); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ketika program terganggu, kami ingin mengembalikan konsol ke pengaturan normal. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_interrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> signal)</span></span></span><span class="hljs-function"> </span></span>{ restore_input_buffering(); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">-2</span></span>); }</code> </pre> <br><pre> <code class="cpp hljs">signal(SIGINT, handle_interrupt); disable_input_buffering();</code> </pre> <br><pre> <code class="cpp hljs">restore_input_buffering();</code> </pre> <br><pre> <code class="cpp hljs">{Sign Extend, <span class="hljs-number"><span class="hljs-number">6</span></span>} {Swap, <span class="hljs-number"><span class="hljs-number">10</span></span>} {Update Flags, <span class="hljs-number"><span class="hljs-number">6</span></span>} {Read Image File, <span class="hljs-number"><span class="hljs-number">10</span></span>} {Read Image, <span class="hljs-number"><span class="hljs-number">10</span></span>} {Check Key, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Memory Access, <span class="hljs-number"><span class="hljs-number">11</span></span>} {Input Buffering, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Handle Interrupt, <span class="hljs-number"><span class="hljs-number">12</span></span>}</code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; #include &lt;string.h&gt; #include &lt;signal.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/time.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/termios.h&gt; #include &lt;sys/mman.h&gt;</span></span></span></span></code> </pre> <br><a name="13"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Startup mesin virtual </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang Anda dapat membangun dan menjalankan mesin virtual LC-3! </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompilasi </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">program dengan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kompiler favorit </font><a href=""><font style="vertical-align: inherit;">Anda</font></a><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unduh versi kompilasi </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2048</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rogue</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jalankan program dengan file obj sebagai argumen: </font></font><br> <code>lc3-vm path/to/2048.obj</code> </li> <li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mainkan di 2048! </font></font></li></ol><br><pre> <code class="cpp hljs">Control the game <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> WASD keys. <span class="hljs-function"><span class="hljs-function">Are you on an ANSI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">terminal</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(y/n)</span></span></span><span class="hljs-function">? y +--------------------------+ | | | | | | | 2 | | | | 2 | | | | | | | +--------------------------+</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Debugging </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika program tidak bekerja dengan benar, kemungkinan besar Anda salah mengode beberapa jenis instruksi. </font><font style="vertical-align: inherit;">Sulit untuk melakukan debug. </font><font style="vertical-align: inherit;">Saya sarankan Anda membaca kode perakitan program pada saat yang sama - dan dengan bantuan debugger langkah demi langkah ikuti petunjuk dari mesin virtual satu per satu. </font><font style="vertical-align: inherit;">Saat membaca kode, pastikan bahwa VM pergi ke instruksi yang dimaksud. </font><font style="vertical-align: inherit;">Jika ketidakcocokan terjadi, Anda akan menemukan instruksi mana yang menyebabkan masalah. </font><font style="vertical-align: inherit;">Baca kembali spesifikasi dan periksa kembali kode.</font></font><br><br><a name="14"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14. Metode alternatif dalam C ++ </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut cara canggih untuk menjalankan instruksi yang secara signifikan mengurangi ukuran kode. Ini adalah bagian yang sepenuhnya opsional. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena C ++ mendukung generik yang kuat selama proses kompilasi, kami dapat membuat bagian dari instruksi menggunakan kompiler. Metode ini mengurangi duplikasi kode dan sebenarnya lebih dekat ke tingkat perangkat keras komputer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idenya adalah untuk menggunakan kembali langkah-langkah umum untuk setiap instruksi. Misalnya, beberapa instruksi menggunakan pengalamatan tidak langsung atau perluasan nilai dan menambahkannya ke nilai saat ini </font></font><code>PC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Setuju, akan menyenangkan untuk menulis kode ini sekali untuk semua instruksi?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mempertimbangkan instruksi sebagai urutan langkah-langkah, kita melihat bahwa setiap instruksi hanyalah penataan ulang beberapa langkah yang lebih kecil. </font><font style="vertical-align: inherit;">Kami akan menggunakan tanda bit untuk menunjukkan langkah mana yang harus diikuti untuk setiap instruksi. </font><font style="vertical-align: inherit;">Nilai </font></font><code>1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam bit nomor instruksi menunjukkan bahwa untuk instruksi ini kompiler harus menyertakan bagian kode ini.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> op&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ins</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> instr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r0, r1, r2, imm5, imm_flag; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc_plus_off, base_plus_off; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> opbit = (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; op); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0x4EEE</span></span> &amp; opbit) { r0 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0x12E3</span></span> &amp; opbit) { r1 = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0x0022</span></span> &amp; opbit) { r2 = instr &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; imm_flag = (instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x1</span></span>; imm5 = sign_extend((instr) &amp; <span class="hljs-number"><span class="hljs-number">0x1F</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0x00C0</span></span> &amp; opbit) { <span class="hljs-comment"><span class="hljs-comment">// Base + offset base_plus_off = reg[r1] + sign_extend(instr &amp; 0x3f, 6); } if (0x4C0D &amp; opbit) { // Indirect address pc_plus_off = reg[R_PC] + sign_extend(instr &amp; 0x1ff, 9); } if (0x0001 &amp; opbit) { // BR uint16_t cond = (instr &gt;&gt; 9) &amp; 0x7; if (cond &amp; reg[R_COND]) { reg[R_PC] = pc_plus_off; } } if (0x0002 &amp; opbit) // ADD { if (imm_flag) { reg[r0] = reg[r1] + imm5; } else { reg[r0] = reg[r1] + reg[r2]; } } if (0x0020 &amp; opbit) // AND { if (imm_flag) { reg[r0] = reg[r1] &amp; imm5; } else { reg[r0] = reg[r1] &amp; reg[r2]; } } if (0x0200 &amp; opbit) { reg[r0] = ~reg[r1]; } // NOT if (0x1000 &amp; opbit) { reg[R_PC] = reg[r1]; } // JMP if (0x0010 &amp; opbit) // JSR { uint16_t long_flag = (instr &gt;&gt; 11) &amp; 1; pc_plus_off = reg[R_PC] + sign_extend(instr &amp; 0x7ff, 11); reg[R_R7] = reg[R_PC]; if (long_flag) { reg[R_PC] = pc_plus_off; } else { reg[R_PC] = reg[r1]; } } if (0x0004 &amp; opbit) { reg[r0] = mem_read(pc_plus_off); } // LD if (0x0400 &amp; opbit) { reg[r0] = mem_read(mem_read(pc_plus_off)); } // LDI if (0x0040 &amp; opbit) { reg[r0] = mem_read(base_plus_off); } // LDR if (0x4000 &amp; opbit) { reg[r0] = pc_plus_off; } // LEA if (0x0008 &amp; opbit) { mem_write(pc_plus_off, reg[r0]); } // ST if (0x0800 &amp; opbit) { mem_write(mem_read(pc_plus_off), reg[r0]); } // STI if (0x0080 &amp; opbit) { mem_write(base_plus_off, reg[r0]); } // STR if (0x8000 &amp; opbit) // TRAP { {TRAP, 8} } //if (0x0100 &amp; opbit) { } // RTI if (0x4666 &amp; opbit) { update_flags(r0); } }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*op_table[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">16</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>= { ins&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">5</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">6</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">7</span></span>&gt;, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, ins&lt;<span class="hljs-number"><span class="hljs-number">9</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">10</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">11</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">12</span></span>&gt;, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, ins&lt;<span class="hljs-number"><span class="hljs-number">14</span></span>&gt;, ins&lt;<span class="hljs-number"><span class="hljs-number">15</span></span>&gt; };</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Catatan:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saya belajar tentang teknik ini dari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">emulator NES yang dikembangkan oleh Bisqwit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Jika Anda tertarik pada emulasi atau NES, saya sangat merekomendasikan videonya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versi lain dari C ++ menggunakan kode yang sudah ditulis. </font><font style="vertical-align: inherit;">Versi lengkap di </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cpp hljs">{Includes, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Registers, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Condition Flags, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Opcodes, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Memory Mapped Registers, <span class="hljs-number"><span class="hljs-number">11</span></span>} {TRAP Codes, <span class="hljs-number"><span class="hljs-number">8</span></span>} {Memory Storage, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Register Storage, <span class="hljs-number"><span class="hljs-number">3</span></span>} {Functions, <span class="hljs-number"><span class="hljs-number">12</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> running = <span class="hljs-number"><span class="hljs-number">1</span></span>; {Instruction C++, <span class="hljs-number"><span class="hljs-number">14</span></span>} {Op Table, <span class="hljs-number"><span class="hljs-number">14</span></span>} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[])</span></span></span><span class="hljs-function"> </span></span>{ {Load Arguments, <span class="hljs-number"><span class="hljs-number">12</span></span>} {Setup, <span class="hljs-number"><span class="hljs-number">12</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { PC_START = <span class="hljs-number"><span class="hljs-number">0x3000</span></span> }; reg[R_PC] = PC_START; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (running) { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> instr = mem_read(reg[R_PC]++); <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> op = instr &gt;&gt; <span class="hljs-number"><span class="hljs-number">12</span></span>; op_table[op](instr); } {Shutdown, <span class="hljs-number"><span class="hljs-number">12</span></span>} }</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id434138/">https://habr.com/ru/post/id434138/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id434126/index.html">Putar media menggunakan perpustakaan VLCj</a></li>
<li><a href="../id434128/index.html">PHP Digest No. 146 (10 - 24 Desember 2018) + Hasil 2018</a></li>
<li><a href="../id434130/index.html">Antarmuka reaktif. Kuliah oleh Artyom Belov di FrontTalks 2018</a></li>
<li><a href="../id434134/index.html">Analisis hasil 2018 Kaggle ML & DS Survey</a></li>
<li><a href="../id434136/index.html">Anatomi Korporat</a></li>
<li><a href="../id434140/index.html">Sejarah Singkat Fitur Asinkron Javascript</a></li>
<li><a href="../id434142/index.html">Tim QRL menetapkan tenggat waktu yang ketat untuk migrasi token</a></li>
<li><a href="../id434146/index.html">10 Film TI Teratas</a></li>
<li><a href="../id434150/index.html">Fitur pencarian pekerjaan di Eropa</a></li>
<li><a href="../id434154/index.html">Kumpulan data Tahun Baru 2018: semantik terbuka dari bahasa Rusia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>