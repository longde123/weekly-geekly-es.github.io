<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕑 🖖🏾 🍓 Bagaimana LLVM mengoptimalkan fungsi 🍍 🕴🏻 ✋🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kompilator AOT yang mengoptimalkan biasanya disusun seperti ini: 



1. frontend mengubah kode sumber ke representasi perantara 
2. pipeline machine-i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana LLVM mengoptimalkan fungsi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433598/">  Kompilator AOT yang mengoptimalkan biasanya disusun seperti ini: <br><br><ol><li>  frontend mengubah kode sumber ke representasi perantara </li><li>  pipeline machine-independent optimization (IR): urutan lintasan yang menulis ulang IR untuk menghilangkan bagian dan struktur yang tidak efisien yang tidak dapat langsung dikonversi ke kode mesin.  Terkadang bagian ini disebut ujung-tengah. </li><li>  Backend yang bergantung pada mesin untuk menghasilkan kode perakitan atau kode mesin. </li></ol><br><img src="https://habrastorage.org/webt/dx/1k/k8/dx1kk8oxixxudiub62ffatlrpzq.jpeg"><br><br>  Dalam beberapa kompiler, format IR tetap tidak berubah selama proses pengoptimalan, pada yang lain format atau semantiknya berubah.  Dalam LLVM, format dan semantiknya diperbaiki, dan oleh karena itu dimungkinkan untuk menjalankan lintasan dengan urutan apa pun tanpa risiko kompilasi yang salah atau crash kompilator. <br><a name="habracut"></a><br>  Urutan melewati optimisasi dikembangkan oleh pengembang kompiler, tujuannya adalah untuk menyelesaikan pekerjaan dalam waktu yang dapat diterima.  Ini berubah dari waktu ke waktu, dan, tentu saja, ada serangkaian operan yang berbeda untuk dijalankan pada level optimisasi yang berbeda.  Salah satu topik jangka panjang dalam penelitian komputer adalah penggunaan pembelajaran mesin atau metode lain untuk menemukan jalur optimalisasi pipa terbaik untuk penggunaan umum dan untuk aplikasi spesifik yang jalur pipa standarnya tidak terlalu cocok. <br><br>  Prinsip-prinsip mendesain bagian-bagiannya adalah minimalisme dan ortogonalitas: setiap pass harus melakukan satu hal dengan baik, dan fungsinya tidak boleh tumpang tindih.  Dalam praktiknya, kompromi terkadang dimungkinkan.  Dalam praktiknya, ketika dua lintasan menghasilkan pekerjaan untuk satu sama lain, mereka dapat digabungkan menjadi satu lintasan yang lebih besar.  Juga, beberapa fungsionalitas tingkat IR, seperti melipat operator konstan, sangat berguna sehingga tidak masuk akal untuk meletakkannya dalam lintasan terpisah, LLVM secara default meminimalkan operasi konstan ketika instruksi dibuat. <br><br>  Dalam posting ini kita akan melihat bagaimana beberapa optimasi LLVM melewati bekerja.  Maksud saya, Anda membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian ini</a> tentang bagaimana Clang mengkompilasi fungsi atau bahwa Anda kurang lebih memahami cara kerja LLVM IR.  Memahami formulir SSA (static single assignment) sangat membantu: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wikipedia</a> akan memberi Anda pengantar, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buku ini</a> akan memberi Anda lebih banyak informasi daripada yang ingin Anda ketahui.  Baca juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Referensi Bahasa LLVM</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">daftar lintasan optimisasi</a> . <br><br>  Mari kita lihat bagaimana Dentang / LLVM 6.0.1 mengoptimalkan kode C ++ ini: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_sorted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n - <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a[i] &gt; a[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Pada saat yang sama, kami ingat bahwa jalur optimasi adalah tempat yang sangat sibuk, dan kami akan kehilangan banyak momen menyenangkan, seperti: <br><br>  Inlining adalah pengoptimalan sederhana namun sangat penting yang tidak terjadi dalam contoh ini, karena  kami menganggap hanya satu fungsi.  Hampir semua optimasi khusus untuk C ++, tetapi tidak untuk C. Auto-vektorisasi, yang mencegah keluar awal dari loop <br><br>  Dalam teks di bawah ini, saya akan melewati semua lintasan yang tidak membuat perubahan pada kode.  Juga, kita tidak akan melihat ke dalam backend, yang juga melakukan banyak pekerjaan.  Tetapi bahkan bagian yang tersisa pun banyak!  (Maaf untuk gambarnya, tetapi ini tampaknya menjadi cara terbaik untuk menghindari kesulitan pemformatan). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berikut adalah file IR yang</a> dibuat oleh Dentang (saya secara manual menghapus atribut "optnone" yang dimasukkan Dentang) dan baris perintah yang digunakan untuk melihat efek dari setiap pass optimasi: <br><br><pre> <code class="bash hljs">opt -O2 -<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>-before-all -<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>-after-all is_sorted2.ll</code> </pre> <br>  Lulus pertama adalah <a href="">penyederhanaan CFG</a> (grafik aliran kendali).  Karena Dentang tidak melakukan pengoptimalan, IR yang dihasilkannya berisi opsi pengoptimalan sederhana: <br><br><img src="https://habrastorage.org/webt/kn/xb/ow/knxbowtdwkjlcjaogvmo7rlzdtu.png"><br><br>  Di sini, unit dasar 26 hanya bergerak ke blok 27. Blok tersebut dapat dihapus dengan mengarahkan referensi ke mereka oleh blok tujuan.  LLVM akan secara otomatis memberi nomor baru pada blok.  Daftar lengkap konversi yang dihasilkan oleh SimplifyCFG terdaftar di bagian atas lorong. <br><br> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> <ul><li> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> </li> <li> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> </li> <li> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> </li> <li> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> </li> <li> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> </li> <li> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> </li> </ul> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> <br>  Sebagian besar peluang untuk pengoptimalan CFG muncul sebagai hasil dari pekerjaan pass LLVM lainnya.  Misalnya, menghapus kode mati eliminasi dan memindahkan invarian lingkaran dapat dengan mudah menyebabkan blok dasar kosong. <br><br>  Bagian selanjutnya, <a href="">SROA</a> (penggantian skalar agregat), adalah salah satu yang paling banyak digunakan.  Namanya menyebabkan beberapa kebingungan karena SROA hanya salah satu fungsinya.  Pass memeriksa setiap pengalokasian instruksi (alokasi memori pada tumpukan fungsi), dan mencoba mengubahnya menjadi register SSA.  Satu instruksi pengalokasian ( <i>yaitu, pada kenyataannya, sebuah variabel pada tumpukan</i> kira <i>-</i> kira Terjemahan.) Berubah menjadi banyak register jika ia ditugaskan secara statis beberapa kali, dan jika pengalokasian adalah kelas atau struktur, ia dibagi menjadi komponen (ini disebut "skalar" pengganti ”sebagaimana disebutkan dalam nama bagian ini).  Versi sederhana SROA akan menyerah untuk menumpuk variabel yang digunakan untuk operasi pengambilan alamat, tetapi versi LLVM berinteraksi dengan algoritma analisis alias dan bertindak dengan cara yang cerdas (meskipun ini tidak diperlukan dalam contoh berikut). <br><br><img src="https://habrastorage.org/webt/d9/qp/tt/d9qpttybpemz-gxsqew6orkzlj8.png"><br><br>  Setelah SROA, petunjuk pengalokasian (dan petunjuk pemuatan dan penyimpanan yang sesuai) menghilang, dan kode menjadi lebih bersih dan lebih cocok untuk pengoptimalan berikutnya (tentu saja, SROA tidak dapat menghapus semua pengalokasian dalam kasus umum, ini hanya terjadi jika analisis penunjuk dapat benar-benar menyingkirkan alias).  Dalam prosesnya, SROA memasukkan instruksi phi ke dalam kode.  Instruksi phi membentuk inti dari representasi SSA, dan kurangnya phi dalam kode yang dihasilkan oleh Clang memberitahu kita bahwa Clang menghasilkan versi sepele dari SSA, di mana blok-blok dasar dihubungkan melalui memori dan bukan melalui register SSA. <br><br>  Berikut ini adalah " <a href="">eliminasi subekspresi umum awal</a> ", CSE (penghapusan dini subekspresi umum).  CSE mencoba menghilangkan kasus subekspresi berlebihan yang dapat terjadi baik dalam kode yang ditulis manusia maupun dalam kode yang dioptimalkan sebagian.  "CSE Awal" adalah versi CSE cepat dan mudah yang mengidentifikasi kalkulasi redundan sepele. <br><br><img src="https://habrastorage.org/webt/zv/bk/ud/zvbkudo1n9njnkertwvr_agrkrq.png"><br><br>  Di sini,% 10 dan% 17 melakukan hal yang sama, yaitu, kode dapat ditulis ulang sehingga satu nilai digunakan, dan yang kedua dihapus.  Ini memberikan beberapa wawasan tentang manfaat SSA: ketika setiap register ditugaskan hanya satu kali, tidak ada yang namanya beberapa versi dari satu register.  Dengan demikian, perhitungan yang berlebihan dapat dideteksi menggunakan kesetaraan sintaksis, tanpa menggunakan analisis mendalam dari program (ini bukan kasus untuk lokasi memori yang ada di luar dunia SSA). <br><br>  Berikutnya, beberapa lintasan diluncurkan yang tidak berpengaruh dalam kasus kami, dan kemudian " <a href="">pengoptimal variabel global</a> " diluncurkan, yang digambarkan sebagai berikut: <br><br> <code>     ,      .   ,        ,  ,     ,  ..</code> <br> <br>  Bagian ini membuat perubahan berikut: <br><br><img src="https://habrastorage.org/webt/pz/nd/nm/pzndnmja1jgtbkw9acxrenagtku.png"><br><br>  Dia menambahkan atribut fungsi: metadata yang digunakan oleh satu bagian dari kompiler untuk menyimpan informasi tentang apa yang mungkin berguna untuk bagian lain dari kompiler.  Anda dapat membaca tentang tujuan dari atribut ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Tidak seperti optimasi lain yang kami pertimbangkan, optimizer variabel global adalah antar-prosedur, itu terlihat sepenuhnya pada modul LLVM.  Modul (kurang lebih) setara dengan unit kompilasi dalam C dan C ++.  Berbeda dengan optimasi antar-prosedur, intraprocedural hanya melihat satu fungsi pada satu waktu. <br><br>  Bagian selanjutnya menggabungkan instruksi dan disebut " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">instruksi combiner</a> ", InstCombine.  Ini adalah kumpulan besar dan beragam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">optimisasi lubang intip</a> , yang (biasanya) menulis ulang beberapa instruksi, dikombinasikan dengan data umum, dalam bentuk yang lebih efisien.  InstCombine tidak mengubah aliran kontrol suatu fungsi.  Dalam contoh di atas, dia tidak banyak berubah: <br><br><img src="https://habrastorage.org/webt/ma/z2/ky/maz2ky8g_cis8kasz94_rlhzck4.png"><br><br>  Di sini, alih-alih mengurangi 1 dari% 1, untuk menghitung% 4, kami menambahkan -1.  Ini bukan optimasi, tetapi kanonikisasi.  Ketika ada banyak cara untuk melakukan perhitungan, LLVM mencoba untuk membawanya ke bentuk kanonik (sering dipilih secara acak) yang akan dilewati oleh pass dan backend berikutnya.  Perubahan kedua yang dibuat InstCombine adalah bentuk kanonik dari dua operasi ekspansi yang ditandatangani (instruksi sext), yang menghitung% 7 dan% 11 dikonversi menjadi nol ekspansi (zext).  Konversi ini aman ketika kompiler dapat membuktikan bahwa operan sext adalah non-negatif.  Dalam hal ini, ini karena variabel loop berubah dari 0 ke n (jika n negatif, loop tidak dieksekusi sama sekali).  Perubahan terakhir adalah penambahan bendera “nuw” (tanpa bungkus yang tidak ditandatangani) pada instruksi yang menghitung% 10.  Kita dapat melihat bahwa ini aman, dari kenyataan bahwa (1) variabel loop selalu meningkat dan (2) jika variabel dimulai dari nol dan meningkat, itu akan menjadi tidak terdefinisi ketika tanda berubah di persimpangan INT_MAX sebelum mencapai luapan yang tidak ditandai, mengikuti UINT_MAX.  Bendera ini dapat digunakan untuk pengoptimalan berikutnya. <br><br>  Selanjutnya, SimplifyCFG memulai yang kedua kalinya, dan menghapus dua blok dasar kosong: <br><br><img src="https://habrastorage.org/webt/oa/jj/om/oajjom0adr5es0yccpze9nnkyzs.png"><br><br>  Kemudian, “Deduce function attributes” meneruskan anotasi fungsi: <br><br><img src="https://habrastorage.org/webt/vj/s4/dm/vjs4dmr1paqb3s0yabk6ev-ycfq.png"><br><br>  "Norecurse" berarti bahwa fungsi tidak termasuk dalam panggilan rekursif, "readonly" berarti bahwa fungsi tersebut tidak mengubah keadaan global.  Atribut parameter "nocapture" berarti bahwa parameter tidak disimpan di mana pun setelah keluar dari fungsi, dan "readonly" berarti bahwa memori tidak dimodifikasi oleh fungsi.  Anda dapat melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">daftar</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">atribut</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">atribut parameter</a> . <br><br>  Kemudian pass " <a href="">rotate loops</a> " memindahkan kode dalam upaya untuk meningkatkan kondisi untuk optimasi berikutnya: <br><br><img src="https://habrastorage.org/webt/fd/qm/eg/fdqmegxzophmowskfsd-wpwjkmi.png"><br><br>  Meskipun perbedaannya terlihat menakutkan, perubahannya sebenarnya kecil.  Kita dapat melihat apa yang terjadi, dengan cara yang lebih mudah dibaca, jika kita meminta LLVM untuk menggambar grafik transfer kendali sebelum dan sesudah melalui siklus rotasi.  Inilah pandangan mereka sebelum (kiri) dan sesudah (kanan): <br><br><img src="https://habrastorage.org/webt/ab/wb/8p/abwb8pofuvyvzu13vn278retos8.png"><br><br>  Kode asli masih mengikuti struktur loop yang dihasilkan Dentang: <br><br><pre> <code class="cpp hljs">initializer <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> COND COND: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> BODY <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> EXIT BODY: body modifier <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> COND EXIT:</code> </pre> <br>  Setelah dijalankan, loop terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">initializer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(condition)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">goto</span></span></span><span class="hljs-function"> BODY </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">else</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">goto</span></span></span><span class="hljs-function"> EXIT BODY: body modifier </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(condition)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">goto</span></span></span><span class="hljs-function"> BODY </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">else</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">goto</span></span></span><span class="hljs-function"> EXIT EXIT:</span></span></code> </pre> <br>  (Koreksi yang diajukan oleh Johannes Durfert tercantum di bawah ini - terima kasih!) <br><br>  Tujuan dari putaran putaran pass adalah untuk menghapus satu cabang, yang memungkinkan untuk optimasi lebih lanjut.  Saya tidak menemukan deskripsi yang lebih baik tentang konversi ini di Internet. <br><br>  Pass penyederhanaan CFG meminimalkan dua blok dasar yang hanya berisi instruksi phi degenerasi (input tunggal): <br><br><img src="https://habrastorage.org/webt/vi/rp/tv/virptvmlal7fxobwfsagegvh9sa.png"><br><br>  Pass combiner instruksi mengubah “% 4 = 0 s &lt;(% 1 - 1)” menjadi “% 4 =% 1 s&gt; 1 ″ (di mana s &lt;dan s&gt; adalah operasi untuk membandingkan operan yang ditandatangani), ini transformasi yang bermanfaat, mengurangi panjang rantai ketergantungan dan juga dapat membuat instruksi "mati" (tidak dapat dicapai) (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tambalan</a> yang melakukan ini).  Pass ini juga menghapus instruksi phi sepele yang ditambahkan oleh pass rotasi putaran. <br><br><img src="https://habrastorage.org/webt/5j/ds/vd/5jdsvdbgbxm2ycakdby1q9t9stm.png"><br><br>  Berikut ini adalah perikop “ <a href="">canonicalize natural loops</a> ”, yang dijelaskan dalam kode sumbernya sendiri sebagai berikut: <br><br> <code>          ,          . <br> <br>     (Loop pre-header) ,   ,      .      ,,  LICM. <br> <br>       ,   ,     (      )        (      ).   , ,  "store-sinking",   LICM. <br> <br>   ,               (backedge). <br> <br>  Indirectbr   .            ,      .    ,    ,     . <br> <br> ,   simplifycfg  ,   ,      ,         . <br> <br>  , ,  CFG,       . <br></code> <br><br>  Di sini kita melihat bahwa blok keluaran dimasukkan: <br><br><img src="https://habrastorage.org/webt/k_/qb/v0/k_qbv0es1zxpy7-uprkg-qc0l5y.png"><br><br>  Kemudian ikuti " <a href="">penyederhanaan variabel loop</a> ": <br><br> <code>       ( ,    ),    ,      . <br> <br>     ,     : <br> <br>       ,        . ,  'for (i = 7; i*i &lt; 1000; ++i)'   'for (i = 0; i != 25; ++i)'. <br> <br>          indvar        ,       .           ,     "". <br></code> <br>  Efek dari pass ini adalah mengubah variabel loop 32-bit menjadi 64-bit: <br><br><img src="https://habrastorage.org/webt/e9/o2/ta/e9o2tabc6zwddljjzvfqxevmnlm.png"><br><br>  Saya tidak tahu mengapa zext - sebelumnya dilemparkan ke bentuk kanonik dari sext, kembali lagi ke sext. <br><br>  Sekarang pass “ <a href="">penomoran nilai global</a> ” sedang melakukan optimasi yang sangat cerdas.  Salah satu alasan untuk menulis posting ini adalah keinginan untuk menunjukkannya.  Bisakah kamu melihatnya di sini? <br><br><img src="https://habrastorage.org/webt/xz/w9/qz/xzw9qzzlspziaetqokxpkgeajz4.png"><br><br>  Apakah kamu melihat?  Ya, dua instruksi muat di loop di sebelah kiri, sesuai dengan [i] dan [i + 1].  Di sini, GVN menemukan bahwa memuat [i] tidak perlu, karena [i +1] dari satu iterasi dari loop dapat ditransfer ke yang berikutnya, seperti [i].  Trik sederhana ini mengurangi jumlah memori yang dibaca oleh fungsi menjadi setengahnya.  Baik LLVM dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GCC</a> telah belajar untuk melakukan transformasi ini baru-baru ini. <br><br>  Anda mungkin bertanya pada diri sendiri apakah trik ini akan berhasil jika kita membandingkan [i] dengan [i + 2].  Ternyata tidak, tetapi GCC dapat mengalokasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hingga empat register</a> untuk kasus-kasus seperti itu. <br><br>  Kemudian pass “ <a href="">penghapusan kode mati bit-tracking</a> ” dimulai: <br><br> <code>    "Bit-Tracking Dead Code Elimination".   (,   ""  ""  ..) ""   .        ,    "" .</code> <br> <br>  Tapi di sini ternyata trik seperti itu tidak diperlukan, karena satu-satunya kode mati adalah instruksi GEP (get element pointer), dan itu sepele mati (pass GVN menghapus instruksi muatan yang menggunakan alamat yang dihitung oleh instruksi ini): <br><br><img src="https://habrastorage.org/webt/wc/ya/kp/wcyakpozeya4ntmpbtgj8e49h0u.png"><br><br>  Sekarang algoritma untuk menggabungkan instruksi telah menempatkan add di unit dasar lain.  Logika di mana transformasi ini ditempatkan di InstCombine tidak jelas bagi saya, mungkin tidak ada tempat yang jelas di mana ia dapat ditempatkan: <br><br><img src="https://habrastorage.org/webt/wl/5a/lf/wl5alf_cvrnvgdjtmrmeiqddvno.png"><br><br>  Sesuatu yang lebih aneh sedang terjadi sekarang: pass “ <a href="">jump threading</a> ” telah menghapus apa yang telah dilakukan pass “canonicalize natural loops” sebelumnya: <br><br><img src="https://habrastorage.org/webt/8l/qo/wj/8lqowjsprlzfgnu9w_kilkckbvc.png"><br><br>  Kemudian kita kembali melemparkan ke bentuk kanonik: <br><br><img src="https://habrastorage.org/webt/-c/ax/ev/-caxev-fsfgtsrr10dhwmwizuzg.png"><br><br>  Dan penyederhanaan CFG mengubahnya secara berbeda: <br><br><img src="https://habrastorage.org/webt/6m/p6/c8/6mp6c8wo3tdsj4ylu5_iuycuktc.png"><br><br>  Dan kembali: <br><br><img src="https://habrastorage.org/webt/yn/jm/k3/ynjmk3lrtjxek1x2tmlsbdw2sfc.png"><br><br>  Dan di sana lagi: <br><br><img src="https://habrastorage.org/webt/to/l2/jb/tol2jb-p3tatdxzdqpas_vsnkt0.png"><br><br>  Dan kembali: <br><br><img src="https://habrastorage.org/webt/xx/dd/o5/xxddo5fos6vgooq4g_mu4pvrss4.png"><br><br>  Dan disana: <br><br><img src="https://habrastorage.org/webt/nf/gp/qv/nfgpqvw4-oikia4hmkxok04vmwo.png"><br><br>  Dan akhirnya, kita selesai dengan midland!  Kode di sebelah kanan adalah kode yang akan kami sampaikan (dalam kasus kami) ke backend x86-64. <br><br>  Anda mungkin ingin tahu apakah fluktuasi perilaku pada akhir pipa adalah hasil dari bug penyusun, tetapi mari kita perhatikan bahwa fungsi ini sangat, sangat sederhana dan ada banyak lintasan yang terlibat dalam pemrosesan, tetapi saya bahkan tidak menyebutkannya karena mereka tidak melakukan perubahan apa pun pada kode.  Sepanjang paruh kedua dari pipa optimasi, kami terutama mengamati kasus-kasus degenerasi untuk fungsi ini. <br><br>  Ucapan Terima Kasih: beberapa siswa dalam kursus kompiler mendalam saya musim gugur ini meninggalkan umpan balik pada draft posting ini (dan saya juga menggunakan bahan ini untuk pekerjaan rumah).  Saya membahas fungsi-fungsi yang dibahas di sini dalam serangkaian kuliah yang bagus tentang optimasi loop. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433598/">https://habr.com/ru/post/id433598/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433582/index.html">Bagaimana jika pembagian keuntungan 30/70 berhenti menjadi standar pengembang game?</a></li>
<li><a href="../id433586/index.html">Bagaimana kami tidak memenangkan hackathon</a></li>
<li><a href="../id433588/index.html">Kinerja luar biasa dari algoritma C ++ 17 paralel. Mitos atau Realitas?</a></li>
<li><a href="../id433592/index.html">Informasi: Yandex.Phone</a></li>
<li><a href="../id433596/index.html">Kesalahan Magellan: Buffer overrun atau ekspedisi keliling dunia menggunakan SQLite FTS</a></li>
<li><a href="../id433600/index.html">Pixel 3 mempelajari cara menentukan kedalaman di foto</a></li>
<li><a href="../id433602/index.html">Kesederhanaan matematis mungkin mendasari kecepatan evolusi.</a></li>
<li><a href="../id433604/index.html">Kerja nyaman dengan Android Studio</a></li>
<li><a href="../id433606/index.html">Kedalaman SIEM: korelasi out-of-box. Bagian 3.2. Metodologi Normalisasi Peristiwa</a></li>
<li><a href="../id433608/index.html">Mobil masa depan. Layar bukan kaca otomatis?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>