<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>↩️ 🚩 😒 简约的四部分MIDI播放器 🕋 💵 😲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="建议的播放器不需要存储卡；它直接在ATtiny85微控制器中存储长达6,000字节的MIDI文件（与播放WAV文件的经典设计不同，它自然需要存储卡）。 使用PWM实现具有衰减的四路回放。 这里有一个发声的例子。 

 该设备是根据方案制造的： 



 如果由于软件故障而在PB4的输出端出现逻辑单元...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>简约的四部分MIDI播放器</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454394/"><img src="https://habrastorage.org/webt/wy/qv/ce/wyqvcexiheyxhiuc2lspo3iz7jm.jpeg"><br><br> 建议的播放器不需要存储卡；它直接在ATtiny85微控制器中存储长达6,000字节的MIDI文件（与播放WAV文件的经典设计不同，它自然需要存储卡）。 使用PWM实现具有衰减的四路回放。  <a href="">这里有</a>一个发声的例子。 <a name="habracut"></a><br><br> 该设备是根据方案制造的： <br><br><img src="https://habrastorage.org/webt/qs/h8/uz/qsh8uzrueecz-x4c-pxv5webr7o.gif"><br><br> 如果由于软件故障而在PB4的输出端出现逻辑单元，则微控制器和动态磁头之间的电解电容器将不会丢失常数组件。 磁头的电感不超过PWM频率。 如果决定将设备连接到放大器，为了避免后者因PWM信号而过载，您需要添加一个低通滤波器，如下所示。 <br><br>  MIDI文件必须以以下形式的数组放置在固件源中： <br><br><pre><code class="plaintext hljs">const uint8_t Tune[] PROGMEM = { 0x4d, 0x54, 0x68, 0x64, 0x00, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x01, 0x03, 0xc0, 0x4d, 0x54, 0x72, 0x6b, 0x00, 0x00, 0x0a, 0x7e, 0x00, 0xff, ... 0x50, 0xb0, 0x5b, 0x00, 0x00, 0xff, 0x2f, 0x00 };</code> </pre> <br> 有一个现成的解决方案可将文件转换为类似UNIX的操作系统上的这种格式-xxd实用程序。 我们获取MIDI文件，并通过以下实用程序进行传递： <br><br><pre> <code class="plaintext hljs">xxd -i musicbox.mid</code> </pre> <br> 控制台将显示如下内容： <br><br><pre> <code class="plaintext hljs">unsigned char musicbox_mid[] = { 0x4d, 0x54, 0x68, 0x64, 0x00, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x01, 0x03, 0xc0, 0x4d, 0x54, 0x72, 0x6b, 0x00, 0x00, 0x0a, 0x7e, 0x00, 0xff, ... 0x50, 0xb0, 0x5b, 0x00, 0x00, 0xff, 0x2f, 0x00 }; unsigned int musicbox_mid_len = 2708;</code> </pre> <br>  2708是字节长度。 原来少于6000-这意味着它适合。 通过剪贴板的十六进制数字序列将传输到草图（请记住： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在控制台中，没有Ctrl + C</a> ），而不是默认数组。 或者，如果我们希望离开，则不要执行所有这些操作。 <br><br> 计时器计数器1将从PLL以64 MHz的频率工作： <br><br><pre> <code class="plaintext hljs"> PLLCSR = 1&lt;&lt;PCKE | 1&lt;&lt;PLLE;</code> </pre> <br> 我们将此定时器转换为PWM模式以用作DAC；占空比取决于OCR1B的值： <br><br><pre> <code class="plaintext hljs"> TIMSK = 0; // Timer interrupts OFF TCCR1 = 1&lt;&lt;CS10; // 1:1 prescale GTCCR = 1&lt;&lt;PWM1B | 2&lt;&lt;COM1B0; // PWM B, clear on match OCR1B = 128; DDRB = 1&lt;&lt;DDB4; // Enable PWM output on pin 4</code> </pre> <br> 矩形脉冲的频率取决于OCR1C的值，我们将其设为255（默认情况下），然后将64 MHz的频率除以256，得到250 kHz。 <br><br> 计时器计数器0将产生中断： <br><br><pre> <code class="plaintext hljs"> TCCR0A = 3&lt;&lt;WGM00; // Fast PWM TCCR0B = 1&lt;&lt;WGM02 | 2&lt;&lt;CS00; // 1/8 prescale OCR0A = 19; // Divide by 20 TIMSK = 1&lt;&lt;OCIE0A; // Enable compare match, disable overflow</code> </pre> <br>  16 MHz的时钟频率由8分频器分频，然后由19 + 1的OCR0A值分频，得到100 kHz。 播放器为四声，每个声音获得25 kHz。 中断后，将调用ISR处理例程（TIMER0_COMPA_vect），该例程计算并输出声音。 <br><br> 看门狗定时器配置为每16 ms产生一次中断，接收中断频率是必需的： <br><br><pre> <code class="plaintext hljs">WDTCR = 1&lt;&lt;WDIE | 0&lt;&lt;WDP0; // Interrupt every 16ms</code> </pre> <br> 为了获得给定形状的振荡，使用直接数字合成。  ATtiny85中没有硬件乘法，因此我们采用矩形脉冲并将包络的幅度乘以1或-1。 幅度线性减小，并且为了在给定的时间点进行计算，足以线性减小仪表读数。 <br><br> 为每个通道提供三个变量：频率[]-频率，加速度[]-相电池，电流[]，包络幅度值。  Freq []和Acc []的值相加。 高阶位Acc []用于获得矩形脉冲。  Freq []越多，频率越高。 完成的波形乘以包络线Amp []。 所有四个通道都被多路复用并馈送到模拟输出。 <br><br> 该程序的重​​要部分是处理来自定时器0的中断的过程，该过程将振荡输出到模拟输出。 以大约95 kHz的频率调用此过程。 对于当前通道c，它更新Acc [c]和Amp [c]的值，并计算当前音符的值。 结果被发送到OCR1B计时器的OCR1B比较寄存器，以在引脚4上获得模拟信号： <br><br><pre> <code class="plaintext hljs">ISR(TIMER0_COMPA_vect) { static uint8_t c; signed char Temp, Mask, Env, Note; Acc[c] = Acc[c] + Freq[c]; Amp[c] = Amp[c] - (Amp[c] != 0); Temp = Acc[c] &gt;&gt; 8; Temp = Temp &amp; Temp&lt;&lt;1; Mask = Temp &gt;&gt; 7; Env = Amp[c] &gt;&gt; Volume; Note = (Env ^ Mask) + (Mask &amp; 1); OCR1B = Note + 128; c = (c + 1) &amp; 3; }</code> </pre> <br> 弦乐 <br><br><pre> <code class="plaintext hljs">Acc[c] = Acc[c] + Freq[c];</code> </pre> <br> 将频率freq [c]添加到电池Acc [c]。 频率[c]越大，Acc [c]值变化得越快。 然后行 <br><br><pre> <code class="plaintext hljs">Amp[c] = Amp[c] - (Amp[c] != 0);</code> </pre> <br> 降低给定通道的幅度值。 需要片段（Amp [c]！= 0），以便在振幅达到零后不会进一步减小。 现在行 <br><br><pre> <code class="plaintext hljs">Temp = Acc[c] &gt;&gt; 8;</code> </pre> <br> 将Acc [c]的高9位传送到Temp。 和线 <br><br><pre> <code class="plaintext hljs">Temp = Temp &amp; Temp&lt;&lt;1;</code> </pre> <br> 如果两个高阶位等于1，则使此变量的高阶位等于1；如果不相同，则将其设置为零。 结果是开/关比为25/75的矩形脉冲。 在以前的一种构造中，作者施加了曲折，而采用新方法时，谐波得到了更多。 弦乐 <br><br><pre> <code class="plaintext hljs">Mask = Temp &gt;&gt; 7;</code> </pre> <br> 将最高有效位的值传输到字节的其余位，例如，如果最高有效位为0，则将获得0x00，如果为1-则为0xFF。 弦乐 <br><br><pre> <code class="plaintext hljs">Env = Amp[c] &gt;&gt; Volume;</code> </pre> <br> 由于Volume = 8，因此将Volume值指定的Amp [c]位传输到Env，默认情况下是优先级1。 <br><br><pre> <code class="plaintext hljs">Note = (Env ^ Mask) + (Mask &amp; 1);</code> </pre> <br> 所有这些结合在一起。 如果Mask = 0x00，则为Note分配值Env。 如果Mask = 0xFF，则为Note分配Env +1以外的值，即带有负号的Env。 现在注意包含电流波形，电流波形从正值变为负值。 弦乐 <br><br><pre> <code class="plaintext hljs">OCR1B = Note + 128;</code> </pre> <br> 将128加到Note并将结果写入OCR1B。 弦乐 <br><br><pre> <code class="plaintext hljs">c = (c + 1) &amp; 3;</code> </pre> <br> 根据相应的中断输出四个通道，多路复用输出端的声音。 <br><br> 数组中给出了十二个音符频率： <br><br><pre> <code class="plaintext hljs">unsigned int Scale[] = { 10973, 11626, 12317, 13050, 13826, 14648, 15519, 16442, 17419, 18455, 19552, 20715};</code> </pre> <br> 其他八度音阶的音符频率通过除以2 <sup>n获得</sup> 。 例如，将10973除以2 <sup>4</sup>得到686。高位Acc [c]将以25000 /（65536/685）= 261.7 Hz的频率进行切换。 <br><br> 有两个变量会影响声音：音量-音量（从7到9）和衰减-衰减（从12到14）。“衰减”值越高，衰减越慢。 <br><br> 最简单的MIDI解释器仅关注音符，速度和除法系数的值，而忽略其他数据。  readIgnore（）例程跳过从文件接收的数组中指定数量的字节： <br><br><pre> <code class="plaintext hljs">void readIgnore (int n) { Ptr = Ptr + n; }</code> </pre> <br>  readNumber（）例程从给定的字节数中读取一个数字，精度为4： <br><br><pre> <code class="plaintext hljs">unsigned long readNumber (int n) { long result = 0; for (int i=0; i&lt;n; i++) result = (result&lt;&lt;8) + pgm_read_byte(&amp;Tune[Ptr++]); return result; }</code> </pre> <br>  readVariable（）例程读取MIDI变量精度的数字。 在这种情况下，字节数可以为1到4： <br><br><pre> <code class="plaintext hljs">unsigned long readVariable () { long result = 0; uint8_t b; do { b = pgm_read_byte(&amp;Tune[Ptr++]); result = (result&lt;&lt;7) + (b &amp; 0x7F); } while (b &amp; 0x80); return result; }</code> </pre> <br> 每个字节取7位，如果需要进一步读取另一个字节，则第八位等于1；否则，则等于0。 <br><br> 解释器调用noteOn（）例程在以下可用通道中播放笔记： <br><br><pre> <code class="plaintext hljs">void noteOn (uint8_t number) { uint8_t octave = number/12; uint8_t note = number%12; unsigned int freq = Scale[note]; uint8_t shift = 9-octave; Freq[Chan] = freq&gt;&gt;shift; Amp[Chan] = 1&lt;&lt;Decay; Chan = (Chan + 1) &amp; 3; }</code> </pre> <br>  Ptr变量指示要读取的下一个字节： <br><br><pre> <code class="plaintext hljs">void playMidiData () { Ptr = 0; // Begin at start of file</code> </pre> <br>  MIDI文件中的第一个块是标头，它指示音轨的数量，速度和分割比率： <br><br><pre> <code class="plaintext hljs">// Read header chunk unsigned long type = readNumber(4); if (type != MThd) error(1); unsigned long len = readNumber(4); unsigned int format = readNumber(2); unsigned int tracks = readNumber(2); unsigned int division = readNumber(2); // Ticks per beat TempoDivisor = (long)division*16000/Tempo;</code> </pre> <br> 除法系数通常等于960。现在，我们读取给定的块数： <br><br><pre> <code class="plaintext hljs"> // Read track chunks for (int t=0; t&lt;tracks; t++) { type = readNumber(4); if (type != MTrk) error(2); len = readNumber(4); EndBlock = Ptr + len;</code> </pre> <br> 读取顺序事件，直到块结束： <br><br><pre> <code class="plaintext hljs"> // Parse track while (Ptr &lt; EndBlock) { unsigned long delta = readVariable(); uint8_t event = readNumber(1); uint8_t eventType = event &amp; 0xF0; if (delta &gt; 0) Delay(delta/TempoDivisor);</code> </pre> <br> 在每个事件中，都指定了增量-由除法系数确定的时间单位的延迟，该延迟必须在此事件之前发生。 对于应该在此处发生的事件，delta为零。 <br><br> 元事件是类型为0xFF的事件： <br><br><pre> <code class="plaintext hljs"> // Meta event if (event == 0xFF) { uint8_t mtype = readNumber(1); uint8_t mlen = readNumber(1); // Tempo if (mtype == 0x51) { Tempo = readNumber(mlen); TempoDivisor = (long)division*16000/Tempo; // Ignore other meta events } else readIgnore(mlen);</code> </pre> <br> 我们感兴趣的唯一元事件类型是Tempo，即拍速的值（以微秒为单位）。 默认情况下为500,000，即半秒，相当于每分钟120次。 <br><br> 其余事件是由其类型的第一个十六进制数字定义的MIDI事件。 我们只对0x90感兴趣-注意开启，在以下可用频道上播放笔记： <br><br><pre> <code class="plaintext hljs"> // Note off - ignored } else if (eventType == 0x80) { uint8_t number = readNumber(1); uint8_t velocity = readNumber(1); // Note on } else if (eventType == 0x90) { uint8_t number = readNumber(1); uint8_t velocity = readNumber(1); noteOn(number); // Polyphonic key pressure } else if (eventType == 0xA0) readIgnore(2); // Controller change else if (eventType == 0xB0) readIgnore(2); // Program change else if (eventType == 0xC0) readIgnore(1); // Channel key pressure else if (eventType == 0xD0) readIgnore(1); // Pitch bend else if (eventType == 0xD0) readIgnore(2); else error(3); } } }</code> </pre> <br> 我们忽略了力度值，但是如果您愿意，可以在其上设置音符的初始幅度。 我们跳过其余事件，它们的长度可以不同。 如果MIDI文件中发生错误，则LED点亮。 <br><br> 微控制器的工作频率为16 MHz，因此不需要石英，您需要正确配置内置PLL。 为了使微控制器变得与Arduino兼容，应用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了</a> Spence Konde的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这种经验</a> 。 在Board菜单中，选择ATtinyCore子菜单，然后显示ATtiny25 / 45/85。 在以下菜单中，选择：计时器1时钟：CPU，禁用BOD，ATtiny85、16 MHz（PLL）。 然后选择Burn Bootloader，然后填写程序。 像SpinyFun的Tiny AVR编程器板一样使用该编程器。 <br><br>  CC-BY 4.0的固件在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a> ，已经在D小调中具有巴赫赋格了，原始MIDI文件<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里获取</a> 。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN454394/">https://habr.com/ru/post/zh-CN454394/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN454378/index.html">Rogozin演讲：到2030年，俄罗斯宇航员将登上月球</a></li>
<li><a href="../zh-CN454382/index.html">伊万（Ivan Uglyansky）和弗拉基米尔（Vladimir Sitnikov）在jug.msk.ru上</a></li>
<li><a href="../zh-CN454384/index.html">激光视力矫正-Smile方法真的有效吗？</a></li>
<li><a href="../zh-CN454386/index.html">AvaloniaUI的MessageBox</a></li>
<li><a href="../zh-CN454388/index.html">ARA：用于查找直线上最大点数的算法</a></li>
<li><a href="../zh-CN454396/index.html">在主要发行版上安装sdl2</a></li>
<li><a href="../zh-CN454398/index.html">从评论家到算法：民主和技术专家如何进入音乐行业</a></li>
<li><a href="../zh-CN454400/index.html">使用R和PowerShell的虚拟机状态每日报告</a></li>
<li><a href="../zh-CN454402/index.html">用于组织单元行为的Unity状态机架构</a></li>
<li><a href="../zh-CN454404/index.html">培训Cisco 200-125 CCNA v3.0。 第6天。填写空白（DHCP，TCP，“握手”，通用端口号）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>