<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¶üèæ üè≠ üî© werf - nossa ferramenta para CI / CD no Kubernetes (revis√£o e reportagem em v√≠deo) üå™Ô∏è üìÆ ü§ûüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em 27 de maio, no sal√£o principal da confer√™ncia DevOpsConf 2019, realizada como parte do festival RIT ++ 2019 , como parte da se√ß√£o Entrega cont√≠nua,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>werf - nossa ferramenta para CI / CD no Kubernetes (revis√£o e reportagem em v√≠deo)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/460351/">  Em 27 de maio, no sal√£o principal da confer√™ncia DevOpsConf 2019, realizada como parte do festival <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RIT ++ 2019</a> , como parte da se√ß√£o Entrega cont√≠nua, foi feito um relat√≥rio "werf √© a nossa ferramenta para CI / CD em Kubernetes".  Ele fala sobre os <b>problemas e desafios que todos enfrentam ao implantar no Kubernetes</b> , bem como sobre as nuances que podem n√£o ser imediatamente percept√≠veis.  Analisando poss√≠veis solu√ß√µes, mostramos como isso √© implementado na ferramenta de c√≥digo aberto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">werf</a> . <br><br>  Desde o programa, nosso utilit√°rio (anteriormente conhecido como dapp) superou o limite hist√≥rico de <b>1000 estrelas no GitHub</b> - esperamos que a crescente comunidade de seus usu√°rios simplifique a vida de muitos engenheiros de DevOps. <br><br><img src="https://habrastorage.org/webt/lh/k9/x1/lhk9x1wf3gzo6bk1lsjosnvjg1g.jpeg"><br><br>  Ent√£o, apresentamos o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><b>v√≠deo com o relat√≥rio</b></a> (~ 47 minutos, muito mais informativo que o artigo) e o principal extrato dele em forma de texto.  Vamos l√°! <a name="habracut"></a><br><br><h2>  Entrega de c√≥digo no Kubernetes </h2><br>  A conversa n√£o ser√° mais sobre werf, mas sobre CI / CD no Kubernetes, o que implica que nosso software √© empacotado em cont√™ineres do Docker <i>(falei sobre isso no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">relat√≥rio de 2016</a> )</i> , e os K8s ser√£o usados ‚Äã‚Äãpara inici√°-lo na produ√ß√£o <i>(sobre isso - em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2017</a> )</i> . <br><br>  Como √© a entrega do Kubernetes? <br><br><ul><li>  Existe um reposit√≥rio Git com c√≥digo e instru√ß√µes para constru√≠-lo.  O aplicativo √© compilado em uma imagem do Docker e publicado no Registro do Docker. </li><li>  No mesmo reposit√≥rio, h√° instru√ß√µes sobre como implantar e executar o aplicativo.  No est√°gio de implanta√ß√£o, essas instru√ß√µes s√£o enviadas ao Kubernetes, que recebe a imagem desejada do registro e a inicia. </li><li>  Al√©m disso, geralmente existem testes.  Alguns deles podem ser realizados ao publicar uma imagem.  Voc√™ tamb√©m pode (pelas mesmas instru√ß√µes) implantar uma c√≥pia do aplicativo (em um espa√ßo para nome K8s separado ou em um cluster separado) e executar testes nele. </li><li>  Por fim, precisamos de um sistema de IC que receba eventos do Git (ou cliques no bot√£o) e chame todos os est√°gios indicados: construir, publicar, implantar, testar. </li></ul><br><img src="https://habrastorage.org/webt/vd/jh/ks/vdjhksq3874swybast6v7oerqe4.gif"><br><br>  Existem algumas notas importantes aqui: <br><br><ol><li>  Como temos uma infraestrutura imut√°vel, a imagem do aplicativo usada em todas as etapas (preparo, produ√ß√£o, etc.) <b>deve ser uma</b> .  <i>Eu falei mais sobre isso e com exemplos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .</i> </li><li>  Como seguimos a infraestrutura como um c√≥digo <i>(IaC)</i> , o c√≥digo do aplicativo e as instru√ß√µes para compilar e execut√°-lo devem estar <b>em um reposit√≥rio</b> .  <i>Para mais informa√ß√µes, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o mesmo relat√≥rio</a> .</i> </li><li>  Normalmente, vemos a cadeia de entrega <i>(entrega)</i> assim: o aplicativo √© montado, testado, liberado <i>(est√°gio de libera√ß√£o)</i> e √© tudo - a entrega ocorreu.  Mas, na realidade, o usu√°rio recebe o que voc√™ lan√ßou, <b>n√£o</b> quando voc√™ o entregou √† produ√ß√£o, mas quando ele p√¥de ir at√© l√° e essa produ√ß√£o funcionou.  Portanto, acredito que a cadeia de entrega termina <b>apenas no est√°gio operacional</b> <i>(execu√ß√£o)</i> e, mais precisamente, mesmo no momento em que o c√≥digo foi removido da produ√ß√£o (substituindo-o por um novo). </li></ol><br>  Voltemos ao esquema de entrega do Kubernetes descrito acima: ele foi inventado n√£o apenas por n√≥s, mas literalmente por todos que lidaram com esse problema.  Em ess√™ncia, esse padr√£o agora √© chamado GitOps <i>(mais sobre o termo e as id√©ias por tr√°s dele podem ser encontradas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> )</i> .  Vejamos as etapas do esquema. <br><br><h2>  Fase de Constru√ß√£o </h2><br>  Parece que em 2019 voc√™ pode falar sobre a montagem de imagens do Docker, quando todo mundo sabe escrever Dockerfiles e executar a <code>docker build</code> ? ... Aqui est√£o as nuances que eu gostaria de prestar aten√ß√£o: <br><br><ol><li>  <b>O peso da imagem √©</b> importante, portanto, use <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">v√°rios est√°gios</a> para deixar apenas o aplicativo realmente necess√°rio para a imagem. </li><li>  <b>O n√∫mero de camadas</b> deve ser minimizado combinando as cadeias de comandos <code>RUN</code> dentro do significado. </li><li>  No entanto, isso aumenta os problemas de <b>depura√ß√£o</b> , pois quando o assembly falha, voc√™ precisa encontrar o comando necess√°rio da cadeia que causou o problema. </li><li>  <b>A velocidade de cria√ß√£o √©</b> importante porque queremos implementar rapidamente as altera√ß√µes e observar o resultado.  Por exemplo, n√£o quero remontar as depend√™ncias nas bibliotecas de idiomas com cada compila√ß√£o de aplicativo. </li><li>  Muitas vezes, <b>muitas imagens</b> s√£o necess√°rias em um reposit√≥rio Git, que pode ser resolvido por um conjunto de Dockerfiles (ou est√°gios nomeados em um arquivo) e um script Bash com sua montagem sequencial. </li></ol><br>  Foi apenas a ponta do iceberg que todo mundo est√° enfrentando.  Mas existem outros problemas, e em particular: <br><br><ol><li>  Freq√ºentemente, no est√°gio de montagem, precisamos <b>montar</b> algo (por exemplo, armazenar em cache o resultado de um comando como o apt em um diret√≥rio de terceiros). </li><li>  Queremos <b>Ansible em</b> vez de escrever no shell. </li><li>  Queremos <b>construir sem o Docker</b> (por que precisamos de uma m√°quina virtual adicional na qual voc√™ precisa configurar tudo para isso quando j√° existe um cluster Kubernetes no qual voc√™ pode executar cont√™ineres?). </li><li>  <b>Montagem paralela</b> , que pode ser entendida de diferentes maneiras: comandos diferentes do Dockerfile (se forem usados ‚Äã‚Äãv√°rios est√°gios), v√°rios commits de um reposit√≥rio, v√°rios Dockerfiles. </li><li>  <b>Montagem distribu√≠da</b> : queremos coletar algo em vagens ‚Äúef√™meras‚Äù, porque  seu cache desaparece, o que significa que ele precisa ser armazenado em algum lugar separadamente. </li><li>  Por fim, chamei <b>o</b> pin√°culo dos desejos de auto- <b>magia</b> : seria ideal ir ao reposit√≥rio, digitar alguma equipe e obter uma imagem pronta, montada com uma compreens√£o de como e o que fazer corretamente.  No entanto, pessoalmente, n√£o tenho certeza de que todas as nuances possam ser previstas dessa maneira. </li></ol><br>  E aqui est√£o os projetos: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">moby / buildkit</a> - um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">construtor</a> da empresa Docker Inc (j√° integrada nas vers√µes atuais do Docker), que est√° tentando resolver todos esses problemas; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">kaniko</a> - um colecionador do Google, que permite construir sem o Docker; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Buildpacks.io</a> - uma tentativa do CNCF de executar automagia e, em particular, uma solu√ß√£o interessante com rebase para camadas; </li><li>  e um monte de outros utilit√°rios como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">buildah</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">genuinetools / img</a> ... </li></ul><br>  ... e veja quantas estrelas eles t√™m no GitHub.  Ou seja, por um lado, a <code>docker build</code> √© e pode fazer alguma coisa, mas, na realidade, o <b>problema n√£o foi completamente resolvido</b> - isso √© evidenciado pelo desenvolvimento paralelo de construtores alternativos, cada um dos quais resolve alguns dos problemas. <br><br><h2>  Construir em werf </h2><br>  Ent√£o chegamos ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">werf</a> <i>(anteriormente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">conhecido</a> como dapp)</i> - o utilit√°rio de c√≥digo aberto do Flant, o que estamos fazendo h√° muitos anos.  Tudo come√ßou h√° cerca de 5 anos com scripts Bash que otimizam a montagem de Dockerfiles e, nos √∫ltimos 3 anos, o desenvolvimento completo est√° em andamento no √¢mbito de um projeto com seu pr√≥prio reposit√≥rio Git <i>(primeiro no Ruby e depois <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reescrito</a> no Go, e ao mesmo tempo renomeado)</i> .  Quais problemas de compila√ß√£o s√£o resolvidos no werf? <br><br><img src="https://habrastorage.org/webt/--/1-/ca/--1-cakzswwfhrcrgnees6cvf-a.png"><br><br>  Os problemas sombreados em azul j√° foram implementados, a montagem paralela foi realizada no mesmo host e planejamos concluir as perguntas amarelas at√© o final do ver√£o. <br><br><h2>  Est√°gio de publica√ß√£o no registro (publica√ß√£o) </h2><br>  Digitamos o <code>docker push</code> ... - o que pode ser dif√≠cil no upload de uma imagem para o registro?  E ent√£o surge a pergunta: "Qual tag colocar a imagem?"  Surge pela raz√£o de termos o <b>Gitflow</b> (ou outra estrat√©gia do Git) e o Kubernetes, e o setor est√° comprometido em garantir que o que est√° acontecendo no Kubernetes siga o que est√° sendo feito no Git.  Git √© a nossa √∫nica fonte de verdade. <br><br>  O que √© t√£o complicado?  <b>Garanta a reprodutibilidade</b> : de uma confirma√ß√£o no Git, inerentemente <i>imut√°vel</i> , a uma imagem do Docker que deve ser mantida igual. <br><br>  Tamb√©m √© importante <b>determinarmos a origem</b> , porque queremos entender a partir de qual commit o aplicativo iniciado no Kubernetes foi constru√≠do (ent√£o podemos fazer diferen√ßas e coisas semelhantes). <br><br><h3>  Estrat√©gias de marca√ß√£o </h3><br>  O primeiro √© uma <b>tag git</b> simples.  Temos um registro com uma imagem marcada como <code>1.0</code> .  Kubernetes tem palco e produ√ß√£o, onde esta imagem √© bombeada.  No Git, fazemos commits e, em algum momento, colocamos a tag <code>2.0</code> .  N√≥s o coletamos de acordo com as instru√ß√µes do reposit√≥rio e o colocamos no registro com a tag <code>2.0</code> .  N√≥s lan√ßamos no palco e, se estiver tudo bem, ent√£o na produ√ß√£o. <br><br><img src="https://habrastorage.org/webt/4f/ub/u4/4fubu4r-0obh9gkzs4_kftnlqxs.gif"><br><br>  O problema com essa abordagem √© que primeiro definimos a tag e s√≥ ent√£o a testamos e a implementamos.  Porque  Primeiro, isso √© simplesmente il√≥gico: fornecemos uma vers√£o do software que ainda n√£o testamos (n√£o podemos fazer o contr√°rio, porque, para verificar, voc√™ precisa colocar uma tag).  Em segundo lugar, esse caminho n√£o √© compat√≠vel com o Gitflow. <br><br>  A segunda op√ß√£o √© <b>git commit + tag</b> .  H√° uma tag <code>1.0</code> no ramo mestre;  para ele no registro - uma imagem implantada na produ√ß√£o.  Al√©m disso, o cluster Kubernetes possui loops de pr√©-visualiza√ß√£o e prepara√ß√£o.  Al√©m disso, seguimos o Gitflow: no ramo principal do desenvolvimento, <code>develop</code> novos recursos, como resultado do qual existe um commit com o identificador <code>#c1</code> .  N√≥s coletamos e publicamos no registro usando este identificador ( <code>#c1</code> ).  Lan√ßamos a visualiza√ß√£o com o mesmo identificador.  Fazemos o mesmo com os commits <code>#c2</code> e <code>#c3</code> . <br><br>  Quando percebemos que existem recursos suficientes, come√ßamos a estabilizar tudo.  No Git, crie a ramifica√ß√£o <code>release_1.1</code> (com base no <code>#c3</code> do <code>develop</code> ).  A coleta deste release n√£o √© necess√°ria, porque  Isso foi feito na etapa anterior.  Portanto, podemos apenas implement√°-lo na prepara√ß√£o.  Corrigimos bugs no <code>#c4</code> e <code>#c4</code> mesma forma na prepara√ß√£o.  Ao mesmo tempo, o desenvolvimento est√° em andamento no <code>develop</code> , onde as altera√ß√µes da <code>release_1.1</code> s√£o realizadas periodicamente.  Em algum momento, recebemos um commit e <code>#c25</code> para o commit tempor√°rio, com o qual estamos felizes ( <code>#c25</code> ). <br><br>  Em seguida, fazemos uma mesclagem (com avan√ßo r√°pido) da ramifica√ß√£o de lan√ßamento ( <code>release_1.1</code> ) no master.  Colocamos uma tag com a nova vers√£o ( <code>1.1</code> ) nesse commit.  Mas essa imagem j√° est√° montada no registro, portanto, para n√£o colet√°-la novamente, basta adicionar uma segunda tag √† imagem existente (agora ela possui as tags <code>#c25</code> e <code>1.1</code> no registro).  Depois disso, lan√ßamos para produ√ß√£o. <br><br>  Existe uma desvantagem de que uma imagem ( <code>#c25</code> ) √© <code>#c25</code> no preparo e outra ( <code>1.1</code> ) √© <code>#c25</code> na produ√ß√£o, mas sabemos que "fisicamente" √© a mesma imagem do registro. <br><br><img src="https://habrastorage.org/webt/mb/pq/iu/mbpqiumzomvrouhp8llx5aishza.gif"><br><br>  O real menos √© que n√£o h√° suporte para mesclar commit'ov, voc√™ precisa avan√ßar rapidamente. <br><br>  Voc√™ pode ir al√©m e executar o truque ... Considere um exemplo de um Dockerfile simples: <br><br><pre> <code class="plaintext hljs">FROM ruby:2.3 as assets RUN mkdir -p /app WORKDIR /app COPY . ./ RUN gem install bundler &amp;&amp; bundle install RUN bundle exec rake assets:precompile CMD bundle exec puma -C config/puma.rb FROM nginx:alpine COPY --from=assets /app/public /usr/share/nginx/www/public</code> </pre> <br>  N√≥s constru√≠mos um arquivo a partir dele de acordo com este princ√≠pio, que usamos: <br><br><ul><li>  SHA256 de identificadores de imagens usadas ( <code>ruby:2.3</code> e <code>nginx:alpine</code> ), que s√£o somas de verifica√ß√£o de seu conte√∫do; </li><li>  todas as equipes ( <code>RUN</code> , <code>CMD</code> , etc.); </li><li>  SHA256 dos arquivos que foram adicionados. </li></ul><br>  ... e pegue a soma de verifica√ß√£o (novamente SHA256) desse arquivo.  Essa √© a <b>assinatura de</b> tudo que define o conte√∫do de uma imagem do Docker. <br><br><img src="https://habrastorage.org/webt/zp/w2/ju/zpw2jup54xa66mit1bt9u7amwlk.gif"><br><br>  Vamos voltar ao esquema e, em <b>vez de confirma√ß√µes, usaremos essas assinaturas</b> , ou seja,  marque imagens com assinaturas. <br><br><img src="https://habrastorage.org/webt/pr/d3/wf/prd3wfn6ctkod9ddqqmgtqnr1ew.gif"><br><br>  Agora, quando voc√™ precisar, por exemplo, mesclar altera√ß√µes da vers√£o para master, podemos fazer uma consolida√ß√£o de mesclagem real: ela ter√° um identificador diferente, mas a mesma assinatura.  Com o mesmo identificador, apresentaremos a imagem na produ√ß√£o tamb√©m. <br><br>  A desvantagem √© que agora n√£o ser√° poss√≠vel determinar que tipo de confirma√ß√£o foi bombeada para a produ√ß√£o - as somas de verifica√ß√£o funcionam apenas em uma dire√ß√£o.  Esse problema √© resolvido por uma camada adicional com metadados - vou contar mais adiante. <br><br><h3>  Marcando em werf </h3><br>  No werf, fomos ainda mais longe e estamos nos preparando para fazer uma montagem distribu√≠da com um cache que n√£o √© armazenado na mesma m√°quina ... Portanto, temos dois tipos de imagens do Docker, que chamamos de <i>est√°gio</i> e <i>imagem</i> . <br><br>  O reposit√≥rio werf Git armazena instru√ß√µes de constru√ß√£o espec√≠ficas que descrevem os diferentes est√°gios da constru√ß√£o ( <i>beforeInstall</i> , <i>install</i> , <i>beforeSetup</i> , <i>setup</i> ).  Coletamos a imagem do primeiro est√°gio com uma assinatura definida como a soma de verifica√ß√£o das primeiras etapas.  Em seguida, adicionamos o c√≥digo fonte; para a nova imagem de palco, consideramos sua soma de verifica√ß√£o ... Essas opera√ß√µes s√£o repetidas para todos os est√°gios, como resultado, obtemos um conjunto de imagens de palco.  Em seguida, fazemos a imagem-imagem final contendo tamb√©m metadados sobre sua origem.  E identificamos essa imagem de maneiras diferentes (detalhes mais adiante). <br><br><img src="https://habrastorage.org/webt/4a/uw/am/4auwamdra7bm0xtvht35kpbstye.gif"><br><br>  Deixe depois que um novo commit apare√ßa, no qual apenas o c√≥digo do aplicativo seja alterado.  O que vai acontecer?  Um patch ser√° criado para altera√ß√µes de c√≥digo, uma nova imagem de est√°gio ser√° preparada.  Sua assinatura ser√° definida como a soma de verifica√ß√£o da imagem do est√°gio antigo e do novo patch.  A partir desta imagem, uma nova imagem-imagem final ser√° formada.  Comportamento semelhante ocorrer√° com altera√ß√µes em outros est√°gios. <br><br>  Assim, as imagens de palco s√£o um cache que pode ser distribu√≠do distribu√≠do e as imagens de imagem j√° criadas a partir dele s√£o carregadas no Docker Registry. <br><br><img src="https://habrastorage.org/webt/sc/8j/me/sc8jme4f1jfqbrbwt1anf2-rja8.gif"><br><br><h3>  Limpeza do registro </h3><br>  N√£o se trata de excluir camadas que permanecem suspensas ap√≥s as tags exclu√≠das - esse √© um recurso padr√£o do pr√≥prio Docker Registry.  √â uma situa√ß√£o em que muitas tags do Docker est√£o se acumulando e entendemos que n√£o precisamos mais de algumas delas, e elas ocupam espa√ßo (e / ou pagamos por isso). <br><br>  Quais s√£o as estrat√©gias de limpeza? <br><br><ol><li>  Voc√™ simplesmente <b>n√£o</b> pode <b>limpar</b> nada.  √Äs vezes, √© muito mais f√°cil pagar um pouco pelo espa√ßo extra do que desvendar uma enorme bola de tags.  Mas isso s√≥ funciona at√© um certo ponto. </li><li>  <b>Reset completo</b> .  Se voc√™ excluir todas as imagens e reconstruir apenas as relevantes no sistema de IC, poder√° ocorrer um problema.  Se o cont√™iner reiniciar na produ√ß√£o, uma nova imagem ser√° carregada para ele - uma que ainda n√£o foi testada por ningu√©m.  Isso mata a ideia de infraestrutura imut√°vel. </li><li>  <b>Azul esverdeado</b> .  Um registro come√ßou a transbordar - carregando imagens em outro.  O mesmo problema do m√©todo anterior: em que momento voc√™ pode limpar o registro que come√ßou a transbordar? </li><li>  <b>Pelo tempo</b> .  Excluir todas as imagens com mais de 1 m√™s?  Mas com certeza existe um servi√ßo que n√£o foi atualizado por um m√™s ... </li><li>  Determine <b>manualmente o</b> que j√° pode ser exclu√≠do. </li></ol><br>  Existem duas op√ß√µes realmente vi√°veis: n√£o limpe ou uma combina√ß√£o de azul esverdeado + manualmente.  No √∫ltimo caso, estamos falando do seguinte: quando entender que √© hora de limpar o registro, crie um novo e adicione todas as novas imagens por, por exemplo, um m√™s.  Um m√™s depois, veja quais pods no Kubernetes ainda est√£o usando o registro antigo e transfira-os para o novo registro tamb√©m. <br><br>  <b>Para onde</b> fomos a <b>werf</b> ?  N√≥s coletamos: <br><br><ol><li>  Git head: todas as tags, todas as ramifica√ß√µes, - assumindo que tudo o que √© testado no Git, precisamos nas imagens (e, se n√£o, precisamos excluir no pr√≥prio Git); </li><li>  todos os pods que agora s√£o baixados no Kubernetes; </li><li>  ReplicaSets antigos (algo que foi lan√ßado recentemente), bem como planejamos digitalizar vers√µes do Helm e selecionar as imagens mais recentes l√°. </li></ol><br>  ... e criamos uma lista de permiss√µes deste conjunto - uma lista de imagens que n√£o excluiremos.  Limpamos tudo o resto, ap√≥s o que encontramos as imagens de palco √≥rf√£s e as exclu√≠mos tamb√©m. <br><br><h2>  Est√°gio de implanta√ß√£o (implanta√ß√£o) </h2><br><h3>  Declaratividade robusta </h3><br>  O primeiro ponto que eu gostaria de chamar a aten√ß√£o na implanta√ß√£o √© implementar a configura√ß√£o de recursos atualizada, declarada declarativamente.  O documento YAML original que descreve os recursos do Kubernetes √© sempre muito diferente do resultado que realmente funciona no cluster.  Como o Kubernetes adiciona √† configura√ß√£o: <br><br><ol><li>  identificadores </li><li>  informa√ß√µes de servi√ßo; </li><li>  muitos valores padr√£o; </li><li>  se√ß√£o com status atual; </li><li>  altera√ß√µes feitas como parte do webhook de admiss√£o; </li><li>  o resultado do trabalho de v√°rios controladores (e agendador). </li></ol><br>  Portanto, quando uma nova configura√ß√£o de um recurso ( <i>novo</i> ) aparece, n√£o podemos simplesmente pegar e substituir com ele a atual configura√ß√£o "ativa" ( <i>ativa</i> ).  Para fazer isso, precisamos comparar a <i>nova</i> configura√ß√£o com a √∫ltima aplicada ( <i>√∫ltima aplica√ß√£o</i> ) e lan√ßar o patch resultante no <i>live</i> . <br><br>  Essa abordagem √© chamada <b>mesclagem bidirecional</b> .  √â usado, por exemplo, no Helm. <br><br>  H√° tamb√©m uma <b>mesclagem de tr√™s vias</b> , que difere em que: <br><br><ul><li>  comparando o <i>√∫ltimo aplicado</i> e o <i>novo</i> , examinamos o que foi removido; </li><li>  comparando <i>novo</i> e <i>ao vivo</i> , vemos o que foi adicionado ou alterado; </li><li>  aplique o patch resumido para <i>viver</i> . </li></ul><br>  Implementamos mais de 1000 aplicativos com o Helm, portanto, vivemos com uma mesclagem bidirecional.  No entanto, ele tem v√°rios problemas que resolvemos com nossos patches que ajudam o Helm a funcionar normalmente. <br><br><h3>  Status real de lan√ßamento </h3><br>  Ap√≥s o pr√≥ximo evento, nosso sistema de IC gerou uma nova configura√ß√£o para o Kubernetes, passando-a para <i>aplicar</i> ao cluster usando Helm ou <code>kubectl apply</code> .  Em seguida, ocorre a mesclagem N-way j√° descrita, para a qual a API do Kubernetes aprova o sistema de IC e o √∫ltimo responde ao usu√°rio. <br><br><img src="https://habrastorage.org/webt/sk/vh/-u/skvh-uifcwg6_d5mgxhehh39q9i.png"><br><br>  No entanto, h√° um enorme problema: afinal, um <b>aplicativo bem</b> - <b>sucedido n√£o significa uma implementa√ß√£o bem-sucedida</b> .  Se o Kubernetes entende quais altera√ß√µes aplicar, aplica-as - ainda n√£o sabemos qual ser√° o resultado.  Por exemplo, a atualiza√ß√£o e a reinicializa√ß√£o de pods no front-end podem ser bem-sucedidas, mas n√£o no back-end, e obteremos vers√µes diferentes das imagens do aplicativo em execu√ß√£o. <br><br>  Para fazer tudo certo, surge um link adicional nesse esquema - um rastreador especial que receber√° informa√ß√µes de status da API do Kubernetes e as transmitir√° para uma an√°lise mais aprofundada do estado real das coisas.  Criamos uma biblioteca de c√≥digo aberto no Go - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><b>kubedog</b></a> <i>(veja seu an√∫ncio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> )</i> - que resolve esse problema e √© incorporado ao werf. <br><br>  O comportamento desse rastreador no n√≠vel werf √© configurado usando anota√ß√µes colocadas em Deployments ou StatefulSets.  A anota√ß√£o principal, <code>fail-mode</code> , compreende os seguintes significados: <br><br><ul><li>  <code>IgnoreAndContinueDeployProcess</code> - ignore os problemas de <code>IgnoreAndContinueDeployProcess</code> deste componente e continue a implanta√ß√£o; </li><li>  <code>FailWholeDeployProcessImmediately</code> - um erro neste componente interrompe o processo de implanta√ß√£o; </li><li>  <code>HopeUntilEndOfDeployProcess</code> - esperamos que este componente funcione at√© o final da implanta√ß√£o. </li></ul><br>  Por exemplo, uma combina√ß√£o de recursos e valores de anota√ß√£o no <code>fail-mode</code> : <br><br><img src="https://habrastorage.org/webt/ja/qf/ot/jaqfotxaxoxwznieu2lvnnyhih0.png"><br><br>  Ao implantar pela primeira vez, o banco de dados (MongoDB) ainda n√£o est√° pronto - as implanta√ß√µes falham.  Mas voc√™ pode esperar at√© o momento em que iniciar e a implanta√ß√£o ainda passar√°. <br><br>  Existem mais duas anota√ß√µes para o kubedog no werf: <br><br><ul><li>  <code>failures-allowed-per-replica</code> - o n√∫mero de quedas permitidas por r√©plica; </li><li>  <code>show-logs-until</code> - ajusta o momento at√© o qual o werf mostra (no stdout) logs de todos os pods que est√£o sendo lan√ßados.  Por padr√£o, √© <code>PodIsReady</code> (para ignorar as mensagens que mal precisamos quando o tr√°fego come√ßa a chegar no pod), no entanto, os valores <code>ControllerIsReady</code> e <code>EndOfDeploy</code> tamb√©m <code>EndOfDeploy</code> . </li></ul><br><h3>  O que mais queremos da implanta√ß√£o? </h3><br>  Al√©m dos dois pontos j√° descritos, gostar√≠amos de: <br><br><ul><li>  ver <b>logs</b> - e apenas necess√°rio, mas n√£o tudo; </li><li>  acompanhar o <b>progresso</b> , porque se um trabalho "silenciosamente" travar por v√°rios minutos, √© importante entender o que est√° acontecendo l√°; </li><li>  ter uma <b>revers√£o autom√°tica</b> caso algo d√™ errado (e, portanto, √© fundamental saber o status real da implanta√ß√£o).  A distribui√ß√£o deve ser at√¥mica: ou vai at√© o fim ou tudo volta ao seu estado anterior. </li></ul><br><h2>  Sum√°rio </h2><br>  Como empresa, para n√≥s, implementar todas as nuances descritas em diferentes est√°gios de entrega (compila√ß√£o, publica√ß√£o, implanta√ß√£o), o sistema de CI e o utilit√°rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">werf</a> s√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">suficientes</a> . <br><br>  Em vez de uma conclus√£o: <br><br><img src="https://habrastorage.org/webt/ja/1y/tc/ja1ytcqobpkbw5rtf78ykb4clnm.png"><br><br>  Com a ajuda do werf, fizemos um bom progresso na solu√ß√£o de um grande n√∫mero de problemas dos engenheiros do DevOps e ficaremos felizes se a comunidade em geral, pelo menos, tentar esse utilit√°rio na pr√°tica.  Conseguir um bom resultado juntos ser√° mais f√°cil. <br><br><h2>  V√≠deos e slides </h2><br>  V√≠deo da apresenta√ß√£o (~ 47 minutos): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/cK3ackGUTLw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Apresenta√ß√£o do relat√≥rio: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  PS </h2><br>  Outros relat√≥rios do Kubernetes em nosso blog: <br><br><ul><li>  ‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Escalonamento autom√°tico e gerenciamento de recursos em Kubernetes</a> ‚Äù <i>(Dmitry Stolyarov; 27 de abril de 2019 no ‚ÄúStrike‚Äù)</i> ; </li><li>  ‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Expandindo e complementando o Kubernetes</a> ‚Äù <i>(Andrey Polov; 8 de abril de 2019 em Saint HighLoad ++)</i> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bancos de dados e Kubernetes</a> " <i>(Dmitry Stolyarov; 8 de novembro de 2018 no HighLoad ++)</i> ; </li><li>  ‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Monitoring and Kubernetes</a> ‚Äù <i>(Dmitry Stolyarov; 28 de maio de 2018 na RootConf)</i> ; </li><li>  ‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Melhores pr√°ticas de CI / CD com Kubernetes e GitLab</a> ‚Äù <i>(Dmitry Stolyarov; 7 de novembro de 2017 em HighLoad ++)</i> ; </li><li>  ‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Nossa experi√™ncia com o Kubernetes em pequenos projetos</a> ‚Äù <i>(Dmitry Stolyarov; 6 de junho de 2017 na RootConf)</i> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt460351/">https://habr.com/ru/post/pt460351/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt460341/index.html">ASO cont√≠nuo: tend√™ncias, classifica√ß√µes e um pouco de feedback</a></li>
<li><a href="../pt460343/index.html">A hist√≥ria de como o desenvolvimento de jogos se tornou parte da minha vida</a></li>
<li><a href="../pt460345/index.html">Instale e configure o Sonata Admin no Symfony 4</a></li>
<li><a href="../pt460347/index.html">Gerenciamento de dispositivos m√≥veis e muito mais com a solu√ß√£o UEM da Sophos</a></li>
<li><a href="../pt460349/index.html">Cart√µes de Acelera√ß√£o de Falcon de Check Point - Acelerando o Processamento de Tr√°fego</a></li>
<li><a href="../pt460353/index.html">Rede neural no vidro. N√£o requer energia, reconhece n√∫meros</a></li>
<li><a href="../pt460355/index.html">Salvar o afogamento √© o nosso neg√≥cio: como lidar com a desmotiva√ß√£o da equipe</a></li>
<li><a href="../pt460359/index.html">Young Game Designer 2 Course: Balanceando Progress√£o e Din√¢mica sem Matem√°tica</a></li>
<li><a href="../pt460361/index.html">√ìtimas perguntas frequentes sobre seguran√ßa cibern√©tica de sistemas de informa√ß√µes m√©dicas</a></li>
<li><a href="../pt460363/index.html">7 fatores ausentes na abordagem 12 Factor App</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>