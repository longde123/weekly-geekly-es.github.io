<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚑 🤔 👨‍👨‍👧‍👧 Regeln für die Arbeit mit dynamischen Arrays und benutzerdefinierten Auflistungsklassen 🧔🏿 🛌🏽 🤕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Regeln für die Arbeit mit dynamischen Arrays und benutzerdefinierten Auflistungsklassen 
 Hier sind die Regeln, die ich beim Arbeiten mit dynamischen ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Regeln für die Arbeit mit dynamischen Arrays und benutzerdefinierten Auflistungsklassen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/484336/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/qy/hx/3d/qyhx3dbaepmsxkx2azb_tmi9dee.jpeg"></div><br><br>  Regeln für die Arbeit mit dynamischen Arrays und benutzerdefinierten Auflistungsklassen <br>  Hier sind die Regeln, die ich beim Arbeiten mit dynamischen Arrays befolge.  Tatsächlich ist dies eine Anleitung zum Entwerfen von Arrays, aber ich wollte sie nicht in eine Anleitung zum Entwerfen von Objekten aufnehmen, da nicht jede objektorientierte Sprache dynamische Arrays hat.  Die Beispiele sind in PHP geschrieben, da sie Java ähneln (mit dem Sie möglicherweise bereits vertraut sind), aber mit dynamischen Arrays anstelle der integrierten Auflistungsklassen und -schnittstellen. <br><a name="habracut"></a><br><h2>  Verwenden von Arrays als Liste </h2><br><h4>  Alle Artikel müssen vom selben Typ sein. </h4><br>  Wenn Sie ein Array als Liste verwenden (eine Sammlung von Werten in einer bestimmten Reihenfolge), müssen alle Werte vom gleichen Typ sein: <br><br><pre><code class="php hljs">$goodList = [ <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span> ]; $badList = [ <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> ];</code> </pre> <br>  Der gebräuchliche Annotationsstil für <code>@var array&lt;TypeOfElment&gt;</code> lautet: <code>@var array&lt;TypeOfElment&gt;</code> .  Stellen Sie sicher, dass Sie keinen Indextyp hinzufügen, er sollte immer <code>int</code> . <br><br><h4>  Der Index jedes Elements muss ignoriert werden </h4><br>  PHP erstellt automatisch einen neuen Index für jedes Listenelement (0, 1, 2 usw.).  Sie sollten sich jedoch weder auf diese Indizes verlassen noch sie direkt verwenden.  Kunden können sich nur auf <code>iterable</code> und <code>countable</code> . <br><br>  So können Sie <code>foreach</code> und <code>count()</code> frei verwenden, aber nicht, um Listenelemente zu durchlaufen: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// Good loop: foreach ($list as $element) { } // Bad loop (exposes the index of each element): foreach ($list as $index =&gt; $element) { } // Also bad loop (the index of each element should not be used): for ($i = 0; $i &lt; count($list); $i++) { }</span></span></code> </pre> <br>  In PHP funktioniert die <code>for</code> Schleife möglicherweise überhaupt nicht, wenn die Liste keine Indizes enthält oder wenn mehr Indizes als die Anzahl der Elemente vorhanden sind. <br><br><h4>  Verwenden Sie einen Filter, anstatt Elemente zu löschen </h4><br>  Möglicherweise möchten Sie Elemente nach Index löschen ( <code>unset()</code> ), aber anstatt zu löschen, ist es besser, mit <code>array_filter()</code> eine neue Liste ohne unerwünschte Elemente zu erstellen. <br><br>  Auch hier sollte man sich nicht auf Elementindizes verlassen.  Verwenden <code>array_filter()</code> bei Verwendung von <code>array_filter()</code> nicht <a href="https://www.php.net/manual/en/function.array-filter.php">den Parameter flag</a> , um Elemente nach Index oder sogar nach Element und Index herauszufiltern. <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// Good filter: array_filter( $list, function (string $element): bool { return strlen($element) &gt; 2; } ); // Bad filter (uses the index to filter elements as well) array_filter( $list, function (int $index): bool { return $index &gt; 3; }, ARRAY_FILTER_USE_KEY ); // Bad filter (uses both the index and the element to filter elements) array_filter( $list, function (string $element, int $index): bool { return $index &gt; 3 || $element === 'Include'; }, ARRAY_FILTER_USE_BOTH );</span></span></code> </pre><br><h2>  Verwenden von Arrays als assoziative Arrays </h2><br>  Wenn die Schlüssel relevant sind und keine Indizes (0, 1, 2 usw.), verwenden Sie frei assoziative Arrays (eine Auflistung, aus der Sie Werte anhand ihrer eindeutigen Schlüssel extrahieren können). <br><br><h4>  Alle Schlüssel müssen vom selben Typ sein. </h4><br>  Die erste Regel für die Verwendung von assoziativen Arrays: Alle Schlüssel müssen vom gleichen Typ sein (meistens handelt es sich um <code>string</code> ). <br><br><pre> <code class="php hljs">$goodMap = [ <span class="hljs-string"><span class="hljs-string">'foo'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'baz'</span></span> ]; <span class="hljs-comment"><span class="hljs-comment">// Bad (uses different types of keys) $badMap = [ 'foo' =&gt; 'bar', 1 =&gt; 'baz' ];</span></span></code> </pre><br><h3>  Alle Werte müssen vom selben Typ sein. </h3><br>  Gleiches gilt für Werte: Sie müssen vom gleichen Typ sein. <br><br><pre> <code class="php hljs">$goodMap = [ <span class="hljs-string"><span class="hljs-string">'foo'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'baz'</span></span> ]; <span class="hljs-comment"><span class="hljs-comment">// Bad (uses different types of values) $badMap = [ 'foo' =&gt; 'bar', 'bar' =&gt; 1 ];</span></span></code> </pre> <br>  Ein gebräuchlicher Stil zum Kommentieren eines Typs ist: <code>@var array&lt;TypeOfKy, TypeOfValue&gt;</code> . <br><br><h4>  Assoziative Arrays müssen privat bleiben </h4><br>  Listen können aufgrund der Einfachheit ihrer Eigenschaften sicher von Objekt zu Objekt übertragen werden.  Jeder Client kann Elemente durchlaufen oder zählen, auch wenn die Liste leer ist.  Es ist schwieriger, mit Map zu arbeiten, da Clients sich auf Schlüssel verlassen können, die keinem Wert entsprechen.  Dies bedeutet, dass assoziative Arrays in Bezug auf die Objekte, die sie verwalten, normalerweise privat bleiben sollten.  Anstatt Clients den direkten Zugriff auf interne Zuordnungen zu ermöglichen, können Getter (und möglicherweise Setter) Werte abrufen.  Ausnahmen auslösen, wenn für den angeforderten Schlüssel kein Wert vorhanden ist.  Wenn Sie jedoch die Karte und ihre Werte vollständig geheim halten können, tun Sie dies. <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// Exposing a list is fine /** * @return array&lt;User&gt; */ public function allUsers(): array { // ... } // Exposing a map may be troublesome /** * @return array&lt;string, User&gt; */ public function usersById(): array { // ... } // Instead, offer a method to retrieve a value by its key /** * @throws UserNotFound */ public function userById(string $id): User { // ... }</span></span></code> </pre><br><h2>  Verwenden Sie Objekte als assoziative Arrays mit Werten verschiedener Typen </h2><br>  Wenn Sie ein assoziatives Array verwenden möchten, aber Werte unterschiedlichen Typs darin speichern möchten, verwenden Sie Objekte.  Definieren Sie eine Klasse, fügen Sie öffentliche Typeneigenschaften hinzu oder fügen Sie einen Konstruktor und Getter hinzu.  Solche Objekte umfassen Konfigurations- oder Befehlsobjekte: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SillyRegisterUserCommand</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> string $username; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> string $plainTextPassword; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool $wantsToReceiveSpam; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> int $answerToIAmNotARobotQuestion; }</code> </pre><br><h4>  Ausnahmen von der Regel </h4><br>  Bibliotheken und Frameworks erfordern manchmal eine dynamischere Verwendung von Arrays.  Dann ist es unmöglich (und unerwünscht), die vorherigen Regeln zu befolgen.  Beispiele sind das <a href="https://matthiasnoback.nl/2018/03/ormless-a-memento-like-pattern-for-object-persistence/">Array von Daten</a> , die in einer Datenbanktabelle gespeichert sind, und <a href="https://symfony.com/doc/current/forms.html">die Formularkonfiguration</a> in Symfony. <br><br><h2>  Benutzerdefinierte Sammlungsklassen </h2><br>  Benutzerdefinierte Auflistungsklassen können ein großartiges Werkzeug für die Arbeit mit <code>Iterator</code> , <code>ArrayAccess</code> und anderen Entitäten sein, aber ich finde, dass der Code oft verwirrend wird.  Wer sich zum ersten Mal mit Code befasst, muss das PHP-Handbuch konsultieren, auch wenn er ein erfahrener Entwickler ist.  Außerdem müssen Sie mehr Code schreiben, um zu warten (testen, debuggen usw.).  In den meisten Fällen ist ein einfaches Array mit den richtigen Typanmerkungen ausreichend. <br><br>  Was bedeutet, dass Sie das Array in ein benutzerdefiniertes Auflistungsobjekt einschließen müssen? <br><br><ul><li>  Vervielfältigung der Logik in Bezug auf ein Array. <br></li><li>  Clients müssen mit zu vielen Details über den Inhalt des Arrays arbeiten. <br></li></ul><br><h4>  Verwenden Sie eine benutzerdefinierte Auflistungsklasse, um doppelte Logik zu verhindern. </h4><br>  Wenn mehrere Clients, die mit demselben Array arbeiten, dieselbe Aufgabe ausführen (z. B. Filtern, Vergleichen, Reduzieren, Zählen), können Duplikate mithilfe der benutzerdefinierten Auflistungsklasse entfernt werden.  Durch die Übertragung doppelter Logik in eine Sammlungsklassenmethode kann jeder Client dieselbe Aufgabe ausführen, indem er einfach die Sammlungsmethode aufruft: <br><br><pre> <code class="php hljs">$names = [<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// Found in several places: $shortNames = array_filter( $names, function (string $element): bool { return strlen($element) &lt; 5; } ); // Turned into a custom collection class: use Assert\Assert; final class Names { /** * @var array&lt;string&gt; */ private array $names; public function __construct(array $names) { Assert::that()-&gt;allIsString($names); $this-&gt;names = $names; } public function shortNames(): self { return new self( array_filter( $this-&gt;names, function (string $element): bool { return strlen($element) &lt; 5; } ) ); } } $names = new Names([/* ... */]); $shortNames = $names-&gt;shortNames();</span></span></code> </pre> <br>  Der Vorteil der Transformation einer Auflistung mithilfe einer Methode besteht darin, dass diese Transformation benannt wird.  Sie können einen kurzen und informativen Namen für den Aufruf von <code>array_filter()</code> , der sonst ziemlich schwer zu finden wäre. <br><br><h4>  Binden Sie Kunden mit einer benutzerdefinierten Auflistungsklasse auf </h4><br>  Wenn ein Client ein Array durchläuft, einen Teil der Daten aus den ausgewählten Elementen entnimmt und etwas damit unternimmt, wird dieser Client eng mit allen entsprechenden Typen verknüpft: Array, Elemente, abgerufene Werte, Auswahlmethode usw. dass es aufgrund einer solch tiefen Bindung für Sie viel schwieriger sein wird, irgendetwas in Bezug auf diese Typen zu ändern, ohne den Client zu beschädigen.  In diesem Fall können Sie das Array auch in eine benutzerdefinierte Auflistungsklasse einschließen und die richtige Antwort geben, die erforderlichen Berechnungen im Array ausführen und die Bindung des Clients an die Auflistung lösen. <br><br><pre> <code class="php hljs">$lines = []; $sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($lines <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $line) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($line-&gt;isComment()) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } $sum += $line-&gt;quantity(); } <span class="hljs-comment"><span class="hljs-comment">// Turned into a custom collection class: final class Lines { public function totalQuantity(): int { $sum = 0; foreach ($lines as $line) { if ($line-&gt;isComment()) { continue; } $sum += $line-&gt;quantity(); } return $sum; } }</span></span></code> </pre><br><h2>  Einige Regeln für benutzerdefinierte Auflistungsklassen </h2><br><h4>  Mach sie unveränderlich </h4><br>  Bei der Durchführung solcher Transformationen sollten die vorhandenen Verweise auf die Auflistungsinstanz nicht betroffen sein.  Daher sollte jede Methode, die diese Konvertierung ausführt, eine neue Instanz der Klasse zurückgeben, wie wir im vorherigen Beispiel gesehen haben: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Names</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array&lt;string&gt; */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> $names; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $names)</span></span></span><span class="hljs-function"> </span></span>{ Assert::that()-&gt;allIsString($names); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;names = $names; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shortNames</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">self</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>( <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> ); } }</code> </pre> <br>  Wenn Sie ein internes Array konvertieren, können Sie natürlich in einen anderen Auflistungstyp oder ein einfaches Array konvertieren.  Stellen Sie wie gewohnt sicher, dass der richtige Typ zurückgegeben wird. <br><br><h4>  Stellen Sie nur das Verhalten zur Verfügung, das Kunden wirklich benötigen </h4><br>  Anstatt eine Klasse aus einer Bibliothek mit einer universellen Sammlung zu erweitern oder einen universellen Filter oder eine universelle Zuordnung zu implementieren und für jede benutzerdefinierte Sammlungsklasse zu reduzieren, implementieren Sie nur das, was Sie wirklich benötigen.  Wenn Sie die Methode irgendwann nicht mehr verwenden, löschen Sie sie. <br><br><h4>  Verwenden Sie IteratorAggregate und ArrayIterator zum Iterieren </h4><br>  Wenn Sie mit PHP arbeiten, implementieren Sie anstelle aller Methoden der <code>Iterator</code> Schnittstelle (Speichern interner Zeiger usw.) nur die <code>IteratorAggregate</code> Schnittstelle und lassen Sie sie eine <code>ArrayIterator</code> Instanz basierend auf dem internen Array zurückgeben: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Names</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IteratorAggregate</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array&lt;string&gt; */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> $names; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $names)</span></span></span><span class="hljs-function"> </span></span>{ Assert::that()-&gt;allIsString($names); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;names = $names; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterator</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayIterator(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;names); } } $names = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Names([<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($names <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name) { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br><h4>  Kompromiss </h4><br>  Da Sie mehr Code für eine benutzerdefinierte Auflistungsklasse schreiben, sollte es für Clients einfacher sein, mit dieser Auflistung (und nicht nur mit einem Array) zu arbeiten.  Wenn der Clientcode klarer wird und die Auflistung nützliches Verhalten bietet, ist der zusätzliche Aufwand für die Verwaltung einer benutzerdefinierten Auflistungsklasse gerechtfertigt.  Da die Arbeit mit dynamischen Arrays jedoch so einfach ist (hauptsächlich, weil Sie die verwendeten Typen nicht angeben müssen), verwende ich meine Auflistungsklassen selten.  Einige Entwickler setzen sie jedoch aktiv ein, sodass ich auf jeden Fall weiter nach möglichen Anwendungsfällen suchen werde. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484336/">https://habr.com/ru/post/de484336/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484320/index.html">Erstellen eines Microservices für Quarkus, Kotlin und Gradle</a></li>
<li><a href="../de484326/index.html">Springe nach London oder mein Praktikum bei Jump Trading</a></li>
<li><a href="../de484328/index.html">Paul Graham kündigt neue Bel-Programmiersprache an</a></li>
<li><a href="../de484330/index.html">[Nginx] So schlagen Sie response_status = 0</a></li>
<li><a href="../de484332/index.html">Fokus auf Aufgabenverwaltung. Wie wir unser Managementsystem machen</a></li>
<li><a href="../de484338/index.html">Samsungs Neon-Projekt: Digital Bankers, Fernsehmoderatoren, Companions</a></li>
<li><a href="../de484340/index.html">Java Digest für den 17. Januar. Die ersten zwei Wochen des neuen Jahres</a></li>
<li><a href="../de484342/index.html">Toolkit basierend auf Eclipse und GTK + für “Toradex Colibri T20 (Linux)”</a></li>
<li><a href="../de484344/index.html">Drei Ebenen der automatischen Skalierung in Kubernetes: wie man sie effektiv nutzt</a></li>
<li><a href="../de484356/index.html">Ein interessantes Projekt in einem freundlichen Team, oder wie viel kostet der richtige Mitarbeiter?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>