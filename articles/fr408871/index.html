<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛏️ 🍟 👛 Session de transmission vidéo du son à travers l'eau avec exposition 🌄 ✍🏼 🌁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="«Le Seigneur Tout-Puissant! Il semble que je viens de tuer M. May! ... Mais quoi qu'il en soit, nous continuons »(C) J. Clarkson 
 Dans cet article, j...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Session de transmission vidéo du son à travers l'eau avec exposition</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/408871/"><blockquote>  «Le Seigneur Tout-Puissant!  Il semble que je viens de tuer M. May! ... Mais quoi qu'il en soit, nous continuons »(C) J. Clarkson </blockquote><br>  Dans cet article, je vais vous dire comment transférer de la vidéo (enfin presque de la vidéo) en utilisant le son dans l'eau à l'aide d'un ordinateur portable ordinaire, d'un morceau de fil, de deux prises 3,5 mm et de deux tweeter piézo.  Je vais également expliquer pourquoi et comment cela fonctionne, raconter une histoire amusante sur la façon dont nous en sommes arrivés à cela.  Et comme cerise sur le gâteau, un article sur C # avec des codes sources est joint à l'article afin que tous ceux qui sont intéressés puissent l'essayer eux-mêmes, car les connaissances scientifiques sont vérifiables, n'est-ce pas? <br><a name="habracut"></a><br>  Si tout à coup le lecteur souhaite approfondir un peu les thèmes hydroacoustiques, je vous propose de vous familiariser avec nos publications précédentes, où nous parlons de nos projets d'une manière révélant les difficultés de transmission d'informations par l'eau: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GPS sous-marin à partir de zéro par an</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GPS sous-marin: suite</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Navigation sous l'eau: radiogoniométrie - ne pas radiogoniométrie, vous êtes voué au succès</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sur l'effet des cyanobactéries sur les fonctions vocales du président</a> <br><br>  En général, une vérité simple doit être apprise: la vidéo à travers l'eau à n'importe quelle distance significative (enfin, au moins des centaines de mètres) ne peut pas être transmise en utilisant l'acoustique.  Le point est la bande de fréquences disponible extrêmement étroite et la forte inégalité de l'atténuation des différentes fréquences avec la distance.  Les avantages sont le bruit, la propagation par trajets multiples, la réverbération, le changement de la vitesse du son dans le milieu par rapport à la densité (c.-à-d. La pression, la température et la salinité), l'effet Doppler, qui ne fonctionne d'ailleurs pas tout à fait comme dans les communications radio. <br><br>  Les limites de vitesse pour les modems sonar les plus avancés sont très loin de pouvoir transmettre de la vidéo.  Pour autant que je sache, le record appartient à EvoLogics et s'élève à 62,5 kbps avec une distance maximale déclarée de 300 mètres.  De plus, les mots sur l'impossibilité de transmettre le son vidéo à travers l'eau (à des distances raisonnables) appartiennent uniquement à Konstantin Georgievich, fondateur et directeur d'EvoLogics. <br><br>  Quand j'étais chercheur à l'Institut de recherche Hydrosvyaz, alors complètement inconscient, je voulais de grandes réalisations, des <s>victoires dans le nord et le sud, un grand ameublissement des sols</s> (non, je les veux toujours, mais alors je n'étais pas du tout accablé d'expérience et de connaissances et tout semblait presque magique et fabuleux).  Dans notre équipe de l'époque (dont une partie est la mienne), nous avons souvent fantasmé sur des projets de sonar irréalistes, fouillé dans une <s>décharge</s> et essayé d'utiliser toutes sortes d'artefacts d'une grande civilisation ancienne d'affilée, dont cet institut de recherche tente en partie de comprendre le tao de la communication sonar . <br><br>  L'immersion dans ces souvenirs évoque des sentiments contradictoires en moi.  Alors rien ne semblait et personne ne pouvait nous arrêter: nous avons mis hors service une fraiseuse chinoise du directeur du prototypage de produits, assemblé des corps normobares à partir de conduites d'eau néerlandaises Van De Lande, dont le fabricant a même écrit une lettre sur le sujet: «Avez-vous vérifié accidentellement vos tuyaux résistent-ils à la pression extérieure? "  Ils ont collecté des modèles de planche à pain pour leur propre argent dans des conteneurs de petit-déjeuner et se sont rendus secrètement au test pour les tester secrètement, collectant des forets à glace et des traîneaux pour des collègues et des parents, et ont même acheté un bateau chinois en PVC à Auchan.  Avec le recul, je sens à quel point mon cœur est rempli d'horreur, de nostalgie et d'appréhension. <br><br>  En toute honnêteté, il convient de noter que pendant tout ce temps, nous avons reçu un grand soutien de certains de nos dirigeants - en paroles et en actes, et en conséquence, tous nos métiers ont été légalisés en TOC (ce qui signifie travail de conception expérimentale et non trouble obsessionnel compulsif), qui était même présenté au salon naval international en 2013.  Oui, oui, nous avons conduit au salon nos conduites d'eau, peint <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">StDmitirev</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">notre</a> propre main en orange vif!  Les voici, dans des valises: <br><br><img src="https://habrastorage.org/webt/-7/jk/ii/-7jkii7tkq9yhpbwuvb1dw6ah2g.jpeg"><br><br>  Un jour, mon ami et collègue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">StDmitirev,</a> au milieu d'une conversation sur les spectres et les spectrogrammes, a prononcé la phrase suivante: <br><br><blockquote>  "Mais, ce serait amusant de faire un tel système: le sous-marin est assis dans le sous-marin et regarde le moniteur, sur lequel le spectrogramme se déplace en douceur, sur lequel les lettres et les chiffres sont écrits comme le doigt d' <s>un autre sous-marin</s> sur la fenêtre brumeuse d' <s>un autre sous-marin</s> ." <br></blockquote><br>  Tout le monde a ri, développé ce sujet, il semble que même le même jour, ils aient dessiné un smiley sur le spectrogramme et écouté comment ça sonne.  Je voulais vraiment apporter cela à un aspect pratique. <br><br>  Maintenant, c'est difficile à retenir (c'était en 2012).  J'avais un ordinateur en état de marche avec une webcam, divers artefacts-antennes et un "godet boosting" spécial (VG-1-P) avec de l'eau.  Ils l'ont appelé une étape parce que j'ai montré à tous ses patrons le travail de différents modèles d'équipement, ce qui a conduit à ma promotion en tant que chercheur senior. <br><br>  Je ne suis contraint par aucune obligation, la méthode elle-même est depuis longtemps publiée dans le domaine public et les résultats ont été rapportés à plusieurs reprises lors de conférences. <br><br>  Donc, je vous dis comment dans l'esprit - comment transmettre une vidéo à travers l'eau: <br><br><h3>  Comment générer un signal? </h3><br>  Nous nous souvenons que l'idée est basée sur le «dessin sur un spectrogramme», c'est-à-dire que l'image transmise est le spectrogramme du signal.  Pour convertir un signal du domaine temporel en domaine fréquentiel et vice versa, il est pratique d'utiliser (enfin, par exemple) la transformée de Fourier, ou plutôt, la transformée de Fourier rapide, par souci de concision, appelée FFT ou, plus communément, FFT (Fast Fourier Transform). <br><br>  Comme nous devons transformer une image (image vidéo) en un signal audio qui pourrait être émis par la carte son de n'importe quel ordinateur, nous utiliserons évidemment la transformation inverse, IFFT, pour la former.  Nous émettrons une image en colonnes, et un signal pour une colonne sera formé comme dans le diagramme suivant: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l4/wi/3t/l4wi3t5t4mk3vq5zo_-bmau-dne.png"></div><br>  = <br>  Supposons que la taille de la fenêtre FFT soit N et que nous ayons un tableau de taille N. Si nous le considérons comme le spectre du signal, alors son élément zéro correspond à la fréquence zéro (constante), et le compte avec l'indice N-1 correspond à la fréquence d'échantillonnage de la fréquence d'échantillonnage.  Il est nécessaire de choisir ces tailles de trame d'image et la taille de la fenêtre FFT de sorte que, d'une part, tout cela ressemble en quelque sorte à la vidéo (le transfert d'une trame prendrait un temps raisonnable), et d'autre part, la bande de fréquence utilisée était adéquate en principe et adaptée à l'équipement disponible. .  Maintenant, si nous entrons les valeurs de luminosité de la colonne de l'image (Colonne de cadre) à partir d'un décompte favori (de bas en haut dans le diagramme), puis effectuons la FFT inverse, la sortie recevra un signal codant une colonne de l'image.  Il nous reste maintenant à former les signaux de la même manière pour les colonnes restantes de l'image et à les émettre alternativement à l'aide d'une carte son. <br><br>  Il convient de noter que la FFT à la sortie donne un tableau de valeurs complexes, donc notre signal est la partie réelle.  Bien sûr, le signal résultant dans les colonnes est réduit à des entiers signés 16 bits (sous cette forme, un signal audio numérique est généralement stocké) et normalisé. <br><br>  En fait, au début de l'image, j'entre également quelques colonnes de luminosité maximale, plus tard du côté du récepteur, cela déterminera la réponse en fréquence du trajet de l'émetteur-récepteur (et du canal de transmission), qui, une fois inversée et légèrement lissée, nous aidera à améliorer la trame reçue. <br><br>  À mon avis, le moyen le plus simple de démontrer le dispositif de l'émetteur est avec un morceau de code, le voici (méthode Encode de la classe Encoder): <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Encode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Bitmap source</span></span></span><span class="hljs-function">)</span></span> { Bitmap frame; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (source.PixelFormat != System.Drawing.Imaging.PixelFormat.Format8bppIndexed) frame = Grayscale.CommonAlgorithms.RMY.Apply(source); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> frame = source; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!frame.Size.Equals(frameSize)) frame = resizer.Apply(frame); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] samples = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[fftSize * frameSize.Width]; alglib.complex[] slice = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> alglib.complex[fftSize]; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> maxSlice; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sampleIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> colsCount = frameSize.Width; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startRow = startLine; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endRow = startRow + frameSize.Height; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; colsCount; x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = startRow; y &lt; endRow; y++) slice[y].x = (frame.GetPixel(x, frameSize.Height - (y - startRow) - <span class="hljs-number"><span class="hljs-number">1</span></span>).R / <span class="hljs-number"><span class="hljs-number">255.0</span></span>) * <span class="hljs-keyword"><span class="hljs-keyword">short</span></span>.MaxValue; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; fftSize; y++) slice[y].x *= randomizerMask[y]; alglib.fftc1dinv(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> slice); maxSlice = <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>.MinValue; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; slice.Length; y++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(slice[y].x) &gt; maxSlice) maxSlice = Math.Abs(slice[y].x); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; slice.Length; i++) { samples[sampleIndex] = (<span class="hljs-keyword"><span class="hljs-keyword">short</span></span>)Math.Round(slice[i].x * <span class="hljs-keyword"><span class="hljs-keyword">short</span></span>.MaxValue / maxSlice); sampleIndex++; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> samples; }</code> </pre> <br>  Le code, naturellement, ne prétend rien et a été écrit à la hâte uniquement à des fins de démonstration. <br><br><h3>  Et la vitesse de transmission? </h3><br>  Et comment l'évaluer?  Nous avons réussi ( <s>du mal</s> pas du mal) à maintenir l'intrigue pendant environ deux mois, et certains de nos camarades et dirigeants supérieurs ont réussi à écrire un tas de papier pendant leur temps libre, se demandant comment une vitesse de transmission aussi folle pourrait se produire. <br><br>  Par exemple, si la fréquence d'échantillonnage est de 96 kHz et que nous prenons la taille de la fenêtre FFT à 512, nous enverrons 120 x 120 pixels (8 bits par pixel) à l'entrée de l'émetteur, alors le temps qu'il faut pour transmettre une trame d'image est: <br><br>  <i>120 * 512/96000 = 0,64 seconde</i> <br><br>  Le débit binaire devrait sembler être: <br><br>  <i>120x120 * 8 / 0,64 = 180 000 bits par seconde!</i> <br><br>  <s>Le fils du réalisateur était ravi à l'époque - oui, vous pouvez déjà utiliser les protocoles Internet!</s>  <s>C'est une percée!</s> <br><br>  Comme je vais le montrer ci-dessous, il est très facile de tomber dans une telle illusion.  Qu'est-ce qui ne va pas ici?  Après tout, tout est si simple et élégant! <br><br>  En fait, un tel calcul de vitesse n'est pas applicable à cette méthode, tout comme, par exemple, il ne s'applique pas à un signal de télévision analogique, combien y a-t-il de bits par pixel?  =) Et qu'en est-il du récepteur détecteur le plus simple?  =)) <br><br>  La méthode de transmission décrite est essentiellement <i>ANALOGIQUE</i> et les concepts de «bit» et de «pixel» ne lui sont pas applicables - dans la même image, théoriquement, vous ne pouvez pas prendre 8 bits par luminosité de pixel mais 16 et «vitesse» doublera automatiquement. <br><br>  Il est temps de montrer les tout premiers résultats de notre «percée»: <br><br><img src="https://habrastorage.org/webt/a5/ji/pv/a5jipvfgywxfxpy7p9jwl34v-ze.gif"><br><br>  La photo ci-dessus a été prise par nous à l'hiver 2012 sur la rivière Pichuga.  La distance de transmission était de 700 mètres.  Oui, hélas, mon cher lecteur, ce n'est pas du tout HD et ne tire même pas sur le CamRip le plus honteux.  Je ne me souviens pas déjà de qui, mais quelqu'un a très précisément remarqué que toutes nos «vidéos» sont comme envoyer des signaux d'aide d'une planète mourante. <br><br>  Ce qui est remarquable, avec un étirement, cela peut être décrit comme une sorte d'OFDM - les données sont transmises sur des sous-porteuses orthogonales, ce qui signifie une bonne résistance aux interférences tonales et autres interférences à bande étroite - dans ce cas, les "lignes" individuelles de l'image sont déformées.  Le bruit impulsionnel, au contraire, déforme une ou un groupe de colonnes.  Le "bandage" caractéristique des images est causé par ce que l'on appelle  évanouissement sélectif en fréquence dû à la propagation par trajets multiples, mais j'en parlerai une autre fois. <br><br><h3>  Comment est arrangé le récepteur? </h3><br>  Je dois réserver tout de suite que pour essayer cette méthode dans un seau ou même dans une petite piscine, des pièces de deux heures (rondes par exemple) avec un connecteur pour une carte son soudée seront suffisantes.  Pour l'émetteur, vous pouvez prendre un câble assez long (2-3-4-5 mètres) et non blindé, scellant l'élément piézoélectrique avec du vernis au zapon ou une petite couche de mastic - c'est certainement suffisant à plusieurs reprises.  L'antenne sonar résultante (pas, eh bien, quoi?) Est insérée dans la prise casque. <br><br>  La photo ci-dessous montre différentes pièces qui étaient à portée de main au moment de la rédaction.  Tous les éléments piézoélectriques illustrés sont tout à fait adaptés pour "essayer" et il y a généralement un magasin de radio dans n'importe quel <s>dépotoir</s> .  Pyatak n'a pas d'effet piézoélectrique et est présent sur l'image pour l'échelle. <br><br><img src="https://habrastorage.org/webt/5v/r6/xq/5vr6xqryjht0yd5tqz7sdvmbd3a.jpeg"><br><br>  Pour le récepteur, il est préférable de prendre un câble de microphone blindé avec le même connecteur et un piezo enduit de scellant ou de vernis à la fin.  Nous insérons cette antenne dans la prise microphone. <br><br>  Pour les expériences sur un étang, il est préférable de prendre une sorte d'anneau piézoélectrique comme émetteur et de l'alimenter amplifié (un amplificateur sur un TDA2030 avec un transformateur correctement enroulé durera plusieurs centaines de mètres dans un bon étang <s>ou 5 autres tours peuvent être</s> enroulés).  Pour le récepteur, dans ce cas, un préamplificateur et de préférence un filtre passe-bande sont également nécessaires.  Si les lecteurs sont intéressés à en savoir plus à ce sujet en détail, dites-le nous dans les commentaires et nous essaierons de faire un article sur la création d'amplificateurs de puissance, de préamplis et d'antennes pour la communication sonar. <br><br><h3>  Revenons donc au récepteur, plus précisément à sa partie logicielle </h3><br>  La chose la plus importante en communication est la synchronisation et la détermination de la présence d'un signal utile.  Dans notre exemple, la détection est effectuée par l'énergie dans la bande: les endroits où elle augmente fortement (début de la trame) et où elle chute fortement (la fin de la trame) sont déterminés, à condition que d'avant en bas il y ait au moins la durée de la trame. <br><br>  Pour toute sa simplicité, il fonctionne étonnamment bien. <br><br>  Les données de la carte son sont collectées par des échantillons FFTSize, la FFT est exécutée immédiatement sur elles et elles sont stockées sous forme de «tranches» séparées, en attendant le moment où elles seront traitées par la procédure de recherche, voici son code (méthode de recherche dans la classe Receiver): <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sliceIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> frameWidth = encoder.FrameSize.Width; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minSlicesToSearch = Convert.ToInt32((frameWidth + <span class="hljs-number"><span class="hljs-number">5</span></span>) * <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sliceSize = encoder.FFTSize; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> weight; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastRisePosition = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> prevRisePosition = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((slices.Count &gt; minSlicesToSearch) &amp;&amp; (sliceIndex &lt; slices.Count)) { weight = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; sliceSize; i++) weight += Math.Abs(slices[sliceIndex][i]); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> ratio = weight / previousWeight; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((ratio &gt;= risePeekRatio) &amp;&amp; (sliceIndex - prevRisePosition &gt; frameWidth)) { prevRisePosition = lastRisePosition; lastRisePosition = sliceIndex; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lastRisePosition + (frameWidth + <span class="hljs-number"><span class="hljs-number">5</span></span>) &lt; slices.Count) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] samples = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[frameWidth + <span class="hljs-number"><span class="hljs-number">5</span></span>][]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; frameWidth + <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { samples[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[sliceSize]; Array.Copy(slices[lastRisePosition + i], samples[i], sliceSize); } slices.RemoveRange(<span class="hljs-number"><span class="hljs-number">0</span></span>, sliceIndex); lastRisePosition = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FrameReceived != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) FrameReceived(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameReceivedEventArgs(encoder.DecodeEx(samples, <span class="hljs-number"><span class="hljs-number">5</span></span>))); lastRisePosition = sliceIndex; } } sliceIndex++; previousWeight = weight; } Interlocked.Decrement(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> isSearching); }</code> </pre> <br>  Et voici un morceau de code qui est responsable du décodage de l'image (Encoder.DecodeEx): <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Bitmap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Decode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] samples, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> measureCols</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> colCount = samples.Length / fftSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colCount == frameSize.Width + measureCols) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rowCount = frameSize.Height; Bitmap temp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bitmap(colCount, rowCount); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] slice = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[fftSize]; alglib.complex[] sliceC = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> alglib.complex[fftSize]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> samplesCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> component; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> decodeStart = startLine; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> decodeEnd = startLine + rowCount; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> maxSlice; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; colCount; x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; fftSize; y++) { slice[y] = samples[samplesCount]; samplesCount++; } alglib.fftr1d(slice, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> sliceC); maxSlice = <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>.MinValue; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = decodeStart; y &lt; decodeEnd; y++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (alglib.math.abscomplex(sliceC[y].x) &gt; maxSlice) maxSlice = alglib.math.abscomplex(sliceC[y].x); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = temp.Height + decodeStart - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = decodeStart; y &lt; decodeEnd; y++) { component = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(<span class="hljs-number"><span class="hljs-number">255.0</span></span> * alglib.math.abscomplex(sliceC[y].x) / maxSlice); temp.SetPixel(x, offset - y, Color.FromArgb(component, component, component)); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temp; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApplicationException(<span class="hljs-string"><span class="hljs-string">"Specified array length error"</span></span>); } }</code> </pre><br>  Et maintenant je propose de regarder les résultats d'expériences sur la transmission de "vidéo", menées à différents moments dans différents réservoirs. <br><br>  Les deux photos (ci-dessous) ont été enregistrées au salon naval international de Saint-Pétersbourg en 2013 sur notre (alors) stand à travers deux ordinateurs portables et un aquarium. <br><br>  Il n'est pas possible de distinguer ce qui est écrit sur le badge <br><br><img src="https://habrastorage.org/webt/xp/wx/sq/xpwxsqvxyyqwrzrjh0n5wr0tm-q.gif"><br><br><img src="https://habrastorage.org/webt/w7/9y/zb/w79yzbz7caic4fre7xftuh_tq00.gif"><br><br>  Et voici deux «vidéos» enregistrées par nous dans l'une des baies du lac Ladoga en Carélie, elles sont une sorte de record pour cette méthode (nous ne l'avons plus jamais essayée et il est peu probable qu'elle soit) - la première a été obtenue à une distance de 500 et la seconde à 1000 mètres : <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Transmission vidéo dans l'eau, distance 500 m (fichier 8.7 mb)</a> <br><br><img src="https://habrastorage.org/webt/ek/c_/sv/ekc_svi18z7oupqlmckhziofpy8.gif"><br><br>  Puisque la "vidéo" a été enregistrée en temps réel à l'aide d'une webcam, diverses choses étranges sont tombées dans le cadre.  Ce sera très intéressant si quelqu'un devine et écrit dans un commentaire ce qui est en arrière-plan dans la dernière «vidéo»). <br><br>  À l'appui du fait que la méthode a été publiée il y a longtemps - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">notre article</a> déjà pour 2013 <br><br>  J'ai utilisé la merveilleuse bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AForge</a> pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">capturer des images de webcam</a> . <br><br>  Le nombre complexe et les fonctions FFT sont utilisés à partir de l'excellente bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AlgLib</a> . <br><br>  Et, comme je l'ai promis, l'ensemble du projet en C # (VS2012) est attaché à l'article comme matériau pour le travail "à domicile".  Pour plus de commodité, le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">projet</a> et les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fichiers binaires sont</a> séparés. <br>  La démo offre la possibilité de changer (déplacer) la bande de fréquence occupée ainsi que la correction gamma de la trame de sortie (tout peut être changé en temps réel). <br><br><h3>  PS </h3><br>  Je n'ai pas choisi C # depuis longtemps et il est très difficile de trouver l'heure dans l'horaire de travail, donc je m'excuse à l'avance pour la confusion et la hâte du code. <br><br><h3>  PPS </h3><br>  Je n’attache pas un morceau de fil, deux prises et deux pièces à l’article - pas assez pour tout le monde. <br><br><h3>  Errata et annexe </h3><br>  - Dans certaines cartes son à l'entrée, il y a un filtre passe-bas qui coupe tragiquement tout ce qui dépasse ~ 15 kHz (pourquoi ???). <br><br>  - Par défaut, le projet de démonstration fonctionne avec une fréquence d'échantillonnage de 96 kHz, mais toutes les cartes son modernes ne le prennent pas en charge (pourquoi ???).  Si l'équipement ne peut pas 96 kHz, vous devez définir 48 kHz dans les paramètres, sinon, 44100 est certainement pris en charge partout, cependant, la durée de transmission d'une image sera d'autant plus longue. <br><br>  Voici une liste d'ordinateurs portables et de cartes son pouvant être considérés comme de jeunes équipements sonars: <br><br><ul><li>  Lenovo ideapad Y510P avec son JBL </li><li>  Asus n55s </li><li>  Asus K501U </li><li>  carte son externe Sound Blaster X-Fi Surround 5.1 (modèle n ° SB 1095) </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr408871/">https://habr.com/ru/post/fr408871/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr408857/index.html">Revue de presse d'Océ Technology</a></li>
<li><a href="../fr408859/index.html">KidPRO - L'histoire d'un écureuil aidant les enfants</a></li>
<li><a href="../fr408861/index.html">Une nouvelle bioprinter aide à traiter le diabète de type 1</a></li>
<li><a href="../fr408863/index.html">Numérisation 3D de voitures dans le réglage et la réparation</a></li>
<li><a href="../fr408865/index.html">Nous supprimons le russe de notre anglais</a></li>
<li><a href="../fr408873/index.html">Revue vidéo de la fraiseuse CNC 3Dtool AMAN</a></li>
<li><a href="../fr408875/index.html">Rouleau pour le dos</a></li>
<li><a href="../fr408879/index.html">Objectif fascinant de travailler beaucoup moins</a></li>
<li><a href="../fr408881/index.html">Mais que faire si nous vivons dans le futur et le passé en même temps? Et quel est notre univers?</a></li>
<li><a href="../fr408883/index.html">Vidéo 3Dtool Hercules Strong 2017 3D Printer Review</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>