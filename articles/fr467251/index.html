<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚Äçüåæ üë©üèæ‚ÄçüöÄ üë©üèº‚Äçüç≥ Otages COBOL et Math. partie 1 üë®‚Äç‚öñÔ∏è üî≤ üöê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Avouons-le: personne n'aime les nombres fractionnaires - m√™me les ordinateurs. 

 En ce qui concerne le langage de programmation COBOL, la premi√®re qu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Otages COBOL et Math. partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/467251/">  Avouons-le: personne n'aime les nombres fractionnaires - m√™me les ordinateurs. <br><br>  En ce qui concerne le langage de programmation COBOL, la premi√®re question qui se pose dans la t√™te de tout le monde ressemble toujours √† ceci: "Pourquoi l'humanit√© utilise-t-elle encore ce langage dans de nombreux domaines vitaux?"  Les banques utilisent toujours COBOL.  Environ 7% du PIB am√©ricain d√©pend de COBOL pour le traitement des paiements √† partir de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CMS</a> .  L'Internal Revenue Service (IRS) des √âtats-Unis, comme chacun le sait, utilise toujours COBOL.  Cette langue est √©galement utilis√©e dans l'aviation (√† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partir de l√†,</a> j'ai appris une chose int√©ressante √† ce sujet: le num√©ro de r√©servation sur les billets d'avion √©tait un pointeur habituel).  On peut dire que de nombreuses organisations tr√®s s√©rieuses, qu'il s'agisse d'un secteur priv√© ou public, utilisent toujours COBOL. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/q1/m_/gs/q1m_gsyxbbwdk32ng3w1foeckgc.jpeg"></a> <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La deuxi√®me partie</a> <br><br>  L'auteur du document, dont nous publions aujourd'hui la premi√®re partie de la traduction, va trouver une r√©ponse √† la question de savoir pourquoi COBOL, la langue apparue en 1959, est toujours aussi r√©pandue. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Pourquoi COBOL est-il toujours vivant?</font> </h2><br>  La r√©ponse traditionnelle √† cette question est profond√©ment cynique.  Les organisations sont la paresse, l'incomp√©tence et la stupidit√©.  Ils recherchent le bon march√© et ne sont pas enclins √† investir dans la r√©√©criture de leurs syst√®mes logiciels sur quelque chose de moderne.  En g√©n√©ral, on peut supposer que la raison pour laquelle le travail d'un nombre aussi important d'organisations d√©pend de COBOL est une combinaison d'inertie et de myopie.  Et en cela, bien s√ªr, il y a une part de v√©rit√©.  La r√©√©criture de grandes quantit√©s de code d√©routant est une t√¢che √©norme.  C'est cher.  C'est compliqu√©.  Et si le logiciel existant semble bien fonctionner, l'organisation ne sera pas particuli√®rement motiv√©e √† investir dans un projet de mise √† jour de ce logiciel. <br><br>  Tout cela est vrai.  Mais quand j'ai travaill√© √† l'IRS, les v√©t√©rans de COBOL ont expliqu√© comment ils avaient essay√© de r√©√©crire le code en Java et il s'est av√©r√© que Java ne pouvait pas effectuer les calculs correctement. <br><br>  Cela me semblait extr√™mement √©trange.  C‚Äôest tellement √©trange que j‚Äôai imm√©diatement pens√© √† l‚Äôalarmiste: "Seigneur, cela signifie que l‚ÄôIRS arrondit les imp√¥ts √† tout le monde depuis 50 ans !!!"  Je ne pouvais tout simplement pas croire que COBOL est capable de contourner Java en termes de calculs math√©matiques n√©cessaires √† l'IRS.  Finalement, ils n‚Äôont pas lanc√© de personnes dans l‚Äôespace. <br><br>  L'un des effets secondaires int√©ressants de l'apprentissage du COBOL pendant l'√©t√© est que j'ai commenc√© √† comprendre ce qui suit.  Le fait n'est pas que Java ne peut pas effectuer correctement des calculs math√©matiques.  Le point est exactement comment Java rend les calculs corrects.  Et lorsque vous comprenez comment les calculs sont effectu√©s en Java et comment la m√™me chose est effectu√©e dans COBOL, vous commencez √† comprendre pourquoi de nombreuses organisations ont du mal √† se d√©barrasser de leur h√©ritage informatique. <br><br><h2>  <font color="#3AC1EF">Quel "i" doit √™tre pointill√©?</font> </h2><br>  Je vais m'√©loigner un peu de l'histoire COBOL et parler de la fa√ßon dont les ordinateurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">stockaient les informations</a> avant que la repr√©sentation binaire des donn√©es ne devienne la norme de facto (mais le mat√©riel sur la fa√ßon d'utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'interface</a> z / OS; c'est quelque chose de sp√©cial).  Je pense qu'en examinant notre probl√®me, il sera utile de s'√©carter du th√®me principal dans cette direction.  Dans le document ci-dessus, j'ai parl√© de diff√©rentes fa√ßons d'utiliser des commutateurs binaires pour stocker des nombres dans des syst√®mes binaires, ternaires, d√©cimaux, pour stocker des nombres n√©gatifs - et ainsi de suite.  La seule chose √† laquelle je n'ai pas pr√™t√© suffisamment d'attention √©tait de savoir comment les nombres d√©cimaux sont stock√©s. <br><br>  Si vous avez con√ßu votre propre ordinateur binaire, vous pouvez commencer par d√©cider d'utiliser le syst√®me num√©rique binaire.  Les bits √† gauche du point repr√©sentent des entiers - 1, 2, 4, 8. Et les bits √† droite - nombres fractionnaires - 1/2, 1/4, 1/8 ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c87/2eb/182/c872eb1825dc1d6b456ae11cbcc3325d.png"></div><br>  <i><font color="#999999">2,75 en repr√©sentation binaire</font></i> <br><br>  Le probl√®me ici est de comprendre comment stocker le point d√©cimal lui-m√™me (en fait - je devrais dire ¬´point binaire¬ª - car, apr√®s tout, nous parlons de nombres binaires).  Ce n'est pas une sorte d'alchimie informatique, vous pouvez donc bien deviner de quoi je parle des nombres √† virgule flottante et des nombres √† virgule fixe.  Dans les nombres √† virgule flottante, un point binaire peut √™tre plac√© n'importe o√π (c'est-√†-dire qu'il peut ¬´flotter¬ª).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La position du</a> point est stock√©e en tant qu'exposant.  La possibilit√© de d√©placer un point permet de stocker une gamme de nombres plus large que celle disponible en l'absence d'une telle opportunit√©.  Le point d√©cimal peut √™tre d√©plac√© tout √† l'arri√®re du nombre et s√©lectionner tous les bits pour stocker des valeurs enti√®res, repr√©sentant de tr√®s grands nombres.  Le point peut √™tre d√©plac√© vers l'avant du nombre et exprimer de tr√®s petites valeurs.  Mais cette libert√© vient au prix de la pr√©cision.  Jetons un autre regard sur la repr√©sentation binaire de 2,75 de l'exemple pr√©c√©dent.  Une transition de quatre √† huit est bien plus qu'une transition d'un quart √† un huiti√®me.  Il peut √™tre plus facile pour nous d'imaginer cela si nous r√©√©crivons l'exemple comme indiqu√© ci-dessous. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/894/ec9/8aa/894ec98aa1715609e45d95ede3b865b1.png"></div><br>  <i><font color="#999999">J'ai choisi la distance entre les nombres √† l'≈ìil nu - juste pour d√©montrer mon id√©e</font></i> <br><br>  La diff√©rence entre les nombres est facile √† calculer par vous-m√™me.  Par exemple, la distance entre 1/16 et 1/32 est de 0,03125, mais la distance entre 1/2 et 1/4 est d√©j√† de 0,25. <br><br>  Pourquoi est-ce important?  Dans le cas d'une repr√©sentation binaire d'entiers, cela n'a pas d'importance - la distance entre les nombres adjacents d'un enregistrement binaire peut √™tre facilement compens√©e en les remplissant avec les combinaisons appropri√©es de bits et sans perte de pr√©cision.  Mais dans le cas de la repr√©sentation des nombres fractionnaires, ce n'est pas si simple.  Si vous essayez de "remplir" les "trous" entre des nombres adjacents - quelque chose peut "tomber" (et r√©ellement tomber) dans ces trous.  Ceci conduit au fait qu'en format binaire il n'est pas possible d'obtenir des repr√©sentations exactes de nombres fractionnaires. <br><br>  Ceci est illustr√© par l'exemple classique du nombre 0,1 (un dixi√®me).  Comment repr√©senter ce nombre au format binaire?  2 <sup>-1</sup> est 1/2 ou 0,5.  C'est trop.  1/16 est 0,0635.  C'est trop peu.  1/16 + 1/32 est d√©j√† plus proche (0,09375), mais 1/16 + 1/32 + 1/64 est d√©j√† plus que ce dont nous avons besoin (0,109375). <br><br>  Si vous croyez que ce raisonnement peut √™tre poursuivi ind√©finiment - alors vous avez raison - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tel qu'il est</a> . <br><br>  Ici, vous pouvez vous dire: ¬´Pourquoi ne sauvegardons-nous pas simplement 0,1 de la m√™me mani√®re que nous stockons le num√©ro 1?  Nous pouvons enregistrer le num√©ro 1 sans aucun probl√®me. Supprimons simplement le point d√©cimal et stockons tous les nombres de la m√™me mani√®re que nous stockons les entiers. " <br><br>  Il s'agit d'une excellente solution √† ce probl√®me, sauf qu'elle n√©cessite de fixer le point binaire / d√©cimal √† un emplacement pr√©d√©termin√©.  Sinon, les nombres 10.00001 et 100000.1 seront exactement identiques.  Mais si le point est fix√© de mani√®re √† ce que, disons, 2 chiffres soient attribu√©s √† la partie fractionnaire du nombre, alors nous pouvons arrondir 10,00001 √† 10,00 et 100000,1 tournera √† 100000,10. <br><br>  Nous venons ¬´d'inventer¬ª des nombres √† virgule fixe. <br><br>  Avec la repr√©sentation de diff√©rentes valeurs en utilisant des nombres √† virgule fixe, nous venons de le comprendre.  C'est facile √† faire.  Est-il possible, en utilisant des nombres √† virgule fixe, de faciliter la solution de certains autres probl√®mes?  Rappelons-nous ici de nos bons amis - des nombres d√©cimaux binaires (Binary Coded Decimal, BCD).  Soit dit en passant, pour vous faire savoir, ces chiffres sont utilis√©s dans la plupart des calculatrices scientifiques et graphiques.  De ces appareils, ce qui est assez clair, ils attendent les r√©sultats corrects des calculs. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/102/020/d31/102020d313c5627bb37fc6dee57954a4.jpg"></div><br>  <i><font color="#999999">Calculatrice TI-84 Plus</font></i> <br><br><h2>  <font color="#3AC1EF">Ratio de r√©currence de Muller et Python</font> </h2><br>  Les nombres √† virgule fixe sont consid√©r√©s comme plus pr√©cis en raison du fait que les ¬´trous¬ª entre les nombres sont constants, et parce que l'arrondi se produit uniquement lorsque vous avez besoin d'imaginer un nombre pour lequel il n'y a tout simplement pas assez d'espace.  Mais lorsque vous utilisez des nombres √† virgule flottante, nous pouvons repr√©senter des nombres tr√®s grands et tr√®s petits en utilisant la m√™me quantit√© de m√©moire.  Certes, avec leur aide, il est impossible de repr√©senter avec pr√©cision tous les nombres dans la plage accessible et nous sommes oblig√©s de recourir √† l'arrondissement afin de combler les ¬´trous¬ª. <br><br>  COBOL a √©t√© cr√©√© comme une langue dans laquelle, par d√©faut, des nombres √† virgule fixe sont utilis√©s.  Mais cela signifie-t-il que COBOL est meilleur que les langages modernes pour effectuer des calculs math√©matiques?  Si nous nous attaquons √† un probl√®me comme le r√©sultat du calcul de la valeur 0,1 + 0,2, alors il peut sembler que la question pr√©c√©dente doit √™tre r√©pondue ¬´oui¬ª.  Mais ce sera ennuyeux.  Continuons donc. <br><br>  Nous allons exp√©rimenter COBOL en utilisant la relation dite de r√©currence de Muller.  Jean-Michel Muller est un scientifique fran√ßais qui a peut-√™tre fait une d√©couverte scientifique majeure dans le domaine des technologies de l'information.  Il a trouv√© un moyen de briser le bon fonctionnement des ordinateurs en utilisant les math√©matiques.  Je suis s√ªr qu'il dirait qu'il √©tudie les probl√®mes de fiabilit√© et de pr√©cision, mais non et encore: il cr√©e des probl√®mes math√©matiques qui ¬´cassent¬ª les ordinateurs.  L'une de ces t√¢ches est sa formule de r√©currence.  Cela ressemble √† ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fa/1d8/56c/8fa1d856cfe581c272fc25a8c55e8938.png"></div><br>  <i><font color="#999999">Cet exemple est tir√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d'ici.</a></font></i> <br><br>  La formule ne semble pas du tout effrayante.  Non?  Cette t√¢che convient √† nos besoins pour les raisons suivantes: <br><br><ul><li>  Seules des r√®gles math√©matiques simples sont utilis√©es ici - pas de formules compliqu√©es ou d'id√©es profondes. </li><li>  Nous commen√ßons par un nombre qui a deux chiffres apr√®s la virgule d√©cimale.  Par cons√©quent, il est facile d'imaginer que nous travaillons avec des valeurs repr√©sentant certaines sommes d'argent. </li><li>  L'erreur qui r√©sulte des calculs n'est pas une petite erreur d'arrondi.  Il s'agit d'une d√©viation du r√©sultat correct par des ordres de grandeur entiers. </li></ul><br>  Voici un petit script Python qui calcule les r√©sultats de la relation de r√©currence de Mueller en utilisant des nombres √† virgule flottante et √† virgule fixe: <br><br><pre><code class="plaintext hljs">from decimal import Decimal def rec(y, z):  return 108 - ((815-1500/z)/y)  def floatpt(N):  x = [4, 4.25]  for i in range(2, N+1):   x.append(rec(x[i-1], x[i-2]))  return x  def fixedpt(N):  x = [Decimal(4), Decimal(17)/Decimal(4)]  for i in range(2, N+1):   x.append(rec(x[i-1], x[i-2]))  return x N = 20 flt = floatpt(N) fxd = fixedpt(N) for i in range(N):  print str(i) + ' | '+str(flt[i])+' | '+str(fxd[i])</code> </pre> <br>  Voici le r√©sultat de ce script: <br><br><pre> <code class="plaintext hljs">i | floating pt  | fixed pt -- | -------------- | --------------------------- 0 | 4       | 4 1 | 4.25      | 4.25 2 | 4.47058823529 | 4.4705882352941176470588235 3 | 4.64473684211 | 4.6447368421052631578947362 4 | 4.77053824363 | 4.7705382436260623229461618 5 | 4.85570071257 | 4.8557007125890736342039857 6 | 4.91084749866 | 4.9108474990827932004342938 7 | 4.94553739553 | 4.9455374041239167246519529 8 | 4.96696240804 | 4.9669625817627005962571288 9 | 4.98004220429 | 4.9800457013556311118526582 10 | 4.9879092328  | 4.9879794484783912679439415 11 | 4.99136264131 | 4.9927702880620482067468253 12 | 4.96745509555 | 4.9956558915062356478184985 13 | 4.42969049831 | 4.9973912683733697540253088 14 | -7.81723657846 | 4.9984339437852482376781601 15 | 168.939167671 | 4.9990600687785413938424188 16 | 102.039963152 | 4.9994358732880376990501184 17 | 100.099947516 | 4.9996602467866575821700634 18 | 100.004992041 | 4.9997713526716167817979714 19 | 100.000249579 | 4.9993671517118171375788238</code> </pre> <br>  Jusqu'√† l'it√©ration 12, l'erreur d'arrondi semble plus ou moins insignifiante, mais le v√©ritable enfer commence.  Les calculs √† virgule flottante convergent vers un nombre qui est vingt fois plus √©lev√© que celui r√©sultant des calculs √† virgule fixe. <br><br>  Vous pensez peut-√™tre qu'il est peu probable que quiconque effectue des calculs r√©cursifs √† si grande √©chelle.  Mais c'est pr√©cis√©ment ce qui a caus√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la catastrophe de</a> 1991, qui a entra√Æn√© la mort de 28 personnes, lorsque le syst√®me de contr√¥le des missiles Patriot a mal calcul√© l'heure.  Il s'est av√©r√© que les calculs en virgule flottante ont accidentellement fait beaucoup de mal.  Voici quelques <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">trucs</a> formidables que l'informatique hautes performances n'est peut-√™tre qu'un moyen plus rapide d'obtenir les mauvaises r√©ponses.  Lisez ce travail si vous souhaitez obtenir plus d'informations sur le probl√®me discut√© ici et voir plus d'exemples. <br><br>  Le probl√®me est que la quantit√© de RAM que les ordinateurs ont n'est pas infinie.  Par cons√©quent, il est impossible de stocker un nombre infini de positions d√©cimales (ou binaires).  Les calculs √† virgule fixe peuvent √™tre plus pr√©cis que les calculs √† virgule flottante s'il est certain qu'il est moins probable que plus de nombres seront n√©cessaires apr√®s le point que le format utilis√©.  Si le nombre ne rentre pas dans ce format, il sera arrondi.  Il convient de noter que ni les calculs √† virgule fixe ni les calculs √† virgule flottante ne sont prot√©g√©s du probl√®me que la relation de r√©currence de Mueller d√©montre.  Cela et d'autres en cons√©quence donnent des r√©sultats incorrects.  La question est de savoir quand cela se produit.  Si vous augmentez le nombre d'it√©rations dans un script Python, par exemple, de 20 √† 22, le nombre final obtenu dans les calculs avec un point fixe sera 0,728107.  23 it√©rations?  -501.7081261.  24?  105.8598187. <br><br>  Dans diff√©rentes langues, ce probl√®me se manifeste de diff√©rentes mani√®res.  Certains, comme COBOL, vous permettent de travailler avec des nombres dont les param√®tres sont bien d√©finis.  Et en Python, par exemple, il existe des valeurs par d√©faut qui peuvent √™tre configur√©es si l'ordinateur a suffisamment de m√©moire.  Si nous ajoutons la ligne <code>getcontext().prec = 60</code> √† notre programme, indiquant au module d√©cimal Python qu'il utiliserait 60 positions apr√®s la p√©riode, plut√¥t que 28, comme cela est fait par d√©faut, le programme sera en mesure de terminer 40 it√©rations de la relation de r√©currence sans erreurs Mueller. <br><br>  √Ä suivre ... <br><br>  <b>Chers lecteurs!</b>  Avez-vous rencontr√© de s√©rieux probl√®mes dus √† la nature des calculs √† virgule flottante? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467251/">https://habr.com/ru/post/fr467251/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467239/index.html">La diff√©rence entre Data Scientist et un adolescent dans une voiture de sport</a></li>
<li><a href="../fr467241/index.html">Chariot de camion ROS. Partie 4. Cr√©ation d'une simulation de robot √† l'aide des √©diteurs rviz et gazebo</a></li>
<li><a href="../fr467245/index.html">Dmitry Matskevich, Dbrain: sur l'entrepreneuriat en tant que handicap mental, IA et s√©curit√© √©motionnelle</a></li>
<li><a href="../fr467247/index.html">Une histoire sur V8, React et une baisse des performances. partie 1</a></li>
<li><a href="../fr467249/index.html">Une histoire sur V8, React et une baisse des performances. 2e partie</a></li>
<li><a href="../fr467253/index.html">Otages COBOL et Math. 2e partie</a></li>
<li><a href="../fr467255/index.html">Trois erreurs de s√©curit√© courantes que chaque d√©veloppeur React devrait conna√Ætre</a></li>
<li><a href="../fr467257/index.html">Ne stockez pas tous vos ≈ìufs dans le m√™me panier √† la fois</a></li>
<li><a href="../fr467259/index.html">DPI (inspection SSL) contredit le sens de la cryptographie, mais les entreprises la mettent en ≈ìuvre</a></li>
<li><a href="../fr467261/index.html">Filetage correct dans Qt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>