<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍💻 👨🏼‍💻 🥠 Como os microsserviços Netflix lidam com dados Pub-Sub 🕑 👩🏽‍🤝‍👩🏼 👨🏾‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A tradução do artigo foi preparada especialmente para os alunos do curso “High Load Architect” . 
 



 1. Introdução 
 Na arquitetura de microsserviç...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como os microsserviços Netflix lidam com dados Pub-Sub</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/479572/">  <i>A tradução do artigo foi preparada especialmente para os alunos do curso <a href="https://otus.pw/RCke/">“High Load Architect”</a> .</i> <i><br></i> <br><br><img src="https://habrastorage.org/webt/ro/7u/1i/ro7u1is2mtzuzuuuzpdm07pgzc8.png"><br><hr><br><h3>  1. Introdução </h3><br>  Na arquitetura de microsserviço da Netflix, a transferência de conjuntos de dados de um para vários pontos de extremidade pode ser extremamente difícil.  Esses conjuntos de dados podem conter qualquer coisa, desde uma configuração de serviço até resultados de processamento em lote.  Para otimizar o acesso, geralmente é necessário um banco de dados residente e as alterações devem ser enviadas imediatamente após a atualização dos dados. <br><br>  Um exemplo que reflete a necessidade de distribuição distribuída de um conjunto de dados é mais ou menos assim: a qualquer momento, a Netflix realiza um grande número de testes A / B.  Esses testes abrangem vários serviços e comandos, e os operadores de teste devem poder reconfigurar em tempo real.  Também requer a capacidade de detectar nós que não puderam obter a configuração de teste mais recente e a capacidade de reverter para versões mais antigas, caso algo dê errado. <a name="habracut"></a><br><br>  Outro exemplo de um conjunto de dados que precisa ser distribuído é a sequência de saída de um modelo de aprendizado de máquina: os resultados de seu trabalho podem ser usados ​​por várias equipes; no entanto, as equipes de ML não estão necessariamente interessadas em oferecer suporte a serviços de acesso ininterrupto em uma situação crítica.  Em vez da situação em que cada equipe precisa criar backups para poder fazer uma reversão sucinta, é dada atenção especial para garantir que várias equipes possam usar os resultados de uma única equipe. <br><br>  Sem suporte no nível da infraestrutura, cada equipe tenta implementar sua própria solução, mas acontece com equipes diferentes com sucesso variável.  Os conjuntos de dados são de tamanhos diferentes, de alguns bytes a alguns gigabytes.  É importante criar a capacidade de monitorar o desempenho dos processos e detectar defeitos usando ferramentas especiais, para que os operadores possam fazer alterações rapidamente sem precisar criar sua própria solução. <br><br><img src="https://habrastorage.org/webt/96/wa/uw/96wauwyjpxs3xx0kljnxvxcmk2i.png"><br>  <i>Divulgação de dados</i> <br><br>  Na Netflix, usamos um sistema de publicação / sub-dados interno chamado Gutenberg.  O Gutenberg permite distribuir conjuntos de dados com controle de versão - os destinatários assinam os dados e recebem as versões mais recentes quando publicados.  Cada versão do conjunto de dados permanece inalterada e contém uma representação completa dos dados, ou seja, não há dependência das versões anteriores.  O Gutenberg permite visualizar versões antigas de dados, caso você precise, por exemplo, de depuração, resolução rápida de um problema de dados ou reciclagem de um modelo de aprendizado de máquina.  Neste artigo, falaremos sobre a arquitetura de alto nível de Gutenberg. <br><br><h4>  Modelo de dados </h4><br><img src="https://habrastorage.org/webt/7g/7z/b6/7g7zb66okgkinf1xxzvlyxk-60w.png"><br>  <i>1 tópico -&gt; muitas versões</i> <br><br>  O design de alto nível de Gutenberg é o tema.  O publicador publica dados dentro do tópico e os destinatários os extraem.  A publicação no tópico é adicionada como uma versão separada.  Esses são caracterizados por uma política de armazenamento específica que determina o número de versões, dependendo do caso de uso.  Por exemplo, você pode configurar um tema para armazenar 10 versões ou versões dos últimos 10 dias. <br><br>  Cada versão contém metadados (chaves e valores) e um ponteiro de dados.  O ponteiro de dados pode ser considerado como metadado especial, indicando onde os dados publicados são realmente armazenados.  Hoje, o Gutenberg suporta ponteiros de dados diretos (se a carga útil estiver gravada no valor do ponteiro de dados) e ponteiros de dados S3 (se a carga útil estiver armazenada no S3).  Os ponteiros de dados diretos geralmente são usados ​​quando os dados são pequenos (menos de 1 MB) e o S3 é usado como armazenamento de backup, caso o volume de dados seja grande. <br><br><img src="https://habrastorage.org/webt/z7/we/mp/z7wemphye670skkx23aemtfkdyi.png"><br>  <i>1 tópico -&gt; muitos conjuntos publicados</i> <br><br>  Gutenberg oferece a capacidade de enviar uma publicação a um conjunto específico de usuários destinatários - por exemplo, um conjunto pode ser agrupado por uma região, aplicativo ou cluster específico.  Isso pode ser usado para controlar a qualidade das alterações de dados ou para limitar o conjunto de dados para que um subconjunto de aplicativos possa se inscrever nele.  Os editores determinam a área de publicação de uma versão específica dos dados e podem adicionar áreas aos dados publicados anteriormente.  Observe que isso significa que o conceito da versão mais recente dos dados depende de uma área específica - os dois aplicativos podem receber as versões diferentes mais recentes dos dados, dependendo da área de publicação definida pelo editor.  O serviço Gutenberg mapeia os aplicativos destinatários para as áreas de publicação antes de decidir o que enviar como a versão mais recente. <br><br><h3>  Casos de uso </h3><br>  O caso de uso mais comum do Gutenberg é distribuir dados de tamanhos diferentes de um editor para vários destinatários.  Freqüentemente, os dados são armazenados na memória do destinatário e usados ​​como um "cache compartilhado", onde permanecem sempre disponíveis durante a execução do código do destinatário e são substituídos atomicamente sob o capô, se necessário.  Muitos desses casos de uso podem ser agrupados em "configurações", como a configuração de cache do <a href="https://medium.com/netflix-techblog/distributing-content-to-open-connect-3e3e391d4dc9">Open Connect Appliance</a> , IDs de tipo de dispositivo suportados, metadados de métodos de pagamento suportados e configurações de teste A / B.  Gutenberg fornece uma abstração entre publicar e receber esses dados, permitindo que os editores iterem livremente através de seus aplicativos sem afetar os destinatários posteriores.  Em alguns casos, a publicação é feita usando uma interface de usuário gerenciada por Gutenberg, e as equipes não precisam tocar em seu próprio aplicativo de publicação. <br><br>  Outro uso do sistema Gutenberg é um repositório de dados com versão.  Isso é útil para aplicativos de aprendizado de máquina em que as equipes constroem e treinam modelos com base em dados históricos, veem como eles mudam ao longo do tempo, alteram determinados parâmetros e executam o aplicativo novamente.  Geralmente, nos cálculos em lotes, o Gutenberg é usado para armazenar e distribuir os resultados desses cálculos como versões diferentes dos conjuntos de dados.  Os casos de uso online assinam tópicos para fornecer dados em tempo real dos conjuntos de versões mais recentes, enquanto sistemas autônomos podem usar dados históricos dos mesmos tópicos, por exemplo, para ensinar um modelo de aprendizado de máquina. <br><br>  É importante observar que o Gutenberg não foi projetado como um sistema de eventos, destina-se apenas ao controle de versão e distribuição de dados.  Em particular, publicações frequentes não significam que o assinante seja obrigado a receber cada versão.  Quando ele solicita uma atualização, ele recebe a versão mais recente, mesmo que no momento sua versão atual esteja muito atrás da atual.  Os sistemas tradicionais pub-sub ou event são mais adequados para pequenas mensagens enviadas seqüencialmente.  Ou seja, os destinatários podem criar uma idéia de todo o conjunto de dados consumindo todo o fluxo (compactado) de eventos.  No entanto, Gutenberg pretende publicar e usar uma representação completa e imutável de um conjunto de dados. <br><br><h3>  Desenvolvimento e arquitetura </h3><br>  Gutenberg consiste em um serviço gRPC e uma API REST, além de uma biblioteca cliente Java que usa a API gRPC. <br><br><img src="https://habrastorage.org/webt/lw/bz/m_/lwbzm_dd871-cgpebuwlmorejd4.png"><br>  <i>Arquitetura de alto nível</i> <br><br><h3>  Cliente </h3><br>  A biblioteca do cliente Gutenberg lida com tarefas como gerenciar uma assinatura, carregar / descarregar S3, métricas <a href="https://github.com/Netflix/atlas">Atlas</a> e parâmetros que podem ser configurados usando as propriedades do <a href="https://github.com/Netflix/archaius">Archaius</a> .  Ela interage com o serviço Gutenberg através do gRPC, usando <a href="https://github.com/Netflix/eureka">Eureka</a> para descobrir serviços. <br><br><h3>  Postagem </h3><br>  Os editores geralmente usam APIs de alto nível para publicar sequências, arquivos e matrizes de bytes.  Dependendo do tamanho dos dados, eles podem ser publicados como um ponteiro direto para os dados ou enviados para o S3 e, em seguida, publicados como um ponteiro de dados S3.  O cliente pode fazer upload da carga útil para o S3 em nome do editor ou publicar apenas os metadados da carga útil que já estão no S3. <br><br>  Os ponteiros de dados diretos são automaticamente replicados globalmente.  Os dados publicados no S3 são, por padrão, carregados pelo editor em várias áreas, embora também possam ser personalizados. <br><br><h3>  Gerenciamento de Assinaturas </h3><br>  A biblioteca do cliente fornece gerenciamento de assinaturas de destinatários.  Isso permite que os usuários criem assinaturas para determinados tópicos dos quais a biblioteca extrai dados (por exemplo, do S3) para transferi-los para o destinatário definido pelo usuário.  As assinaturas funcionam de acordo com o modelo de pesquisa - elas solicitam uma nova atualização do serviço a cada 30 segundos, enviando a versão que receberam por último.  Os clientes assinados não usarão uma versão mais antiga dos dados do que a que eles têm atualmente se não forem corrigidos (consulte "tolerância a falhas" abaixo).  A lógica de solicitação repetida é cabeada e configurável.  Por exemplo, os usuários podem configurar o Gutenberg para usar versões mais antigas dos dados se o processo de download for interrompido ou para processar a versão mais recente dos dados na inicialização, na maioria das vezes, para trabalhar com alterações de dados incompatíveis com o feedback.  O Gutenberg também fornece uma assinatura pré-configurada que armazena os dados mais recentes e os atualiza automaticamente quando as alterações chegam.  Isso atende à maioria dos casos de uso de assinaturas, em que os assinantes se preocupam apenas com o valor atual a qualquer momento, o que permite aos usuários especificar um valor padrão, por exemplo, para um tópico que nunca foi publicado antes (por exemplo, se o tema for usado para configuração) ou se houver um erro dependendo do tópico (para evitar o bloqueio do lançamento do serviço quando houver um valor padrão válido). <br><br><h3>  API do destinatário </h3><br>  A Gutenberg também fornece APIs de cliente de alto nível, que possuem APIs de gRPC de baixo nível e fornecem funcionalidade adicional e transparência na execução da consulta.  Um exemplo é o download de dados para um tema e versão específicos, amplamente utilizados por componentes conectados ao <a href="https://github.com/Netflix/hollow">Netflix Hollow</a> .  Outro exemplo é o recebimento da versão mais recente de um tópico em um determinado momento - um caso de uso comum para depuração ou ensino de modelos de aprendizado de máquina. <br><br><h3>  Sustentabilidade e "transparência" do cliente </h3><br>  O Gutenberg foi projetado com o objetivo de permitir que os serviços de destinatário iniciem com êxito, em vez de garantir que eles comecem com os dados mais atuais.  Por esse motivo, a biblioteca cliente foi construída com lógica de backup para lidar com estados quando não pode interagir com o serviço Gutenberg.  Se as solicitações HTTP falharem, o cliente carregará o cache de metadados de backup do tópico publicado do S3 e trabalhará com ele.  Esse cache contém todas as informações para decidir se deve aplicar a atualização e onde recuperar os dados (dos próprios metadados da publicação ou do S3).  Isso permite que os clientes recuperem dados (que estão potencialmente desatualizados, dependendo do estado atual do cache de backup) sem usar o serviço. <br><br>  Uma das vantagens de fornecer uma biblioteca cliente é a capacidade de obter métricas que podem ser usadas para relatar problemas de infraestrutura em geral e erros em aplicativos específicos.  Hoje, essas métricas são usadas pela equipe de Gutenberg para monitorar nossa distribuição de publicações e alertas SLI em caso de problemas típicos.  Alguns clientes também usam essas métricas para relatar erros específicos de aplicativos específicos, por exemplo, falhas de publicação individuais ou uma recusa de tópico específica. <br><br><h3>  Servidor </h3><br>  Gutenberg é um aplicativo <a href="https://github.com/Netflix/governator">Governator</a> / Tomcat que fornece pontos de extremidade gRPC e REST.  Ele usa o cluster Cassandra replicado globalmente para armazenar e distribuir metadados de publicação em cada região.  As instâncias que processam solicitações de destinatário são dimensionadas separadamente das instâncias que processam solicitações de publicação.  Há aproximadamente 1.000 vezes mais solicitações de publicação do que solicitações de publicação.  Além disso, isso permite remover a dependência do fato da publicação no recebimento, para que um aumento repentino nas publicações não afete o recebimento e vice-versa. <br><br>  Cada instância no Cluster de Solicitações de Destinatário processa seu próprio cache de memória das publicações recentes, retirando-o do Cassandra a cada poucos segundos.  Isso é necessário para processar um grande número de solicitações de recebimento provenientes de clientes assinados sem transferir tráfego para o cluster Cassandra.  Além disso, os caches com um pequeno pool de solicitações ttl protegem contra picos de consulta que podem retardar tanto o Cassandra que afetam toda a região.  Tivemos situações em que erros repentinos coincidentes com a redistribuição de grandes grupos causaram interrupções no serviço Gutenberg.  Além disso, usamos o <a href="https://github.com/Netflix/concurrency-limits">limitador de simultaneidade</a> adaptável encontrado no aplicativo original para suprimir aplicativos com comportamento incorreto sem afetar outros. <br><br>  Nos casos em que os dados são publicados no S3 em várias regiões, o servidor decide qual segmento enviar de volta ao cliente para download, dependendo da localização do cliente.  Ele também permite que o serviço forneça ao cliente um segmento na região "mais próxima" ou force o cliente a mudar para outra região se a região atual for desconectada por um motivo ou outro. <br><br>  Antes de devolver os dados da assinatura aos destinatários, o Gutenberg primeiro verifica a consistência dos dados.  Se a verificação falhar e o assinante já tiver recebido alguns dados, o serviço não retornará nada, o que realmente significa que a atualização não está disponível.  Se o cliente assinante ainda não recebeu nenhum dado (geralmente isso significa que acabou de iniciar), o serviço solicita o histórico do tópico e retorna o último valor que passa na verificação de consistência.  Isso ocorre pelo fato de observarmos atrasos episódicos na replicação no nível Cassandra, onde, quando os assinantes solicitam novos dados, os metadados associados à versão publicada mais recente eram apenas parcialmente replicados.  Isso pode fazer com que o cliente receba dados incompletos, o que levará a erros na solicitação de dados ou na lógica de negócios.  A realização de tais verificações de consistência no servidor protege os destinatários de alertas de possível consistência que acompanham a escolha de um serviço de armazém de dados. <br><br>  A capacidade de monitorar publicações de tópicos e sites que usam esses tópicos é uma função importante para auditar e coletar informações de uso.  Para coletar esses dados, o serviço intercepta solicitações de editores e destinatários (solicitações de atualização de dados de assinantes e outros) e as indexa no Elasticsearch usando o <a href="https://medium.com/netflix-techblog/keystone-real-time-stream-processing-platform-a3ee651812a">pipeline de</a> dados <a href="https://medium.com/netflix-techblog/keystone-real-time-stream-processing-platform-a3ee651812a">Keystone</a> .  Portanto, temos a oportunidade de obter dados para monitorar tópicos usados ​​e que não estão mais lá.  Publicamos links detalhados para o painel do Kibana a partir da interface do usuário interna, para que os proprietários do tema possam gerenciar seus assinantes de maneira independente. <br><br>  Além de clusters que lidam com solicitações de editores e destinatários, o serviço Gutenberg lança outro cluster que processa solicitações periódicas.  Em particular, ele resolve dois problemas: <br><br><ol><li>  A cada poucos minutos, todas as publicações e metadados mais recentes são coletados e enviados para o S3.  Isso inicia o início do cache de backup, usado pelo cliente, conforme descrito acima. </li><li>  O coletor de lixo exclui versões de tópicos que não atendem às políticas de retenção.  Ele também exclui os dados associados a ele (por exemplo, objetos S3) e ajuda a garantir um ciclo de vida dos dados bem definido. </li></ol><br><h3>  Tolerância a falhas </h3><br><h4>  Snap </h4><br>  As implantações malsucedidas acontecem no mundo do desenvolvimento de aplicativos, e as reversões para versões anteriores são uma estratégia comum para corrigir esses problemas.  A arquitetura orientada a dados complica a situação, porque o comportamento é determinado por dados que mudam com o tempo. <br><br>  Os dados distribuídos por Gutenberg influenciam e, em muitos casos, controlam o comportamento do sistema.  Isso significa que, se algo der errado, você precisará de uma maneira de reverter para uma boa versão comprovada dos dados.  Para aliviar a situação, Gutenberg torna possível "vincular" o tema a uma versão específica.  Os pinos substituem a versão mais recente dos dados e forçam o cliente a atualizar para esta versão, o que permite corrigir rapidamente uma situação crítica, em vez de tentar descobrir como publicar a versão de trabalho mais recente.  Você pode até aplicar a ligação à área de publicação para que apenas os destinatários dessa área possam usar os dados.  Os pinos também substituem os dados publicados durante a ligação ativa, mas quando o pino é excluído, os clientes receberão a versão mais recente, que pode ser a última versão fixada ou uma nova versão publicada enquanto a antiga foi fixada. <br><br><h3>  Implantação sequencial </h3><br>  Ao implantar um novo código, é recomendável criar novos assemblies com um subconjunto de tráfego, implantá-los gradualmente ou, de alguma outra maneira, reduzir os riscos de implantação, diminuindo a velocidade.  ,    ,    . <br><br>   ,   Gutenberg, —         <a href="https://medium.com/netflix-techblog/global-continuous-delivery-with-spinnaker-2a6896c23ba7">Spinnaker</a> .       ,         .      ,            .     , ,       ,      ,      ,    . ,           AWS-  . <br><br><h4>  </h4><br> Gutenberg   Netflix     .    Gutenberg       ,              6 .      –           ,        1-2   ,        12 . <br><br>    24-    ,      ,     .   ,         200,          7.    -    ,      ,      Hollow.     ,       ,      ,     – 60,     – 4. <br><br><h4>   </h4><br>   ,      Gutenberg: <br><br><ul><li> <b>  </b> :    Gutenberg   Java-,        Node.JS  Python-.       ,   REST API Gutenberg   .     ,       Node.JS  Python. </li><li> <b>   </b> :     Gutenberg               .        Gutenberg. </li><li> <b>  </b> :            ,     . ,                  . </li><li> <b> </b> : ,   Gutenberg,    Gutenberg     .            ,        . </li><li> <b> </b> :      ,     ,            .           ,   Elasticsearch. </li><li> <b>  </b> :   Netflix –       .           ,    Gutenberg  ,           . </li></ul><br>  <i>Só isso.</i> <i>    <a href="https://otus.pw/RCke/"></a> .</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt479572/">https://habr.com/ru/post/pt479572/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt479562/index.html">Crie a estrutura de um bot multiplataforma simples</a></li>
<li><a href="../pt479564/index.html">ClickHouse + Graphite: como reduzir significativamente o consumo de espaço em disco</a></li>
<li><a href="../pt479566/index.html">Sistema de supressão de potencial ou engenharia reversa da Matrix + prova de tempo simultâneo</a></li>
<li><a href="../pt479568/index.html">Eu trabalho como programador em uma empresa, mas quero conhecer meus 50 anos de maneira diferente</a></li>
<li><a href="../pt479570/index.html">Pontos de entrada Python</a></li>
<li><a href="../pt479574/index.html">4 aspectos do gerenciamento de serviços ITIL</a></li>
<li><a href="../pt479578/index.html">Terceirização de impressão: como verificar se o contratado não está cobrando valores da fatura</a></li>
<li><a href="../pt479580/index.html">Golden canon grid: história de horror para frontend</a></li>
<li><a href="../pt479584/index.html">Sistemas gerais de detecção e prevenção de intrusões</a></li>
<li><a href="../pt479586/index.html">O Efros Config Inspector beneficia mesmo aqueles que não o usam</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>