<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏇🏿 👨🏾‍🎓 👨‍⚕️ Docker + Laravel = ❤ 🌝 📓 🏘️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Neste artigo, falarei sobre minha experiência de "agrupar" um aplicativo Laravel em um contêiner Docker para que os desenvolvedores de front-end e bac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Docker + Laravel = ❤</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425101/"><p><img src="https://habrastorage.org/getpro/habr/post_images/89c/b0e/91f/89cb0e91fd1efafb24b66b7ee44dc1b0.png" alt="laravel-in-docker"></p><br><p> Neste artigo, falarei sobre minha experiência de "agrupar" um aplicativo Laravel em um contêiner Docker para que os desenvolvedores de front-end e back-end possam trabalhar localmente com ele, e iniciá-lo na produção foi o mais simples possível.  Além disso, o CI executará automaticamente analisadores de código estático, testes de <code>phpunit</code> e criará imagens. </p><br><p>  "E o que, de fato, é complexidade?"  - você pode dizer e estará parcialmente certo.  O fato é que muitas discussões nas comunidades de língua russa e de língua inglesa são dedicadas a esse tópico, e eu dividiria condicionalmente quase todos os tópicos estudados nas seguintes categorias: </p><br><ul><li>  "Estou usando o docker para desenvolvimento local. Coloquei o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">laradock</a> e não conheço os problemas".  Legal, mas e o lançamento da automação e produção? </li><li>  "Eu coleciono um container <em>(monólito)</em> baseado no <code>fedora:latest</code> (~ 230 Mb), coloco todos os serviços (nginx, db, cache, etc) nele, executo tudo dentro do supervisor."  Também excelente, fácil de iniciar, mas e a ideologia de "um contêiner - um processo"?  E quanto ao balanceamento e gerenciamento de processos?  Qual é o tamanho da imagem? </li><li>  "Aqui estão algumas configurações, tempere com trechos de sh-scripts, adicione env-values ​​mágicos, use-os."  Obrigado, mas e quanto a pelo menos um exemplo vivo que eu poderia usar e tocar totalmente? </li></ul><br><p>  Tudo o que você lê abaixo é uma experiência subjetiva que não finge ser a verdade suprema.  Se você tiver adições ou indicações de imprecisões - bem-vindo aos comentários. </p><br><blockquote>  Para os impacientes - um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link para o repositório</a> , clone o qual você pode iniciar o aplicativo Laravel com um comando.  Também não é difícil executá-lo no mesmo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fazendeiro</a> , "vinculando" corretamente os contêineres ou usar a versão do supermercado <code>docker-compose.yml</code> como ponto de partida. </blockquote><a name="habracut"></a><br><h2 id="chast-teoreticheskaya">  Parte teórica </h2><br><p>  Quais ferramentas usaremos em nosso trabalho e em que focaremos?  Primeiro de tudo, precisamos instalar no host: </p><br><ul><li>  <code>docker</code> - no momento da redação, usei a versão <code>18.06.1-ce</code> </li><li>  <code>docker-compose</code> - lida com a conexão de contêineres e o armazenamento dos valores ambientais necessários;  versão <code>1.22.0</code> </li><li>  <code>make</code> - você pode se surpreender, mas se encaixa perfeitamente no contexto de trabalhar com o docker </li></ul><br><blockquote>  Você pode <code>curl -fsSL get.docker.com | sudo sh</code> <code>docker</code> em sistemas do tipo <code>debian</code> com o comando <code>curl -fsSL get.docker.com | sudo sh</code>  <code>curl -fsSL get.docker.com | sudo sh</code> , mas o <code>docker-compose</code> melhor para instalar usando o <code>pip</code> , pois as versões mais recentes estão em seus repositórios (o <code>apt</code> muito atrasado, em regra). </blockquote><p>  Isso completa a lista de dependências.  O que você usará para trabalhar com o código-fonte - <code>phpstorm</code> , <code>netbeans</code> ou dead <code>vim</code> - depende de você. </p><br><p>  A seguir, um controle de qualidade improvisado no contexto do design da imagem <em>(não tenho medo dessa palavra)</em> : </p><br><ul><li><p>  <strong>P: Imagem básica - qual é a melhor escolha?</strong> </p><br></li><li><p>  <strong>A:</strong> O que é "mais fino", sem frescuras.  Com base no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>alpine</code></a> <em>(~ 5 Mb),</em> você pode coletar o que seu coração desejar, mas provavelmente terá que jogar com a montagem de serviços da fonte.  Como alternativa - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>jessie-slim</code></a> <em>(~ 30 Mb)</em> .  Ou use o que é mais usado em seus projetos. </p><br></li><li><p>  <strong>P: Por que o peso da imagem é importante?</strong> </p><br></li><li><p>  <strong>R:</strong> Diminuição do volume de tráfego, diminuição da probabilidade de erro ao baixar (menos dados - menos probabilidade), diminuição no local consumido.  A regra "A gravidade é confiável" (© "Snatch") não funciona muito bem aqui. </p><br></li><li><p>  <strong>P: Mas meu amigo <code>%friend_name%</code> diz que uma imagem "monolítica" com todas as dependências é a melhor maneira.</strong> </p><br></li><li><p>  <strong>A:</strong> Vamos apenas contar.  O aplicativo possui 3 dependências - PG, Redis, PHP.  E você queria testar como ele se comportaria em pacotes de versões diferentes dessas dependências.  PG - versões 9.6 e 10, Redis - 3.2 e 4.0, PHP - 7.0 e 7.2.  Caso cada dependência seja uma imagem separada - você precisa de 6 delas, que nem precisa coletar - tudo está pronto e fica no <code>hub.docker.com</code> .  Se, por razões ideológicas, todas as dependências forem "empacotadas" em um contêiner, você precisará montá-lo com canetas ... 8 vezes?  Agora adicione a condição que você ainda deseja jogar com o <code>opcache</code> .  No caso de decomposição, isso é simplesmente uma alteração nas tags das imagens usadas.  Um monólito é mais fácil de executar e manter, mas é o caminho para lugar nenhum. </p><br></li><li><p>  <strong>P: Por que o supervisor no contêiner é mau?</strong> </p><br></li><li><p>  <strong>A:</strong> Porque o <code>PID 1</code> .  Se você não deseja muitos problemas com os processos zumbis e tem a capacidade de "adicionar capacidade" de forma flexível, quando necessário - tente executar um processo por contêiner.  Uma exceção peculiar é o <code>nginx</code> com seus trabalhadores e o <code>php-fpm</code> , que têm a capacidade de produzir processos, mas precisam tolerar isso (além disso, eles não são ruins em reagir ao <code>SIGTERM</code> , "matando" corretamente seus trabalhadores).  Ao lançar todos os demônios como supervisor, você quase certamente está se condenando a problemas.  Embora, em alguns casos, seja difícil ficar sem isso, mas essas já são exceções. </p><br></li></ul><br><p>  Tendo decidido sobre as principais abordagens, vamos para o nosso aplicativo.  Deve ser capaz de: </p><br><ul><li>  <code>web|api</code> - dê estática com <code>nginx</code> e gere conteúdo dinâmico com <code>fpm</code> </li><li>  <code>scheduler</code> - execute o agendador de tarefas nativo </li><li>  <code>queue</code> - processa trabalhos de filas </li></ul><br><p>  Um conjunto básico que pode ser expandido, se necessário.  Agora, vamos às imagens que precisamos coletar para que nosso aplicativo "decole" (seus nomes de código são dados entre colchetes): </p><br><ul><li>  <code>PHP + PHP-FPM</code> ( <strong>app</strong> ) - o ambiente em que nosso código será executado.  Como as versões do PHP e do FPM serão as mesmas para nós - nós as coletamos em uma imagem.  Portanto, é mais fácil gerenciar com as configurações e a composição dos pacotes será idêntica.  Obviamente - os processos de aplicação e FPM serão executados em diferentes contêineres </li><li>  <code>nginx</code> ( <strong>nginx</strong> ) - que não se incomodaria com a entrega de configurações e módulos opcionais para o <code>nginx</code> - coletaremos uma imagem separada com ele.  Por ser um serviço separado, ele possui seu próprio arquivo docker e seu contexto </li><li>  Fontes do aplicativo ( <strong>fontes</strong> ) - a fonte será entregue usando uma imagem separada, montando o <code>volume</code> com elas em um contêiner com o aplicativo.  A imagem base é <code>alpine</code> ; no interior, existem apenas fontes com dependências instaladas e coletadas usando os recursos do webpack (criar artefatos) </li></ul><br><p>  Outros serviços de desenvolvimento são lançados em contêineres, retirando-os do <code>hub.docker.com</code> ;  na produção, por outro lado - eles estão sendo executados em servidores separados, agrupados em cluster.  Tudo o que resta para nós é dizer ao aplicativo <em>(através do ambiente)</em> em quais endereços / portas e com quais detalhes é necessário bater neles.  Ainda mais legal é usar a descoberta de serviços para esse fim, mas não nesse momento. </p><br><p>  Tendo decidido a parte teórica, proponho passar para a próxima parte. </p><br><h2 id="chast-prakticheskaya">  A parte prática </h2><br><p>  Sugiro organizar arquivos no repositório da seguinte maneira: </p><br><pre> <code class="hljs css">. ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">docker</span></span> #    <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>   │  ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">app</span></span> │  │  ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">Dockerfile</span></span> │  │  └── ... │  ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">nginx</span></span> │  │  ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">Dockerfile</span></span> │  │  └── ... │  └── <span class="hljs-selector-tag"><span class="hljs-selector-tag">sources</span></span> │    ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">Dockerfile</span></span> │    └── ... ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">src</span></span> #   │ ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">app</span></span> │ ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">bootstrap</span></span> │ ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">config</span></span> │ ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">artisan</span></span> │ └── ... ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">docker-compose</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.yml</span></span> # <span class="hljs-selector-tag"><span class="hljs-selector-tag">Compose-</span></span>    ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">Makefile</span></span> ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">CHANGELOG</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.md</span></span> └── <span class="hljs-selector-tag"><span class="hljs-selector-tag">README</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.md</span></span></code> </pre> <br><blockquote>  Você pode se familiarizar com a estrutura e os arquivos clicando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste link</a> . </blockquote><p>  Para criar um serviço, você pode usar o comando: </p><br><pre> <code class="bash hljs">$ docker build \ --tag %local_image_name% \ -f ./docker/%service_directory%/Dockerfile ./docker/%service_directory%</code> </pre> <br><p>  A única diferença será a montagem da imagem com as fontes - para isso, o contexto da montagem (argumento extremo) <code>./src</code> ser definido como <code>./src</code> . </p><br><p>  As regras para nomear imagens no registro local recomendam o uso das que o <code>docker-compose</code> usa por padrão, a saber: <code>%root_directory_name%_%service_name%</code> .  Se o diretório do projeto for chamado <code>my-awesome-project</code> e o serviço for chamado <code>redis</code> , o nome da imagem (local) será melhor para escolher <code>my-awesome-project_redis</code> respectivamente. </p><br><blockquote>  Para acelerar o processo de construção, você pode dizer ao docker para usar o cache da imagem montada anteriormente e, para isso, a <code>--cache-from %full_registry_name%</code> inicialização <code>--cache-from %full_registry_name%</code> .  Portanto, o daemon do docker procurará antes de iniciar uma instrução específica no Dockerfile - ele mudou?  E se não (o hash converge) - ele pulará a instrução, usando a camada já preparada da imagem, que será solicitada como cache.  Como isso não é ruim, ele reconstruirá o processo, especialmente se nada mudou :) <br><br>  Preste atenção aos scripts <code>ENTRYPOINT</code> para iniciar contêineres de aplicativos. </blockquote><p>  A imagem do ambiente para iniciar o aplicativo (aplicativo) foi coletada levando em consideração o fato de que ele funcionará não apenas na produção, mas também localmente, os desenvolvedores precisam interagir efetivamente com ele.  A instalação e remoção de dependências do <code>composer</code> , execução de testes de <code>unit</code> , registros de <code>tail</code> e uso de aliases familiares ( <code>php /app/artisan</code> → <code>art</code> , <code>composer</code> → <code>c</code> ) não devem causar nenhum desconforto.  Além disso - também será usado para executar testes de <code>unit</code> e analisadores de código estático ( <code>phpstan</code> no nosso caso) no CI.  É por isso que o Dockerfile, por exemplo, contém a <code>xdebug</code> instalação do <code>xdebug</code> , mas o próprio módulo não está ativado (ele é ativado apenas usando o CI). </p><br><blockquote>  Também para o <code>composer</code> o pacote <code>hirak/prestissimo</code> é <code>hirak/prestissimo</code> , o que aumenta muito a instalação de todas as dependências. </blockquote><p>  Na produção, montamos o conteúdo do diretório <code>/src</code> partir da imagem com as fontes (fontes) dentro dele no diretório <code>/app</code> .  Para desenvolvimento, “rolamos” o diretório local com fontes de aplicativo ( <code>-v "$(pwd)/src:/app:rw"</code> ). </p><br><p>  E aqui está uma complexidade - esses são os <strong>direitos de acesso aos arquivos</strong> criados a partir do contêiner.  O fato é que, por padrão, os processos em execução no contêiner iniciam a partir da raiz ( <code>root:root</code> ), os arquivos criados por esses processos (cache, logs, sessões etc.) - também e, como resultado - você não possui nada "localmente" com eles você pode fazer isso sem executar o <code>sudo chown -R $(id -u):$(id -g) /path/to/sources</code> . </p><br><p>  Como uma solução, use <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fixuid</a> , mas essa solução é direta.  Pareceu-me a melhor maneira de <code>USER_ID</code> local e seu <code>GROUP_ID</code> dentro do contêiner e <a href="">iniciar processos com esses valores</a> .  Por padrão, a substituição dos valores <code>1000:1000</code> (os valores padrão do primeiro usuário local) eliminou a chamada <code>$(id -u):$(id -g)</code> e, se necessário, você sempre pode substituí-los ( <code>$ USER_ID=666 docker-compose up -d</code> ) ou coloque o arquivo de composição de encaixe no arquivo <code>.env</code> . </p><br><p>  Além disso, quando o <code>php-fpm</code> iniciado localmente <code>php-fpm</code> não se esqueça de desativar o <code>opcache</code> - caso contrário, haverá muito "sim, que diabos!"  você será fornecido. </p><br><p>  Para uma conexão "direta" com o redis e o postgres, joguei portas adicionais "fora" ( <code>15432</code> e <code>15432</code> respectivamente), para que não haja problemas em "conectar e ver o que e como realmente é" em princípio. </p><br><p>  Eu mantenho o contêiner com o <code>app</code> codinome em execução ( <code>--command keep-alive.sh</code> ) com a finalidade de acesso conveniente ao aplicativo. </p><br><p>  Aqui estão alguns exemplos de solução de problemas diários com o <code>docker-compose</code> : </p><br><table><thead><tr><th>  Operação </th><th>  Comando em execução </th></tr></thead><tbody><tr><td>  Instale o pacote do <code>composer</code> </td><td> <code>$ docker-compose exec app composer require package/name</code> </td> </tr><tr><td>  Executando phpunit </td><td> <code>$ docker-compose exec app php ./vendor/bin/phpunit --no-coverage</code> </td> </tr><tr><td>  Instale todas as dependências do nó </td><td> <code>$ docker-compose run --rm node npm install</code> </td> </tr><tr><td>  Instalar pacote de nós </td><td> <code>$ docker-compose run --rm node npm i package_name</code> </td> </tr><tr><td>  Iniciando uma reconstrução ao vivo de ativos </td><td> <code>$ docker-compose run --rm node npm run watch</code> </td> </tr></tbody></table><br><p>  Você pode encontrar todos os detalhes de inicialização no <strong><a href="">arquivo docker-compose.yml</a></strong> . </p><br><h4 id="coy-make-zhiv"><del>  Choi </del>  <code>make</code> vivo! </h4><br><p>  Digitar os mesmos comandos todas as vezes se torna entediante após a segunda vez, e como os programadores são criaturas preguiçosas por natureza, vamos entrar em sua "automação".  Manter um conjunto de scripts <code>sh</code> é uma opção, mas não tão atraente quanto um único <code>Makefile</code> , especialmente porque sua aplicabilidade no desenvolvimento moderno é muito subestimada. </p><br><blockquote>  O manual completo em russo pode ser encontrado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste link</a> . </blockquote><p>  Vamos ver como a <code>make</code> run fica na raiz do repositório: </p><br><pre> <code class="bash hljs">[user@host ~/projects/app] $ make <span class="hljs-built_in"><span class="hljs-built_in">help</span></span> Show this <span class="hljs-built_in"><span class="hljs-built_in">help</span></span> app-pull Application - pull latest Docker image (from remote registry) app Application - build Docker image locally app-push Application - tag and push Docker image into remote registry sources-pull Sources - pull latest Docker image (from remote registry) sources Sources - build Docker image locally sources-push Sources - tag and push Docker image into remote registry nginx-pull Nginx - pull latest Docker image (from remote registry) nginx Nginx - build Docker image locally nginx-push Nginx - tag and push Docker image into remote registry pull Pull all Docker images (from remote registry) build Build all Docker images push Tag and push all Docker images into remote registry login Log <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> to a remote Docker registry clean Remove images from <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> registry --------------- --------------- up Start all containers (<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> background) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> development down Stop all started <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> development containers restart Restart all started <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> development containers shell Start shell into application container install Install application dependencies into application container watch Start watching assets <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> changes (node) init Make full application initialization (install, seed, build assets) <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> Execute application tests Allowed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> overriding next properties: PULL_TAG - Tag <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pulling images before building own (<span class="hljs-string"><span class="hljs-string">'latest'</span></span> by default) PUBLISH_TAGS - Tags list <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> building and pushing into remote registry (delimiter - single space, <span class="hljs-string"><span class="hljs-string">'latest'</span></span> by default) Usage example: make PULL_TAG=<span class="hljs-string"><span class="hljs-string">'v1.2.3'</span></span> PUBLISH_TAGS=<span class="hljs-string"><span class="hljs-string">'latest v1.2.3 test-tag'</span></span> app-push</code> </pre> <br><p>  Ele é muito bom em objetivos viciantes.  Por exemplo, para iniciar o <code>watch</code> ( <code>docker-compose run --rm node npm run watch</code> ), você precisa que o aplicativo seja "aumentado" - você só precisa especificar o destino <code>docker-compose run --rm node npm run watch</code> como dependente - e não precisa se preocupar em esquecer de fazer isso antes de chamar o <code>watch</code> - <code>make</code> si mesmo fará tudo por você.  O mesmo se aplica à execução de testes e analisadores estáticos, por exemplo, antes de realizar alterações - <code>make test</code> um <code>make test</code> e toda a mágica acontecerá com você! </p><br><p>  Escusado será dizer que você não precisa se preocupar em montar imagens, fazer download delas, especificar <code>--cache-from</code> e quase tudo? </p><br><p>  Você pode ver o conteúdo do <code>Makefile</code> <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste link</a></strong> . </p><br><h2 id="chast-avtomaticheskaya">  Peça de automóvel </h2><br><p>  Vamos para a parte final deste artigo - essa é a automação do processo de atualização de imagens no Docker Registry.  Embora no meu exemplo o GitLab CI seja usado - para transferir a idéia para outro serviço de integração, acho que será bem possível. </p><br><p>  Primeiro, determinaremos o nome das tags de imagem usadas: </p><br><table><thead><tr><th>  Nome da tag </th><th>  Destino </th></tr></thead><tbody><tr><td> <code>latest</code> </td> <td>  Imagens coletadas do ramo <code>master</code> . <br>  O estado do código é o mais recente, mas ainda não está pronto para entrar no lançamento </td></tr><tr><td> <code>some-branch-name</code> </td> <td>  Imagens coletadas no brunch <code>some-branch-name</code> . <br>  Assim, podemos "implantar" as alterações em qualquer ambiente que foram implementadas somente dentro da estrutura de um brunch específico, mesmo antes de mesclá-las com o <code>master</code> -light - basta "esticar" as imagens com essa tag. <br>  E - sim, as alterações podem estar relacionadas ao código e às imagens de todos os serviços em geral! </td></tr><tr><td> <code>vX.XX</code> </td> <td>  Na verdade, o lançamento do aplicativo (use para implantar uma versão específica) </td></tr><tr><td> <code>stable</code> </td> <td>  Alias, para a tag com a versão mais recente (use para implantar a versão estável mais recente) </td></tr></tbody></table><br><p>  O lançamento ocorre publicando uma tag no <code>vX.XX</code> formato <code>vX.XX</code> </p><br><p>  Para acelerar a construção, o cache dos diretórios <code>./src/vendor</code> e <code>./src/node_modules</code> + <code>--cache-from</code> para <code>docker build</code> e consiste nos seguintes estágios: </p><br><table><thead><tr><th>  Nome do estágio </th><th>  Destino </th></tr></thead><tbody><tr><td> <code>prepare</code> </td> <td>  A fase preparatória - a montagem de imagens de todos os serviços, <strong>exceto a</strong> imagem com a fonte </td></tr><tr><td> <code>test</code> </td> <td>  Testando o aplicativo (executando <code>phpunit</code> , analisadores de código estático) usando imagens <strong>coletadas no estágio de preparação</strong> </td></tr><tr><td> <code>build</code> </td> <td>  Instalando todas as dependências do <code>composer</code> ( <code>--no-dev</code> ), montando <code>assets</code> <code>webpack</code> e <code>webpack</code> imagem com o código-fonte, <strong>incluindo artefatos recebidos</strong> ( <code>vendor/*</code> , <code>app.js</code> , <code>app.css</code> ) </td></tr></tbody></table><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8c2/873/625/8c2873625893ec1a0605e24bf85ef541.png" alt="captura de tela de tubulações"></p><br><blockquote>  A montagem no ramo <code>master</code> produzindo <code>push</code> com as tags <code>master</code> e <code>latest</code> </blockquote><p>  Em média, todas as etapas da montagem levam <strong>4 minutos</strong> , o que é um resultado muito bom (a execução paralela de tarefas é tudo). </p><br><p>  Você pode se familiarizar com o conteúdo da configuração ( <strong><code>.gitlab-ci.yml</code></strong> ) do coletor <strong><a href="">neste link</a></strong> . </p><br><h2 id="vmesto-zaklyucheniya">  Em vez de uma conclusão </h2><br><p>  Como você pode ver, organizar o trabalho com um aplicativo php (usando o <code>Laravel</code> como exemplo) usando o Docker não é tão difícil.  Como teste, você pode bifurcar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">repositório</a> e substituir todas as ocorrências de <code>tarampampam/laravel-in-docker</code> por você - tente tudo "ao vivo" por conta própria. </p><br><p>  Para inicialização local - execute apenas 2 comandos: </p><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://gitlab.com/tarampampam/laravel-in-docker.git ./laravel-in-docker &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> <span class="hljs-variable"><span class="hljs-variable">$_</span></span> $ make init</code> </pre> <br><p>  Em seguida, abra <code>http://127.0.0.1:9999</code> no seu navegador favorito. </p><br><p>  <strong><em>... aproveitando a oportunidade</em></strong> </p><br><p>  <em>No momento, estou trabalhando no projeto TL "autocode" e estamos procurando talentosos desenvolvedores de php e administradores de sistema (o escritório de desenvolvimento está localizado em Yekaterinburg).</em>  <em>Se você se considera o primeiro ou o segundo - escreva nossa carta de RH com o texto "Quero ser uma equipe de desenvolvimento, retome:% link_on_summary%" para o e-mail <code>hr@avtocod.ru</code> , ajudamos na realocação.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt425101/">https://habr.com/ru/post/pt425101/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt425089/index.html">TI no mundo animal: pesquisa de formigas e TCP / IP</a></li>
<li><a href="../pt425091/index.html">O que diabos está acontecendo com as classificações de popularidade das linguagens de programação?</a></li>
<li><a href="../pt425093/index.html">Soluções de IoT para serviços habitacionais e comunitários: o que serão os medidores inteligentes e quem deve atendê-los?</a></li>
<li><a href="../pt425095/index.html">Seminário on-line aberto "Jogo" 2048 "</a></li>
<li><a href="../pt425099/index.html">O que eu entendi e que problemas encontrei ao criar um clone do Hacker News</a></li>
<li><a href="../pt425103/index.html">Pare o Google Predators de perseguir seus filhos</a></li>
<li><a href="../pt425105/index.html">Modo de fabricação Intel ME - uma ameaça oculta ou o que está por trás da vulnerabilidade CVE-2018-4251 no MacBook</a></li>
<li><a href="../pt425107/index.html">Fintech Digest: problemas de biometria no celular, leasing de telefones Samsung, valores mobiliários no blockchain</a></li>
<li><a href="../pt425109/index.html">O livro “Java na nuvem. Bota de Primavera, Nuvem de Primavera, Fundição em Nuvem »</a></li>
<li><a href="../pt425111/index.html">Truques publicitários que podem custar dinheiro e reputação</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>