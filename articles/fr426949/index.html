<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔡 🗾 💆🏽 Recréation du son THX Deep Note 👋🏾 👨🏿‍🎓 🙍🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Si vous avez déjà visité une salle de cinéma, vous avez probablement entendu Deep Note , la marque de commerce du son THX . C'est l'un des premiers so...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Recréation du son THX Deep Note</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426949/"><img src="https://habrastorage.org/webt/rt/lm/nf/rtlmnfcd-xj_8nfptcohqx1dees.jpeg" align="left">  Si vous avez déjà visité une salle de cinéma, vous avez probablement entendu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Deep Note</a> , la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">marque de commerce du son</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">THX</a> .  C'est l'un des premiers sons à être entendus au début des remorques dans les halls certifiés THX.  J'ai toujours aimé son crescendo reconnaissable, commençant par un terrible mélange de notes et se terminant par une finale lumineuse et grandiose ( <b><a href="">son</a></b> ).  Quel délice pour l'oreille! <br><br>  Hier (probablement) sans aucune raison je m'intéressais à l'origine de ce son, et j'ai fait quelques recherches.  J'ai été profondément touché par son histoire, que je veux partager avec vous.  Ensuite, nous continuons - et nous allons créer ce son nous-mêmes, préparer des ciseaux et de la colle! <br><a name="habracut"></a><br>  La meilleure source d'informations sur le son que j'ai pu trouver est, à mon avis, sa composition électro-acoustique complète, publiée dans l'excellent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Blog Music Thing</a> en 2005.  Voici le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien vers l'article</a> . <br><br>  Quelques faits sur le son: <br><br><ul><li>  Il a été créé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">par le Dr James Andy Moorer</a> en 1982. </li><li>  Un jour dans l'histoire, il a été perdu 4 000 fois par jour, presque toutes les 20 secondes!  Citation du Dr Moorer: <br><blockquote>  «Je voudrais dire que le son du THX est l'œuvre la plus populaire de l'informatique musicale au monde.  C'est peut-être vrai ou pas, mais ça a l'air cool! » </blockquote></li><li>  Il est créé sur un ordinateur ASP (Audio Signal Processor) qui peut synthétiser des sons en temps réel. </li><li>  Un programme de 20 000 lignes de code C a généré des données pour la lecture sur ASP.  Les données générées se composaient de 250 000 lignes qui ont été traitées par ASP. </li><li>  Les oscillateurs vocaux utilisent un ton de violoncelle numérisé comme signal.  Le Dr Murer rappelle qu'il y avait environ 12 harmoniques dans l'échantillon.  ASP pourrait exécuter 30 de ces oscillateurs en temps réel (à titre de comparaison, mon ordinateur portable peut désormais en traiter plus de 1000 sans échecs). </li><li>  Le son lui-même est protégé par le droit d'auteur, mais voici le problème: le code du Dr Murer repose sur des générateurs de nombres aléatoires (processus génératif) et chaque fois le son est légèrement différent.  Par conséquent, je ne pense pas qu'il soit sûr de dire que le processus lui-même est ou peut être «protégé par le droit d'auteur».  Le son lui-même, oui, l'échantillon spécifique est protégé. </li><li>  Le son a fait ses débuts dans la bande-annonce de THX <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Return of the Jedi"</a> avant sa première en 1983. </li><li>  Les caractéristiques génératives du processus sont devenues à un moment donné problématiques.  Après la sortie de The Return of the Jedi, l'enregistrement original de Deep Note a été perdu.  Le Dr Murer a recréé le travail pour l'entreprise, mais ils se plaignaient constamment qu'il ne ressemble pas à l'original.  Finalement, l'enregistrement original a été retrouvé et conservé dans un endroit sûr. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dr.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dre a</a> demandé la permission d'utiliser l'échantillon dans sa musique, mais il a été refusé.  Il l'a quand même utilisé et a obtenu un procès. </li><li>  Dans l'œuvre de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Metastaseis de</a> Janis Xenakis (1954), il y a un crescendo d'ouverture très similaire (comme dans d'autres œuvres de divers compositeurs).  Mais il commence par un ton unique et se termine par un cluster tonal semi-accordé au lieu d'être complètement consonant, comme dans Deep Note.  L'enregistrement sonore de la demande de brevet peut être entendu <a href="">ici</a> . </li></ul><br>  Assurez-vous d'écouter le son, car lorsque nous recréerons Deep Note, nous ferons référence à cet enregistrement particulier. <br><br>  Voici quelques faits techniques / théoriques avant de vous lancer dans la synthèse sonore: <br><br><ul><li>  Mon observation: sur l'entrée originale du site Web de l'Office des brevets, le ton principal est entre D et Eb, et dans les versions plus récentes, la valeur fondamentale est entre E et F. Nous utiliserons la constante D / Eb originale.  Les nouvelles options sont généralement plus courtes, sinon erronées.  Évidemment, je préfère l'option qui a été déposée auprès de l'office des brevets. </li><li>  Selon le Dr Murer (et également confirmé par mes oreilles), le fragment commence avec des oscillateurs accordés sur des fréquences aléatoires entre 200 Hz et 400 Hz.  Mais les oscillateurs ne bourdonnent pas seulement - leurs fréquences sont modulées de manière aléatoire, et ils utilisent des filtres de lissage pour atténuer les transitions aléatoires des tons.  Cela continue jusqu'au début du crescendo. </li><li>  À l'intérieur du crescendo et à la fin du segment sonore, les randomiseurs modulent toujours les fréquences des oscillateurs, de sorte qu'aucun d'entre eux n'est stable à un moment donné.  Mais la plage de balayage aléatoire est si étroite qu'elle ajoute simplement un son naturel / choral. </li><li>  Le Dr Murer rappelle qu'il y avait environ 12 harmoniques distinctes dans le spectre du son de violoncelle numérisé. </li><li>  Pour autant que je sache, les valeurs écrites du générateur (qui ont été utilisées pour obtenir des droits d'auteur) n'ont jamais été publiées.  Le Dr Moorer dit qu'il peut les enregistrer si nous obtenons la permission de THX.  Mais je pense qu'il n'est pas nécessaire de recréer le son. </li><li>  Le son dans la finale (techniquement pas un accord) - à mon oreille, juste l'ajout des octaves du ton fondamental.  Ainsi, lors de la reconstruction, nous commençons avec des oscillateurs accordés de façon aléatoire (entre 200 et 400 Hz), effectuons un balayage plus ou moins complexe et terminons en appliquant des octaves à la hauteur entre le D / Eb bas. </li></ul><br>  Commençons donc.  Mon outil de travail ici est SuperCollider.  Commençons par un simple échantillon.  Je veux utiliser une onde en dents de scie comme source, elle a un spectre riche et harmonique de composants pairs et impairs.  Plus tard, je prévois de filtrer les sommets.  Voici un extrait de la partie initiale du code: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//30 ,    ( { var numVoices = 30; //generating initial random fundamentals: var fundamentals = {rrand(200.0, 400.0)}!numVoices; Mix ({|numTone| var freq = fundamentals[numTone]; Pan2.ar ( Saw.ar(freq), rrand(-0.5, 0.5), //stereo placement of voices numVoices.reciprocal //scale the amplitude of each voice ) }!numVoices); }.play; )</span></span></code> </pre> <br>  J'ai choisi 30 oscillateurs pour générer du son, selon les capacités de l'ordinateur ASP, comme l'a dit le Dr Murer.  J'ai créé un tableau de 30 fréquences aléatoires entre 200 et 400 Hz, réparties au hasard sur le champ stéréo en utilisant Pan2.ar avec l'argument rrand (-0,5, 0,5), assigné des fréquences aux oscillateurs en dents de scie (30 copies).  <a href="">Voilà comment ça sonne</a> . <br><br>  Si vous étudiez les informations du Dr Moorer et / ou écoutez attentivement le fragment original, vous pouvez entendre que les fréquences de l'oscillateur sont décalées de façon aléatoire de haut en bas.  Je voudrais ajouter cet effet pour un son plus organique.  L'échelle de fréquence est logarithmique, donc aux fréquences plus basses il devrait y avoir des gammes d'oscillation plus étroites qu'aux plus hautes.  Cela peut être fait en triant nos fréquences générées aléatoirement avec LFNoise2 (qui génère des valeurs aléatoires interpolées quadratiquement) d'arguments mul dans l'ordre dans notre macro Mix.  Et j'ai également ajouté un filtre passe-bas pour les oscillateurs avec une fréquence de coupure de cinq fois la fréquence de l'oscillateur et modérée 1 / q: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    , ,    ( { var numVoices = 30; //sorting to get high freqs at top var fundamentals = ({rrand(200.0, 400.0)}!numVoices).sort; Mix ({|numTone| //fundamentals are sorted, so higher frequencies drift more. var freq = fundamentals[numTone] + LFNoise2.kr(0.5, 3 * (numTone + 1)); Pan2.ar ( BLowPass.ar(Saw.ar(freq), freq * 5, 0.5), rrand(-0.5, 0.5), numVoices.reciprocal ) }!numVoices); }.play; )</span></span></code> </pre> <br>  <a href="">Voici comment sonne l'échantillon</a> avec les dernières modifications. <br><br>  Cela ressemble déjà à un bon point de départ, alors passons à la mise en œuvre d'un balayage, très grossier au début.  Pour implémenter un balayage, vous devez d'abord déterminer les fréquences finales pour chaque oscillateur.  Ce n'est pas très simple, mais pas très difficile non plus.  La tonalité principale doit être comprise entre les graves D et Eb, donc la fréquence moyenne de cette tonalité sera de 14,5 (0 est C, en comptant chromatiquement, sans la première octave).  Ainsi, pour 30 oscillateurs, nous traduisons des fréquences aléatoires comprises entre 200 et 400 Hz en une valeur de 14,5 et les octaves correspondantes.  A l'oreille, j'ai choisi les 6 premières octaves.  Ainsi, le tableau final de fréquences est le suivant: <br><br><pre> <code class="cpp hljs">(numVoices.collect({|nv| (nv/(numVoices/<span class="hljs-number"><span class="hljs-number">6</span></span>)).round * <span class="hljs-number"><span class="hljs-number">12</span></span>; }) + <span class="hljs-number"><span class="hljs-number">14.5</span></span>).midicps;</code> </pre> <br>  Nous utiliserons le balayage de 0 à 1. Les fréquences aléatoires sont multipliées par la valeur <code>(1 − )</code> et les fréquences cibles sont multipliées par le balayage lui-même.  Par conséquent, lorsque le balayage est 0 (au début), la fréquence sera aléatoire.  Lorsque le balayage est de 0,5, il s'avère <code>(( +  ) / 2)</code> , et lorsqu'il est de 1, la fréquence sera la valeur finale.  Voici le code modifié: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   (),    ( { var numVoices = 30; var fundamentals = ({rrand(200.0, 400.0)}!numVoices).sort; var finalPitches = (numVoices.collect({|nv| (nv/(numVoices/6)).round * 12; }) + 14.5).midicps; var sweepEnv = EnvGen.kr(Env([0, 1], [13])); Mix ({|numTone| var initRandomFreq = fundamentals[numTone] + LFNoise2.kr(0.5, 3 * (numTone + 1)); var destinationFreq = finalPitches[numTone]; var freq = ((1 - sweepEnv) * initRandomFreq) + (sweepEnv * destinationFreq); Pan2.ar ( BLowPass.ar(Saw.ar(freq), freq * 5, 0.5), rrand(-0.5, 0.5), numVoices.reciprocal //scale the amplitude of each voice ) }!numVoices); }.play; )</span></span></code> </pre> <br>  Le son est <a href="">là</a> . <br><br>  Comme je l'ai dit, c'est une analyse très approximative.  Il augmente linéairement de 0 à 1, ce qui n'est pas conforme à la composition d'origine.  Vous avez peut-être également remarqué que les dernières octaves sonnent mal parce qu'elles sont réglées sur des octaves parfaites et se confondent comme des tons de base et des harmoniques.  Nous allons résoudre ce problème en ajoutant un swing aléatoire au stade final - tout comme cela a été fait au début, et cela semblera beaucoup plus organique. <br><br>  Vous devez d'abord fixer la formule générale de balayage de fréquence.  Le précédent était juste pour le procès.  Si nous regardons l'original, nous notons que dans les 5-6 premières secondes, il y a très peu de changements dans le son.  Après cela, un balayage rapide et exponentiel a lieu, ce qui conduit les oscillateurs à des intervalles d'octave finis.  Voici l'option que j'ai choisie: <br><br><pre> <code class="cpp hljs">sweepEnv = EnvGen.kr(Env([<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>], [<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]));</code> </pre> <br>  Ici, une transition de 0 à 0,1 prend 5 secondes et une transition de 0,1 à 1 prend 8 secondes.  Les courbures de ces segments sont définies sur 2 et 5. Plus tard, nous écoutons ce qui s'est passé, mais nous devons d'abord fixer à nouveau les intervalles finaux.  Comme précédemment, nous ajoutons des oscillations aléatoires avec LFNoise2, dont la plage est proportionnelle à la fréquence finale de l'oscillateur.  Cela rendra la finale plus organique.  Voici le code modifié: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     ( { var numVoices = 30; var fundamentals = ({rrand(200.0, 400.0)}!numVoices).sort; var finalPitches = (numVoices.collect({|nv| (nv/(numVoices/6)).round * 12; }) + 14.5).midicps; var sweepEnv = EnvGen.kr(Env([0, 0.1, 1], [5, 8], [2, 5])); Mix ({|numTone| var initRandomFreq = fundamentals[numTone] + LFNoise2.kr(0.5, 3 * (numTone + 1)); var destinationFreq = finalPitches[numTone] + LFNoise2.kr(0.1, (numTone / 4)); var freq = ((1 - sweepEnv) * initRandomFreq) + (sweepEnv * destinationFreq); Pan2.ar ( BLowPass.ar(Saw.ar(freq), freq * 8, 0.5), rrand(-0.5, 0.5), numVoices.reciprocal ) }!numVoices); }.play; )</span></span></code> </pre> <br>  Ici, j'ai également ajusté la fréquence de coupure du filtre passe-bas à mon goût.  J'aime arranger les choses si le résultat n'empire pas ... En tout cas, <a href="">c'est ce qui s'est passé</a> . <br><br>  Je n'aime pas vraiment ce modèle de scan.  Besoin d'étirer le départ et d'accélérer l'arrivée.  Ou attendez ... est-il vraiment nécessaire d'implémenter le même circuit pour tous les oscillateurs?  Absolument pas!  Chaque oscillateur devrait avoir son propre circuit avec des valeurs de temps et de courbure légèrement différentes - je suis sûr que ce sera plus intéressant.  Les harmoniques à haute fréquence d'un cluster aléatoire en dents de scie sont encore un peu ennuyeuses, nous ajoutons donc au résultat global un filtre passe-bas, dont la coupure est contrôlée par une valeur globale "externe" qui n'a rien à voir avec les circuits d'oscillateur.  Voici le code modifié: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// .      ( { var numVoices = 30; var fundamentals = ({rrand(200.0, 400.0)}!numVoices).sort; var finalPitches = (numVoices.collect({|nv| (nv/(numVoices/6)).round * 12; }) + 14.5).midicps; var outerEnv = EnvGen.kr(Env([0, 0.1, 1], [8, 4], [2, 4])); var snd = Mix ({|numTone| var initRandomFreq = fundamentals[numTone] + LFNoise2.kr(0.5, 3 * (numTone + 1)); var destinationFreq = finalPitches[numTone] + LFNoise2.kr(0.1, (numTone / 4)); var sweepEnv = EnvGen.kr( Env([0, rrand(0.1, 0.2), 1], [rrand(5.0, 6), rrand(8.0, 9)], [rrand(2.0, 3.0), rrand(4.0, 5.0)])); var freq = ((1 - sweepEnv) * initRandomFreq) + (sweepEnv * destinationFreq); Pan2.ar ( BLowPass.ar(Saw.ar(freq), freq * 8, 0.5), rrand(-0.5, 0.5), numVoices.reciprocal ) }!numVoices); BLowPass.ar(snd, 2000 + (outerEnv * 18000), 0.5); }.play; )</span></span></code> </pre> <br>  Un petit changement a rendu le scan un peu plus intéressant.  Un filtre passe-bas de 2000 Hz permet d'apprivoiser le cluster initial.  <a href="">Voilà comment ça sonne</a> . <br><br>  Il reste encore une chose qui rendra le processus plus intéressant.  Rappelez-vous, nous avons trié les oscillateurs aléatoires au début?  Eh bien, maintenant nous pouvons les trier dans l'ordre inverse et nous assurer que les oscillateurs à des fréquences aléatoires plus élevées se retrouvent dans les voix inférieures après le crescendo, et vice versa.  Cela ajoutera plus de «mouvement» au crescendo et correspond à la structure du fragment d'origine.  Je ne suis pas sûr que le Dr Murer l'ait programmé de cette façon, mais il y a ce processus dans le dossier, et cela semble cool, qu'il s'agisse d'un produit aléatoire d'un processus génératif ou d'un choix spécial.  (Oh, ai-je dit cela? Si le processus offre une telle option, alors c'est le choix ... ou pas?).  Ainsi, nous allons changer l'ordre de tri et la structure du code afin que les dents de scie avec des fréquences plus élevées tombent dans des voix plus basses en finale, et vice versa. <br><br>  Encore une chose: vous avez besoin d'une basse plus forte.  Maintenant, toutes les voix ont la même amplitude.  Je veux que les sons graves sonnent un peu plus fort et s'estompent proportionnellement à l'augmentation de la fréquence.  Par conséquent, nous modifions l'argument mul pour Pan2 en conséquence.  Réajustez les fréquences de coupure des filtres passe-bas pour les oscillateurs individuels.  Et je vais ajouter un schéma de mise à l'échelle d'amplitude qui prendra progressivement effet et disparaîtra à la fin, et se libèrera de scserver.  Quelques paramètres numériques de plus ici et là - et voici le code final: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// init sort,   ,   ,    ( { var numVoices = 30; var fundamentals = ({rrand(200.0, 400.0)}!numVoices).sort.reverse; var finalPitches = (numVoices.collect({|nv| (nv/(numVoices/6)).round * 12; }) + 14.5).midicps; var outerEnv = EnvGen.kr(Env([0, 0.1, 1], [8, 4], [2, 4])); var ampEnvelope = EnvGen.kr(Env([0, 1, 1, 0], [3, 21, 3], [2, 0, -4]), doneAction: 2); var snd = Mix ({|numTone| var initRandomFreq = fundamentals[numTone] + LFNoise2.kr(0.5, 6 * (numVoices - (numTone + 1))); var destinationFreq = finalPitches[numTone] + LFNoise2.kr(0.1, (numTone / 3)); var sweepEnv = EnvGen.kr( Env([0, rrand(0.1, 0.2), 1], [rrand(5.5, 6), rrand(8.5, 9)], [rrand(2.0, 3.0), rrand(4.0, 5.0)])); var freq = ((1 - sweepEnv) * initRandomFreq) + (sweepEnv * destinationFreq); Pan2.ar ( BLowPass.ar(Saw.ar(freq), freq * 6, 0.6), rrand(-0.5, 0.5), (1 - (1/(numTone + 1))) * 1.5 ) / numVoices }!numVoices); Limiter.ar(BLowPass.ar(snd, 2000 + (outerEnv * 18000), 0.5, (2 + outerEnv) * ampEnvelope)); }.play; )</span></span></code> </pre> <br>  Et voici l' <a href="">enregistrement final de l'œuvre</a> . <br><br>  Vous pouvez comparer avec l' <a href="">original</a> . <br><br>  Oui, c'est mon interprétation.  Et bien sûr, il peut être optimisé à mort en changeant les modèles, les fréquences, la distribution, peu importe ... néanmoins, je pense que c'est une tentative digne de préserver l'héritage sonore.  J'aimerais entendre vos commentaires et / ou vos propres tentatives pour synthétiser ce crescendo. <br><br><hr><br>  Oui, et voici une autre chose que j'ai faite pour le plaisir.  Rappelez-vous, je vous ai dit qu'il a fallu 20 000 lignes de code C pour générer l'original. Je suis sûr que le Dr Moorer a dû tout écrire à la main, donc ce nombre n'est pas surprenant.  Mais vous savez, en raison de la popularité de Twitter, nous essayons de tout compresser en 140 caractères de code.  Pour le plaisir, j'ai essayé de reproduire les éléments de base de la composition en 140 caractères du code.  Je pense que l'échantillon sonne toujours cool, voici le code (ici avec le ton principal F / E): <br><br><pre> <code class="cpp hljs">play{Mix({|k|k=k+<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span>;<span class="hljs-number"><span class="hljs-number">2</span></span>/k*Mix({|i|i=i+<span class="hljs-number"><span class="hljs-number">1</span></span>;Blip.ar(i*XLine.kr(rand(<span class="hljs-number"><span class="hljs-number">2e2</span></span>,<span class="hljs-number"><span class="hljs-number">4e2</span></span>),<span class="hljs-number"><span class="hljs-number">87</span></span>+LFNoise2.kr(<span class="hljs-number"><span class="hljs-number">2</span></span>)*k,<span class="hljs-number"><span class="hljs-number">15</span></span>),<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>/(i/a=XLine.kr(<span class="hljs-number"><span class="hljs-number">0.3</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>))/<span class="hljs-number"><span class="hljs-number">9</span></span>)}!<span class="hljs-number"><span class="hljs-number">9</span></span>)}!<span class="hljs-number"><span class="hljs-number">40</span></span>)!<span class="hljs-number"><span class="hljs-number">2</span></span>*a}</code> </pre> <br>  Et <a href="">voici le son</a> que cette version génère. <br><br>  Dans <a href="">un seul document</a> - tout le code de cette page pour vos expériences. <br><br>  Bon crescendo, amis! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr426949/">https://habr.com/ru/post/fr426949/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr426939/index.html">Un étudiant diplômé a résolu le problème de la confirmation de l'informatique quantique</a></li>
<li><a href="../fr426941/index.html">Sur la question de la vitesse et de sa mesure en Arduino</a></li>
<li><a href="../fr426943/index.html">La traduction russe la plus complète du cours de programmation Harvard CS50 2015 2015, gratuite sur YouTube</a></li>
<li><a href="../fr426945/index.html">Ce que j'ai aimé chez Paul Allen</a></li>
<li><a href="../fr426947/index.html">"Le diable m'a poussé à aller travailler au bureau" - 10 questions au programmeur, 9ème édition</a></li>
<li><a href="../fr426951/index.html">Altium Designer: que faire si un projet se complique?</a></li>
<li><a href="../fr426953/index.html">Exemple d'archivage Linux et méthodes d'installation</a></li>
<li><a href="../fr426957/index.html">Introduction aux serveurs WSGI: première partie</a></li>
<li><a href="../fr426959/index.html">Installer kubernetes via kubespray (stockage local, installer Elasticsearch + Fluentd + Kibana, prometheus)</a></li>
<li><a href="../fr426961/index.html">Comment Microsoft a réécrit le compilateur C # en C # et l'a ouvert</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>