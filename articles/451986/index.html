<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº üèÄ üë† ¬°Obtener datos con ORM es f√°cil! O no? üôà ü§öüèø üíÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 


 Casi cualquier sistema de informaci√≥n de una forma u otra interact√∫a con almacenes de datos externos. En la mayor√≠a de los casos, est...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬°Obtener datos con ORM es f√°cil! O no?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/451986/"><p><img src="https://habrastorage.org/webt/uv/4h/wb/uv4hwblmcfkf-f6018hxpbkf1s8.jpeg"></p><br><h2 id="vvedenie">  Introduccion </h2><br><p>  Casi cualquier sistema de informaci√≥n de una forma u otra interact√∫a con almacenes de datos externos.  En la mayor√≠a de los casos, esta es una base de datos relacional y, a menudo, se utiliza alg√∫n tipo de marco ORM para trabajar con datos.  ORM elimina la mayor√≠a de las operaciones de rutina, en su lugar ofrece un peque√±o conjunto de abstracciones adicionales para trabajar con datos. </p><br><p>  Martin Fowler public√≥ un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo</a> interesante, uno de los pensamientos clave all√≠: "Los ORM nos ayudan a resolver una gran cantidad de problemas en las aplicaciones empresariales ... Esta herramienta no puede llamarse bonita, pero los problemas con los que trata tampoco son agradables".  Creo que ORM merece m√°s respeto y m√°s comprensi√≥n ". </p><br><p>  Utilizamos ORM de forma muy intensiva en el marco de trabajo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CUBA</a> , por lo que conocemos de primera mano los problemas y limitaciones de esta tecnolog√≠a, ya que CUBA se usa en varios proyectos en todo el mundo.  Hay muchos temas que pueden discutirse en relaci√≥n con ORM, pero nos centraremos en uno de ellos: la elecci√≥n entre los m√©todos de muestreo de datos "vagos" (vagos) y "codiciosos" (ansiosos).  Hablaremos sobre diferentes enfoques para resolver este problema con ilustraciones de JPA API y Spring, y tambi√©n describiremos c√≥mo (y por qu√© exactamente) se usa ORM en CUBA y qu√© trabajo estamos haciendo para mejorar el trabajo con datos en nuestro marco. </p><a name="habracut"></a><br><h2 id="vyborka-dannyh-lenivaya-ili-net">  Muestreo de datos: ¬øperezoso o no? </h2><br><p> Si su modelo de datos tiene solo una entidad, lo m√°s probable es que no note ning√∫n problema al trabajar con ORM.  Veamos un peque√±o ejemplo.  Supongamos que tenemos una entidad de <code>User ()</code> que tiene dos atributos: <code>ID</code> y <code>Name ()</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-comment"><span class="hljs-comment">//Getters and Setters here }</span></span></code> </pre> <br><p>  Para obtener una instancia de esta entidad de la base de datos, solo necesitamos llamar a un m√©todo del objeto <code>EntityManager</code> : </p><br><pre> <code class="java hljs">EntityManager em = entityManagerFactory.createEntityManager(); User user = em.find(User.class, id);</code> </pre> <br><p>  Las cosas se ponen un poco m√°s interesantes cuando aparece una relaci√≥n uno a muchos: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-meta"><span class="hljs-meta">@OneToMany</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Address&gt; addresses; <span class="hljs-comment"><span class="hljs-comment">//Getters and Setters here }</span></span></code> </pre> <br><p>  Si necesitamos extraer una instancia de usuario de la base de datos, surge la pregunta: "¬øTambi√©n seleccionamos direcciones?".  Y la respuesta "correcta" aqu√≠ es: "Depende de ..." En algunos casos necesitaremos direcciones, en otros, no.  Normalmente, ORM proporciona dos formas de obtener registros dependientes: perezoso y codicioso.  Por defecto, la mayor√≠a de los ORM usan la forma perezosa.  Pero, si escribimos este c√≥digo: </p><br><pre> <code class="java hljs">EntityManager em = entityManagerFactory.createEntityManager(); User user = em.find(User.class, <span class="hljs-number"><span class="hljs-number">1</span></span>); em.close(); System.out.println(user.getAddresses().get(<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre> <br><p>  ... entonces tenemos la excepci√≥n <code>‚ÄúLazyInitException‚Äù</code> , que confunde terriblemente a los reci√©n llegados que acaban de comenzar a trabajar con ORM.  Y aqu√≠ llega el momento en que necesita comenzar una historia sobre qu√© son las instancias "Adjuntas" y "Separadas" de una entidad, qu√© son las sesiones y las transacciones. <br>  S√≠, eso significa que la entidad debe estar "adjunta" a la sesi√≥n para que pueda seleccionar los datos dependientes.  Bueno, no cerremos las transacciones de inmediato, y la vida se volver√° m√°s f√°cil de inmediato.  Y aqu√≠ surge otro problema: las transacciones se vuelven m√°s largas, lo que aumenta el riesgo de punto muerto.  ¬øHacer transacciones m√°s cortas?  Es posible, pero si crea muchas, muchas peque√±as transacciones, obtenemos el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Cuento de Komar Komarovich - una nariz larga y sobre una peluda Misha - una cola corta"</a> sobre c√≥mo gan√≥ la horda de peque√±os mosquitos oso - suceder√° con la base de datos.  Si el n√∫mero de transacciones peque√±as aumenta significativamente, surgir√°n problemas de rendimiento. <br>  Como se dijo, cuando se obtienen datos sobre un usuario, las direcciones pueden ser necesarias o no, por lo tanto, dependiendo de la l√≥gica empresarial, debe seleccionar la colecci√≥n o no.  Es necesario agregar nuevas condiciones al c√≥digo ... Hmmm ... Algo se est√° complicando de alguna manera. </p><br><p>  Entonces, ¬øqu√© pasa si prueba un tipo diferente de muestra? </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-meta"><span class="hljs-meta">@OneToMany</span></span>(fetch = FetchType.EAGER) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Address&gt; addresses; <span class="hljs-comment"><span class="hljs-comment">//Getters and Setters here }</span></span></code> </pre> <br><p>  Bueno ... no puedes decir que ayudar√° mucho.  S√≠, eliminaremos el odiado <code>LazyInit</code> y no es necesario verificar si la entidad est√° conectada a la sesi√≥n o no.  Pero ahora podemos tener problemas de rendimiento, porque no siempre necesitamos direcciones, pero a√∫n seleccionamos estos objetos en la memoria del servidor. <br>  ¬øAlguna idea m√°s? </p><br><h2 id="spring-jdbc">  Spring jdbc </h2><br><p>  Algunos desarrolladores se cansan tanto de ORM que cambian a marcos alternativos.  Por ejemplo, en Spring JDBC, que proporciona la capacidad de convertir datos relacionales en datos de objeto en modo "semiautom√°tico".  El desarrollador escribe consultas para cada caso donde se necesita un conjunto particular de atributos (o el mismo c√≥digo se reutiliza para casos donde se necesitan las mismas estructuras de datos). </p><br><p>  Esto nos da una gran flexibilidad.  Por ejemplo, puede seleccionar solo un atributo sin crear el objeto de entidad correspondiente: </p><br><pre> <code class="java hljs">String name = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jdbcTemplate.queryForObject( <span class="hljs-string"><span class="hljs-string">"select name from t_user where id = ?"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[]{<span class="hljs-number"><span class="hljs-number">1L</span></span>}, String.class);</code> </pre> <br><p>  O seleccione un objeto en la forma habitual: </p><br><pre> <code class="java hljs">User user = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jdbcTemplate.queryForObject( <span class="hljs-string"><span class="hljs-string">"select id, name from t_user where id = ?"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[]{<span class="hljs-number"><span class="hljs-number">1L</span></span>}, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RowMapper&lt;User&gt;() { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> User </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapRow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ResultSet rs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rowNum)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> SQLException </span></span>{ User user = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(); user.setName(rs.getString(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)); user.setId(rs.getInt(<span class="hljs-string"><span class="hljs-string">"id"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> user; } });</code> </pre> <br><p>  Tambi√©n puede seleccionar una lista de direcciones para el usuario, solo necesita escribir un poco m√°s de c√≥digo y componer correctamente la consulta SQL para evitar el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">problema de las consultas n + 1</a> . </p><br><p>  Taaaan, complicado otra vez.  S√≠, controlamos todas las consultas y c√≥mo se asignan los datos a los objetos, pero necesitamos escribir m√°s c√≥digo, aprender SQL y saber c√≥mo se ejecutan las consultas en la base de datos.  Personalmente, creo que el conocimiento de SQL es una habilidad necesaria para un programador de aplicaciones, pero no todos piensan de esa manera, y no voy a involucrarme en pol√©micas.  Despu√©s de todo, el conocimiento de las instrucciones de montaje x86 en estos d√≠as tambi√©n es opcional.  Pensemos mejor en c√≥mo hacer la vida m√°s f√°cil para los programadores. </p><br><h2 id="jpa-entitygraph">  JPA EntityGraph </h2><br><p>  Y demos un paso atr√°s y pensemos, ¬øqu√© necesitamos?  Parece que solo necesitamos indicar exactamente qu√© atributos necesitamos en cada caso.  Bueno, hag√°moslo!  JPA 2.1 introdujo una nueva API: EntityGraph (gr√°fico de entidad).  La idea es muy simple: utilizamos anotaciones para describir lo que elegiremos de la base de datos.  Aqu√≠ hay un ejemplo: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@NamedEntityGraphs</span></span>({ <span class="hljs-meta"><span class="hljs-meta">@NamedEntityGraph</span></span>(name = <span class="hljs-string"><span class="hljs-string">"user-only-entity-graph"</span></span>), <span class="hljs-meta"><span class="hljs-meta">@NamedEntityGraph</span></span>(name = <span class="hljs-string"><span class="hljs-string">"user-addresses-entity-graph"</span></span>, attributeNodes = {<span class="hljs-meta"><span class="hljs-meta">@NamedAttributeNode</span></span>(<span class="hljs-string"><span class="hljs-string">"addresses"</span></span>)}) }) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-meta"><span class="hljs-meta">@OneToMany</span></span>(fetch = FetchType.LAZY) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Set&lt;Address&gt; addresses; <span class="hljs-comment"><span class="hljs-comment">//Getters and Setters here }</span></span></code> </pre> <br><p>  Se describen dos gr√°ficos para esta entidad: el <code>user-only-entity-graph</code> no selecciona el atributo <code>Addresses</code> (marcado como vago), mientras que el segundo gr√°fico le dice a ORM que seleccione este atributo.  Si marcamos <code>Addresses</code> como ansiosas, el gr√°fico se ignorar√° y las direcciones se seleccionar√°n de todos modos. </p><br><p>  Entonces, en JPA 2.1, puede muestrear datos como este: </p><br><pre> <code class="java hljs">EntityManager em = entityManagerFactory.createEntityManager(); EntityGraph graph = em.getEntityGraph(<span class="hljs-string"><span class="hljs-string">"user-addresses-entity-graph"</span></span>); Map&lt;String, Object&gt; properties = Map.of(<span class="hljs-string"><span class="hljs-string">"javax.persistence.fetchgraph"</span></span>, graph); User user = em.find(User.class, <span class="hljs-number"><span class="hljs-number">1</span></span>, properties); em.close();</code> </pre> <br><p>  Este enfoque simplifica enormemente el trabajo, no es necesario pensar por separado acerca de los atributos perezosos y la duraci√≥n de la transacci√≥n.  Una ventaja adicional es que el gr√°fico se aplica al nivel de la consulta SQL, por lo que no se seleccionan datos "adicionales" en la aplicaci√≥n Java.  Pero hay un peque√±o problema: no puede decir qu√© atributos se seleccionaron y cu√°les no.  Hay una API para verificar, esto se hace usando la clase <code>PersistenceUtil</code> : </p><br><pre> <code class="java hljs">PersistenceUtil pu = entityManagerFactory.getPersistenceUnitUtil(); System.out.println(<span class="hljs-string"><span class="hljs-string">"User.addresses loaded: "</span></span> + pu.isLoaded(user, <span class="hljs-string"><span class="hljs-string">"addresses"</span></span>));</code> </pre> <br><p>  Pero esto es bastante aburrido y no todos est√°n listos para hacer tales controles.  ¬øHay algo m√°s que pueda simplificar y simplemente no mostrar atributos que no fueron seleccionados? </p><br><h2 id="proekcii-spring">  Proyecciones de primavera </h2><br><p>  Spring Framework tiene una gran cosa llamada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Proyecciones</a> (y esto no es lo mismo que las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">proyecciones en Hibernate</a> ).  Si necesita seleccionar solo algunos atributos de una entidad, se crea una interfaz con los atributos necesarios y Spring selecciona "instancias" de esta interfaz de la base de datos.  Como ejemplo, considere la siguiente interfaz: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NamesOnly</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p>  Ahora puede definir un repositorio Spring JPA para obtener entidades de usuario de la siguiente manera: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">Collection&lt;NamesOnly&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String lastname)</span></span></span></span>; }</code> </pre> <br><p>  ¬°En este caso, despu√©s de llamar al m√©todo findByName, en la lista resultante obtenemos entidades que solo tienen acceso a los atributos definidos en la interfaz!  De acuerdo con el mismo principio, uno puede elegir entidades dependientes, es decir  seleccione inmediatamente la relaci√≥n "maestro-detalle".  Adem√°s, Spring genera SQL "correcto" en la mayor√≠a de los casos, es decir  solo aquellos atributos que se describen en la proyecci√≥n se seleccionan de la base de datos, esto es muy similar a c√≥mo funcionan los gr√°ficos de entidad. <br>  Esta es una API muy poderosa. Al definir interfaces, puede usar expresiones SpEL, usar clases con alg√∫n tipo de l√≥gica incorporada en lugar de interfaces, y mucho m√°s, todo se describe en detalle en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> . <br>  El √∫nico problema con las proyecciones es que en su interior se implementan como pares clave-valor, es decir.  son de solo lectura.  Esto significa que incluso si definimos un m√©todo de establecimiento para la proyecci√≥n, no podremos guardar los cambios ni a trav√©s de los repositorios CRUD ni a trav√©s del EntityManager.  Por lo tanto, las proyecciones son DTO que se pueden convertir de nuevo a Entity y guardar solo si escribe su propio c√≥digo para esto. </p><br><h2 id="kak-vybirayutsya-dannye-v-cuba">  C√≥mo seleccionar datos en CUBA </h2><br><p>  Desde el comienzo del desarrollo del marco CUBA, intentamos optimizar la parte del c√≥digo que funciona con la base de datos.  En CUBA, utilizamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">EclipseLink</a> como base para la API de acceso a datos.  Lo bueno de EclipseLink es que admiti√≥ la carga parcial de entidades desde el principio, y este fue un factor decisivo para elegir entre √©l e Hibernate.  En EclipseLink, podr√≠a especificar atributos para cargar mucho antes de que apareciera el est√°ndar JPA 2.1.  CUBA tiene su propia forma de describir un gr√°fico de entidad, denominado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Vistas de CUBA</a> .  Representaciones CUBA es una API bastante desarrollada, puede heredar algunas representaciones de otras, combinarlas, aplicando a entidades maestras y de detalle.  Otra motivaci√≥n para crear vistas de CUBA es que quer√≠amos usar transacciones cortas para poder trabajar con entidades separadas en la interfaz de usuario web. <br>  En CUBA, las vistas se describen en un archivo XML, como en el siguiente ejemplo: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">view</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.sample.User"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">extends</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"_minimal"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"user-minimal-view"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"name"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"addresses"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">view</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"address-street-only-view"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">view</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Esta vista selecciona la entidad <code>User</code> y su <code>name</code> atributo local, y tambi√©n selecciona direcciones al aplicarles la vista de <code>address-street-only-view</code> .  Todo esto sucede (¬°atenci√≥n!) A nivel de la consulta SQL.  Cuando se crea la vista, puede usarla en la selecci√≥n de datos utilizando la clase DataManager: </p><br><pre> <code class="java hljs">List&lt;User&gt; users = dataManager.load(User.class).view(<span class="hljs-string"><span class="hljs-string">"user-edit-view"</span></span>).list();</code> </pre> <br><p>  Este enfoque funciona bien, mientras consume el tr√°fico de red de manera econ√≥mica, ya que los atributos no utilizados simplemente no se transfieren de la base de datos a la aplicaci√≥n, pero, como en el caso de JPA, hay un problema: no se puede decir qu√© atributos de la entidad se cargaron.  Y en CUBA hay una excepci√≥n <code>‚ÄúIllegalStateException: Cannot get unfetched attribute [...] from detached object‚Äù</code> , que, como <code>LazyInit</code> , debe haber sido encontrado por todos los que escriben utilizando nuestro marco.  Al igual que en el JPA, hay formas de verificar qu√© atributos se cargaron y cu√°les no, pero, nuevamente, escribir dichos controles es una tarea tediosa y laboriosa que molesta mucho a los desarrolladores.  Hay que inventar algo m√°s para no agobiar a las personas con el trabajo que, en teor√≠a, las m√°quinas pueden hacer. </p><br><h2 id="koncept---cuba-view-interfaces">  Concepto - CUBA View Interfaces </h2><br><p>  Pero, ¬øqu√© pasa si intentas combinar gr√°ficos de entidad y proyecciones?  Decidimos probar esto y desarrollamos interfaces para las interfaces de vista de entidad que siguen el enfoque de proyecci√≥n Spring.  Estas interfaces se traducen en vistas CUBA al inicio de la aplicaci√≥n y se pueden usar en el DataManager.  La idea es simple: describimos una interfaz (o un conjunto de interfaces), que es un gr√°fico de entidad. </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserMinimalView</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseEntityView</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String val)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">List&lt;AddressStreetOnly&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAddresses</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddressStreetOnly</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseEntityView</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Address</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getStreet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setStreet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String street)</span></span></span></span>; } }</code> </pre> <br><p>  Vale la pena se√±alar que para algunos casos espec√≠ficos, puede hacer interfaces locales, como en el caso de <code>AddressStreetOnly</code> del ejemplo anterior, para no "contaminar" la API p√∫blica de su aplicaci√≥n. </p><br><p>  En el proceso de iniciar una aplicaci√≥n CUBA (la mayor√≠a de las cuales es la inicializaci√≥n del contexto Spring), creamos program√°ticamente vistas CUBA y las colocamos en el repositorio interno de beans en contexto. <br>  Ahora necesita modificar ligeramente la implementaci√≥n de la clase DataManager para que acepte vistas de interfaz, y puede seleccionar entidades de esta manera: </p><br><pre> <code class="java hljs">List&lt;UserMinimalView&gt; users = dataManager.load(UserMinimalView.class).list();</code> </pre> <br><p>  Bajo el cap√≥, se genera un objeto proxy que implementa la interfaz y envuelve la instancia de la entidad seleccionada de la base de datos (de la misma manera que en Hibernate).  Y, cuando el desarrollador solicita el valor del atributo, el proxy delega la llamada al m√©todo en la instancia "real" de la entidad. </p><br><p>  Al desarrollar este concepto, estamos tratando de matar dos p√°jaros de un tiro: </p><br><ul><li>  Los datos que no se describen en la interfaz no se cargan en la aplicaci√≥n, lo que ahorra recursos del servidor. </li><li>  El desarrollador puede usar solo aquellos atributos que son accesibles a trav√©s de la interfaz (y, por lo tanto, se seleccionan de la base de datos), eliminando as√≠ las excepciones <code>UnfetchedAttribute</code> que escribimos anteriormente. </li></ul><br><p>  A diferencia de las proyecciones de Spring, envolvemos entidades en objetos proxy, adem√°s, cada interfaz hereda la interfaz CUBA est√°ndar: <code>Entity</code> .  Esto significa que los atributos de Vista de entidad se pueden cambiar y luego guardar estos cambios en la base de datos utilizando la API est√°ndar de CUBA para trabajar con datos. <br>  Y, por cierto, la "tercera liebre": puede hacer que los atributos sean de solo lectura si define una interfaz solo con m√©todos getter.  Por lo tanto, ya establecemos las reglas de modificaci√≥n en el nivel de API de la entidad. <br>  Adem√°s, puede realizar algunas operaciones locales para entidades separadas utilizando atributos disponibles, por ejemplo, conversi√≥n de cadena de nombre, como en el ejemplo a continuaci√≥n: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@MetaProperty</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNameLowercase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getName().toLowerCase(); }</code> </pre> <br><p>  Tenga en cuenta que los atributos calculados pueden extraerse del modelo de clase de entidad y transferirse a las interfaces aplicables a una l√≥gica comercial particular. </p><br><p>  Otra caracter√≠stica interesante es la herencia de la interfaz.  Puede crear varias vistas con diferentes conjuntos de atributos y luego combinarlos.  Por ejemplo, puede crear una interfaz para una entidad de Usuario con los atributos de nombre y correo electr√≥nico, y otra con los atributos de nombre y direcci√≥n.  Ahora, si necesita seleccionar el nombre, el correo electr√≥nico y las direcciones, no necesita copiar estos atributos en la tercera interfaz, solo necesita heredar de las dos primeras vistas.  Y s√≠, las instancias de la tercera interfaz se pueden pasar a m√©todos que aceptan par√°metros con el tipo de interfaces principales, las reglas de OOP son las mismas para todos. </p><br><p>  Tambi√©n se implement√≥ una conversi√≥n entre vistas: cada interfaz tiene un m√©todo reload (), en el que puede pasar la clase de vista como par√°metro: </p><br><pre> <code class="java hljs">UserFullView userFull = userMinimal.reload(UserFullView.class);</code> </pre> <br><p>  UserFullView puede contener atributos adicionales, por lo que la entidad se volver√° a cargar desde la base de datos, si es necesario.  Y este proceso se retrasa.  El acceso a la base de datos se realizar√° solo cuando ocurra el primer acceso a los atributos de la entidad.  Esto ralentizar√° un poco la primera llamada, pero este enfoque se eligi√≥ intencionalmente: si la instancia de entidad se usa en el m√≥dulo "web", que contiene IU y sus propios controladores REST, este m√≥dulo se puede implementar en un servidor separado.  Y esto significa que la sobrecarga forzada de la entidad crear√° tr√°fico de red adicional: acceso al m√≥dulo central y luego a la base de datos.  Por lo tanto, posponiendo la sobrecarga hasta el momento en que es necesario, ahorramos tr√°fico y reducimos el n√∫mero de consultas a la base de datos. </p><br><p>  El concepto est√° dise√±ado como un m√≥dulo para CUBA, un ejemplo de uso se puede descargar desde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> . </p><br><h2 id="zaklyuchenie">  Conclusi√≥n </h2><br><p>  Parece que en el futuro cercano todav√≠a estaremos usando masivamente ORM en aplicaciones empresariales simplemente porque necesitamos algo que convierta los datos relacionales en objetos.  Por supuesto, se desarrollar√°n soluciones espec√≠ficas para aplicaciones complejas, √∫nicas y de carga ultra alta, pero parece que los marcos de ORM vivir√°n tanto como las bases de datos relacionales. <br>  En CUBA, intentamos simplificar al m√°ximo el trabajo con ORM, y en futuras versiones presentaremos nuevas funciones para trabajar con datos.  Ser√° dif√≠cil decir si ser√°n interfaces de presentaci√≥n u otra cosa, pero estoy seguro de una cosa: seguiremos simplificando el trabajo con datos en futuras versiones del marco. </p><cut></cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/451986/">https://habr.com/ru/post/451986/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../451970/index.html">Thrangrycat: la vulnerabilidad cr√≠tica en el firmware del dispositivo Cisco permite a los hackers instalar puertas traseras en ellos</a></li>
<li><a href="../451972/index.html">QuadCast - Suena Real</a></li>
<li><a href="../451974/index.html">Historia de AMD: 50 a√±os de r√°pido desarrollo</a></li>
<li><a href="../451976/index.html">¬øCu√°nto cuesta un Runet "soberano"?</a></li>
<li><a href="../451982/index.html">Cuanto m√°s r√°pido se olvide de OOP, mejor para usted y sus programas.</a></li>
<li><a href="../451990/index.html">Preguntas frecuentes sobre transferencias y vuelos de conexi√≥n: ¬øcu√°l es la diferencia que un pasajero puede y no puede hacer?</a></li>
<li><a href="../451996/index.html">Mi experiencia de errores</a></li>
<li><a href="../451998/index.html">Problemas de la agricultura de precisi√≥n y c√≥mo vivir con ellos.</a></li>
<li><a href="../452000/index.html">C√≥mo en Leroy Merlin puede comprar bienes en el almac√©n de un proveedor que no est√° en el surtido de la tienda</a></li>
<li><a href="../452004/index.html">Encontr√≥ el lugar del accidente de Bereshit en la luna</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>