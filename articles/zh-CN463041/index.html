<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👶 🙋🏿 🎥 定义还是未定义？ 在JavaScript中创建数组的细节 🎼 👨🏼‍⚕️ 👨🏻‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="几个月前，我偶然发现了一个关于stackoverflow的有趣问题，简而言之，一个人想要创建一个空的5x5矩阵，并使用他成功的一种方法，但是没有使用另一种方法。 在随后的讨论中，对此主题提出了有趣的想法。 

 的确，提出问题的人以及回答该问题的人都没有注意到事实上无法创建矩阵并且计算结果不正确的事...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>定义还是未定义？ 在JavaScript中创建数组的细节</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463041/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/cf/uz/xt/cfuzxt6gszx356ckhbffnh21g9g.jpeg" alt="图片"></div><br> 几个月前，我偶然发现了一个关于<i>stackoverflow</i>的有趣问题，简而言之，一个人想要创建一个空的<i>5x5</i>矩阵，并使用他成功的一种方法，但是没有使用另一种方法。 在随后的讨论中，对此主题提出了有趣的想法。 <br><br> 的确，提出问题的人以及回答该问题的人都没有注意到事实上无法创建矩阵并且计算结果不正确的事实。 这一切使我感兴趣，因此我决定更深入地研究，然后得出有趣的结论，我现在将与您分享。 <br><a name="habracut"></a><br>  <i>注意：在讨论中，我也以昵称<i>AndreyGS进行了</i>回答-在这里我做了简短的回答，在这里我将尽力解决问题。</i> <br><br> 通常，挑战在于创建数组。 我们该怎么做？ 奇怪的是，有不同的选择，这取决于我们想要得到什么。 <br><br> 我们知道JavaScript中的函数有两个内部方法， <i>Call</i>和<i>Construct</i> 。 如果我们使用<i>new</i>关键字，则使用Construct方法，该方法创建对象的新实例， <i>将此</i>引用分配给<i>它</i> ，然后执行该函数的主体。 并非所有函数都具有此方法，但是对我们而言，这现在并不重要。 <br><br> 创建数组时，有一个特点：我们使用<i>Array（...）</i>还是<i>新的Array（...）</i>都没关系<i>-ECMAScript</i>规范不区分它们，而且认为它们是等效的。 <br><br><pre><code class="dos hljs"><span class="hljs-number"><span class="hljs-number">22</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span> The Array Constructor The Array constructor is the <span class="hljs-variable"><span class="hljs-variable">%Array%</span></span> intrinsic object and the initial value of the Array property of the global object. When called as a constructor it creates and initializes a new exotic Array object. When Array is called as a function rather than as a constructor, it also creates and initializes a new Array object. Thus the function <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> Array(…) is equivalent to the object creation expression new Array(…) with the same arguments.</code> </pre> <br> 因此，我不会调皮捣蛋，在示例中，我将仅使用<i>新的Array（...）</i>构造，以免混淆任何人。 <br><br> 让我们开始吧。 <br><br> 创建一个数组： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>);</code> </pre> <br> 我们得到了什么？ <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// Array(5) [ &lt;5 empty slots&gt; ] console.log(arr[0]); // undefined console.log(Object.getOwnPropertyDescriptor(arr,"0")); // undefined</span></span></code> </pre> <br> 嗯...嗯，原则上应该是这样-我们设置长度并得到五个空单元格，其值是<i>undefined</i> ，可以进一步处理，对吧？ 没错，有几点让我感到困惑。 让我们来看看。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>).map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// Array(5) [ &lt;5 empty slots&gt; ] console.log(arr[0]); // undefined console.log(Object.getOwnPropertyDescriptor(arr,"0")); // undefined console.log(arr[0][0]); // TypeError: arr[0] is undefined</span></span></code> </pre> <br> 毕竟，我们必须得到一个矩阵，然后在每个单元格中应该有5个元素的数组，这是怎么回事？ <br><br> 让我们再次转到<i>ECMAScript</i>文档，看看其中写的有关使用一个参数创建数组的方法的内容： <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">22</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span> Array (len) This description applies <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> and only <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the Array constructor is called with exactly one argument. <span class="hljs-number"><span class="hljs-number">1</span></span>. Let numberOfArgs be the number of arguments passed to this function <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>. <span class="hljs-number"><span class="hljs-number">2</span></span>. Assert: numberOfArgs = <span class="hljs-number"><span class="hljs-number">1</span></span>. <span class="hljs-number"><span class="hljs-number">3</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> NewTarget is undefined, let newTarget be the active function object, <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> let newTarget be NewTarget. <span class="hljs-number"><span class="hljs-number">4</span></span>. Let proto be GetPrototypeFromConstructor(newTarget, "<span class="hljs-variable"><span class="hljs-variable">%ArrayPrototype%</span></span>"). <span class="hljs-number"><span class="hljs-number">5</span></span>. ReturnIfAbrupt(proto). <span class="hljs-number"><span class="hljs-number">6</span></span>. Let array be ArrayCreate(<span class="hljs-number"><span class="hljs-number">0</span></span>, proto). <span class="hljs-number"><span class="hljs-number">7</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Type</span></span>(len) is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Number, then <span class="hljs-number"><span class="hljs-number">1</span></span>. Let defineStatus be CreateDataProperty(array, "<span class="hljs-number"><span class="hljs-number">0</span></span>", len). <span class="hljs-number"><span class="hljs-number">2</span></span>. Assert: defineStatus is true. <span class="hljs-number"><span class="hljs-number">3</span></span>. Let intLen be <span class="hljs-number"><span class="hljs-number">1</span></span>. <span class="hljs-number"><span class="hljs-number">8</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">Else</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>. Let intLen be ToUint32(len). <span class="hljs-number"><span class="hljs-number">2</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> intLen ≠ len, throw a RangeError exception. <span class="hljs-number"><span class="hljs-number">9</span></span>. Let setStatus be <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span>(array, "length", intLen, true). <span class="hljs-number"><span class="hljs-number">10</span></span>. Assert: setStatus is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> an abrupt completion. <span class="hljs-number"><span class="hljs-number">11</span></span>. Return array.</code> </pre> <br> 而且，我们看到的是，事实证明对象已创建，在ArrayCreate过程中创建了<i>length</i>属性（第6点），在<i>length</i>属性中设置了值（第9点），单元格又如何？ 除了特殊情况（传递的参数不是数字，并且使用单个单元格“ 0”创建具有对应值（点7）的数组）外，没有关于它们的任何单词……也就是说，== 5的长度，但是没有五个单元格。 是的，当我们尝试访问单个单元格时，编译器使我们感到困惑，它表明其值是<i>undefined</i> ，而实际上不是。 <br><br> 为了进行比较，这里提供了使用多个参数发送到构造函数的创建数组的方法： <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">22</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">3</span></span> Array (...items ) This description applies <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> and only <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the Array constructor is called with <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> least two arguments. When the Array function is called the following steps are taken: <span class="hljs-number"><span class="hljs-number">1</span></span>. Let numberOfArgs be the number of arguments passed to this function <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>. <span class="hljs-number"><span class="hljs-number">2</span></span>. Assert: numberOfArgs ≥ <span class="hljs-number"><span class="hljs-number">2</span></span>. <span class="hljs-number"><span class="hljs-number">3</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> NewTarget is undefined, let newTarget be the active function object, <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> let newTarget be NewTarget. <span class="hljs-number"><span class="hljs-number">4</span></span>. Let proto be GetPrototypeFromConstructor(newTarget, "<span class="hljs-variable"><span class="hljs-variable">%ArrayPrototype%</span></span>"). <span class="hljs-number"><span class="hljs-number">5</span></span>. ReturnIfAbrupt(proto). <span class="hljs-number"><span class="hljs-number">6</span></span>. Let array be ArrayCreate(numberOfArgs, proto). <span class="hljs-number"><span class="hljs-number">7</span></span>. ReturnIfAbrupt(array). <span class="hljs-number"><span class="hljs-number">8</span></span>. Let k be <span class="hljs-number"><span class="hljs-number">0</span></span>. <span class="hljs-number"><span class="hljs-number">9</span></span>. Let items be a zero-origined List containing the argument items <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> order. <span class="hljs-number"><span class="hljs-number">10</span></span>. Repeat, while k &lt; numberOfArgs <span class="hljs-number"><span class="hljs-number">1</span></span>. Let Pk be ToString(k). <span class="hljs-number"><span class="hljs-number">2</span></span>. Let itemK be items[k]. <span class="hljs-number"><span class="hljs-number">3</span></span>. Let defineStatus be CreateDataProperty(array, Pk, itemK). <span class="hljs-number"><span class="hljs-number">4</span></span>. Assert: defineStatus is true. <span class="hljs-number"><span class="hljs-number">5</span></span>. Increase k by <span class="hljs-number"><span class="hljs-number">1</span></span>. <span class="hljs-number"><span class="hljs-number">11</span></span>. Assert: the value of array's length property is numberOfArgs. <span class="hljs-number"><span class="hljs-number">12</span></span>. Return array.</code> </pre> <br> 请在这里-10点，创建相同的单元格。 <br><br> 现在， <i>Array.prototype.map（）</i>接下来做什么？ <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">22</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">3</span></span>.<span class="hljs-number"><span class="hljs-number">15</span></span> Array.prototype.map ( callbackfn [ , thisArg ] ) <span class="hljs-number"><span class="hljs-number">1</span></span>. Let O be ToObject(this value). <span class="hljs-number"><span class="hljs-number">2</span></span>. ReturnIfAbrupt(O). <span class="hljs-number"><span class="hljs-number">3</span></span>. Let len be ToLength(Get(O, "length")). <span class="hljs-number"><span class="hljs-number">4</span></span>. ReturnIfAbrupt(len). <span class="hljs-number"><span class="hljs-number">5</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> IsCallable(callbackfn) is false, throw a TypeError exception. <span class="hljs-number"><span class="hljs-number">6</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> thisArg was supplied, let T be thisArg; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> let T be undefined. <span class="hljs-number"><span class="hljs-number">7</span></span>. Let A be ArraySpeciesCreate(O, len). <span class="hljs-number"><span class="hljs-number">8</span></span>. ReturnIfAbrupt(A). <span class="hljs-number"><span class="hljs-number">9</span></span>. Let k be <span class="hljs-number"><span class="hljs-number">0</span></span>. <span class="hljs-number"><span class="hljs-number">10</span></span>. Repeat, while k &lt; len <span class="hljs-number"><span class="hljs-number">1</span></span>. Let Pk be ToString(k). <span class="hljs-number"><span class="hljs-number">2</span></span>. Let kPresent be HasProperty(O, Pk). <span class="hljs-number"><span class="hljs-number">3</span></span>. ReturnIfAbrupt(kPresent). <span class="hljs-number"><span class="hljs-number">4</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> kPresent is true, then <span class="hljs-number"><span class="hljs-number">1</span></span>. Let kValue be Get(O, Pk). <span class="hljs-number"><span class="hljs-number">2</span></span>. ReturnIfAbrupt(kValue). <span class="hljs-number"><span class="hljs-number">3</span></span>. Let mappedValue be <span class="hljs-keyword"><span class="hljs-keyword">Call</span></span>(callbackfn, T, «kValue, k, O»). <span class="hljs-number"><span class="hljs-number">4</span></span>. ReturnIfAbrupt(mappedValue). <span class="hljs-number"><span class="hljs-number">5</span></span>. Let status be CreateDataPropertyOrThrow (A, Pk, mappedValue). <span class="hljs-number"><span class="hljs-number">6</span></span>. ReturnIfAbrupt(status). <span class="hljs-number"><span class="hljs-number">5</span></span>. Increase k by <span class="hljs-number"><span class="hljs-number">1</span></span>. <span class="hljs-number"><span class="hljs-number">11</span></span>. Return A.</code> </pre> <br> 条款7-创建原始数组的副本，在条款10中对其元素执行<i>len</i>迭代，尤其是条款10.2检查源数组中是否存在特定的单元格，以便在成功的情况下映射（10.4）并在副本中创建适当的单元格-10.4.5。 由于10.2在<i>5</i>次传递中每一次都为<i>false</i> ，因此在返回数组的副本中也不会创建单个单元格。 <br><br> 因此，我们弄清楚了数组构造函数和<i>Array.prototype.map（）</i>方法是如何<i>工作的</i> ，但由于未构建矩阵，因此任务仍未解决。  <i>Function.prototype.apply（）</i>会救出来的！ <br> 让我们立即检查一下它的作用： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// Array(5) [ undefined, undefined, undefined, undefined, undefined ] console.log(arr[0]); // undefined console.log(Object.getOwnPropertyDescriptor(arr,"0")); // Object { value: undefined, writable: true, enumerable: true, configurable: true }</span></span></code> </pre> <br> 欢呼，这里清楚地观察到所有五个单元格，第一个测试数字为<i>“ 0”的</i>单元格都有一个描述符。 <br><br> 在这种情况下，该程序的工作方式如下： <br><br><ol><li> 我们调用了<i>Function.prototype.apply（）</i>方法，并将<i>null</i>上下文传递给它，并将其作为数组<i>new Array（5）</i>传递。 </li><li>  <i>new Array（5）</i>创建了一个没有单元格但长度为<i>5</i>的数组。 </li><li>  <i>Function.prototype.apply（）</i>使用了将数组拆分为单独参数的内部方法，因此，将五个具有<i>未定义</i>值的参数传递给<i>Array</i>构造函数。 </li><li>  <i>数组</i>接收到<i>5个</i>具有<i>未定义</i>值的参数，并将它们添加到相应的单元格中。 </li></ol><br> 一切似乎都很清楚，除了<i>Function.prototype.apply（）的</i>内部方法是什么之外，它使<i>5个</i>参数完全变为<i>空白</i> -我建议再次查看<i>ECMAScript</i>文档： <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">19</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>.<span class="hljs-number"><span class="hljs-number">3</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span> Function.prototype.apply <span class="hljs-number"><span class="hljs-number">1</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> IsCallable(func) is false, throw a TypeError exception. <span class="hljs-number"><span class="hljs-number">2</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> argArray is null or undefined, then Return <span class="hljs-keyword"><span class="hljs-keyword">Call</span></span>(func, thisArg). <span class="hljs-number"><span class="hljs-number">3</span></span>. Let argList be CreateListFromArrayLike(argArray). <span class="hljs-number"><span class="hljs-number">7</span></span>.<span class="hljs-number"><span class="hljs-number">3</span></span>.<span class="hljs-number"><span class="hljs-number">17</span></span> CreateListFromArrayLike (obj [, elementTypes] ) <span class="hljs-number"><span class="hljs-number">1</span></span>. ReturnIfAbrupt(obj). <span class="hljs-number"><span class="hljs-number">2</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> elementTypes was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> passed, let elementTypes be (Undefined, Null, Boolean, String, Symbol, Number, Object). <span class="hljs-number"><span class="hljs-number">3</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Type</span></span>(obj) is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Object, throw a TypeError exception. <span class="hljs-number"><span class="hljs-number">4</span></span>. Let len be ToLength(Get(obj, "length")). <span class="hljs-number"><span class="hljs-number">5</span></span>. ReturnIfAbrupt(len). <span class="hljs-number"><span class="hljs-number">6</span></span>. Let list be an empty List. <span class="hljs-number"><span class="hljs-number">7</span></span>. Let index be <span class="hljs-number"><span class="hljs-number">0</span></span>. <span class="hljs-number"><span class="hljs-number">8</span></span>. Repeat while index &lt; len a. Let indexName be ToString(index). b. Let next be Get(obj, indexName). c. ReturnIfAbrupt(next). d. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Type</span></span>(next) is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> an element of elementTypes, throw a TypeError exception. e. <span class="hljs-built_in"><span class="hljs-built_in">Append</span></span> next as the last element of list. f. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> index to index + <span class="hljs-number"><span class="hljs-number">1</span></span>. <span class="hljs-number"><span class="hljs-number">9</span></span>. Return list.</code> </pre> <br> 我们来看最有趣的几点： <br><br>  19.2.3.1-第3段：从类似于数组的对象创建一个参数列表（我们记得，此类对象应具有length属性）。 <br><br>  7.3.17-列表创建方法本身。 它检查对象是否存在，如果是，则检查对<i>长度</i>字段的请求（第4段）。 然后创建一个等于<i>“ 0”</i>的索引（第7段）。 创建一个循环，将索引的增量增加到从<i>长度</i>字段中获取的值（第8段）。 在此循环中，我们用相应的索引（第8a和8b条）指代所传输数组的像元值。 就像我们记得的那样，当访问实际上没有任何单元格的数组中的单个单元格的值时，它仍然会给出值<i>undefined</i> 。 结果值将添加到参数列表的末尾（第8e段）。 <br><br> 好了，既然一切都准备就绪，您就可以安全地建立非常空的矩阵。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>)).map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>)); }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// Array(5) [ (5) […], (5) […], (5) […], (5) […], (5) […] ] console.log(arr[0]); // Array(5) [ undefined, undefined, undefined, undefined, undefined ] console.log(Object.getOwnPropertyDescriptor(arr,"0")); // Object { value: (5) […], writable: true, enumerable: true, configurable: true } console.log(arr[0][0]); // undefined console.log(Object.getOwnPropertyDescriptor(arr[0],"0")); // Object { value: undefined, writable: true, enumerable: true, configurable: true }</span></span></code> </pre> <br> 现在，您可以看到，所有内容都收敛并且看起来非常简单：以我们已经知道的方式，我们创建了一个简单的空<i>Array.apply（空，新的Array（5））</i>数组，然后将其传递给map方法，后者在其中创建了相同的数组。每个单元。 <br><br> 此外，您可以使其变得更加容易。  <i>扩展</i> <i>-...</i>运算符出现在<i>ECMAScript6中</i> ，这是典型的，它也特别适用于数组。 因此，我们可以简单地进入： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(...new <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>)).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(...new <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>)));</code> </pre> <br> 还是我们将其完全简化，即使我之前曾承诺不要接触新的东西... <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(...Array(<span class="hljs-number"><span class="hljs-number">5</span></span>)).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(...Array(<span class="hljs-number"><span class="hljs-number">5</span></span>)));</code> </pre>  <i>注意：这里我们还使用了箭头功能，因为我们仍在处理与它们相同的规范中出现的扩展运算符。</i> <br><br> 我们将不讨论<i>散布</i>算子的原理，但是，对于一般开发而言，我相信此示例也很有用。 <br><br> 此外，我们当然可以构建函数，使用<i>Function.prototype.apply（）</i>排序将为我们创建带有空单元格的常规数组，但是，了解JavaScript的内部原理以及相应的正确用法内置功能，是掌握的基础，这是当务之急。 嗯，当然，它是如此简单，快捷，方便。 <br><br> 最后，回到关于<i>stackoverflow的</i>相同问题-我记得，那个人错误地认为他收到的方法导致了正确的答案，但是他收到了一个<i>5x5</i>矩阵，但是-一个小错误悄悄潜入了那里。 <br><br> 他开车进去了： <br><br> <code>Array.apply(null, new Array(5)).map(function(){ <br> return new Array(5); <br> });</code> <br> <br> 您认为实际结果如何？ <br><br><div class="spoiler">  <b class="spoiler_title">答案</b> <div class="spoiler_text">  console.log（arr）;  //数组（5）[（5）[...]，（5）[...]，（5）[...]，（5）[...]，（5）[...]] <br>  console.log（arr [0]）;  //数组（5）[&lt;5空插槽&gt;] <br>  console.log（Object.getOwnPropertyDescriptor（arr，“ 0”））;  //对象{value：（5）[...]，可写：true，可枚举：true，可配置：true} <br>  console.log（arr [0] [0]）;  //未定义 <br>  console.log（Object.getOwnPropertyDescriptor（arr [0]，“ 0”））;  //未定义 <br></div></div><br> 是不是，那不是他想要的... <br><br> 参考文献： <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">ECMAScript 2015语言规范</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Array.apply实际在做什么</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN463041/">https://habr.com/ru/post/zh-CN463041/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN463027/index.html">对PVS-Studio的独立审查（Linux，C ++）</a></li>
<li><a href="../zh-CN463031/index.html">生活和学习。 第3部分。继续教育或永恒的学生年龄</a></li>
<li><a href="../zh-CN463035/index.html">OpenStreetMap第471号世界的新闻（07.23.2019-29.07.2019）</a></li>
<li><a href="../zh-CN463037/index.html">寻找灵感，或如何使自己摆脱F</a></li>
<li><a href="../zh-CN463039/index.html">自己动手修指甲吸尘器</a></li>
<li><a href="../zh-CN463045/index.html">使用神经网络自动检测文本对话中的情绪</a></li>
<li><a href="../zh-CN463055/index.html">关于公司内部的管理员，开发人员，无休止的混乱和DevOps转型</a></li>
<li><a href="../zh-CN463057/index.html">Yii Framework 2自定义权限</a></li>
<li><a href="../zh-CN463059/index.html">IT中的三者</a></li>
<li><a href="../zh-CN463061/index.html">在Figma中准备布局的规则</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>