<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎽 🌇 🎪 Bagaimana kami berburu bug NFS selama dua minggu di kernel Linux 🎁 👨🏽‍🚒 🔚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Deskripsi terperinci dari pencarian bug dari tugas GitLab yang mengarah ke patch untuk kernel Linux 


 Pada 14 September, dukungan GitLab melaporkan ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana kami berburu bug NFS selama dua minggu di kernel Linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/432922/"><h3 id="podrobnoe-opisanie-poiskov-baga-iz-zadachi-gitlab-kotorye-priveli-k-patchu-dlya-yadra-linux">  Deskripsi terperinci dari pencarian bug dari tugas GitLab yang mengarah ke patch untuk kernel Linux </h3><br><p> Pada 14 September, dukungan GitLab melaporkan masalah kritis yang terjadi pada salah satu pelanggan kami: pertama, GitLab berfungsi dengan baik, dan kemudian pengguna mendapatkan kesalahan.  Mereka mencoba mengkloning beberapa repositori melalui Git, dan tiba-tiba sebuah pesan yang tidak dapat dimengerti muncul tentang file yang sudah usang: <code>Stale file error</code> .  Kesalahan bertahan untuk waktu yang lama dan tidak berfungsi sampai administrator sistem secara manual memulai <code>ls</code> di direktori itu sendiri. </p><br><p>  Saya harus mempelajari mekanisme internal Git dan sistem file jaringan NFS.  Hasilnya, kami menemukan bug di klien Linux v4.0 NFS, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Trond Myklebust menulis tambalan untuk kernel</a> , dan sejak 26 Oktober <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tambalan ini telah dimasukkan dalam kernel Linux utama</a> . </p><br><p>  Dalam posting ini saya akan memberi tahu Anda bagaimana kami mempelajari masalah, ke arah mana kami berpikir dan alat apa yang kami gunakan untuk melacak bug.  Kami terinspirasi oleh karya detektif yang sangat baik dari Oleg Dashevsky yang dijelaskan dalam posting <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Bagaimana Saya Memburu Memori yang Kebocoran di Ruby selama Dua Minggu"</a> . </p><br><img src="https://habrastorage.org/webt/es/0f/-7/es0f-7dbqlnheksnnmxtlwawlic.jpeg"><a name="habracut"></a><br><p>  Ini juga contoh yang bagus tentang bagaimana debug sumber terbuka adalah olahraga tim yang melibatkan banyak orang, perusahaan, dan negara.  Moto GitLab, “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Semua orang dapat berkontribusi,</a> ” benar tidak hanya untuk GitLab itu sendiri, tetapi juga untuk proyek-proyek sumber terbuka lainnya, seperti kernel Linux. </p><br><h3 id="vosproizvedenie-baga">  Reproduksi bug </h3><br><p>  Kami menyimpan NFS di GitLab.com selama bertahun-tahun, tetapi kemudian berhenti menggunakannya untuk mengakses data repositori pada mesin dengan aplikasi.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kami telah memindahkan semua panggilan Git ke Gitaly</a> .  Kami mendukung NFS untuk klien yang mengelola instalasi mereka di GitLab tetapi tidak pernah mengalami masalah yang sama dengan klien yang disebutkan sebelumnya. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Klien memberikan beberapa petunjuk bermanfaat</a> : </p><br><ol><li>  Teks kesalahan penuh: <code>fatal: Couldn't read ./packed-refs: Stale file handle</code> . </li><li>  Tampaknya, masalah muncul ketika klien secara manual memulai pengumpulan sampah di Git dengan perintah <code>git gc</code> . </li><li>  Kesalahan menghilang ketika administrator sistem memulai utilitas <code>ls</code> di direktori. </li><li>  Kesalahan menghilang ketika proses <code>git gc</code> . </li></ol><br><p>  Jelas bahwa dua titik pertama terhubung.  Saat Anda mengirim perubahan ke cabang Git, Git membuat tautan yang lemah - nama file panjang yang menunjukkan nama cabang untuk komit.  Misalnya, saat mengirim ke <code>master</code> , file bernama <code>refs/heads/master</code> akan dibuat di repositori: </p><br><pre> <code class="plaintext hljs">$ cat refs/heads/master 2e33a554576d06d9e71bfd6814ee9ba3a7838963</code> </pre> <br><p>  Perintah <code>git gc</code> melakukan beberapa tugas.  Sebagai contoh, ia mengumpulkan tautan-tautan lemah ini (ref) dan mengemasnya menjadi satu file yang disebut <code>packed-refs</code> .  Ini sedikit mempercepat pekerjaan, karena membaca satu file besar lebih mudah daripada banyak file kecil.  Sebagai contoh, setelah menjalankan perintah <code>git gc</code> , file paket <code>packed-refs</code> mungkin terlihat seperti ini: </p><br><pre> <code class="plaintext hljs"># pack-refs with: peeled fully-peeled sorted 564c3424d6f9175cf5f2d522e10d20d781511bf1 refs/heads/10-8-stable edb037cbc85225261e8ede5455be4aad771ba3bb refs/heads/11-0-stable 94b9323033693af247128c8648023fe5b53e80f9 refs/heads/11-1-stable 2e33a554576d06d9e71bfd6814ee9ba3a7838963 refs/heads/master</code> </pre> <br><p>  Bagaimana file <code>packed-refs</code> ?  Untuk mengetahuinya, kami menjalankan perintah <code>strace git gc</code> mana kami memiliki tautan yang lemah.  Berikut adalah baris yang relevan: </p><br><pre> <code class="plaintext hljs">28705 open("/tmp/libgit2/.git/packed-refs.lock", O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC, 0666) = 3 28705 open(".git/packed-refs", O_RDONLY) = 3 28705 open("/tmp/libgit2/.git/packed-refs.new", O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC, 0666) = 4 28705 rename("/tmp/libgit2/.git/packed-refs.new", "/tmp/libgit2/.git/packed-refs") = 0 28705 unlink("/tmp/libgit2/.git/packed-refs.lock") = 0</code> </pre> <br><p>  Panggilan sistem menunjukkan bahwa perintah <code>git gc</code> : </p><br><ol><li>  Terbuka <code>packed-refs.lock</code> .  Ini memberitahu proses lain bahwa file <code>packed-refs</code> terkunci dan tidak dapat diubah. </li><li>  Dibuka <code>packed-refs.new</code> . </li><li>  Saya <code>packed-refs.new</code> tautan lemah di <code>packed-refs.new</code> . </li><li>  Berganti nama <code>packed-refs.new</code> menjadi <code>packed-refs</code> . </li><li>  Dihapus <code>packed-refs.lock</code> . </li><li>  Tautan lemah yang dihapus. </li></ol><br><p>  Poin kunci di sini adalah yang keempat, yaitu, mengganti nama, di mana Git memperkenalkan file <code>packed-refs</code> .  <code>git gc</code> tidak hanya mengumpulkan tautan yang lemah, tetapi juga melakukan tugas yang jauh lebih banyak sumber daya - ia mencari dan menghapus objek yang tidak digunakan.  Dalam repositori besar, ini bisa bertahan lebih dari satu jam. </p><br><p>  Dan kami bertanya pada diri sendiri: dalam repositori besar, apakah <code>git gc</code> menjaga file tetap terbuka selama pembersihan?  Kami mempelajari <code>strace</code> log, meluncurkan utilitas <code>lsof</code> , dan inilah yang kami pelajari tentang proses <code>git gc</code> : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/493/51d/077/49351d077382c8b70317346789331c81.svg" alt="gambar"></p><br><p>  Seperti yang Anda lihat, file <code>packed-refs</code> ditutup di bagian paling akhir, setelah proses <code>Garbage collect objects</code> berpotensi lama <code>Garbage collect objects</code> . </p><br><p>  Jadi pertanyaan berikut muncul: bagaimana NFS berperilaku ketika file <code>packed-refs</code> terbuka pada satu node, dan yang lainnya mengubah nama itu pada waktu itu? </p><br><p>  "Untuk tujuan ilmiah," kami meminta klien untuk melakukan satu percobaan pada dua mesin yang berbeda (Alice dan Bob): <br>  1) Dalam volume bersama NFS, buat dua file: <code>test1.txt</code> dan <code>test2.txt</code> dengan konten yang berbeda, sehingga lebih mudah untuk membedakannya: </p><br><pre> <code class="plaintext hljs">alice $ echo "1 - Old file" &gt; /path/to/nfs/test1.txt alice $ echo "2 - New file" &gt; /path/to/nfs/test2.txt</code> </pre> <br><p>  2) Pada mesin Alice, file <code>test1.txt</code> harus terbuka: </p><br><pre> <code class="plaintext hljs">alice $ irb irb(main):001:0&gt; File.open('/path/to/nfs/test1.txt')</code> </pre> <br><p>  3) Pada mesin Alice, terus tampilkan konten <code>test1.txt</code> : </p><br><pre> <code class="plaintext hljs">alice $ while true; do cat test1.txt; done</code> </pre> <br><p>  4) Kemudian, pada mesin Bob, jalankan perintah: </p><br><pre> <code class="plaintext hljs">bob $ mv -f test2.txt test1.txt</code> </pre> <br><p>  Langkah terakhir mereproduksi apa yang <code>git gc</code> lakukan dengan file <code>packed-refs</code> ketika menimpa file yang sudah ada. <br>  Di mesin klien, hasilnya terlihat seperti ini: </p><br><pre> <code class="plaintext hljs">1 - Old file 1 - Old file 1 - Old file cat: test1.txt: Stale file handle</code> </pre> <br><p>  Ada!  Kami tampaknya telah mengendalikan masalah dengan cara yang terkendali.  Tetapi dalam percobaan yang sama pada server Linux NFS, masalah ini tidak terjadi.  Hasilnya diharapkan - setelah mengganti nama konten baru diterima: </p><br><pre> <code class="plaintext hljs">1 - Old file 1 - Old file 1 - Old file 2 - New file &lt;--- RENAME HAPPENED 2 - New file 2 - New file</code> </pre> <br><p>  Dari mana perbedaan perilaku ini berasal?  Ternyata klien menggunakan penyimpanan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Isilon NFS</a> , yang hanya mendukung NFS v4.0.  Ketika kami mengubah pengaturan koneksi ke v4.0 menggunakan parameter <code>vers=4.0</code> di <code>/etc/fstab</code> , tes menunjukkan hasil yang berbeda untuk server Linux NFS: </p><br><pre> <code class="plaintext hljs">1 - Old file 1 - Old file 1 - Old file 1 - Old file &lt;--- RENAME HAPPENED 1 - Old file 1 - Old file</code> </pre> <br><p>  Alih-alih <code>Stale file handle</code> usang <code>Stale file handle</code> server Linux NFS v4.0 menampilkan <em>konten</em> usang.  Ternyata perbedaan perilaku dapat dijelaskan oleh spesifikasi NFS.  Dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RFC 3010</a> : </p><br><blockquote>  Deskriptor file mungkin kedaluwarsa atau kedaluwarsa saat diganti namanya, tetapi tidak selalu.  Pelaksana server disarankan untuk mengambil langkah-langkah untuk memastikan bahwa deskriptor file tidak kedaluwarsa dan tidak kedaluwarsa dengan cara ini. </blockquote><p>  Dengan kata lain, server NFS dapat memilih bagaimana berperilaku ketika file diubah namanya, dan server NFS cukup mengembalikan <code>Stale file error</code> dalam kasus tersebut.  Kami menyarankan bahwa penyebab masalahnya adalah sama, walaupun hasilnya berbeda.  Kami menduga itu adalah pemeriksaan cache, karena utilitas <code>ls</code> di direktori menghapus kesalahan.  Sekarang kami memiliki skenario pengujian yang dapat direproduksi, dan kami beralih ke ahli - pengelola Linux NFS. </p><br><h2 id="lozhnyy-sled-delegirovanie-na-nfs-servere">  Pelacakan Salah: Delegasi pada Server NFS </h2><br><p>  Ketika kami berhasil mereproduksi kesalahan langkah demi langkah, saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menulis ke kontak NFS Linux</a> tentang apa yang kami pelajari.  Saya berkorespondensi dengan Bruce Fields, pengelola server Linux NFS selama seminggu, dan dia menyarankan bahwa bug ada di NFS dan saya perlu mempelajari lalu lintas jaringan.  Dia pikir masalahnya adalah mendelegasikan tugas di server NFS. </p><br><h3 id="chto-takoe-delegirovanie-na-nfs-servere">  Apa yang dimaksud dengan delegasi pada server NFS? </h3><br><p>  Singkatnya, versi NFS v4 memiliki fungsi delegasi untuk mempercepat akses file.  Server dapat mendelegasikan akses baca atau tulis ke klien sehingga klien tidak harus terus-menerus bertanya kepada server apakah file telah diubah oleh klien lain.  Sederhananya, mendelegasikan catatan seperti meminjamkan buku catatan Anda kepada seseorang dan berkata, "Anda menulis di sini, dan saya akan mengambilnya ketika saya siap."  Dan seseorang tidak harus meminta buku catatan setiap kali Anda perlu menulis sesuatu - ia memiliki kebebasan penuh untuk bertindak sampai buku catatan tersebut diambil.  Di NFS, permintaan untuk mengembalikan notebook disebut pencabutan delegasi. </p><br><p>  Bug dalam pencabutan delegasi NFS dapat menjelaskan masalah <code>Stale file handle</code> .  Ingat bagaimana <code>test1.txt</code> dibuka dalam <code>test1.txt</code> Alice, dan kemudian <code>test2.txt</code> menggantinya.  Mungkin server tidak dapat mencabut delegasi untuk <code>test1.txt</code> , dan ini menyebabkan status yang tidak valid.  Untuk menguji teori ini, kami mencatat lalu lintas NFC dengan utilitas <code>tcpdump</code> dan memvisualisasikannya menggunakan Wireshark. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wireshark</a> adalah alat open source yang hebat untuk menganalisis lalu lintas jaringan, terutama untuk menjelajahi NFS dalam aksi.  Kami merekam jejak menggunakan perintah berikut di server NFS: </p><br><pre> <code class="plaintext hljs">tcpdump -s 0 -w /tmp/nfs.pcap port 2049</code> </pre> <br><p>  Perintah ini mencatat semua lalu lintas NFS yang biasanya melewati port TCP 2049. Karena percobaan kami berhasil dengan NFS v4.1, tetapi tidak dengan NFS v4.0, kami dapat membandingkan perilaku NFS dalam kasus yang bekerja dan yang tidak bekerja.  Dengan Wireshark, kami melihat perilaku berikut: </p><br><h3 id="nfs-v40-ustarevshiy-fayl">  NFS v4.0 (file usang) </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6a1/0bb/e23/6a10bbe2304b155431010aa4ca577fa7.svg" alt="gambar"></p><br><p>  Diagram ini menunjukkan bahwa pada langkah 1, Alice membuka <code>test1.txt</code> dan menerima deskriptor file NFS dengan pengenal <code>stateid</code> 0x3000.  Ketika Bob mencoba mengubah nama file, server NFS meminta untuk mencoba lagi dengan mengirim pesan <code>NFS4ERR_DELAY</code> , dan ia mengingat delegasi dari Alice melalui pesan <code>CB_RECALL</code> (langkah 3).  Alice mengembalikan delegasi (DELEGRETURN pada langkah 4), dan Bob mencoba mengirim pesan <code>RENAME</code> lagi (langkah 5).  <code>RENAME</code> dieksekusi dalam kedua kasus, tetapi Alice terus membaca file oleh deskriptor yang sama. </p><br><h3 id="nfs-v41-rabochiy-sluchay">  NFS v4.1 (case kerja) </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f3d/1a3/d49/f3d1a3d49e803d73a4dd7f830e9b238a.svg" alt="gambar"></p><br><p>  Di sini perbedaannya terlihat pada langkah 6. Dalam NFS v4.0 (dengan file yang usang) Alice mencoba menggunakan <code>stateid</code> sama <code>stateid</code> .  Dalam NFS v4.1 (case kerja), Alice melakukan operasi <code>LOOKUP</code> dan <code>OPEN</code> tambahan, sehingga server mengembalikan <code>stateid</code> berbeda.  Di v4.0, itu tidak mengirim pesan tambahan.  Ini menjelaskan mengapa Alice melihat konten yang sudah usang - ia menggunakan deskriptor lama. </p><br><p>  Mengapa Alice tiba-tiba memutuskan <code>LOOKUP</code> tambahan?  Tampaknya, penarikan kembali delegasi berhasil, tetapi beberapa masalah tampaknya tetap ada.  Misalnya, langkah cacat dilewati.  Untuk memverifikasi ini, kami mengecualikan delegasi NFS di server NFS sendiri dengan perintah ini: </p><br><pre> <code class="plaintext hljs">echo 0 &gt; /proc/sys/fs/leases-enable</code> </pre> <br><p>  Kami mengulangi percobaan, tetapi masalahnya tidak hilang.  Kami memastikan bahwa masalahnya bukan pada server atau delegasi NFS, dan memutuskan untuk melihat klien NFS di kernel. </p><br><h2 id="kopaem-glubzhe-linux-nfs-klient">  Menggali lebih dalam: klien Linux NFS </h2><br><p>  Pertanyaan pertama yang harus kami jawab kepada pengelola NFS adalah: </p><br><h3 id="eta-problema-sohranyaetsya-v-posledney-versii-yadra">  Apakah masalah ini tetap ada pada versi kernel terbaru? </h3><br><p>  Masalahnya terjadi pada kernel CentOS 7.2 dan Ubuntu 16.04 dengan versi 3.10.0-862.11.6 dan 4.4.0-130.  Namun kedua core tertinggal versi terbaru, yang pada waktu itu adalah 4.19-rc2. </p><br><p>  Kami menggunakan mesin virtual Ubuntu 16.04 baru di Google Cloud Platform (GCP), mengkloning kernel Linux terbaru, dan mengatur lingkungan pengembangan kernel.  Kami membuat file <code>.config</code> menggunakan <code>menuconfig</code> dan memverifikasi bahwa: </p><br><ol><li>  Driver NFS dikompilasi sebagai modul ( <code>CONFIG_NFSD=m</code> ). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Parameter kernel GCP</a> yang benar ditentukan dengan benar. </li></ol><br><p>  Genetika melacak evolusi secara real time oleh Drosophila, dan dengan item pertama kita dapat dengan cepat melakukan koreksi pada klien NFS tanpa memulai ulang kernel.  Poin kedua menjamin bahwa kernel akan mulai setelah instalasi.  Untungnya, kami puas dengan parameter kernel default. </p><br><p>  Kami memastikan bahwa masalah file yang usang tidak hilang dalam versi kernel terbaru.  Kami bertanya pada diri sendiri: </p><br><ol><li>  Di mana tepatnya masalah muncul? </li><li>  Mengapa ini terjadi di NFS v4.0, tetapi tidak di v4.1? </li></ol><br><p>  Untuk menjawab pertanyaan ini, kami mempelajari kode sumber NFS.  Kami tidak memiliki debugger kernel, jadi kami mengirim dua jenis panggilan ke kode sumber: </p><br><ol><li>  <code>pr_info()</code> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>   printk</code></a> ). </li><li>  <code>dump_stack()</code> : ini menunjukkan jejak stack untuk panggilan fungsi saat ini. </li></ol><br><p>  Sebagai contoh, hal pertama yang kami lakukan adalah terhubung ke fungsi <code>nfs4_file_open()</code> di <code>fs/nfs/nfs4file.c</code> : </p><br><pre> <code class="plaintext hljs">static int nfs4_file_open(struct inode *inode, struct file *filp) { ... pr_info("nfs4_file_open start\n"); dump_stack();</code> </pre> <br><p>  Tentu saja, kami dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>  dprintk</code> dengan debugging dinamis Linux</a> atau menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>rpcdebug</code></a> , tetapi kami ingin menambahkan pesan kami sendiri untuk memeriksa perubahan. </p><br><p>  Setelah setiap perubahan, kami mengkompilasi ulang modul dan menginstalnya kembali di kernel menggunakan perintah: </p><br><pre> <code class="plaintext hljs">make modules sudo umount /mnt/nfs-test sudo rmmod nfsv4 sudo rmmod nfs sudo insmod fs/nfs/nfs.ko sudo mount -a</code> </pre> <br><p>  Dengan modul NFS, kami dapat mengulangi eksperimen dan menerima pesan untuk memahami kode NFS.  Misalnya, Anda dapat langsung melihat apa yang terjadi ketika panggilan aplikasi <code>open()</code> : </p><br><pre> <code class="plaintext hljs">Sep 24 20:20:38 test-kernel kernel: [ 1145.233460] Call Trace: Sep 24 20:20:38 test-kernel kernel: [ 1145.233462] dump_stack+0x8e/0xd5 Sep 24 20:20:38 test-kernel kernel: [ 1145.233480] nfs4_file_open+0x56/0x2a0 [nfsv4] Sep 24 20:20:38 test-kernel kernel: [ 1145.233488] ? nfs42_clone_file_range+0x1c0/0x1c0 [nfsv4] Sep 24 20:20:38 test-kernel kernel: [ 1145.233490] do_dentry_open+0x1f6/0x360 Sep 24 20:20:38 test-kernel kernel: [ 1145.233492] vfs_open+0x2f/0x40 Sep 24 20:20:38 test-kernel kernel: [ 1145.233493] path_openat+0x2e8/0x1690 Sep 24 20:20:38 test-kernel kernel: [ 1145.233496] ? mem_cgroup_try_charge+0x8b/0x190 Sep 24 20:20:38 test-kernel kernel: [ 1145.233497] do_filp_open+0x9b/0x110 Sep 24 20:20:38 test-kernel kernel: [ 1145.233499] ? __check_object_size+0xb8/0x1b0 Sep 24 20:20:38 test-kernel kernel: [ 1145.233501] ? __alloc_fd+0x46/0x170 Sep 24 20:20:38 test-kernel kernel: [ 1145.233503] do_sys_open+0x1ba/0x250 Sep 24 20:20:38 test-kernel kernel: [ 1145.233505] ? do_sys_open+0x1ba/0x250 Sep 24 20:20:38 test-kernel kernel: [ 1145.233507] __x64_sys_openat+0x20/0x30 Sep 24 20:20:38 test-kernel kernel: [ 1145.233508] do_syscall_64+0x65/0x130</code> </pre> <br><p>  Apa <code>vfs_open</code> dan <code>vfs_open</code> ?  Linux memiliki sistem file virtual ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">VFS</a> ), lapisan abstraksi yang menyediakan antarmuka umum untuk semua sistem file.  Dokumentasi VFS mengatakan: </p><br><blockquote>  VFS mengimplementasikan open (2), stat (2), chmod (2) dan panggilan sistem lainnya.  Sistem VFS menggunakan argumen nama jalur yang diteruskan ke mereka untuk mencari cache untuk entri direktori (cache gigi palsu, atau dcache).  Ini menyediakan mesin pencari yang sangat cepat yang mengubah nama jalur (atau nama file) menjadi gigi palsu tertentu.  Dentry berada dalam RAM dan tidak pernah disimpan ke disk - mereka hanya ada untuk kinerja. </blockquote><br><h3 id="i-nas-osenilo--a-chto-esli-problema-v-dentry-keshe">  Dan saya sadar - bagaimana jika masalahnya ada dalam cache dentry? </h3><br><p>  Kami memperhatikan bahwa cache dentry biasanya diperiksa di <code>fs/nfs/dir.c</code>  Kami terutama tertarik pada fungsi <code>nfs4_lookup_revalidate()</code> , dan sebagai percobaan, kami membuatnya berfungsi lebih awal: </p><br><pre> <code class="plaintext hljs">diff --git a/fs/nfs/dir.cb/fs/nfs/dir.c index 8bfaa658b2c1..ad479bfeb669 100644 --- a/fs/nfs/dir.c +++ b/fs/nfs/dir.c @@ -1159,6 +1159,7 @@ static int nfs_lookup_revalidate(struct dentry *dentry, unsigned int flags) trace_nfs_lookup_revalidate_enter(dir, dentry, flags); error = NFS_PROTO(dir)-&gt;lookup(dir, &amp;dentry-&gt;d_name, fhandle, fattr, label); trace_nfs_lookup_revalidate_exit(dir, dentry, flags, error); + goto out_bad; if (error == -ESTALE || error == -ENOENT) goto out_bad; if (error)</code> </pre> <br><p>  Dan dalam percobaan ini, masalah file yang usang tidak terjadi!  Akhirnya, kami menyerang jalan. </p><br><p>  Untuk mengetahui mengapa masalah tidak terjadi pada NFS v4.1, kami menambahkan panggilan <code>pr_info()</code> untuk masing-masing <code>if</code> blok dalam fungsi ini.  Kami bereksperimen dengan NFS v4.0 dan v4.1 dan menemukan kondisi khusus di versi v4.1: </p><br><pre> <code class="plaintext hljs">if (NFS_SB(dentry-&gt;d_sb)-&gt;caps &amp; NFS_CAP_ATOMIC_OPEN_V1) { goto no_open; }</code> </pre> <br><p>  Apa itu <code>NFS_CAP_ATOMIC_OPEN_V1</code> ?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Patch kernel</a> ini mengatakan bahwa ini adalah fitur NFS v4.1, dan kode di <code>fs/nfs/nfs4proc.c</code> mengkonfirmasi bahwa parameter ini di v4.1 tetapi tidak di v4.0: </p><br><pre> <code class="plaintext hljs">static const struct nfs4_minor_version_ops nfs_v4_1_minor_ops = { .minor_version = 1, .init_caps = NFS_CAP_READDIRPLUS | NFS_CAP_ATOMIC_OPEN | NFS_CAP_POSIX_LOCK | NFS_CAP_STATEID_NFSV41 | NFS_CAP_ATOMIC_OPEN_V1</code> </pre> <br><p>  Oleh karena itu, versi berperilaku berbeda - di v4.1, <code>goto no_open</code> memanggil lebih banyak pemeriksaan di fungsi <code>nfs_lookup_revalidate()</code> , dan di v4.0 fungsi <code>nfs4_lookup_revalidate()</code> kembali lebih awal.  Dan bagaimana kita memecahkan masalah? </p><br><h2 id="reshenie">  Solusi </h2><br><p>  Saya berbicara tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">temuan</a> kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di milis NFS</a> dan menyarankan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">patch primitif</a> .  Seminggu kemudian, Trond Myklebust <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengirim serangkaian tambalan dengan perbaikan bug ke milis dan menemukan masalah terkait lainnya di NFS v4.1</a> . </p><br><p>  Ternyata perbaikan untuk bug NFS v4.0 lebih dalam di basis kode daripada yang kita duga.  Trond menggambarkannya dengan baik di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tambalan</a> : </p><br><blockquote>  Penting untuk memastikan bahwa inode dan dentry diperiksa ulang dengan benar ketika file yang sudah dibuka dibuka.  Saat ini kami tidak mengecek NFSv4.0, karena file yang terbuka di-cache.  Mari kita perbaiki ini dan cache file yang terbuka hanya dalam kasus khusus - untuk mengembalikan file yang terbuka dan mengembalikan delegasi. </blockquote><p>  Kami memastikan bahwa perbaikan ini menyelesaikan masalah file yang usang dan mengirim laporan bug ke tim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ubuntu</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RedHat</a> . </p><br><p>  Kami sangat memahami bahwa perubahan tersebut belum dalam versi kernel yang stabil, jadi kami menambahkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">solusi sementara untuk masalah ini di Gitaly</a> .  Kami bereksperimen dan memverifikasi bahwa <code>stat()</code> panggilan <code>stat()</code> dalam file <code>packed-refs</code> menyebabkan kernel memeriksa ulang file yang diubah namanya di cache dentry.  Untuk mempermudah, kami menerapkan ini di Gitaly untuk sistem file apa pun, bukan hanya NFS.  Validasi dilakukan hanya sekali sebelum Gitaly membuka repositori, dan untuk file lain sudah ada panggilan <code>stat()</code> . </p><br><h2 id="chemu-my-nauchilis">  Apa yang telah kita pelajari </h2><br><p>  Bug dapat bersembunyi di sudut mana pun dari tumpukan perangkat lunak, dan kadang-kadang Anda harus mencarinya di luar aplikasi.  Jika Anda memiliki koneksi yang bermanfaat di dunia open source, ini akan membuat pekerjaan Anda lebih mudah. </p><br><p>  Banyak terima kasih kepada Trond Myuklebust untuk memperbaiki masalah, dan kepada Bruce Fields untuk menjawab pertanyaan kami dan membantu mencari tahu NFS.  Karena responsif dan profesionalisme kami menghargai komunitas pengembang open source. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id432922/">https://habr.com/ru/post/id432922/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id432910/index.html">Berbahaya menganggap realitas virtual sebagai mesin empati</a></li>
<li><a href="../id432912/index.html">Cara mendapatkan magang di Google</a></li>
<li><a href="../id432914/index.html">Bot obrolan yang sangat sederhana untuk Telegram untuk yang terkecil</a></li>
<li><a href="../id432918/index.html">Maaf, saya merusak recovery.conf Anda</a></li>
<li><a href="../id432920/index.html">Faktor manusia dalam perusahaan: apakah itu berbahaya?</a></li>
<li><a href="../id432924/index.html">Jalankan, Gecko, jalankan: mekanisme pergerakan air hibrida tokek</a></li>
<li><a href="../id432926/index.html">24 resep tentang bagaimana startup dapat berhasil di sebuah pameran dunia besar, menggunakan Web Summit 2018 sebagai contoh</a></li>
<li><a href="../id432928/index.html">Apa yang terjadi di Intel dan mengapa Amazon tidak akan mentransfer AWS sepenuhnya ke chip-nya meskipun ada berita utama yang keras</a></li>
<li><a href="../id432930/index.html">Eksploitasi Rabu Desember 2018: untuk menguji waktu yang baru, mereka melaju ...</a></li>
<li><a href="../id432932/index.html">Ekosistem dunia pengadaan digital (untuk mencuri lebih sedikit)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>