<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüé§ üëçüèª üöà Pylint de l'int√©rieur vers l'ext√©rieur. Comment fait-il üéø üõê üëö</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Divers assistants dans l'√©criture de code cool nous entourent, linter, typekchera, utilitaire pour trouver des vuln√©rabilit√©s, tous avec nous. Nous y ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pylint de l'int√©rieur vers l'ext√©rieur. Comment fait-il</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/433474/">  Divers assistants dans l'√©criture de code cool nous entourent, linter, typekchera, utilitaire pour trouver des vuln√©rabilit√©s, tous avec nous.  Nous y sommes habitu√©s et nous l'utilisons sans entrer dans les d√©tails comme une ¬´bo√Æte noire¬ª.  Par exemple, peu de gens comprennent les principes de Pylint, l'un de ces outils indispensables pour optimiser et am√©liorer le code Python. <br><br>  Mais <strong>Maxim Mazaev</strong> sait √† quel point il est important de comprendre ses outils, et il nous l'a dit √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Moscow Python Conf ++</a> .  √Ä l'aide d'exemples concrets, il a montr√© comment la connaissance du p√©riph√©rique interne de Pylint et de ses plug-ins a permis de r√©duire le temps de r√©vision du code, d'am√©liorer la qualit√© du code et g√©n√©ralement d'am√©liorer l'efficacit√© du d√©veloppement.  Vous trouverez ci-dessous une instruction de d√©cryptage. <br><br><img src="https://habrastorage.org/webt/4d/mv/i7/4dmvi7slkt32taha4ec14e8kdfg.jpeg"><br><a name="habracut"></a><br><h2>  Pourquoi avons-nous besoin de Pylint? <br></h2><br>  Si vous l'utilisez d√©j√†, la question peut se poser: "Pourquoi savoir ce qu'il y a √† l'int√©rieur de Pylint, comment cette connaissance peut-elle aider?" <br><br>  En r√®gle g√©n√©rale, les d√©veloppeurs √©crivent du code, lancent le linter, re√ßoivent des messages sur ce qu'il faut am√©liorer, comment rendre le code plus beau et apporter les modifications propos√©es.  Maintenant, le code est plus facile √† lire et n'a pas honte de montrer √† ses coll√®gues. <br><br>  Pendant longtemps, ils ont travaill√© exactement de la m√™me mani√®re avec Pylint au Cyan Institute, avec des ajouts mineurs: ils ont chang√© les configurations, supprim√© les r√®gles inutiles et augment√© la longueur maximale des cordes. <br><br>  Mais √† un moment donn√©, ils ont rencontr√© un probl√®me, pour lequel j'ai d√ª creuser profond√©ment dans Pylint et comprendre comment cela fonctionne.  Quel est ce probl√®me et comment le r√©soudre, lisez la suite. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZKoBZkdYLiM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>√Ä propos du conf√©rencier:</strong> Maxim Mazaev ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">barre oblique inverse</a> ), 5 ans de d√©veloppement, travaille au CIAN.  Apprend en profondeur Python, la programmation asynchrone et fonctionnelle. <br><br><h2>  √Ä propos du cyan <br></h2><br>  La plupart croient que CIAN est une agence immobili√®re avec des agents immobiliers et sont tr√®s surpris lorsqu'ils d√©couvrent qu'au lieu d'agents immobiliers, nous avons des programmeurs. <br><br>  Nous sommes une entreprise technique dans laquelle il n'y a pas d'agents immobiliers, mais il y a beaucoup de programmeurs. <br><br><ul><li>  1 million d'utilisateurs uniques par jour. </li><li>  Le plus grand tableau d'affichage pour la vente et la location de biens immobiliers √† Moscou et √† Saint-P√©tersbourg.  En 2018, ils sont entr√©s au niveau f√©d√©ral et travaillent dans toute la Russie. </li><li>  Pr√®s de 100 personnes dans l'√©quipe de d√©veloppement, dont 30 √©crivent du code Python quotidiennement. </li></ul><br>  Chaque jour, des centaines et des milliers de lignes de nouveau code entrent en production.  Les exigences pour le code sont assez simples: <br><br><ul><li>  Code de qualit√© d√©cente. </li><li>  Homog√©n√©it√© stylistique.  Tous les d√©veloppeurs doivent √©crire du code √† peu pr√®s similaire, sans "vinaigrette" dans les r√©f√©rentiels. </li></ul><br>  Pour y parvenir, bien s√ªr, vous avez besoin d'une r√©vision du code. <br><br><h2>  Examen du code <br></h2><br>  L'examen du code dans CIAN se d√©roule en deux √©tapes: <br><br><ol><li>  La premi√®re √©tape est <strong>automatis√©e</strong> .  Le robot Jenkins ex√©cute les tests, ex√©cute Pylint et v√©rifie la coh√©rence de l'API entre les microservices, puisque nous utilisons des microservices.  Si √† ce stade les tests √©chouent ou que le linter montre quelque chose d'√©trange, alors c'est une occasion de rejeter la demande d'extraction et d'envoyer le code pour r√©vision. <br></li><li>  Si la premi√®re √©tape a r√©ussi, la deuxi√®me vient - l'approbation de <strong>deux</strong> <strong>d√©veloppeurs</strong> .  Ils peuvent √©valuer la qualit√© du code en termes de logique m√©tier, approuver une demande d'extraction ou renvoyer le code pour r√©vision. <br></li></ol><br><h3><br>  Probl√®mes de r√©vision de code <br></h3><br>  La demande d'extraction peut ne pas r√©ussir l'examen du code en raison de: <br><br><ul><li>  des erreurs dans la logique m√©tier lorsqu'un d√©veloppeur a r√©solu de mani√®re inefficace ou incorrecte un probl√®me; </li><li>  probl√®mes de style de code. </li></ul><br>  Quels pourraient √™tre les probl√®mes de style si le linter v√©rifie le code? <br><br>  Tous ceux qui √©crivent en Python savent qu'il existe un guide pour √©crire du code <strong>PEP-8</strong> .  Comme toute norme, PEP-8 est assez g√©n√©ral et nous, en tant que d√©veloppeurs, ne sommes pas assez.  Je veux sp√©cifier la norme √† certains endroits et d√©velopper √† d'autres. <br><br>  Par cons√©quent, nous avons √©labor√© nos dispositions internes sur la fa√ßon dont le code devrait ressembler et fonctionner, et nous les avons appel√©es <strong>¬´propositions Cian refus√©es¬ª</strong> . <br><br><img src="https://habrastorage.org/webt/u8/rk/tw/u8rktwmht5bmkqktwuoof_kbohs.png"><br><br>  ¬´Decline Cian Proposals¬ª - un ensemble de r√®gles, il y en a maintenant environ 15. Chacune de ces r√®gles est √† la base du rejet de la demande et de sa r√©vision. <br><br><h3>  Qu'est-ce qui emp√™che une r√©vision productive du code? <br></h3><br><blockquote>  Il y a un probl√®me avec nos r√®gles internes - le linter ne les conna√Æt pas, et il serait √©trange qu'il le sache - elles sont internes. <br></blockquote>  Le d√©veloppeur qui ex√©cute la t√¢che doit toujours se souvenir et garder les r√®gles √† l'esprit.  S'il oublie l'une des r√®gles, au cours du processus de r√©vision du code, les r√©viseurs indiqueront le probl√®me, la t√¢che sera r√©vis√©e et le temps de publication de la t√¢che augmentera.  Apr√®s l'ach√®vement et la correction des erreurs, les testeurs doivent se rappeler ce qui √©tait dans la t√¢che, pour changer de contexte. <br><br>  Cela cr√©e un probl√®me pour le d√©veloppeur et les r√©viseurs.  En cons√©quence, la vitesse de r√©vision du code est consid√©rablement r√©duite.  Au lieu d'analyser la logique du code, les testeurs commencent √† analyser le style visuel, c'est-√†-dire qu'ils effectuent le travail du linter: ils scannent le code ligne par ligne et recherchent les incoh√©rences dans l'indentation dans le format d'importation. <br><br>  Nous aimerions nous d√©barrasser de ce probl√®me. <br><br><h2>  Mais ne nous √©crivez pas votre linter? <br></h2><br>  Il semble que le probl√®me sera r√©solu par un outil qui conna√Ætra tous les accords internes et pourra v√©rifier le code pour leur mise en ≈ìuvre.  Nous avons donc besoin de notre propre linter? <br><br>  Pas vraiment.  L'id√©e est stupide, car nous utilisons d√©j√† Pylint.  C'est un linter pratique, appr√©ci√© des d√©veloppeurs et int√©gr√© √† tous les processus: il s'ex√©cute dans Jenkins, g√©n√®re de beaux rapports qui sont enti√®rement satisfaits et sous forme de commentaires viennent tirer la requ√™te.  Tout va bien, un <strong>deuxi√®me linter n'est pas n√©cessaire</strong> . <br><br>  Alors, comment r√©soudre le probl√®me si nous ne voulons pas √©crire notre propre linter? <br><br><h2>  √âcrire un plugin Pylint <br></h2><br>  Vous pouvez √©crire des plugins pour Pylint, ils sont appel√©s checkers.  Sous chaque r√®gle interne, vous pouvez √©crire votre propre v√©rificateur, qui le v√©rifiera. <br><br>  Prenons deux exemples de ces v√©rificateurs. <br><br><h3>  Exemple n ¬∞ 1 <br></h3><br>  √Ä un moment donn√©, il s'est av√©r√© que le code contient de nombreux commentaires de la forme ¬´TODO¬ª - promet de refactoriser, de supprimer le code inutile ou de le r√©√©crire magnifiquement, mais pas maintenant, mais plus tard.  Il y a un probl√®me avec de tels commentaires - ils ne vous obligent absolument √† rien. <br><br><h4>  Le probl√®me <br></h4><br>  Le d√©veloppeur a √©crit une promesse, a exhal√© et est all√© l'esprit tranquille pour faire la prochaine t√¢che. <br><img src="https://habrastorage.org/webt/ji/fk/js/jifkjskaly04vj5ljo74qrb0ys8.png"><br><br>  En r√©sum√©: <br><br><ul><li>  les commentaires avec des promesses pendent au fil des ans et ne sont pas suivis; </li><li>  le code est jonch√©; </li><li>  la dette technique s'accumule depuis des ann√©es. </li></ul><br>  Par exemple, un d√©veloppeur a promis il y a 3 ans de supprimer quelque chose apr√®s une version r√©ussie, mais la version a-t-elle eu lieu dans 3 ans?  Peut-√™tre que oui.  Dois-je supprimer le code dans ce cas?  C'est une grande question, mais probablement pas. <br><br><h4>  Solution: √©crivez votre v√©rificateur pour Pylint <br></h4><br>  Vous ne pouvez pas interdire aux d√©veloppeurs d'√©crire de tels commentaires, mais vous pouvez leur faire faire un travail suppl√©mentaire: cr√©ez une t√¢che dans le tracker pour finaliser la promesse.  Ensuite, nous ne l'oublierons certainement pas. <br><br>  Nous devons trouver tous les commentaires du formulaire TODO et nous assurer que chacun d'eux a un lien vers une t√¢che dans Jira.  √âcrivons. <br><br>  Qu'est-ce qu'un v√©rificateur en termes de Pylint?  Il s'agit d'une classe qui h√©rite de la classe de base du v√©rificateur et impl√©mente une certaine interface. <br><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TodoIssueChecker</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BaseChecker)</span></span></span><span class="hljs-class">:</span></span> _ _implements_ _ = IRawChecker</code> </pre> <br>  Dans notre cas, c'est <strong>IRawChecker</strong> - le soi-disant v√©rificateur ¬´brut¬ª. <br><br>  Un v√©rificateur brut parcourt les lignes d'un fichier et peut effectuer une certaine action sur une ligne.  Dans notre cas, sur chaque ligne, le v√©rificateur recherchera quelque chose de similaire √† un commentaire et un lien vers une t√¢che. <br><br>  Pour le v√©rificateur, vous devez d√©terminer la liste des messages qu'il √©mettra: <br><br><pre> <code class="python hljs">msgs = { <span class="hljs-string"><span class="hljs-string">'9999'</span></span>: (<span class="hljs-string"><span class="hljs-string">'  TODO    '</span></span>, issue-code-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>-todo<span class="hljs-string"><span class="hljs-string">', '</span></span> <span class="hljs-string"><span class="hljs-string">')}</span></span></code> </pre><br>  Le message a: <br><br><ul><li>  la description est courte et longue; </li><li>  code v√©rificateur et un nom mn√©monique court qui d√©termine de quel type de message il s'agit. </li></ul><br>  Le code du message a la forme "C1234", dans lequel: <br><br><ul><li>  La premi√®re lettre est clairement standardis√©e pour diff√©rents types de messages: <strong>[C]</strong> onvention;  <strong>[W]</strong> arning;  <strong>[E]</strong> yog;  <strong>[F]</strong> atal;  <strong>[R]</strong> efactoring.  Gr√¢ce √† la lettre, le rapport montre imm√©diatement ce qui se passe: un rappel des accords ou des probl√®mes fatals qui doivent √™tre r√©solus de toute urgence. </li><li>  4 nombres al√©atoires uniques √† Pylint. </li></ul><br>  Le code est n√©cessaire pour d√©sactiver la v√©rification si elle devient inutile.  Vous pouvez √©crire Pylint: disable et un code alphanum√©rique court ou un nom mn√©monique: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Pylint: disable=C9999 # Pylint: disable=issue-code-in-todo</span></span></code> </pre><br>  Les auteurs de Pylint recommandent d'abandonner le code alphanum√©rique et d'utiliser le mn√©monique, c'est plus visuel. <br><br>  L'√©tape suivante consiste √† d√©finir une m√©thode appel√©e <strong>process_module</strong> . <br><br><img src="https://habrastorage.org/webt/25/cg/lc/25cglcdvsxu5qwgwv6fwhmhuvyu.jpeg"><br><br>  Le nom est tr√®s important.  La m√©thode doit √™tre appel√©e de cette fa√ßon, car Pylint l'appellera ensuite. <br><br>  Le param√®tre de <strong>n≈ìud</strong> est transmis au module.  Dans ce cas, peu importe de quoi il s'agit ou de quel type il s'agit, il est seulement important de se rappeler que le n≈ìud a une m√©thode de <strong>flux</strong> qui renvoie un fichier ligne par ligne. <br><br>  Vous pouvez parcourir le fichier et pour chaque ligne v√©rifier les commentaires et les liens vers la t√¢che.  S'il y a un commentaire, mais pas de lien, lancez un avertissement du formulaire <strong>¬´issue-code-in-todo¬ª</strong> avec le code du v√©rificateur et le num√©ro de ligne.  L'algorithme est assez simple. <br><br>  Enregistrez le v√©rificateur pour que Pylint le sache.  Cela se fait par la fonction de <strong>registre</strong> : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(linter: Pylinter)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> linter. register_checker ( TodoIssueChecker(linter) )</code> </pre><br><ul><li>  Une instance de Pylint entre dans la fonction. </li><li>  Il appelle la m√©thode register_checker. </li><li>  Nous passons le v√©rificateur √† la m√©thode. </li></ul><br>  <strong>Un point important: le</strong> module checker doit √™tre en PYTHONPATH pour que Pylint puisse l'importer plus tard. <br><br>  Un v√©rificateur enregistr√© est v√©rifi√© par un fichier de test avec des commentaires sans liens vers des t√¢ches. <br><br><pre> <code class="python hljs">$ cat work. <span class="hljs-comment"><span class="hljs-comment"># T0D0:   , -! $ pylint work. --load-plugins todo_checker ‚Ä¶</span></span></code> </pre><br>  Pour le test, ex√©cutez Pylint, passez-lui le module, utilisez le param√®tre <strong>load-plugins</strong> pour passer le v√©rificateur et √† l'int√©rieur du linter, ex√©cutez deux phases. <br><br><h4>  Phase 1. Initialisation du plugin <br></h4><br><ul><li>  Tous les modules avec plugins sont import√©s.  Pylint a des contr√¥leurs internes et externes.  Ils se r√©unissent tous et sont import√©s. </li><li>  Nous nous <strong>inscrivons</strong> - <strong>module.register (self)</strong> .  Pour chaque v√©rificateur, la fonction de registre est appel√©e, o√π l'instance Pylint est pass√©e. </li><li>  Des contr√¥les sont effectu√©s: pour la validit√© des param√®tres, pour la pr√©sence de messages, d'options et de rapports dans le format correct. </li></ul><br><h4>  Phase 2. Analyser le pool de v√©rificateurs <br></h4><br>  Apr√®s la phase 1, il reste une liste compl√®te de diff√©rents types de v√©rificateurs: <br><br><ul><li>  V√©rificateur AST; </li><li>  V√©rificateur brut; </li><li>  V√©rificateur de jetons. </li></ul><br><img src="https://habrastorage.org/webt/iy/o-/e9/iyo-e93tezy3y4iczp5d8regoog.jpeg"><br><br>  Dans la liste, nous s√©lectionnons ceux qui se rapportent √† l'interface du v√©rificateur brut: nous regardons quels v√©rificateurs impl√©mentent l'interface IRawChecker et les prenons pour nous-m√™mes. <br><br>  Pour chaque v√©rificateur s√©lectionn√©, appelez la <strong>m√©thode checker.process_module (module)</strong> et ex√©cutez la v√©rification. <br><br><h4>  R√©sultat <br></h4><br>  Ex√©cutez √† nouveau le v√©rificateur sur le fichier de test: <br><br><pre> <code class="python hljs">$ cat work. <span class="hljs-comment"><span class="hljs-comment"># T0D0:   , -! $ pylint work,  --load-plugins todo_checker : 0,0:   T0D0     (issue-code-in-todo)</span></span></code> </pre><br>  Un message appara√Ætra indiquant qu'il y a un commentaire avec TODO et aucun lien vers la t√¢che. <br><br>  Le probl√®me est r√©solu et maintenant dans le processus de r√©vision du code, les d√©veloppeurs n'ont plus besoin de scanner le code avec leurs yeux, de trouver des commentaires, d'√©crire un rappel √† l'auteur du code qu'il existe un accord et il est conseill√© de laisser un lien.  Tout se passe automatiquement et la r√©vision du code est un peu plus rapide. <br><br><h3>  Exemple n ¬∞ 2. arguments-mots-cl√©s <br></h3><br>  Il existe des fonctions qui prennent des arguments positionnels.  S'il y a beaucoup d'arguments, alors quand ils appellent la fonction, il n'est pas tr√®s clair o√π l'argument est et pourquoi il est n√©cessaire. <br><br><h4>  Le probl√®me <br></h4><br>  Par exemple, nous avons une fonction: <br><br><pre> <code class="python hljs">get_offer_by_cian_id( <span class="hljs-string"><span class="hljs-string">"sale"</span></span>, rue, <span class="hljs-number"><span class="hljs-number">859483</span></span>, )</code> </pre><br>  Le code a <strong>vente</strong> et <strong>True,</strong> et on ne sait pas ce qu'ils signifient.  C'est beaucoup plus pratique lorsque les fonctions dans lesquelles il y a beaucoup d'arguments sont appel√©es uniquement avec des arguments nomm√©s: <br><br><pre> <code class="python hljs">get_offer_by_cian_id( deal_type=<span class="hljs-string"><span class="hljs-string">"sale"</span></span>, truncate=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, cian_id=<span class="hljs-number"><span class="hljs-number">859483</span></span>, )</code> </pre><br>  C'est un bon code, dans lequel il est imm√©diatement clair o√π se trouve le param√®tre et nous ne confondrons pas leur s√©quence.  Essayons d'√©crire un v√©rificateur qui v√©rifie de tels cas. <br><br>  Le v√©rificateur "brut" utilis√© dans l'exemple pr√©c√©dent est tr√®s difficile √† √©crire pour un tel cas.  Vous pouvez ajouter des expressions r√©guli√®res super complexes, mais ce code est difficile √† lire.  Il est bon que Pylint permette d'√©crire un autre type de v√©rificateur bas√© sur l'arbre de syntaxe abstraite <strong>AST</strong> , et nous l'utiliserons. <br><br><h4>  Paroles sur AST <br></h4><br>  Un arbre de syntaxe AST ou abstraite est une repr√©sentation arborescente du code, o√π le sommet est les op√©randes et les feuilles sont des op√©rateurs. <br><br>  Par exemple, un appel de fonction, o√π il y a un argument positionnel et deux arguments nomm√©s, est transform√© en un arbre abstrait: <br><img src="https://habrastorage.org/webt/k3/zi/hu/k3zihuknbk9txzbwffdwcwr5gf4.jpeg"><br><br>  Il existe un sommet de type <strong>Appel</strong> et il a: <br><br><ul><li>  attributs de fonction appel√©s func; </li><li>  une liste d'arguments positionnels args, o√π il existe un n≈ìud de type Const et une valeur de 112; </li><li>  liste des arguments nomm√©s Mots cl√©s. </li></ul><br>  La t√¢che dans ce cas: <br><br><ul><li>  Trouvez dans le module tous les n≈ìuds de type Appel (appel de fonction). </li><li>  Calculez le nombre total d'arguments pris par la fonction. </li><li>  S'il y a plus de 2 arguments, assurez-vous qu'il n'y a pas d'arguments positionnels dans le n≈ìud. </li><li>  S'il y a des arguments positionnels, affichez un avertissement. </li></ul><br><br><pre> <code class="python hljs">ll( func=Name(name=<span class="hljs-string"><span class="hljs-string">'get_offer'</span></span>), args=[Const(value=<span class="hljs-number"><span class="hljs-number">1298880</span></span>)], keywords=[ ‚Ä¶ ]))]</code> </pre><br>  Du point de vue de Pylint, un v√©rificateur bas√© sur AST est une classe qui h√©rite de la classe de v√©rificateur de base et impl√©mente l'interface <strong>IAstroidChecker</strong> : <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NonKeywordArgsChecker</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BaseChecker)</span></span></span><span class="hljs-class">:</span></span> -_ _implements_ _ = IAstroidChecker</code> </pre><br>  Comme dans le premier exemple, la description du v√©rificateur, le code du message, le nom mn√©monique court sont indiqu√©s dans la liste des messages: <br><br><pre> <code class="python hljs">msgs = { <span class="hljs-string"><span class="hljs-string">'9191'</span></span>: (<span class="hljs-string"><span class="hljs-string">' '</span></span>, keyword-only-args<span class="hljs-string"><span class="hljs-string">', '</span></span> <span class="hljs-string"><span class="hljs-string">')}</span></span></code> </pre><br>  L'√©tape suivante consiste √† d√©finir la m√©thode <strong>visit_call</strong> : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit_call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, node: Call)</span></span></span><span class="hljs-function"> ‚Ä¶</span></span></code> </pre><br>  La m√©thode n'a pas √† √™tre appel√©e ainsi.  La chose la plus importante est le pr√©fixe visit_, puis vient le nom du sommet qui nous int√©resse, avec une petite lettre. <br><br><ul><li>  L'analyseur AST parcourt l'arbre et pour chaque sommet, il cherche √† voir si l'interface checkr visit_ &lt;Name&gt; est d√©finie. </li><li>  Si oui, appelez-le. </li><li>  R√©cursivement passe par tous ses enfants. </li><li>  En quittant un n≈ìud, il appelle la m√©thode Leave_ &lt;Name&gt;. </li></ul><br>  Dans cet exemple, la m√©thode visit_call recevra un n≈ìud de type appel en entr√©e et verra s'il a plus de deux arguments et si des arguments positionnels sont pr√©sents pour lancer un avertissement et transmettre le code au n≈ìud lui-m√™me. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit_call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node.args <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(node.args + node.keywords) &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>: self.add_message( <span class="hljs-string"><span class="hljs-string">'keyword-only-args'</span></span>, node=node )</code> </pre><br>  Nous enregistrons le v√©rificateur, comme dans l'exemple pr√©c√©dent: nous transf√©rons l'instance Pylint, appelons register_checker, passons le v√©rificateur lui-m√™me et le d√©marrons. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(linter: Pylinter)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> linter.register_checker( TodoIssueChecker(linter) )</code> </pre><br>  Voici un exemple d'appel de fonction de test dans lequel il y a 3 arguments et un seul d'entre eux est nomm√©: <br><br><pre> <code class="python hljs">$ cat work. get_offers(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, deal_type=<span class="hljs-string"><span class="hljs-string">"sale"</span></span>) $ Pylint work.py --load-plugins non_kwargs_checker ‚Ä¶</code> </pre><br>  Il s'agit d'une fonction qui est potentiellement appel√©e incorrectement de notre point de vue.  Lancez Pylint. <br><br>  La phase d'initialisation du plugin 1 est compl√®tement r√©p√©t√©e, comme dans l'exemple pr√©c√©dent. <br><br><h4>  Phase 2. Analyse du module chez AST <br></h4><br>  Le code est analys√© dans un arbre AST.  L'analyse est r√©alis√©e par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la biblioth√®que Astroid</a> . <br><br><h4>  Pourquoi Astroid, pas AST (stdlib) <br></h4><br>  Astroid n'utilise pas en interne le module Python AST standard, mais l' <strong>analyseur typ√© AST typed_ast</strong> , qui diff√®re en ce qu'il prend en charge les <strong>indications de type</strong> PEP 484. <strong>Typed_ast</strong> est une branche d'AST, une fourchette qui se d√©veloppe en parall√®le.  Fait int√©ressant, il y a les m√™mes bogues qui sont dans AST et sont r√©par√©s en parall√®le. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> module <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Entity <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bar)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># type: (Entity) -&gt; None return</span></span></code> </pre><br>  Auparavant, Astroid utilisait le module AST standard, dans lequel on pouvait rencontrer le probl√®me de l'utilisation des astuces d√©finies dans les commentaires utilis√©s dans le second Python.  Si vous v√©rifiez ce code via Pylint, jusqu'√† un certain point, il jurerait lors de l'importation inutilis√©e, car la classe Entity import√©e n'est pr√©sente que dans le commentaire. <br><br><blockquote>  √Ä un moment donn√© sur GitHub, Guido Van Rossum est venu chez Astroid et a d√©clar√©: ¬´Les gars, vous avez Pylint qui jure sur de tels cas, et nous avons un analyseur AST typ√© qui prend en charge tout cela.  Soyons amis! " <br></blockquote><br>  Le travail a commenc√© √† bouillir!  2 ans se sont √©coul√©s, ce printemps, Pylint est pass√© √† un analyseur AST typ√© et a cess√© de jurer de telles choses.  Les importations de taiphints ne sont plus marqu√©es comme inutilis√©es. <br><br>  Astroid utilise un analyseur AST pour analyser le code dans un arbre, puis fait des choses int√©ressantes lors de sa construction.  Par exemple, si vous utilisez <strong>import *</strong> , il importe tout avec un ast√©risque et ajoute aux sections locales pour √©viter les erreurs avec les importations inutilis√©es. <br><br>  <strong>Les plugins Transform</strong> sont utilis√©s dans les cas o√π il existe des mod√®les complexes bas√©s sur des m√©ta-classes, lorsque tous les attributs sont g√©n√©r√©s dynamiquement.  Dans ce cas, Astroid est tr√®s difficile √† comprendre.  Lors de la v√©rification, Pylint jure que les mod√®les n'ont pas un tel attribut lors de son acc√®s, et en utilisant les plugins Transform, vous pouvez r√©soudre le probl√®me: <br><br><ul><li>  Aidez Astroid √† modifier l'arbre abstrait et √† comprendre la nature dynamique de Python. </li><li>  Compl√©tez AST avec des informations utiles. </li></ul><br>  Un exemple typique est <strong>pylint-django</strong> .  Lorsque vous travaillez avec des mod√®les django complexes, le linter jure souvent sur des attributs inconnus.  Pylint-django r√©sout simplement ce probl√®me. <br><br><h4>  Phase 3. Analyser le pool de v√©rificateurs <br></h4><br>  Nous revenons au v√©rificateur.  Nous avons √† nouveau une liste de v√©rificateurs, √† partir de laquelle nous trouvons ceux qui impl√©mentent l'interface du v√©rificateur AST. <br><br><h4>  Phase 4. Analyser les v√©rificateurs par types de n≈ìuds <br></h4><br>  Ensuite, nous trouvons des m√©thodes pour chaque v√©rificateur, elles peuvent √™tre de deux types: <br><br><ul><li>  visit_ &lt;Nom du n≈ìud&gt; </li><li>  lev_ &lt;nom du n≈ìud&gt;. </li></ul><br>  Ce serait bien de savoir quels n≈ìuds vous devez appeler pour un n≈ìud en marchant dans un arbre.  Par cons√©quent, ils comprennent le dictionnaire, o√π la cl√© est le nom du n≈ìud, la valeur est une liste des v√©rificateurs int√©ress√©s par le fait d'acc√©der √† ce n≈ìud. <br><br><pre> <code class="python hljs">_visit_methods = dict( &lt; &gt; : [checker1, checker2 ... checkerN] )</code> </pre><br>  La m√™me chose avec les m√©thodes de cong√©: une cl√© sous la forme d'un nom de n≈ìud, une liste de v√©rificateurs qui sont int√©ress√©s par le fait de sortir de ce n≈ìud. <br><br><pre> <code class="python hljs">_leave_methods = dict( &lt; &gt;: [checker1, checker2 ... checkerN] )</code> </pre><br>  Lancez Pylint.  Il montre un avertissement que nous avons une fonction o√π il y a plus de deux arguments et qui contient un argument positionnel: <br><br><pre> <code class="python hljs">$ cat work. get_offers(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, deal_type=<span class="hljs-string"><span class="hljs-string">"sale"</span></span>) $ Pylint work.py --load-plugins non_kwargs_checker C: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>:  c &gt;<span class="hljs-number"><span class="hljs-number">2</span></span>      (keyword-only-args)</code> </pre><br>  Le probl√®me est r√©solu.  D√©sormais, les programmeurs de r√©vision de code n'ont pas besoin de lire les arguments de la fonction; le linter le fera pour eux.  <strong>Nous avons gagn√© du temps</strong> , du temps pour la r√©vision du code et les t√¢ches vont plus vite en production. <br><br><h2>  Et pour √©crire des tests? <br></h2><br>  Pylint vous permet d'effectuer des tests unitaires de contr√¥leurs et c'est tr√®s simple.  Du point de vue du linter, le test-checker ressemble √† une classe qui h√©rite du <strong>CheckerTestCase</strong> abstrait.  Il est n√©cessaire d'indiquer le v√©rificateur qui est en cours de v√©rification. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestNonKwArgsChecker</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(CheckerTestCase)</span></span></span><span class="hljs-class">:</span></span> CHECKER_CLASS = NonKeywordArgsChecker</code> </pre><br>  √âtape 1. Nous cr√©ons un n≈ìud AST de test √† partir de la partie du code que nous v√©rifions. <br><br><pre> <code class="python hljs">node = astroid.extract_node( <span class="hljs-string"><span class="hljs-string">"get_offers(3, 'magic', 'args')"</span></span> )</code> </pre><br>  √âtape 2. V√©rifiez que le v√©rificateur, entrant dans le n≈ìud, l√®ve ou ne jette pas le message correspondant: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> self.assertAddsMessages(message): self.checker.visit_call(node)</code> </pre><br><h2>  Tokenchecker <br></h2><br>  Il existe un autre type de v√©rificateur appel√© <strong>TokenChecker</strong> .  Il fonctionne sur le principe d'un analyseur lexical.  Python poss√®de un module <strong>tokenize</strong> qui fait le travail d'un scanner lexical et divise le code en une liste de jetons.  Cela pourrait ressembler √† ceci: <br><img src="https://habrastorage.org/webt/ul/vj/bl/ulvjblhatvsted81sc1drmjn2io.png"><br><br>  Les noms de variable, les noms de fonction et les mots cl√©s deviennent des jetons de type NAME et les d√©limiteurs, crochets et deux-points deviennent des jetons de type OP.  De plus, il existe des jetons distincts pour l'indentation, le saut de ligne et la traduction inverse. <br><br>  Comment Pylint fonctionne avec TokenChecker: <br><br><ul><li>  Le module test√© est tokenis√©. </li><li>  Une √©norme liste de jetons est transmise √† tous les v√©rificateurs qui impl√©mentent ITokenChecker et la m√©thode <strong>process_tokens</strong> (jetons) est <strong>appel√©e</strong> . </li></ul><br>  Nous n'avons pas trouv√© l'utilisation de TokenChecker, mais il y a quelques exemples que Pylint utilise: <br><br><ul><li>  <strong>V√©rification orthographique</strong> .  Par exemple, vous pouvez prendre tous les jetons avec du texte de type et regarder l'alphab√©tisation lexicale, v√©rifier les mots des listes de mots vides, etc. </li><li>  <strong>V√©rifiez les retraits</strong> , les espaces. </li><li>  <strong>Travaillez avec des cordes</strong> .  Par exemple, vous pouvez v√©rifier que Python 3 n'utilise pas de litt√©raux Unicode ou v√©rifier que seuls les caract√®res ASCI sont pr√©sents dans la cha√Æne d'octets. </li></ul><br><h2>  Conclusions <br></h2><br>  Nous avons eu un probl√®me avec la r√©vision du code.  Les d√©veloppeurs ont effectu√© le travail du linter, ont pass√© leur temps √† balayer du code inutile et √† informer l'auteur des erreurs.  Avec Pylint, nous: <br><br><ul><li>  Transfert des v√©rifications de routine au linter, mise en ≈ìuvre des accords internes. </li><li>  Augmentation de la vitesse et de la r√©vision du code de qualit√©. </li><li>  R√©duction du nombre de demandes d'extraction rejet√©es et r√©duction du temps de passage des t√¢ches en production. </li></ul><br>  Un simple v√©rificateur est √©crit en une demi-heure, et un complexe en quelques heures.  Le v√©rificateur √©conomise beaucoup plus de temps qu'il n'en faut pour l'√©criture et se bat pour plusieurs demandes d'extraction non rejet√©es. <br><br>  Vous pouvez en savoir plus sur Pylint et comment √©crire des v√©rificateurs dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation officielle</a> , mais en termes d'√©criture de v√©rificateurs, c'est plut√¥t m√©diocre.  Par exemple, √† propos de TokenChecker, il n'y a qu'une mention, mais pas sur la fa√ßon d'√©crire le v√©rificateur lui-m√™me.  Plus d'informations sont disponibles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans les sources Pylint sur GitHub</a> .  Vous pouvez voir ce que les v√©rificateurs sont dans le package standard et vous inspirer pour √©crire le v√¥tre. <br><br>  <em>La connaissance de la conception interne de Pylint √©conomise des heures de travail et simplifie</em> <em><br></em>  <em>performances et am√©liore le code.</em>  <em>√âconomisez votre temps, √©crivez un bon code et</em> <em><br></em>  <em>utilisez du linter.</em> <br><blockquote>  La prochaine conf√©rence <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Moscow Python Conf ++</a> se tiendra <b>le 5 avril 2019</b> et vous pouvez d√©j√† r√©server un billet anticip√© Birf maintenant.  Il est encore mieux de recueillir vos r√©flexions et de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">demander</a> un rapport, puis la visite sera gratuite et de jolis petits pains seront offerts en prime, y compris du coaching sur la pr√©paration du rapport. <br><br>  Notre conf√©rence est une plate-forme pour rencontrer des personnes partageant les m√™mes id√©es, les moteurs de l'industrie, pour communiquer et discuter des choses que les d√©veloppeurs Python aiment: backend et web, collecte et traitement de donn√©es, AI / ML, tests, IoT.  Comment cela s'est pass√© √† l'automne, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">regardez le reportage vid√©o</a> sur notre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cha√Æne Python</a> et abonnez-vous √† la cha√Æne - bient√¥t, nous publierons les meilleurs rapports de la conf√©rence en acc√®s gratuit. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr433474/">https://habr.com/ru/post/fr433474/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr433456/index.html">Comment convaincre un client ou une entreprise d'utiliser Flutter</a></li>
<li><a href="../fr433458/index.html">Quelques avantages √©vidents de Serverless pour DevOps</a></li>
<li><a href="../fr433462/index.html">Contr√¥les d'int√©grit√© et d√©gradation progressive des syst√®mes distribu√©s</a></li>
<li><a href="../fr433466/index.html">Comparez les pages. Plugin simple pour Atlassian Confluence</a></li>
<li><a href="../fr433472/index.html">Unity 2018.3 est sorti</a></li>
<li><a href="../fr433476/index.html">50 nuances de c√©leri</a></li>
<li><a href="../fr433478/index.html">Pourquoi Django est choisi dans Tinkoff Magazine</a></li>
<li><a href="../fr433480/index.html">Histoire d'Holivarny sur Linter</a></li>
<li><a href="../fr433482/index.html">Django sous microscope</a></li>
<li><a href="../fr433486/index.html">Quoi encore? Le renouveau des cartes de d√©bit non bancaires</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>