<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙅🏼 🕥 🎋 在机器学习项目中构建工具，概述 ✊🏿 💢 🤟🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我想知道机器学习/数据科学项目的结构/工作流程，并在阅读有关该主题的不同意见。 当人们开始谈论工作流时，他们希望其工作流具有可复制性。 有很多建议使用make来保持工作流程可重复的帖子。 尽管make非常稳定且使用广泛，但我个人还是喜欢跨平台解决方案。 毕竟是2019年，而不是1977年。有人可以说...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在机器学习项目中构建工具，概述</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451962/">我想知道机器学习/数据科学项目的结构/工作流程，并在阅读有关该主题的不同意见。 当人们开始谈论工作流时，他们希望其工作流具有可复制性。 有很多建议使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">make</a>来保持工作流程可重复的帖子。 尽管<code>make</code>非常稳定且使用广泛，但我个人还是喜欢跨平台解决方案。 毕竟是2019年，而不是1977年。有人可以说使自己是跨平台的，但实际上，您会遇到麻烦，并且会花时间修复工具而不是进行实际工作。 因此，我决定环顾四周，并查看可用的其他工具。 是的，我决定花一些时间在工具上。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aff/fbf/656/afffbf6566a6e67ea6427d28d76d7eea.png" alt="图片"></div><br> 这篇文章更多是对话邀请而不是教程。 也许您的解决方案是完美的。 如果是这样，那么听到它将会很有趣。 <br><br> 在本文中，我将使用一个小的Python项目，并在不同的系统上执行相同的自动化任务： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CMake的</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Pybuilder</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">nt</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">摊铺机</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">做</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">路易吉</a> </li></ul><br> 帖子末尾会有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">比较表</a> 。 <br><a name="habracut"></a><br> 我将介绍的大多数工具都称为<em>构建自动化软件</em>或<em>构建系统</em> 。 它们有无数种，口味各异，大小和复杂程度各不相同。 想法是一样的：开发人员定义规则以自动且一致的方式产生一些结果。 例如，结果可能是带有图形的图像。 为了制作此图像，需要下载数据，清理数据并进行一些数据操作（确实是经典示例）。 您可以从几个可以完成此工作的shell脚本开始。 一年后返回项目后，将很难记住制作该图像所需的所有步骤及其顺序。 显而易见的解决方案是记录所有步骤。 好消息！ 构建系统使您可以以计算机程序的形式记录步骤。 一些构建系统就像您的shell脚本一样，但是带有额外的花哨功能。 <br><br> 这篇文章的基础是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Mateusz Bednarski</a>关于机器学习项目的自动化工作流的一系列文章。  Mateusz解释了他的观点，并提供了使用<code>make</code> 。 我鼓励您先检查一下他的帖子。 我将主要使用他的代码，但使用不同的构建系统。 <br><br> 如果您想进一步了解<code>make</code> ，请参考以下几篇文章。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">布鲁克·肯尼迪（Brooke Kennedy）</a>在使您的数据科学项目可重现的5个简单步骤中进行了概述。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Zachary Jones</a>提供了有关语法和功能的更多详细信息，以及指向其他文章的链接。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">大卫·史蒂文斯</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">David Stevens）</a>写了一篇非常炒作的文章，介绍了为什么您绝对必须立即开始使用<code>make</code> 。 他提供了比较<i>旧方法</i>和<i>新方法的</i>很好的例子。 另一方面， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">塞缪尔·兰帕</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Samuel Lampa）</a>写道，为什么使用<code>make</code>是个坏主意。 <br><br> 我对构建系统的选择既不全面也不偏颇。 如果要列出您的清单，则<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wikipedia</a>可能是一个不错的起点。 如上所述，我将介绍<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CMake</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PyBuilder</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pynt</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Paver</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">doit</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Luigi</a> 。 此列表中的大多数工具都是基于python的，这很有意义，因为该项目使用的是Python。 这篇文章不会介绍如何安装工具。 我假设您相当精通Python。 <br><br> 我对测试此功能最感兴趣： <br><br><ol><li> 指定具有依赖关系的两个目标。 我想看看它是如何做到的以及它是多么容易。 </li><li> 检查是否可以进行增量构建。 这意味着构建系统将不会重建自上次运行以来未更改的内容，即您不需要重新下载原始数据。 我还将寻找的另一件事是，依赖关系发生变化时，增量构建。 想象一下，我们有一个依赖图<code>A -&gt; B -&gt; C</code> 如果<code>B</code>发生变化，是否会重建目标<code>C</code> ？ 如果一个？ </li><li> 如果更改了源代码，即更改生成的图形的参数，则检查是否会触发重新构建，下次构建图像​​时必须重新构建。 </li><li> 检查清理构建构件的方法，即删除在构建过程中创建的文件，并回滚到干净的源代码。 </li></ol><br> 我不会使用Mateusz帖子中的所有构建目标，仅使用其中三个来说明原理。 <br><br> 所有代码都可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub</a>上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">找到</a> 。 <br><br><h2><a name="CMake"></a>  CMake的 </h2><br>  CMake是一个构建脚本生成器，它为各种构建系统生成输入文件。 它的名字代表跨平台的制作。  CMake是一种软件工程工具。 主要关注的是构建可执行文件和库。 因此，CMake知道如何根据支持的语言从源代码构建<i>目标</i> 。  CMake分两个步骤执行：配置和生成。 在配置期间，可以根据一种需求配置将来的版本。 例如，在此步骤中给出了用户提供的变量。 生成通常很简单，并且生成构建系统可以使用的文件。 使用CMake，您仍然可以使用<code>make</code> ，但是您可以直接写一个CMake文件，而不是直接编写makefile，这将为您生成makefile。 <br><br> 另一个重要的概念是CMake鼓励<i>进行源外构建</i> 。 源外构建使源代码远离其产生的任何工件。 这对于可执行文件可能具有很大意义，在可执行文件中，单个源代码库可以在不同的CPU体系结构和操作系统下进行编译。 但是，这种方法可能与许多数据科学家的工作方式相矛盾。 在我看来，数据科学界倾向于将数据，代码和结果高度结合在一起。 <br><br> 让我们看看使用CMake实现目标所需要的。 在CMake中定义自定义内容有两种可能性：自定义目标和自定义命令。 不幸的是，与vanila makefile相比，我们将需要同时使用两者，这将导致更多的键入。 自定义目标被认为总是过时的，即，如果有用于下载原始数据的目标，CMake将始终重新下载它。 将自定义命令与自定义目标结合使用可使目标保持最新状态。 <br><br> 对于我们的项目，我们将创建一个名为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CMakeLists.txt</a>的文件，并将其放在项目的根目录中。 让我们检查一下内容： <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">cmake_minimum_required</span></span>(VERSION <span class="hljs-number"><span class="hljs-number">3.14</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> FATAL_ERROR) <span class="hljs-keyword"><span class="hljs-keyword">project</span></span>(Cmake_in_ml VERSION <span class="hljs-number"><span class="hljs-number">0.1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> LANGUAGES NONE)</code> </pre><br> 这部分是基本的。 第二行定义项目的名称，版本，并指定我们将不使用任何内置语言支持（正弦，我们将称为Python脚本）。 <br><br> 我们的第一个目标将下载IRIS数据集： <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(IRIS_URL <span class="hljs-string"><span class="hljs-string">"https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data"</span></span> CACHE <span class="hljs-keyword"><span class="hljs-keyword">STRING</span></span> <span class="hljs-string"><span class="hljs-string">"URL to the IRIS data"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(IRIS_DIR <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span>/data/raw) <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(IRIS_FILE <span class="hljs-variable"><span class="hljs-variable">${IRIS_DIR}</span></span>/iris.csv) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> <span class="hljs-variable"><span class="hljs-variable">${CMAKE_COMMAND}</span></span> -E echo <span class="hljs-string"><span class="hljs-string">"Downloading IRIS."</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/data/download.py <span class="hljs-variable"><span class="hljs-variable">${IRIS_URL}</span></span> <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> <span class="hljs-variable"><span class="hljs-variable">${CMAKE_COMMAND}</span></span> -E echo <span class="hljs-string"><span class="hljs-string">"Done. Checkout ${IRIS_FILE}."</span></span> WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(rawdata ALL DEPENDS <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span>)</code> </pre><br> 第一行定义参数<code>IRIS_URL</code> ，该参数在配置步骤中向用户公开。 如果使用CMake GUI，则可以通过GUI设置此变量： <br><br><img src="https://habrastorage.org/webt/oo/za/pj/oozapjujvjg_q86ndg6r7c5u36a.png"><br><br> 接下来，我们使用IRIS数据集的下载位置定义变量。 然后，我们添加一个自定义命令，该命令将在输出时生成<code>IRIS_FILE</code> 。 最后，我们定义了一个依赖于<code>IRIS_FILE</code>的自定义目标<code>rawdata</code> ，这意味着要构建<code>rawdata</code> <code>IRIS_FILE</code>必须构建<code>rawdata</code> 。 自定义目标的选项<code>ALL</code>表示<code>rawdata</code>将是要构建的默认目标之一。 请注意，我使用<code>CMAKE_CURRENT_SOURCE_DIR</code>来将下载的数据保留在源文件夹中，而不是构建文件夹中。 这仅仅是为了使其与Mateusz相同。 <br><br> 好吧，让我们看看如何使用它。 我目前正在装有已安装MinGW编译器的Windows上运行它。 您可能需要根据需要调整发电机设置（运行<code>cmake --help</code>以查看可用发电机的列表）。 启动终端并转到源代码的父文件夹，然后： <br><br><pre> <code class="bash hljs">mkdir overcome-the-chaos-build <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> overcome-the-chaos-build cmake -G <span class="hljs-string"><span class="hljs-string">"MinGW Makefiles"</span></span> ../overcome-the-chaos</code> </pre><br><div class="spoiler">  <b class="spoiler_title">结果</b> <div class="spoiler_text">  -配置完成 <br>  -完成生成 <br>  -构建文件已写入到：C：/ home / workspace /克服混乱构建 <br></div></div><br> 使用现代CMake，我们可以直接从CMake构建项目。 该命令将调用<code>build all</code>命令： <br><br><pre> <code class="bash hljs">cmake --build .</code> </pre><br><div class="spoiler">  <b class="spoiler_title">结果</b> <div class="spoiler_text"> 扫描目标原始数据的依存关系 <br>  [100％]建立目标原始数据 <br></div></div><br> 我们还可以查看可用目标的列表： <br><br><pre> <code class="bash hljs">cmake --build . --target <span class="hljs-built_in"><span class="hljs-built_in">help</span></span></code> </pre><br> 我们可以通过以下方式删除下载的文件： <br><br><pre> <code class="bash hljs">cmake --build . --target clean</code> </pre><br> 看到我们不需要手动创建清理目标。 <br><br> 现在，我们移至下一个目标-预处理的IRIS数据。  Mateusz通过一个函数创建两个文件： <code>processed.pickle</code>和<code>processed.xlsx</code> 。 您可以看到他如何通过将<code>rm</code>与通配符一起使用来清理此Excel文件。 我认为这不是一个很好的方法。 在CMake中，我们有两种方法来处理它。 第一种选择是使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ADDITIONAL_MAKE_CLEAN_FILES</a>目录属性。 代码将是： <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(PROCESSED_FILE <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span>/data/processed/processed.pickle) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/data/preprocess.py <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> --excel data/processed/processed.xlsx WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> DEPENDS rawdata <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(preprocess DEPENDS <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span>) <span class="hljs-comment"><span class="hljs-comment"># Additional files to clean set_property(DIRECTORY PROPERTY ADDITIONAL_MAKE_CLEAN_FILES ${CMAKE_CURRENT_SOURCE_DIR}/data/processed/processed.xlsx )</span></span></code> </pre><br> 第二个选项是指定文件列表作为自定义命令输出： <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">LIST</span></span>(APPEND PROCESSED_FILE <span class="hljs-string"><span class="hljs-string">"${CMAKE_CURRENT_SOURCE_DIR}/data/processed/processed.pickle"</span></span> <span class="hljs-string"><span class="hljs-string">"${CMAKE_CURRENT_SOURCE_DIR}/data/processed/processed.xlsx"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/data/preprocess.py <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> data/processed/processed.pickle --excel data/processed/processed.xlsx WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> DEPENDS rawdata <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> src/data/preprocess.py ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(preprocess DEPENDS <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span>)</code> </pre><br> 看到在这种情况下，我创建了列表，但是没有在自定义命令中使用它。 我不知道在其中引用自定义命令的输出参数的方法。 <br><br> 要注意的另一件有趣的事情是此自定义命令中<code>depends</code>的用法。 我们不仅从自定义目标设置了依赖关系，还设置了它的输出以及python脚本。 如果我们不向<code>IRIS_FILE</code>添加依赖<code>IRIS_FILE</code> ，那么手动修改<code>iris.csv</code>将不会导致重建<code>preprocess</code>目标。 好吧，您不应该首先手动修改构建目录中的文件。 只是让你知道。 有关更多详细信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Sam Thursfield的文章</a> 。 如果python脚本发生更改，则需要依赖python脚本来重建目标。 <br><br> 最后是第三个目标： <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(EXPLORATORY_IMG <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span>/reports/figures/exploratory.png) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${EXPLORATORY_IMG}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/visualization/exploratory.py <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> <span class="hljs-variable"><span class="hljs-variable">${EXPLORATORY_IMG}</span></span> WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> DEPENDS <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> src/visualization/exploratory.py ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(exploratory DEPENDS <span class="hljs-variable"><span class="hljs-variable">${EXPLORATORY_IMG}</span></span>)</code> </pre><br> 该目标与第二个目标基本相同。 <br><br> 总结一下。  CMake看起来比较混乱，比Make更难。 确实，很多人批评CMake的语法。 以我的经验，理解将会来临，并且完全有可能理解甚至非常复杂的CMake文件。 <br><br> 您仍然会做很多事情，因为您需要传递正确的变量。 我没有看到一种简单的方法来引用另一个自定义命令的输出。 似乎可以通过自定义目标来实现。 <br><br><h2><a name="PyBuilder"></a>  Pybuilder </h2><br>  PyBuilder部分很短。 我在项目中使用了Python 3.7，而PyBuilder当前版本0.11.17不支持它。 建议的解决方案是使用开发版本。 但是，该版本仅限于pip v9。 撰写本文时，点数为v19.3。  mm 稍微摆弄一下之后，它根本对我不起作用。  PyBuilder评估是短暂的。 <br><br><h2><a name="pynt"></a>  nt </h2><br>  Pynt是基于python的，这意味着我们可以直接使用python函数。 不必通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">单击</a>将它们包装起来并提供命令行界面。 但是，pynt也能够执行shell命令。 我将使用python函数。 <br><br> 生成命令在文件<code>build.py</code>中给出。 使用功能装饰器创建目标/任务。 任务依赖项通过同一装饰器提供。 <br><br> 由于我想使用python函数，因此需要在构建脚本中导入它们。  Pynt不包含当前目录作为python脚本，因此编写如下的smth： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> src.data.download <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pydownload_file</code> </pre><br> 将无法正常工作。 我们必须做： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys sys.path.append(os.path.join(os.path.dirname(__file__), <span class="hljs-string"><span class="hljs-string">'.'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> src.data.download <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pydownload_file</code> </pre><br> 我最初的<code>build.py</code>文件是这样的： <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/python import os import sys sys.path.append(os.path.join(os.path.dirname(__file__), '.')) from pynt import task from path import Path import glob from src.data.download import pydownload_file from src.data.preprocess import pypreprocess iris_file = 'data/raw/iris.csv' processed_file = 'data/processed/processed.pickle' @task() def rawdata(): '''Download IRIS dataset''' pydownload_file('https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data', iris_file) @task() def clean(): '''Clean all build artifacts''' patterns = ['data/raw/*.csv', 'data/processed/*.pickle', 'data/processed/*.xlsx', 'reports/figures/*.png'] for pat in patterns: for fl in glob.glob(pat): Path(fl).remove() @task(rawdata) def preprocess(): '''Preprocess IRIS dataset''' pypreprocess(iris_file, processed_file, 'data/processed/processed.xlsx')</span></span></code> </pre><br> 而且<code>preprocess</code>目标无效。 一直在抱怨<code>pypreprocess</code>函数的输入参数。 似乎Pynt不能很好地处理可选函数参数。 我必须删除用于制作excel文件的参数。 如果您的项目具有带有可选参数的函数，请记住这一点。 <br><br> 我们可以从项目的文件夹运行pynt并列出所有可用的目标： <br><br><pre> <code class="bash hljs">pynt -l</code> </pre><br><div class="spoiler">  <b class="spoiler_title">结果</b> <div class="spoiler_text"><pre> <code class="bash hljs">Tasks <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> build file build.py: clean Clean all build artifacts exploratory Make an image with pairwise distribution preprocess Preprocess IRIS dataset rawdata Download IRIS dataset Powered by pynt 0.8.2 - A Lightweight Python Build Tool.</code> </pre><br></div></div><br> 让我们进行成对分布： <br><br><pre> <code class="bash hljs">pynt exploratory</code> </pre><br><div class="spoiler">  <b class="spoiler_title">结果</b> <div class="spoiler_text"><pre> <code class="bash hljs">[ build.py - Starting task <span class="hljs-string"><span class="hljs-string">"rawdata"</span></span> ] Downloading from https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data to data/raw/iris.csv [ build.py - Completed task <span class="hljs-string"><span class="hljs-string">"rawdata"</span></span> ] [ build.py - Starting task <span class="hljs-string"><span class="hljs-string">"preprocess"</span></span> ] Preprocessing data [ build.py - Completed task <span class="hljs-string"><span class="hljs-string">"preprocess"</span></span> ] [ build.py - Starting task <span class="hljs-string"><span class="hljs-string">"exploratory"</span></span> ] Plotting pairwise distribution... [ build.py - Completed task <span class="hljs-string"><span class="hljs-string">"exploratory"</span></span> ]</code> </pre><br></div></div><br> 如果我们现在再次运行相同的命令（即<code>pynt exploratory</code> ），将进行完全重建。  Pynt没有追踪到没有任何变化。 <br><br><h2><a name="Paver"></a> 摊铺机 </h2><br> 摊铺机看上去几乎与Pynt一样。 它在定义目标之间的依赖关系（另一种装饰器<code>@needs</code> ）的方式上略有不同。  Paver每次都会进行完全重建，因此不能与带有可选参数的函数配合使用。 构建说明位于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pavement.py</a>文件中。 <br><br><h2><a name="doit"></a> 做 </h2><br>  Doit似乎是在尝试用python创建真正的构建自动化工具。 它可以执行python代码和shell命令。 看起来很有希望。 在我们特定目标的背景下，似乎遗漏的是处理目标之间依赖关系的能力。 假设我们要建立一个小的管道，其中将目标A的输出用作目标B的输入。并且假设我们将文件用作输出，因此目标A创建了一个名为<code>outA</code>的文件。 <br><br><img src="https://habrastorage.org/webt/xh/te/ol/xhteolpanywbjxanltb8uxdsoly.png"><br><br> 为了建立这样的管道，我们将需要在目标A中两次指定文件<code>outA</code> （作为目标的结果，但还要在执行目标时返回其名称）。 然后，需要将其指定为目标B的输入。因此，总共需要提供3个地方来提供有关文件<code>outA</code>信息。 而且即使这样做，修改文件<code>outA</code>也不会导致目标B的自动重建。这意味着，如果我们要求doit构建目标B，则doit将仅检查目标B是否为最新，而不检查任何目标B。的依赖关系。 为了克服这个问题，我们将需要指定4次<code>outA</code>也作为目标B的文件依赖项。我认为这是一个缺点。  Make和CMake都能够正确处理这种情况。 <br><br>  doit中的依赖项基于文件，并表示为字符串。 这意味着依赖项<code>./myfile.txt</code>和<code>myfile.txt</code>被视为不同。 就像我在上面写的，我发现将信息从目标传递到目标的方式（使用python目标时）有些奇怪。 目标有一个将要产生的工件列表，但是另一个目标不能使用它。 相反，构成目标的python函数必须返回一个字典，该字典可以在另一个目标中访问。 让我们看一个例子： <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task_preprocess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Preprocess IRIS dataset"""</span></span> pickle_file = <span class="hljs-string"><span class="hljs-string">'data/processed/processed.pickle'</span></span> excel_file = <span class="hljs-string"><span class="hljs-string">'data/processed/processed.xlsx'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-string"><span class="hljs-string">'file_dep'</span></span>: [<span class="hljs-string"><span class="hljs-string">'src/data/preprocess.py'</span></span>], <span class="hljs-string"><span class="hljs-string">'targets'</span></span>: [pickle_file, excel_file], <span class="hljs-string"><span class="hljs-string">'actions'</span></span>: [doit_pypreprocess], <span class="hljs-string"><span class="hljs-string">'getargs'</span></span>: {<span class="hljs-string"><span class="hljs-string">'input_file'</span></span>: (<span class="hljs-string"><span class="hljs-string">'rawdata'</span></span>, <span class="hljs-string"><span class="hljs-string">'filename'</span></span>)}, <span class="hljs-string"><span class="hljs-string">'clean'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, }</code> </pre><br> 在此，目标<code>preprocess</code>取决于<code>rawdata</code> 。 依赖关系通过<code>getargs</code>属性提供。 它说函数<code>doit_pypreprocess</code>的参数<code>input_file</code>是目标<code>rawdata</code>的输出<code>filename</code> 。 看一下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">dodo.py</a>文件中的完整示例。 <br><br> 值得一读使用doit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的成功案例</a> 。 它绝对具有不错的功能，例如提供自定义最新目标检查的功能。 <br><br><h2><a name="Luigi"></a> 路易吉 </h2><br>  Luigi与其他工具分开，因为它是一个用于构建复杂管道的系统。 一位同事告诉我他尝试过Make，但从未在Windows / Linux上使用过它，后来搬到了Luigi，它出现在我的雷达上。 <br><br>  Luigi致力于生产就绪系统。 它带有一个服务器，该服务器可用于可视化您的任务或获取任务执行的历史记录。 该服务器称为<em>中央调度程序</em> 。 本地调度程序可用于调试目的。 <br><br>  Luigi在创建任务的方式上也与其他系统不同。  Lugi不会对某些预定义文件（例如<code>dodo.py</code> ， <code>pavement.py</code>或makefile） <code>dodo.py</code> 。 相反，必须传递一个python模块名称。 因此，如果我们尝试以与其他工具类似的方式使用它（将带有任务的文件放在项目的根目录中），它将无法正常工作。 我们必须安装项目或通过将路径添加到项目来修改环境变量<code>PYTHONPATH</code> 。 <br><br>  luigi的优点是指定任务之间的依赖关系的方法。 每个任务都是一个类。 方法<code>output</code>告诉Luigi任务的结果将在哪里结束。 结果可以是单个元素或列表。 方法<code>requires</code>指定任务依赖项（其他任务；尽管可以从自身创建依赖项）。 就是这样。 如果任务B依赖任务A，则在任务A中指定为<code>output</code>的任何内容都将作为输入传递给任务B。 <br><img src="https://habrastorage.org/getpro/habr/post_images/ba2/95c/bb9/ba295cbb9b744767e709aa7b3a0e358f.png"><br><br>  Luigi不在乎文件修改。 它关心文件的存在。 因此，当源代码更改时，不可能触发重建。 路易吉（Luigi）没有内置的<i>清理</i>功能。 <br><br> 该项目的Luigi任务可在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">luigitasks.py</a>文件中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">找到</a> 。 我从终端运行它们： <br><br><pre> <code class="plaintext hljs">luigi --local-scheduler --module luigitasks Exploratory</code> </pre><br><h2><a name="Comparison"></a> 比较方式 </h2><br> 下表总结了不同系统在实现我们特定目标方面的工作方式。 <br><div class="scrollable-table"><table><tbody><tr><th></th><th> 用依赖定义目标 </th><th> 增量构建 </th><th> 如果源代码更改，则增量构建 </th><th> 能够确定在<code>clean</code>命令期间要删除的工件 </th></tr><tr><td>  <strong>CMake的</strong> </td><td> 是的 </td><td> 是的 </td><td> 是的 </td><td> 是的 </td></tr><tr><td>  <strong>平特</strong> </td><td> 是的 </td><td> 没有啦 </td><td> 没有啦 </td><td> 没有啦 </td></tr><tr><td>  <strong>摊铺机</strong> </td><td> 是的 </td><td> 没有啦 </td><td> 没有啦 </td><td> 没有啦 </td></tr><tr><td>  <strong>做</strong> </td><td> 是的 </td><td> 是的 </td><td> 是的 </td><td> 是的 </td></tr><tr><td>  <strong>路易吉</strong> </td><td> 是的 </td><td> 没有啦 </td><td> 没有啦 </td><td> 没有啦 </td></tr></tbody></table></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN451962/">https://habr.com/ru/post/zh-CN451962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN451950/index.html">虚拟电厂。 有可能管理“绿色”能源吗？</a></li>
<li><a href="../zh-CN451954/index.html">更多秘密电报</a></li>
<li><a href="../zh-CN451956/index.html">将AppDynamics与Red Hat OpenShift v3结合使用</a></li>
<li><a href="../zh-CN451958/index.html">我们在没有短信和注册的情况下在智能电视上观看种子</a></li>
<li><a href="../zh-CN451960/index.html">5月更新90个远程执行代码漏洞（星期二）</a></li>
<li><a href="../zh-CN451966/index.html">现代的I / O设备比处理器更快。 文章概述</a></li>
<li><a href="../zh-CN451968/index.html">顶级3D学院-在领先的俄罗斯企业中进行添加剂技术培训</a></li>
<li><a href="../zh-CN451970/index.html">Thrangrycat：Cisco设备固件中的严重漏洞使黑客可以在其上安装后门</a></li>
<li><a href="../zh-CN451972/index.html">QuadCast-听起来真实</a></li>
<li><a href="../zh-CN451974/index.html">AMD历史：50年的快速发展</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>