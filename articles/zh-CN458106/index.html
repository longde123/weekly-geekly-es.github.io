<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌰 👩🏻‍🔧 🎩 在Jetpack Compose中潜水 🐌 😁 🔗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好 在离开周末之前，我们必须与您分享另一份特别为Android开发人员的学生准备的翻译。 高级课程 。 ” 



 尝试用于Android应用程序的新UI框架 
 在过去的几年中，参与许多移动项目，我不得不使用各种技术，例如Android，ReactNative和Flutter。 从React...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在Jetpack Compose中潜水</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/458106/"> 大家好 在离开周末之前，我们必须与您分享另一份特别为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Android开发人员的</a>学生准备的翻译<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">高级课程</a> 。 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">”</a> <br><br><img src="https://habrastorage.org/webt/z6/qg/xa/z6qgxa6dlio2hf4bnnpwbvlk2j4.png"><br><br><h2> 尝试用于Android应用程序的新UI框架 </h2><br> 在过去的几年中，参与许多移动项目，我不得不使用各种技术，例如Android，ReactNative和Flutter。 从ReactNative切换回经典Android，让我百感交集。 返回Kotlin的过程很顺利，但是我真的很想念React UI框架。 组成用户界面的小型可重用组件非常棒，并提供了更大的灵活性和开发速度。 <a name="habracut"></a><br><br> 回到经典的Android，我需要担心保持View层次结构尽可能统一。 因此，很难真正致力于组件方法。 这使复制粘贴更具吸引力，从而导致更复杂且受支持较少的代码。 最终，我们避免尝试使用可以改善用户体验的用户界面。 <br><br><img src="https://habrastorage.org/webt/9w/qc/oy/9wqcoytvuj4zccl4dbkrmpgx-v8.png"><br>  <i>Android揭示了Jetpack Compose。</i>  <i>插图：伊曼纽尔·巴吉拉（Emanuel Bagilla）</i> <br><br><h3>  Jetpack进行救援 </h3><br> 因此，在观看Google I / O 2019大会上的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Android新增功能</a>之后，我立即开始处理Compose并尝试了解有关它的更多信息。  Compose是Kotlin完全开发的反应式用户界面工具包。  Compose看起来与现有的用户界面框架（例如React，Litho或Flutter）非常相似。 <br><br>  Android UI框架的当前结构自2008年以来就存在，并且随着时间的推移变得越来越复杂，很难维护。  Jetpack Compose的目标是从一开始就考虑现代组件的哲学。 该框架在编写时考虑了以下主要目标： <br><br><ul><li>  <b>与平台版本不一致：</b>由于Compose不依赖于新的Android版本，因此可以快速修复错误。 </li><li>  <b>较小的技术堆栈：</b>创建用户界面时，框架不会强制您使用“视图”或“片段”。 所有元素都是组件，可以自由组合在一起。 </li><li>  <b>透明的状态管理和事件处理：</b>在大型应用程序中需要解决的最重要和最复杂的事情之一是在用户界面中处理数据流和状态。  Compose阐明了由谁负责状态以及如何处理事件，这与React的处理方式类似。 </li><li> <b>编写更少的代码：</b>在Android中编写用户界面通常需要大量代码，尤其是在创建更复杂的布局（例如，使用RecyclerView）时。  Compose旨在极大地简化创建用户界面的方式。 </li></ul><br> 这使得创建隔离的和可重复使用的组件更加容易，从而使创建带有现有元素的新屏幕变得更加容易。 作为开发人员，帮助您专注于创建方便的用户界面，而不是试图控制View层次结构并驯服View和Fragment。 <br><br><h2> 使用Compose的一个简单应用程序：Hello World </h2><br> 让我们看看带有Jetpack Compose的简单Hello World应用程序的代码。 <br><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComposeActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) setContent { CraneWrapper { MyApp() } } } <span class="hljs-meta"><span class="hljs-meta">@Composable</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyApp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { MaterialTheme { Text(text = <span class="hljs-string"><span class="hljs-string">"Hello world!"</span></span>, style = +themeTextStyle { h3 }) } } }</code> </pre> <br> 在<code>onCreate</code>方法中<code>onCreate</code>我们通过调用<code>setContent</code>设置应用程序的内容。 这是一种初始化复合窗口小部件树并将其包装在<code>FrameLayout</code> 。 <br><br> 为了使其工作，我们需要将应用程序包装在<code>CraneWrapper</code>和<code>MaterialTheme</code> 。  <code>CraneWrapper</code>负责配置<code>Context</code> ， <code>FocusManager</code>和<code>TextInputService</code> 。 需要使用<code>MaterialTheme</code>来提供小部件的颜色，样式和字体。 考虑到这一点，我们可以添加<code>Text</code>组件，它将以某种样式在屏幕上显示我们的文本。 <br><br><h2> 州介绍 </h2><br> 管理数据流和状态可能是一项艰巨的任务。 为了说明使用Compose多么容易，让我们创建一个简单的计数器应用程序。 <br> 为了处理状态，Jetpack Compose使用了其他现代UI框架的思想，例如Flutter和React。 有一个单向的和反应性的数据流，可导致您的小部件进行更新或“重建”。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Composable</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyApp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { MaterialTheme { Counter() } } <span class="hljs-meta"><span class="hljs-meta">@Composable</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Counter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> amount = +state { <span class="hljs-number"><span class="hljs-number">0</span></span> } Column { Text(text = <span class="hljs-string"><span class="hljs-string">"Counter demo"</span></span>) Button(text = <span class="hljs-string"><span class="hljs-string">"Add"</span></span>, onClick = { amount.value++ }) Button(text = <span class="hljs-string"><span class="hljs-string">"Subtract"</span></span>, onClick = { amount.value-- }) Text(text = <span class="hljs-string"><span class="hljs-string">"Clicks: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${amount.value}</span></span></span><span class="hljs-string">"</span></span>) } }</code> </pre> <br><br> 在上面的示例中，我们添加了“添加”和“减去”按钮，以及显示当前点击次数的标签。 如您在下面的示例中看到的那样，更新“金额”状态，状态发生变化时，会智能地重新排列小部件。 <br><br><img src="https://habrastorage.org/webt/ks/_y/ko/ks_ykoqxzmr24t-woc8o854dl_o.gif"><br>  <i>启动演示应用程序</i> <br><br>  <code>amount</code>状态用<code>+state { 0 }</code>初始化。 为了弄清楚什么是巫术，我抓取了源代码。 这是我的观点，尽管我仍然不确定我是否完全了解所有内容。 <br><br>  <code>state {...}</code>创建一个<code><code>Effect&lt;</code> State <code>&lt;</code> T <code>&lt;</code> code&gt;&gt;</code> 。  <code>Effect</code>类是一个模糊类，其中包含在合成上下文中按位置运行的可执行代码块。  <code>State</code>类包含一个具有<code>Model</code>类型的值，从本质上讲该值是可观察的。  +运算符是一个临时运算符，可从<code>Effect</code>解析<code>State</code> 。 <br><br><h3> 自定义状态模型 </h3><br> 除了使用<code>+state {}</code>创建单个值模型外，我们还可以使用@Model注释创建自定义模型。 我们可以通过将计数器应用程序划分为较小的小部件，并将模型传递给其他已更新并显示此模型状态的小部件来改进计数器应用程序。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Model</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CounterModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> counter: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> header = <span class="hljs-string"><span class="hljs-string">"Counter demo"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { counter++ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subtract</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { counter-- } }</code> </pre> <br><br> 使用<code>@Model</code>批注，Compose Compiler插件使模型中的所有变量均可见，从而可用于重新排列小部件。 让我们更新小部件以使用<code>CounterModel</code> ： <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Composable</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Counter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(counterModel: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CounterModel</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { Column { CounterHeader(counterModel) AddSubtractButtons(counterModel) CounterLabel(counterModel) } } <span class="hljs-meta"><span class="hljs-meta">@Composable</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CounterHeader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(counterModel: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CounterModel</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { Text(text = counterModel.header) } <span class="hljs-meta"><span class="hljs-meta">@Composable</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddSubtractButtons</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(counterModel: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CounterModel</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { Button( text = <span class="hljs-string"><span class="hljs-string">"Add"</span></span>, onClick = { counterModel.add() }) Button( text = <span class="hljs-string"><span class="hljs-string">"Subtract"</span></span>, onClick = { counterModel.subtract() }) } <span class="hljs-meta"><span class="hljs-meta">@Composable</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CounterLabel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(counterModel: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CounterModel</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { Text(text = <span class="hljs-string"><span class="hljs-string">"Clicks: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${counterModel.counter}</span></span></span><span class="hljs-string">"</span></span>) }</code> </pre> <br><br> 微调器应用程序所包含的唯一窗口小部件现已拆分为几个较小的可组合窗口小部件。  <code>CounterModel</code>传递给各种小部件，以显示模型的状态，或使用<code>add()</code>或<code>subtract()</code>函数更改模型的状态。 <br><br><h2> 没有更多的看法 </h2><br> 重要的是要了解，Jetpack Compose窗口小部件不会在后台使用视图或片段，这些只是在画布上绘制的功能。  Compose Compiler插件使用<code>@Composable</code>批注处理所有功能，并自动更新UI层次结构。 <br><br> 例如， <code>Divider</code>小部件由包含<code>DrawFillRect</code>小部件的<code>Padding</code>小部件组成。 查看<code>DrawFillRect</code>的源代码，很明显，他直接在画布上绘制线条。 所有其他小部件都以相同的方式实现。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Composable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DrawFillRect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(brush: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Brush</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { Draw { canvas, parentSize -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paint = Paint() brush.applyBrush(paint) canvas.drawRect(parentSize.toRect(), paint) } }</code> </pre> <br><br> 在Divider小部件内使用的DrawFillRect的源代码。 <br> 如果我们通过启动Google的一个示例应用程序来查看Layout Inspector，我们将清楚地看到，使用Compose启动Android应用程序时，没有<code>View</code>或<code>ViewGroups</code> 。 我们看到一个包含在代码中创建的<code>CraneWrapper</code>的<code>FrameLayout</code> ，从那里在屏幕上显示Compose UI层次结构。 <br><br><img src="https://habrastorage.org/webt/fc/oa/bb/fcoabbcltglyqbogmtcywdxiums.png"><br>  <i>布局检查器检查Jetpack Compose。</i> <br><br> 没有视图也意味着Jetpack Compose无法使用当前可用的视图，例如<code>android.widget.Button</code> ，并且必须从头开始创建所有小部件。 例如，如果您使用相同的方法查看Flutter，您会发现这是一项艰巨的工作。 这是Jetpack Compose在准备投入生产之前需要时间的原因之一。 <br><br><h2> 所有元素都是小部件。 </h2><br> 就像Flutter一样，在Compose中，所有元素都是小部件。 将更复杂的小部件分解为职责明确的基本小部件。 因此，即使填充，分隔符等也是小部件。 例如，如果要在按钮周围添加缩进，只需将其包装在padding小部件中： <br><br><pre> <code class="kotlin hljs">Padding(padding = <span class="hljs-number"><span class="hljs-number">16</span></span>.dp) { Button(text = <span class="hljs-string"><span class="hljs-string">"Say hello"</span></span>, onClick = { ... }) }</code> </pre> <br><br><h2> 将代码连接到用户界面 </h2><br> 将Kotlin代码与UI小部件结合起来非常容易。 例如，如果要显示重复或取决于某些条件的用户界面。 因此，您可以轻松显示名称列表，如下所示。 <br><br><pre> <code class="kotlin hljs">Column { listOf(<span class="hljs-string"><span class="hljs-string">"John"</span></span>, <span class="hljs-string"><span class="hljs-string">"Julia"</span></span>, <span class="hljs-string"><span class="hljs-string">"Alice"</span></span>, <span class="hljs-string"><span class="hljs-string">"Mark"</span></span>).forEach { Text(text = it) } }</code> </pre> <br><br> 这是一个非常强大的功能，但是您必须注意不要在用户界面级别上编写过多的逻辑。 <br><br><h2> 与您的Android应用程序兼容 </h2><br> 设计Compose是为了使您可以将其添加到现有应用程序中，并将UI的某些部分逐步转移到新框架中。 上面的示例将Jetpack Compose UI添加到一个活动中。 您还可以使用<code>GenerateView</code>批注将Compose小部件嵌入现有的XML布局中： <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Composable</span></span> <span class="hljs-meta"><span class="hljs-meta">@GenerateView</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Greeting</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">/* … */</span></span> } <span class="hljs-comment"><span class="hljs-comment">//  -  layout.xml &lt;GreetingView app:name=”John” /&gt;</span></span></code> </pre> <br><h2> 结论 </h2><br> 我对Compose感到很满意，因为它减少了我为Android开发时所遭受的不断增长的痛苦。 它有助于变得更加灵活，专注于创建方便的用户界面，明确的职责也有助于避免错误。 <br><br> 我认为Compose还有很长的路要走，不超过一两年就可以投入生产。 但是，我认为现在是查看Jetpack Compose的好时机。 创作者正在积极寻求反馈，在这个阶段您仍然可以进行更改。 所有评论将有助于改进此新框架。 <br><br> 阅读我的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Try Jetpack今天撰写</a>文章，了解如何连接Compose pre-alpha。 另外，我认为用Google I / O观看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有关声明性接口模板</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">视频</a>将非常有趣。 <br> 我期待何时可以在真正的Android应用程序中使用Compose！ <br><br> 仅此而已。 我们期待您的评论，祝您周末愉快！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN458106/">https://habr.com/ru/post/zh-CN458106/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN458096/index.html">什么是MERN堆栈，以及如何使用它？</a></li>
<li><a href="../zh-CN458098/index.html">GDPR的陷阱</a></li>
<li><a href="../zh-CN458100/index.html">Visual Studio Code中的Python-2019年6月发行</a></li>
<li><a href="../zh-CN458102/index.html">有效的Web开发工作流程：融合，Airtable等</a></li>
<li><a href="../zh-CN458104/index.html">华为在数据中心内部实施RDMA</a></li>
<li><a href="../zh-CN458108/index.html">重定向：301、302、307 | 301操作指南</a></li>
<li><a href="../zh-CN458110/index.html">现实世界中的动态编程：接缝切割</a></li>
<li><a href="../zh-CN458112/index.html">索尼Xperia 10评估</a></li>
<li><a href="../zh-CN458114/index.html">建立全球开源法律网络</a></li>
<li><a href="../zh-CN458116/index.html">SwiftUI和自动续订订阅</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>