<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🚒 🖱️ 🤛🏿 《有效火花》一书。 缩放和优化” 👶🏼 👩🏾‍🎤 🙅🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在本文中，我们将探讨如何从JVM中的各种编程语言访问Spark API，以及超越Scala语言时的一些性能问题。 即使您在JVM之外工作，本节也会很有用，因为非JVM语言通常取决于Java API，而不取决于Scala API。 

 使用其他编程语言并不总是意味着您需要超越JVM，并且在JVM方面...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>《有效火花》一书。 缩放和优化”</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/414525/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/g1/uu/lu/g1uulu2edgzcixecswin9lfylnc.jpeg" align="left" alt="图片"></a> 在本文中，我们将探讨如何从JVM中的各种编程语言访问Spark API，以及超越Scala语言时的一些性能问题。 即使您在JVM之外工作，本节也会很有用，因为非JVM语言通常取决于Java API，而不取决于Scala API。 <br><br> 使用其他编程语言并不总是意味着您需要超越JVM，并且在JVM方面在性能方面具有许多优势-主要是因为您不需要复制数据。 尽管不必使用特殊的绑定库或适配器从Scala语言外部访问Spark，但是从其他编程语言调用Scala代码可能很困难。  Spark框架支持在lambda表达式中使用Java 8，使用JDK的较早版本的人有机会从org.apache.spark.api.java.function包中实现适当的接口。 即使在不需要复制数据的情况下，使用另一种编程语言进行的工作也可能与性能有微小但重要的细微差别。 <br><a name="habracut"></a><br> 当使用类标签调用函数或使用隐式类型转换提供的属性时（例如，与Double和Tuple类相关的RDD集的所有功能），访问各种Scala API的困难尤其明显。 对于依赖隐式类型转换的机制，通常会提供等效的具体类以及对它们的显式转换。 虚拟类标签（例如，AnyRef）可以传递给依赖于类标签的函数（通常适配器自动执行此操作）。 使用特定的类而不是隐式类型转换通常不会导致额外的开销，但是伪类标记可以对某些编译器优化施加限制。 <br><br>  Java API在属性方面与Scala API并没有太大区别，只是偶尔缺少某些功能或开发人员API。 使用各种Java API（而不是直接调用Scala API） <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">支持</a>其他JVM编程语言，例如带有DSL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Flambo</a>的Clojure语言和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">闪闪发光的</a>库。 由于大多数语言绑定，甚至非JVM语言（如Python和R）都通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Java</a> API进行处理，因此处理它非常有用。 <br><br>  Java API与Scala API非常相似，尽管它们独立于类标记和隐式转换。 缺少后者意味着必须使用显式类型转换函数（例如mapToDouble或mapToPair），而不是将元组或双精度对象的RDD集自动转换为具有附加功能的特殊类。 指定的功能仅为Java RDD集定义； 幸运的是，出于兼容性考虑，这些特殊类型仅是Scala RDD集的适配器。 另外，这些特殊功能返回各种数据类型，例如JavaDoubleRDD和JavaPairRDD，以及隐式Scala语言转换提供的功能。 <br><br> 让我们再次转到使用Java API进行字计数的规范示例（示例7.1）。 由于从Java调用Scala API有时可能很困难，因此Spark框架Java API几乎都是用Scala语言实现的，具有隐藏的类标记和隐式转换。 因此，Java适配器是一个非常薄的层，平均仅包含几行代码，并且重写它们实际上是毫不费力的。 <br><br> 范例7.1 字数统计（Java） <br><br><pre><code class="hljs actionscript"><span class="hljs-meta"><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> scala.Tuple2;</span></span>  <span class="hljs-meta"><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> org.apache.spark.api.java.JavaRDD;</span></span> <span class="hljs-meta"><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> org.apache.spark.api.java.JavaPairRDD </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> org.apache.spark.api.java.JavaSparkContext;</span></span>  <span class="hljs-meta"><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> java.util.regex.Pattern;</span></span> <span class="hljs-meta"><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> java.util.Arrays;</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WordCount</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Pattern pattern = Pattern.compile(<span class="hljs-string"><span class="hljs-string">" "</span></span>);  <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(String[] args) throws Exception { JavaSparkContext jsc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JavaSparkContext(); JavaRDD&lt;String&gt; lines = jsc.textFile(args[<span class="hljs-number"><span class="hljs-number">0</span></span>]); JavaRDD&lt;String&gt; words = lines.flatMap(e -&gt; Arrays.asList(                                           pattern.split(e)).iterator()); JavaPairRDD&lt;String, Integer&gt; wordsIntial = words.mapToPair(  e -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Tuple2&lt;String, Integer&gt;(e, <span class="hljs-number"><span class="hljs-number">1</span></span>));   } }</code> </pre> <br> 有时您可能需要将Java RDD转换为Scala RDD，反之亦然。 对于需要输入或返回Scala RDD集的库，这是最经常需要的，但是有时基本的Spark属性可能在Java API中不可用。 将Java RDD转换为Scala RDD是使用这些新功能的最简单方法。 <br><br> 如果您需要将Java RDD集转移到Scala库（需要在输入中使用常规RDD Spark），则可以使用rdd（）方法访问基础的RDD Scala。 通常，这足以将最终的RDD转移到任何所需的Scala库中。 值得注意的例外是Scala库，该库在其工作中依赖于内容类型集类型或类标签信息的隐式转换。 在这种情况下，访问隐式转换的最简单方法是在Scala中编写一个小型适配器。 如果无法使用Scala shell，则可以调用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JavaConverters</a>类的相应函数并形成一个虚拟类标签。 <br><br> 要创建一个虚拟类标记，可以使用scala.reflect.ClassTag $ .MODULE $ .AnyRef（）方法，或者使用scala.reflect.ClassTag $ .MODULE $ .apply（CLASS）获得真实的标记，如示例7.2和7.3所示。 <br><br> 要从Scala RDD转换为RDD Java，类标记信息通常比大多数Spark库更重要。 原因是，尽管各种JavaRDD类提供了以Scala RDD作为参数的可公开访问的构造函数，但是它们打算从Scala代码中调用，因此需要有关类标记的信息。 <br><br> 虚拟类标记最常用于通用代码或模板代码，在编译时确切的类型未知。 这样的标签通常就足够了，尽管可能会失去Scala代码方面的细微差别。 在极少数情况下，Scala代码需要准确的类标签信息。 在这种情况下，您将必须使用真实标签。 在大多数情况下，这不需要太多的工作并可以提高性能，因此请尽可能使用此类标签。 <br><br> 示例7.2 使Java / Scala RDD与虚拟类标签兼容 <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static JavaPairRDD wrapPairRDDFakeCt( RDD&lt;Tuple2&lt;String, <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>&gt;&gt; RDD) { //       AnyRef —   //        , //        , //        //    ClassTag&lt;<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>&gt; fake = ClassTag$.MODULE$.AnyRef(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> JavaPairRDD(rdd, fake, fake); }</code> </pre> <br> 示例7.3 确保Java / Scala RDD兼容性 <br><br><pre> <code class="hljs ruby">public static JavaPairRDD wrapPairRDD( RDD&lt;Tuple2&lt;String, Object<span class="hljs-meta"><span class="hljs-meta">&gt;&gt; </span></span>RDD) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    ClassTag&lt;String&gt; strCt = ClassTag$.MODULE$.apply(String.class); ClassTag&lt;Long&gt; longCt = ClassTag$.MODULE$.apply(scala.Long.class); return new JavaPairRDD(rdd, strCt, longCt); }</code> </pre> <br> 大多数情况下，Spark SQL和ML管道API在Java和Scala中都保持一致。 但是，存在特定于Java的帮助器函数，与它们等效的Scala函数不容易调用。 这是它们的示例：Column类的各种数值函数，例如加号，减号等。 从Scala语言（+，-）很难调用它们的重载等效项。 代替使用JavaDataFrame和JavaSQLContext，在SQLContext和常规DataFrame集中提供了Java必需的方法。 这可能会使您感到困惑，因为无法从Java代码中使用Java文档中提到的某些方法，但是在这种情况下，提供了具有相同名称的函数以从Java进行调用。 <br><br>  Java语言的用户定义函数（UDF），就此而言，在除Scala之外的其他大多数语言中，它们都需要指定函数返回的值的类型，因为它无法逻辑推断，类似于在Scala语言中执行的方式（示例7.4） 。 <br><br> 示例7.4  Java UDF示例 <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">sqlContext</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.udf</span></span>() <span class="hljs-selector-class"><span class="hljs-selector-class">.register</span></span>("<span class="hljs-selector-tag"><span class="hljs-selector-tag">strlen</span></span>", (<span class="hljs-selector-tag"><span class="hljs-selector-tag">String</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">s</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">s</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.length</span></span>(), <span class="hljs-selector-tag"><span class="hljs-selector-tag">DataTypes</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.StringType</span></span>);</code> </pre> <br> 尽管Scala和Java API要求的类型不同，但是包装Java集合类型不需要额外的复制。 对于迭代器，适配器所需的类型转换将在访问元素时以延迟的方式执行，这将使Spark框架在必要时转储数据（如第121页的“使用mapPartitions函数执行迭代器-迭代器转换”一节中所述）。 这非常重要，因为对于许多简单的操作而言，复制数据的成本可能会高于计算本身的成本。 <br><br><h3> 超越Scala和JVM </h3><br> 如果您不局限于JVM，那么可用于工作的编程语言的数量将急剧增加。 但是，对于当前的Spark架构，由于在JVM和目标语言代码之间复制工作节点中的数据，因此在JVM外部（尤其是在工作节点上）进行工作可能会导致成本显着增加。 在复杂的操作中，复制数据成本的份额相对较小，但是在简单的操作中，它很容易导致总计算成本加倍。 <br><br>  Spark外部直接支持的第一种非JVM编程语言是Python，其API和接口已成为其他非JVM编程语言的实现所基于的模型。 <br><br><h3>  PySpark如何工作 </h3><br>  PySpark使用worker上的多个通道和驱动程序上提供Python / Java交互的专用库Py4J连接到JVM Spark。 在此之下，乍看之下，简单的架构隐藏了许多复杂的细微差别，这要归功于PySpark的工作，如图1所示。  7.1。 主要问题之一：即使将数据从Python worker复制到JVM，虚拟机也不容易解析。  Python和Java worker都需要付出特殊的努力，以确保JVM具有足够的信息来进行分区等操作。 <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/10/ez/wf/10ezwfv-1jvl1gxwsansnexwvj4.png" alt="图片"></div><br><h3>  PySpark RDD套件 </h3><br> 用于往返于JVM的数据传输以及运行Python执行器的资源成本非常可观。 您可以使用DataFrame / Dataset API避免PySpark RDD Suite API的许多性能问题，因为数据会尽可能长时间地保留在JVM中。 <br><br> 使用套接字和序列化字节将数据从JVM复制到Python。 可通过PipedRDD界面获得用于与其他语言的程序进行交互的更通用版本，其应用程序在“使用管道”部分中显示。 <br><br> 每次转换的数据交换渠道的组织（在两个方向上）将过于昂贵。 结果，PySpark使用专用的PipelinedRDD类在Python解释器内部组织了Python转换管道（如果可能的话），链接了过滤操作，并在其后映射了Python对象的迭代器上的映射。 即使您需要重新整理数据并且PySpark无法在单个工作人员的虚拟机中链接转换，您也可以重用Python解释器，因此启动解释器的成本不会进一步降低。 <br><br> 这只是难题的一部分。 常规PipedRDD与String类型一起使用，由于缺少自然键，因此不太容易随机播放。 在PySpark中，以及与绑定到许多其他编程语言的库中的图像和相似性中，使用了一种特殊的PairwiseRDD类型，其中键是一个长整数，并且其反序列化由Scala语言中的用户代码执行，旨在解析Python值。 这种反序列化的代价不是很高，但表明Spark框架中的Scala基本上将Python代码的结果视为“不透明”字节数组。 <br><br> 尽管非常简单，但是这种集成方法的效果出奇地好，并且Scala RDD集上的大多数操作都可以在Python中使用。 在代码中某些最困难的地方，可以访问库，例如MLlib，以及从各种来源加载/保存数据。 <br><br> 使用各种数据格式也有其局限性，因为从Spark框架加载/保存数据的代码中有很大一部分是基于Hadoop Java接口的。 这意味着所有加载的数据都首先加载到JVM中，然后才移至Python。 <br><br> 通常使用两种方法与MLlib进行交互：PySpark使用具有Scala类型转换的专用数据类型，或者在Python中重新实现该算法。 使用ML软件包可以避免这些问题，该软件包使用DataFrame / Dataset接口，该接口通常将数据存储在JVM中。 <br><br><h3>  PySpark DataFrame和数据集套件 </h3><br>  Python RDD Set API的DataFrame和Dataset集没有很多性能问题，因为它们将数据尽可能长时间地存储在JVM中。 为了说明DataFrame集相对于RDD集的优越性而进行的性能测试（参见图3.1），在Python中运行时（图7.2）存在显着差异。 <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d9/mk/tl/d9mktl7qhe3hg8z2e9lnyanlgde.png" alt="图片"></div><br> 对于许多使用DataFrame和Dataset集的操作，您可能根本不需要从JVM移动数据，尽管使用各种UDF，UDAF和Python lambda表达式自然需要将某些数据移入JVM。 这导致了针对许多操作的以下简化方案，看起来类似于图1中所示的方案。  7.3。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4e/3q/el/4e3qel6hamrvb5ipzycqh9sftcg.png" alt="图片"></div><br><h3> 访问Scala中的基础Java对象和混合代码 </h3><br>  PySpark架构的一个重要结果是，许多Spark Python框架类实际上是用于将来自Python代码的调用转换为可理解的JVM形式的适配器。 <br><br> 如果您与Scala / Java开发人员一起工作并且想与他们的代码进行交互，那么事先没有适配器可以访问您的代码，但是您可以注册Java / Scala UDF并从Python代码中使用它们。 从Spark 2.1开始，可以使用sqlContext对象的registerJavaFunction方法完成此操作。 <br><br> 有时，这些适配器没有所有必要的机制，并且由于Python没有针对调用私有方法的强大保护，因此您可以立即转向JVM。 相同的技术将使您可以在JVM中访问自己的代码，并且不费吹灰之力即可将结果转换回Python对象。 <br><br> 在p的“大查询计划和迭代算法”小节中。  91我们注意到使用DataFrame和RDD集的JVM版本来减少查询计划的重要性。 这是一种解决方法，因为当查询计划变得太大而无法由Spark SQL优化器进行处理时，由于将RDD集放在中间，SQL优化器将失去查看超出数据出现在RDD中的能力。 借助公共Python API可以实现相同的目的，但是，同时，由于所有数据都必须在Python的工作节点之间来回传递，因此DataFrame集的许多优点将丢失。 相反，您可以通过继续将数据存储在JVM中来减少源图（如示例7.5所示）。 <br><br> 示例7.5 使用Python整理DataFrame的大型查询计划 <br><br><pre> <code class="hljs python"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cutLineage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(df)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""    DataFrame —     .. :              &gt;&gt;&gt; df = RDD.toDF() &gt;&gt;&gt; cutDf = cutLineage(df) &gt;&gt;&gt; cutDf.count() 3 """</span></span> jRDD = df._jdf.toJavaRDD() jSchema = df._jdf.schema() jRDD.cache() sqlCtx = df.sql_ctx <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: javaSqlCtx = sqlCtx._jsqlContext <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: javaSqlCtx = sqlCtx._ssql_ctx newJavaDF = javaSqlCtx.createDataFrame(jRDD, jSchema) newDF = DataFrame(newJavaDF, sqlCtx) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newDF</code> </pre> <br> 一般来说，按照惯例，_j [abbreviated_name]语法用于访问大多数Python对象的内部Java版本。 因此，例如，SparkContext对象具有_jsc，它使您可以获取内部SparkContext Java对象。 这仅在驱动程序中是可能的，因此，当您将PySpark对象发送到工作节点时，将无法访问内部Java组件，并且大多数API将无法工作。 <br><br> 要在没有Python适配器的JVM中访问Spark类，可以在驱动程序上使用Py4J网关。  SparkContext对象在_gateway属性中包含指向网关的链接。 语法sc._gateway.jvm。[Full_class_name_in_JVM]将允许访问任何Java对象。 <br><br> 如果您的Scala类是根据类路径进行排列的，则类似的技术也适用于您自己的Scala类。 您可以使用带有--jars参数的spark-submit命令或通过设置spark.driver.extraClassPath配置属性，将JAR文件添加到类路径。 例7.6，它有助于产生水稻。  7.2是有意设计的，用于使用现有Scala代码生成用于性能测试的数据。 <br><br> 示例7.6 使用Py4J调用非Spark-JVM类 <br><br><pre> <code class="hljs pgsql">sc = sqlCtx._sc #  <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span> Context,   <span class="hljs-number"><span class="hljs-number">2.1</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>   , #  <span class="hljs-number"><span class="hljs-number">2.0</span></span>, —  ,   :p try: try: javaSqlCtx = sqlCtx._jsqlContext <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: javaSqlCtx = sqlCtx._ssql_ctx <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: javaSqlCtx = sqlCtx._jwrapped jsc = sc._jsc scalasc = jsc.sc() gateway = sc._gateway #  java-,   RDD JVM- # <span class="hljs-keyword"><span class="hljs-keyword">Row</span></span> (<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Double</span></span>).   RDD  Python   #  RDD  Java (   <span class="hljs-keyword"><span class="hljs-keyword">Row</span></span>),   # ,      . #   Java-RDD  <span class="hljs-keyword"><span class="hljs-keyword">Row</span></span> —     #    DataFrame,     #    RDD  <span class="hljs-keyword"><span class="hljs-keyword">Row</span></span>. java_rdd = (gateway.jvm.com.highperformancespark.examples. tools.GenerateScalingData. generateMiniScaleRows(scalasc, <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>, numCols)) #     <span class="hljs-type"><span class="hljs-type">JSON</span></span>     . #  Python-     Java-. schema = StructType([ StructField("zip", IntegerType()), StructField("fuzzyness", DoubleType())]) #   <span class="hljs-number"><span class="hljs-number">2.1</span></span> /  <span class="hljs-number"><span class="hljs-number">2.1</span></span> try: jschema = javaSqlCtx.parseDataType(<span class="hljs-keyword"><span class="hljs-keyword">schema</span></span>.json()) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: jschema = sqlCtx._jsparkSession.parseDataType(<span class="hljs-keyword"><span class="hljs-keyword">schema</span></span>.json()) #  RDD (Java)  DataFrame (Java) java_dataframe = javaSqlCtx.createDataFrame(java_rdd, jschema) #  DataFrame (Java)  DataFrame (Python) python_dataframe = DataFrame(java_dataframe, sqlCtx) #  DataFrame (Python)   RDD pairRDD = python_dataframe.rdd.map(lambda <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>: (<span class="hljs-keyword"><span class="hljs-keyword">row</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>])) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (python_dataframe, pairRDD)</code> </pre> <br><br> 尽管许多Python类只是Java对象的适配器，但并非所有Java对象都可以包装在Python对象中，然后在Spark中使用。 例如，PySpark RDD集中的对象表示为序列化的字符串，这些字符串只能在Python代码中轻松解析。 幸运的是，DataFrame对象在不同的​​编程语言之间是标准化的，因此，如果您可以将数据转换为DataFrame集，则可以将它们包装在Python对象中，或者直接将它们用作Python DataFrame，或者将Python DataFrame转换为此RDD相同的语言。 <br><br>  »这本书的更多信息可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在出版商的网站上找到</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">目录</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">摘录</a> <br><br> 喷雾器-Spark优惠券20％折扣 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN414525/">https://habr.com/ru/post/zh-CN414525/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN414513/index.html">27种出色的开源Web开发工具</a></li>
<li><a href="../zh-CN414515/index.html">Web应用程序服务器优化课程</a></li>
<li><a href="../zh-CN414517/index.html">牛津大学的科学家：我们独自一人在宇宙可预见部分的可能性远高于零</a></li>
<li><a href="../zh-CN414519/index.html">如何将15分钟的Scrum会议变成一个满屋子？</a></li>
<li><a href="../zh-CN414523/index.html">四轴飞行器DJI Mavic Pro和Mavic Air的比较</a></li>
<li><a href="../zh-CN414527/index.html">在Highload ++ Siberia上等待我们的是什么，除了彩绘的熊</a></li>
<li><a href="../zh-CN414531/index.html">从7月1日起，没人知道网上购物会发生什么</a></li>
<li><a href="../zh-CN414535/index.html">曼彻斯特：沮丧的发源地，后朋克俱乐部和两个著名的足球俱乐部</a></li>
<li><a href="../zh-CN414537/index.html">我们如何在没有付费流量的情况下成为世界上最好的AR游戏之一</a></li>
<li><a href="../zh-CN414539/index.html">网络犯罪分子越来越多地窃取俄罗斯人的个人数据</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>