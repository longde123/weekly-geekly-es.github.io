<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌿 🗒️ 💥 Invalidation du cache en cascade. Partie 1 🥀 👩🏻‍✈️ 😟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Depuis plusieurs années maintenant, comme presque tous les articles sur les approches avancées de la mise en cache recommandent d'utiliser les techniq...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Invalidation du cache en cascade. Partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/472860/">  Depuis plusieurs années maintenant, comme presque tous les articles sur les approches avancées de la mise en cache recommandent d'utiliser les techniques suivantes en production: <br><br><ul><li>  Ajout aux noms de fichiers d'informations sur la version des données qu'ils contiennent (généralement sous la forme d'un hachage des données dans les fichiers). </li><li> Définition des en <code>Cache-Control: max-age</code> têtes HTTP <code>Cache-Control: max-age</code> et <code>Expires</code> , qui contrôlent le temps de mise en cache des documents (ce qui élimine la revalidation des documents pertinents pour les visiteurs revenant à la ressource). </li></ul><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/0d/fi/12/0dfi12ooly3mmtiq05otewvw4du.jpeg"></a> <br><br>  Tous les outils de construction de projets que je connais prennent en charge l'ajout au nom des fichiers de hachage de leur contenu.  Cela se fait à l'aide d'une règle de configuration simple (comme celle illustrée ci-dessous): <br><br><pre> <code class="javascript hljs">filename: <span class="hljs-string"><span class="hljs-string">'[name]-[contenthash].js'</span></span></code> </pre> <br>  Un tel soutien généralisé à cette technologie a conduit au fait que cette pratique est devenue extrêmement courante. <br><a name="habracut"></a><br>  Les experts en performances de projets Web recommandent également d'utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des</a> techniques de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">séparation de code</a> .  Ces techniques permettent de diviser le code JavaScript en lots distincts.  Ces bundles peuvent être téléchargés par le navigateur en parallèle, ou même uniquement lorsqu'ils deviennent nécessaires, à la demande du navigateur. <br><br>  L'un des nombreux avantages de la séparation de code, en particulier, lié aux meilleures techniques de mise en cache, est que les modifications apportées à un fichier séparé avec le code source n'entraînent pas l'invalidation du cache de l'ensemble complet.  En d'autres termes, si une mise à jour de sécurité a été publiée pour le package npm créé par le développeur «X» et que le contenu de <code>node_modules</code> fragmenté par les développeurs, seul le fragment contenant les packages créés par «X» devra être modifié. <br><br>  Le problème ici est que si tout cela est combiné, cela conduit rarement à une augmentation de l'efficacité de la mise en cache des données à long terme. <br><br>  En pratique, les modifications apportées à l'un des fichiers de code source entraînent presque toujours l'invalidation de plusieurs fichiers de sortie du système d'assemblage de packages.  Et cela est précisément dû au fait que des hachages ont été ajoutés aux noms de fichiers qui reflètent les versions du contenu de ces fichiers. <br><br><h2>  <font color="#3AC1EF">Problème de version de nom de fichier</font> </h2><br>  Imaginez que vous avez créé et déployé un site Web.  Vous avez utilisé le fractionnement de code. Par conséquent, la plupart du code JavaScript de votre site est chargé sur demande. <br><br>  Dans le diagramme de dépendance suivant, vous pouvez voir le point d'entrée de la base de code - le fragment racine de <code>main</code> , ainsi que trois fragments de dépendance chargés de manière asynchrone - <code>dep1</code> , <code>dep2</code> et <code>dep3</code> .  Il existe également un fragment de <code>vendor</code> contenant toutes les dépendances de site de <code>node_modules</code> .  Tous les noms de fichiers, conformément aux directives de mise en cache, incluent des hachages du contenu de ces fichiers. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/828/7ad/f78/8287adf785b9ac4b9843fa5f1b81e543.png"></div><br>  <i><font color="#999999">Arbre de dépendance typique du module JavaScript</font></i> <br><br>  Étant <code>dep2</code> que les <code>dep3</code> <code>dep2</code> et <code>dep3</code> importent des modules à partir du fragment de <code>vendor</code> , alors en haut de leur code généré par le <code>dep3</code> projet, nous trouverons très probablement des commandes d'importation qui ressemblent à ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {...} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'/vendor-5e6f.mjs'</span></span>;</code> </pre> <br>  Réfléchissons maintenant à ce qui se passera si le contenu du fragment de <code>vendor</code> change. <br><br>  Si cela se produit, le hachage dans le nom du fichier correspondant changera également.  Et puisque le lien vers le nom de ce fichier se trouve dans les commandes d'importation pour les <code>dep3</code> <code>dep2</code> et <code>dep3</code> , alors il faudra que ces commandes d'importation changent: <br><br><pre> <code class="javascript hljs">-<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {...} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'/vendor-5e6f.mjs'</span></span>; +<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {...} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'/vendor-d4a1.mjs'</span></span>;</code> </pre> <br>  Cependant, étant donné que ces commandes d'importation font partie du contenu des <code>dep3</code> <code>dep2</code> et <code>dep3</code> , leur modification signifie que le hachage du contenu des fichiers <code>dep2</code> et <code>dep3</code> <code>dep2</code> également.  Et cela signifie que les noms de ces fichiers changeront également. <br><br>  Mais cela ne s'arrête pas là.  Étant donné que le fragment <code>main</code> importe les fragments <code>dep2</code> et <code>dep3</code> et que leurs noms de fichier ont changé, les commandes d'importation dans <code>main</code> changeront également: <br><br><pre> <code class="javascript hljs">-<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {...} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'/dep2-3c4d.mjs'</span></span>; +<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {...} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'/dep2-2be5.mjs'</span></span>; -<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {...} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'/dep3-d4e5.mjs'</span></span>; +<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {...} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'/dep3-3c6f.mjs'</span></span>;</code> </pre> <br>  Et enfin, puisque le contenu du fichier <code>main</code> a changé, le nom de ce fichier devra également changer. <br><br>  Voici à quoi ressemblera le diagramme de dépendance. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c3/4e7/1c4/1c34e71c45d94977d5445366abe26bec.png"></div><br>  <i><font color="#999999">Modules de l'arbre de dépendances affectés par une seule modification du code de l'un des nœuds feuilles de l'arbre</font></i> <br><br>  Cet exemple montre comment une petite modification de code effectuée dans un seul fichier a entraîné l'invalidation du cache de 80% des fragments du bundle. <br><br>  Bien qu'il soit vrai que tous les changements n'entraînent pas de si tristes conséquences (par exemple, invalider le cache de nœud feuille conduit à invalider le cache de tous les nœuds jusqu'à la racine, mais invalider le cache racine ne provoque pas l'invalidation en cascade atteignant la capture de feuille), dans un monde idéal nous n'aurions pas à traiter les invalidations inutiles du cache. <br><br>  Cela nous amène à la question suivante: "Est-il possible de bénéficier des ressources immuables et de la mise en cache à long terme, sans souffrir d'invalidations de cache en cascade?" <br><br><h2>  <font color="#3AC1EF">Approches de résolution de problèmes</font> </h2><br>  Le problème avec les hachages du contenu des fichiers dans les noms de fichiers, d'un point de vue technique, n'est pas que les hachages sont dans les noms.  Cela réside dans le fait que ces hachages apparaissent dans d'autres fichiers.  Par conséquent, le cache de ces fichiers est désactivé lors de la modification des hachages dans les noms des fichiers dont ils dépendent. <br><br>  La solution à ce problème consiste à utiliser le langage de l'exemple ci-dessus pour permettre d'importer le fragment <code>vendor</code> par les fragments <code>dep2</code> et <code>dep3</code> sans spécifier les informations de version du fichier de fragment <code>vendor</code> .  Ce faisant, vous devez vous assurer que la version du <code>vendor</code> téléchargée est correcte, en tenant compte des versions actuelles de <code>dep2</code> et <code>dep3</code> . <br><br>  Il s'est avéré qu'il existe plusieurs façons d'atteindre cet objectif: <br><br><ul><li>  Importez des cartes. </li><li>  Travailleurs des services. </li><li>  Scripts natifs pour le chargement des ressources. </li></ul><br>  Considérez ces mécanismes. <br><br><h2>  <font color="#3AC1EF">Approche n ° 1: Importer des cartes</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les cartes d'importation</a> sont la solution la plus simple à l'invalidation du cache en cascade.  De plus, ce mécanisme est plus facile à mettre en œuvre.  Mais, malheureusement, il n'est pris en charge que dans Chrome (cette fonctionnalité doit en outre être explicitement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">activée</a> ). <br><br>  Malgré cela, je veux commencer par l'histoire des cartes d'importation, car je suis sûr que cette décision deviendra la plus courante à l'avenir.  De plus, la description du travail avec les cartes d'importation aidera à expliquer les caractéristiques d'autres approches pour résoudre notre problème. <br><br>  L'utilisation des cartes d'importation pour empêcher l'invalidation du cache en cascade se compose de trois étapes. <br><br><h3>  <font color="#3AC1EF">▍Étape 1</font> </h3><br>  Vous devez configurer le bundle de sorte que lors de la construction du projet, il n'inclue pas de hachage du contenu des fichiers dans leurs noms. <br><br>  Si vous assemblez un projet dont les modules sont illustrés dans le diagramme de l'exemple précédent, sans inclure de hachage de leur contenu dans les noms de fichiers, les fichiers dans le répertoire de sortie du projet ressembleront à ceci: <br><br><pre> <code class="javascript hljs">dep1.mjs dep2.mjs dep3.mjs main.mjs vendor.mjs</code> </pre> <br>  Les commandes d'importation dans les modules correspondants n'incluront pas non plus les hachages: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {...} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'/vendor.mjs'</span></span>;</code> </pre> <br><h3>  <font color="#3AC1EF">▍Étape 2</font> </h3><br>  Vous devez utiliser un outil comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rev-hash</a> et l'utiliser pour générer une copie de chaque fichier avec un hachage ajouté à son nom indiquant la version de son contenu. <br>  Une fois cette partie du travail terminée, le contenu du répertoire de sortie devrait ressembler à celui illustré ci-dessous (notez qu'il existe maintenant deux options pour chaque fichier): <br><br><pre> <code class="javascript hljs">dep1-b2c3.mjs<span class="hljs-string"><span class="hljs-string">", dep1.mjs dep2-3c4d.mjs"</span></span>, dep2.mjs dep3-d4e5.mjs<span class="hljs-string"><span class="hljs-string">", dep3.mjs main-1a2b.mjs"</span></span>, main.mjs vendor<span class="hljs-number"><span class="hljs-number">-5e6</span></span>f.mjs<span class="hljs-string"><span class="hljs-string">", vendor.mjs</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍Étape 3</font> </h3><br>  Vous devez créer un objet JSON qui stocke des informations sur la correspondance de chaque fichier au nom duquel il n'y a pas de hachage avec chaque fichier au nom duquel il y a un hachage.  Cet objet doit être ajouté aux modèles HTML. <br><br>  Cet objet JSON est une carte d'importation.  Voici à quoi cela pourrait ressembler: <br><br><pre> <code class="javascript hljs">&lt;script type=<span class="hljs-string"><span class="hljs-string">"importmap"</span></span>&gt; {  <span class="hljs-string"><span class="hljs-string">"imports"</span></span>: {    <span class="hljs-string"><span class="hljs-string">"/main.mjs"</span></span>: <span class="hljs-string"><span class="hljs-string">"/main-1a2b.mjs"</span></span>,    <span class="hljs-string"><span class="hljs-string">"/dep1.mjs"</span></span>: <span class="hljs-string"><span class="hljs-string">"/dep1-b2c3.mjs"</span></span>,    <span class="hljs-string"><span class="hljs-string">"/dep2.mjs"</span></span>: <span class="hljs-string"><span class="hljs-string">"/dep2-3c4d.mjs"</span></span>,    <span class="hljs-string"><span class="hljs-string">"/dep3.mjs"</span></span>: <span class="hljs-string"><span class="hljs-string">"/dep3-d4e5.mjs"</span></span>,    <span class="hljs-string"><span class="hljs-string">"/vendor.mjs"</span></span>: <span class="hljs-string"><span class="hljs-string">"/vendor-5e6f.mjs"</span></span>,  } } &lt;<span class="hljs-regexp"><span class="hljs-regexp">/script&gt;</span></span></code> </pre> <br>  Après cela, chaque fois que le navigateur voit la commande d'importation du fichier situé à l'adresse correspondant à l'une des clés de la carte d'importation, le navigateur importe le fichier qui correspond à la valeur de clé. <br><br>  Si vous utilisez cette carte d'importation comme exemple, vous pouvez découvrir que la commande d'importation qui fait référence au fichier <code>/vendor.mjs</code> va en fait interroger et charger le fichier <code>/vendor-5e6f.mjs</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    `/vendor.mjs`,  `/vendor-5e6f.mjs`. import {...} from '/vendor.mjs';</span></span></code> </pre> <br>  Cela signifie que le code source des modules peut se référer assez facilement aux noms de fichiers des modules qui ne contiennent pas de hachage, et le navigateur télécharge toujours les fichiers dont les noms contiennent des informations sur les versions de leur contenu.  Et, comme il n'y a pas de hachage dans le code source des modules (ils ne sont présents que dans la carte d'importation), les modifications apportées à ces hachages n'entraîneront pas l'invalidation de modules autres que ceux dont le contenu a vraiment changé. <br><br>  Vous vous demandez peut-être maintenant pourquoi j'ai créé une copie de chaque fichier au lieu de simplement renommer les fichiers.  Cela est nécessaire pour prendre en charge les navigateurs qui ne peuvent pas fonctionner avec les cartes d'importation.  Dans l'exemple précédent, ces navigateurs ne verront que le fichier <code>/vendor.mjs</code> et téléchargeront simplement ce fichier, en faisant comme d'habitude, en rencontrant des constructions similaires.  En conséquence, il s'avère que les deux fichiers doivent exister sur le serveur. <br><br>  Si vous souhaitez voir les cartes d'importation en action, voici un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ensemble d'exemples</a> qui illustrent toutes les façons de résoudre le problème d'invalidation du cache en cascade présenté dans cet article.  Jetez également un œil à la <a href="">configuration de l'assembly du projet</a> , au cas où vous souhaiteriez savoir comment j'ai généré la carte d'importation et les hachages de version pour chaque fichier. <br><br>  À suivre ... <br><br>  <b>Chers lecteurs!</b>  Êtes-vous au courant de l'invalidation du cache en cascade? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr472860/">https://habr.com/ru/post/fr472860/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr472848/index.html">Réflexions sur une carrière en informatique</a></li>
<li><a href="../fr472850/index.html">Profession ou vie: gagnez un cours de netologie si vous n'avez pas peur</a></li>
<li><a href="../fr472854/index.html">Profilage UI Unity: qui gâche mon lot?</a></li>
<li><a href="../fr472856/index.html">Comment j'ai créé un service de contrôle qualité à partir de tables et de bâtons</a></li>
<li><a href="../fr472858/index.html">Clients Python et HTTP rapides</a></li>
<li><a href="../fr472862/index.html">Invalidation du cache en cascade. 2e partie</a></li>
<li><a href="../fr472864/index.html">Check Point: optimisation CPU et RAM</a></li>
<li><a href="../fr472866/index.html">Talisman pour une communication stable</a></li>
<li><a href="../fr472868/index.html">Gestion du serveur téléphonique: client mobile RUVDS</a></li>
<li><a href="../fr472872/index.html">Comment augmenter le démarrage à 50 employés sans perdre la culture</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>