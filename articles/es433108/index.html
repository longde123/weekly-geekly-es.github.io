<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛌🏼 🐃 🕵🏽 ld -z código separado 🧛🏿 🙋🏾 ♋️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artículo se centrará en una pequeña característica de seguridad agregada en GNU ld a la versión 2.30 en diciembre de 2018. En ruso, esta mejora s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ld -z código separado</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/433108/"><p><img src="https://habrastorage.org/webt/mz/nr/5c/mznr5cswg58pumrqbt60sjacvg4.png"></p><br><p>  Este artículo se centrará en una pequeña característica de seguridad agregada en GNU ld a la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">versión 2.30</a> en diciembre de 2018.  En ruso, esta mejora se mencionó en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">opennet</a> con la siguiente anotación: </p><br><blockquote>  Modo "-z código separado", que aumenta la seguridad de los archivos ejecutables a costa de un pequeño aumento en el tamaño y el consumo de memoria </blockquote><p>  Vamos a resolverlo.  Para explicar de qué tipo de problema de seguridad estamos hablando y cuál es la solución, comencemos con las características generales de las vulnerabilidades de vulnerabilidad binaria. </p><a name="habracut"></a><br><h1 id="problemy-perehvata-potoka-upravleniya-v-eksploytah">  Explotar problemas de control de flujo </h1><br><p>  Un atacante puede transferir datos al programa y manipularlos de esta manera con la ayuda de varias vulnerabilidades: escribir por índice más allá del límite de la matriz, copiar de forma insegura las cadenas, usar objetos después del lanzamiento.  Tales errores son típicos para el código del programa C y C ++ y pueden provocar daños en la memoria con ciertos datos de entrada para el programa. </p><br><div class="spoiler">  <b class="spoiler_title">Vulnerabilidades de corrupción de memoria</b> <div class="spoiler_text"><p> CWE-20: Validación de entrada incorrecta <br>  CWE-118: Acceso incorrecto de recurso indexable ('Error de rango') <br>  CWE-119: Restricción incorrecta de operaciones dentro de los límites de un búfer de memoria <br>  CWE-120: Copia de búfer sin verificar el tamaño de la entrada ('Desbordamiento de búfer clásico') <br>  CWE-121: desbordamiento de búfer basado en pila <br>  CWE-122: desbordamiento de búfer basado en el montón <br>  CWE-123: Condición de escribir qué-dónde <br>  CWE-124: Buffer Underwrite ('Buffer Underflow') <br>  CWE-125: Lectura fuera de límites <br>  CWE-126: Lectura excesiva del búfer <br>  CWE-127: Buffer Under-read <br>  CWE-128: error de ajuste <br>  CWE-129: Validación incorrecta del índice de matriz <br>  CWE-130: Manejo incorrecto de la inconsistencia del parámetro de longitud <br>  CWE-131: Cálculo incorrecto del tamaño del búfer <br>  CWE-134: Uso de cadenas de formato controladas externamente <br>  CWE-135: Cálculo incorrecto de la longitud de cadena de varios bytes <br>  CWE-170: Terminación nula incorrecta <br>  CWE-190: Desbordamiento de enteros o envolvente <br>  CWE-415: Doble gratis <br>  CWE-416: Uso después de gratis <br>  CWE-476: Desreferencia de puntero nulo <br>  CWE-787: Escritura fuera de límites <br>  CWE-824: Acceso del puntero no inicializado <br>  ... </p></div></div><br><p>  El elemento de explotación clásico de las vulnerabilidades similares a la corrupción de la memoria es sobrescribir un puntero en la memoria.  Luego, el programa utilizará el puntero para transferir el control a otro código: para llamar a un método o función de clase desde otro módulo, para regresar desde una función.  Y como el puntero se sobrescribió, el atacante interceptará el control, es decir, se ejecutará el código preparado por él.  Si está interesado en variaciones y detalles de estas técnicas, le recomendamos leer el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documento</a> . </p><br><p>  Este momento común de la operación de tales exploits es conocido, y aquí para el atacante las barreras se han colocado durante mucho tiempo: </p><br><ol><li>  Comprobación de la integridad de los punteros antes de pasar el control: cookies de pila, protección de flujo de control, autenticación de puntero </li><li>  Aleatorización de direcciones de segmento con código y datos: aleatorización del diseño del espacio de direcciones </li><li>  Evitar que el código ejecute segmentos de código externos: protección de espacio ejecutable </li></ol><br><p>  A continuación, nos centraremos en proteger este último tipo. </p><br><h1 id="executable-space-protection">  protección de espacio ejecutable </h1><br><p>  La memoria del programa es heterogénea y está dividida en segmentos con diferentes derechos: leer, escribir y ejecutar.  Esto está garantizado por la capacidad del procesador para marcar páginas de memoria con marcas de acceso en las tablas de páginas.  La idea de protección se basa en una estricta separación de código y datos: los datos recibidos del atacante en el proceso de procesamiento deben colocarse en segmentos <strong>no ejecutables</strong> (pila, montón) y el código del programa en sí, en segmentos separados <strong>inmutables</strong> .  Por lo tanto, esto debería privar al atacante de la capacidad de colocar y ejecutar código extraño en la memoria. </p><br><p>  Para evitar la prohibición de la ejecución de código en segmentos de datos, se utilizan técnicas de reutilización de código.  Es decir, el atacante transfiere el control a los fragmentos de código (en lo sucesivo denominados gadgets) ubicados en las páginas ejecutables.  Las técnicas de este tipo son de diversa dificultad, en orden creciente: </p><br><ul><li>  pasar el control a una función que hace lo suficiente para el atacante: a la función system () con un argumento controlado para ejecutar comandos de shell arbitrarios (ret2libc) </li><li> transferir el control a una función o cadena de dispositivos que deshabilitarán la protección o harán que parte de la memoria sea ejecutable (por ejemplo, llamando a <code>mprotect()</code> ), seguido de la ejecución de código arbitrario </li><li>  ejecución de todas las acciones deseadas utilizando una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=http://web.archive.org/web/20170325014927/">larga cadena de gadgets</a> </li></ul><br><p>  Por lo tanto, el atacante se enfrenta a la tarea de reutilizar el código existente en un volumen u otro.  Si esto es algo más complicado que volver a una sola función, se requerirá una <em>cadena de gadgets</em> .  Para buscar gadgets por segmentos ejecutables, hay herramientas: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ropper</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ropgadget</a> . </p><br><h2 id="dyra-read_implies_exec">  Hoyo READ_IMPLIES_EXEC </h2><br><p>  Sin embargo, a veces las áreas de memoria con datos pueden ser ejecutables, y los principios de separación de código y datos descritos anteriormente se violan claramente.  En tales casos, el atacante se ahorra la molestia de encontrar dispositivos o funciones para reutilizar el código.  Un hallazgo interesante de este tipo fue la pila ejecutable y todos los segmentos de datos en el mismo "firewall industrial". </p><br><p>  Listado <code>/proc/$pid/maps</code> : </p><br><pre> <code class="plaintext hljs">00008000-00009000 r-xp 00000000 08:01 10 /var/flash/dmt/nx_test/a.out 00010000-00011000 rwxp 00000000 08:01 10 /var/flash/dmt/nx_test/a.out 00011000-00032000 rwxp 00000000 00:00 0 [heap] 40000000-4001f000 r-xp 00000000 1f:02 429 /lib/ld-linux.so.2 4001f000-40022000 rwxp 00000000 00:00 0 40027000-40028000 r-xp 0001f000 1f:02 429 /lib/ld-linux.so.2 40028000-40029000 rwxp 00020000 1f:02 429 /lib/ld-linux.so.2 4002c000-40172000 r-xp 00000000 1f:02 430 /lib/libc.so.6 40172000-40179000 ---p 00146000 1f:02 430 /lib/libc.so.6 40179000-4017b000 r-xp 00145000 1f:02 430 /lib/libc.so.6 4017b000-4017c000 rwxp 00147000 1f:02 430 /lib/libc.so.6 4017c000-40b80000 rwxp 00000000 00:00 0 be8c2000-be8d7000 rwxp 00000000 00:00 0 [stack]</code> </pre> <br><p>  Aquí puede ver la tarjeta de memoria del proceso de utilidad de prueba.  Un mapa consta de áreas de memoria: filas de tabla.  Primero, preste atención a la columna derecha: explica el contenido del área (segmentos de código, datos de las bibliotecas de funciones o el programa en sí) o su tipo (montón, pila).  A la izquierda, en orden, se encuentra el rango de direcciones que ocupa cada área de memoria y, además, las banderas de derechos de acceso: r (lectura), w (escritura), x (ejecución).  Estas banderas determinan el comportamiento del sistema cuando se intenta leer, escribir y ejecutar memoria en estas direcciones.  Si se viola el modo de acceso designado, se produce una excepción. </p><br><p>  Tenga en cuenta que casi toda la memoria dentro del proceso es ejecutable: la pila, el montón y todos los segmentos de datos.  Esto es un problema  Obviamente, la presencia de páginas de memoria rwx facilitará la vida de un atacante, ya que podrá ejecutar libremente <strong>su</strong> código en dicho proceso en cualquier lugar donde su código llegue al transferir datos (paquetes, archivos) a dicho programa para su procesamiento. </p><br><p>  ¿Por qué surgió tal situación en un dispositivo moderno que admite la prohibición de la ejecución de código en páginas de datos con hardware, la seguridad de las redes corporativas e industriales depende del dispositivo y el problema sonoro y su solución se conocen desde hace mucho tiempo? </p><br><p>  Esta imagen está determinada por el comportamiento del núcleo durante la inicialización del proceso (asignación de una pila, montón, carga del ELF principal, etc.) y durante la ejecución de las llamadas al proceso nuclear.  El atributo clave que afecta esto es el indicador de personalidad <code>READ_IMPLIES_EXEC</code> .  El efecto de este indicador es que cualquier memoria legible también se vuelve ejecutable.  Se puede establecer un indicador en su proceso por varias razones: </p><br><ol><li>  El indicador de software en el encabezado ELF puede solicitar explícitamente Legacy para implementar un mecanismo muy interesante: un trampolín en la pila ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3</a> ). </li><li>  Puede ser heredado por procesos hijos del padre. </li><li>  ¡Puede ser instalado por el kernel independientemente para todos los procesos!  Primero, si la arquitectura no admite memoria no ejecutable.  En segundo lugar, por si acaso, para soportar otras <a href="">muletas antiguas</a> .  Este código está en el kernel 2.6.32 (ARM), que tuvo una vida útil muy larga.  Este fue solo nuestro caso. </li></ol><br><h1 id="prostranstvo-dlya-poiska-gadzhetov-v-obraze-elf">  Espacio para encontrar gadgets en una imagen ELF </h1><br><p>  Las bibliotecas de funciones y los ejecutables del programa están en formato ELF.  El compilador gcc traduce las construcciones de lenguaje en código máquina y lo coloca en una sección, y los datos que este código opera en otras secciones.  Hay muchas secciones y el enlazador ld las agrupa en segmentos.  Por lo tanto, ELF contiene una imagen de programa que tiene dos representaciones: una tabla de secciones y una tabla de segmentos. </p><br><pre> <code class="plaintext hljs">$ readelf -l /bin/ls Elf file type is EXEC (Executable file) Entry point 0x804bee9 There are 9 program headers, starting at offset 52 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align PHDR 0x000034 0x08048034 0x08048034 0x00120 0x00120 RE 0x4 INTERP 0x000154 0x08048154 0x08048154 0x00013 0x00013 R 0x1 [Requesting program interpreter: /lib/ld-linux.so.2] LOAD 0x000000 0x08048000 0x08048000 0x1e40c 0x1e40c RE 0x1000 LOAD 0x01ef00 0x08067f00 0x08067f00 0x00444 0x01078 RW 0x1000 DYNAMIC 0x01ef0c 0x08067f0c 0x08067f0c 0x000f0 0x000f0 RW 0x4 NOTE 0x000168 0x08048168 0x08048168 0x00044 0x00044 R 0x4 GNU_EH_FRAME 0x018b74 0x08060b74 0x08060b74 0x00814 0x00814 R 0x4 GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RW 0x10 GNU_RELRO 0x01ef00 0x08067f00 0x08067f00 0x00100 0x00100 R 0x1 Section to Segment mapping: Segment Sections... 00 01 .interp 02 .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .plt.got .text .fini .rodata .eh_frame_hdr .eh_frame 03 .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss 04 .dynamic 05 .note.ABI-tag .note.gnu.build-id 06 .eh_frame_hdr 07 08 .init_array .fini_array .jcr .dynamic .got</code> </pre> <br><p>  Aquí puede ver la asignación de secciones a segmentos en una imagen ELF. </p><br><p>  Las utilidades utilizan la tabla de <strong>secciones</strong> para analizar programas y bibliotecas, pero los cargadores no la utilizan para proyectar archivos ELF en la memoria de proceso.  La tabla de sección describe la estructura ELF con más detalle que la tabla de segmentos.  Varias secciones pueden estar dentro de un segmento. </p><br><p>  Los cargadores ELF crean una imagen ELF en memoria basada en el contenido de la tabla de <strong>segmentos</strong> .  La tabla de <strong>particiones</strong> ya no se usa para cargar ELF en la memoria. </p><br><div class="spoiler">  <b class="spoiler_title">Pero hay excepciones a esta regla.</b> <div class="spoiler_text"><p>  Por ejemplo, en la naturaleza, hay un parche de desarrolladores de Debian para el cargador ELF ld.so para la arquitectura ARM, que busca una sección especial ".ARM.attributes" como <a href="">SHT_ARM_ATTRIBUTES</a> y binarios con una tabla de sección <a href="">recortada</a> en dicho sistema. </p></div></div><br><p>  Un segmento ELF tiene banderas que determinan qué permisos tendrá el segmento en la memoria.  Tradicionalmente, la mayoría del software para GNU / Linux se organizó de tal manera que se <code>PT_LOAD</code> dos <code>PT_LOAD</code> (cargables en memoria) en la tabla de segmentos, como en la lista anterior: </p><br><ol><li><p>  Segmento con banderas <code>RE</code> </p><br><p>  1.1.  Código <strong>ejecutable</strong> ELF: secciones <code>.init</code> , <code>.text</code> , <code>.fini</code> </p><br><p>  1.2.  Datos <strong>inmutables</strong> en ELF: <code>.symtab</code> , <code>.rodata</code> </p><br></li><li><p>  Segmento de banderas <code>RW</code> </p><br><p>  2.1.  Datos <strong>variables</strong> en ELF: secciones <code>.plt</code> , <code>.got</code> , <code>.data</code> , <code>.bss</code> </p><br></li></ol><br><p>  Si presta atención a la composición del primer segmento y sus banderas de acceso, queda claro que tal diseño expande el espacio para buscar dispositivos para técnicas de reutilización de código.  En ELF grandes, como libcrypto, las tablas de servicio y otros <strong>datos</strong> inmutables pueden ocupar hasta el 40% del segmento <strong>ejecutable</strong> .  La presencia de algo similar a piezas de código en estos datos se confirma por los intentos de desmontar dichos archivos binarios con una gran cantidad de datos en el segmento ejecutable sin tablas de sección y símbolos.  Cada secuencia de bytes en este único segmento ejecutable puede considerarse útil para el fragmento de ataque del código de máquina y el trampolín, ya sea esta secuencia de bytes con al menos una parte de la línea del mensaje de depuración del programa, parte del nombre de la función en la tabla de símbolos o el número constante del algoritmo criptográfico ... </p><br><div class="spoiler">  <b class="spoiler_title">Encabezados ejecutables de PE</b> <div class="spoiler_text"><p>  Los encabezados y tablas ejecutables al comienzo del primer segmento de la imagen ELF se parecen a la situación de Windows hace aproximadamente 15 años.  Hubo una serie de virus que infectaron archivos, escribiendo su código en su encabezado PE, que también era ejecutable allí.  Logré desenterrar tal muestra en el archivo: </p><br><p><img src="https://habrastorage.org/webt/gy/kt/7t/gykt7t5znycwstjaek_cdoo_xvm.png" alt="Virus.Win32.Haless.1127"></p><br><p>  Como puede ver, el cuerpo del virus se aprieta justo después de la tabla de secciones en el área de los encabezados de PE.  En una proyección de un archivo en la memoria virtual, generalmente hay alrededor de 3 KB de espacio libre aquí.  Después del cuerpo del virus hay un espacio vacío y luego la primera sección comienza con el código del programa. </p><br><p>  Sin embargo, para Linux hubo trabajos mucho más interesantes de la escena VX: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Represalias</a> . </p></div></div><br><h1 id="reshenie">  Solución </h1><br><ul><li>  El problema descrito anteriormente se conoce desde hace <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mucho tiempo</a> . </li><li>  Corregido <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el 12 de enero de 2018</a> : se agrega la clave `ld -z separate-code: encabezado de segmento" Crear código separado "PT_LOAD" en el objeto. Esto especifica un segmento de memoria que debe contener solo instrucciones y debe estar en páginas totalmente separadas de cualquier otro dato. No cree un segmento de código separado "PT_LOAD" si se usa el código noseparate ").  La característica fue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lanzada</a> en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">versión 2.30</a> . </li><li>  Además, esta característica se incluyó de manera predeterminada en la próxima <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">versión 2.31</a> . </li><li>  Presente en paquetes <code>binutils</code> nuevos, por ejemplo, en los repositorios Ubuntu 18.10.  Muchos paquetes ya se han ensamblado con esta nueva característica, que el investigador de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ElfMaster</a> encontró y documentó </li></ul><br><p>  Como resultado de los cambios en el algoritmo de diseño, se obtiene una nueva imagen ELF: </p><br><pre> <code class="plaintext hljs">$ readelf -l ls Elf file type is DYN (Shared object file) Entry point 0x41aa There are 11 program headers, starting at offset 52 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align PHDR 0x000034 0x00000034 0x00000034 0x00160 0x00160 R 0x4 INTERP 0x000194 0x00000194 0x00000194 0x00013 0x00013 R 0x1 [Requesting program interpreter: /lib/ld-linux.so.2] LOAD 0x000000 0x00000000 0x00000000 0x01e6c 0x01e6c R 0x1000 LOAD 0x002000 0x00002000 0x00002000 0x14bd8 0x14bd8 RE 0x1000 LOAD 0x017000 0x00017000 0x00017000 0x0bf80 0x0bf80 R 0x1000 LOAD 0x0237f8 0x000247f8 0x000247f8 0x0096c 0x01afc RW 0x1000 DYNAMIC 0x023cec 0x00024cec 0x00024cec 0x00100 0x00100 RW 0x4 NOTE 0x0001a8 0x000001a8 0x000001a8 0x00044 0x00044 R 0x4 GNU_EH_FRAME 0x01c3f8 0x0001c3f8 0x0001c3f8 0x0092c 0x0092c R 0x4 GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RW 0x10 GNU_RELRO 0x0237f8 0x000247f8 0x000247f8 0x00808 0x00808 R 0x1 Section to Segment mapping: Segment Sections... 00 01 .interp 02 .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt 03 .init .plt .plt.got .text .fini 04 .rodata .eh_frame_hdr .eh_frame 05 .init_array .fini_array .data.rel.ro .dynamic .got .data .bss 06 .dynamic 07 .note.ABI-tag .note.gnu.build-id 08 .eh_frame_hdr 09 10 .init_array .fini_array .data.rel.ro .dynamic .got</code> </pre> <br><p>  El límite entre el código y los datos ahora es más preciso.  El único segmento ejecutable realmente contiene solo secciones de código: .init, .plt, .plt.got, .text, .fini. </p><br><div class="spoiler">  <b class="spoiler_title">¿Qué ha cambiado exactamente dentro de ld?</b> <div class="spoiler_text"><p>  Como sabe, la <a href="">secuencia de comandos del vinculador</a> describe la estructura del archivo ELF de salida.  Puede ver el script predeterminado como este: </p><br><pre> <code class="plaintext hljs">$ ld --verbose GNU ld (GNU Binutils for Ubuntu) 2.26.1 * * * using internal linker script: ================================================== /* Script for -z combreloc: combine and sort reloc sections */ /* Copyright (C) 2014-2015 Free Software Foundation, Inc. * * *</code> </pre> <br><p>  Muchos otros scripts para diferentes plataformas y combinaciones de opciones se encuentran en el directorio <code>ldscripts</code> .  Se han creado nuevos scripts para la opción de <code>separate-code</code> . </p><br><pre> <code class="plaintext hljs">$ diff elf_x86_64.x elf_x86_64.xe 1c1 &lt; /* Default linker script, for normal executables */ --- &gt; /* Script for -z separate-code: generate normal executables with separate code segment */ 46a47 &gt; . = ALIGN(CONSTANT (MAXPAGESIZE)); 70a72,75 &gt; . = ALIGN(CONSTANT (MAXPAGESIZE)); &gt; /* Adjust the address for the rodata segment. We want to adjust up to &gt; the same address within the page on the next page up. */ &gt; . = SEGMENT_START("rodata-segment", ALIGN(CONSTANT (MAXPAGESIZE)) + (. &amp; (CONSTANT (MAXPAGESIZE) - 1)));</code> </pre> <br><p>  Aquí puede ver que se ha agregado una directiva para declarar un nuevo segmento con secciones de solo lectura que siguen al segmento de código. </p><br><p>  Sin embargo, además de los scripts, se realizaron cambios en las fuentes del vinculador.  A saber, en la función <code>_bfd_elf_map_sections_to_segments</code> - vea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">commit</a> .  Ahora, al seleccionar segmentos para secciones, se agregará un nuevo segmento cuando la sección difiera por el indicador <code>SEC_CODE</code> de la sección anterior. </p></div></div><br><h1 id="vyvod">  Conclusión </h1><br><p>  Como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">antes</a> , recomendamos que los desarrolladores no se olviden de utilizar los indicadores de seguridad integrados en el compilador y el vinculador al desarrollar software.  Un cambio tan pequeño puede complicar en gran medida la vida del atacante y hacer que la suya sea mucho más tranquila. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es433108/">https://habr.com/ru/post/es433108/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es433098/index.html">La historia de DDR3, SPD y fabricantes chinos originales</a></li>
<li><a href="../es433100/index.html">Trabajando con una base de datos desde una aplicación</a></li>
<li><a href="../es433102/index.html">¿Por qué los científicos creen que el Noveno Planeta no existe?</a></li>
<li><a href="../es433104/index.html">El desafío de Foobar: la prueba secreta de Google para desarrolladores</a></li>
<li><a href="../es433106/index.html">SpaceX y NASA reafirman sus intenciones de lanzar el lanzamiento debut de la nave Crew Dragon en enero de 2019</a></li>
<li><a href="../es433112/index.html">JavaScript entretenido: Snow Day</a></li>
<li><a href="../es433114/index.html">Certificación PMP: preparación para el examen de estilo de cercanías</a></li>
<li><a href="../es433116/index.html">Lanzallamas, Santa Claus en un tanque, Bigfoot, Baba Yaga en Endurica (y, posiblemente, un jetpack): todo para niños para el nuevo año</a></li>
<li><a href="../es433118/index.html">Pruebas de referencia y análisis rápido de algoritmos de permutaciones</a></li>
<li><a href="../es433122/index.html">React-Hot-Loader v4.6</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>