<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍❤️‍💋‍👨 🤰🏾 ⌛️ Bagaimana menjalin pertemanan sebagai perancang, perancang tata letak, dan "Figma" menggunakan sistem desain, linggis, dan semacam mother ™ 🆙 💃🏼 👂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai, Habr. Baru-baru ini, saya memamerkan dalam komentar dan berjanji untuk menjawab secara rinci pertanyaan tentang bagaimana sistem desain menyederh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana menjalin pertemanan sebagai perancang, perancang tata letak, dan "Figma" menggunakan sistem desain, linggis, dan semacam mother ™</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464115/"><img src="https://habrastorage.org/webt/dg/qs/56/dgqs56pmsleaxfhdngdvpslxozu.jpeg"><br><br>  Hai, Habr.  Baru-baru ini, saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memamerkan</a> dalam komentar dan berjanji untuk menjawab secara rinci pertanyaan tentang bagaimana sistem desain menyederhanakan hubungan dan menetralisir konflik antara desainer dan desainer tata letak (pengembang).  Ditambah bicara tentang beberapa opsi untuk menstandarisasi penamaan layer.  Jadi saya jawab.  <i>Secara detail</i> .  Tentang grid.  Tentang komponen.  Tentang ikon.  Tentang bahasanya.  Tentang BEM  Tentang slash "figmin" dan pluginsnya.  Tentang artboards dan viewports.  Tentang tipografi.  Tentang gaya dan palet.  Tentang efeknya.  Tentang mengekspor raster.  Tentang "multi-pemain."  Tentang pembagian tugas.  Ya, sedikit "tentang kehidupan, alam semesta, dan secara umum."  Perhatian, lalu lintas: ada banyak gambar di dalamnya, ada animasi gif.  Dan banyak, <i>sangat banyak</i> teks yang membosankan.  Saya memperingatkan. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Penafian, untuk menghemat waktu Anda:</b> <div class="spoiler_text">  Penulis adalah nama mutlak dan tidak memiliki pengalaman dalam organisasi besar dan megah.  Segala sesuatu yang dijelaskan adalah pendapat pribadi, tidak didukung oleh penelitian ilmiah.  Semua pengalaman subjektif saya diperoleh saat bekerja pada proyek-proyek yang relatif kecil dengan sumber daya manusia hingga 10 orang, ditambah dari menjadi sukarelawan dalam beberapa proyek asing dari mereka yang digerakkan oleh masyarakat.  Saya tidak siap memikul tanggung jawab atas waktu Anda yang hilang, kemungkinan kerugian atau kehilangan keuntungan.  Dan saya tidak akan mengembalikan tahun terbaik Anda kepada Anda jika Anda membelanjakannya untuk saya :) Apa yang saya miliki, saya akan membagikannya.  Ayo pergi. <br></div></div><br><h2>  Desain sistem sebagai sarana penyelesaian konflik </h2><br>  Beberapa desainer berpikir bahwa <i>sistem desain</i> adalah perpustakaan gaya.  Perjanjian bahwa "kami membuat tombol merah, dadu biru, dan kami menulis teks dengan Helvetica."  Beberapa orang berpikir bahwa ini adalah satu set kosong dari mana model dirakit.  Seperti, ini akan terlihat seperti jendela modal, dan seperti ini - kartu produk.  Tender front-end melangkah lebih jauh dan memasukkan implementasi teknis dalam konsep.  Ucapkan pustaka komponen pada Bereaksi.  Semua ini benar dengan caranya sendiri.  Tapi ini khusus.  Jika Anda menggalinya, fungsi utama dari sistem desain adalah untuk mengembangkan standar untuk interaksi orang-orang yang bekerja di proyek.  Karena itu, pada awalnya dimaksudkan untuk menghilangkan konflik.  Setidaknya saya percaya pada hal itu dan saya ingin membenarkan, setelah berjalan melalui semua jagung sakit utama. <br><br><h2>  Konflik pertama.  Jarak, ukuran, dan indentasi </h2><br>  <i><b>Intinya.</b></i>  <i>Perancang memahat ukuran secara tidak akurat, perancang tata letak secara konstan menemukan nilai heterogen dan fraksional.</i>  <i>Tidak jelas yang mana yang benar dan mana yang salah.</i>  <i>"Figma" tidak memungkinkan untuk mengukur jarak dengan penggaris.</i> <br><br>  <b>"Solusi" yang khas.</b>  Semua orang menendang sang desainer, berusaha membuatnya lebih penuh perhatian dan benar-benar menargetkan piksel.  Hasil: diz jahat berkedut menghabiskan berjam-jam mencoba untuk memindahkan ratusan blok pada seratus artboards dengan 1-2 piksel.  Hasilnya masih belum sempurna, desainer tata letak masih tidak puas, tenggat waktu pergi, klien kehilangan uang, semua orang bertengkar dan bertebaran saling mengeluh di forum profil. <br><br>  <b>Solusi nyata.</b>  Buat sistem desain dan terima.  Untuk memikirkan atau secara bertahap mengembangkan kisi-kisi yang nyaman, satukan tata letak (dalam arti teknis), dan gunakan pustaka gaya dan komponen dengan benar.  Hasil: perancang Akela masih merindukan secara teratur, tetapi perancang tata letak dapat menentukan sebagian besar jarak bahkan dengan mata tanpa melihat sifat-sifat blok.  Selain itu, semakin jauh, semakin keduanya menumpuk komponen siap pakai dan gaya / mixin yang hanya disalin dari proyek ke proyek. <br><br>  Jika Anda memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kisi yang</a> dirancang dengan baik dan Anda menggunakan pendekatan komponen, maka semua angka dapat disatukan atau dihitung dengan aritmatika dasar.  Agar tidak berdasar, untuk contoh di bawah ini saya akan menunjukkan salah satu sistem grid di mana bagian terbesar dari proyek saya dikumpulkan.  Ini adalah sepeda pribadi, tetapi dengan menggunakan prinsip-prinsip serupa, Anda dapat menciptakan sebanyak mungkin untuk setiap selera Anda. <br><br><h3>  4px.  Multiplisitas - Adik Bakat </h3><br>  Lapisan mesh pertama selalu sama: <b>kotak 4px.</b>  Bahkan, saya bekerja dengan "skala piksel", yang terdiri dari 4x4 yang biasa.  Akibatnya, elemen tata letak apa pun, kecuali garis (garis, garis, garis offline, jam, dll.) Selalu memiliki ukuran kelipatan empat. <br><br><img src="https://habrastorage.org/webt/hf/ob/vw/hfobvwihln-vbr3h4xb3uhroqgy.jpeg"><br><br>  Ini secara otomatis menghapus semua pertanyaan tentang offset acak, piksel fraksional, dll.  Jika perancang tata letak melihat sesuatu yang sama sekali berbeda dari empat di tata letak dan tanpa komentar tambahan, maka dengan probabilitas 99% ini hanya sebuah kusen - ia dapat dengan mudah mengganti angka dengan kelipatan terdekat, bahkan tanpa merinci. <br><br>  Ini tidak berarti bahwa Anda dapat bersantai dan memahat model dengan tumit kiri Anda melewati jaring.  Kecelakaan tidak bisa dihindari, tetapi keberadaan sistem memungkinkan perancang tata letak untuk membedakan antara jambs dan perubahan yang disengaja. <br><br><h4>  Mengapa tepatnya 4? </h4><br>  Karena  Pada prinsipnya, itu bisa berupa angka: setidaknya 5, setidaknya 3, setidaknya 10. Satu-satunya kriteria: kemudahan penggunaan.  Bahkan angka lebih nyaman, karena ukuran viewports dan operator hampir selalu dinyatakan dalam angka genap (dan sering kelipatan empat).  Selain itu, masih ada interpolasi saat penskalaan raster, tetapi ini tidak begitu penting. <br><br>  Hal utama adalah bahwa angka 4 cukup kecil untuk menjadi universal, dan cukup besar untuk secara signifikan mengurangi penyebaran semua jenis nilai dalam tata letak.  Jika Anda mengambil lebih banyak, akan sulit untuk membuat elemen kecil.  Sebagai contoh, dengan basis 10px, padding di dalam kolom input akan sangat tidak sopan, dan pilihan memimpin untuk teks akan langka.  Ini adalah langkah besar yang tidak perlu, saya ingin lebih kecil.  Secara empiris, semua orang telah lama mencoba 4px, dan tidak mungkin Anda akan menemukan sesuatu yang lebih universal.  Tapi Anda yang memutuskan. <br><br><h3>  Irama vertikal </h3><br><h4>  Memimpin Dasar </h4><br>  Sekarang Anda perlu menentukan dasar memimpin - <b>ketinggian garis</b> , yang akan menciptakan ritme vertikal dan selanjutnya akan mempengaruhi ketinggian sebagian besar elemen.  Hasilnya, kami "mengatur" tata letak secara vertikal. <br><br>  <i>(Jika Anda tidak terbiasa dengan konsep-konsep ritme vertikal, font dasar dan modul, sekali lagi, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel tentang grid</a> - katanya bahkan lebih membosankan daripada di sini, tetapi di sana Anda memilikinya).</i> <br><br>  Memimpin dapat bervariasi di berbagai proyek.  Tetapi paling sering saya menggunakan <b>16px</b> <b>atau 24px</b> .  Anda dapat menghasilkan sesuatu milik Anda sendiri, dengan mengingat bahwa angka-angka tersebut harus merupakan kelipatan dari grid piksel dasar Anda. <br><br><img src="https://habrastorage.org/webt/c6/wm/mk/c6wmmkgfzbr5lzg5sxgclcdcrom.jpeg"><br><br><img src="https://habrastorage.org/webt/n2/nn/83/n2nn83jjqnpwlfn700yzdtmgs1u.jpeg"><br><br>  Harap dicatat bahwa pada 16px teks sebenarnya tidak mengambil satu baris, tetapi dua.  Jadi secara resmi kami menggunakan timah 32px.  Tetapi dalam hal ritme, ini adalah satu dan sama.  Cukup bagi setiap baris menjadi dua untuk membuatnya lebih mudah untuk bekerja dengan elemen-elemen kecil. <br><br><h4>  Ketinggian standar </h4><br>  Sebagai hasil dari keputusan tersebut, sejumlah angka <b>"ajaib"</b> diperoleh, yang akan dianggap sebagai ukuran blok vertikal standar.  Kami tidak lupa tentang kemungkinan menggunakan interval setengah dan setengah untuk kasus menengah, seperti paddings atau teks kecil.  Ini adalah praktik umum sejak pengaturan huruf kertas. <br><br><img src="https://habrastorage.org/webt/1y/u9/d8/1yu9d8tfaoc2r2zezfjhj6y-cy0.jpeg"><br><br>  Jika terjadi masalah dengan memuat gambar dan aritmatika: <br><div class="scrollable-table"><table><tbody><tr><th>  Terkemuka </th><th>  Interval keseluruhan </th><th>  Interval pecahan </th></tr><tr><td>  16px / 32px </td><td>  32px, 48px, 64px, 80px, 96px, ... </td><td>  8px, 24px, ... </td></tr><tr><td>  24px </td><td>  24px, 48px, 72px, 96px, ... </td><td>  12px, 36px, ... </td></tr></tbody></table></div><br>  Alasan lain untuk mencintai hanya dua penguasa ini adalah bahwa mereka sebanding satu sama lain: tiga baris 16px sama dengan dua baris 24px (16 * 3 = 24 * 2).  Ini memungkinkan Anda untuk menyeret beberapa komponen di antara mereka tanpa kehilangan ritme keseluruhan.  Misalnya, 48x48 ikon sangat pas di kedua kisi.  Seperti yang Anda duga, semua kelipatan 48: 96, 144, 192, dll. Akan bersifat universal. <br><br>  Tidak perlu takut dengan kegelapan angka yang tidak biasa.  Dalam praktiknya, setelah 2-3 proyek, mereka memperbudak otak Anda dan dengan kuat membekas di subkorteks. <br><br><h4>  Modul dan tinggi gatter </h4><br>  Saya perhatikan bahwa standardisasi tidak berarti keseragaman total.  Kami menyesuaikan baseline, ya.  Tetapi tidak ada yang mengganggu untuk memvariasikan <i>proporsi</i> modul yang Anda inginkan.  Berikut adalah dua contoh untuk perbandingan: <br><br><img src="https://habrastorage.org/webt/i_/k-/pk/i_k-pkovlxcltoybtcfl6d57tdm.jpeg"><br><br>  Di sebelah kiri, kami membuat tinggi modul sama dengan dua garis dan mendapat kisi yang sangat "datar", yang nyaman untuk formulir pengaturan huruf, tabel, antarmuka daftar, dan hal-hal serupa lainnya.  Dan di sebelah kanan, modul lebih tinggi, 5 baris.  Cocok untuk tata letak di mana ada banyak galeri, kartu horisontal, blok spanduk, gambar. <br><br>  <b>Talang</b>  Talang - “selokan”, “alur”] - inilah yang biasa disebut <i>jarak antar moda</i> .  Tingginya juga selalu dilakukan sebagai kelipatan dari lead base.  Paling sering itu akan menjadi 1 baris.  Tetapi jika, misalnya, tata letaknya menyedihkan dan sebagian besar terdiri dari gambar-gambar besar, Anda dapat memisahkannya dengan gatter tinggi dalam beberapa baris. <br><br>  Seperti yang Anda lihat, kami masih menciptakan cukup banyak kisi, tetapi semuanya digabungkan satu sama lain dan pustaka komponen, karena pustaka memiliki <i>dasar ritme yang</i> sama <i>.</i> <br><br>  Adalah penting bahwa dari sudut pandang tata letak praktis tidak ada perbedaan.  Semua angka masih merupakan kelipatan dari basis terkemuka (16px) dan merupakan bagian dari standar "ajaib" kami.  Jadi modul ini hanya proporsi visual, yang membantu dengan cepat membuat sketsa elemen pada tata letak dan menghitung dimensi mereka dengan mata. <br><br>  <b>Mari kita coba</b> dengan contoh kecil.  Jadi, ada 2 jerat standar dengan 16px terkemuka.  Tinggi Gatter - 1 baris (16px).  Ketinggian modul di tata letak kiri adalah 2 baris, di kanan - 5 baris.  Bisakah kita sekarang menentukan ukuran / indentasi elemen yang benar tanpa melihat propertinya? <br><br><img src="https://habrastorage.org/webt/o0/s_/zq/o0s_zqm1t4b6xjv-ozn2a72ltyg.jpeg"><br><br>  Saya pikir kita bisa.  Tidak ada yang rumit: perkirakan jumlah garis dan gandakan dengan pimpinan dasar.  Itu saja.  Selain itu, angka-angka ini dijamin akan dimasukkan dalam seri "standar".  Yaitu, karena latihan aritmatika dengan cepat dibawa ke otomatisme.  Apakah garis Photoshop diperlukan di sini?  Saya pikir juga tidak.  Sekalipun ada sesuatu yang sulit diperhitungkan dalam pikiran, maka mengintip ke dalam sifat bukanlah masalah. <br><br>  Sekarang mari kita bayangkan bahwa desainer keliru di suatu tempat dalam pixel atau bahkan dua.  Apakah ini memengaruhi perancang tata letak?  Tidak, tidak.  Perancang tata letak melihat kisi, perancang tata letak mengumpulkan proyek di atasnya.  Intinya.  Dan Tuhan memberkatinya, dengan getaran sang desainer.  <i>Tidak ada masalah</i> , tidak ada konflik) <br><br><h3>  Irama horisontal: gatter, speaker, bidang </h3><br><h4>  Gatter </h4><br>  Demikian pula, pilih gatter ukuran horisontal kelipatan 4px.  Paling sering saya membuat gatter <b>square (16x16).</b>  Tetapi jika Anda membutuhkan lekukan yang lebih luas di antara kolom, Anda dapat mengambil nilai lain: 20px, 24px, 28px, 32px ... dll. <br><br>  Dalam hal ini, gatter menjadi dasar untuk jarak horizontal dengan analogi dengan yang terkemuka.  Jika Anda membuat lebarnya sama dengan 20px, maka seluruh "standar ajaib" untuk garis kontur akan berubah menjadi "10, 20, 30, 40 ...".  Tapi, terus terang, ini adalah angka-angka yang tidak nyaman, bantalan kecil dan semua yang akan sangat dirindukan.  Secara umum, saya akan merekomendasikan untuk tidak menjadi pintar dan membuat gatter baik persegi atau ganda.  Lebih mudah untuk bekerja dengan satu set angka standar dibandingkan dengan dua. <br><br><h4>  Kolom dan daya tanggapnya </h4><br>  Setelah memutuskan "standar ajaib", kami menyesuaikan kolom sesuai dengan ukuran kanvas atau breakpoint, yang akan kita bicarakan sedikit kemudian. <br><br>  Kotak dapat dibuat benar-benar responsif, maka kolom akan menjadi karet: lebarnya adalah "peregangan", jumlahnya berubah-ubah - misalnya, 12. <br><br><img src="https://habrastorage.org/webt/qj/3i/-f/qj3i-ffms-dh9kbndghecy8najk.gif"><br><br>  Atau Anda dapat secara manual mengatur lebar kolom untuk mendapatkan jumlah kolom yang berbeda pada viewports yang berbeda (klasik: 4 pada ponsel, 8 pada "tablet", 12 pada desktop, 16 pada layar lebar).  Dalam pengaturan kisi, terlihat seperti ini: jumlah "otomatis", lebarnya adalah angka yang berubah-ubah, yang dipilih berdasarkan ukuran artboard dan gatter. <br><br><img src="https://habrastorage.org/webt/-_/cd/sn/-_cdsnz-nbqww-ewy8bxamioshu.gif"><br><br>  Pada saat yang sama, pada tingkat tata letak, kolom dapat menjadi karet dan sepenuhnya diperbaiki.  Dalam kasus terakhir, "telinga" muncul di tata letak - bidang yang tidak digunakan oleh konten, tetapi, sebagai aturan, tumpang tindih dengan latar belakang umum halaman.  Jika diinginkan, ini dapat ditunjukkan dengan menyesuaikan "margin" dengan perataan tengah kolom. <br><br><img src="https://habrastorage.org/webt/-c/nz/kx/-cnzkxy3lrvrq0mrrng9t1tu8e4.gif"><br><br><h4>  Siapa yang memutuskan bagaimana perilaku grid </h4><br>  Idealnya, seorang desainer.  Jika dia UI / UX.  Oleh karena itu, desainnya sering <i>adaptif</i> , dan bukan hanya karet, dan diinginkan bahwa ada beberapa perilaku seragam dari seluruh tata letak.  Tetapi penting bahwa perancang tata letak menerima informasi di muka tentang skema mana yang Anda putuskan untuk diterapkan dalam proyek tertentu, dan dapat mengungkapkan pendapatnya jika perlu. <br><br>  Dalam praktiknya, ada situasi di mana lebih baik membuat keputusan untuk perancang tata letak.  Misalnya, jika penggunaan beberapa kerangka kerja, seperti bootstrap atau yang lainnya, disepakati sebelumnya.  Apa pun bisa terjadi: permintaan klien, warisan, batas waktu, atau bahkan kemampuan perancang tata letak sendiri.  Ini harus diambil dengan tenang.  Kita tidak semua dewa, semua orang memiliki batas kemungkinan.  Dalam kasus tersebut, perancang sudah ditolak oleh persyaratan perancang tata letak, memastikan bahwa tata letak cocok.  Tidak ada yang kriminal, karena  kami terlibat dalam tugas-tugas terapan, bukan seni murni. <br><br>  Jadi, memiliki gagasan tentang ukuran gerbang + prinsip mempartisi kolom + "standar ajaib", kita, sekali lagi, dapat menentukan ukuran horizontal elemen dengan aritmatika murni.  Konflik khusus seharusnya tidak muncul di sini lagi. <br><br><h3>  Breakpoint dan ukuran bingkai utama </h3><br>  Halangan lain yang mungkin terjadi: tata letak ukuran apa, bagaimana memilih breakpoint, viewports yang akan digambar, dan di mana "semuanya sudah jelas." <br><br>  Di era Photoshop, dan bahkan hanya setahun yang lalu, ini menjadi masalah bagi banyak orang: <br><br><img src="https://habrastorage.org/webt/re/c3/6n/rec36n6b4_dejufzhxktfrljycu.png"><br><br>  Dengan Figma, ini menjadi urutan besarnya lebih mudah karena kanvas responsif.  Dalam bahasa sehari-hari, "karet" membentang.  Tetapi beberapa pertanyaan masih ada. <br><br>  Seseorang mengambil resolusi layar standar langsung dari "Figma".  Seseorang menyesuaikan artboards dengan nilai default "Bootstrap", seseorang mendorong menjauh dari konten.  Saya seorang pengendara sepeda kecil dalam hal ini.  Saya menyesuaikan ukuran kanvas sehingga mereka dengan jelas masuk ke dalam kisi dan selalu bekerja dengan angka "ajaib" yang sama. <br><br><h4>  Mengapa artboards dengan ukuran sewenang-wenang </h4><br>  Pertama-tama, saya rasa tidak tepat untuk menggambar tata letak karet persis di bawah viewport.  Beberapa tahun yang lalu saya membaca artikel yang bagus “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara 100% benar untuk melakukan breakpoint CSS</a> ”.  Saya mengunyah untuk waktu yang lama, tetapi pada akhirnya saya menerima sudut pandang penulis.  Singkatnya: dengan pendekatan yang biasa, pada titik breakpoint, semua elemen tata letak berada dalam keadaan ekstrim (lebar minimum atau lebar maksimum), sedangkan untuk viewports populer saya ingin mendapatkan nilai rata-rata "normal", lebih alami.  Oleh karena itu, breakpoints paling baik ditempatkan di <i>antara</i> lebar layar yang populer, dan tidak tepat di atasnya.  Dengan demikian, lebar minimum tata letak diambil sedikit kurang dari viewport, dan membentang sedikit lebih jauh.  Kedengarannya membingungkan, tetapi masuk akal. <br><br>  Kedua, saya hampir tidak menemukan bootstraps dan tidak ada masalah dengan tata letak manual, jadi saya tidak harus benar-benar fokus pada standar eksternal apa pun. <br><br>  Ketiga, bertentangan dengan stereotip, huruf-huruf dengan siapa saya bekerja lebih sering meminta penjelasan untuk layar lebar daripada yang sempit.  Artinya, mereka sendiri mampu menyesuaikan tata letak dengan viewport.  Mereka lebih peduli tentang bagaimana dan bagaimana kita akan mengisi area "ekstra". <br><br>  Dengan demikian, lebih mudah untuk menempatkan artboard persis di grid, yang dengan jelas menunjukkan <i>prinsip</i> - <i>prinsip</i> penskalaan dan semua jarak, daripada memukau secara ketat ukuran viewports dan kemudian bermain-main dengan jumlah kolom dan lebar elemen yang sedikit canggung.  Ini adalah solusi untuk konflik. <br><br><h4>  Perhitungan lebar tata letak optimal </h4><br><ol><li>  Tentukan <i>perkiraan</i> lebar yang diinginkan untuk viewport terdekat.  Misalnya, sebagai layar minimum, lebar apa pun dalam kisaran 290-320 px cocok untuk saya, dan untuk desktop, katakanlah 1100-1300px.  Tertarik terutama pada bilah bawah, karena  Meregangkan kolom dalam plus atau menambahkan “telinga” bukanlah masalah. </li><li>  Kami memperkirakan jumlah kolom yang diinginkan.  Untuk seluler, saya biasanya mengambil 3 atau 4 (dari konten, yang ada di sana: genap atau ganjil), dan untuk desktop - 12. (Dalam artikel tentang kisi-kisi, saya sudah bicara tentang versi 24-kolom yang menarik, tetapi khusus, untuk kesederhanaan kami tidak membawanya dalam perhitungan). </li><li>  Kurangi semua gatters dan bidang dari lebar yang diinginkan (ada 1 gatters kurang dari kolom, dan dua bidang - catatan Cap). </li><li>  Jumlah yang tersisa dibagi dengan jumlah kolom, kami mendapatkan perkiraan lebar kolom yang dibutuhkan. </li><li>  Bulatkan perkiraan lebar kolom ke angka "sihir" standar terdekat.  Kami mendapatkan lebar kolom yang <i>nyaman</i> . </li><li>  Kami mempertimbangkan lebar tata letak yang optimal: semua kolom <i>nyaman</i> + semua bidang gatter +. </li></ol><br>  Akibatnya, luasnya tata letak selalu merupakan kelipatan dari pangkalan, semua kolom dan lekukan terletak tepat di panduan, semuanya nyaman dan dapat dimengerti. <br><br>  Paling sering, untuk web saya menggunakan kolom lebar <b>80px.</b>  Dan gateway persegi 16px.  Sebagai hasilnya, lebar khas artboards adalah: <b>304px,</b> 592px, <b>1168px,</b> 1552px.  Secara alami, setiap tata letak dengan mudah memanjang ke atas.  Gambar bitmap latar belakang disiapkan dengan margin.  Cukup nyaman, biasanya tidak ada keluhan tentang ini. <br><br><h4>  Lapisan kotak tambahan </h4><br>  Kadang-kadang, panduan tambahan ditumpangkan di atas grid biasa, yang membantu untuk mengontrol jarak lebih fleksibel atau menunjukkan semacam pembatasan.  Sebagai contoh, salah satu artboards ponsel standar saya (304px) termasuk 16px dan 48px indent “rails” untuk membuat ikon dan teks lebih nyaman.  Area "layar pertama" yang relatif aman ditandai oleh garis horizontal hijau. <br><br><img src="https://habrastorage.org/webt/nb/pz/nx/nbpznxbl8vy26sy69cw1doa9ays.jpeg"><br><br>  Prinsipnya sama: untuk merancang pola dan kisi sehingga untuk semua situasi, solusi dan komponen yang khas ada tempat yang siap. <br><br><h3>  Ikon </h3><br>  Ikon disimpan pada kotak terpisah dan dikumpulkan melalui komponen pembungkus menengah.  Ikon-ikon itu sendiri diskalakan.  Terkadang perlu untuk menggunakan beberapa dari mereka sebagai ilustrasi, peluru, dll.  Tapi pembungkus selalu menangkap ukurannya dan memberikan margin keamanan.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika komponen ikon (pembungkus) membentang, ikon itu sendiri tetap normal, karena </font><font style="vertical-align: inherit;">di dalam bungkusnya, semuanya disejajarkan dengan "tengah", bukan "skala". </font><font style="vertical-align: inherit;">Pembungkus bisa dari beberapa ukuran. </font></font><br><br><img src="https://habrastorage.org/webt/pz/js/mg/pzjsmgbwys-_wonxxyiqbhu8rbm.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pendekatan ini memungkinkan Anda untuk menyesuaikan dimensi optik ikon tanpa merusak komponen, plus mudah untuk mengubah ikon di dalam komponen apa pun dengan hanya memilihnya dari daftar. </font></font><br><br><img src="https://habrastorage.org/webt/f4/rk/s1/f4rks1ofierlscc5l_xhnizyplw.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Cara mengelompokkan - lihat bagian tentang lapisan penamaan).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tidak perlu memasukkan sesuatu ke internet </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jelas, ada pengecualian untuk semua "keindahan". Misalnya, tidak ada alasan untuk mengukur bantalan di antara item menu sebaris jika panjangnya sendiri bervariasi (“tumbuh secara horizontal”). Jarak-jarak ini dihitung secara otomatis baik pada level "Angka" (ketika Anda menggunakan "Atur -&gt; jarak horisontal Ditribute") dan pada tingkat tata letak (misalnya, fleksibel). Artinya, tidak ada yang membutuhkan nilai persisnya sama sekali. Satu-satunya hal yang diperlukan adalah menjelaskan kepada perancang tata letak perilaku seperti apa yang Anda harapkan dari poin-poin ini. Ada komentar untuk ini. (Atau label atas nama lapisan, atau surat pengantar, atau hanya perjanjian awal - yang utama adalah bahwa saluran komunikasi diterima oleh semua orang).</font></font><br><br><img src="https://habrastorage.org/webt/hv/jl/uy/hvjluyjpijmart_mj_e5a2ksoco.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena Figma tidak sempurna, beberapa hal lebih mudah dilakukan di tingkat tata letak, tanpa repot-repot menggambarnya. </font><font style="vertical-align: inherit;">Oleh karena itu, komentar didahulukan dari apa yang ditarik. </font><font style="vertical-align: inherit;">Sebagai contoh, dalam tata letak menu tampak seperti ruang-antara, tetapi saya menulis ruang-sekitar. </font><font style="vertical-align: inherit;">Di dunia yang ideal, perancang tata letak akan mempertimbangkan ini. </font><font style="vertical-align: inherit;">Tidak sempurna - mungkin tidak diperhatikan, tetapi nanti akan diperbaiki atas permintaan saya, karena saya menggunakan umpan komentar sebagai daftar periksa. </font><font style="vertical-align: inherit;">Sekali lagi, tidak ada konflik.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cara menggunakan komponen sehingga semua orang senang </font></font></h3><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penting untuk menetapkan perilaku yang benar untuk setiap lapisan (metode penyelarasan dan penskalaan). </font><font style="vertical-align: inherit;">Periksa perilaku dengan menarik bolak-balik tidak hanya komponen itu sendiri, tetapi seluruh artboard (ada nuansa dengan grup). </font><font style="vertical-align: inherit;">Ini menghilangkan sebagian besar pertanyaan mengenai respons tata letak, ditambah lagi membantu untuk menemukan area masalah baik dalam desain itu sendiri maupun dalam arsitektur komponen.</font></font></li><li>        .      ,             —       ,         . </li><li>  -                  () —  ,     .      -,         . </li><li>      -. (    ,      ).          ,     -,       . </li><li>     ,       -.      -   (, ,  ). </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara umum, cacat acak dan kruk visual tidak termasuk dalam tata letak. </font><font style="vertical-align: inherit;">Saya dapat, misalnya, bereksperimen dengan font komponen dalam beberapa tata letak yang terpisah, dan kemudian lupa mengembalikan semuanya. </font><font style="vertical-align: inherit;">Jika penata huruf akan mempelajari setiap salinan secara terpisah, maka ia pasti akan mengumpulkan 3-5 versi komponen apa pun dari seratus layar) Oleh karena itu, lebih mudah untuk mematuhi prinsip terbalik: apa yang tidak secara sadar terdaftar dalam daftar komponen tidak ada di alam dan merupakan halusinasi) Atau, misalnya, "Curang" - kasus ideal untuk desain presentasi, yang tidak ada hubungannya dengan pengaturan huruf pertempuran.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konflik kedua. </font><font style="vertical-align: inherit;">Penamaan (layer, artboards, gaya, file)</font></font></h2><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intinya. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perancang tidak peduli dengan penamaan lapisan atau nama mereka dari bulldozer. </font><font style="vertical-align: inherit;">Sulit bagi perancang tata letak untuk menemukan lapisan yang diperlukan dalam daftar bentuk "Rectangle1, Rectangle2, ...". </font><font style="vertical-align: inherit;">Proyek tidak terstruktur atau tidak terstruktur dengan baik. </font><font style="vertical-align: inherit;">Tidak jelas ke mana harus mencari layar atau komponen tertentu. </font></font></i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solusi </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setujuilah prinsip-prinsip paling umum (bahasa, struktur halaman). </font><font style="vertical-align: inherit;">Pilih salah satu sistem penamaan yang ada saat ini (misalnya, BEM). </font><font style="vertical-align: inherit;">Gunakan kemampuan "Gambar" dan plugin untuk mengelompokkan, mencari, dan mengganti nama. </font><font style="vertical-align: inherit;">Merakit desain pada komponen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inggris, Latin </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda memiliki tim yang kurang lebih berbahasa Inggris, saya sangat menyarankan agar Anda menyebutkan semuanya dalam bahasa Inggris dan menghindari Cyrillic. </font><font style="vertical-align: inherit;">Bahkan jika Anda saat ini hanya bekerja di pasar domestik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama, ini memungkinkan Anda untuk mendekatkan tata letak ke tata letak: menyinkronkan nama komponen dengan kelas, dan gaya dengan mixin. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kedua, ini akan sangat membantu jika suatu hari nanti Anda ingin berbagi pengalaman Anda dengan audiens yang lebih luas atau, misalnya, menjadi perlu untuk menunjukkan semacam kasus pada sumber daya internasional. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya memahami kontra-argumen, tetapi saya sampai pada praktiknya. </font><font style="vertical-align: inherit;">Seperti lelucon itu: "Tidak ada yang berpikir kertas toilet adalah hadiah yang sempurna sampai mereka membutuhkannya."</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penamaan. </font><font style="vertical-align: inherit;">Notasi BEM</font></font></h3><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konvensi penamaan BEM.</font></font></a> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kenapa tepatnya? </font></font></h4><br><ul><li>       (CSS),    «»      ,  ,       CSS-  GUI. </li><li>      .     ,   ,    . (  ,     ;   ,      .      — ,   . ,     ,   - ). </li><li>         «» (   ., . ). </li><li>         «»      (  , ,   ..). </li><li>         :    ,  ,  . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yang penting adalah kita tidak mencari </font><font style="vertical-align: inherit;">sistem yang </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ideal</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tetapi yang </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">universal</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Penamaan layer seperti itu tidak masuk akal dalam hal mengekspor CSS: kami masih tidak dapat mengonversinya menjadi markup yang sudah jadi. Tetapi kami tidak mencapai ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita membutuhkan perancang dan perancang tata letak untuk hanya memahami satu sama lain dan bekerja pada panjang gelombang yang sama. Bahwa menu tidak jatuh pada 10 lapisan atau komponen dengan nama yang sama. Sehingga, melihat dalam korespondensi "nav-menu-item_active", penata letak langsung mengerti komponen tertentu yang dimaksud. Sehingga orang tidak perlu memutar otak mereka, datang dengan nama mereka untuk hal yang sama. Agar komponen dalam pustaka Figma bertepatan dengan pustaka komponen di sumber perakitan, setidaknya untuk posisi kunci. Singkatnya, standar, tidak ideal.</font></font><br><br>     - ,  «».   ,       - .   , .     <i></i>  ,       :) <br><br><h4>       </h4><br><img src="https://habrastorage.org/webt/xm/lc/xy/xmlcxyligfcwe-9-ngqq-t8rps8.jpeg"><br><br><img src="https://habrastorage.org/webt/7a/ib/jr/7aibjrzwbrgvkzsmc9gxybvucrc.jpeg"><br><br>         .    ,  . <br><br>  (&amp;)     Stylus (sass/less),     .  «&amp;__» ,    « <b></b> » (   <b></b> ).     ,      ,    Stylus    : <br><br><pre><code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.widget-heading</span></span> &amp;__<span class="hljs-selector-tag"><span class="hljs-selector-tag">title</span></span> … &amp;__<span class="hljs-selector-tag"><span class="hljs-selector-tag">icon-menu</span></span> …</code> </pre> <br>  Setiap komponen dalam hal <b>B</b> EM dianggap sebagai kunci <b>B.</b>  Oleh karena itu, hanya tanda hubung dan Latin yang digunakan dalam judul jika Anda menggunakan sintaks klasik. <br><br>  Satu garis bawah ("_") dalam sintaksis klasik yang sama dari BE <b>M</b> digunakan untuk menunjukkan odifier <b>M.</b>  Misalnya, "block_hover" adalah komponen "block" di negara: hover, dan "widget_collapsed" adalah komponen widget dalam keadaan diminimalkan. <br><br>  Tentu saja, struktur lapisan dalam Figma tidak persis sesuai dengan tata letak.  Karena itu, beberapa hal cukup arbitrer.  Sebagai contoh, komponen dengan pengubah harus dibungkus dengan komponen baru - nesting tambahan muncul, sedangkan dalam tata letak kelas-kelas ini ditugaskan ke blok bersama-sama, mereka berada di level yang sama.  Tetapi, sekali lagi, tidak ada tujuan untuk secara akurat meniru tata letak. <br><br>  Garis miring adalah simbol yang disediakan oleh Bentuk yang memungkinkan Anda untuk mengelompokkan komponen.  Lihat di bawah.  Saya menyisipkannya sehingga nyaman untuk mengganti status elemen (hover, fokus, dll.). <br><br>  Nah, tanda kurung kotak hanya tanda teknis, yang mengatakan bahwa lapisan ini adalah penopang visual (seperti sudut pembulatan di latar belakang) dan tidak perlu ditambahkan ke markup. <br><br><h4>  Apa dan kapan memberi nama dan apa yang dinilai </h4><br>  Para ahli teori merekomendasikan memberi nama setiap lapisan pada saat penciptaan.  Pada kenyataannya, ini akan menjadi pekerjaan yang tidak berarti.  Lapisan dalam proyek terus-menerus ditambahkan dan menghilang, dilem dan dipindahkan bolak-balik.  Karena itu, prinsip saya lebih sederhana. <br><br>  <b>Disebut dengan ketat:</b> <br><br><ul><li>  Artboards (bingkai level root). </li><li>  Komponen utama. </li><li>  Semua lapisan yang merupakan bagian dari komponen master.  (Life hack: ini <b>tidak</b> dilakukan pada tahap pencarian kreatif, tetapi pada saat pembuatan komponen, ketika Anda sudah bermain cukup dan akhirnya memutuskan pada struktur). </li><li>  Gaya teks, efek, warna bernama - apa yang terstruktur oleh "Gambar" atau digunakan dalam preprosesor sebagai variabel atau campuran. </li><li>  Lapisan-lapisan yang maknanya penting, tetapi tidak jelas dari konteksnya.  Misalnya, jika Anda ingin meletakkan huruf raksasa di latar belakang atau menggunakan "x" sebagai ikon (seperti diri Anda sendiri) - lebih baik beri nama layer ini secara bermakna, karena  itu adalah elemen markup khusus, bukan hanya teks huruf tunggal. </li><li>  Lapisan yang mengandung konten yang langsung digunakan untuk ekspor dan tata letak: gambar bitmap, SVG, dll. </li><li>  Bingkai yang harus dimasukkan dalam markup selama tata letak (pembungkus fleksibel, bagian logis tata letak, seperti bilah samping, samping, bagian, dll.). </li></ul><br>  <b>Tidak disebutkan secara umum:</b> <br><br><ul><li>  Kruk visual yang tidak termasuk dalam komponen dan diimplementasikan oleh gaya dan properti CSS tanpa tambahan.  tanda (semua jenis colokan erosi, mati). </li><li>  Lapisan teks yang bukan bagian dari komponen master. </li><li>  "Ikan" dan lapisan dekoratif yang tidak perlu diekspor.  Ketik stok foto dalam simulasi halaman konten. </li><li>  Semua jenis pembungkus dan artboards yang dibutuhkan hanya untuk pengaturan ruang yang nyaman atau demonstrasi beberapa catatan teknis. </li><li>  Lapisan bagian dalam grafik SVG, bentuk di jalur dan bingkai gabungan, bagian komponen ikon, dll.  Mereka tidak dianggap sebagai lapisan independen, oleh karena itu hanya objek induk yang dinamai.  (Jika Anda berencana untuk mengimplementasikan inline dan, misalnya, menghidupkan, maka lebih baik untuk menyiapkan grafik tersebut di artboards terpisah). </li><li>  Salinan komponen dalam set besar (seperti item dalam daftar) - mereka mewarisi nama umum dari komponen master, dan tidak masuk akal untuk membuatnya secara individual. </li></ul><br><h4>  "Aku tidak bisa, aku punya cakar" </h4><br>  Terkadang desainer terlalu malas untuk menyelidiki bagian teknis. <br><br>  Menurut pendapat pribadi saya, seorang desainer UX harus, jika tidak dapat melakukan tata letak, setidaknya memahami prinsip dan proses dasar.  BEM, antara lain, membantu Anda belajar cara berpikir dalam komponen, secara <i>sistemik</i> .  Jadi masuk akal untuk menghabiskan waktu belajar bahkan bukan demi beberapa lapisan, tetapi hanya untuk dapat membuat desain yang kuat secara teknologi yang mudah ditransfer dari proyek ke proyek dan “dijual kembali” berulang-ulang. <br><br>  Tetapi saya perhatikan bahwa saya sendiri adalah perancang yang agak biasa-biasa saja: bersarang persegi dan jauh dari seni.  Mungkin posisi saya karena kurangnya bakat.  Jadi jika Anda adalah pencipta hebat dan pencipta bebas yang jauh dari detail teknis, tetapi yang mentolerir Anda pada saat yang sama, mungkin Anda tidak membutuhkan semua ini.  Meskipun saya berani menyarankan bahwa bahkan dalam kasus ini, Anda masih memiliki beberapa tekno-tangan yang setia di tangan yang dengan sabar membawa ide-ide progresif Anda sejalan dengan setumpuk pembuat kode fana biasa.  Dalam hal ini, Anda bisa memberikan artikel ini kepadanya dan terus melambung di kerajaan. <br><br><h3>  Keripik dan plugin </h3><br>  Diasumsikan bahwa Anda terbiasa dengan " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Praktik terbaik: komponen, gaya, dan perpustakaan bersama</a> ".  Dan bahwa Anda sudah menjadi anak laki-laki / perempuan dewasa yang cukup untuk mencetak dan mengendarai dua sepeda banyak dari mereka. <br><br><h4>  Mengelompokkan komponen, gaya, dan efek </h4><br>  Bagaimanapun, kami selalu mengambil garis miring dari "Figma".  Slash adalah segalanya bagi kita: <br><br><blockquote>  Untuk mempermudah menemukan dan memilih gaya, Anda juga dapat mengatur gaya Anda menjadi grup dengan menamai mereka dengan konvensi penamaan garis miring.  Di menu Gaya, Anda akan melihat Gaya Lokal Anda dan Gaya apa pun yang dibagikan melalui Perpustakaan Tim.  Gaya akan dipesan sesuai abjad berdasarkan nama Tim, lalu Nama file.  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber</a> ) </blockquote><br><br>  Jadi, garis miring memisahkan "grup" dan "nama" yang sebenarnya. <br><br>  <i>[Pengecualiannya adalah Slash Hudson, yang membagi Gun's &amp; Roses menjadi sebuah grup dan namanya sendiri, tetapi kemudian berubah pikiran].</i> <br><br>  Misalnya, lapisan "tombol / hantu" dan "tombol / cta" mendeklarasikan grup bernama "tombol", dan "ponsel / paragraf" dan "ponsel / h1" menyatakan grup "ponsel".  Pada prinsipnya, jika Anda sangat pintar, sistem ini bisa disebut taksonomi, dan kelompok - taksa.  Maka Anda tidak akan membingungkan semua ini dengan pengelompokan lapisan yang biasa, yang dibuat sederhana dengan "Ctrl / Cmd + G". <br><br>  Grup yang dibuat dengan penamaan secara otomatis ditarik ke antarmuka, berubah menjadi daftar drop-down (untuk komponen) atau bagian di jendela-jendela pop-up (untuk gaya dan efek). <br><br><img src="https://habrastorage.org/webt/7c/ty/1f/7cty1ftl0hf2fjjlkz-jiyi2z_m.jpeg"><br><br><img src="https://habrastorage.org/webt/vq/av/bt/vqavbtahlbrdtzkzua1mam3ergm.jpeg"><br><br><h4>  Menamai plugin </h4><br>  Dengan munculnya plug-in, telah ada tren tertentu ketika nama layer juga digunakan sebagai data sampel untuk semua jenis filter. <br><br>  Contoh yang mencolok adalah plugin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Google Sheets Sync</a> , yang sangat kuat dalam penampilan, yang memungkinkan Anda untuk menarik data dari tabel Google yang terbuka ke berbagai lapisan komponen (!).  Yaitu, kami mengambil selusin instance dari komponen dengan selusin layer, beri nama segalanya sesuai dengan persyaratan plugin, dan itu menarik nilai-nilai dari tabel di dalamnya secara berurutan: teks, angka dan bahkan gambar.  Sintaksnya sederhana: kisi (oke, octotorp) + nama layer.  Saya belum pernah menggunakan plugin ini, tetapi terlihat sangat keren dan menjanjikan.  Segera memecahkan banyak masalah dengan pengisian kartu produk secara manual, profil pengguna dan "ikan" berulang lainnya.  Pada prinsipnya, dia tidak merusak sistem saya, karena  menambahkan kisi ke awal garis itu mudah. <br><br>  Ada beberapa plugin untuk bekerja dengan penamaan (ulang) layer: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ganti</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nama</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">transformasi nama Layer</a> , berbagai penomoran, dan lainnya. Saya tidak bisa menangani mereka di sini, dan saya belum menggunakan semuanya.  Tetapi sudah jelas bahwa dengan API terbuka kami akan segera mendapatkan banyak alat otomasi.  Saya akan mengatakan lebih banyak lagi, segala sesuatu yang telah saya ketahui tentang kisi-kisi dan sisanya, pada prinsipnya, dapat diwujudkan dalam bentuk plug-in tunggal yang akan menghasilkan bingkai dan gaya yang sesuai berdasarkan selusin pengaturan. <br>  Plugin muncul baru-baru ini, beberapa bulan dalam kekuatan, tetapi sudah ada banyak hal yang membuat hidup lebih mudah di kali.  Pada saat yang sama, API terbuka pasti akan mengarah pada munculnya aspek baru penamaan, dll. Oleh karena itu, saya sangat menyarankan Anda melihat bagian ini dari waktu ke waktu. <br><br><h3>  Halaman dan Bingkai </h3><br><h4>  Hirarki komponen </h4><br>  Nama-nama halaman dan bingkai, antara lain, termasuk dalam hierarki komponen.  Pada beberapa tangkapan layar yang diambil dari prototipe sistem desain saya (yang mungkin tidak akan pernah saya selesaikan, karena sebagai gantinya saya menulis artikel tanpa akhir ini sebagai gantinya), dapat dilihat bahwa komponen di sana disusun dalam halaman. <br><br><img src="https://habrastorage.org/webt/_l/ac/lh/_laclhbsjcs8bdagrdslj66znu4.jpeg"><br><br>  Tingkat pertama dari sarang dalam rantai ini diambil dari halaman, yang kedua dari bingkai root, yang ketiga dari nama komponen sebelum slash, dan yang keempat setelah slash.  Dengan demikian, hierarki lokal diperoleh di dalam satu file, bahkan tanpa menghubungkan perpustakaan eksternal.  Semua ini dapat diperhitungkan saat mengembangkan sistem penamaan. <br><br><h4>  Awalan Halaman </h4><br>  Seperti yang telah disebutkan, saya menggunakan tanda kurung siku sebagai label - di mana saya perlu menunjukkan bahwa ada sesuatu yang tidak berhubungan langsung dengan konteks utama dan ada beberapa poin teknis.  Ini juga berlaku untuk awalan halaman.  Mereka berbeda: [figma], [konsep], [komponen], [prototipe], dll. Masing-masing dari mereka memiliki arti bagi perancang tata letak. <br><br>  Misalnya, “[draft]” (draft), berarti bahwa halaman tersebut belum selesai - semuanya dapat berubah kapan saja, yang berarti bahwa isinya perlu diabaikan untuk saat ini.  "[Prototipe]" biasanya berisi banyak bingkai dengan tipe yang sama yang menunjukkan logika satu simpul (keranjang, akun pengguna, sistem pendaftaran, dll.) Menggunakan alat "Angka" bawaan untuk membuat prototipe. <br><br>  Dan "[Figma]" berarti bahwa halaman ini diperlukan semata-mata untuk kompatibilitas dengan beberapa bagian dari "Figma" itu sendiri.  Biasanya di tempat pertama saya memiliki "sampul" proyek - halaman yang disebut "[figma] sampul".  Dari sana, thumbnail file dalam daftar umum diambil + terkadang sesuatu sok dilakukan di sana untuk presentasi kepada klien. <br><br>  Nama tanpa awalan sesuai dengan halaman (atau templat) situs.  Untuk mendesain ulang, saya mengambilnya langsung dari struktur tautan sumber.  Jika strukturnya rumit atau kikuk, kadang-kadang saya menduplikasi seluruh rantai dalam nama, memisahkan level dengan sesuatu yang dimengerti dan jarang digunakan, seperti panah: <br><br><img src="https://habrastorage.org/webt/z4/gz/ml/z4gzml2mf1nwhzdpdpjtczh-yho.jpeg"><br><br><h4>  Bingkai root </h4><br>  Kisah yang sama dengan bingkai.  ada apa dengan komponennya.  Nama-nama menggunakan "blok" + "pengubah".  Misalnya, dalam tangkapan layar di atas "kereta", "gerobak", "gerobak", dll., Karena secara logis keranjang di tempat saya adalah blok, dan sisa layar adalah negara bagian yang dimodifikasi.  Bingkai viewport disebut tanpa halangan: ponsel, tablet, desktop, desktop + dan biasanya disimpan pada halaman yang sama.  Ada pengecualian, tetapi ini sudah terlalu mendalam. <br><br><h4>  Tipografi (gaya teks) </h4><br>  Sekali lagi, tebas.  Saya mengelompokkan dalam tiga set utama: <br><br><ul><li>  desktop - tipografi yang sesuai untuk konten desktop biasa; </li><li>  seluler - tebak; </li><li>  ui adalah gaya teks yang digunakan dalam elemen antarmuka tertentu dan tidak bergantung pada viewport (well, misalnya, angka stopwatch atau font input). </li></ul><br>  Dengan demikian, nama-nama tersebut terlihat seperti "desktop / paragraf", "ponsel / h2", "ui / timer", "ui / basefont", "ui / widget-heading_active", dll. <br><br><h3>  Pemilih Warna, Gaya Efek </h3><br><img src="https://habrastorage.org/webt/8_/yd/7v/8_yd7vzzgpdi44h7i8rrtd5p6iw.jpeg"><br><br>  Saya memiliki palet berikut: <br><br><ul><li>  tema - warna pembentuk gaya, gamma utama; </li><li>  netral - nuansa abu-abu bersyarat yang digunakan untuk teks, dadu, batas; </li><li>  fungsional - warna yang memiliki arti fungsional ("kesalahan", "sukses", keadaan tautan dan tombol); </li><li>  tambahan - satu set kemungkinan berbagai corak, lebih atau kurang dikombinasikan dengan gamut utama, yang digunakan dalam antarmuka untuk menandai status, indikator, menyoroti elemen daftar, spanduk, dll. </li><li>  gradien - kadang-kadang gradien dan latar belakang dialokasikan dalam kelompok yang terpisah, hanya agar tidak membingungkan mereka dengan isi yang biasa dan lebih mudah untuk menempatkannya dalam variabel CSS. </li></ul><br>  Penamaannya sama: group + slash + name + modifier.  Misalnya, "tema / primer", "tema / halaman-latar belakang", "func / link_visited", "func / warning_light". <br><br>  Efek dikelompokkan berdasarkan jenis.  Saya menggunakan tidak begitu banyak, sebagian besar, bayangan dua atau tiga jenis kedalaman "bayangan / _depth_deep" (pop-up), "bayangan / _depth_minimal" (bayangan kecil tombol, dll.), "Bayangan / _depth_mid" (sedang daftar drop-down, panel).  Pengubah inset ditambahkan untuk bayangan bagian dalam. <br><br>  Omong-omong, pengubah kedua selalu dipisahkan oleh tanda tambah ("blok / _mod1 + _mod2 + _mod3"), agar tidak bingung dengan konstruksi standar "_modifier_value".  Tetapi, secara umum, pornografi semacam itu sebaiknya dihindari.  Jika proyek memiliki banyak hal seperti itu, maka Anda dapat mengganti sekelompok pengubah dengan satu nama bermakna yang umum.  A "bayangan / _active-tombol". <br><br><h4>  Hal-hal yang Harus Dihindari Dengan Hati-hati </h4><br><ul><li>  Sangat disarankan untuk tidak mengikat nama (pengidentifikasi) warna ke nilai warna tertentu ("merah", "daging", "biru", dll.).  Nama harus mencerminkan fungsi atau ruang lingkup, bukan warna sebenarnya.  Nilai warna dapat berubah kapan saja: desain ulang, rebranding, manajer baru di klien.  Oleh karena itu, nama-nama seperti "tombol / merah" atau "bg / kuning" dalam kebanyakan kasus tidak roll. </li><li>  Tidak perlu menggunakan warna dari satu palet untuk yang lain.  Misalnya, jika Anda memiliki warna putih di merek dan putih yang sama di gamut netral, secara teknis itu harus dua warna berbeda (dua variabel).  Sekarang mereka cocok, ya.  Dan dalam setahun?  Dan dalam subjek yang gelap? </li><li>  Sebaiknya jangan biarkan warna merek cocok dengan warna fungsional.  Tidak perlu tautan "merek" - biarkan dengan warna biru dan biru klasik, sesuaikan hanya keteduhan.  Jika keseluruhan merek masih bertepatan dengan sesuatu (merek merah dan pesan kesalahan merah), disarankan untuk memaksimalkan nuansa mereka setidaknya dalam hal saturasi dan kecerahan. </li></ul><br><h3>  Konflik ketiga.  Gaya dan Efek yang Tidak Stabil </h3><br>  <i><b>Intinya.</b></i>  <i>Perancang menciptakan warna dan gradien dengan menerapkan efek atau mengubah transparansi.</i>  <i>Akibatnya, perancang tata letak menjadi bingung, dipaksa untuk memeriksa semuanya sendiri, mengambil warna dengan pipet, dll.</i> <br><br>  <b>Solusi</b>  Hanya nilai-nilai yang diserahkan ke perpustakaan "resmi" gaya dan efek jatuh ke dalam tata letak.  Jika ada lelucon dalam tata letak tanpa komentar yang jelas, Anda harus memberi tahu perancang.  Jika tidak ada reaksi, perancang tata letak menggunakan gaya terdekat dari yang standar.  Selain itu, tanggung jawab untuk ini terletak pada desainer.  Prinsip umumnya adalah ini: jika perancang tidak bekerja, maka ia menyerahkannya kepada perancang tata letak.  Dan perancang tata letak memiliki hak untuk menggunakan alat apa pun dari standar yang diterima. <br><br><h4>  Bagaimana sistem desain membantu di sini </h4><br>  Secara umum, ini terjadi pada semua orang, karena transparansi adalah cara yang paling nyaman untuk "mencairkan" warna atau gradien.  Dan karena Anda jarang berhasil mengambil bayangan pertama kali, Anda membuat sketsa opsi, dan kemudian Anda mundur beberapa langkah maju dan mundur - Anda kehilangan beberapa tempat, dan "konsekuensi dari percobaan" tetap ada. <br><br>  Tapi  Saat Anda tahu pasti bahwa hanya gaya yang diperbaiki yang akan masuk ke tata letak, Anda tanpa sadar menjadi lebih perhatian.  Jumlah variasi dalam nuansa dikurangi hingga memadai.  Ya, kekurangan bisa tetap di suatu tempat dalam salinan, pada beberapa artboards terpisah, tetapi gaya yang diekspor itu sendiri biasanya dibawa ke dalam bentuk yang dapat diterima.  Jika perlu, cek dapat dengan mudah dimasukkan dalam daftar periksa.  Kemudian, sebelum menempatkan tata letak ke dalam tata letak, perancang memeriksa seluruh daftar gaya dan memperbaiki kekasaran. <br><br>  Perancang tata letak, sekali lagi, bekerja dengan palet jadi.  Dia tidak peduli tentang anomali tertentu, kecuali mereka secara khusus disepakati (tetapi dalam kasus ini, probabilitas kesalahan minimal). <br><br><h4>  Gaya “Angka” adalah larva variabel untuk perakitan </h4><br>  Palet dan efek dapat digunakan sebagai variabel dalam perakitan.  Dalam hal ini, mereka ditransfer ke beberapa file konfigurasi yang sesuai dan ditarik ke gaya komponen dalam beberapa cara, tergantung pada struktur proyek.  Artinya, idealnya tidak ada warna / gradien / efek selain yang "standar" dalam aturan CSS.  Ternyata, kira-kira mirip dengan ini: <br><br><pre> <code class="css hljs">// <span class="hljs-selector-tag"><span class="hljs-selector-tag">named</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">colors</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-aqua</span></span> = <span class="hljs-selector-id"><span class="hljs-selector-id">#057f99</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-aqua-light</span></span> = <span class="hljs-selector-id"><span class="hljs-selector-id">#3ebca6</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-aqua-dark</span></span> = <span class="hljs-selector-id"><span class="hljs-selector-id">#006B81</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-violet</span></span> = <span class="hljs-selector-id"><span class="hljs-selector-id">#89288f</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-violet-deep</span></span> = <span class="hljs-selector-id"><span class="hljs-selector-id">#361946</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-white</span></span> = <span class="hljs-selector-id"><span class="hljs-selector-id">#fff</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-white-alt</span></span> = <span class="hljs-selector-id"><span class="hljs-selector-id">#f1f4f6</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-gray-lightest</span></span> = <span class="hljs-selector-id"><span class="hljs-selector-id">#e0f1f1</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-gray-light</span></span> = <span class="hljs-selector-id"><span class="hljs-selector-id">#dde9f0</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-indigo</span></span> = <span class="hljs-selector-id"><span class="hljs-selector-id">#5f2d7b</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-purple-pink</span></span> = <span class="hljs-selector-id"><span class="hljs-selector-id">#a93897</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-purple</span></span> = <span class="hljs-selector-id"><span class="hljs-selector-id">#89288f</span></span> // <span class="hljs-selector-tag"><span class="hljs-selector-tag">default</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">theme</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">palette</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-primary</span></span> = $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-aqua</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-primary_light</span></span> = $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-aqua-light</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-primary_dark</span></span> = $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-aqua-dark</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-secondary</span></span> = $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-violet</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-secondary_dark</span></span> = $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-violet-deep</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-bg-primary</span></span> = $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-white</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-bg-primary_interlaced</span></span> = $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-white-alt</span></span> // <span class="hljs-selector-tag"><span class="hljs-selector-tag">typography</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-basefont</span></span> = <span class="hljs-selector-id"><span class="hljs-selector-id">#1b262d</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-basefont_mid</span></span> = <span class="hljs-selector-id"><span class="hljs-selector-id">#465666</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-basefont_light</span></span> = <span class="hljs-selector-id"><span class="hljs-selector-id">#607080</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-basefont_pale</span></span> = <span class="hljs-selector-id"><span class="hljs-selector-id">#b9c0c0</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-basefont_invert</span></span> = <span class="hljs-selector-id"><span class="hljs-selector-id">#f1f4f6</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-link</span></span> = <span class="hljs-selector-id"><span class="hljs-selector-id">#1383B4</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-headings</span></span> = $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-violet-deep</span></span> // <span class="hljs-selector-tag"><span class="hljs-selector-tag">gradients</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">grad-primary</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">linear-gradient</span></span>( <span class="hljs-selector-tag"><span class="hljs-selector-tag">-45deg</span></span>, $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-primary-light</span></span> 0%, $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-primary</span></span> 50%, $<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-primary-dark</span></span> 100% ) // <span class="hljs-selector-tag"><span class="hljs-selector-tag">Transparent</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">gradient</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">is</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">used</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">as</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">an</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">overlay</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">grad-primary_overlay</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">linear-gradient</span></span>( <span class="hljs-selector-tag"><span class="hljs-selector-tag">-45deg</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">rgba</span></span>($<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-primary-light</span></span>,<span class="hljs-selector-class"><span class="hljs-selector-class">.5</span></span>) 0%, <span class="hljs-selector-tag"><span class="hljs-selector-tag">rgba</span></span>($<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-primary</span></span>,<span class="hljs-selector-class"><span class="hljs-selector-class">.5</span></span>) 50%, <span class="hljs-selector-tag"><span class="hljs-selector-tag">rgba</span></span>($<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-primary-dark</span></span>,<span class="hljs-selector-class"><span class="hljs-selector-class">.5</span></span>) 100% ) // <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadows</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">shadow-glow_mid</span></span> = 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">px</span></span> 8<span class="hljs-selector-tag"><span class="hljs-selector-tag">px</span></span> 16<span class="hljs-selector-tag"><span class="hljs-selector-tag">px</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rgba</span></span>($<span class="hljs-selector-tag"><span class="hljs-selector-tag">clr-primary-dark</span></span>, 0<span class="hljs-selector-class"><span class="hljs-selector-class">.3</span></span>) //...</code> </pre><br>  Seperti yang Anda lihat, sistem awalan sedikit berbeda, sehingga tidak memperpanjang lebih banyak penyeleksi, dll. Tetapi pengidentifikasi warna masih muncul, sehingga sistem disimpan. <br><br>  Poin lain: ada "warna bernama" yang mengambil nilai hex, dan kemudian ditugaskan ke warna "standar".  Ini dilakukan hanya untuk kejelasan, untuk "melihat" skema warna saat ini dari proyek / tema dalam konteks file.  Warna-warna tersebut, pada prinsipnya, dapat digunakan dengan aman di suatu tempat dan langsung untuk beberapa tujuan tertentu, karena  nilai hex mereka tidak pernah berubah.  Tetapi untuk alasan yang sama, lebih baik tidak memproduksinya. <br><br><h4>  Tentang ketidaksempurnaan dan perfeksionisme </h4><br>  Secara umum, palet saya masih disisir dengan buruk, karena alasan historis: Saya tidak segera datang ke sistem saat ini, ada banyak proyek transisi.  Jika seseorang tiba-tiba membaca ini dengan saksama, ia mungkin memperhatikan bahwa pada tangkapan layar ada perbedaan dalam nama dan kata-kata yang tidak cukup sesuai dengan teks.  Ce la vie.  Pada dasarnya, saya tidak menjilat, sehingga tidak ada yang akan memiliki ilusi yang tidak perlu.  Sistem desain tidak akan selalu sempurna.  Ini memecahkan banyak masalah, tetapi fakta bahwa Anda menggunakannya tidak berarti bahwa unicorn dan kupu-kupu berdebar di mock-up.  Masih ada warisan, tekanan waktu, faktor manusia dan banyak lagi.  Tapi coders dengan desainer, setidaknya, berhenti membuntuti apa-apa. <br><br>  Secara umum, menurut saya, jika semuanya sangat nyaman dalam pekerjaan, benar, sederhana dan logis, maka skrip harus melakukannya.  Seseorang itu baik karena ia dapat menangani pengecualian yang tidak terduga tanpa jatuh keluar dari layar biru.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Selain itu, bagian dari ketidakpedulian yang sehat menyelamatkan perfeksionis praktis dari menjadi patologis. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konflik keempat. </font><font style="vertical-align: inherit;">Ekspor Grafik</font></font></h2><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intinya. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perancang memberikan tata letak, tetapi perancang tata letak tidak dapat memilih bahan grafis yang diperlukan dari sana (ilustrasi bitmap, latar belakang, ikon). </font><font style="vertical-align: inherit;">Figma tidak memungkinkan Anda mengambil sumbernya, hanya ekspor olahan, yang terkadang tidak cukup. </font></font></i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solusi </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perancang membuka folder dengan sumber dan mengunggah gambar asli ukuran penuh (tanpa kompresi) ke direktori proyek pada server yang berfungsi (atau di cloud) tim. </font><font style="vertical-align: inherit;">Pengeset membuka ayah, menemukan bahan yang diperlukan dengan nama dan menghasilkan dari mereka semua yang dia butuhkan: variasi dimensi, sprite, dll. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya datang ke ini relatif baru-baru ini, ketika ternyata angka itu tidak memberikan sumber file jpeg / png, yang saya unggah di sana dari sekrup. </font><font style="vertical-align: inherit;">Terkadang dibutuhkan.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dari mana desainer mendapatkan "daddy with source" </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perancang mengambilnya dari tempat ia menyiapkan gambar. </font><font style="vertical-align: inherit;">Gambar raster dari editor raster. </font><font style="vertical-align: inherit;">Vektor stok - dari vektor stok. </font><font style="vertical-align: inherit;">Tidak masalah yang mana, ini adalah bisnis perancang. </font><font style="vertical-align: inherit;">Hal lain yang penting: file ukuran penuh seharusnya. </font><font style="vertical-align: inherit;">Bahkan jika sesuatu dilakukan dalam "Figma" yang sama menggunakan penyetelan gambar, Anda perlu mengekspor dari sana dan menyimpannya sebagai file. </font><font style="vertical-align: inherit;">Vektor juga, kalau-kalau - biarkan berbaring di awan. </font><font style="vertical-align: inherit;">Itu tidak sulit.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dan mengapa perancang itu tiba-tiba terlibat dalam ekspor? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena itu adalah kompetensinya, ia lebih kuat di dalamnya (kami akan membicarakan ini di bawah). </font><font style="vertical-align: inherit;">Pertama, ia memiliki akses ke sumbernya. </font><font style="vertical-align: inherit;">Kedua, ia tahu tata letaknya lebih baik dan memahami dari mana asalnya (versi, stok, lisensi hak cipta, dll.). </font><font style="vertical-align: inherit;">Ketiga, jika di suatu tempat ada sesuatu yang salah dipotong, dilapiskan, dikaburkan, diratakan - desainer tahu semua ini. </font><font style="vertical-align: inherit;">Bagian visual di atasnya.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dan mengapa perancang tata letak harus memampatkan gambar sendiri? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena itu adalah kompetensinya, ia lebih kuat di dalamnya. </font><font style="vertical-align: inherit;">Ya, sekarang ini lebih merupakan pertanyaan retoris, untuk simetri. </font><font style="vertical-align: inherit;">Siapa yang kita miliki di majelis, Ale. </font><font style="vertical-align: inherit;">Siapa, jika bukan perancang tata letak, yang mengetahui persyaratan semua platform dan dapat mengotomatisasi semua yang ada di dunia dengan "Gulp" -nya yang perkasa? </font><font style="vertical-align: inherit;">Tentu saja, ini adalah pertanyaannya. </font><font style="vertical-align: inherit;">Perancang tidak perlu pergi ke sana tanpa perlu.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cara menyederhanakan hidup Anda sedikit dan di sini </font></font></h3><br><ul><li>      ,     . </li><li>  .        ,     ,        assets   - .       .. </li><li> []      —   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">semver</a>     .  ,   —  ,   —  ,      —  .            ..      . </li></ul><br><h2>  . «»:   ,   </h2><br> <i><b>.</b>             . «»       («»).    ,  -              . <br></i> <br><br> <b>.</b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isolasi komponen master (letakkan di halaman terpisah yang dilupakan dan dilupakan oleh Tuhan dan kunci dengan "kunci"), dan siapkan "salinan referensi" alih-alih untuk perancang tata letak - salinan diperiksa oleh cheklists yang dapat dengan mudah dibedah. Baik, "seperti biasa": berikan tautan sehingga perancang tata letak menyalin file ke drafnya sendiri menggunakan tombol "Duplikat ke konsep", yang gratis dan menghilangkan pertanyaan tentang menambahkan "editor". Seorang desainer yang pemalu, dengan prinsip yang sama, diam-diam bekerja di file lokalnya, dan ketika siap, membuang perubahan ke file publik. Pemilik tim pro-akun "Figma" (sejauh yang saya dengar tentang oligarki ini :) memiliki kesempatan untuk menggunakan perpustakaan komponen untuk semua proyek dan mengkonfigurasi akses ke masing-masing proyek, sehingga masalahnya dihapus di sana.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara alami, semua pendekatan ini bukan tanpa kelemahan, tetapi jika Anda menggunakan sistem kisi dan yang lain yang dijelaskan di atas, maka pekerjaan perancang tata letak di "Figma" menjadi lebih mudah. Dan terlepas dari semua pembicaraan tentang waktu berlalu dan keluhan tentang waktu dan bea cukai, membuat tata letak yang disusun pada komponen menggunakan sistem desain, dalam hal apa pun, lebih nyaman daripada 99% dari kekacauan yang terjadi sebelumnya di .psd-shahs.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ya, omong-omong, ada momen lain untuk desainer tata letak yang bermigrasi dari Photoshop yang belum mencoba Figma dan mengalami masalah dengan produktivitas tenaga kerja. </font><font style="vertical-align: inherit;">Saya sungguh-sungguh merekomendasikan: mempelajari hot key-nya, terutama yang dirancang untuk bernavigasi melalui lapisan dan komponen. </font><font style="vertical-align: inherit;">Ini bukan kemauan dalam kasus ini. </font><font style="vertical-align: inherit;">Saya ingat betul bahwa pada hari-hari pertama untuk mengenal Figma, sangat menjengkelkan bahwa saya perlu "mendorong jauh ke dalam" komponen-komponen untuk menyoroti lapisan tertanam tertentu. </font><font style="vertical-align: inherit;">Dia memanjat tepat di dinding. </font><font style="vertical-align: inherit;">Tetapi kemudian, ketika saya terbiasa dengan "Ctrl / Cmd + Click", "Enter", "Shift + Enter" dan banyak lagi, semuanya menjadi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jauh lebih</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nyaman dan nyaman. </font><font style="vertical-align: inherit;">Di sini hotkey adalah mutlak harus dimiliki.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konflik adalah yang keenam. </font><font style="vertical-align: inherit;">Siapa yang harus melakukan ini atau itu?</font></font></h2><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intinya. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perancang berusaha menyalahkan pekerjaan pada tata letak, dengan harapan bahwa ia akan membersihkan ekor dan menghilangkan cacat. </font><font style="vertical-align: inherit;">Dan perancang tata letak memaksakan kebutuhan dan hidupnya dengan harapan bahwa perancang akan "melatih kembali" dan mulai hidup dan berpikir seperti seorang teknisi. </font></font></i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solusi </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Selain semua hal di atas). </font><font style="vertical-align: inherit;">Pisahkan tanggung jawab, tetapi kombinasikan kepentingan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada awalnya, segala sesuatu seringkali berlawanan: orang melintasi bidang tanggung jawab mereka, tetapi menyoroti kepentingan pribadi. </font><font style="vertical-align: inherit;">Yaitu, keduanya terus-menerus berusaha untuk masuk dalam proses satu sama lain dan tugas-tugas sepakbola bolak-balik, tetapi pada saat yang sama tidak bertanggung jawab atas proses-proses ini, karena "ini bukan pekerjaan saya." </font><font style="vertical-align: inherit;">Ini dapat diubah jika Anda mematuhi beberapa prinsip dan memahami bahwa:</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Persahabatan desainer dan desainer tata letak tidak bisa dihindari </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena pada akhirnya mereka sangat bergantung satu sama lain. Tidak masalah dari mana tugas "kontroversial" berasal. Adalah penting bahwa itu akan menutup </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keduanya</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan memperlambat proses keduanya. Dan semakin cepat ditutup, semakin baik untuk </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keduanya</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Perancang dan perancang tata letak selalu berada di tim yang sama, minat mereka adalah 80% jadi: syarat, perubahan, pendapatan (jika ada% dari transaksi), dan bahkan portofolio - semuanya saling tergantung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Satu-satunya hal yang dapat mencegah orang-orang ini untuk bekerja bersama (di samping jambs organisasi kepemimpinan) adalah kesalahpahaman atau pemahaman yang terpisah-pisah tentang spesifik pekerjaan masing-masing.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penting bahwa jika perancang tata letak memiliki pengalaman desain terapan yang kurang lebih terlihat, dan perancang memiliki pengaturan huruf, maka hampir tidak ada konflik di antara mereka. </font><font style="vertical-align: inherit;">Mereka lebih memahami peluang dan masalah masing-masing, oleh karena itu mereka mencari solusi yang optimal, dan tidak memerlukan kondisi yang tidak mungkin.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tugas ini dilakukan bukan oleh orang yang "harus" atau "disalahkan", tetapi oleh orang yang </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lebih nyaman</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lebih mudah</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk mencapai hasil yang diinginkan.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda perlu memutar kembali struktur dokumen, memindahkan bolak-balik, menukar, dll. </font><font style="vertical-align: inherit;">- Ini dilakukan oleh desainer di editornya, karena lebih mudah daripada membalikkan tata letak. </font><font style="vertical-align: inherit;">Jika Anda perlu perdukunan dengan nilai numerik, kompres paket besar jpeg, atau, katakanlah, bereksperimen dengan waktu animasi, ini dilakukan oleh penyetel, karena menggunakan CSS / JS lebih mudah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah klasik yang dibuat-buat dari seri "siapa yang harus mengekspor ikon" dari spesialis penuh berubah menjadi "Jadi, izinkan saya mengekspor semuanya dengan cepat sekarang, dan Anda telah menyelesaikan omong kosong itu sehingga kami dapat melewati semuanya pada akhir pekan". </font><font style="vertical-align: inherit;">Ini adalah tata letak yang khas. </font><font style="vertical-align: inherit;">Saya sudah lupa terakhir kali saya mengutuk dengan desainer tata letak, meskipun saya berteriak secara teratur pada pelanggan (lelucon dengan sebagian kecil dari lelucon :)</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kompetensi proaktif </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak ada yang suka ketika seseorang mengintervensi urusannya. </font><font style="vertical-align: inherit;">Itu sendiri adalah motivasi yang hebat. </font><font style="vertical-align: inherit;">Jika Anda tidak ingin perancang tata letak untuk "merusak" desain cerdik Anda, buat sedemikian rupa sehingga ia harus berinteraksi dengannya sesedikit mungkin. </font><font style="vertical-align: inherit;">Dan sebaliknya, jika Anda benar-benar seorang penata huruf run-up, jangan membodohi desainer dengan masalah Anda - Anda akan membuat permen dari setiap gambut lebih cepat daripada diz akan memahami apa yang Anda inginkan darinya) Jadi apa alasan konflik?</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bagaimana cara kerja logika ini? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh No. 1 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misalkan "Figma" adalah alat saya. Saya memutuskan untuk melakukan proyek di dalamnya. Jika pembuat kode tidak tetap bersamanya, maka dia memiliki hak untuk bertanya kepada saya bagaimana cara keluar dari situasi tersebut. Dan justru aku yang harus menemukan solusi untuknya. Jika perlu, membolak-balik manual yang sesuai, googling dan bahkan pengujian. Kenapa begitu Ya, karena ini adalah "keuskupan" saya. Diasumsikan bahwa kita berdua, dialah rajanya Allah. Dan itu berarti tanggung jawab untuk sisi komunikasi ini ada pada saya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan sisi lain dari koin: perancang tata letak seharusnya tidak peduli bagaimana saya menggambar tata letak: di Figma, di Chandelier, di Paint atau kotoran di dinding. Ini adalah proses kreatif saya. Tetapi pada saat yang sama, saya harus memastikan kepatuhan antara proses saya dan beberapa standar universal yang sesuai untuk itu.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lingkungan terbagi, kepentingan umum - tidak ada konflik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh No. 2 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kisah nyata. </font><font style="vertical-align: inherit;">Suatu kali saya memutuskan untuk menjadi perintis teladan dan pergi ke satu juru ketik yang baik dengan sebuah pertanyaan: bagaimana saya bisa mengatur tata letak yang lebih baik untuknya. </font><font style="vertical-align: inherit;">Seperti, apa yang kamu butuhkan, lebih tua. </font><font style="vertical-align: inherit;">Tanyakan apa yang Anda inginkan. </font><font style="vertical-align: inherit;">Saya mengutip jawabannya kata demi kata (maaf): “Ya, sial. </font><font style="vertical-align: inherit;">Setidaknya saya mengarang dari paengashka. </font><font style="vertical-align: inherit;">Anda, yang paling penting, menggambar. " </font><font style="vertical-align: inherit;">Dan kemudian saya mengagumi kebijaksanaan dari penatua suci dan pergi, tercerahkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lingkungan terbagi, kepentingan umum - tidak ada konflik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya pikir contoh-contoh itu akan menjelaskan mengapa saya biasa mendengar keluhan perancang tata letak bahwa perancang mereka di suatu tempat di sana tidak mengukur beberapa piksel dengan mikrometer. </font><font style="vertical-align: inherit;">Atau sebaliknya: omelan para desainer bahwa meja kerja jahat membuat mereka mengubah nama "Rectangle 1" menjadi "Button".</font></font><br><br><h2>  Total </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Prinsip-prinsip sistem desain untuk menyelesaikan konflik: </font></font><br><br><ul><li>  «»    . </li><li>   . </li><li>    . </li><li>   . </li><li>  - ( ). </li><li>  . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Ya, saya menggulungnya ke beberapa puluh layar. Tapi tidak berhasil sebaliknya). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terima kasih kepada semua orang yang menguasai setidaknya satu bagian. </font><font style="vertical-align: inherit;">Saya harap Anda dapat memperoleh beberapa manfaat dari ini untuk diri Anda sendiri. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya tidak punya apa-apa untuk diiklankan, tetapi jika Anda benar-benar ingin mengikuti tautan dalam uraian, maka, pergi, misalnya, kepada orang-orang ini: </font></font><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kamushken</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - artikel tentang sistem desain dan "Figmu"; </font></font><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mkoloskov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - artikel tentang BEM; </font></font><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vasyay</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - artikel tentang manajemen studio. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS Jika artikel itu bermanfaat bagi Anda, jangan ragu untuk mengatakannya di komentar - mereka akan membantu untuk memahami jika ada akal dalam menulis Talmuds seperti itu untuk Habr. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semoga beruntung</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464115/">https://habr.com/ru/post/id464115/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464105/index.html">Server Commento Asli dengan Docker Compose</a></li>
<li><a href="../id464107/index.html">Acara digital di Moskow dari 19 hingga 25 Agustus</a></li>
<li><a href="../id464109/index.html">Ruang Parasut Supersonik</a></li>
<li><a href="../id464111/index.html">Natas Web. Passage dari platform KKP bertujuan untuk mengeksploitasi kerentanan Web</a></li>
<li><a href="../id464113/index.html">"CAD untuk semua orang, gratis, dan jangan biarkan siapa pun pergi ..." atau langkah pertama dalam pemrograman FreeCAD dengan Python</a></li>
<li><a href="../id464117/index.html">Mengunjungi Vladimir Likhachev, ayah Nikolai Likhachev, lebih dikenal sebagai Chris Kaspersky</a></li>
<li><a href="../id464119/index.html">Frontend Weekly Digest (12 - 18 Agustus 2019)</a></li>
<li><a href="../id464121/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 376 (12 - 18 Agustus 2019)</a></li>
<li><a href="../id464125/index.html">Kisah internet rahasia dalam kebijakan privasi Google 4.000 kata</a></li>
<li><a href="../id464127/index.html">Pengembangan favicon animasi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>