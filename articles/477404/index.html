<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÇüèº üéõÔ∏è üë®üèº‚Äçüíª El problema de crear y eliminar objetos con frecuencia en C ++ ‚úãüèΩ üíº üë®üèø‚Äçüé§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La empresa para la que trabajo escribe su propio sistema de filtrado de tr√°fico y protege a la empresa con ataques DDoS, bots, analizadores y mucho m√°...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>El problema de crear y eliminar objetos con frecuencia en C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477404/"><img src="https://habrastorage.org/webt/fb/bt/53/fbbt53apqltc7isyigy39vkizmk.jpeg" alt="imagen"><br><br>  La empresa para la que trabajo escribe su propio sistema de filtrado de tr√°fico y protege a la empresa con ataques DDoS, bots, analizadores y mucho m√°s.  El producto se basa en un proceso como <a href="https://en.wikipedia.org/wiki/Reverse_proxy" rel="nofollow">el proxy inverso</a> , con la ayuda del cual analizamos grandes vol√∫menes de tr√°fico en tiempo real y, al final, solo permitimos solicitudes leg√≠timas de los usuarios, filtrando todos los maliciosos. <br><br>  La caracter√≠stica principal es que nuestros servicios funcionan con tr√°fico entrante ilimitado, por lo que es muy importante utilizar todos los recursos de las estaciones de trabajo de la manera m√°s eficiente posible.  Una gran experiencia de desarrollo en C ++ moderno nos ayuda con esto, incluidos los √∫ltimos est√°ndares y un conjunto de bibliotecas llamadas Boost. <br><a name="habracut"></a><br><h3>  Proxy inverso </h3><br>  Volvamos al proxy inverso y veamos c√≥mo puedes implementarlo en C ++ y boost.asio.  En primer lugar, necesitamos dos objetos llamados sesiones de servidor y cliente.  La sesi√≥n del servidor establece y mantiene una conexi√≥n con el navegador; la sesi√≥n del cliente establece y mantiene una conexi√≥n con el servicio.  Tambi√©n necesitar√° un b√∫fer de flujo que encapsule el trabajo con memoria interna, en el que la sesi√≥n del servidor lee desde el socket y desde el cual la sesi√≥n del cliente escribe en el socket.  Se pueden encontrar ejemplos de sesiones de servidor y cliente en la documentaci√≥n de boost.asio.  Aqu√≠ se puede encontrar c√≥mo trabajar con el b√∫fer de flujo. <br><br>  Despu√©s de recopilar el prototipo de proxy inverso de los ejemplos, quedar√° claro que tal aplicaci√≥n probablemente no servir√° tr√°fico entrante ilimitado.  Entonces comenzaremos a aumentar la complejidad del c√≥digo.  Pensemos en subprocesos m√∫ltiples, wokers y pools para contextos io, y mucho m√°s.  En particular, sobre optimizaciones prematuras relacionadas con la copia de memoria entre el servidor y las sesiones del cliente. <br><br>  ¬øDe qu√© tipo de copia de memoria estamos hablando?  El hecho es que cuando se filtra, el tr√°fico no siempre se transmite sin cambios.  Mire el ejemplo a continuaci√≥n: en √©l eliminamos un encabezado y agregamos dos en su lugar.  El n√∫mero de consultas de usuarios sobre las cuales se realizan acciones similares aumenta con la complejidad de la l√≥gica dentro del servicio.  ¬°En ning√∫n caso puede copiar datos sin pensar en tales casos!  Si solo cambia el 1% del total de la solicitud y el 99% permanece sin cambios, entonces debe asignar nueva memoria solo para este 1%.  Le ayudar√° con este boost :: asio :: const_buffer y boost :: asio :: mutable_buffer, con la ayuda de los cuales puede representar varios bloques continuos de memoria con una entidad. <br><br>  Solicitud del usuario: <br><br><pre><code class="plaintext hljs">Browser -&gt; Proxy: &gt; POST / HTTP/1.1 &gt; User-Agent: curl/7.29.0 &gt; Host: 127.0.0.1:50080 &gt; Accept: */* &gt; Content-Length: 5888903 &gt; Content-Type: application/x-www-form-urlencoded &gt; ... Proxy -&gt; Service: &gt; POST / HTTP/1.1 &gt; User-Agent: curl/7.29.0 &gt; Host: 127.0.0.1:50080 &gt; Accept: */* &gt; Transfer-Encoding: chunked &gt; Content-Type: application/x-www-form-urlencoded &gt; Expect: 100-continue &gt; ... Service -&gt; Proxy: &lt; HTTP/1.1 200 OK Proxy -&gt; Browser &lt; HTTP/1.1 200 OK</code> </pre> <br><h3>  El problema </h3><br>  Como resultado, obtuvimos una aplicaci√≥n lista para usar que puede escalar bien y est√° dotada de todo tipo de optimizaciones.  Al lanzarlo en producci√≥n, estuvimos muy contentos por el tiempo que funcion√≥ bien y de manera estable. <br><br>  Con el tiempo, comenzamos a tener m√°s y m√°s clientes, con el advenimiento de que el tr√°fico tambi√©n ha crecido.  En alg√∫n momento, nos enfrentamos con el problema de la falta de rendimiento al rechazar grandes ataques.  Despu√©s de analizar el servicio utilizando la utilidad <a href="https://perf.wiki.kernel.org/index.php/Tutorial" rel="nofollow">perf</a> , notamos que todas las operaciones con el mont√≥n bajo carga est√°n en la parte superior.  Luego, recreamos una situaci√≥n similar en el circuito de prueba utilizando <a href="https://github.com/yandex/yandex-tank" rel="nofollow">yandex-tank</a> y cartuchos generados en funci√≥n del tr√°fico real.  Conectando un servicio a trav√©s de un <a href="https://software.intel.com/en-us/vtune" rel="nofollow">amplificador,</a> vimos la siguiente imagen ... <br><br>  Captura de pantalla del amplificador (woslab): <br><br><img src="https://habrastorage.org/webt/tz/ks/d9/tzksd9oddf-rhcfphtkxkun-pdg.png"><br><br>  En la captura de pantalla, el operador nuevo trabaj√≥ 67 segundos y el operador elimin√≥ a√∫n m√°s: 97 segundos. <br><br>  Esta situaci√≥n nos molest√≥.  ¬øC√≥mo reducir el tiempo de permanencia de la aplicaci√≥n en operador nuevo y eliminar operador?  Es l√≥gico que esto se pueda hacer abandonando las asignaciones constantes de objetos frecuentemente creados y eliminados en el mont√≥n.  Nos decidimos por tres enfoques.  Dos de ellos son est√°ndar: <a href="https://en.wikipedia.org/wiki/Object_pool_pattern" rel="nofollow">grupo de objetos</a> y <a href="https://en.wikipedia.org/wiki/Stack-based_memory_allocation" rel="nofollow">asignaci√≥n de pila</a> .  Las sesiones de cliente que se organizan en un grupo en la etapa de inicio de la aplicaci√≥n est√°n bien ubicadas en el primer enfoque.  El segundo enfoque se usa en todas partes donde se procesa una solicitud de usuario de principio a fin en la misma pila, en otras palabras, en el mismo controlador de contexto io.  No nos detendremos en esto con m√°s detalle.  Ser√° mejor que hablemos del tercer enfoque, como el m√°s complejo e interesante.  Se llama <a href="https://en.wikipedia.org/wiki/Slab_allocation" rel="nofollow">asignaci√≥n de</a> losas o distribuci√≥n de losas. <br><br>  La idea de la distribuci√≥n de losas no es nueva.  Fue inventado e implementado en Solaris, luego migr√≥ al kernel de Linux, y consiste en el hecho de que los objetos del mismo tipo que se usan con frecuencia son m√°s f√°ciles de almacenar en el grupo.  Simplemente tomamos el objeto del grupo cuando lo necesitamos, y al finalizar el trabajo lo devolvemos.  ¬°No hay llamadas al operador nuevo y operador eliminado!  Adem√°s, un m√≠nimo de inicializaci√≥n.  En el n√∫cleo de losa, la distribuci√≥n se utiliza para sem√°foros, descriptores de archivos, procesos y subprocesos.  En nuestro caso, cay√≥ perfectamente en las sesiones de servidor y cliente, as√≠ como en todo lo que est√° dentro de ellas. <br><br>  Gr√°fico (distribuci√≥n de losas): <br><br><img src="https://habrastorage.org/webt/zb/k2/u8/zbk2u8m0jexhso3nmkttzxkvrw0.png"><br><br>  Adem√°s del hecho de que los asignadores de losas est√°n en el n√∫cleo, sus implementaciones tambi√©n existen en el espacio del usuario.  Hay pocos de ellos, y los que se est√°n desarrollando activamente son generalmente pocos.  Nos instalamos en una biblioteca llamada <a href="https://github.com/tarantool/small" rel="nofollow">libsmall</a> , que es parte de <a href="https://github.com/tarantool/tarantool" rel="nofollow">tarantool</a> .  Tiene todo lo que necesitas. <br><br><ul><li>  peque√±o :: asignador </li><li>  small :: slab_cache (hilo local) </li><li>  peque√±o :: losa </li><li>  peque√±o :: arena </li><li>  peque√±o :: cuota </li></ul><br>  La estructura small :: slab es un grupo con un tipo espec√≠fico de objeto.  La estructura small :: slab_cache es un cach√© que contiene varias listas de grupos con un tipo espec√≠fico de objetos.  La estructura small :: allocator es un c√≥digo que selecciona el cach√© necesario, busca un grupo adecuado en √©l, en el que se distribuye el objeto solicitado.  Lo que hacen los objetos small :: arena y small :: quota quedar√° claro en los ejemplos a continuaci√≥n. <br><br><h3>  Envolver </h3><br>  La biblioteca libsmall est√° escrita en C, no en C ++, por lo que tuvimos que desarrollar varios contenedores para una integraci√≥n transparente en la biblioteca est√°ndar de C ++. <br><br><ul><li>  variti :: slab_allocator </li><li>  variti :: losa </li><li>  variti :: thread_local_slab </li><li>  variti :: slab_allocate_shared </li></ul><br>  La clase variti :: slab_allocator implementa los requisitos m√≠nimos establecidos por el est√°ndar al escribir su propio asignador.  Dentro de las clases variti :: slab, todo el trabajo con la biblioteca libsmall est√° encapsulado.  ¬øPor qu√© se necesita variti :: thread_local_slab?  El hecho es que las cach√©s de losas de distribuci√≥n son objetos locales de hilo.  Esto significa que cada hilo tiene su propio conjunto de cach√©s.  Esto se hace para reducir a cero el n√∫mero de operaciones bloqueadas al distribuir un nuevo objeto.  Por lo tanto, en la memoria de cada subproceso, colocamos nuestra instancia de la clase variti :: slab, y el acceso a esta se regula mediante el contenedor variti :: thread_local_slab.  Te contar√© sobre la funci√≥n de plantilla variti :: slab_allocate_shared m√°s adelante. <br><br>  Dentro de la clase variti :: slab_allocator, todo es bastante simple.  Tiene la capacidad de volver a vincular de un tipo a otro, por ejemplo, de vac√≠o a char.  Curiosamente, puede prestar atenci√≥n a la prevalencia de nullptr a la excepci√≥n std :: bad_alloc en el caso de que la memoria se agote de la losa de distribuci√≥n.  El resto es reenviar llamadas dentro del contenedor variti :: thread_local_slab. <br><br>  Fragmento (slab_allocator.hpp): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slab_allocator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> value_type = T; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> pointer = value_type*; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> const_pointer = <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value_type*; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> reference = value_type&amp;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> const_reference = <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value_type&amp;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rebind</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> other = slab_allocator&lt;U&gt;; }; slab_allocator() {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; slab_allocator(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> slab_allocator&lt;U&gt;&amp; other) {} <span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allocate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T*&gt;(thread_local_slab::allocate(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T) * n)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!p &amp;&amp; n) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bad_alloc(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deallocate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T* p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ thread_local_slab::deallocate(p, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T) * n); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slab_allocator</span></span></span><span class="hljs-class">&lt;void&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> value_type = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> pointer = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> const_pointer = <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rebind</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> slab_allocator&lt;U&gt; other; }; };</code> </pre> <br>  Veamos c√≥mo se implementa el constructor y destructor variti :: slab.  En el constructor, asignamos un total de no m√°s de 1 GiB de memoria para todos los objetos.  El tama√±o de cada grupo en nuestro caso no supera 1 MiB.  El objeto m√≠nimo que podemos distribuir es de 2 bytes (de hecho, libsmall lo aumentar√° al m√≠nimo requerido: 8 bytes).  Los objetos restantes disponibles a trav√©s de nuestra distribuci√≥n de losa ser√°n m√∫ltiplos de dos (establecidos por la constante 2.f).  Total, puede distribuir objetos de tama√±o 8, 16, 32, etc.  Si el objeto solicitado tiene un tama√±o de 24 bytes, se producir√° una sobrecarga de la memoria.  La distribuci√≥n le devolver√° este objeto, pero se colocar√° en un grupo que corresponde a un objeto de 32 bytes de tama√±o.  Los 8 bytes restantes estar√°n inactivos. <br><br>  Fragmento (slab.hpp): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">phys_to_virt_p</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(p) + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">phys_to_virt_n</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n - <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">virt_to_phys_p</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(p) - <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">virt_to_phys_n</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id); } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::<span class="hljs-function"><span class="hljs-function">id&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">phys_thread_id</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id*&gt;(p); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slab</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> noncopyable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: slab() { small::quota_init(&amp; quota_, <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>); small::slab_arena_create(&amp;arena_, &amp; quota_, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>, MAP_PRIVATE); small::slab_cache_create(&amp;cache_, &amp;arena_); small::allocator_create(&amp;allocator_, &amp;cache_, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>); } ~slab() { small::allocator_destroy(&amp;allocator_); small::slab_cache_destroy(&amp;cache_); small::slab_arena_destroy(&amp;arena_); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allocate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> phys_n = virt_to_phys_n(n); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> phys_p = small::<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(&amp;allocator_, phys_n); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!phys_p) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; phys_thread_id(phys_p) = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::this_thread::get_id(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> phys_to_virt_p(phys_p); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deallocate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> phys_p = virt_to_phys_p(<span class="hljs-keyword"><span class="hljs-keyword">const_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*&gt;(p)); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> phys_n = virt_to_phys_n(n); assert(phys_thread_id(phys_p) == <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::this_thread::get_id()); small::<span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(&amp;allocator_, phys_p, phys_n); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: small::quota quota_; small::slab_arena arena_; small::slab_cache cache_; small::allocator allocator_; };</code> </pre> <br>  Todas estas restricciones se aplican a una instancia particular de la clase variti :: slab.  Dado que cada subproceso tiene su propio (piense en el subproceso local), el l√≠mite total del proceso no ser√° de 1 GiB, sino que ser√° directamente proporcional al n√∫mero de subprocesos que utilizan la distribuci√≥n de losa. <br><br>  Gr√°fico (std :: thread :: id): <br><br><img src="https://habrastorage.org/webt/_8/65/jy/_865jyoyp0qqoz7-tgsgmjsc9b0.png"><br><br>  Por un lado, el uso de hilo local le permite acelerar el trabajo de distribuci√≥n de losas en una aplicaci√≥n multiproceso, por otro lado, impone restricciones serias en la arquitectura de la aplicaci√≥n asincr√≥nica.  Debe solicitar y devolver un objeto en la misma secuencia.  Hacer esto como parte de boost.asio a veces es muy problem√°tico.  Para rastrear situaciones obviamente err√≥neas, al comienzo de cada objeto colocamos el identificador de la secuencia en la que se llama el m√©todo de asignaci√≥n.  Este identificador se verifica en el m√©todo de desasignaci√≥n.  Los ayudantes phys_to_virt_p y virt_to_phys_p ayudan en esto. <br><br>  Fragmento (thread_local_slab.hpp): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_local_slab</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> noncopyable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finalize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allocate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deallocate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>; };</code> </pre> <br>  Fragmento (thread_local_slab.cpp): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">thread_local</span></span> slab* slab_; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> thread_local_slab::initialize() { slab_ = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> slab(slab_cfg_); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> thread_local_slab::finalize() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> slab_; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* thread_local_slab::<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> n) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> slab_-&gt;<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(n); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> thread_local_slab::<span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* p, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> n) { slab_-&gt;<span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(p, n); }</code> </pre> <br>  Cuando se pierde el control sobre la secuencia (cuando se transfiere un objeto entre diferentes contextos io), un puntero inteligente permite la liberaci√≥n correcta del objeto.  Todo lo que hace es distribuir el objeto, recordando su contexto io, y luego envolverlo en std :: shared_ptr con un divisor personalizado, que no devuelve inmediatamente el objeto a la distribuci√≥n, sino que lo hace en el contexto io guardado anteriormente.  Esto funciona bien cuando cada contexto io se ejecuta en un solo hilo.  De lo contrario, desafortunadamente, este enfoque no es aplicable. <br><br>  Fragmento (slab_helper.hpp): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Allocator, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;T&gt; slab_allocate_shared(Allocator allocator, Args... args) { T* p = allocator.allocate(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)p) T(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args)...); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;T&gt; ptr(p, [allocator](T* p) { p-&gt;~T(); allocator.deallocate(p); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptr; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Allocator, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;T&gt; slab_allocate_shared(Allocator allocator, boost::asio::io_service* io, Args... args) { T* p = allocator.allocate(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)p) T(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args)...); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;T&gt; ptr(p, [allocator, io](T* p) { io-&gt;post([allocator, p]() { p-&gt;~T(); allocator.deallocate(p); }); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptr; };</code> </pre> <br><h3>  Soluci√≥n </h3><br>  Despu√©s de completar el trabajo de ajuste de libsmall, primero movimos los asignadores de chun dentro del b√∫fer de flujo a losa.  Esto fue bastante f√°cil de hacer.  Habiendo recibido un resultado positivo, seguimos adelante y aplicamos los asignadores de losas primero al b√∫fer de flujo en s√≠, y luego a todos los objetos dentro de las sesiones de servidor y cliente. <br><br><ul><li>  variti :: trozo </li><li>  variti :: streambuf </li><li>  variti :: server_session </li><li>  variti :: sesi√≥n_cliente </li></ul><br>  Al mismo tiempo, era necesario resolver problemas adicionales, a saber: transferir objetos simples, objetos compuestos y colecciones a asignadores de losas.  Y si no hubo serias dificultades con las dos primeras clases de objetos (los objetos compuestos se reducen a simples), entonces al traducir colecciones nos encontramos con serias dificultades. <br><br><ul><li>  std :: list </li><li>  std :: deque </li><li>  std :: vector </li><li>  std :: string </li><li>  std :: mapa </li><li>  std :: unordered_map </li></ul><br>  Una de las principales limitaciones cuando se trabaja con la distribuci√≥n de losas es que el n√∫mero de objetos de diferentes tipos no debe ser demasiado grande (cuanto menor sea, mejor).  En este contexto, algunas colecciones pueden caer en el concepto de asignadores de losas, mientras que otras no. <br><br>  Para std :: list slab, los asignadores funcionan muy bien.  Esta colecci√≥n se implementa internamente utilizando una lista vinculada, cada elemento del cual tiene un tama√±o fijo.  Por lo tanto, con la adici√≥n de nuevos datos a la lista std :: en la distribuci√≥n de losa, no aparecen nuevos tipos de objetos.  ¬°La condici√≥n indicada arriba est√° satisfecha!  El std :: map est√° organizado de manera similar.  La √∫nica diferencia es que dentro no hay una lista vinculada, sino un √°rbol. <br><br>  En el caso de std :: deque, las cosas son m√°s complicadas.  Esta colecci√≥n se implementa a trav√©s de un bloque contiguo de memoria que contiene punteros a fragmentos.  Si bien los fragmentos son bastante precisos, std :: deque se comporta igual que std :: list, pero cuando finalizan, este mismo bloque de memoria se redistribuye.  Desde el punto de vista de los asignadores de losas, cada redistribuci√≥n de memoria es un objeto con un nuevo tipo.  El n√∫mero de objetos agregados a la colecci√≥n depende directamente del usuario y puede crecer sin control.  Esta situaci√≥n no es aceptable, por lo que limitamos preliminarmente el tama√±o de std :: deque donde era posible o preferimos std :: list. <br><br>  Si tomamos std :: vector y std :: string, entonces a√∫n son m√°s complicados.  La implementaci√≥n de estas colecciones es algo similar a std :: deque, excepto que su bloque de memoria continua crece significativamente m√°s r√°pido.  Reemplazamos std :: vector y std :: string con std :: deque, y en el peor de los casos con std :: list.  S√≠, perdimos en funcionalidad y en alg√∫n lugar incluso en rendimiento, pero esto afect√≥ la imagen final mucho menos que las optimizaciones para las cuales todo fue concebido. <br><br>  Hicimos exactamente lo mismo con std :: unordered_map, abandon√°ndolo a favor del variti :: flat_map auto-escrito implementado a trav√©s de std :: deque.  Al mismo tiempo, simplemente almacenamos en cach√© las claves de uso frecuente en variables separadas, por ejemplo, como se hace con los encabezados de solicitud http en nginx. <br><br><h3>  Conclusi√≥n </h3><br>  Una vez finalizada la transferencia completa de las sesiones de servidor y cliente a los asignadores de losas, redujimos el tiempo dedicado a trabajar con un grupo m√°s de una vez y media. <br><br>  Captura de pantalla del amplificador (coldslab): <br><br><img src="https://habrastorage.org/webt/ls/yx/l_/lsyxl_b6xngl5xap-t5erwn4now.png"><br><br>  En la captura de pantalla, el operador nuevo trabaj√≥ 32 segundos y el operador elimin√≥ - 24 segundos.  En este momento, se agregaron otras funciones para trabajar con el mont√≥n: smalloc - 21 segundos, mslab_alloc - 37 segundos, smfree - 8 segundos, mslab_free - 21 segundos.  Total, 143 segundos versus 161 segundos. <br><br>  Pero estas mediciones se realizaron inmediatamente despu√©s de comenzar el servicio sin inicializar los cach√©s en la distribuci√≥n de losas.  Despu√©s de disparos repetidos desde un tanque yandex, la imagen general mejor√≥. <br><br>  Captura de pantalla del amplificador (hotslab): <br><br><img src="https://habrastorage.org/webt/gc/zj/kt/gczjkt5r8yedhniu5afswdjqk2y.png"><br><br>  En la captura de pantalla, el operador nuevo trabaj√≥ 20 segundos, smalloc - 16 segundos, mslab_alloc - 27 segundos, el operador elimin√≥ - 16 segundos, smfree - 7 segundos, mslab_free - 17 segundos.  Total 103 segundos contra 161 segundos. <br><br>  Tabla de medidas: <br><br><pre> <code class="plaintext hljs"> woslab coldslab hotslab operator new 67s 32s 20s smalloc - 21s 16s mslab_alloc - 37s 27s operator delete 94s 24s 16s smfree - 8s 7s mslab_free - 21s 17s summary 161s 143s 103s</code> </pre><br>  En la vida real, el resultado deber√≠a ser a√∫n mejor, ya que los asignadores de losas resuelven no solo el problema de la asignaci√≥n y liberaci√≥n de memoria prolongada, sino que tambi√©n reducen la fragmentaci√≥n.  Sin losa, con el tiempo, la operaci√≥n del operador nuevo y la eliminaci√≥n del operador solo deber√≠an disminuir.  Con losa, siempre se mantendr√° al mismo nivel. <br><br>  Como podemos ver, los asignadores de losas resuelven con √©xito el problema de asignaci√≥n de memoria de los objetos de uso frecuente.  Preste atenci√≥n a ellos si el tema de la creaci√≥n y eliminaci√≥n frecuente de objetos es relevante para usted.  ¬°Pero no se olvide de las limitaciones que imponen a la arquitectura de su aplicaci√≥n!  No todos los objetos complejos se pueden colocar simplemente en la distribuci√≥n de losas.  ¬°A veces tienes que rendirte mucho!  Bueno, cuanto m√°s compleja sea la arquitectura de su aplicaci√≥n, m√°s a menudo tendr√° que encargarse de devolver el objeto a la cach√© correcta en t√©rminos de subprocesamiento m√∫ltiple.  Puede ser simple cuando calcul√≥ de inmediato la arquitectura de la aplicaci√≥n, teniendo en cuenta el uso de asignadores de losas, pero definitivamente causar√° dificultades cuando decida integrarlos en una etapa tard√≠a. <br><br><h3>  App </h3><br>  ¬°Mira el c√≥digo fuente <a href="https://github.com/sonntex/slab-allocator" rel="nofollow">aqu√≠</a> ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/477404/">https://habr.com/ru/post/477404/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../477390/index.html">Depuraci√≥n de retrasos en la red en Kubernetes</a></li>
<li><a href="../477392/index.html">Micr√≥fono abierto: backend. Invitamos oradores</a></li>
<li><a href="../477396/index.html">C√≥mo inscribirse en un curso y ... ir al final</a></li>
<li><a href="../477400/index.html">Sobre la profesi√≥n de gerente de producto: ¬øc√≥mo lograr el ideal?</a></li>
<li><a href="../477402/index.html">Implementaci√≥n de Keras Deep Learning Model como una aplicaci√≥n web de Python</a></li>
<li><a href="../477406/index.html">Soporte t√©cnico y soporte. Gran investigaci√≥n sobre el mercado laboral y los salarios. ¬øQu√© ha cambiado en 2 a√±os?</a></li>
<li><a href="../477408/index.html">Tutorial JavaFX: dise√±os avanzados</a></li>
<li><a href="../477414/index.html">Ingeniero de datos: la profesi√≥n m√°s sexy del siglo XXI</a></li>
<li><a href="../477416/index.html">¬øCu√°ndo es perjudicial para el hach√≠s?</a></li>
<li><a href="../477418/index.html">Refracci√≥n de tres lados en tres pasos.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>