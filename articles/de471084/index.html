<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤧 🍈 ↩️ Verfahrensmuster, die mit Kachelkarten verwendet werden können 🕵🏾 🤞🏿 🥁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die prozedurale Generierung wird verwendet, um die Variabilität von Spielen zu erhöhen. Bekannte Projekte sind Minecraft , Enter the Gungeon und Desce...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verfahrensmuster, die mit Kachelkarten verwendet werden können</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471084/">  Die prozedurale Generierung wird verwendet, um die Variabilität von Spielen zu erhöhen.  Bekannte Projekte sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Minecraft</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Enter the Gungeon</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Descenders</a> .  In diesem Beitrag werde ich einige der Algorithmen erläutern, die bei der Arbeit mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tilemap-</a> System, das in Unity 2017.2 als 2D-Funktion angezeigt wurde, und mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RuleTile verwendet werden können</a> . <br><br>  Mit der prozeduralen Erstellung von Karten wird jedes vorbeiziehende Spiel einzigartig.  Sie können verschiedene Eingabedaten wie die Zeit oder die aktuelle Stufe des Spielers verwenden, um den Inhalt auch nach der Zusammenstellung des Spiels dynamisch zu ändern. <br><br><h2>  Worum geht es in diesem Beitrag? </h2><br>  Wir werden uns einige der gebräuchlichsten Methoden zum Erstellen von prozeduralen Welten sowie einige von mir erstellte Variationen ansehen.  Hier ist ein Beispiel dafür, was Sie nach dem Lesen des Artikels erstellen können.  Drei Algorithmen arbeiten zusammen, um mithilfe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tilemap</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RuleTile</a> eine Karte zu erstellen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/349/44e/154/34944e154f324b508701b42877494500.gif"></div><br>  Beim Generieren einer Karte mit einem beliebigen Algorithmus erhalten wir ein <code>int</code> Array, das alle neuen Daten enthält.  Sie können diese Daten weiterhin ändern oder in eine Kachelzuordnung rendern. <br><a name="habracut"></a><br>  Bevor Sie weiterlesen, wäre es schön, Folgendes zu wissen: <br><br><ol><li>  Wir unterscheiden, was eine Kachel ist und was keine Binärwerte verwendet.  1 ist eine Kachel, 0 ist ihre Abwesenheit. </li><li>  Wir speichern alle Karten in einem zweidimensionalen Ganzzahl-Array, das am Ende jeder Funktion an den Benutzer zurückgegeben wird (mit Ausnahme derjenigen, in der das Rendern ausgeführt wird). </li><li>  Ich werde die Array-Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GetUpperBound ()</a> verwenden, um die Höhe und Breite jeder Karte zu ermitteln, damit die Funktion weniger Variablen empfängt und der Code sauberer ist. </li><li>  Ich verwende häufig <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mathf.FloorToInt ()</a> , da das Tilemap-Koordinatensystem unten links beginnt und Sie mit Mathf.FloorToInt () Zahlen auf eine Ganzzahl runden können. </li><li>  Der gesamte Code in diesem Beitrag ist in C # geschrieben. </li></ol><br><h2>  Array-Generierung </h2><br>  GenerateArray erstellt ein neues <code>int</code> Array mit der angegebenen Größe.  Wir können auch angeben, ob das Array gefüllt oder leer sein soll (1 oder 0).  Hier ist der Code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] GenerateArray(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> empty) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[width, height]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>); x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>); y++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (empty) { map[x, y] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { map[x, y] = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> map; }</code> </pre> <br><h2>  Karten-Rendering </h2><br>  Diese Funktion wird verwendet, um eine Karte auf einer Kachelkarte zu rendern.  Wir durchlaufen die Breite und Höhe der Karte und platzieren Kacheln nur, wenn das Array am getesteten Punkt den Wert 1 hat. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RenderMap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[,] map, Tilemap tilemap, TileBase tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Clear the map (ensures we dont overlap) tilemap.ClearAllTiles(); //Loop through the width of the map for (int x = 0; x &lt; map.GetUpperBound(0) ; x++) { //Loop through the height of the map for (int y = 0; y &lt; map.GetUpperBound(1); y++) { // 1 = tile, 0 = no tile if (map[x, y] == 1) { tilemap.SetTile(new Vector3Int(x, y, 0), tile); } } } }</span></span></code> </pre> <br><h2>  Kartenaktualisierung </h2><br>  Diese Funktion wird nur zum Aktualisieren der Karte und nicht zum erneuten Rendern verwendet.  Dank dessen können wir weniger Ressourcen verbrauchen, ohne jede Kachel und ihre Kacheldaten neu zu zeichnen. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateMap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[,] map, Tilemap tilemap</span></span></span><span class="hljs-function">) </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//Takes in our map and tilemap, setting null tiles where needed { for (int x = 0; x &lt; map.GetUpperBound(0); x++) { for (int y = 0; y &lt; map.GetUpperBound(1); y++) { //We are only going to update the map, rather than rendering again //This is because it uses less resources to update tiles to null //As opposed to re-drawing every single tile (and collision data) if (map[x, y] == 0) { tilemap.SetTile(new Vector3Int(x, y, 0), null); } } } }</span></span></span></span></code> </pre> <br><h2>  Noise Perlin </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Perlin-Rauschen</a> kann für verschiedene Zwecke verwendet werden.  Erstens können wir damit die oberste Ebene unserer Karte erstellen.  Holen Sie sich dazu einfach einen neuen Punkt mit der aktuellen Position x und dem Startwert. <br><br><h3>  Einfache Lösung </h3><br>  Diese Erzeugungsmethode verwendet die einfachste Form der Realisierung von Perlin-Rauschen bei der Erzeugung von Pegeln.  Wir können die Unity-Funktion für Perlin-Rauschen verwenden, damit wir den Code nicht selbst schreiben.  Wir werden auch nur Ganzzahlen für die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kachelzuordnung verwenden</a> , indem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wir die</a> Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mathf.FloorToInt ()</a> verwenden. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] PerlinNoise(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seed) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newPoint; <span class="hljs-comment"><span class="hljs-comment">//Used to reduced the position of the Perlin point float reduction = 0.5f; //Create the Perlin for (int x = 0; x &lt; map.GetUpperBound(0); x++) { newPoint = Mathf.FloorToInt((Mathf.PerlinNoise(x, seed) - reduction) * map.GetUpperBound(1)); //Make sure the noise starts near the halfway point of the height newPoint += (map.GetUpperBound(1) / 2); for (int y = newPoint; y &gt;= 0; y--) { map[x, y] = 1; } } return map; }</span></span></code> </pre> <br>  So sieht es nach dem Rendern auf einer Kachelkarte aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d18/ab8/4e1/d18ab84e1e13fa2f8480424cfecc3de5.gif"></div><br><h3>  Glätten </h3><br>  Sie können diese Funktion auch übernehmen und glätten.  Stellen Sie Intervalle für die Festlegung der Perlin-Höhen ein und führen Sie dann eine Glättung zwischen diesen Punkten durch.  Diese Funktion wird sich als etwas komplizierter herausstellen, da Sie für Intervalle Listen mit ganzzahligen Werten berücksichtigen müssen. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] PerlinNoiseSmooth(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seed, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> interval) { <span class="hljs-comment"><span class="hljs-comment">//Smooth the noise and store it in the int array if (interval &gt; 1) { int newPoint, points; //Used to reduced the position of the Perlin point float reduction = 0.5f; //Used in the smoothing process Vector2Int currentPos, lastPos; //The corresponding points of the smoothing. One list for x and one for y List&lt;int&gt; noiseX = new List&lt;int&gt;(); List&lt;int&gt; noiseY = new List&lt;int&gt;(); //Generate the noise for (int x = 0; x &lt; map.GetUpperBound(0); x += interval) { newPoint = Mathf.FloorToInt((Mathf.PerlinNoise(x, (seed * reduction))) * map.GetUpperBound(1)); noiseY.Add(newPoint); noiseX.Add(x); } points = noiseY.Count;</span></span></code> </pre> <br>  Im ersten Teil dieser Funktion prüfen wir zunächst, ob das Intervall größer als eins ist.  Wenn ja, dann erzeugen Sie Rauschen.  Die Erzeugung erfolgt in Intervallen, damit eine Glättung angewendet werden kann.  Der nächste Teil der Funktion besteht darin, Punkte zu glätten. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Start at 1 so we have a previous position already for (int i = 1; i &lt; points; i++) { //Get the current position currentPos = new Vector2Int(noiseX[i], noiseY[i]); //Also get the last position lastPos = new Vector2Int(noiseX[i - 1], noiseY[i - 1]); //Find the difference between the two Vector2 diff = currentPos - lastPos; //Set up what the height change value will be float heightChange = diff.y / interval; //Determine the current height float currHeight = lastPos.y; //Work our way through from the last x to the current x for (int x = lastPos.x; x &lt; currentPos.x; x++) { for (int y = Mathf.FloorToInt(currHeight); y &gt; 0; y--) { map[x, y] = 1; } currHeight += heightChange; } } }</span></span></code> </pre> <br>  Das Glätten wird wie folgt durchgeführt: <br><br><ol><li>  Wir bekommen die aktuelle und letzte Position </li><li>  Wir erhalten den Unterschied zwischen zwei Punkten. Die wichtigste Information, die wir benötigen, ist der Unterschied entlang der y-Achse </li><li>  Dann bestimmen wir, wie viel die Änderung vorgenommen werden muss, um zum Punkt zu gelangen. Dies erfolgt durch Teilen der Differenz in y durch die Intervallvariable. </li><li>  Als nächstes beginnen wir, Positionen zu setzen und gehen bis auf Null </li><li>  Wenn wir auf der y-Achse 0 erreichen, addieren Sie die Höhenänderung zur aktuellen Höhe und wiederholen Sie den Vorgang für die nächste x-Position </li><li>  Wenn wir mit jeder Position zwischen der letzten und der aktuellen Position fertig sind, gehen wir zum nächsten Punkt </li></ol><br>  Wenn das Intervall kleiner als eins ist, verwenden wir einfach die vorherige Funktion, die die ganze Arbeit für uns erledigt. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Defaults to a normal Perlin gen map = PerlinNoise(map, seed); } return map;</span></span></code> </pre> <br>  Werfen wir einen Blick auf das Rendering: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91d/e8f/112/91de8f112bb1aa4bbd139245a1c8c215.gif"></div><br><h2>  Zufälliger Spaziergang </h2><br><h3>  Random Walk Top </h3><br>  Dieser Algorithmus führt einen Münzwurf durch.  Wir können eines von zwei Ergebnissen erzielen.  Wenn das Ergebnis "Adler" ist, bewegen wir uns einen Block nach oben, wenn das Ergebnis "Schwänze" ist, bewegen wir den Block nach unten.  Dies schafft Höhen, indem es sich ständig nach oben oder unten bewegt.  Der einzige Nachteil eines solchen Algorithmus ist seine sehr auffällige Blockierung.  Werfen wir einen Blick darauf, wie es funktioniert. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] RandomWalkTop(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seed) { <span class="hljs-comment"><span class="hljs-comment">//Seed our random System.Random rand = new System.Random(seed.GetHashCode()); //Set our starting height int lastHeight = Random.Range(0, map.GetUpperBound(1)); //Cycle through our width for (int x = 0; x &lt; map.GetUpperBound(0); x++) { //Flip a coin int nextMove = rand.Next(2); //If heads, and we aren't near the bottom, minus some height if (nextMove == 0 &amp;&amp; lastHeight &gt; 2) { lastHeight--; } //If tails, and we aren't near the top, add some height else if (nextMove == 1 &amp;&amp; lastHeight &lt; map.GetUpperBound(1) - 2) { lastHeight++; } //Circle through from the lastheight to the bottom for (int y = lastHeight; y &gt;= 0; y--) { map[x, y] = 1; } } //Return the map return map; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57b/791/cd4/57b791cd49bb1c967e994638406371a8.gif"></div><br>  <i>Random Walk Top mit Anti-Aliasing</i> <br><br>  Eine solche Erzeugung führt zu gleichmäßigeren Höhen als die Perlin-Geräuschentwicklung. <br><br>  Diese Variante von Random Walk liefert im Vergleich zur vorherigen Version ein viel flüssigeres Ergebnis.  Wir können es implementieren, indem wir der Funktion zwei weitere Variablen hinzufügen: <br><br><ul><li>  Die erste Variable wird verwendet, um zu bestimmen, wie lange es dauert, die aktuelle Höhe beizubehalten.  Es ist eine Ganzzahl und wird zurückgesetzt, wenn sich die Höhe ändert </li><li>  Die zweite Variable wird in die Funktion eingegeben und als minimale Abschnittsbreite für die Höhe verwendet.  Es wird klarer, wenn wir uns die Funktion ansehen. </li></ul><br>  Jetzt wissen wir, was wir hinzufügen müssen.  Werfen wir einen Blick auf die Funktion: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] RandomWalkTopSmoothed(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seed, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minSectionWidth) { <span class="hljs-comment"><span class="hljs-comment">//Seed our random System.Random rand = new System.Random(seed.GetHashCode()); //Determine the start position int lastHeight = Random.Range(0, map.GetUpperBound(1)); //Used to determine which direction to go int nextMove = 0; //Used to keep track of the current sections width int sectionWidth = 0; //Work through the array width for (int x = 0; x &lt;= map.GetUpperBound(0); x++) { //Determine the next move nextMove = rand.Next(2); //Only change the height if we have used the current height more than the minimum required section width if (nextMove == 0 &amp;&amp; lastHeight &gt; 0 &amp;&amp; sectionWidth &gt; minSectionWidth) { lastHeight--; sectionWidth = 0; } else if (nextMove == 1 &amp;&amp; lastHeight &lt; map.GetUpperBound(1) &amp;&amp; sectionWidth &gt; minSectionWidth) { lastHeight++; sectionWidth = 0; } //Increment the section width sectionWidth++; //Work our way from the height down to 0 for (int y = lastHeight; y &gt;= 0; y--) { map[x, y] = 1; } } //Return the modified map return map; }</span></span></code> </pre> <br>  Wie Sie im unten gezeigten GIF sehen können, können Sie durch Glätten des Random-Walk-Algorithmus schöne flache Segmente auf der Ebene erhalten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c1/baf/b53/7c1bafb53bda68f46d617fa4ee2f5c11.gif"></div><br><h2>  Fazit </h2><br>  Ich hoffe, dieser Artikel inspiriert Sie dazu, die prozedurale Generierung in Ihren Projekten zu verwenden.  Wenn Sie mehr über prozedural generierte Karten erfahren möchten, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">besuchen Sie</a> die hervorragenden Ressourcen des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prozedurgenerierungs-</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikis</a> oder von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Roguebasin.com</a> . <br><br>  Im zweiten Teil des Artikels werden wir die prozedurale Generierung verwenden, um Höhlensysteme zu erstellen. <br><br><h2>  Teil 2 </h2><br>  Alles, was wir in diesem Teil diskutieren werden, finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Projekt</a> .  Sie können Assets herunterladen und Ihre eigenen Verfahrensalgorithmen ausprobieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/349/44e/154/34944e154f324b508701b42877494500.gif"></div><br><h1>  Noise Perlin </h1><br>  Im vorherigen Teil haben wir uns Möglichkeiten angesehen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Perlin-Rauschen</a> anzuwenden, um oberste Ebenen zu erstellen.  Glücklicherweise kann Perlins Lärm auch verwendet werden, um eine Höhle zu schaffen.  Dies wird durch Berechnung des neuen Perlin-Rauschwerts realisiert, der die Parameter der aktuellen Position multipliziert mit dem Modifikator empfängt.  Der Modifikator ist ein Wert von 0 bis 1. Je höher der Modifikatorwert, desto chaotischer ist die Perlin-Erzeugung.  Dann runden wir diesen Wert auf die Ganzzahl (0 oder 1), die wir im Map-Array speichern.  Sehen Sie, wie dies implementiert wird: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] PerlinNoiseCave(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> modifier, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> edgesAreWalls) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newPoint; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>); x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>); y++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edgesAreWalls &amp;&amp; (x == <span class="hljs-number"><span class="hljs-number">0</span></span> || y == <span class="hljs-number"><span class="hljs-number">0</span></span> || x == map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>) - <span class="hljs-number"><span class="hljs-number">1</span></span> || y == map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>) - <span class="hljs-number"><span class="hljs-number">1</span></span>)) { map[x, y] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//Keep the edges as walls } else { //Generate a new point using Perlin noise, then round it to a value of either 0 or 1 newPoint = Mathf.RoundToInt(Mathf.PerlinNoise(x * modifier, y * modifier)); map[x, y] = newPoint; } } } return map; }</span></span></code> </pre> <br>  Wir verwenden den Modifikator anstelle von Seed, da die Ergebnisse der Perlin-Generation besser aussehen, wenn sie mit einer Zahl von 0 bis 0,5 multipliziert werden.  Je niedriger der Wert, desto blockiger wird das Ergebnis.  Schauen Sie sich die Beispielergebnisse an.  Gif beginnt mit einem Modifikatorwert von 0,01 und erreicht schrittweise einen Wert von 0,25. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/760/abb/891/760abb891c7f225803aecc64c24af5ed.gif"></div><br>  Aus diesem GIF ist ersichtlich, dass die Perlin-Erzeugung mit jedem Inkrement einfach das Muster erhöht. <br><br><h1>  Zufälliger Spaziergang </h1><br>  Im vorherigen Teil haben wir gesehen, dass Sie mithilfe eines Münzwurfs bestimmen können, wo sich die Plattform nach oben oder unten bewegt.  In diesem Teil werden wir die gleiche Idee verwenden, aber <br>  mit zwei zusätzlichen Optionen für Links- und Rechtsverschiebung.  Diese Variation des Random Walk-Algorithmus ermöglicht es uns, Höhlen zu erstellen.  Dazu wählen wir eine zufällige Richtung, verschieben dann unsere Position und löschen die Kachel.  Wir setzen diesen Prozess fort, bis wir die erforderliche Anzahl von Kacheln erreicht haben, die zerstört werden müssen.  Bisher verwenden wir nur 4 Richtungen: oben, unten, links, rechts. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] RandomWalkCave(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seed, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> requiredFloorPercent) { <span class="hljs-comment"><span class="hljs-comment">//Seed our random System.Random rand = new System.Random(seed.GetHashCode()); //Define our start x position int floorX = rand.Next(1, map.GetUpperBound(0) - 1); //Define our start y position int floorY = rand.Next(1, map.GetUpperBound(1) - 1); //Determine our required floorAmount int reqFloorAmount = ((map.GetUpperBound(1) * map.GetUpperBound(0)) * requiredFloorPercent) / 100; //Used for our while loop, when this reaches our reqFloorAmount we will stop tunneling int floorCount = 0; //Set our start position to not be a tile (0 = no tile, 1 = tile) map[floorX, floorY] = 0; //Increase our floor count floorCount++;</span></span></code> </pre> <br>  Die Funktion beginnt mit: <br><br><ol><li>  Finde die Startposition </li><li>  Berechnen Sie die Anzahl der zu löschenden Bodenfliesen. </li><li>  Löschen Sie die Kachel in der Startposition </li><li>  Fügen Sie der Anzahl der Kacheln eine hinzu. </li></ol><br>  Dann fahren wir mit der <code>while</code> .  Er wird eine Höhle schaffen: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (floorCount &lt; reqFloorAmount) { <span class="hljs-comment"><span class="hljs-comment">//Determine our next direction int randDir = rand.Next(4); switch (randDir) { //Up case 0: //Ensure that the edges are still tiles if ((floorY + 1) &lt; map.GetUpperBound(1) - 1) { //Move the y up one floorY++; //Check if that piece is currently still a tile if (map[floorX, floorY] == 1) { //Change it to not a tile map[floorX, floorY] = 0; //Increase floor count floorCount++; } } break; //Down case 1: //Ensure that the edges are still tiles if ((floorY - 1) &gt; 1) { //Move the y down one floorY--; //Check if that piece is currently still a tile if (map[floorX, floorY] == 1) { //Change it to not a tile map[floorX, floorY] = 0; //Increase the floor count floorCount++; } } break; //Right case 2: //Ensure that the edges are still tiles if ((floorX + 1) &lt; map.GetUpperBound(0) - 1) { //Move the x to the right floorX++; //Check if that piece is currently still a tile if (map[floorX, floorY] == 1) { //Change it to not a tile map[floorX, floorY] = 0; //Increase the floor count floorCount++; } } break; //Left case 3: //Ensure that the edges are still tiles if ((floorX - 1) &gt; 1) { //Move the x to the left floorX--; //Check if that piece is currently still a tile if (map[floorX, floorY] == 1) { //Change it to not a tile map[floorX, floorY] = 0; //Increase the floor count floorCount++; } } break; } } //Return the updated map return map; }</span></span></code> </pre> <br><h3>  Was machen wir hier? </h3><br>  Zunächst wählen wir mit Hilfe einer Zufallszahl, in welche Richtung wir uns bewegen möchten.  Dann überprüfen wir die neue Richtung mit der <code>switch case</code> .  In dieser Aussage prüfen wir, ob es sich bei der Position um eine Wand handelt.  Wenn nicht, löschen Sie das Element mit der Kachel aus dem Array.  Wir machen so weiter, bis wir die gewünschte Grundfläche erreicht haben.  Das Ergebnis ist unten dargestellt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c6/fc1/86c/2c6fc186c67095e13c1dcbea4c95aff4.gif"></div><br>  Ich habe auch meine eigene Version dieser Funktion erstellt, die auch diagonale Richtungen enthält.  Der Funktionscode ist ziemlich lang. Wenn Sie ihn also ansehen möchten, laden Sie das Projekt über den Link am Anfang dieses Teils des Artikels herunter. <br><br><h1>  Richtungstunnel </h1><br>  Ein Richtungstunnel beginnt an einem Rand der Karte und erreicht den gegenüberliegenden Rand.  Wir können die Krümmung und Rauheit des Tunnels steuern, indem wir sie an die Eingabefunktion übergeben.  Wir können auch die minimale und maximale Länge der Teile des Tunnels einstellen.  Werfen wir einen Blick auf die Implementierung: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] DirectionalTunnel(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minPathWidth, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxPathWidth, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxPathChange, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> roughness, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> curvyness) { <span class="hljs-comment"><span class="hljs-comment">//This value goes from its minus counterpart to its positive value, in this case with a width value of 1, the width of the tunnel is 3 int tunnelWidth = 1; //Set the start X position to the center of the tunnel int x = map.GetUpperBound(0) / 2; //Set up our random with the seed System.Random rand = new System.Random(Time.time.GetHashCode()); //Create the first part of the tunnel for (int i = -tunnelWidth; i &lt;= tunnelWidth; i++) { map[x + i, 0] = 0; }</span></span></code> </pre> <br><h3>  Was ist los? </h3><br>  Zuerst setzen wir den Breitenwert.  Der Breitenwert wechselt vom Wert mit einem Minus zu einem Positiv.  Dank dessen erhalten wir die Größe, die wir benötigen.  In diesem Fall verwenden wir den Wert 1, was wiederum eine Gesamtbreite von 3 ergibt, da wir die Werte -1, 0, 1 verwenden. <br><br>  Als nächstes setzen wir die Anfangsposition in x, dafür nehmen wir die Mitte der Breite der Karte.  Danach können wir im ersten Teil der Karte einen Tunnel legen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/605/0a7/552/6050a75522b8d628722d5373ddee8c76.png"></div><br>  Kommen wir nun zum Rest der Karte. <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//Cycle through the array for (int y = 1; y &lt; map.GetUpperBound(1); y++) { //Check if we can change the roughness if (rand.Next(0, 100) &gt; roughness) { //Get the amount we will change for the width int widthChange = Random.Range(-maxPathWidth, maxPathWidth); //Add it to our tunnel width value tunnelWidth += widthChange; //Check to see we arent making the path too small if (tunnelWidth &lt; minPathWidth) { tunnelWidth = minPathWidth; } //Check that the path width isnt over our maximum if (tunnelWidth &gt; maxPathWidth) { tunnelWidth = maxPathWidth; } } //Check if we can change the curve if (rand.Next(0, 100) &gt; curvyness) { //Get the amount we will change for the x position int xChange = Random.Range(-maxPathChange, maxPathChange); //Add it to our x value x += xChange; //Check we arent too close to the left side of the map if (x &lt; maxPathWidth) { x = maxPathWidth; } //Check we arent too close to the right side of the map if (x &gt; (map.GetUpperBound(0) - maxPathWidth)) { x = map.GetUpperBound(0) - maxPathWidth; } } //Work through the width of the tunnel for (int i = -tunnelWidth; i &lt;= tunnelWidth; i++) { map[x + i, y] = 0; } } return map; }</span></span></code> </pre> <br>  Wir generieren eine Zufallszahl zum Vergleich mit dem Rauheitswert. Wenn dieser Wert höher als dieser Wert ist, kann die Pfadbreite geändert werden.  Wir überprüfen auch den Wert, um die Breite nicht zu klein zu machen.  Im nächsten Teil des Codes machen wir uns auf den Weg durch die Karte.  In jeder Phase tritt Folgendes auf: <br><br><ol><li>  Wir erzeugen eine neue Zufallszahl im Vergleich zum Krümmungswert.  Wie im vorherigen Test ändern wir den Mittelpunkt des Pfades, wenn er größer als der Wert ist.  Wir führen auch eine Überprüfung durch, um nicht über die Karte hinauszugehen. </li><li>  Schließlich legen wir einen Tunnel in den neu geschaffenen Teil. </li></ol><br>  Die Ergebnisse dieser Implementierung sehen folgendermaßen aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d25/bd4/d34/d25bd4d348871f08fcb383c3508ab25f.gif"></div><br><h1>  Zelluläre Automaten </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zelluläre Automaten</a> verwenden benachbarte Zellen, um zu bestimmen, ob die aktuelle Zelle eingeschaltet (1) oder ausgeschaltet (0) ist.  Die Basis zur Bestimmung benachbarter Zellen wird basierend auf einem zufällig erzeugten Gitter von Zellen erstellt.  Wir werden dieses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellraster mit der</a> Funktion C # <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Random.Next generieren</a> . <br><br>  Da wir einige verschiedene Implementierungen von zellularen Automaten haben, habe ich eine separate Funktion geschrieben, um dieses Grundraster zu generieren.  Die Funktion sieht folgendermaßen aus: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] GenerateCellularAutomata(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seed, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fillPercent, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> edgesAreWalls) { <span class="hljs-comment"><span class="hljs-comment">//Seed our random number generator System.Random rand = new System.Random(seed.GetHashCode()); //Initialise the map int[,] map = new int[width, height]; for (int x = 0; x &lt; map.GetUpperBound(0); x++) { for (int y = 0; y &lt; map.GetUpperBound(1); y++) { //If we have the edges set to be walls, ensure the cell is set to on (1) if (edgesAreWalls &amp;&amp; (x == 0 || x == map.GetUpperBound(0) - 1 || y == 0 || y == map.GetUpperBound(1) - 1)) { map[x, y] = 1; } else { //Randomly generate the grid map[x, y] = (rand.Next(0, 100) &lt; fillPercent) ? 1 : 0; } } } return map; }</span></span></code> </pre> <br>  In dieser Funktion können Sie auch festlegen, ob unser Gitter Wände benötigt.  Im Übrigen ist es ganz einfach.  Wir überprüfen eine Zufallszahl mit prozentualer Füllung, um festzustellen, ob die aktuelle Zelle aktiviert ist.  Schauen Sie sich das Ergebnis an: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/585/bfa/9ec/585bfa9ec7953056e160af10b4efbc88.gif"></div><br><h2>  Die Nachbarschaft von Moore </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Moore-Nachbarschaft wird</a> verwendet, um die anfängliche Erzeugung von zellularen Automaten zu glätten.  Die Nachbarschaft von Moore sieht so aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30b/c02/328/30bc02328e772a2955aa071bfdbc2cc6.png"></div><br>  Für die Nachbarschaft gelten folgende Regeln: <br><br><ul><li>  Wir überprüfen den Nachbarn in jede Richtung. </li><li>  Wenn der Nachbar eine aktive Kachel ist, addieren Sie eine zur Anzahl der umgebenden Kacheln. </li><li>  Wenn der Nachbar eine inaktive Kachel ist, tun wir nichts. </li><li>  Wenn eine Zelle mehr als 4 umgebende Kacheln hat, aktivieren Sie die Zelle. </li><li>  Wenn die Zelle genau 4 umgebende Kacheln hat, machen wir nichts damit. </li><li>  Wiederholen Sie diesen Vorgang, bis wir jede Kartenkachel überprüft haben. </li></ul><br>  Die Nachbarschaftsprüfungsfunktion von Moore lautet wie folgt: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMooreSurroundingTiles</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[,] map, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> edgesAreWalls</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* Moore Neighbourhood looks like this ('T' is our tile, 'N' is our neighbours) * * NNN * NTN * NNN * */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tileCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> neighbourX = x - <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbourX &lt;= x + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbourX++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> neighbourY = y - <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbourY &lt;= y + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbourY++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbourX &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; neighbourX &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; neighbourY &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; neighbourY &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">//We don't want to count the tile we are checking the surroundings of if(neighbourX != x || neighbourY != y) { tileCount += map[neighbourX, neighbourY]; } } } } return tileCount; }</span></span></code> </pre> <br>  Nach dem Überprüfen der Kachel verwenden wir diese Informationen in der Glättungsfunktion.  Hier kann wie bei der Erzeugung von zellularen Automaten angegeben werden, ob die Kanten der Karte Wände sein sollen. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] SmoothMooreCellularAutomata(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> edgesAreWalls, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> smoothCount) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; smoothCount; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>); x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>); y++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> surroundingTiles = GetMooreSurroundingTiles(map, x, y, edgesAreWalls); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edgesAreWalls &amp;&amp; (x == <span class="hljs-number"><span class="hljs-number">0</span></span> || x == (map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>) - <span class="hljs-number"><span class="hljs-number">1</span></span>) || y == <span class="hljs-number"><span class="hljs-number">0</span></span> || y == (map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>) - <span class="hljs-number"><span class="hljs-number">1</span></span>))) { <span class="hljs-comment"><span class="hljs-comment">//Set the edge to be a wall if we have edgesAreWalls to be true map[x, y] = 1; } //The default moore rule requires more than 4 neighbours else if (surroundingTiles &gt; 4) { map[x, y] = 1; } else if (surroundingTiles &lt; 4) { map[x, y] = 0; } } } } //Return the modified map return map; }</span></span></code> </pre> <br>  Hierbei ist zu beachten, dass die Funktion über eine <code>for</code> Schleife verfügt, die die angegebene Anzahl von Glättungen durchführt.  Dadurch wird eine schönere Karte erhalten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68f/082/25c/68f08225c0c31cb243969192744f7b16.gif"></div><br>  Wir können diesen Algorithmus jederzeit ändern, indem wir Räume verbinden, wenn sich beispielsweise nur zwei Blöcke zwischen ihnen befinden. <br><br><h2>  Von Neumann Nachbarschaft </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Viertel von Neumann</a> ist ein weiterer beliebter Weg, um zellulare Automaten zu implementieren.  Für eine solche Generation verwenden wir eine einfachere Nachbarschaft als für die Moore-Generation.  Die Nachbarschaft sieht so aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/952/d30/66c/952d3066c638932947db9c9a95ee36bf.png"></div><br>  Für die Nachbarschaft gelten folgende Regeln: <br><br><ul><li>  Wir überprüfen die unmittelbaren Nachbarn der Kachel, ohne die diagonalen zu berücksichtigen. </li><li>  Wenn die Zelle aktiv ist, addieren Sie eine zur Menge. </li><li>  Wenn die Zelle inaktiv ist, tun Sie nichts. </li><li>  Wenn die Zelle mehr als 2 Nachbarn hat, aktivieren wir die aktuelle Zelle. </li><li>  Wenn die Zelle weniger als 2 Nachbarn hat, wird die aktuelle Zelle inaktiv. </li><li>  Wenn es genau 2 Nachbarn gibt, ändern Sie die aktuelle Zelle nicht. </li></ul><br>  Das zweite Ergebnis verwendet dieselben Prinzipien wie das erste, erweitert jedoch den Bereich der Nachbarschaft. <br><br>       : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetVNSurroundingTiles</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[,] map, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> edgesAreWalls</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* von Neumann Neighbourhood looks like this ('T' is our Tile, 'N' is our Neighbour) * * N * NTN * N * */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tileCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//Keep the edges as walls if(edgesAreWalls &amp;&amp; (x - 1 == 0 || x + 1 == map.GetUpperBound(0) || y - 1 == 0 || y + 1 == map.GetUpperBound(1))) { tileCount++; } //Ensure we aren't touching the left side of the map if(x - 1 &gt; 0) { tileCount += map[x - 1, y]; } //Ensure we aren't touching the bottom of the map if(y - 1 &gt; 0) { tileCount += map[x, y - 1]; } //Ensure we aren't touching the right side of the map if(x + 1 &lt; map.GetUpperBound(0)) { tileCount += map[x + 1, y]; } //Ensure we aren't touching the top of the map if(y + 1 &lt; map.GetUpperBound(1)) { tileCount += map[x, y + 1]; } return tileCount; }</span></span></code> </pre> <br>   ,     .   ,    <code>for</code>        . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] SmoothVNCellularAutomata(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> edgesAreWalls, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> smoothCount) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; smoothCount; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>); x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>); y++) { <span class="hljs-comment"><span class="hljs-comment">//Get the surrounding tiles int surroundingTiles = GetVNSurroundingTiles(map, x, y, edgesAreWalls); if (edgesAreWalls &amp;&amp; (x == 0 || x == map.GetUpperBound(0) - 1 || y == 0 || y == map.GetUpperBound(1))) { //Keep our edges as walls map[x, y] = 1; } //von Neuemann Neighbourhood requires only 3 or more surrounding tiles to be changed to a tile else if (surroundingTiles &gt; 2) { map[x, y] = 1; } else if (surroundingTiles &lt; 2) { map[x, y] = 0; } } } } //Return the modified map return map; }</span></span></code> </pre> <br>   ,      ,    : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c15/fcd/1bb/c15fcd1bb16d2451b47fb7d37aea1f9b.gif"></div><br> ,     ,          . <br><br><h1>  Fazit </h1><br> ,         -   .      ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471084/">https://habr.com/ru/post/de471084/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471072/index.html">Wie viel Gramm im Telegramm?</a></li>
<li><a href="../de471074/index.html">Synet - ein Framework zum Starten vorab trainierter neuronaler Netze auf der CPU</a></li>
<li><a href="../de471076/index.html">Wie die Matrix ein kugelsicheres Erbe schuf</a></li>
<li><a href="../de471078/index.html">Chrome blockiert gemischte Inhalte vollständig</a></li>
<li><a href="../de471080/index.html">Wer ist für die Qualität des Testens der Anwendung verantwortlich? 10 Gründe für Produktionsfehler</a></li>
<li><a href="../de471086/index.html">Python-Musik-Cover-Generator in Blender</a></li>
<li><a href="../de471088/index.html">Burn-out-IT-Spezialisten: 4 Geschichten von Manager, Entwickler, Produkt und Administrator. Und das Rezept von Southbridge</a></li>
<li><a href="../de471090/index.html">[Nicht] CDN verwenden</a></li>
<li><a href="../de471092/index.html">Befehl Cp: Kopieren von Dateiordnern nach * nix korrekt</a></li>
<li><a href="../de471094/index.html">Tutu.ru und der Moskauer Club der Programmierer sind am 17. Oktober zu einem Backend-Meeting eingeladen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>