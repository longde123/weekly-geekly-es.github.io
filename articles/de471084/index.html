<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ß üçà ‚Ü©Ô∏è Verfahrensmuster, die mit Kachelkarten verwendet werden k√∂nnen üïµüèæ ü§ûüèø ü•Å</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die prozedurale Generierung wird verwendet, um die Variabilit√§t von Spielen zu erh√∂hen. Bekannte Projekte sind Minecraft , Enter the Gungeon und Desce...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verfahrensmuster, die mit Kachelkarten verwendet werden k√∂nnen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471084/">  Die prozedurale Generierung wird verwendet, um die Variabilit√§t von Spielen zu erh√∂hen.  Bekannte Projekte sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Minecraft</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Enter the Gungeon</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Descenders</a> .  In diesem Beitrag werde ich einige der Algorithmen erl√§utern, die bei der Arbeit mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tilemap-</a> System, das in Unity 2017.2 als 2D-Funktion angezeigt wurde, und mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RuleTile verwendet werden k√∂nnen</a> . <br><br>  Mit der prozeduralen Erstellung von Karten wird jedes vorbeiziehende Spiel einzigartig.  Sie k√∂nnen verschiedene Eingabedaten wie die Zeit oder die aktuelle Stufe des Spielers verwenden, um den Inhalt auch nach der Zusammenstellung des Spiels dynamisch zu √§ndern. <br><br><h2>  Worum geht es in diesem Beitrag? </h2><br>  Wir werden uns einige der gebr√§uchlichsten Methoden zum Erstellen von prozeduralen Welten sowie einige von mir erstellte Variationen ansehen.  Hier ist ein Beispiel daf√ºr, was Sie nach dem Lesen des Artikels erstellen k√∂nnen.  Drei Algorithmen arbeiten zusammen, um mithilfe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tilemap</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RuleTile</a> eine Karte zu erstellen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/349/44e/154/34944e154f324b508701b42877494500.gif"></div><br>  Beim Generieren einer Karte mit einem beliebigen Algorithmus erhalten wir ein <code>int</code> Array, das alle neuen Daten enth√§lt.  Sie k√∂nnen diese Daten weiterhin √§ndern oder in eine Kachelzuordnung rendern. <br><a name="habracut"></a><br>  Bevor Sie weiterlesen, w√§re es sch√∂n, Folgendes zu wissen: <br><br><ol><li>  Wir unterscheiden, was eine Kachel ist und was keine Bin√§rwerte verwendet.  1 ist eine Kachel, 0 ist ihre Abwesenheit. </li><li>  Wir speichern alle Karten in einem zweidimensionalen Ganzzahl-Array, das am Ende jeder Funktion an den Benutzer zur√ºckgegeben wird (mit Ausnahme derjenigen, in der das Rendern ausgef√ºhrt wird). </li><li>  Ich werde die Array-Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GetUpperBound ()</a> verwenden, um die H√∂he und Breite jeder Karte zu ermitteln, damit die Funktion weniger Variablen empf√§ngt und der Code sauberer ist. </li><li>  Ich verwende h√§ufig <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mathf.FloorToInt ()</a> , da das Tilemap-Koordinatensystem unten links beginnt und Sie mit Mathf.FloorToInt () Zahlen auf eine Ganzzahl runden k√∂nnen. </li><li>  Der gesamte Code in diesem Beitrag ist in C # geschrieben. </li></ol><br><h2>  Array-Generierung </h2><br>  GenerateArray erstellt ein neues <code>int</code> Array mit der angegebenen Gr√∂√üe.  Wir k√∂nnen auch angeben, ob das Array gef√ºllt oder leer sein soll (1 oder 0).  Hier ist der Code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] GenerateArray(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> empty) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[width, height]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>); x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>); y++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (empty) { map[x, y] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { map[x, y] = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> map; }</code> </pre> <br><h2>  Karten-Rendering </h2><br>  Diese Funktion wird verwendet, um eine Karte auf einer Kachelkarte zu rendern.  Wir durchlaufen die Breite und H√∂he der Karte und platzieren Kacheln nur, wenn das Array am getesteten Punkt den Wert 1 hat. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RenderMap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[,] map, Tilemap tilemap, TileBase tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Clear the map (ensures we dont overlap) tilemap.ClearAllTiles(); //Loop through the width of the map for (int x = 0; x &lt; map.GetUpperBound(0) ; x++) { //Loop through the height of the map for (int y = 0; y &lt; map.GetUpperBound(1); y++) { // 1 = tile, 0 = no tile if (map[x, y] == 1) { tilemap.SetTile(new Vector3Int(x, y, 0), tile); } } } }</span></span></code> </pre> <br><h2>  Kartenaktualisierung </h2><br>  Diese Funktion wird nur zum Aktualisieren der Karte und nicht zum erneuten Rendern verwendet.  Dank dessen k√∂nnen wir weniger Ressourcen verbrauchen, ohne jede Kachel und ihre Kacheldaten neu zu zeichnen. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateMap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[,] map, Tilemap tilemap</span></span></span><span class="hljs-function">) </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//Takes in our map and tilemap, setting null tiles where needed { for (int x = 0; x &lt; map.GetUpperBound(0); x++) { for (int y = 0; y &lt; map.GetUpperBound(1); y++) { //We are only going to update the map, rather than rendering again //This is because it uses less resources to update tiles to null //As opposed to re-drawing every single tile (and collision data) if (map[x, y] == 0) { tilemap.SetTile(new Vector3Int(x, y, 0), null); } } } }</span></span></span></span></code> </pre> <br><h2>  Noise Perlin </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Perlin-Rauschen</a> kann f√ºr verschiedene Zwecke verwendet werden.  Erstens k√∂nnen wir damit die oberste Ebene unserer Karte erstellen.  Holen Sie sich dazu einfach einen neuen Punkt mit der aktuellen Position x und dem Startwert. <br><br><h3>  Einfache L√∂sung </h3><br>  Diese Erzeugungsmethode verwendet die einfachste Form der Realisierung von Perlin-Rauschen bei der Erzeugung von Pegeln.  Wir k√∂nnen die Unity-Funktion f√ºr Perlin-Rauschen verwenden, damit wir den Code nicht selbst schreiben.  Wir werden auch nur Ganzzahlen f√ºr die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kachelzuordnung verwenden</a> , indem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wir die</a> Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mathf.FloorToInt ()</a> verwenden. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] PerlinNoise(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seed) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newPoint; <span class="hljs-comment"><span class="hljs-comment">//Used to reduced the position of the Perlin point float reduction = 0.5f; //Create the Perlin for (int x = 0; x &lt; map.GetUpperBound(0); x++) { newPoint = Mathf.FloorToInt((Mathf.PerlinNoise(x, seed) - reduction) * map.GetUpperBound(1)); //Make sure the noise starts near the halfway point of the height newPoint += (map.GetUpperBound(1) / 2); for (int y = newPoint; y &gt;= 0; y--) { map[x, y] = 1; } } return map; }</span></span></code> </pre> <br>  So sieht es nach dem Rendern auf einer Kachelkarte aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d18/ab8/4e1/d18ab84e1e13fa2f8480424cfecc3de5.gif"></div><br><h3>  Gl√§tten </h3><br>  Sie k√∂nnen diese Funktion auch √ºbernehmen und gl√§tten.  Stellen Sie Intervalle f√ºr die Festlegung der Perlin-H√∂hen ein und f√ºhren Sie dann eine Gl√§ttung zwischen diesen Punkten durch.  Diese Funktion wird sich als etwas komplizierter herausstellen, da Sie f√ºr Intervalle Listen mit ganzzahligen Werten ber√ºcksichtigen m√ºssen. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] PerlinNoiseSmooth(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seed, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> interval) { <span class="hljs-comment"><span class="hljs-comment">//Smooth the noise and store it in the int array if (interval &gt; 1) { int newPoint, points; //Used to reduced the position of the Perlin point float reduction = 0.5f; //Used in the smoothing process Vector2Int currentPos, lastPos; //The corresponding points of the smoothing. One list for x and one for y List&lt;int&gt; noiseX = new List&lt;int&gt;(); List&lt;int&gt; noiseY = new List&lt;int&gt;(); //Generate the noise for (int x = 0; x &lt; map.GetUpperBound(0); x += interval) { newPoint = Mathf.FloorToInt((Mathf.PerlinNoise(x, (seed * reduction))) * map.GetUpperBound(1)); noiseY.Add(newPoint); noiseX.Add(x); } points = noiseY.Count;</span></span></code> </pre> <br>  Im ersten Teil dieser Funktion pr√ºfen wir zun√§chst, ob das Intervall gr√∂√üer als eins ist.  Wenn ja, dann erzeugen Sie Rauschen.  Die Erzeugung erfolgt in Intervallen, damit eine Gl√§ttung angewendet werden kann.  Der n√§chste Teil der Funktion besteht darin, Punkte zu gl√§tten. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Start at 1 so we have a previous position already for (int i = 1; i &lt; points; i++) { //Get the current position currentPos = new Vector2Int(noiseX[i], noiseY[i]); //Also get the last position lastPos = new Vector2Int(noiseX[i - 1], noiseY[i - 1]); //Find the difference between the two Vector2 diff = currentPos - lastPos; //Set up what the height change value will be float heightChange = diff.y / interval; //Determine the current height float currHeight = lastPos.y; //Work our way through from the last x to the current x for (int x = lastPos.x; x &lt; currentPos.x; x++) { for (int y = Mathf.FloorToInt(currHeight); y &gt; 0; y--) { map[x, y] = 1; } currHeight += heightChange; } } }</span></span></code> </pre> <br>  Das Gl√§tten wird wie folgt durchgef√ºhrt: <br><br><ol><li>  Wir bekommen die aktuelle und letzte Position </li><li>  Wir erhalten den Unterschied zwischen zwei Punkten. Die wichtigste Information, die wir ben√∂tigen, ist der Unterschied entlang der y-Achse </li><li>  Dann bestimmen wir, wie viel die √Ñnderung vorgenommen werden muss, um zum Punkt zu gelangen. Dies erfolgt durch Teilen der Differenz in y durch die Intervallvariable. </li><li>  Als n√§chstes beginnen wir, Positionen zu setzen und gehen bis auf Null </li><li>  Wenn wir auf der y-Achse 0 erreichen, addieren Sie die H√∂hen√§nderung zur aktuellen H√∂he und wiederholen Sie den Vorgang f√ºr die n√§chste x-Position </li><li>  Wenn wir mit jeder Position zwischen der letzten und der aktuellen Position fertig sind, gehen wir zum n√§chsten Punkt </li></ol><br>  Wenn das Intervall kleiner als eins ist, verwenden wir einfach die vorherige Funktion, die die ganze Arbeit f√ºr uns erledigt. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Defaults to a normal Perlin gen map = PerlinNoise(map, seed); } return map;</span></span></code> </pre> <br>  Werfen wir einen Blick auf das Rendering: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91d/e8f/112/91de8f112bb1aa4bbd139245a1c8c215.gif"></div><br><h2>  Zuf√§lliger Spaziergang </h2><br><h3>  Random Walk Top </h3><br>  Dieser Algorithmus f√ºhrt einen M√ºnzwurf durch.  Wir k√∂nnen eines von zwei Ergebnissen erzielen.  Wenn das Ergebnis "Adler" ist, bewegen wir uns einen Block nach oben, wenn das Ergebnis "Schw√§nze" ist, bewegen wir den Block nach unten.  Dies schafft H√∂hen, indem es sich st√§ndig nach oben oder unten bewegt.  Der einzige Nachteil eines solchen Algorithmus ist seine sehr auff√§llige Blockierung.  Werfen wir einen Blick darauf, wie es funktioniert. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] RandomWalkTop(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seed) { <span class="hljs-comment"><span class="hljs-comment">//Seed our random System.Random rand = new System.Random(seed.GetHashCode()); //Set our starting height int lastHeight = Random.Range(0, map.GetUpperBound(1)); //Cycle through our width for (int x = 0; x &lt; map.GetUpperBound(0); x++) { //Flip a coin int nextMove = rand.Next(2); //If heads, and we aren't near the bottom, minus some height if (nextMove == 0 &amp;&amp; lastHeight &gt; 2) { lastHeight--; } //If tails, and we aren't near the top, add some height else if (nextMove == 1 &amp;&amp; lastHeight &lt; map.GetUpperBound(1) - 2) { lastHeight++; } //Circle through from the lastheight to the bottom for (int y = lastHeight; y &gt;= 0; y--) { map[x, y] = 1; } } //Return the map return map; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57b/791/cd4/57b791cd49bb1c967e994638406371a8.gif"></div><br>  <i>Random Walk Top mit Anti-Aliasing</i> <br><br>  Eine solche Erzeugung f√ºhrt zu gleichm√§√üigeren H√∂hen als die Perlin-Ger√§uschentwicklung. <br><br>  Diese Variante von Random Walk liefert im Vergleich zur vorherigen Version ein viel fl√ºssigeres Ergebnis.  Wir k√∂nnen es implementieren, indem wir der Funktion zwei weitere Variablen hinzuf√ºgen: <br><br><ul><li>  Die erste Variable wird verwendet, um zu bestimmen, wie lange es dauert, die aktuelle H√∂he beizubehalten.  Es ist eine Ganzzahl und wird zur√ºckgesetzt, wenn sich die H√∂he √§ndert </li><li>  Die zweite Variable wird in die Funktion eingegeben und als minimale Abschnittsbreite f√ºr die H√∂he verwendet.  Es wird klarer, wenn wir uns die Funktion ansehen. </li></ul><br>  Jetzt wissen wir, was wir hinzuf√ºgen m√ºssen.  Werfen wir einen Blick auf die Funktion: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] RandomWalkTopSmoothed(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seed, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minSectionWidth) { <span class="hljs-comment"><span class="hljs-comment">//Seed our random System.Random rand = new System.Random(seed.GetHashCode()); //Determine the start position int lastHeight = Random.Range(0, map.GetUpperBound(1)); //Used to determine which direction to go int nextMove = 0; //Used to keep track of the current sections width int sectionWidth = 0; //Work through the array width for (int x = 0; x &lt;= map.GetUpperBound(0); x++) { //Determine the next move nextMove = rand.Next(2); //Only change the height if we have used the current height more than the minimum required section width if (nextMove == 0 &amp;&amp; lastHeight &gt; 0 &amp;&amp; sectionWidth &gt; minSectionWidth) { lastHeight--; sectionWidth = 0; } else if (nextMove == 1 &amp;&amp; lastHeight &lt; map.GetUpperBound(1) &amp;&amp; sectionWidth &gt; minSectionWidth) { lastHeight++; sectionWidth = 0; } //Increment the section width sectionWidth++; //Work our way from the height down to 0 for (int y = lastHeight; y &gt;= 0; y--) { map[x, y] = 1; } } //Return the modified map return map; }</span></span></code> </pre> <br>  Wie Sie im unten gezeigten GIF sehen k√∂nnen, k√∂nnen Sie durch Gl√§tten des Random-Walk-Algorithmus sch√∂ne flache Segmente auf der Ebene erhalten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c1/baf/b53/7c1bafb53bda68f46d617fa4ee2f5c11.gif"></div><br><h2>  Fazit </h2><br>  Ich hoffe, dieser Artikel inspiriert Sie dazu, die prozedurale Generierung in Ihren Projekten zu verwenden.  Wenn Sie mehr √ºber prozedural generierte Karten erfahren m√∂chten, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">besuchen Sie</a> die hervorragenden Ressourcen des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prozedurgenerierungs-</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikis</a> oder von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Roguebasin.com</a> . <br><br>  Im zweiten Teil des Artikels werden wir die prozedurale Generierung verwenden, um H√∂hlensysteme zu erstellen. <br><br><h2>  Teil 2 </h2><br>  Alles, was wir in diesem Teil diskutieren werden, finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Projekt</a> .  Sie k√∂nnen Assets herunterladen und Ihre eigenen Verfahrensalgorithmen ausprobieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/349/44e/154/34944e154f324b508701b42877494500.gif"></div><br><h1>  Noise Perlin </h1><br>  Im vorherigen Teil haben wir uns M√∂glichkeiten angesehen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Perlin-Rauschen</a> anzuwenden, um oberste Ebenen zu erstellen.  Gl√ºcklicherweise kann Perlins L√§rm auch verwendet werden, um eine H√∂hle zu schaffen.  Dies wird durch Berechnung des neuen Perlin-Rauschwerts realisiert, der die Parameter der aktuellen Position multipliziert mit dem Modifikator empf√§ngt.  Der Modifikator ist ein Wert von 0 bis 1. Je h√∂her der Modifikatorwert, desto chaotischer ist die Perlin-Erzeugung.  Dann runden wir diesen Wert auf die Ganzzahl (0 oder 1), die wir im Map-Array speichern.  Sehen Sie, wie dies implementiert wird: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] PerlinNoiseCave(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> modifier, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> edgesAreWalls) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newPoint; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>); x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>); y++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edgesAreWalls &amp;&amp; (x == <span class="hljs-number"><span class="hljs-number">0</span></span> || y == <span class="hljs-number"><span class="hljs-number">0</span></span> || x == map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>) - <span class="hljs-number"><span class="hljs-number">1</span></span> || y == map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>) - <span class="hljs-number"><span class="hljs-number">1</span></span>)) { map[x, y] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//Keep the edges as walls } else { //Generate a new point using Perlin noise, then round it to a value of either 0 or 1 newPoint = Mathf.RoundToInt(Mathf.PerlinNoise(x * modifier, y * modifier)); map[x, y] = newPoint; } } } return map; }</span></span></code> </pre> <br>  Wir verwenden den Modifikator anstelle von Seed, da die Ergebnisse der Perlin-Generation besser aussehen, wenn sie mit einer Zahl von 0 bis 0,5 multipliziert werden.  Je niedriger der Wert, desto blockiger wird das Ergebnis.  Schauen Sie sich die Beispielergebnisse an.  Gif beginnt mit einem Modifikatorwert von 0,01 und erreicht schrittweise einen Wert von 0,25. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/760/abb/891/760abb891c7f225803aecc64c24af5ed.gif"></div><br>  Aus diesem GIF ist ersichtlich, dass die Perlin-Erzeugung mit jedem Inkrement einfach das Muster erh√∂ht. <br><br><h1>  Zuf√§lliger Spaziergang </h1><br>  Im vorherigen Teil haben wir gesehen, dass Sie mithilfe eines M√ºnzwurfs bestimmen k√∂nnen, wo sich die Plattform nach oben oder unten bewegt.  In diesem Teil werden wir die gleiche Idee verwenden, aber <br>  mit zwei zus√§tzlichen Optionen f√ºr Links- und Rechtsverschiebung.  Diese Variation des Random Walk-Algorithmus erm√∂glicht es uns, H√∂hlen zu erstellen.  Dazu w√§hlen wir eine zuf√§llige Richtung, verschieben dann unsere Position und l√∂schen die Kachel.  Wir setzen diesen Prozess fort, bis wir die erforderliche Anzahl von Kacheln erreicht haben, die zerst√∂rt werden m√ºssen.  Bisher verwenden wir nur 4 Richtungen: oben, unten, links, rechts. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] RandomWalkCave(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seed, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> requiredFloorPercent) { <span class="hljs-comment"><span class="hljs-comment">//Seed our random System.Random rand = new System.Random(seed.GetHashCode()); //Define our start x position int floorX = rand.Next(1, map.GetUpperBound(0) - 1); //Define our start y position int floorY = rand.Next(1, map.GetUpperBound(1) - 1); //Determine our required floorAmount int reqFloorAmount = ((map.GetUpperBound(1) * map.GetUpperBound(0)) * requiredFloorPercent) / 100; //Used for our while loop, when this reaches our reqFloorAmount we will stop tunneling int floorCount = 0; //Set our start position to not be a tile (0 = no tile, 1 = tile) map[floorX, floorY] = 0; //Increase our floor count floorCount++;</span></span></code> </pre> <br>  Die Funktion beginnt mit: <br><br><ol><li>  Finde die Startposition </li><li>  Berechnen Sie die Anzahl der zu l√∂schenden Bodenfliesen. </li><li>  L√∂schen Sie die Kachel in der Startposition </li><li>  F√ºgen Sie der Anzahl der Kacheln eine hinzu. </li></ol><br>  Dann fahren wir mit der <code>while</code> .  Er wird eine H√∂hle schaffen: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (floorCount &lt; reqFloorAmount) { <span class="hljs-comment"><span class="hljs-comment">//Determine our next direction int randDir = rand.Next(4); switch (randDir) { //Up case 0: //Ensure that the edges are still tiles if ((floorY + 1) &lt; map.GetUpperBound(1) - 1) { //Move the y up one floorY++; //Check if that piece is currently still a tile if (map[floorX, floorY] == 1) { //Change it to not a tile map[floorX, floorY] = 0; //Increase floor count floorCount++; } } break; //Down case 1: //Ensure that the edges are still tiles if ((floorY - 1) &gt; 1) { //Move the y down one floorY--; //Check if that piece is currently still a tile if (map[floorX, floorY] == 1) { //Change it to not a tile map[floorX, floorY] = 0; //Increase the floor count floorCount++; } } break; //Right case 2: //Ensure that the edges are still tiles if ((floorX + 1) &lt; map.GetUpperBound(0) - 1) { //Move the x to the right floorX++; //Check if that piece is currently still a tile if (map[floorX, floorY] == 1) { //Change it to not a tile map[floorX, floorY] = 0; //Increase the floor count floorCount++; } } break; //Left case 3: //Ensure that the edges are still tiles if ((floorX - 1) &gt; 1) { //Move the x to the left floorX--; //Check if that piece is currently still a tile if (map[floorX, floorY] == 1) { //Change it to not a tile map[floorX, floorY] = 0; //Increase the floor count floorCount++; } } break; } } //Return the updated map return map; }</span></span></code> </pre> <br><h3>  Was machen wir hier? </h3><br>  Zun√§chst w√§hlen wir mit Hilfe einer Zufallszahl, in welche Richtung wir uns bewegen m√∂chten.  Dann √ºberpr√ºfen wir die neue Richtung mit der <code>switch case</code> .  In dieser Aussage pr√ºfen wir, ob es sich bei der Position um eine Wand handelt.  Wenn nicht, l√∂schen Sie das Element mit der Kachel aus dem Array.  Wir machen so weiter, bis wir die gew√ºnschte Grundfl√§che erreicht haben.  Das Ergebnis ist unten dargestellt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c6/fc1/86c/2c6fc186c67095e13c1dcbea4c95aff4.gif"></div><br>  Ich habe auch meine eigene Version dieser Funktion erstellt, die auch diagonale Richtungen enth√§lt.  Der Funktionscode ist ziemlich lang. Wenn Sie ihn also ansehen m√∂chten, laden Sie das Projekt √ºber den Link am Anfang dieses Teils des Artikels herunter. <br><br><h1>  Richtungstunnel </h1><br>  Ein Richtungstunnel beginnt an einem Rand der Karte und erreicht den gegen√ºberliegenden Rand.  Wir k√∂nnen die Kr√ºmmung und Rauheit des Tunnels steuern, indem wir sie an die Eingabefunktion √ºbergeben.  Wir k√∂nnen auch die minimale und maximale L√§nge der Teile des Tunnels einstellen.  Werfen wir einen Blick auf die Implementierung: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] DirectionalTunnel(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minPathWidth, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxPathWidth, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxPathChange, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> roughness, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> curvyness) { <span class="hljs-comment"><span class="hljs-comment">//This value goes from its minus counterpart to its positive value, in this case with a width value of 1, the width of the tunnel is 3 int tunnelWidth = 1; //Set the start X position to the center of the tunnel int x = map.GetUpperBound(0) / 2; //Set up our random with the seed System.Random rand = new System.Random(Time.time.GetHashCode()); //Create the first part of the tunnel for (int i = -tunnelWidth; i &lt;= tunnelWidth; i++) { map[x + i, 0] = 0; }</span></span></code> </pre> <br><h3>  Was ist los? </h3><br>  Zuerst setzen wir den Breitenwert.  Der Breitenwert wechselt vom Wert mit einem Minus zu einem Positiv.  Dank dessen erhalten wir die Gr√∂√üe, die wir ben√∂tigen.  In diesem Fall verwenden wir den Wert 1, was wiederum eine Gesamtbreite von 3 ergibt, da wir die Werte -1, 0, 1 verwenden. <br><br>  Als n√§chstes setzen wir die Anfangsposition in x, daf√ºr nehmen wir die Mitte der Breite der Karte.  Danach k√∂nnen wir im ersten Teil der Karte einen Tunnel legen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/605/0a7/552/6050a75522b8d628722d5373ddee8c76.png"></div><br>  Kommen wir nun zum Rest der Karte. <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//Cycle through the array for (int y = 1; y &lt; map.GetUpperBound(1); y++) { //Check if we can change the roughness if (rand.Next(0, 100) &gt; roughness) { //Get the amount we will change for the width int widthChange = Random.Range(-maxPathWidth, maxPathWidth); //Add it to our tunnel width value tunnelWidth += widthChange; //Check to see we arent making the path too small if (tunnelWidth &lt; minPathWidth) { tunnelWidth = minPathWidth; } //Check that the path width isnt over our maximum if (tunnelWidth &gt; maxPathWidth) { tunnelWidth = maxPathWidth; } } //Check if we can change the curve if (rand.Next(0, 100) &gt; curvyness) { //Get the amount we will change for the x position int xChange = Random.Range(-maxPathChange, maxPathChange); //Add it to our x value x += xChange; //Check we arent too close to the left side of the map if (x &lt; maxPathWidth) { x = maxPathWidth; } //Check we arent too close to the right side of the map if (x &gt; (map.GetUpperBound(0) - maxPathWidth)) { x = map.GetUpperBound(0) - maxPathWidth; } } //Work through the width of the tunnel for (int i = -tunnelWidth; i &lt;= tunnelWidth; i++) { map[x + i, y] = 0; } } return map; }</span></span></code> </pre> <br>  Wir generieren eine Zufallszahl zum Vergleich mit dem Rauheitswert. Wenn dieser Wert h√∂her als dieser Wert ist, kann die Pfadbreite ge√§ndert werden.  Wir √ºberpr√ºfen auch den Wert, um die Breite nicht zu klein zu machen.  Im n√§chsten Teil des Codes machen wir uns auf den Weg durch die Karte.  In jeder Phase tritt Folgendes auf: <br><br><ol><li>  Wir erzeugen eine neue Zufallszahl im Vergleich zum Kr√ºmmungswert.  Wie im vorherigen Test √§ndern wir den Mittelpunkt des Pfades, wenn er gr√∂√üer als der Wert ist.  Wir f√ºhren auch eine √úberpr√ºfung durch, um nicht √ºber die Karte hinauszugehen. </li><li>  Schlie√ülich legen wir einen Tunnel in den neu geschaffenen Teil. </li></ol><br>  Die Ergebnisse dieser Implementierung sehen folgenderma√üen aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d25/bd4/d34/d25bd4d348871f08fcb383c3508ab25f.gif"></div><br><h1>  Zellul√§re Automaten </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zellul√§re Automaten</a> verwenden benachbarte Zellen, um zu bestimmen, ob die aktuelle Zelle eingeschaltet (1) oder ausgeschaltet (0) ist.  Die Basis zur Bestimmung benachbarter Zellen wird basierend auf einem zuf√§llig erzeugten Gitter von Zellen erstellt.  Wir werden dieses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellraster mit der</a> Funktion C # <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Random.Next generieren</a> . <br><br>  Da wir einige verschiedene Implementierungen von zellularen Automaten haben, habe ich eine separate Funktion geschrieben, um dieses Grundraster zu generieren.  Die Funktion sieht folgenderma√üen aus: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] GenerateCellularAutomata(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seed, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fillPercent, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> edgesAreWalls) { <span class="hljs-comment"><span class="hljs-comment">//Seed our random number generator System.Random rand = new System.Random(seed.GetHashCode()); //Initialise the map int[,] map = new int[width, height]; for (int x = 0; x &lt; map.GetUpperBound(0); x++) { for (int y = 0; y &lt; map.GetUpperBound(1); y++) { //If we have the edges set to be walls, ensure the cell is set to on (1) if (edgesAreWalls &amp;&amp; (x == 0 || x == map.GetUpperBound(0) - 1 || y == 0 || y == map.GetUpperBound(1) - 1)) { map[x, y] = 1; } else { //Randomly generate the grid map[x, y] = (rand.Next(0, 100) &lt; fillPercent) ? 1 : 0; } } } return map; }</span></span></code> </pre> <br>  In dieser Funktion k√∂nnen Sie auch festlegen, ob unser Gitter W√§nde ben√∂tigt.  Im √úbrigen ist es ganz einfach.  Wir √ºberpr√ºfen eine Zufallszahl mit prozentualer F√ºllung, um festzustellen, ob die aktuelle Zelle aktiviert ist.  Schauen Sie sich das Ergebnis an: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/585/bfa/9ec/585bfa9ec7953056e160af10b4efbc88.gif"></div><br><h2>  Die Nachbarschaft von Moore </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Moore-Nachbarschaft wird</a> verwendet, um die anf√§ngliche Erzeugung von zellularen Automaten zu gl√§tten.  Die Nachbarschaft von Moore sieht so aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30b/c02/328/30bc02328e772a2955aa071bfdbc2cc6.png"></div><br>  F√ºr die Nachbarschaft gelten folgende Regeln: <br><br><ul><li>  Wir √ºberpr√ºfen den Nachbarn in jede Richtung. </li><li>  Wenn der Nachbar eine aktive Kachel ist, addieren Sie eine zur Anzahl der umgebenden Kacheln. </li><li>  Wenn der Nachbar eine inaktive Kachel ist, tun wir nichts. </li><li>  Wenn eine Zelle mehr als 4 umgebende Kacheln hat, aktivieren Sie die Zelle. </li><li>  Wenn die Zelle genau 4 umgebende Kacheln hat, machen wir nichts damit. </li><li>  Wiederholen Sie diesen Vorgang, bis wir jede Kartenkachel √ºberpr√ºft haben. </li></ul><br>  Die Nachbarschaftspr√ºfungsfunktion von Moore lautet wie folgt: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMooreSurroundingTiles</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[,] map, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> edgesAreWalls</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* Moore Neighbourhood looks like this ('T' is our tile, 'N' is our neighbours) * * NNN * NTN * NNN * */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tileCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> neighbourX = x - <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbourX &lt;= x + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbourX++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> neighbourY = y - <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbourY &lt;= y + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbourY++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbourX &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; neighbourX &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; neighbourY &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; neighbourY &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">//We don't want to count the tile we are checking the surroundings of if(neighbourX != x || neighbourY != y) { tileCount += map[neighbourX, neighbourY]; } } } } return tileCount; }</span></span></code> </pre> <br>  Nach dem √úberpr√ºfen der Kachel verwenden wir diese Informationen in der Gl√§ttungsfunktion.  Hier kann wie bei der Erzeugung von zellularen Automaten angegeben werden, ob die Kanten der Karte W√§nde sein sollen. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] SmoothMooreCellularAutomata(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> edgesAreWalls, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> smoothCount) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; smoothCount; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>); x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>); y++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> surroundingTiles = GetMooreSurroundingTiles(map, x, y, edgesAreWalls); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edgesAreWalls &amp;&amp; (x == <span class="hljs-number"><span class="hljs-number">0</span></span> || x == (map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>) - <span class="hljs-number"><span class="hljs-number">1</span></span>) || y == <span class="hljs-number"><span class="hljs-number">0</span></span> || y == (map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>) - <span class="hljs-number"><span class="hljs-number">1</span></span>))) { <span class="hljs-comment"><span class="hljs-comment">//Set the edge to be a wall if we have edgesAreWalls to be true map[x, y] = 1; } //The default moore rule requires more than 4 neighbours else if (surroundingTiles &gt; 4) { map[x, y] = 1; } else if (surroundingTiles &lt; 4) { map[x, y] = 0; } } } } //Return the modified map return map; }</span></span></code> </pre> <br>  Hierbei ist zu beachten, dass die Funktion √ºber eine <code>for</code> Schleife verf√ºgt, die die angegebene Anzahl von Gl√§ttungen durchf√ºhrt.  Dadurch wird eine sch√∂nere Karte erhalten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68f/082/25c/68f08225c0c31cb243969192744f7b16.gif"></div><br>  Wir k√∂nnen diesen Algorithmus jederzeit √§ndern, indem wir R√§ume verbinden, wenn sich beispielsweise nur zwei Bl√∂cke zwischen ihnen befinden. <br><br><h2>  Von Neumann Nachbarschaft </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Viertel von Neumann</a> ist ein weiterer beliebter Weg, um zellulare Automaten zu implementieren.  F√ºr eine solche Generation verwenden wir eine einfachere Nachbarschaft als f√ºr die Moore-Generation.  Die Nachbarschaft sieht so aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/952/d30/66c/952d3066c638932947db9c9a95ee36bf.png"></div><br>  F√ºr die Nachbarschaft gelten folgende Regeln: <br><br><ul><li>  Wir √ºberpr√ºfen die unmittelbaren Nachbarn der Kachel, ohne die diagonalen zu ber√ºcksichtigen. </li><li>  Wenn die Zelle aktiv ist, addieren Sie eine zur Menge. </li><li>  Wenn die Zelle inaktiv ist, tun Sie nichts. </li><li>  Wenn die Zelle mehr als 2 Nachbarn hat, aktivieren wir die aktuelle Zelle. </li><li>  Wenn die Zelle weniger als 2 Nachbarn hat, wird die aktuelle Zelle inaktiv. </li><li>  Wenn es genau 2 Nachbarn gibt, √§ndern Sie die aktuelle Zelle nicht. </li></ul><br>  Das zweite Ergebnis verwendet dieselben Prinzipien wie das erste, erweitert jedoch den Bereich der Nachbarschaft. <br><br>       : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetVNSurroundingTiles</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[,] map, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> edgesAreWalls</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* von Neumann Neighbourhood looks like this ('T' is our Tile, 'N' is our Neighbour) * * N * NTN * N * */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tileCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//Keep the edges as walls if(edgesAreWalls &amp;&amp; (x - 1 == 0 || x + 1 == map.GetUpperBound(0) || y - 1 == 0 || y + 1 == map.GetUpperBound(1))) { tileCount++; } //Ensure we aren't touching the left side of the map if(x - 1 &gt; 0) { tileCount += map[x - 1, y]; } //Ensure we aren't touching the bottom of the map if(y - 1 &gt; 0) { tileCount += map[x, y - 1]; } //Ensure we aren't touching the right side of the map if(x + 1 &lt; map.GetUpperBound(0)) { tileCount += map[x + 1, y]; } //Ensure we aren't touching the top of the map if(y + 1 &lt; map.GetUpperBound(1)) { tileCount += map[x, y + 1]; } return tileCount; }</span></span></code> </pre> <br>   ,     .   ,    <code>for</code>        . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] SmoothVNCellularAutomata(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] map, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> edgesAreWalls, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> smoothCount) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; smoothCount; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>); x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; map.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>); y++) { <span class="hljs-comment"><span class="hljs-comment">//Get the surrounding tiles int surroundingTiles = GetVNSurroundingTiles(map, x, y, edgesAreWalls); if (edgesAreWalls &amp;&amp; (x == 0 || x == map.GetUpperBound(0) - 1 || y == 0 || y == map.GetUpperBound(1))) { //Keep our edges as walls map[x, y] = 1; } //von Neuemann Neighbourhood requires only 3 or more surrounding tiles to be changed to a tile else if (surroundingTiles &gt; 2) { map[x, y] = 1; } else if (surroundingTiles &lt; 2) { map[x, y] = 0; } } } } //Return the modified map return map; }</span></span></code> </pre> <br>   ,      ,    : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c15/fcd/1bb/c15fcd1bb16d2451b47fb7d37aea1f9b.gif"></div><br> ,     ,          . <br><br><h1>  Fazit </h1><br> ,         -   .      ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471084/">https://habr.com/ru/post/de471084/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471072/index.html">Wie viel Gramm im Telegramm?</a></li>
<li><a href="../de471074/index.html">Synet - ein Framework zum Starten vorab trainierter neuronaler Netze auf der CPU</a></li>
<li><a href="../de471076/index.html">Wie die Matrix ein kugelsicheres Erbe schuf</a></li>
<li><a href="../de471078/index.html">Chrome blockiert gemischte Inhalte vollst√§ndig</a></li>
<li><a href="../de471080/index.html">Wer ist f√ºr die Qualit√§t des Testens der Anwendung verantwortlich? 10 Gr√ºnde f√ºr Produktionsfehler</a></li>
<li><a href="../de471086/index.html">Python-Musik-Cover-Generator in Blender</a></li>
<li><a href="../de471088/index.html">Burn-out-IT-Spezialisten: 4 Geschichten von Manager, Entwickler, Produkt und Administrator. Und das Rezept von Southbridge</a></li>
<li><a href="../de471090/index.html">[Nicht] CDN verwenden</a></li>
<li><a href="../de471092/index.html">Befehl Cp: Kopieren von Dateiordnern nach * nix korrekt</a></li>
<li><a href="../de471094/index.html">Tutu.ru und der Moskauer Club der Programmierer sind am 17. Oktober zu einem Backend-Meeting eingeladen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>