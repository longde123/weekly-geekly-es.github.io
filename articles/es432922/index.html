<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçö üë®üèº‚Äç‚úàÔ∏è üë©üèª‚Äçü§ù‚Äçüë®üèº C√≥mo buscamos durante dos semanas el error NFS en el kernel de Linux üöÜ üëï üëØ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Una descripci√≥n detallada de las b√∫squedas de errores de la tarea GitLab que condujo al parche para el kernel de Linux 


 El 14 de septiembre, el sop...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo buscamos durante dos semanas el error NFS en el kernel de Linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/432922/"><h3 id="podrobnoe-opisanie-poiskov-baga-iz-zadachi-gitlab-kotorye-priveli-k-patchu-dlya-yadra-linux">  Una descripci√≥n detallada de las b√∫squedas de errores de la tarea GitLab que condujo al parche para el kernel de Linux </h3><br><p> El 14 de septiembre, el soporte de GitLab inform√≥ un problema cr√≠tico que le ocurri√≥ a uno de nuestros clientes: primero, GitLab funciona bien, y luego los usuarios obtienen un error.  Intentaron clonar algunos repositorios a trav√©s de Git, y de repente apareci√≥ un mensaje incomprensible sobre un archivo obsoleto: <code>Stale file error</code> obsoleto.  El error persisti√≥ durante mucho tiempo y no funcion√≥ hasta que el administrador del sistema inici√≥ manualmente <code>ls</code> en el directorio mismo. </p><br><p>  Tuve que estudiar los mecanismos internos de Git y el sistema de archivos de red NFS.  Como resultado, encontramos un error en el cliente Linux v4.0 NFS, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Trond Myklebust escribi√≥ un parche para el n√∫cleo</a> , y desde el 26 de octubre, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este parche se ha incluido en el n√∫cleo principal de Linux</a> . </p><br><p>  En esta publicaci√≥n, te contar√© c√≥mo estudiamos el problema, en qu√© direcci√≥n pensamos y qu√© herramientas utilizamos para rastrear el error.  Nos inspir√≥ el excelente trabajo de detective de Oleg Dashevsky que se describe en la publicaci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"C√≥mo busqu√© una fuga de memoria en Ruby durante dos semanas"</a> . </p><br><img src="https://habrastorage.org/webt/es/0f/-7/es0f-7dbqlnheksnnmxtlwawlic.jpeg"><a name="habracut"></a><br><p>  Tambi√©n es un gran ejemplo de c√≥mo la depuraci√≥n de c√≥digo abierto es un deporte de equipo que involucra a muchas personas, empresas y pa√≠ses.  El lema de GitLab, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Todos pueden contribuir</a> " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">,</a> es cierto no solo para GitLab en s√≠, sino tambi√©n para otros proyectos de c√≥digo abierto, como el kernel de Linux. </p><br><h3 id="vosproizvedenie-baga">  Reproducci√≥n de errores </h3><br><p>  Mantuvimos NFS en GitLab.com durante muchos a√±os, pero luego dejamos de usarlo para acceder a los datos del repositorio en m√°quinas con aplicaciones.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hemos trasladado todas las llamadas de Git a Gitaly</a> .  Admitimos NFS para clientes que administran sus instalaciones en GitLab pero que nunca han tenido el mismo problema que el cliente mencionado anteriormente. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El cliente dio algunas sugerencias √∫tiles</a> : </p><br><ol><li>  Texto de error completo: <code>fatal: Couldn't read ./packed-refs: Stale file handle</code> . </li><li>  Aparentemente, el problema surgi√≥ cuando el cliente inici√≥ manualmente la recolecci√≥n de basura en Git con el comando <code>git gc</code> . </li><li>  El error desapareci√≥ cuando el administrador del sistema inici√≥ la utilidad <code>ls</code> en el directorio. </li><li>  El error desapareci√≥ cuando <code>git gc</code> proceso <code>git gc</code> . </li></ol><br><p>  Est√° claro que los dos primeros puntos est√°n conectados.  Cuando env√≠a cambios a la rama de Git, Git crea un enlace d√©bil: un nombre de archivo largo que indica el nombre de la rama para la confirmaci√≥n.  Por ejemplo, cuando se env√≠a a <code>master</code> , se crear√° un archivo llamado <code>refs/heads/master</code> en el repositorio: </p><br><pre> <code class="plaintext hljs">$ cat refs/heads/master 2e33a554576d06d9e71bfd6814ee9ba3a7838963</code> </pre> <br><p>  El comando <code>git gc</code> realiza varias tareas.  Por ejemplo, recopila estos enlaces d√©biles (referencias) y los empaqueta en un solo archivo llamado <code>packed-refs</code> .  Esto acelera un poco el trabajo, porque leer un archivo grande es m√°s f√°cil que muchos peque√±os.  Por ejemplo, despu√©s de ejecutar el comando <code>git gc</code> , el archivo <code>packed-refs</code> podr√≠a verse as√≠: </p><br><pre> <code class="plaintext hljs"># pack-refs with: peeled fully-peeled sorted 564c3424d6f9175cf5f2d522e10d20d781511bf1 refs/heads/10-8-stable edb037cbc85225261e8ede5455be4aad771ba3bb refs/heads/11-0-stable 94b9323033693af247128c8648023fe5b53e80f9 refs/heads/11-1-stable 2e33a554576d06d9e71bfd6814ee9ba3a7838963 refs/heads/master</code> </pre> <br><p>  ¬øC√≥mo se crea el archivo <code>packed-refs</code> ?  Para averiguarlo, <code>strace git gc</code> comando <code>strace git gc</code> donde ten√≠amos un enlace d√©bil.  Aqu√≠ est√°n las l√≠neas que son relevantes: </p><br><pre> <code class="plaintext hljs">28705 open("/tmp/libgit2/.git/packed-refs.lock", O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC, 0666) = 3 28705 open(".git/packed-refs", O_RDONLY) = 3 28705 open("/tmp/libgit2/.git/packed-refs.new", O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC, 0666) = 4 28705 rename("/tmp/libgit2/.git/packed-refs.new", "/tmp/libgit2/.git/packed-refs") = 0 28705 unlink("/tmp/libgit2/.git/packed-refs.lock") = 0</code> </pre> <br><p>  Las llamadas al sistema mostraron que el comando <code>git gc</code> : </p><br><ol><li>  Abierto <code>packed-refs.lock</code> .  Esto le dice a otros procesos que el archivo de <code>packed-refs</code> est√° bloqueado y no puede cambiar. </li><li>  Abierto <code>packed-refs.new</code> . </li><li>  <code>packed-refs.new</code> enlaces d√©biles en <code>packed-refs.new</code> . </li><li>  Renombrado <code>packed-refs</code> <code>packed-refs.new</code> a <code>packed-refs</code> <code>packed-refs.new</code> . </li><li>  Se elimin√≥ el <code>packed-refs.lock</code> . </li><li>  Se eliminaron los enlaces d√©biles. </li></ol><br><p>  El punto clave aqu√≠ es el cuarto, es decir, el cambio de nombre, donde Git presenta el archivo de <code>packed-refs</code> .  <code>git gc</code> no solo recopila enlaces d√©biles, sino que tambi√©n realiza una tarea que requiere muchos m√°s recursos: busca y elimina objetos no utilizados.  En repositorios grandes, esto puede durar m√°s de una hora. </p><br><p>  Y nos preguntamos: ¬øen los repositorios grandes, <code>git gc</code> mantiene el archivo abierto durante la limpieza?  Estudiamos los registros de <code>strace</code> , lanzamos la utilidad <code>lsof</code> , y esto es lo que aprendimos sobre el proceso <code>git gc</code> : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/493/51d/077/49351d077382c8b70317346789331c81.svg" alt="imagen"></p><br><p>  Como puede ver, el archivo de <code>packed-refs</code> cierra al final, despu√©s del proceso potencialmente largo de <code>Garbage collect objects</code> . </p><br><p>  Entonces surgi√≥ la siguiente pregunta: ¬øc√≥mo se comporta NFS cuando el archivo de <code>packed-refs</code> est√° abierto en un nodo y el otro lo renombra en ese momento? </p><br><p>  "Con fines cient√≠ficos", le pedimos al cliente que realizara un experimento en dos m√°quinas diferentes (Alice y Bob): <br>  1) En el volumen compartido NFS, cree dos archivos: <code>test1.txt</code> y <code>test2.txt</code> con diferentes contenidos, para que sea m√°s f√°cil distinguirlos: </p><br><pre> <code class="plaintext hljs">alice $ echo "1 - Old file" &gt; /path/to/nfs/test1.txt alice $ echo "2 - New file" &gt; /path/to/nfs/test2.txt</code> </pre> <br><p>  2) En la m√°quina de Alice, el archivo <code>test1.txt</code> deber√≠a estar abierto: </p><br><pre> <code class="plaintext hljs">alice $ irb irb(main):001:0&gt; File.open('/path/to/nfs/test1.txt')</code> </pre> <br><p>  3) En la m√°quina de Alice, muestre continuamente el contenido de <code>test1.txt</code> : </p><br><pre> <code class="plaintext hljs">alice $ while true; do cat test1.txt; done</code> </pre> <br><p>  4) Luego, en la m√°quina de Bob, ejecute el comando: </p><br><pre> <code class="plaintext hljs">bob $ mv -f test2.txt test1.txt</code> </pre> <br><p>  El √∫ltimo paso reproduce lo que hace <code>git gc</code> con el archivo de <code>packed-refs</code> al sobrescribir un archivo existente. <br>  En la m√°quina del cliente, el resultado se parec√≠a a esto: </p><br><pre> <code class="plaintext hljs">1 - Old file 1 - Old file 1 - Old file cat: test1.txt: Stale file handle</code> </pre> <br><p>  Hay!  Parece que hemos controlado el problema de manera controlada.  Pero en el mismo experimento en un servidor NFS de Linux, este problema no ocurri√≥.  El resultado era esperado; despu√©s de renombrar el nuevo contenido fue aceptado: </p><br><pre> <code class="plaintext hljs">1 - Old file 1 - Old file 1 - Old file 2 - New file &lt;--- RENAME HAPPENED 2 - New file 2 - New file</code> </pre> <br><p>  ¬øDe d√≥nde viene esta diferencia de comportamiento?  Resulta que el cliente us√≥ el almacenamiento <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Isilon NFS</a> , que solo era compatible con NFS v4.0.  Cuando cambiamos la configuraci√≥n de conexi√≥n a v4.0 usando el par√°metro <code>vers=4.0</code> en <code>/etc/fstab</code> , la prueba mostr√≥ un resultado diferente para el servidor NFS de Linux: </p><br><pre> <code class="plaintext hljs">1 - Old file 1 - Old file 1 - Old file 1 - Old file &lt;--- RENAME HAPPENED 1 - Old file 1 - Old file</code> </pre> <br><p>  En lugar del <code>Stale file handle</code> obsoleto <code>Stale file handle</code> servidor Linux NFS v4.0 muestra <em>contenido</em> obsoleto.  Resulta que la diferencia de comportamiento puede explicarse por las especificaciones NFS.  De <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RFC 3010</a> : </p><br><blockquote>  El descriptor de archivo puede quedar obsoleto o caducar cuando se cambia el nombre, pero no siempre.  Se recomienda a los implementadores del servidor que tomen medidas para garantizar que los descriptores de archivos no caduquen y no caduquen de esta manera. </blockquote><p>  En otras palabras, los servidores NFS pueden elegir c√≥mo comportarse cuando se cambia el nombre de un archivo, y el servidor NFS devuelve razonablemente un <code>Stale file error</code> en tales casos.  Sugerimos que la causa del problema es la misma, aunque los resultados fueron diferentes.  Sospechamos que se trataba de una comprobaci√≥n de cach√©, porque la utilidad <code>ls</code> en el directorio elimin√≥ el error.  Ahora ten√≠amos un escenario de prueba reproducible y recurrimos a expertos: mantenedores de Linux NFS. </p><br><h2 id="lozhnyy-sled-delegirovanie-na-nfs-servere">  False Trace: Delegaci√≥n en un servidor NFS </h2><br><p>  Cuando logramos reproducir el error paso a paso, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">escrib√≠ a los contactos de Linux NFS</a> sobre lo que aprendimos.  Me comuniqu√© con Bruce Fields, el encargado del mantenimiento del servidor NFS de Linux durante una semana, y me sugiri√≥ que el error estaba en NFS y que necesitaba estudiar el tr√°fico de la red.  Pens√≥ que el problema era delegar tareas en el servidor NFS. </p><br><h3 id="chto-takoe-delegirovanie-na-nfs-servere">  ¬øQu√© es la delegaci√≥n en un servidor NFS? </h3><br><p>  En pocas palabras, la versi√≥n NFS v4 tiene una funci√≥n de delegaci√≥n para acelerar el acceso a los archivos.  El servidor puede delegar el acceso de lectura o escritura al cliente para que el cliente no tenga que preguntarle constantemente al servidor si otro cliente ha cambiado el archivo.  En pocas palabras, delegar un registro es como prestarle a alguien su cuaderno y decir: "Usted escribe aqu√≠, y lo recoger√© cuando est√© listo".  Y una persona no tiene que pedir un cuaderno cada vez que necesita escribir algo: tiene total libertad de acci√≥n hasta que se lo quite.  En NFS, una solicitud para devolver un cuaderno se llama revocaci√≥n de delegaci√≥n. </p><br><p>  Un error en la revocaci√≥n de la delegaci√≥n NFS podr√≠a explicar el problema de <code>Stale file handle</code> .  Recuerde c√≥mo se abri√≥ <code>test1.txt</code> en el <code>test1.txt</code> de Alice, y luego <code>test2.txt</code> reemplaz√≥.  Tal vez el servidor no pudo revocar la delegaci√≥n para <code>test1.txt</code> , y esto llev√≥ a un estado no v√°lido.  Para probar esta teor√≠a, registramos el tr√°fico NFC con la utilidad <code>tcpdump</code> y lo visualizamos usando Wireshark. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wireshark</a> es una gran herramienta de c√≥digo abierto para analizar el tr√°fico de red, especialmente para explorar NFS en acci√≥n.  Registramos la traza utilizando el siguiente comando en un servidor NFS: </p><br><pre> <code class="plaintext hljs">tcpdump -s 0 -w /tmp/nfs.pcap port 2049</code> </pre> <br><p>  Este comando registra todo el tr√°fico NFS que generalmente pasa por el puerto TCP 2049. Dado que nuestro experimento fue exitoso con NFS v4.1, pero no con NFS v4.0, podr√≠amos comparar el comportamiento de NFS en el caso de trabajo y no trabajo.  Con Wireshark, vimos el siguiente comportamiento: </p><br><h3 id="nfs-v40-ustarevshiy-fayl">  NFS v4.0 (archivo en desuso) </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6a1/0bb/e23/6a10bbe2304b155431010aa4ca577fa7.svg" alt="imagen"></p><br><p>  Este diagrama muestra que en el paso 1, Alice abre <code>test1.txt</code> y recibe un descriptor de archivo NFS con el identificador <code>stateid</code> 0x3000.  Cuando Bob intenta cambiar el nombre del archivo, el servidor NFS solicita volver a intentarlo enviando el mensaje <code>NFS4ERR_DELAY</code> , y recuerda la delegaci√≥n de Alice a trav√©s del mensaje <code>CB_RECALL</code> (paso 3).  Alice devuelve la delegaci√≥n (DELEGRETURN en el paso 4) y Bob intenta enviar el mensaje <code>RENAME</code> nuevamente (paso 5).  <code>RENAME</code> se ejecuta en ambos casos, pero Alice contin√∫a leyendo el archivo con el mismo descriptor. </p><br><h3 id="nfs-v41-rabochiy-sluchay">  NFS v4.1 (caso de trabajo) </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f3d/1a3/d49/f3d1a3d49e803d73a4dd7f830e9b238a.svg" alt="imagen"></p><br><p>  Aqu√≠ la diferencia es visible en el paso 6. En NFS v4.0 (con un archivo obsoleto) Alice intenta usar el mismo <code>stateid</code> .  En NFS v4.1 (caso de trabajo), Alice realiza operaciones adicionales de <code>LOOKUP</code> y <code>OPEN</code> , por lo que el servidor devuelve un <code>stateid</code> diferente.  En v4.0, no env√≠a ning√∫n mensaje adicional.  Esto explica por qu√© Alice ve contenido desactualizado: usa un descriptor antiguo. </p><br><p>  ¬øPor qu√© Alice de repente decide una <code>LOOKUP</code> extra?  Aparentemente, el retiro de la delegaci√≥n fue exitoso, pero aparentemente se mantuvo alg√∫n problema.  Por ejemplo, se omite el paso de discapacidad.  Para verificar esto, excluimos la delegaci√≥n NFS en el servidor NFS con este comando: </p><br><pre> <code class="plaintext hljs">echo 0 &gt; /proc/sys/fs/leases-enable</code> </pre> <br><p>  Repetimos el experimento, pero el problema no desapareci√≥.  Nos aseguramos de que el problema no estuviera en el servidor NFS o en la delegaci√≥n, y decidimos mirar el cliente NFS en el n√∫cleo. </p><br><h2 id="kopaem-glubzhe-linux-nfs-klient">  Profundizando: cliente NFS de Linux </h2><br><p>  La primera pregunta que tuvimos que responder a los mantenedores de NFS fue: </p><br><h3 id="eta-problema-sohranyaetsya-v-posledney-versii-yadra">  ¬øEste problema persiste en la √∫ltima versi√≥n del kernel? </h3><br><p>  El problema ocurri√≥ en los n√∫cleos CentOS 7.2 y Ubuntu 16.04 con las versiones 3.10.0-862.11.6 y 4.4.0-130, respectivamente.  Pero ambos n√∫cleos se quedaron atr√°s de la √∫ltima versi√≥n, que en ese momento era 4.19-rc2. </p><br><p>  Implementamos la nueva m√°quina virtual Ubuntu 16.04 en Google Cloud Platform (GCP), clonamos el √∫ltimo kernel de Linux y configuramos el entorno de desarrollo del kernel.  Creamos el archivo <code>.config</code> usando <code>menuconfig</code> y verificamos que: </p><br><ol><li>  El controlador NFS se compila como un m√≥dulo ( <code>CONFIG_NFSD=m</code> ). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los par√°metros</a> correctos del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">n√∫cleo GCP</a> se especifican correctamente. </li></ol><br><p>  La gen√©tica rastrea la evoluci√≥n en tiempo real por Drosophila, y con el primer elemento pudimos hacer r√°pidamente correcciones al cliente NFS sin reiniciar el n√∫cleo.  El segundo punto garantiza que el n√∫cleo se iniciar√° despu√©s de la instalaci√≥n.  Afortunadamente, est√°bamos satisfechos con los par√°metros predeterminados del kernel. </p><br><p>  Nos aseguramos de que el problema del archivo obsoleto no desapareciera en la √∫ltima versi√≥n del kernel.  Nos preguntamos a nosotros mismos: </p><br><ol><li>  ¬øD√≥nde surge exactamente el problema? </li><li>  ¬øPor qu√© sucede esto en NFS v4.0, pero no en v4.1? </li></ol><br><p>  Para responder a estas preguntas, profundizamos en el c√≥digo fuente NFS.  No ten√≠amos un depurador del n√∫cleo, por lo que enviamos dos tipos de llamadas al c√≥digo fuente: </p><br><ol><li>  <code>pr_info()</code> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>   printk</code></a> ). </li><li>  <code>dump_stack()</code> : muestra el seguimiento de la pila para la llamada a la funci√≥n actual. </li></ol><br><p>  Por ejemplo, lo primero que hicimos fue conectarnos a la funci√≥n <code>nfs4_file_open()</code> en <code>fs/nfs/nfs4file.c</code> : </p><br><pre> <code class="plaintext hljs">static int nfs4_file_open(struct inode *inode, struct file *filp) { ... pr_info("nfs4_file_open start\n"); dump_stack();</code> </pre> <br><p>  Por supuesto, podr√≠amos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>  dprintk</code> con la depuraci√≥n din√°mica de Linux</a> o usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>rpcdebug</code></a> , pero quer√≠amos agregar nuestros propios mensajes para verificar los cambios. </p><br><p>  Despu√©s de cada cambio, recompilamos el m√≥dulo y lo reinstalamos en el kernel usando los comandos: </p><br><pre> <code class="plaintext hljs">make modules sudo umount /mnt/nfs-test sudo rmmod nfsv4 sudo rmmod nfs sudo insmod fs/nfs/nfs.ko sudo mount -a</code> </pre> <br><p>  Con el m√≥dulo NFS, pudimos repetir experimentos y recibir mensajes para comprender el c√≥digo NFS.  Por ejemplo, puede ver de inmediato lo que sucede cuando la aplicaci√≥n llama a <code>open()</code> : </p><br><pre> <code class="plaintext hljs">Sep 24 20:20:38 test-kernel kernel: [ 1145.233460] Call Trace: Sep 24 20:20:38 test-kernel kernel: [ 1145.233462] dump_stack+0x8e/0xd5 Sep 24 20:20:38 test-kernel kernel: [ 1145.233480] nfs4_file_open+0x56/0x2a0 [nfsv4] Sep 24 20:20:38 test-kernel kernel: [ 1145.233488] ? nfs42_clone_file_range+0x1c0/0x1c0 [nfsv4] Sep 24 20:20:38 test-kernel kernel: [ 1145.233490] do_dentry_open+0x1f6/0x360 Sep 24 20:20:38 test-kernel kernel: [ 1145.233492] vfs_open+0x2f/0x40 Sep 24 20:20:38 test-kernel kernel: [ 1145.233493] path_openat+0x2e8/0x1690 Sep 24 20:20:38 test-kernel kernel: [ 1145.233496] ? mem_cgroup_try_charge+0x8b/0x190 Sep 24 20:20:38 test-kernel kernel: [ 1145.233497] do_filp_open+0x9b/0x110 Sep 24 20:20:38 test-kernel kernel: [ 1145.233499] ? __check_object_size+0xb8/0x1b0 Sep 24 20:20:38 test-kernel kernel: [ 1145.233501] ? __alloc_fd+0x46/0x170 Sep 24 20:20:38 test-kernel kernel: [ 1145.233503] do_sys_open+0x1ba/0x250 Sep 24 20:20:38 test-kernel kernel: [ 1145.233505] ? do_sys_open+0x1ba/0x250 Sep 24 20:20:38 test-kernel kernel: [ 1145.233507] __x64_sys_openat+0x20/0x30 Sep 24 20:20:38 test-kernel kernel: [ 1145.233508] do_syscall_64+0x65/0x130</code> </pre> <br><p>  ¬øQu√© son estas <code>vfs_open</code> <code>do_dentry_open</code> y <code>vfs_open</code> ?  Linux tiene un sistema de archivos virtual ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">VFS</a> ), una capa de abstracci√≥n que proporciona una interfaz com√∫n para todos los sistemas de archivos.  La documentaci√≥n de VFS dice: </p><br><blockquote>  VFS implementa open (2), stat (2), chmod (2) y otras llamadas al sistema.  El sistema VFS utiliza el argumento del nombre de ruta que se les pasa para buscar entradas de directorio en el cach√© (dentry cache o dcache).  Esto proporciona un motor de b√∫squeda muy r√°pido que convierte el nombre de la ruta (o el nombre del archivo) en un dentry espec√≠fico.  Dentry reside en la RAM y nunca se guarda en el disco; existen solo para el rendimiento. </blockquote><br><h3 id="i-nas-osenilo--a-chto-esli-problema-v-dentry-keshe">  Y nos dimos cuenta: ¬øqu√© pasa si el problema est√° en el cach√© de dentry? </h3><br><p>  Notamos que el cach√© de dentry generalmente se verifica en <code>fs/nfs/dir.c</code>  Est√°bamos especialmente interesados ‚Äã‚Äãen la funci√≥n <code>nfs4_lookup_revalidate()</code> , y como experimento, lo hicimos funcionar antes: </p><br><pre> <code class="plaintext hljs">diff --git a/fs/nfs/dir.cb/fs/nfs/dir.c index 8bfaa658b2c1..ad479bfeb669 100644 --- a/fs/nfs/dir.c +++ b/fs/nfs/dir.c @@ -1159,6 +1159,7 @@ static int nfs_lookup_revalidate(struct dentry *dentry, unsigned int flags) trace_nfs_lookup_revalidate_enter(dir, dentry, flags); error = NFS_PROTO(dir)-&gt;lookup(dir, &amp;dentry-&gt;d_name, fhandle, fattr, label); trace_nfs_lookup_revalidate_exit(dir, dentry, flags, error); + goto out_bad; if (error == -ESTALE || error == -ENOENT) goto out_bad; if (error)</code> </pre> <br><p>  Y en este experimento, ¬°no ocurri√≥ un problema de archivo obsoleto!  Finalmente, atacamos el camino. </p><br><p>  Para descubrir por qu√© el problema no ocurri√≥ en NFS v4.1, agregamos llamadas <code>pr_info()</code> a cada bloque <code>if</code> en esta funci√≥n.  Experimentamos con NFS v4.0 y v4.1 y encontramos una condici√≥n especial en la versi√≥n v4.1: </p><br><pre> <code class="plaintext hljs">if (NFS_SB(dentry-&gt;d_sb)-&gt;caps &amp; NFS_CAP_ATOMIC_OPEN_V1) { goto no_open; }</code> </pre> <br><p>  ¬øQu√© es <code>NFS_CAP_ATOMIC_OPEN_V1</code> ?  Este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parche del kernel</a> dice que esta es una caracter√≠stica de NFS v4.1, y el c√≥digo en <code>fs/nfs/nfs4proc.c</code> confirm√≥ que este par√°metro est√° en v4.1 pero no en v4.0: </p><br><pre> <code class="plaintext hljs">static const struct nfs4_minor_version_ops nfs_v4_1_minor_ops = { .minor_version = 1, .init_caps = NFS_CAP_READDIRPLUS | NFS_CAP_ATOMIC_OPEN | NFS_CAP_POSIX_LOCK | NFS_CAP_STATEID_NFSV41 | NFS_CAP_ATOMIC_OPEN_V1</code> </pre> <br><p>  Por lo tanto, las versiones se comportaron de manera diferente: en v4.1, <code>goto no_open</code> llama a m√°s comprobaciones en la funci√≥n <code>nfs_lookup_revalidate()</code> , y en v4.0 la funci√≥n <code>nfs4_lookup_revalidate()</code> regresa antes.  ¬øY c√≥mo resolvimos el problema? </p><br><h2 id="reshenie">  Soluci√≥n </h2><br><p>  Habl√© sobre nuestros <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hallazgos en la lista de correo NFS</a> y suger√≠ un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parche primitivo</a> .  Una semana despu√©s, Trond Myklebust <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">envi√≥ una serie de parches con correcciones de errores a la lista de correo y encontr√≥ otro problema relacionado en NFS v4.1</a> . </p><br><p>  Resulta que la soluci√≥n para el error NFS v4.0 era m√°s profunda en la base del c√≥digo de lo que pens√°bamos.  Trond lo describi√≥ bien en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parche</a> : </p><br><blockquote>  Es necesario asegurarse de que el inodo y la dentry est√©n correctamente verificados dos veces cuando se abre un archivo ya abierto.  En este momento no estamos verificando dos veces NFSv4.0, porque el archivo abierto est√° en cach√©.  Arreglemos esto y guardemos en cach√© los archivos abiertos solo en casos especiales: para restaurar los archivos abiertos y devolver la delegaci√≥n. </blockquote><p>  Nos aseguramos de que esta soluci√≥n resolviera el problema del archivo obsoleto y enviara informes de errores a los equipos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ubuntu</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RedHat</a> . </p><br><p>  Entendemos bien que los cambios a√∫n no se realizar√≠an en la versi√≥n estable del kernel, por lo que agregamos una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">soluci√≥n temporal a este problema en Gitaly</a> .  Experimentamos y verificamos que llamar a <code>stat()</code> en el archivo de <code>packed-refs</code> hace que el n√∫cleo verifique dos veces el archivo renombrado en el cach√© de dentry.  Para simplificar, implementamos esto en Gitaly para cualquier sistema de archivos, no solo NFS.  La validaci√≥n se realiza solo una vez antes de que Gitaly abra el repositorio, y para otros archivos ya hay otras llamadas <code>stat()</code> . </p><br><h2 id="chemu-my-nauchilis">  Que hemos aprendido </h2><br><p>  Un error puede ocultarse en cualquier rinc√≥n de la pila de software y, a veces, debe buscarlo fuera de la aplicaci√≥n.  Si tiene conexiones √∫tiles en el mundo de c√≥digo abierto, esto facilitar√° su trabajo. </p><br><p>  Muchas gracias a Trond Myuklebust por solucionar el problema, y ‚Äã‚Äãa Bruce Fields por responder nuestras preguntas y ayudarnos a resolver NFS.  Es por tal capacidad de respuesta y profesionalismo que valoramos la comunidad de desarrolladores de c√≥digo abierto. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es432922/">https://habr.com/ru/post/es432922/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es432910/index.html">Es peligroso considerar la realidad virtual como una m√°quina para la empat√≠a.</a></li>
<li><a href="../es432912/index.html">C√≥mo obtener una pasant√≠a en Google</a></li>
<li><a href="../es432914/index.html">Un bot de chat muy simple para Telegram para los m√°s peque√±os.</a></li>
<li><a href="../es432918/index.html">Lo siento, romp√≠ tu recovery.conf</a></li>
<li><a href="../es432920/index.html">El factor humano en la empresa: ¬øes peligroso?</a></li>
<li><a href="../es432924/index.html">Run, Gecko, run: un mecanismo de movimiento de agua h√≠brido gecko</a></li>
<li><a href="../es432926/index.html">24 recetas sobre c√≥mo una startup puede tener √©xito en una gran exposici√≥n mundial, utilizando la Web Summit 2018 como ejemplo</a></li>
<li><a href="../es432928/index.html">Lo que est√° sucediendo en Intel y por qu√© Amazon no transferir√° AWS por completo a sus chips a pesar de los fuertes titulares</a></li>
<li><a href="../es432930/index.html">Explotar el mi√©rcoles de diciembre de 2018: para probar los nuevos momentos, condujeron ...</a></li>
<li><a href="../es432932/index.html">Ecosistema del mundo de compras digitales (para robar menos)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>