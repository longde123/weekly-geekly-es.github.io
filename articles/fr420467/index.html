<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëó üå∂Ô∏è üöµüèø Enveloppeur C ++ pour "tous" les syst√®mes d'exploitation en temps r√©el pour CortexM4 ü¶è ü§ôüèº üë®üèº‚Äçüíª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J'ai d√©j√† expliqu√© comment utiliser FreeRtos pour des projets √©crits en C ++ dans l'article STM32, C ++ et FreeRTOS. D√©veloppement √† partir de z√©ro. P...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Enveloppeur C ++ pour "tous" les syst√®mes d'exploitation en temps r√©el pour CortexM4</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420467/"><img src="https://habrastorage.org/webt/s0/2o/ve/s02ovegatxm9x39z6c8x_5fydki.png" alt="image"><br><br>  J'ai d√©j√† expliqu√© comment utiliser FreeRtos pour des projets √©crits en C ++ dans l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">STM32, C ++ et FreeRTOS.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©veloppement √† partir de z√©ro.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a>  Depuis lors, pas moins de 3 ans se sont √©coul√©s, j'ai s√©rieusement vieilli, perdu un tas de connexions neuronales, j'ai donc d√©cid√© de secouer les vieux jours afin de r√©tablir ces connexions et de balayer le wrapper pour "n'importe quel" RTOS populaire.  C'est bien s√ªr une blague, j'ai d√©lib√©r√©ment mis ¬´tout le monde¬ª entre guillemets, mais il y a du vrai dans chaque blague. <br><a name="habracut"></a><br>  Alors, quelle est la t√¢che et pourquoi est-elle pertinente du tout?  Pour le moment, il y a un million de syst√®mes d'exploitation diff√©rents √©crits en C - je ne veux pas choisir pour tous les go√ªts, pay√©, gratuit, petit, grand ... Mais pour les projets auxquels je participe, toutes ces puces de diff√©rents syst√®mes d'exploitation ne sont pas n√©cessaires, les fonctionnalit√©s de base telles qu'une t√¢che suffisent , √©v√©nements, notification de t√¢che, section critique, mutex et s√©maphores (bien que j'essaie de ne pas les utiliser), files d'attente.  Et tout cela est n√©cessaire sous une forme assez simple, sans fioritures. <br><br>  √Ä mon avis, l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>OSRV MAX</b></a> domestique, √©crit en C ++, convient parfaitement √† mes projets et c'est un plaisir de l'utiliser. <br><br>  Mais le hic, c'est que nos appareils doivent √™tre conformes √† la norme IEC_61508, dont l'une des exigences est l' <i>application E.29 de biblioth√®que cible √©prouv√©e</i> .  Eh bien, ou en termes simples, si vous fabriquez un appareil pour atteindre le niveau <u>SIL3</u> , veuillez (sup√©rieur recommand√©) utiliser des biblioth√®ques qui correspondent √† ce niveau et sont test√©es dans le temps. <br><br>  En ce qui concerne notre t√¢che, cela signifie qu'il est possible d'utiliser le <b>MAX MAX RTOS</b> pour de tels appareils, mais aucun point de fiabilit√© ne sera ajout√©.  Par cons√©quent, les fabricants de RTOS fabriquent des versions sp√©ciales de leurs syst√®mes d'exploitation qui sont conformes aux normes CEI_61508, par exemple, <i>FreeRTOS</i> a un clone <i>SafeRTOS</i> et <i>embOs</i> a un clone <i>embOS-Safe</i> , bien s√ªr, les fabricants gagnent beaucoup d'argent √† ce sujet, car les licences pour ces syst√®mes d'exploitation co√ªtent plusieurs milliers, voire des dizaines mille dollars. <br><br>  √Ä propos, un bon exemple est le compilateur IAR, dont la licence co√ªte environ 1500 $, mais les versions certifi√©es IAR co√ªtent d√©j√† environ 10000 dollars, bien que j'aie v√©rifi√© plusieurs projets - le fichier de sortie de la version sans certificat et avec certificat est compl√®tement identique.  Eh bien, vous comprenez que vous devez payer pour la paix. <br><br>  Donc, nous avons d'abord utilis√© <i>un syst√®me d'exploitation</i> , puis j'ai commenc√© √† utiliser <i>FreeRTOS</i> pour mes besoins, puis nous sommes pass√©s √† <i>un autre</i> , en g√©n√©ral, nous avons constamment d√ª r√©√©crire le code fini.  De plus, je voudrais que ce soit beau et simple, afin que tout le monde puisse comprendre par le code ce qui se passe, alors le support du code sera un travail simple pour les √©tudiants et les praticiens, et les gourous pourront continuer √† travailler sur des appareils innovants, plut√¥t que de comprendre la pile de nouilles .  En g√©n√©ral, je veux voir quelque chose comme √ßa fossilis√©: <br><br><img src="https://habrastorage.org/webt/rc/2z/_k/rc2z_kzdcpu6isdhwojtbbi4wac.png" alt="image"><br><br>  Eh bien, ou tel ... <br><br><img src="https://habrastorage.org/webt/f7/li/48/f7li48lkaylpglvyjr-tiekmxai.png" alt="image"><br><br>  Par cons√©quent, j'ai d√©cid√© d'√©crire un wrapper qui conviendrait aux deux <i>FreeRTOS</i> , et de dire <i>embOS,</i> eh bien, pour tout le monde aussi :) et pour commencer j'ai d√©termin√© ce dont j'avais besoin pour un bonheur complet: <br><br><ul><li>  Les t√¢ches </li><li>  Sections critiques </li><li>  √âv√©nements et notification de t√¢che </li><li>  S√©maphores et mutex </li><li>  Files d'attente </li></ul><br>  L'encapsuleur doit √™tre id√©ologique <u>SIL3</u> , et ce niveau impose beaucoup de toutes sortes de choses High Recommended, et si vous les suivez compl√®tement, il s'av√®re qu'il vaut mieux ne pas √©crire du code du tout. <br><br>  Mais le fait que la norme r√©gisse un tas de r√®gles, ou plut√¥t de recommandations, ne signifie pas qu'elles ne peuvent pas √™tre viol√©es - vous pouvez, mais vous devez suivre autant de recommandations que possible pour obtenir plus de points.  Par cons√©quent, j'ai d√©cid√© de certaines limitations importantes: <br><br><ul><li>  <b>pas de macros</b> , enfin, sauf pour la protection contre la double inclusion des fichiers d'en-t√™te.  Les macros sont mauvaises, si vous calculez le temps pass√© √† rechercher des erreurs li√©es aux macros, il s'av√®re que l'univers n'est pas si vieux et combien de bien pourrait √™tre fait pendant cette p√©riode, il vaut probablement mieux les interdire au niveau l√©gislatif, comme les torrents l'ont interdit ou prenez un bonus pour chaque macro que vous √©crivez </li><li>  <b>n'utilisez pas de pointeurs</b> , bien s√ªr autant que possible.  On pourrait essayer de ne pas les utiliser du tout, mais il y a encore des endroits o√π sans eux, il n'y a aucun moyen.  Dans tous les cas, l'utilisateur du wrapper, si possible, ne devrait m√™me pas savoir ce qu'est un pointeur, car il n'en a entendu parler que par son grand-p√®re, car maintenant il travaille exclusivement avec des liens </li><li>  <b>ne pas utiliser l'allocation dynamique de m√©moire</b> - tout est clair, le simple fait d'utiliser un tas conduit, d'une part, √† la n√©cessit√© de r√©server de la RAM pour ce tas, et d'autre part, avec une utilisation fr√©quente du tas, il est d√©fragment√© et de nouveaux objets y sont cr√©√©s de plus en plus longtemps plus.  Par cons√©quent, en <i>fait,</i> j'ai configur√© <i>FreeRTOS</i> uniquement sur la m√©moire allou√©e statiquement en d√©finissant <i>configSUPPORT_STATIC_ALLOCATION 1</i> .  Mais si vous voulez travailler en mode par d√©faut.  Et par d√©faut, <i>FreeRTOS</i> utilise de la m√©moire allou√©e dynamiquement pour cr√©er des √©l√©ments de syst√®me d'exploitation; puis d√©finissez simplement <i>configSUPPORT_STATIC_ALLOCATION 0</i> , et <br>  <i>configSUPPORT_DYNAMIC_ALLOCATION 1</i> et n'oubliez pas de connecter l'impl√©mentation de vos propres Mallocs et Callocs √† partir du gestionnaire de m√©moire, par exemple, ce fichier est FreeRtos / portable / MemMang / heap_1.c.  Mais gardez √† l'esprit que vous devrez allouer de la RAM avec une r√©serve pour un groupe, car vous ne pourrez pas calculer la quantit√© exacte de RAM n√©cessaire, avec tous les param√®tres (inactif est activ√©, la t√¢che du minuteur du programme est activ√©e, mes deux t√¢ches, les files d'attente, la taille de la file d'attente pour les minuteurs 10 et ainsi de suite, disons que ce ne sont certainement pas les param√®tres les plus optimaux) qui ont fonctionn√© lorsque j'ai allou√© la m√©moire comme ceci: <br><blockquote>  7 357 octets de m√©moire de code en lecture seule <br>  535 octets de m√©moire de donn√©es en lecture seule <br>  6 053 octets de m√©moire de donn√©es en lecture-√©criture </blockquote><br>  L'allocation de m√©moire statique est ¬´un peu¬ª plus compacte: <br><blockquote>  7 329 octets de m√©moire de code en lecture seule <br>  535 octets de m√©moire de donn√©es en lecture seule <br>  3 877 octets de m√©moire de donn√©es en lecture-√©criture </blockquote><br>  Vous pourriez penser, "g√©nial ... vous-m√™me", mais maintenant nous ne sommes pas int√©ress√©s par la question formul√©e dans l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"J'ai allou√© jusqu'√† 3 Ko au syst√®me d'exploitation et lanc√© seulement 3 t√¢ches avec une pile de 128 Go, et pour une raison quelconque, il n'y a d√©j√† pas assez de m√©moire pour le quatri√®me"</a> , Dans cette situation, je l'ai fait expr√®s, pour plus de clart√©, pour montrer la diff√©rence entre l'allocation de m√©moire dynamique et statique avec les m√™mes param√®tres. <br></li><li>  si possible, <b>ne lancez pas de types</b> .  Les types fant√¥mes en d'autres types en eux-m√™mes signifient le fait que quelque chose ne va pas dans la conception, mais comme d'habitude, parfois vous devez toujours le convertir pour plus de commodit√© (par exemple, l'√©num√©ration doit √™tre cast√©e en nombres entiers), et parfois vous ne pouvez pas vous en passer cela, mais cela doit √™tre √©vit√©. </li><li>  <b>simplicit√© et commodit√©</b> .  Pour l'utilisateur de l'emballage, toutes les difficult√©s doivent √™tre cach√©es, donc sa vie n'est pas de l'huile, et il ne veut pas encore la compliquer - il a cr√©√© la t√¢che, mis en ≈ìuvre tout ce qui est n√©cessaire, d√©marr√© et parti pour profiter de la vie. </li></ul><br>  Nous allons partir de l√†, donc nous nous sommes donn√© pour t√¢che de cr√©er une t√¢che (il s‚Äôest av√©r√© √™tre directement issu de la s√©rie ¬´interdit d‚Äôinterdire¬ª). <br><br><h2>  Cr√©ation de t√¢che </h2><br>  Par de longues recherches, des scientifiques britanniques ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Toute la v√©rit√© sur RTOS de Colin Walls. Article # 4. T√¢ches, changement de contexte et interruptions</a> ) (√† propos, si vous ne le saviez pas, l'assembleur pour ARM a √©galement √©t√© invent√© par un scientifique britannique, quelque chose que je n'ai pas √©t√© surpris non plus une fois :)), et ainsi les scientifiques britanniques ont d√©couvert que pour la majorit√© de "tous" les RTOS, la t√¢che a un <i>nom</i> , une <i>pile</i> , <i>une taille de pile</i> , une <i>"unit√© de contr√¥le"</i> , un <i>identifiant ou un pointeur vers une "unit√© de contr√¥le"</i> , une <i>priorit√©</i> , une <i>fonction qui est ex√©cut√©e dans la t√¢che</i> .  C'est tout, et il √©tait possible de tout ranger dans une classe, mais c'√©tait bien si nous √©crivions un syst√®me d'exploitation avec vous, mais nous faisons un wrapper, donc cela n'a aucun sens de stocker toutes ces choses dans un wrapper, tout cela sera <u>fait</u> pour vous par le <u>syst√®me d'</u> exploitation id√©ologique <u>SIL3</u> nous terminons.  En fait, nous avons seulement besoin d'une <i>fonction qui est ex√©cut√©e dans la t√¢che</i> et d'une <i>structure qui stocke ¬´l'unit√© de contr√¥le¬ª</i> , qui est remplie lors de la cr√©ation de la t√¢che et de <i>l'identifiant de la t√¢che</i> .  Par cons√©quent, la classe de t√¢ches, appelons-la <i>Thread,</i> peut sembler tr√®s simple: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thread</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: tTaskHandle taskHandle ; tTaskContext context ; } ;</code> </pre> <br>  Je veux simplement d√©clarer la classe de ma t√¢che o√π je pourrais impl√©menter tout ce qui est n√©cessaire, puis passer le pointeur vers l'objet de cette classe √† l'encapsuleur, ce qui cr√©erait une t√¢che √† l'aide de l'API RTOS o√π il lancerait la m√©thode <i>Execute ()</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyTask</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Thread { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//do something.. } } ; using tMyTaskStack = std::array&lt;OsWrapper::tStack, static_cast&lt;tU16&gt;(OsWrapper::StackDepth::minimal)&gt; ; inline static tMyTaskStack Stack; //!C++17 } ; MyTask myDesiredTask int main() { Rtos::CreateThread(myTask, MyTask::Stack.data(), "myTask") ; }</span></span></code> </pre> <br>  Dans "tous" RTOS, pour que la t√¢che soit cr√©√©e, il faut passer un pointeur vers une fonction qui sera lanc√©e par le planificateur.  Dans notre cas, il s'agit de la fonction <i>Execute ()</i> , mais je ne peux pas passer de pointeur vers cette m√©thode, car elle n'est pas statique.  Par cons√©quent, nous regardons comment une t√¢che est cr√©√©e dans l'API de "tous" les OS et notons que nous pouvons cr√©er une t√¢che en passant un param√®tre √† la fonction de t√¢che, par exemple, pour <i>embOS</i> ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OS_TASK_CreateEx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( OS_TASK* pTask, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* pName, OS_PRIO Priority, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*pRoutine)(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pVoid ), </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> OS_STACKPTR *pStack, OS_UINT StackSize, OS_UINT TimeSlice, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* pContext)</span></span></span></span>;</code> </pre><br>  <b>void * pContext</b> - c'est la cl√© de la solution.  Ayons une m√©thode statique, un pointeur vers lequel nous passerons comme pointeur vers une m√©thode appel√©e par l'ordonnanceur, et comme param√®tre nous passerons un pointeur vers un objet de type <i>Thread</i> o√π nous pourrons appeler directement la m√©thode <i>Execute ()</i> .  C'est exactement le moment o√π il n'y a aucun moyen sans pointeur et transtyp√© en types, mais ce code sera cach√© √† l'utilisateur: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pContext )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Thread*&gt;(pContext)-&gt;Execute() ; }</code> </pre> <br>  C'est-√†-dire  un tel algorithme d'op√©ration, le planificateur lance la m√©thode <i>Run</i> , un pointeur vers un objet de type <i>Thread</i> est pass√© √† la m√©thode <i>Run</i> .  La m√©thode <i>Run</i> appelle directement la m√©thode <i>Execute ()</i> , un objet sp√©cifique de la classe <i>Thread</i> , qui n'est que notre impl√©mentation de la t√¢che. <br><br>  Le probl√®me est presque r√©solu, nous devons maintenant impl√©menter les m√©thodes.  Tous les syst√®mes d'exploitation ont des API diff√©rentes, donc pour impl√©menter, par exemple, la fonction de cr√©ation de t√¢ches pour <i>embOS,</i> vous devez appeler la <i>m√©thode</i> void <i>OS_TASK_CreateEx (..)</i> , et pour <i>FreeRTOS</i> en mode d'allocation de m√©moire dynamique, il s'agit de <i>xTaskCreate (..)</i> et bien qu'ils aient une seule et m√™me essence m√™me, mais la syntaxe et les param√®tres sont diff√©rents.  Mais nous ne voulons pas parcourir les fichiers et √©crire du code pour chacune des m√©thodes de la classe √† chaque fois pour un nouveau syst√®me d'exploitation, nous devons donc en quelque sorte mettre cela dans un seul fichier et ... l'ex√©cuter sous forme de macros.  G√©nial, mais arr√™tez, je me suis interdit les macros - j'ai besoin d'une approche diff√©rente. <br><br>  La chose la plus simple qui m'est venue √† l'esprit √©tait de cr√©er un fichier s√©par√© pour chaque syst√®me d'exploitation avec des fonctions en ligne.  Si nous voulons utiliser un autre syst√®me d'exploitation, nous aurons juste besoin d'impl√©menter chacune de ces fonctions √† l'aide de l'API de ce syst√®me d'exploitation.  Le fichier <b>rtosFreeRtos.cpp</b> suivant s'est av√©r√© <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"rtos.hpp"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//For FreeRTOS functions prototypes #include &lt;FreeRTOS.h&gt; //For xTaskCreate #include &lt;task.h&gt; namespace OsWrapper { void wCreateThread(Thread &amp; thread, const char * pName, ThreadPriority prior,const tU16 stackDepth, tStack *pStack) { #if (configSUPPORT_STATIC_ALLOCATION == 1) if (pStack != nullptr) { thread.handle = xTaskCreateStatic(static_cast&lt;TaskFunction_t&gt;(Rtos::Run), pName, stackDepth, &amp;thread, static_cast&lt;uint32_t&gt;(prior), pStack, &amp;thread.taskControlBlock); } #else thread.handle = (xTaskCreate(static_cast&lt;TaskFunction_t&gt;(Rtos::Run), pName, stackDepth, &amp;thread, static_cast&lt;uint32_t&gt;(prior), &amp;thread.handle) == pdTRUE) ? thread.handle : nullptr ; #endif }</span></span></span></span></code> </pre><br>  Le fichier pour embOS <b>rtosEmbOS.cpp</b> peut avoir exactement la <b>m√™me</b> apparence <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"rtos.hpp"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//For embOS functions prototypes #include &lt;rtos.h&gt; namespace OsWrapper { void wCreateThread(Thread &amp;thread, const char * pName, ThreadPriority prior,const tU16 stackDepth, tStack *pStack) { constexpr OS_UINT timeSliceNull = 0 ; if (pStack != nullptr) { OS_CreateTaskEx(&amp;(thread.handle), pName, static_cast&lt;OS_PRIO&gt;(prior), Rtos::Run, pStack, ((stackSize == 0U) ? sizeof(pStack) : stackSize), timeSliceNull, &amp;thread) ; } }</span></span></span></span></code> </pre> <br>  Les types de syst√®mes d'exploitation diff√©rents sont √©galement diff√©rents, en particulier la structure du contexte de t√¢che, alors cr√©ons le fichier rtosdefs.hpp avec nos propres alias d'encapsuleur. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;FreeRTOS.h&gt; //For TaskHandle_t namespace OsWrapper { using tTaskContext = StaticTask_t; using tTaskHandle = TaskHandle_t; using tStack = StackType_t ; }</span></span></span></span></code> </pre><br>  Pour <i>EmbOS,</i> cela pourrait ressembler √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;rtos.h&gt; //For OS_TASK namespace OsWrapper { using tTaskContext = OS_TASK; using tTaskHandle = OS_TASK; using tStack = tU16 //   void,      tU16 ; }</span></span></span></span></code> </pre><br>  Par cons√©quent, pour une modification sous n'importe quel autre RTOS, il suffit d'effectuer des modifications uniquement dans ces deux fichiers rtosdefs.cpp et rtos.cpp.  Maintenant, les classes <i>Thread</i> et <i>Rtos</i> ressemblent √† des images c <br><br><img src="https://habrastorage.org/webt/gp/wq/zl/gpwqzlgnristquzlrcdbxyfm9ro.png" alt="image"><br><br><h2>  Lancement des OS et finalisation de la t√¢che </h2><br>  Pour Cortex M4, ¬´tous¬ª les syst√®mes d'exploitation utilisent 3 interruptions, <i>minuterie de tick</i> <i>syst√®me, appel de service syst√®me via l'instruction SWI</i> , <i>demande d'interruption de service syst√®me en attente</i> , qui ont √©t√© principalement invent√©es pour le RTOS.  Certains RTOS utilisent √©galement d'autres interruptions syst√®me, mais celles-ci seront suffisantes pour la plupart des "tous" OS.  Et sinon, il sera possible d'ajouter, il suffit donc de d√©finir trois gestionnaires pour ces interruptions et pour d√©marrer le RTOS nous avons besoin d'une autre m√©thode de d√©marrage: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleSvcInterrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleSvInterrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleSysTickInterrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>;</code> </pre><br>  La premi√®re chose dont j'avais besoin et sans laquelle je ne peux pas vivre, je r√™ve d'un m√©canisme de notification des t√¢ches.  J'aime g√©n√©ralement la programmation bas√©e sur les √©v√©nements, j'ai donc besoin d'impl√©menter rapidement un wrapper pour notifier les t√¢ches. <br><br>  Tout s'est av√©r√© √™tre assez simple, tout syst√®me d'exploitation peut le faire, sauf peut <i>-</i> √™tre <i>uc-OS-II</i> et <i>III</i> , bien que je ne l'ai peut-√™tre pas bien lu, mais, √† mon avis, le m√©canisme des √©v√©nements est g√©n√©ralement d√©licat, mais bon, "tout" est le reste ils le peuvent certainement. <br><br>  Afin de notifier la t√¢che, il vous suffit d'envoyer l'√©v√©nement non pas au vide, mais sp√©cifiquement √† la t√¢che, pour cela, la m√©thode de notification doit avoir un pointeur vers le contexte de la t√¢che ou l'identifiant de la t√¢che.  Je viens de les stocker dans la classe <i>Thread</i> , ce qui signifie que la classe Thread devrait √©galement avoir une m√©thode d'alerte.  Il devrait √©galement y avoir une m√©thode pour attendre une alerte.  En m√™me temps, nous ajoutons la m√©thode <i>Sleep (..)</i> , qui suspend l'ex√©cution de la t√¢che appelante.  Maintenant, les deux classes ressemblent √† ceci: <br><br><img src="https://habrastorage.org/webt/ie/r_/35/ier_35fgsut4a_gf_ismmm91tuk.png" alt="image"><br><br><div class="spoiler">  <b class="spoiler_title">rtos.hpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/******************************************************************************* * Filename : Rtos.hpp * * Details : Rtos class is used to create tasks, work with special Rtos * functions and also it contains a special static method Run. In this method * the pointer on Thread should be pass. This method is input point as * the task of Rtos. In the body of the method, the method of concrete Thread * will run. *******************************************************************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __RTOS_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __RTOS_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"thread.hpp"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// for Thread #include "../../Common/susudefs.hpp" #include "FreeRtos/rtosdefs.hpp" namespace OsWrapper { extern void wCreateThread(Thread &amp;, const char *, ThreadPriority, const tU16, tStack *) ; extern void wStart() ; extern void wHandleSvcInterrupt() ; extern void wHandleSvInterrupt() ; extern void wHandleSysTickInterrupt() ; extern void wEnterCriticalSection(); extern void wLeaveCriticalSection(); class Rtos { public: static void CreateThread(Thread &amp;thread , tStack * pStack = nullptr, const char * pName = nullptr, ThreadPriority prior = ThreadPriority::normal, const tU16 stackDepth = static_cast&lt;tU16&gt;(StackDepth::minimal)) ; static void Start() ; static void HandleSvcInterrupt() ; static void HandleSvInterrupt() ; static void HandleSysTickInterrupt() ; friend void wCreateThread(Thread &amp;, const char *, ThreadPriority, const tU16, tStack *); private: //cstat !MISRAC++2008-7-1-2 To prevent reinterpet_cast in the CreateTask static void Run(void *pContext ) { static_cast&lt;Thread*&gt;(pContext)-&gt;Execute() ; } } ; } ; #endif // __RTOS_HPP</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">thread.hpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/******************************************************************************* * Filename : thread.hpp * * Details : Base class for any Taskis which contains the pure virtual * method Execute(). Any active classes which will have a method for running as * a task of RTOS should inherit the Thread and override the Execute() method. * For example: * class MyTask : public OsWrapper::Thread * { * public: * virtual void Execute() override { * while(true) { * //do something.. * } * } ; * *******************************************************************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __THREAD_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __THREAD_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FreeRtos/rtosdefs.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../../Common/susudefs.hpp"</span></span></span><span class="hljs-meta"> namespace OsWrapper { extern void wSleep(const tTime) ; extern void wSleepUntil(tTime &amp;, const tTime) ; extern tTime wGetTicks() ; extern void wSignal(tTaskHandle const &amp;, const tTaskEventMask) ; extern tTaskEventMask wWaitForSignal(const tTaskEventMask, tTime) ; constexpr tTaskEventMask defaultTaskMaskBits = 0b010101010 ; enum class ThreadPriority { clear = 0, lowest = 10, belowNormal = 20, normal = 30, aboveNormal = 80, highest = 90, priorityMax = 255 } ; enum class StackDepth: tU16 { minimal = 128U, medium = 256U, big = 512U, biggest = 1024U }; class Thread { public: virtual void Execute() = 0 ; inline tTaskHandle GetTaskHanlde() const { return handle; } static void Sleep(const tTime timeOut = 1000ms) { wSleep(timeOut) ; }; inline void Signal(const tTaskEventMask mask = defaultTaskMaskBits) { wSignal(handle, mask); }; inline tTaskEventMask WaitForSignal(tTime timeOut = 1000ms, const tTaskEventMask mask = defaultTaskMaskBits) { return wWaitForSignal(mask, timeOut) ; } friend void wCreateThread(Thread &amp;, const char *, ThreadPriority, const tU16, tStack *); private: tTaskHandle handle ; tTaskContext context ; } ; } ; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// __THREAD_HPP</span></span></span></span></code> </pre><br></div></div><br>  J'ai commenc√© √† l'impl√©menter, et ici le premier probl√®me m'attendait, il s'av√®re que ¬´tout¬ª OS appelle ses fonctions √† partir d'interruptions de diff√©rentes mani√®res.  Par exemple, <i>FreeRTOS</i> a des impl√©mentations sp√©ciales de fonctions pour les ex√©cuter √† partir d'interruptions, par exemple, s'il existe une fonction <i>xTaskNotify (..)</i> , vous ne pouvez pas l'appeler √† partir d'une interruption, mais vous devez appeler <i>xTaskNotifyFromISR (..)</i> . <br>  Pour <i>embOS,</i> si vous appelez une fonction √† partir d'une interruption, veuillez utiliser <i>OS_InInterrupt ()</i> lors de la saisie d'une interruption et <i>OS_LeaveInterrupt ()</i> lors de la fermeture.  J'ai d√ª cr√©er une classe <i>InterruptEntry</i> , qui n'a qu'un constructeur et un destructeur: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> OsWrapper { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wEnterInterrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wLeaveInterrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InterruptEntry</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InterruptEntry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ wEnterInterrupt() ; } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> ~InterruptEntry() { wLeaveInterrupt() ; } } ; } ;</code> </pre> <br>  Vous pouvez l'utiliser comme ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Button::HandleInterrupt() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OsWrapper::InterruptEntry ie; EXTI-&gt;PR = EXTI_PR_PR13 ; myDesiredTask.Signal(); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> myDesiredTask::Execute() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WaitForSignal(<span class="hljs-number"><span class="hljs-number">100000</span></span>ms) == defaultTaskMaskBits) { GPIOC-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; } } } ;</code> </pre> <br>  √âvidemment, pour <i>FreeRTOS,</i> le constructeur et le destructeur seront vides.  Et pour la notification, vous pouvez utiliser la fonction <i>xTaskNotifyFromISR (..)</i> , qui, peu importe d'o√π elle est appel√©e, est un peu plus lourde, mais ce que vous ne pouvez pas faire dans un souci d'universalit√©.  Vous pouvez bien s√ªr cr√©er des m√©thodes distinctes pour appeler √† partir d'interruptions, mais pour l'instant j'ai d√©cid√© de le faire universellement. <br>  La m√™me astuce qu'avec <i>InterruptEntry</i> peut √™tre effectu√©e avec la section critique: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> OsWrapper{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CriticalSection</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CriticalSection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ wEnterCriticalSection() ; } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> ~CriticalSection() { wLeaveCriticalSection() ; } } ; } ;</code> </pre> <br>  Maintenant, ajoutez simplement l'impl√©mentation de fonctions √† l'aide de l'API <i>FreeRtos</i> au fichier et ex√©cutez la v√©rification, bien que vous ne puissiez pas l'ex√©cuter, il est donc clair que cela fonctionnera :) <br><div class="spoiler">  <b class="spoiler_title">rtosFreeRtos.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/******************************************************************************* * Filename : rtosFreeRtos.cpp * * Details : This file containce implementation of functions of concrete * FreeRTOS to support another RTOS create the same file with the * same functions but another name&lt; for example rtosEmbOS.cpp and * implement these functions using EmbOS API. * *******************************************************************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../thread.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../mutex.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../rtos.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../../../Common/susudefs.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"rtosdefs.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../event.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;limits&gt; namespace OsWrapper { /***************************************************************************** * Function Name: wCreateThread * Description: Creates a new task and passes a parameter to the task. The * function should call appropriate RTOS API function to create a task. * * Assumptions: RTOS API create task function should get a parameter to pass the * paramete to task. * Some RTOS does not use pStack pointer so it should be set to nullptr * * Parameters: [in] thread - refernce on Thread object * [in] pName - name of task * [in] prior - task priority * [in] stackDepth - size of Stack * [in] pStack - pointer on task stack * Returns: No ****************************************************************************/ void wCreateThread(Thread &amp; thread, const char * pName, ThreadPriority prior, const tU16 stackDepth, tStack *pStack) { #if (configSUPPORT_STATIC_ALLOCATION == 1) if (pStack != nullptr) { thread.handle = xTaskCreateStatic(static_cast&lt;TaskFunction_t&gt;(Rtos::Run), pName, stackDepth, &amp;thread, static_cast&lt;uint32_t&gt;(prior), pStack, &amp;thread.context); } #else thread.handle = (xTaskCreate(static_cast&lt;TaskFunction_t&gt;(Rtos::Run), pName, stackDepth, &amp;thread, static_cast&lt;uint32_t&gt;(prior), &amp;thread.handle) == pdTRUE) ? thread.handle : nullptr ; #endif } /***************************************************************************** * Function Name: wStart() * Description: Starts the RTOS scheduler * * Assumptions: No * Parameters: No * Returns: No ****************************************************************************/ void wStart() { vTaskStartScheduler() ; } /***************************************************************************** * Function Name: wHandleSvcInterrupt() * Description: Handle of SVC Interrupt. The function should call appropriate * RTOS function to handle the interrupt * * Assumptions: No * Parameters: No * Returns: No ****************************************************************************/ void wHandleSvcInterrupt() { vPortSVCHandler() ; } /***************************************************************************** * Function Name: wHandleSvInterrupt() * Description: Handle of SV Interrupt. The function should call appropriate * RTOS function to handle the interrupt * * Assumptions: No * Parameters: No * Returns: No ****************************************************************************/ void wHandleSvInterrupt() { xPortPendSVHandler() ; } /***************************************************************************** * Function Name: wHandleSysTickInterrupt() * Description: Handle of System Timer Interrupt. The function should call * appropriate RTOS function to handle the interrupt * * Assumptions: No * Parameters: No * Returns: No ****************************************************************************/ void wHandleSysTickInterrupt() { xPortSysTickHandler() ; } /***************************************************************************** * Function Name: wSleep() * Description: Suspends the calling task for a specified period of time, * or waits actively when called from main() * * Assumptions: No * Parameters: [in] timeOut - specifies the time interval in system ticks * Returns: No ****************************************************************************/ void wSleep(const tTime timeOut) { vTaskDelay(timeOut) ; } /***************************************************************************** * Function Name: wEnterCriticalSection() * Description: Basic critical section implementation that works by simply * disabling interrupts * * Assumptions: No * Parameters: No * Returns: No ****************************************************************************/ void wEnterCriticalSection() { taskENTER_CRITICAL() ; } /***************************************************************************** * Function Name: wLeaveCriticalSection() * Description: Leave critical section implementation that works by simply * enabling interrupts * * Assumptions: No * Parameters: No * Returns: No ****************************************************************************/ void wLeaveCriticalSection() { taskEXIT_CRITICAL() ; } /**************************************************************************** * Function Name: wEnterInterrupt() * Description: Some RTOS requires to inform the kernel that interrupt code * is executing * * Assumptions: No * Parameters: No * Returns: No ****************************************************************************/ void wEnterInterrupt() { } /**************************************************************************** * Function Name: wLeaveInterrupt() * Description: Some RTOS requires to inform that the end of the interrupt r * outine has been reached; executes task switching within ISR * * Assumptions: No * Parameters: No * Returns: No ****************************************************************************/ void wLeaveInterrupt() { } /**************************************************************************** * Function Name: wSignal() * Description: Signals event(s) to a specified task * * Assumptions: No * Parameters: [in] taskHandle - Reference to the task structure * [in] mask - The event bit mask containing the event bits, * which shall be signaled. * Returns: No ****************************************************************************/ void wSignal(tTaskHandle const &amp;taskHandle, const tTaskEventMask mask) { BaseType_t xHigherPriorityTaskWoken = pdFALSE ; xTaskNotifyFromISR(taskHandle, mask, eSetBits, &amp;xHigherPriorityTaskWoken) ; portYIELD_FROM_ISR( xHigherPriorityTaskWoken ) ; } /**************************************************************************** * Function Name: wWaitForSignal() * Description: Waits for the specified events for a given time, and clears * the event memory when the function returns * * Assumptions: No * Parameters: [in] mask - The event bit mask containing the event bits, * which shall be waited for * [in] timeOut - Maximum time in system ticks waiting for events * to be signaled. * Returns: Set bits ****************************************************************************/ tTaskEventMask wWaitForSignal(const tTaskEventMask mask, tTime timeOut) { uint32_t ulNotifiedValue = 0U ; xTaskNotifyWait( 0U, std::numeric_limits&lt;uint32_t&gt;::max(), &amp;ulNotifiedValue, timeOut); return (ulNotifiedValue &amp; mask) ; } /**************************************************************************** * Function Name: wCreateEvent() * Description: Create an Event object * * Assumptions: No * Parameters: [in] event - reference on tEvent object * * Returns: Handle of created Event ****************************************************************************/ tEventHandle wCreateEvent(tEvent &amp;event) { #if (configSUPPORT_STATIC_ALLOCATION == 1) return xEventGroupCreateStatic(&amp;event); #else return xEventGroupCreate(); #endif } /**************************************************************************** * Function Name: wDeleteEvent() * Description: Create an Event object * * Assumptions: No * Parameters: [in] eventHandle - reference on tEventHandle object * * Returns: No ****************************************************************************/ void wDeleteEvent(tEventHandle &amp;eventHandle) { vEventGroupDelete(eventHandle); } /**************************************************************************** * Function Name: wSignalEvent() * Description: Sets an resumes tasks which are waiting at the event object * * Assumptions: No * Parameters: [in] event - reference on eventHandle object * [in] mask - The event bit mask containing the event bits, * which shall be signaled * * Returns: No ****************************************************************************/ void wSignalEvent(tEventHandle const &amp;eventHandle, const tEventBits mask) { BaseType_t xHigherPriorityTaskWoken = pdFALSE; xEventGroupSetBitsFromISR(eventHandle, mask, &amp;xHigherPriorityTaskWoken) ; portYIELD_FROM_ISR(xHigherPriorityTaskWoken) ; } /**************************************************************************** * Function Name: wWaitEvent() * Description: Waits for an event and suspends the task for a specified time * or until the event has been signaled. * * Assumptions: No * Parameters: [in] event - Reference on eventHandle object * [in] mask - The event bit mask containing the event bits, * which shall be signaled * [in] timeOut - Maximum time in RTOS system ticks until the * event must be signaled. * [in] mode - Indicate mask bit behaviour * * Returns: Set bits ****************************************************************************/ tEventBits wWaitEvent(tEventHandle const &amp;eventHandle, const tEventBits mask, const tTime timeOut, OsWrapper::EventMode mode) { BaseType_t xWaitForAllBits = pdFALSE ; if (mode == OsWrapper::EventMode::waitAnyBits) { xWaitForAllBits = pdFALSE; } return xEventGroupWaitBits(eventHandle, mask, pdTRUE, xWaitForAllBits, timeOut) ; } /**************************************************************************** * Function Name: wCreateMutex() * Description: Create an mutex. Mutexes are used for managing resources by * avoiding conflicts caused by simultaneous use of a resource. The resource * managed can be of any kind: a part of the program that is not reentrant, a * piece of hardware like the display, a flash prom that can only be written to * by a single task at a time, a motor in a CNC control that can only be * controlled by one task at a time, and a lot more. * * Assumptions: No * Parameters: [in] mutex - Reference on tMutex structure * [in] mode - Indicate mask bit behaviour * * Returns: Mutex handle ****************************************************************************/ tMutexHandle wCreateMutex(tMutex &amp;mutex) { #if (configSUPPORT_STATIC_ALLOCATION == 1) return xSemaphoreCreateMutexStatic(&amp;mutex) ; #else return xSemaphoreCreateMutex(); #endif } /**************************************************************************** * Function Name: wDeleteMutex() * Description: Delete the mutex. * * Assumptions: No * Parameters: [in] mutex - handle of mutex * * Returns: Mutex handle ****************************************************************************/ void wDeleteMutex(tMutexHandle &amp;handle) { vSemaphoreDelete(handle) ; } /**************************************************************************** * Function Name: wLockMutex() * Description: Claim the resource * * Assumptions: No * Parameters: [in] handle - handle of mutex * [in] timeOut - Maximum time until the mutex should be available * * Returns: true if resource has been claimed, false if timeout is expired ****************************************************************************/ bool wLockMutex(tMutexHandle const &amp;handle, tTime timeOut) { return static_cast&lt;bool&gt;(xSemaphoreTake(handle, timeOut)) ; } /**************************************************************************** * Function Name: wUnLockMutex() * Description: Releases a mutex currently in use by a task * * Assumptions: No * Parameters: [in] handle - handle of mutex * * Returns: No ****************************************************************************/ void wUnLockMutex(tMutexHandle const &amp;handle) { BaseType_t xHigherPriorityTaskWoken = pdFALSE ; xSemaphoreGiveFromISR(handle, &amp;xHigherPriorityTaskWoken) ; portYIELD_FROM_ISR( xHigherPriorityTaskWoken ) ; } /**************************************************************************** * Function Name: wSleepUntil() * Description: Suspends the calling task until a specified time, or waits * actively when called from main() * * Assumptions: No * Parameters: [in] last - Refence to a variable that holds the time at which * the task was last unblocked. The variable must be initialised * with the current time prior to its first use * [in] timeOut - Time to delay until, the task will be unblocked * at time * * Returns: No ****************************************************************************/ void wSleepUntil(tTime &amp; last, const tTime timeOut) { vTaskDelayUntil( &amp;last, timeOut) ; } /**************************************************************************** * Function Name: wGetTicks() * Description: Returns the current system time in ticks as a native integer * value * * Assumptions: No * Parameters: No * * Returns: Current system time in ticks ****************************************************************************/ tTime wGetTicks() { return xTaskGetTickCount(); } }</span></span></span></span></code> </pre><br></div></div><br><img src="https://habrastorage.org/webt/4a/sm/mm/4asmmm71hosjm510maad5hcadrm.png" alt="image"><br><br><h2>  Nous continuons d'affiner la t√¢che </h2><br>  La t√¢che a maintenant presque tout ce dont vous avez besoin, nous avons ajout√© la m√©thode Sleep ().  Cette m√©thode interrompt la t√¢che pendant une dur√©e sp√©cifi√©e.  Dans la plupart des cas, cela suffit, mais si vous avez besoin d'une heure clairement d√©termin√©e, Sleep () peut vous poser des probl√®mes.  Par exemple, vous souhaitez effectuer un calcul et faire clignoter la LED et le faire exactement une fois toutes les 100 ms <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MyTask::Execute() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { DoCalculation(); <span class="hljs-comment"><span class="hljs-comment">//It takes about 10ms Led1.Toggle() ; Sleep(100ms) ; } }</span></span></code> </pre><br>  Ce code fera clignoter une LED toutes les 110 ms.  Mais vous voulez une fois toutes les 100 ms, vous pouvez calculer approximativement le temps de calcul et mettre Sleep (90ms).  Mais que faire si le temps de calcul d√©pend des param√®tres d'entr√©e, alors le clignotement ne sera pas du tout d√©terministe.  Pour de tels cas dans "tous" les OS, il existe des m√©thodes sp√©ciales, telles que DelayUntil ().  Cela fonctionne sur ce principe - vous devez d'abord vous souvenir de la valeur actuelle du compteur de ticks du syst√®me d'exploitation, puis ajouter √† cette valeur le nombre de ticks pour lesquels vous devez interrompre la t√¢che, d√®s que le compteur de ticks atteint cette valeur, la t√¢che est d√©verrouill√©e.  Ainsi, la t√¢che sera verrouill√©e exactement √† la valeur que vous avez d√©finie et votre LED clignotera exactement toutes les 100 ms, quelle que soit la dur√©e du calcul. <br>  Ce m√©canisme est impl√©ment√© diff√©remment dans diff√©rents syst√®mes d'exploitation, mais il a un algorithme.  En cons√©quence, le m√©canisme, disons, impl√©ment√© sur FreeRTOS, sera simplifi√© √† l'√©tat montr√© dans l'image suivante: <br><br><img src="https://habrastorage.org/webt/tg/n1/hb/tgn1hba-pczt2p5b0dzy0kut-ua.png" alt="image"><br><br>  Comme vous pouvez le voir, la lecture de l'√©tat initial du compteur de ticks du syst√®me d'exploitation se produit avant d'entrer dans une boucle infinie, et nous devons trouver quelque chose pour l'impl√©menter.  Un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mod√®le de</a> conception vient √† la rescousse.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est impl√©ment√© tr√®s simplement, nous avons juste besoin d'ajouter une autre m√©thode non virtuelle, o√π nous appelons d'abord la m√©thode qui lit et se souvient du compteur de ticks du syst√®me d'exploitation, puis nous appelons la m√©thode virtuelle Execute (), qui sera impl√©ment√©e dans le descendant, c'est-√†-dire </font><font style="vertical-align: inherit;">dans la mise en ≈ìuvre de votre t√¢che. </font><font style="vertical-align: inherit;">Comme nous n'avons pas besoin que cette m√©thode ressorte pour l'utilisateur (c'est juste une m√©thode auxiliaire), nous la cacherons dans la section priv√©e.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thread</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rtos</span></span></span><span class="hljs-class"> ;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ lastWakeTime = wGetTicks() ; Execute(); } ... tTime lastWakeTime = <span class="hljs-number"><span class="hljs-number">0</span></span>ms ; ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par cons√©quent, dans la m√©thode Run statique de la classe Rtos, il sera d√©sormais n√©cessaire d'appeler non pas la m√©thode Execute (), mais la m√©thode Run () de l'objet Thread. </font><font style="vertical-align: inherit;">Nous venons de rendre la classe Rtos conviviale afin d'acc√©der √† la m√©thode Run () priv√©e dans la classe Thread.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pContext )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Thread*&gt;(pContext)-&gt;Run() ; }</code> </pre><br>     <i>SleepUntil()</i> ,          .  ,           ,         ,     <i>SleepUntil()</i> ,        .        : <br><img src="https://habrastorage.org/webt/aw/nx/ts/awnxtsvd-odgyfaagkl3egc_tvs.png" alt="image"><br><br><div class="spoiler"> <b class="spoiler_title">thread.hpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/******************************************************************************* * Filename : thread.hpp * * Details : Base class for any Taskis which contains the pure virtual * method Execute(). Any active classes which will have a method for running as * a task of RTOS should inherit the Thread and override the Execute() method. * For example: * class MyTask : public OsWrapper::Thread * { * public: * virtual void Execute() override { * while(true) { * //do something.. * } * } ; * * Author : Sergey Kolody *******************************************************************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __THREAD_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __THREAD_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FreeRtos/rtosdefs.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../../Common/susudefs.hpp"</span></span></span><span class="hljs-meta"> namespace OsWrapper { extern void wSleep(const tTime) ; extern void wSleepUntil(tTime &amp;, const tTime) ; extern tTime wGetTicks() ; extern void wSignal(tTaskHandle const &amp;, const tTaskEventMask) ; extern tTaskEventMask wWaitForSignal(const tTaskEventMask, tTime) ; constexpr tTaskEventMask defaultTaskMaskBits = 0b010101010 ; enum class ThreadPriority { clear = 0, lowest = 10, belowNormal = 20, normal = 30, aboveNormal = 80, highest = 90, priorityMax = 255 } ; enum class StackDepth: tU16 { minimal = 128U, medium = 256U, big = 512U, biggest = 1024U }; class Thread { public: virtual void Execute() = 0 ; inline tTaskHandle GetTaskHanlde() const { return handle; } static void Sleep(const tTime timeOut = 1000ms) { wSleep(timeOut) ; }; void SleepUntil(const tTime timeOut = 1000ms) { wSleepUntil(lastWakeTime, timeOut); }; inline void Signal(const tTaskEventMask mask = defaultTaskMaskBits) { wSignal(handle, mask); }; inline tTaskEventMask WaitForSignal(tTime timeOut = 1000ms, const tTaskEventMask mask = defaultTaskMaskBits) { return wWaitForSignal(mask, timeOut) ; } friend void wCreateThread(Thread &amp;, const char *, ThreadPriority, const tU16, tStack *); friend class Rtos ; private: tTaskHandle handle ; tTaskContext context ; tTime lastWakeTime = 0ms ; void Run() { lastWakeTime = wGetTicks() ; Execute(); } } ; } ; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// __THREAD_HPP</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">rtos.hpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/******************************************************************************* * Filename : Rtos.hpp * * Details : Rtos class is used to create tasks, work with special Rtos * functions and also it contains a special static method Run. In this method * the pointer on Thread should be pass. This method is input point as * the task of Rtos. In the body of the method, the method of concrete Thread * will run. *******************************************************************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __RTOS_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __RTOS_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"thread.hpp"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// for Thread #include "../../Common/susudefs.hpp" #include "FreeRtos/rtosdefs.hpp" namespace OsWrapper { extern void wCreateThread(Thread &amp;, const char *, ThreadPriority, const tU16, tStack *) ; extern void wStart() ; extern void wHandleSvcInterrupt() ; extern void wHandleSvInterrupt() ; extern void wHandleSysTickInterrupt() ; extern void wEnterCriticalSection(); extern void wLeaveCriticalSection(); class Rtos { public: static void CreateThread(Thread &amp;thread , tStack * pStack = nullptr, const char * pName = nullptr, ThreadPriority prior = ThreadPriority::normal, const tU16 stackDepth = static_cast&lt;tU16&gt;(StackDepth::minimal)) ; static void Start() ; static void HandleSvcInterrupt() ; static void HandleSvInterrupt() ; static void HandleSysTickInterrupt() ; friend void wCreateThread(Thread &amp;, const char *, ThreadPriority, const tU16, tStack *); friend class Thread ; private: //cstat !MISRAC++2008-7-1-2 To prevent reinterpet_cast in the CreateTask static void Run(void *pContext ) { static_cast&lt;Thread*&gt;(pContext)-&gt;Run() ; } } ; } ; #endif // __RTOS_HPP</span></span></span></span></code> </pre><br></div></div><br><br><h2>  Les √©v√©nements </h2><br>  , ,    ,    ,      ,   ,     .  ,     . <br><br>         ,     ,        ,    ,     ,         ,     ,             . ,          .      ,      ,     ,            ,        . <br><br><img src="https://habrastorage.org/webt/gv/na/8k/gvna8ktlrzvrposxbpwhzpn0keq.png"><br><br>    : <br><br><pre> <code class="cpp hljs">OsWrapper::Event event{<span class="hljs-number"><span class="hljs-number">10000</span></span>ms, <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//  ,    10000ms,    0    1. void SomeTask::Execute() { while(true) { using OsWrapper::operator""ms ; Sleep(1000ms); event.Signal() ; //      0   1. Sleep(1000ms); event.SetMaskBits(4) //    2. event.Signal() ; //      2. } } ; void AnotherTask::Execute() { while(true) { using namespace::OsWrapper ; //,      ,    10000ms if ((event.Wait() &amp; defaultTaskMaskBits) != 0) { GPIOC-&gt;ODR ^= (1 &lt;&lt; 5) ; } } } ;</span></span></code> </pre><br><br><h2> ,    </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au d√©but, lorsque j'√©crivais cet article, je ne les avais pas encore mis en ≈ìuvre, mais comme je l'avais promis, j'ai d√©velopp√© des mutex et des bo√Ætes de messagerie, la source se trouve ici: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub OsWrapper</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Voici un exemple d'utilisation d'une bo√Æte aux lettres:</font></font><br><pre> <code class="cpp hljs">OsWrapper::MailBox&lt;tU32, <span class="hljs-number"><span class="hljs-number">10</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    10   int void ReceiveTask::Execute() { tU32 item; while(true) { using OsWrapper::operator""ms ; if (queue.Get(item, 10000ms)) { //    GPIOC-&gt;ODR ^= (1 &lt;&lt; 9); } } } ; void SendTask::Execute() { tU32 item = 0U; while(true) { queue.Put(item); item ++; SleepUntil(1000ms); } } ;</span></span></code> </pre><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comment utiliser toutes ces affaires </font></font></h2><br>  ,       ,     ,   :  <i>LedTask</i> ,     2  ,    2     <i>myTask</i> ,   10  ,    ,    .          2 .      ,     <i>event</i> .      ,     :) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> OsWrapper::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span><span class="hljs-string"><span class="hljs-string">""</span></span>ms ; OsWrapper::Event event{<span class="hljs-number"><span class="hljs-number">10000</span></span>ms, <span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyTask</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OsWrapper::Thread { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event.Wait() != <span class="hljs-number"><span class="hljs-number">0</span></span>) { GPIOC-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">9</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> tMyTaskStack = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;OsWrapper::tStack, <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU16&gt;(OsWrapper::StackDepth::minimal)&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> tMyTaskStack Stack; <span class="hljs-comment"><span class="hljs-comment">//C++17   IAR 8.30 } ; class LedTask : public OsWrapper::Thread { public: virtual void Execute() override { while(true) { GPIOC-&gt;ODR ^= (1 &lt;&lt; 5) ; using OsWrapper::operator""ms ; SleepUntil(2000ms); event.Signal() ; } } using tLedStack = std::array&lt;OsWrapper::tStack, static_cast&lt;tU16&gt;(OsWrapper::StackDepth::minimal)&gt; ; inline static tLedStack Stack; //C++17   IAR 8.30 } ; MyTask myTask; LedTask ledTask; int main() { using namespace OsWrapper ; Rtos::CreateThread(myTask, MyTask::Stack.data(), "myTask", ThreadPriority::lowest, MyTask::Stack.size()) ; Rtos::CreateThread(ledTask, LedTask::Stack.data()) ; Rtos::Start(); return 0; }</span></span></code> </pre> <br><br><h2>  Conclusion </h2><br>           . ,    ++           ++ .          ++. <br>         ,   ++, ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b> </b></a> ,      ,    ,         ,    ,    .         ,       . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais en attendant, la plupart d'entre nous utilisent des OS Sishna traditionnels, vous pouvez utiliser le wrapper comme un d√©but initial pour la transition vers un avenir heureux avec C ++ :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai mis en place un petit projet de test dans </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clion</font></font></a> .     ,           ,      IAR toolchain,   ,  ,   elf ,   hex , ,      GDB.     ‚Äî   ,     ,      ,    2 ,      ,   ,    ,      .     ,     Clion.     ,   IAR toolchain ,  . <br><br>      IAR       8.30.1,        .   : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">XNUCLEO-F411RE</a> ,  ST-Link.   ,  ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Clion</a> ‚Äî   ,    :) <br><br><img src="https://habrastorage.org/webt/tx/m_/e8/txm_e8pms1viazgy6cypd-kjj3q.png" alt="image"><br><br>   <i>IAR</i>    : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  IAR 8.30.1</a>    ,    ,      github,   ,        ,               FreeRtos. <br><br>  Z.Y.      GitHub <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr420467/">https://habr.com/ru/post/fr420467/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr420457/index.html">Pr√©sentation du logiciel d'impression 3D Simplify3D</a></li>
<li><a href="../fr420459/index.html">Ic√¥ne avec un compteur dans la barre d'outils sup√©rieure: un exemple d'une vari√©t√© d'approches pour une t√¢che</a></li>
<li><a href="../fr420461/index.html">10 citations de mauvais designers</a></li>
<li><a href="../fr420463/index.html">ICO √† juste titre en d√©clin, mais ils ont une chance de changer</a></li>
<li><a href="../fr420465/index.html">Variables Nginx avec njs: simples, indolores et via JavaScript</a></li>
<li><a href="../fr420469/index.html">Caract√©ristiques de l'utilisation de Druid sur l'exemple des camarades de classe</a></li>
<li><a href="../fr420471/index.html">Trois rapports techniques RIT 2018 par Plesk</a></li>
<li><a href="../fr420473/index.html">Livres pour cadres d√©butants ou pourquoi il est si important de lire</a></li>
<li><a href="../fr420475/index.html">Comparaison des machines de d√©coupe laser Raylogic 11G et Raylogic V12</a></li>
<li><a href="../fr420477/index.html">Revue HyperX Cloud Stinger Core: un casque de personnage l√©ger et robuste</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>