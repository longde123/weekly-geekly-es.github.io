<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïµÔ∏è üë¶üèª üì¢ Conceptos b√°sicos de la arquitectura de aplicaciones de Flutter: vainilla, modelo con alcance, BLoC üë±üèø ‚õÑÔ∏è üôä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="(art√≠culo original publicado en ingl√©s en medio ) 


 Flutter proporciona un marco receptivo moderno, un gran conjunto de widgets y herramientas. Pero...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Conceptos b√°sicos de la arquitectura de aplicaciones de Flutter: vainilla, modelo con alcance, BLoC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438574/"><p><img src="https://habrastorage.org/webt/2j/2p/yu/2j2pyudr-kde4fqeczqoic_9lpq.png"></p><br><p>  (art√≠culo original publicado en ingl√©s en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">medio</a> ) </p><br><p>  Flutter proporciona un marco receptivo moderno, un gran conjunto de widgets y herramientas.  Pero, desafortunadamente, la documentaci√≥n no es como una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">gu√≠a de la arquitectura recomendada de la aplicaci√≥n de Android</a> . </p><br><p>  No existe una arquitectura universal ideal que pueda ajustarse a los requisitos concebibles de una tarea t√©cnica, pero admitamos que la mayor√≠a de las aplicaciones m√≥viles en las que estamos trabajando tienen la siguiente funcionalidad: </p><br><ol><li>  Solicitar y descargar datos. </li><li>  Transformaci√≥n y preparaci√≥n de datos para el usuario. </li><li>  Escribir y leer datos de una base de datos o sistema de archivos. </li></ol><br><p> Dado todo esto, cre√© una aplicaci√≥n de demostraci√≥n que resuelve el mismo problema utilizando diferentes enfoques de arquitectura. <a name="habracut"></a></p><br><p>  Inicialmente, se muestra al usuario una pantalla con un bot√≥n "Cargar datos del usuario" ubicado en el centro.  Cuando el usuario hace clic en el bot√≥n, se produce una carga de datos asincr√≥nica y el bot√≥n se reemplaza por un indicador de carga.  Cuando se completa la descarga de datos, el indicador de descarga se reemplaza por datos. </p><br><p>  Entonces comencemos. </p><br><p><img src="https://habrastorage.org/webt/c5/by/8g/c5by8gjmz_oov-ukuy4_dwo4njs.gif"></p><br><h2 id="dannye">  Datos </h2><br><p> Para simplificar la tarea, cre√© la clase <code>Repository</code> , que contiene el m√©todo <code>getUser()</code> .  Este m√©todo simula la carga as√≠ncrona de datos desde la red y devuelve <code>Future&lt;User&gt;</code> . </p><br><p>  Si no est√° familiarizado con Futures y la programaci√≥n asincr√≥nica en Dart, podemos leer m√°s sobre esto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> y leer la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n de la clase Future</a> . </p><br><pre> <code class="plaintext hljs">class Repository { Future&lt;User&gt; getUser() async { await Future.delayed(Duration(seconds: 2)); return User(name: 'John', surname: 'Smith'); } }</code> </pre> <br><pre> <code class="plaintext hljs">class User { User({ @required this.name, @required this.surname, }); final String name; final String surname; }</code> </pre> <br><h2 id="vanilla">  Vainilla </h2><br><p>  Desarrollemos la aplicaci√≥n, como lo har√≠a un desarrollador si leyera la documentaci√≥n de Flutter en el sitio web oficial. </p><br><p>  Abra la pantalla <code>VanillaScreen</code> usando <code>Navigator</code> </p><br><pre> <code class="plaintext hljs">Navigator.push( context, MaterialPageRoute( builder: (context) =&gt; VanillaScreen(_repository), ), );</code> </pre> <br><p>  Dado que el estado de un widget puede cambiar varias veces durante su ciclo de vida, debemos heredarlo de <code>StatefulWidget</code> .  Para implementar su widget con estado, tambi√©n necesita la clase <code>State</code> .  Los <code>bool _isLoading</code> y <code>User _user</code> en la clase <code>_VanillaScreenState</code> representan el estado del widget.  Ambos campos se inicializan antes de que se llame por primera vez al m√©todo <code>build(BuildContext context)</code> . </p><br><pre> <code class="plaintext hljs">class VanillaScreen extends StatefulWidget { VanillaScreen(this._repository); final Repository _repository; @override State&lt;StatefulWidget&gt; createState() =&gt; _VanillaScreenState(); } class _VanillaScreenState extends State&lt;VanillaScreen&gt; { bool _isLoading = false; User _user; @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Vanilla'), ), body: SafeArea( child: _isLoading ? _buildLoading() : _buildBody(), ), ); } Widget _buildBody() { if (_user != null) { return _buildContent(); } else { return _buildInit(); } } Widget _buildInit() { return Center( child: RaisedButton( child: const Text('Load user data'), onPressed: () { setState(() { _isLoading = true; }); widget._repository.getUser().then((user) { setState(() { _user = user; _isLoading = false; }); }); }, ), ); } Widget _buildContent() { return Center( child: Text('Hello ${_user.name} ${_user.surname}'), ); } Widget _buildLoading() { return const Center( child: CircularProgressIndicator(), ); } }</code> </pre> <br><p>  Despu√©s de crear el objeto de estado del widget, se llama al m√©todo <code>build(BuildContext context)</code> para construir la IU.  Todas las decisiones sobre qu√© widget debe mostrarse en la pantalla se toman directamente en el c√≥digo de declaraci√≥n de UI. </p><br><pre> <code class="plaintext hljs">body: SafeArea( child: _isLoading ? _buildLoading() : _buildBody(), )</code> </pre> <br><p>  Para mostrar un indicador de progreso, cuando el usuario hace clic en el bot√≥n "Cargar detalles del usuario", hacemos lo siguiente. </p><br><pre> <code class="plaintext hljs">setState(() { _isLoading = true; });</code> </pre> <br><p>  De la documentaci√≥n (traducci√≥n): </p><br><blockquote>  Una llamada al m√©todo setState () notifica al marco que el estado interno de este objeto ha cambiado y puede afectar la interfaz de usuario en el sub√°rbol.  Esta es la raz√≥n por la que el marco llama al m√©todo de compilaci√≥n en este objeto de estado. </blockquote><p>  Esto significa que despu√©s de llamar al m√©todo <code>setState()</code> , el marco volver√° a llamar al m√©todo <code>build(BuildContext context)</code> , que <strong>recrear√° todo el √°rbol de widgets</strong> .  Dado que el valor del campo <code>_isLoading</code> cambiado a <code>true</code> , en lugar del m√©todo <code>_buildLoading()</code> , se llamar√° al m√©todo <code>_buildLoading()</code> y se mostrar√° un indicador de progreso en la pantalla. <br>  Exactamente lo mismo suceder√° cuando recibamos una devoluci√≥n de llamada de <code>getUser()</code> y llamemos al m√©todo <br>  <code>setState()</code> para asignar nuevos valores a los campos <code>_isLoading</code> y <code>_user</code> . </p><br><pre> <code class="plaintext hljs">widget._repository.getUser().then((user) { setState(() { _user = user; _isLoading = false; }); });</code> </pre> <br><h3 id="plyusy">  Pros </h3><br><ol><li>  Umbral de entrada bajo. </li><li>  No se requieren bibliotecas de terceros. </li></ol><br><h3 id="minusy">  Contras </h3><br><ol><li>  Cuando el estado del widget cambia, el √°rbol de widgets se recrea completamente cada vez. </li><li>  Viola el principio de responsabilidad exclusiva.  El widget es responsable no solo de crear la interfaz de usuario, sino tambi√©n de cargar datos, l√≥gica de negocios y gesti√≥n de estado. </li><li>  Las decisiones sobre c√≥mo mostrar el estado actual se toman directamente en el c√≥digo de la interfaz de usuario.  Si el estado se vuelve m√°s complejo, la legibilidad del c√≥digo disminuir√° considerablemente. </li></ol><br><h2 id="scoped-model">  Modelo de alcance </h2><br><p>  Scoped Model es una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">biblioteca de terceros</a> .  As√≠ es como los desarrolladores lo describen: </p><br><blockquote>  Un conjunto de utilidades que le permiten transferir el modelo de datos del widget ancestro a todos sus descendientes.  Adem√°s de esto, cuando los datos del modelo cambien, todos los descendientes que usen el modelo ser√°n recreados.  Esta biblioteca fue tomada originalmente del c√≥digo del proyecto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fuchsia</a> . </blockquote><p>  Creemos la misma pantalla que en el ejemplo anterior, pero usando el Modelo de alcance.  Primero, necesitamos agregar la biblioteca del Modelo Scoped al proyecto.  Agregue la dependencia <code>scoped_model</code> archivo <code>scoped_model</code> en la secci√≥n de <code>dependencies</code> . </p><br><pre> <code class="plaintext hljs">scoped_model: ^1.0.1</code> </pre> <br><p>  Echemos un vistazo al c√≥digo de <code>UserModelScreen</code> y comp√°relo con el ejemplo anterior, en el que no utilizamos el Modelo de alcance.  Para que nuestro modelo sea accesible para los descendientes del widget, necesitamos ajustar el widget y el modelo en <code>ScopedModel</code> . </p><br><pre> <code class="plaintext hljs">class UserModelScreen extends StatefulWidget { UserModelScreen(this._repository); final Repository _repository; @override State&lt;StatefulWidget&gt; createState() =&gt; _UserModelScreenState(); } class _UserModelScreenState extends State&lt;UserModelScreen&gt; { UserModel _userModel; @override void initState() { _userModel = UserModel(widget._repository); super.initState(); } @override Widget build(BuildContext context) { return ScopedModel( model: _userModel, child: Scaffold( appBar: AppBar( title: const Text('Scoped model'), ), body: SafeArea( child: ScopedModelDescendant&lt;UserModel&gt;( builder: (context, child, model) { if (model.isLoading) { return _buildLoading(); } else { if (model.user != null) { return _buildContent(model); } else { return _buildInit(model); } } }, ), ), ), ); } Widget _buildInit(UserModel userModel) { return Center( child: RaisedButton( child: const Text('Load user data'), onPressed: () { userModel.loadUserData(); }, ), ); } Widget _buildContent(UserModel userModel) { return Center( child: Text('Hello ${userModel.user.name} ${userModel.user.surname}'), ); } Widget _buildLoading() { return const Center( child: CircularProgressIndicator(), ); } }</code> </pre> <br><p>  En el ejemplo anterior, cada vez que un widget cambia de estado, el √°rbol de widgets se recrea nuevamente.  ¬øPero realmente necesitamos recrear todo el √°rbol de widgets (pantalla completa)?  Por ejemplo, la barra de aplicaciones no cambia en absoluto y no tiene sentido volver a crearla.  Idealmente, deber√≠a recrear solo aquellos widgets que deber√≠an cambiar de acuerdo con el cambio de estado.  Y el modelo de alcance puede ayudarnos a resolver este problema. </p><br><p>  El <code>ScopedModelDescendant&lt;UserModel&gt;</code> se usa para encontrar el <code>UserModel</code> en el √°rbol de widgets.  Se volver√° a crear autom√°ticamente cada vez que <code>UserModel</code> notifique que ha habido un cambio. </p><br><p>  Otra mejora es que <code>UserModelScreen</code> no es responsable de la administraci√≥n del estado, la l√≥gica empresarial y la carga de datos. </p><br><p>  Veamos el c√≥digo de la clase <code>UserModel</code> . </p><br><pre> <code class="plaintext hljs">class UserModel extends Model { UserModel(this._repository); final Repository _repository; bool _isLoading = false; User _user; User get user =&gt; _user; bool get isLoading =&gt; _isLoading; void loadUserData() { _isLoading = true; notifyListeners(); _repository.getUser().then((user) { _user = user; _isLoading = false; notifyListeners(); }); } static UserModel of(BuildContext context) =&gt; ScopedModel.of&lt;UserModel&gt;(context); }</code> </pre> <br><p>  <code>UserModel</code> ahora contiene y administra el estado.  Para notificar a los oyentes (y recrear descendientes) que se ha producido un cambio, debe llamar al m√©todo <code>notifyListeners()</code> . </p><br><h3 id="plyusy-1">  Pros </h3><br><ol><li>  La gesti√≥n del estado, la l√≥gica empresarial y la carga de datos son independientes del c√≥digo de la interfaz de usuario. </li><li>  Umbral de entrada bajo. </li></ol><br><h3 id="minusy-1">  Contras </h3><br><ol><li>  Dependencia de biblioteca de terceros. </li><li>  Si el modelo se vuelve lo suficientemente complejo, ser√° dif√≠cil hacer un seguimiento de cu√°ndo es realmente necesario llamar al m√©todo <code>notifyListeners()</code> para evitar recreaciones innecesarias. </li></ol><br><h2 id="bloc">  BLoC </h2><br><p>  BLoC (componentes de l√≥gica de negocio) es un patr√≥n recomendado por los desarrolladores de Google.  Las transmisiones se utilizan para administrar el estado y para notificar un cambio de estado. </p><br><p>  <strong>Para desarrolladores de Android:</strong> puedes imaginar que <code>Bloc</code> es un <code>ViewModel</code> y <code>StreamController</code> es un <code>LiveData</code> .  Esto har√° que el siguiente c√≥digo sea f√°cil de entender, ya que ya est√° familiarizado con los principios b√°sicos. </p><br><pre> <code class="plaintext hljs">class UserBloc { UserBloc(this._repository); final Repository _repository; final _userStreamController = StreamController&lt;UserState&gt;(); Stream&lt;UserState&gt; get user =&gt; _userStreamController.stream; void loadUserData() { _userStreamController.sink.add(UserState._userLoading()); _repository.getUser().then((user) { _userStreamController.sink.add(UserState._userData(user)); }); } void dispose() { _userStreamController.close(); } } class UserState { UserState(); factory UserState._userData(User user) = UserDataState; factory UserState._userLoading() = UserLoadingState; } class UserInitState extends UserState {} class UserLoadingState extends UserState {} class UserDataState extends UserState { UserDataState(this.user); final User user; }</code> </pre> <br><p>  El c√≥digo muestra que ya no es necesario llamar a m√©todos adicionales para notificar sobre cambios de estado. </p><br><p>  Cre√© 3 clases para representar posibles estados: </p><br><p>  <code>UserInitState</code> para el estado en el que el usuario abre una pantalla con un bot√≥n en el centro. </p><br><p>  <code>UserLoadingState</code> para el estado en el que se muestra el indicador de carga mientras se cargan los datos. </p><br><p>  <code>UserDataState</code> para el estado cuando los datos ya est√°n cargados y se muestran en la pantalla. </p><br><p>  Pasar el estado de esta manera nos permite deshacernos por completo de la l√≥gica en el c√≥digo de la interfaz de usuario.  En el ejemplo del Modelo con alcance, todav√≠a verificamos si el valor del campo <code>_isLoading</code> <code>true</code> o <code>false</code> para determinar qu√© widget crear.  En el caso de BLoC, pasamos el nuevo estado a la secuencia, y la √∫nica tarea del widget <code>UserBlocScreen</code> crear una interfaz de usuario para el estado actual. </p><br><pre> <code class="plaintext hljs">class UserBlocScreen extends StatefulWidget { UserBlocScreen(this._repository); final Repository _repository; @override State&lt;StatefulWidget&gt; createState() =&gt; _UserBlocScreenState(); } class _UserBlocScreenState extends State&lt;UserBlocScreen&gt; { UserBloc _userBloc; @override void initState() { _userBloc = UserBloc(widget._repository); super.initState(); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Bloc'), ), body: SafeArea( child: StreamBuilder&lt;UserState&gt;( stream: _userBloc.user, initialData: UserInitState(), builder: (context, snapshot) { if (snapshot.data is UserInitState) { return _buildInit(); } if (snapshot.data is UserDataState) { UserDataState state = snapshot.data; return _buildContent(state.user); } if (snapshot.data is UserLoadingState) { return _buildLoading(); } }, ), ), ); } Widget _buildInit() { return Center( child: RaisedButton( child: const Text('Load user data'), onPressed: () { _userBloc.loadUserData(); }, ), ); } Widget _buildContent(User user) { return Center( child: Text('Hello ${user.name} ${user.surname}'), ); } Widget _buildLoading() { return const Center( child: CircularProgressIndicator(), ); } @override void dispose() { _userBloc.dispose(); super.dispose(); } }</code> </pre> <br><p>  El c√≥digo para el widget <code>UserBlocScreen</code> es a√∫n m√°s simple que en los ejemplos anteriores.  Para escuchar los cambios de estado, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se</a> utiliza <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">StreamBuilder</a> .  <code>StreamBuilder</code> es un <code>StatefulWidget</code> que se crea de acuerdo con el √∫ltimo valor (Instant√°nea) de la secuencia ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Stream</a> ). </p><br><h3 id="plyusy-2">  Pros </h3><br><ol><li>  No se requieren bibliotecas de terceros. </li><li>  La l√≥gica empresarial, la gesti√≥n del estado y la carga de datos son independientes del c√≥digo de la interfaz de usuario. </li><li>  Reactividad  No es necesario llamar a m√©todos adicionales, como en el ejemplo con Scoped Model <code>notifyListeners()</code> . </li></ol><br><h3 id="minusy-2">  Contras </h3><br><ol><li>  El umbral de entrada es ligeramente m√°s alto.  Necesita experiencia con transmisiones o rxdart. </li></ol><br><h2 id="linki">  Enlaces </h2><br><p>  Puede leer el c√≥digo completo descarg√°ndolo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mi repositorio github</a> . </p><br><p>  Art√≠culo original publicado en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Medium</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/438574/">https://habr.com/ru/post/438574/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../438560/index.html">Escribir XGBoost desde cero - parte 1: √°rboles de decisi√≥n</a></li>
<li><a href="../438562/index.html">Escribir XGBoost desde cero - parte 2: aumento de gradiente</a></li>
<li><a href="../438566/index.html">Estuche para microprocesador Apple Strange A12X</a></li>
<li><a href="../438568/index.html">Acerca de las computadoras cu√°nticas: c√≥mo los diferentes pa√≠ses desarrollan esta tecnolog√≠a</a></li>
<li><a href="../438570/index.html">CS Center 2018 Competencia de Nochevieja</a></li>
<li><a href="../438576/index.html">C√≥digo abierto popular - tercera parte: 5 herramientas para desarrolladores</a></li>
<li><a href="../438578/index.html">C√≥mo el gigante de audio gigante de TI fue "burlado" por segunda vez</a></li>
<li><a href="../438580/index.html">Contrase√±as generadas autom√°ticamente en iOS 12</a></li>
<li><a href="../438582/index.html">AntiRating 2018</a></li>
<li><a href="../438584/index.html">Frontend para desarrolladores de backend</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>