<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìª ü•ó üëÜüèª Ext JS di server üöµüèº ü§ü üå≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ketika datang ke perpustakaan Ext JS, Anda harus mendengar cukup banyak hal negatif dari para pecinta: berat, mahal, kereta. Biasanya, sebagian besar ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ext JS di server</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431180/"><img src="https://habrastorage.org/webt/wl/0h/yu/wl0hyunbvr2q-wqwydwamsfk804.png" width="250" align="left" alt="foto dari sini https://github.com/tj/palette">  Ketika datang ke perpustakaan Ext JS, Anda harus mendengar cukup banyak hal negatif dari para pecinta: berat, mahal, kereta.  Biasanya, sebagian besar masalah terkait dengan ketidakmampuan memasaknya.  Sebuah proyek yang dirakit dengan benar menggunakan Sencha Cmd dengan semua css, gambar berbobot dalam produksi di wilayah 1Mb, yang sebanding dengan Angular yang sama.  Ya, dan gangguan tidak lebih ... <br><br>  Ada kemungkinan bahwa gagasan Sencha terkait dengan keturunan ini, tetapi bahkan para lawannya yang berprinsip mengakui bahwa sulit untuk menemukan solusi terbaik untuk membangun proyek intranet yang serius. <br><br>  Menurut pendapat saya, hal yang paling berharga di Ext JS bukanlah kumpulan komponen UI, melainkan arsitektur OOP yang baik.  Bahkan dengan mempertimbangkan perkembangan JS yang cepat dalam beberapa tahun terakhir, banyak hal penting yang diimplementasikan dalam Ext JS 7 tahun yang lalu masih hilang di kelas asli (ruang nama, mixin, properti statis, panggilan metode induk yang nyaman).  Inilah yang mendorong saya beberapa tahun yang lalu untuk bereksperimen dengan peluncuran kelas Ext JS di backend.  Tentang eksperimen serupa pertama yang sudah saya posting di Habr√©.  Artikel ini menjelaskan implementasi baru dari gagasan lama dan sejumlah gagasan baru. <br><br>  Sebelum kita mulai, perhatikan pertanyaan: bagaimana menurut Anda, di mana dieksekusi dan apa yang dilakukan cuplikan kode di bawah ini? <br><br><pre><code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Module.message.model.Message'</span></span>, { .... <span class="hljs-comment"><span class="hljs-comment">/* scope:server */</span></span> ,<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> newMessage() { ......... this.fireEvent(<span class="hljs-string"><span class="hljs-string">'newmessage'</span></span>, data); ...... } ... })</code> </pre> <a name="habracut"></a><br>  Kode ini dieksekusi di server dan menyebabkan acara "pesan baru" di semua contoh kelas "Module.message.model.Message" di semua mesin klien yang terhubung ke server. <br><br>  Untuk mengilustrasikan kemungkinan menggunakan Ext JS sisi server, kami akan menganalisis proyek obrolan sederhana.  Kami tidak akan melakukan login apa pun, hanya ketika Anda memasukkan pengguna memasukkan nama panggilan.  Anda dapat memposting pesan umum atau pribadi.  Obrolan harus bekerja secara real time.  Mereka yang berharap dapat segera mencoba semua ekonomi ini dalam bisnis. <br><br><h2>  Instalasi </h2><br>  Untuk memulai, kita memerlukan nodejs 9+ dan redis-server (diasumsikan bahwa mereka sudah diinstal). <br><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/Kolbaskin/extjs-backend-example <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> extjs-backend-example npm i</code> </pre><br>  Kami memulai server: <br><br><pre> <code class="bash hljs">node server</code> </pre><br>  Di browser, buka halaman <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">localhost</a> : 3000 / www / auth / <br>  Masukkan beberapa nama panggilan dan tekan enter. <br><br>  Proyek ini demo, jadi tidak ada dukungan untuk browser lama (ada desain ES8), gunakan Chrome atau FF baru. <br><br><h2>  Server </h2><br>  Mari kita mulai. <br><br>  Kode Server (server.js) <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   http-  express //   Ext JS     express const express = require('express'); const staticSrv = require('extjs-express-static'); const app = express(); const bodyParser = require('body-parser'); //    global = { config: require('config') } //     Ext JS require('extjs-on-backend')({ //     express app, //         wsClient: 'Base.wsClient' }); //    Ext.Loader.setPath('Api', 'protected/rest'); Ext.Loader.setPath('Base', 'protected/base'); Ext.Loader.setPath('Www', 'protected/www'); //   http   app.use( bodyParser.json() ); app.use(bodyParser.urlencoded({ extended: true })); //     Ext JS  app.use('/api/auth', Ext.create('Api.auth.Main')); app.use('/www/auth', Ext.create('Www.login.controller.Login')); //    app.use(staticSrv(__dirname + '/static')); //   const server = app.listen(3000, () =&gt; { console.log('server is running at %s', server.address().port); });</span></span></code> </pre><br>  Seperti yang Anda lihat, di sini semuanya lebih atau kurang standar untuk server pada express.  Yang menarik adalah dimasukkannya kelas Ext JS untuk melayani rute yang sesuai: <br><br><pre> <code class="javascript hljs">app.use(<span class="hljs-string"><span class="hljs-string">'/api/auth'</span></span>, Ext.create(<span class="hljs-string"><span class="hljs-string">'Api.auth.Main'</span></span>)); app.use(<span class="hljs-string"><span class="hljs-string">'/www/auth'</span></span>, Ext.create(<span class="hljs-string"><span class="hljs-string">'Www.login.controller.Login'</span></span>));</code> </pre><br><h3>  Implementasi REST API </h3><br>  Kelas Api.auth.Main melayani permintaan ke REST API (protected / rest / auth / Main.js). <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Api.auth.Main'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Api.Base'</span></span>, <span class="hljs-comment"><span class="hljs-comment">//   //     routes: [ { path: '/', get: 'login'}, { path: '/restore', post: 'restoreLogin' }, { path: '/registration', post: 'newuser'}, { path: '/users', get: 'allUsers'} ] //     : // {query: &lt;...&gt;, params: &lt;...&gt;, body: &lt;...&gt;} ,async login(data) { return {data:[{ id:1, subject: 111, sender:222, }]} } ,async restoreLogin() { ... } ,async newuser() { ... } ,async allUsers() { .... } })</span></span></code> </pre><br><h3>  Pembuatan halaman HTML, menggunakan XTemplate di server </h3><br>  Kelas kedua, Www.login.controller.Login, membangun halaman html biasa dengan formulir login (protected / www / login / controller / Login.js). <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Www.login.controller.Login'</span></span>, { <span class="hljs-comment"><span class="hljs-comment">//      "" : // ,    .. extend: 'Www.Base' //    //   ,   .. ,baseTpl: 'view/inner' //     // ,   ,loginFormTpl: 'login/view/login' //  ,routes: [ { path: '/', get: 'loginForm', post: 'doLogin'} ] //  html   //       ,async loginForm () { return await this.tpl(this.loginFormTpl, { pageTitle: 'Login page', date: new Date() }); } ,async doLogin (params, res) { if(params.body.name &amp;&amp; /^[a-z0-9]{2,10}$/i.test(params.body.name)) { this.redirect(`/index.html?name=${params.body.name}`, res); return; } return await this.tpl(this.loginFormTpl, { pageTitle: 'Login page', date: new Date() }); } })</span></span></code> </pre><br>  Template menggunakan XTemplate standar (protected / www / login / view / login.tpl) <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h2</span></span></span><span class="hljs-tag">&gt;</span></span>{pageTitle} (date: {[Ext.Date.format(values.date,'dmY')]})<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h2</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">form</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">method</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"post"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"name"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">placeholder</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"name"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"submit"</span></span></span><span class="hljs-tag">&gt;</span></span>enter<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">form</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Segala sesuatu yang dijelaskan di atas adalah set yang sepenuhnya standar, pembaca yang teliti akan mengatakan, dan untuk ini tidak perlu pagar taman ini dengan transfer Ext JS ke server.  Oleh karena itu, kami beralih ke bagian kedua artikel, yang akan menunjukkan apa yang dimaksudkan untuk semua. <br><br><h2>  Pelanggan </h2><br>  Mari kita buat aplikasi Ext JS klien biasa di direktori statis.  Dalam contoh ini, saya sengaja tidak mempertimbangkan penggunaan cmd, saya mengambil tema ext-all dan standar yang sudah dibangun.  Masalah majelis adalah topik terpisah, yang, mungkin, akan mencurahkan pos terpisah. <br><br>  Semuanya dimulai dengan app.js <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   Ext.Loader.setConfig({ enabled: true, paths: { "Core": "app/core", "Admin": "app/admin", "Module": "app/admin/modules", "Ext.ux": "ext/ux" } }); //    this.token = Ext.data.identifier.Uuid.createRandom()(); //      //    () //    (   ) Ext.WS = Ext.create('Core.WSocket', { token: this.token, user: new URLSearchParams(document.location.search).get("name") }); //   Ext.application({ name: 'Example', extend: 'Ext.app.Application', requires: ['Admin.*'], autoCreateViewport: 'Admin.view.Viewport' })</span></span></code> </pre><br>  Kehadiran socket web adalah poin penting, itu yang memungkinkan Anda untuk menerapkan semua keajaiban yang dijelaskan di bawah ini. <br><br>  Tata letak elemen pada halaman terdapat di kelas Admin.view.Viewport (statis / app / view / Viewport.js).  Tidak ada yang menarik di sana. <br><br>  Elemen fungsional utama (daftar pengguna, bilah pesan dan formulir pengiriman) diimplementasikan sebagai modul terpisah. <br><br><h3>  Daftar Pengguna </h3><br>  Algoritma sederhana dari daftar ini adalah sebagai berikut: pada saat membuka halaman, pengguna saat ini diambil dari server.  Ketika pengguna baru terhubung, server menghasilkan "tambah" acara di kelas "Module.users.model.UserModel", ketika terputus, di kelas yang sama, acara "hapus" dinaikkan.  Masalahnya adalah bahwa peristiwa tersebut dipicu di sisi server, dan Anda dapat melacaknya di klien. <br><br>  Sekarang, hal pertama yang pertama.  Di sisi klien, Simpan data juggles (static / app / modules / users / store / UsersStore.js) <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Module.users.store.UsersStore'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Ext.data.Store'</span></span> ,<span class="hljs-attr"><span class="hljs-attr">autoLoad</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> ,<span class="hljs-attr"><span class="hljs-attr">total</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> ,<span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-comment"><span class="hljs-comment">//         this.dataModel = Ext.create('Module.users.model.UserModel'); //      this.dataModel.on({ add: (records) =&gt; { this.onDataAdd(records) }, remove: (records) =&gt; { this.onDataRemove(records) } }) this.callParent(arguments) } //   load ,async load() { //      const data = await this.dataModel.$read(); //   this.total = data.total; //    UI this.loadData(data.data); } ,getTotalCount() { return this.total; } //          ,onDataAdd(records) { this.add(records[0]); } //   --  ,onDataRemove(records) { this.remove(this.getById (records[0].id)) } });</span></span></code> </pre><br>  Ada 2 poin menarik.  Pertama, di baris "const data = tunggu this.dataModel. $ Read ();"  Metode server dari model ini disebut.  Sekarang Anda tidak perlu menggunakan Ajax, protokol pendukung, dll., Cukup panggil metode server sebagai lokal.  Pada saat yang sama, keselamatan tidak dikorbankan (lebih dari itu di bawah). <br><br>  Kedua, konstruksi standar this.dataModel.on (...) memungkinkan Anda untuk melacak peristiwa yang akan dihasilkan oleh server. <br><br>  Model adalah jembatan antara bagian klien dan server aplikasi.  Ini seperti dualisme cahaya - ini mengimplementasikan sifat-sifat baik frontend maupun backend.  Mari kita lihat modelnya dengan cermat. <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Module.users.model.UserModel'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Core.data.DataModel'</span></span> <span class="hljs-comment"><span class="hljs-comment">/* scope:client */</span></span> ,testClientMethod() { ... } ,testGlobalMethod() { ... } <span class="hljs-comment"><span class="hljs-comment">/* scope:server */</span></span> ,privateServerMethod() { .... } <span class="hljs-comment"><span class="hljs-comment">/* scope:server */</span></span> ,<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> $read(params) { <span class="hljs-comment"><span class="hljs-comment">//      redis const keys = await this.getMemKeys('client:*'); let data = [], name; for(let i = 0;i&lt;keys.length;i++) { //         name = await this.getMemKey(keys[i]); if(name) { data.push({ id: keys[i].substr(7), name }) } } //    return { total: data.length, data } } })</span></span></code> </pre><br>  Perhatikan komentar / * ruang lingkup: server * / dan / * ruang lingkup: klien * / - konstruksi ini adalah label untuk server dengan mana ia menentukan jenis metode. <br><br>  testClientMethod - metode ini berjalan secara eksklusif pada klien dan hanya tersedia di sisi klien. <br>  testGlobalMethod - metode ini berjalan di klien dan di server dan tersedia untuk digunakan di sisi klien dan server. <br>  privateServerMethod - metode ini dijalankan di server dan tersedia hanya untuk panggilan di server. <br>  $ read adalah jenis metode yang paling menarik yang hanya berjalan di sisi server, tetapi Anda dapat memanggilnya baik di klien maupun di server.  $ Awalan membuat setiap metode sisi server tersedia di sisi klien. <br><br>  Anda dapat melacak koneksi dan pemutusan klien menggunakan soket web.  Sebuah instance dari kelas Base.wsClient dibuat untuk setiap koneksi pengguna (protected / base / wsClient.js) <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Base.wsClient'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Core.WsClient'</span></span> <span class="hljs-comment"><span class="hljs-comment">//      ,usersModel: Ext.create('Module.users.model.UserModel') //       ,async onStart() { //   "add"    this.usersModel.fireEvent('add', 'all', [{id: this.token, name: this.req.query.user}]); //     redis await this.setMemKey(`client:${this.token}`, this.req.query.user || ''); //   ""      , //     await this.queueProcess(`client:${this.token}`, async (data, done) =&gt; { const res = await this.prepareClientEvents(data); done(res); }) } //      ,onClose() { //   "remove"    this.usersModel.fireEvent('remove', 'all', [{id: this.token, name: this.req.query.user}]) this.callParent(arguments); } })</span></span></code> </pre><br>  Metode fireEvent, tidak seperti yang standar, memiliki parameter tambahan, di mana ia diteruskan ke klien mana acara harus dipicu.  Dapat diterima untuk melewati pengidentifikasi klien tunggal, array pengidentifikasi, atau string "semua".  Dalam kasus terakhir, acara akan dipicu pada semua klien yang terhubung.  Kalau tidak, ini adalah FireEvent standar. <br><br><h3>  Mengirim dan menerima pesan </h3><br>  Pengontrol formulir (statis / app / admin / modul / pesan / tampilan / FormController.js) bertanggung jawab untuk mengirim pesan. <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Module.messages.view.FormController'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Ext.app.ViewController'</span></span> ,init(view) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.view = view; <span class="hljs-comment"><span class="hljs-comment">//     this.model = Ext.create('Module.messages.model.Model'); //      this.msgEl = this.view.down('[name=message]'); //     this.usersGrid = Ext.getCmp('users-grid') //    "" this.control({ '[action=submit]' : {click: () =&gt; {this.newMessage() }} }) } //     ,newMessage() { let users = []; //     const sel = this.usersGrid.getSelection(); if(sel &amp;&amp; sel.length) { sel.forEach((s) =&gt; { users.push(s.data.id) }) } //        if(users.length &amp;&amp; users.indexOf(Ext.WS.token) == -1) users.push(Ext.WS.token); //       this.model.$newmessage({ to: users, user: Ext.WS.user, message: this.msgEl.getValue() }) //    this.msgEl.setValue(''); } });</span></span></code> </pre><br>  Pesan tidak disimpan di mana pun di server, acara "pesan baru" hanya dipicu.  Yang menarik adalah panggilan "this.fireEvent ('pesan baru', data.to, msg);", di mana pengidentifikasi klien dilewatkan sebagai penerima pesan.  Dengan demikian, distribusi pesan pribadi diimplementasikan (static / app / admin / modules / messages / model / Model.js). <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Module.messages.model.Model'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Core.data.DataModel'</span></span> <span class="hljs-comment"><span class="hljs-comment">/* scope:server */</span></span> ,<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> $newmessage(data) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> msg = { <span class="hljs-attr"><span class="hljs-attr">user</span></span>: data.user, <span class="hljs-attr"><span class="hljs-attr">message</span></span>: data.message } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(data.to &amp;&amp; Ext.isArray(data.to) &amp;&amp; data.to.length) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fireEvent(<span class="hljs-string"><span class="hljs-string">'newmessage'</span></span>, data.to, msg); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fireEvent(<span class="hljs-string"><span class="hljs-string">'newmessage'</span></span>, <span class="hljs-string"><span class="hljs-string">'all'</span></span>, msg); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } })</code> </pre><br>  Seperti halnya pengguna, data untuk daftar pesan didorong oleh Store (static / app / admin / modules / messages / store / MessagesStore.js) <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Module.messages.store.MessagesStore'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Ext.data.Store'</span></span>, <span class="hljs-attr"><span class="hljs-attr">fields</span></span>: [<span class="hljs-string"><span class="hljs-string">'user'</span></span>, <span class="hljs-string"><span class="hljs-string">'message'</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-comment"><span class="hljs-comment">//       Ext.create('Module.messages.model.Model', { listeners: { newmessage: (mess) =&gt; { this.add(mess) } } }) this.callParent(arguments); } });</span></span></code> </pre><br>  Secara umum, ini semua yang menarik dalam contoh ini. <br><br><h2>  Kemungkinan pertanyaan </h2><br>  <b>Ketersediaan metode server pada klien, tentu saja, bagus, tetapi bagaimana dengan keamanan?</b>  <b>Ternyata seorang peretas jahat dapat melihat kode server dan mencoba memecahkan backend?</b> <br><br>  Tidak, dia tidak akan berhasil.  Pertama, semua metode server dihapus dari kode kelas ketika dikirim ke browser klien.  Untuk tujuan ini, komentar / arahan / * ruang lingkup dimaksudkan: ... * /.  Kedua, kode metode sisi server yang paling publik digantikan oleh konstruksi menengah yang mengimplementasikan mekanisme panggilan jarak jauh di sisi klien. <br><br>  <b>Lagi tentang keamanan.</b>  <b>Jika metode server dapat dipanggil pada klien, ternyata, dapatkah saya memanggil metode semacam itu?</b>  <b>Dan jika ini adalah metode pembersihan basis data?</b> <br><br>  Dari klien, Anda hanya dapat memanggil metode yang memiliki $ awalan dalam namanya.  Untuk metode semacam itu, Anda sendiri yang menentukan logika pemeriksaan dan akses.  Seorang pengguna eksternal tidak memiliki akses ke metode server tanpa $, ia bahkan tidak akan melihatnya (lihat jawaban sebelumnya) <br><br>  <b>Sepertinya Anda memiliki sistem monolitik di mana klien dan server saling terkait.</b>  <b>Apakah penskalaan horizontal mungkin?</b> <br><br>  Sistemnya memang tampak monolitik, tetapi sebenarnya tidak.  Klien dan server dapat "hidup" pada mesin yang berbeda.  Klien dapat dijalankan di server web pihak ketiga mana pun (Nginx, Apache, dll.).  Masalah pemisahan klien dan server sangat mudah diselesaikan oleh pembuat proyek otomatis (saya dapat menulis posting terpisah tentang ini).  Untuk menerapkan mekanisme pesan layanan internal, sistem menggunakan antrian (yaitu, Redis diperlukan untuk ini).  Dengan demikian, bagian server dapat dengan mudah diskalakan secara horizontal dengan hanya menambahkan mesin baru. <br><br>  <b>Dengan pendekatan pengembangan yang biasa, sebagai aturan, backend menyediakan satu set API tertentu yang dapat Anda hubungkan dengan beragam aplikasi klien (situs web, aplikasi seluler).</b>  <b>Dalam kasus Anda, ternyata hanya klien yang ditulis dalam Ext JS yang dapat bekerja dengan backend?</b> <br><br>  Di server, khususnya dalam model modul, logika bisnis tertentu diterapkan.  Untuk menyediakan akses ke sana melalui REST API, "pembungkus" kecil sudah cukup.  Contoh yang sesuai disajikan di bagian pertama artikel ini. <br><br><h2>  Kesimpulan </h2><br>  Seperti yang Anda lihat, untuk pengkodean yang nyaman dari aplikasi yang cukup rumit, sangat mungkin untuk bertahan dengan satu perpustakaan di bagian depan dan belakang.  Ini memiliki manfaat yang signifikan. <br><br>  <b>Mempercepat proses pengembangan.</b>  Setiap anggota tim dapat bekerja di backend dan frontend.  Downtime karena alasan "Saya menunggu API ini muncul di server" tidak lagi relevan. <br><br>  <b>Kode lebih sedikit.</b>  Bagian kode yang sama dapat digunakan pada klien dan di server (pemeriksaan, verifikasi, dll.). <br><br>  <b>Mempertahankan sistem seperti itu jauh lebih sederhana dan lebih murah.</b>  Alih-alih dua programmer yang beragam, sistem akan dapat mendukung satu (atau dua yang sama tetapi dapat dipertukarkan).  Untuk alasan yang sama, risiko yang terkait dengan pergantian tim juga lebih rendah. <br><br>  <b>Kemampuan untuk membuat sistem waktu nyata di luar kotak.</b> <br><br>  <b>Menggunakan sistem pengujian tunggal untuk backend dan frontent.</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id431180/">https://habr.com/ru/post/id431180/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id431170/index.html">Seorang ilmuwan dari Cina mengumumkan kelahiran anak-anak yang dimodifikasi secara genetis</a></li>
<li><a href="../id431172/index.html">Apa yang bisa kita harapkan dari Blizzard? Masa Lalu, Sekarang, dan Masa Depan Seri Diablo</a></li>
<li><a href="../id431174/index.html">Teori simulasi: hubungan perhitungan kimia kuantum dan kenyataan</a></li>
<li><a href="../id431176/index.html">Layanan Mikro, API dan Inovasi: Kekuatan API</a></li>
<li><a href="../id431178/index.html">Kata-kata parasit dalam bahasa Inggris</a></li>
<li><a href="../id431184/index.html">WIFI jaringan multi-hop mesh menggunakan teknologi Mesh Connex</a></li>
<li><a href="../id431186/index.html">Desain berdasarkan jenis: Cara membuat negara yang tidak valid tidak dapat diekspresikan dalam C #</a></li>
<li><a href="../id431188/index.html">Aspek teknis pemblokiran Internet di Rusia. Tantangan dan Prospek</a></li>
<li><a href="../id431190/index.html">Cara mengevaluasi level perusahaan SEO tanpa menyimpulkan perjanjian dengannya</a></li>
<li><a href="../id431192/index.html">AWC memperkenalkan Firecracker - virtualisasi mikro untuk Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>