<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¥ üí∑ üë¥üèΩ Rumo ao QUIC: O que est√° por tr√°s do HTTP / 3 üë´ üë©üèæ‚Äçü§ù‚Äçüë©üèΩ üç†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Um novo marco na hist√≥ria da Internet come√ßa diante de nossos olhos: podemos assumir que o HTTP / 3 j√° foi anunciado. No final de outubro, Mark Nottin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rumo ao QUIC: O que est√° por tr√°s do HTTP / 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/Voximplant/blog/430436/"> Um novo marco na hist√≥ria da Internet come√ßa diante de nossos olhos: podemos assumir que o HTTP / 3 j√° foi anunciado.  No final de outubro, Mark Nottingham, da IETF, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sugeriu j√° decidir sobre um nome</a> para o novo protocolo sobre o qual a IETF vem construindo desde 2015.  Ent√£o, em vez de nomes semelhantes a QUIC, HTTP / 3 alto apareceu.  As publica√ß√µes ocidentais j√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://daniel.haxx.se/blog/tag/">escreveram sobre isso</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://www.zdnet.com/article/http-over-quic-to-be-renamed-">mais de uma vez</a> .  A hist√≥ria do QUIC come√ßou nas entranhas da Good Corporation em 2012, desde ent√£o, apenas os servidores do Google suportavam conex√µes HTTP sobre QUIC, mas o tempo passa e o Facebook j√° come√ßou a implementar essa tecnologia (em 7 de novembro, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Facebook</a> e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LiteSpeed</a> fizeram a primeira intera√ß√£o via HTTP / 3 );  Atualmente, a participa√ß√£o de sites que suportam QUIC √© de 1,2%.  Por fim, o grupo de trabalho do WebRTC <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tamb√©m</a> est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">olhando para o QUIC</a> (al√©m de ver a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">API</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">QUIC</a> ), portanto, no futuro previs√≠vel, o v√≠deo / √°udio em tempo real passar√° pelo QUIC em vez de RTP / RTCP.  Portanto, decidimos que seria √≥timo revelar os detalhes do IETF QUIC: especialmente para Habr, preparamos uma tradu√ß√£o do longread que pontilha i.  Aproveite! <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/r4/ee/3s/r4ee3svcbqzrlxwfzuajri7go04.png"></div><a name="habracut"></a><br>  O QUIC (Quick UDP Internet Connections) √© um novo protocolo de camada de transporte criptografado e padr√£o que possui muitos aprimoramentos HTTP: para acelerar o tr√°fego e aumentar a seguran√ßa.  O QUIC tamb√©m tem um objetivo de longo prazo - eventualmente substituir o TCP e o TLS.  Neste artigo, examinaremos os principais chips QUIC e por que a Web se beneficiar√° deles, bem como os problemas de suporte a esse protocolo completamente novo. <br><br>  De fato, existem dois protocolos com o mesmo nome: Google QUIC (gQUIC), o protocolo original desenvolvido pelos engenheiros do Google h√° v√°rios anos, que, ap√≥s uma s√©rie de experimentos, foi adotado pela Internet Engineering Task Force (IETF) para padroniza√ß√£o. <br><br>  O IETF QUIC (daqui em diante simplesmente QUIC) j√° possui diferen√ßas t√£o fortes com o gQUIC que pode ser considerado um protocolo separado.  Do formato do pacote ao handshake e ao mapeamento HTTP, o QUIC melhorou a arquitetura original do gQUIC, colaborando com muitas organiza√ß√µes e desenvolvedores que t√™m um objetivo comum: tornar a Internet mais r√°pida e segura. <br><br>  Ent√£o, quais melhorias o QUIC oferece? <br><br><h2>  Seguran√ßa Integrada (e Desempenho) </h2><br>  Uma das diferen√ßas mais not√°veis ‚Äã‚Äãentre o QUIC e o vener√°vel TCP √© o objetivo originalmente declarado de ser um protocolo de transporte <b>seguro por padr√£o</b> .  O QUIC consegue isso usando autentica√ß√£o e criptografia, que geralmente ocorre em um n√≠vel superior (por exemplo, no TLS), e n√£o no pr√≥prio protocolo de transporte. <br><br>  O handshake QUIC original combina a comunica√ß√£o de tr√™s vias usual por TCP com o handshake TLS 1.3, que fornece autentica√ß√£o dos participantes, bem como coordena√ß√£o dos par√¢metros criptogr√°ficos.  Para aqueles que est√£o familiarizados com TLS: QUIC substitui o n√≠vel de grava√ß√£o TLS por seu pr√≥prio formato de quadro, mas ao mesmo tempo usa handshakes TLS. <br><br>  Isso n√£o apenas permite que a conex√£o seja sempre criptografada e autenticada, mas tamb√©m √© mais r√°pida para fazer a conex√£o inicial: um handshake QUIC comum faz a troca entre o cliente e o servidor em uma passagem, enquanto o TCP + TLS 1.3 faz duas passagens. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h2/lq/o4/h2lqo4o2itthtb_h7qopgt7kbc4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/g6/ne/vg/g6nevg964eqgvmzillfvnet3lus.png"></div><br>  No entanto, o QUIC vai al√©m e criptografa os metadados da conex√£o que podem ser facilmente comprometidos por terceiros.  Por exemplo, os invasores podem usar n√∫meros de pacotes para direcionar usu√°rios atrav√©s de v√°rios caminhos de rede quando a migra√ß√£o de conex√£o √© usada (veja abaixo).  O QUIC criptografa n√∫meros de pacotes, para que n√£o possam ser corrigidos por ningu√©m al√©m dos verdadeiros participantes da conex√£o. <br><br>  A criptografia tamb√©m pode ser eficaz contra a ‚Äúestagna√ß√£o‚Äù - um fen√¥meno que n√£o permite que a flexibilidade do protocolo seja usada na pr√°tica devido a suposi√ß√µes incorretas nas implementa√ß√µes (ossifica√ß√£o - √© por isso que o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TLS 1.3 foi estabelecido</a> por um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">longo tempo</a> . impedir bloqueios indesejados para novas revis√µes do TLS). <br><br><h2>  Bloqueando o in√≠cio da fila (bloqueio de linha de frente) </h2><br>  Uma das principais melhorias que o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://blog.cloudflare.com/introducing-">HTTP / 2</a> nos trouxe √© a capacidade de combinar solicita√ß√µes HTTP diferentes em uma conex√£o TCP.  Isso permite que aplicativos HTTP / 2 processem solicita√ß√µes em paralelo e fa√ßam melhor uso do canal de rede. <br><br>  Obviamente, este foi um passo significativo adiante.  Como os aplicativos anteriores precisavam iniciar muitas conex√µes TCP + TLS se desejavam processar v√°rias solicita√ß√µes HTTP ao mesmo tempo (por exemplo, quando o navegador precisa receber CSS e JavaScript para renderizar a p√°gina).  Criar novas conex√µes requer v√°rios handshakes, al√©m de inicializar a janela de sobrecarga: isso significa diminuir a renderiza√ß√£o da p√°gina.  Solicita√ß√µes HTTP combinadas evitam isso. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lj/rc/lb/ljrclbypotymwhoajopsze57jry.jpeg"></div><br><br>  No entanto, h√° uma desvantagem: como v√°rias solicita√ß√µes / respostas s√£o transmitidas pela mesma conex√£o TCP, elas s√£o igualmente dependentes da perda de pacotes, mesmo que os dados perdidos digam respeito apenas a uma das solicita√ß√µes.  Isso √© chamado de "bloquear o in√≠cio da fila". <br><br>  O QUIC √© mais profundo e fornece suporte de primeira classe para combinar solicita√ß√µes, por exemplo, solicita√ß√µes HTTP diferentes podem ser consideradas solicita√ß√µes QUIC de transporte diferentes, mas ao mesmo tempo todas elas usam a mesma conex√£o QUIC - ou seja, n√£o s√£o necess√°rios handshakes adicionais, existe um status de congestionamento, as solicita√ß√µes QUIC s√£o entregues independentemente - como resultado, na maioria dos casos, a perda de pacotes afeta apenas uma solicita√ß√£o. <br><br>  Assim, √© poss√≠vel reduzir significativamente o tempo para, por exemplo, a renderiza√ß√£o completa de uma p√°gina da web (CSS, JavaScript, imagens e outros recursos), especialmente no caso de uma rede sobrecarregada com alta perda de pacotes. <br><br><h2>  T√£o simples, n√©? </h2><br>  Para cumprir sua promessa, o protocolo QUIC deve superar algumas das suposi√ß√µes que muitos aplicativos de rede t√™m como certo.  Isso pode complicar a implementa√ß√£o e implementa√ß√£o do QUIC. <br><br>  O QUIC foi projetado para ser entregue atrav√©s de datagramas UDP, a fim de facilitar o desenvolvimento e evitar problemas com dispositivos de rede que descartam pacotes de protocolos desconhecidos (porque a maioria dos dispositivos suporta UDP).  Ele tamb√©m permite que o QUIC viva no espa√ßo do usu√°rio; portanto, por exemplo, os navegadores poder√£o implementar novos recursos de protocolo e transmiti-los aos usu√°rios finais, sem aguardar atualiza√ß√µes do sistema operacional. <br><br>  No entanto, o bom objetivo de reduzir os problemas de rede dificulta a prote√ß√£o de pacotes e o roteamento adequado. <br><br><h2>  Um NAT para reunir todos juntos e unir-se com uma √∫nica vontade negra </h2><br>  Normalmente, os roteadores NAT trabalham com conex√µes TCP usando uma tupla de 4 valores (IP e porta de origem mais IP e porta de destino), al√©m de monitorar pacotes TCP SYN, ACK e FIN transmitidos pela rede;  Os roteadores podem determinar quando uma nova conex√£o √© estabelecida e quando ela √© finalizada.  Portanto, √© poss√≠vel gerenciar com precis√£o as liga√ß√µes NAT (comunica√ß√µes entre IP interno e externo e portas). <br><br>  No caso do QUIC, isso ainda n√£o √© poss√≠vel, porque  Os roteadores NAT modernos ainda n√£o conhecem o QUIC, portanto, eles costumam fazer o downgrade para o processamento UDP padr√£o e menos preciso, o que significa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tempos limite de dura√ß√£o arbitr√°ria (√†s vezes curta)</a> , que podem afetar as conex√µes de longo prazo. <br><br>  Quando ocorre uma nova liga√ß√£o (por exemplo, devido a um tempo limite), o dispositivo fora do per√≠metro NAT come√ßa a receber pacotes de outra fonte, o que torna imposs√≠vel manter a conex√£o usando apenas uma tupla de 4 valores. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xg/ze/kz/xgzekzn8kq0nhe9--wkbotrxxmq.png"></div><br><br>  E n√£o √© apenas NAT!  Um recurso QUIC √© chamado de migra√ß√£o de conex√£o e permite que os dispositivos transfiram conex√µes para outros endere√ßos / caminhos IP, a seu crit√©rio.  Por exemplo, um cliente m√≥vel poder√° transferir uma conex√£o QUIC de uma rede m√≥vel para uma rede WiFi j√° conhecida (o usu√°rio entrou em uma cafeteria favorita etc.). <br><br>  O QUIC tenta resolver esse problema com o conceito de ID de conex√£o: uma informa√ß√£o de tamanho arbitr√°rio, transmitida em pacotes QUIC e permitindo identificar a conex√£o.  Os dispositivos de terminal podem usar esse ID para rastrear suas conex√µes sem se reconciliar com a tupla.  Na pr√°tica, deve haver muitos IDs que indiquem a mesma conex√£o, por exemplo, para evitar a conex√£o de caminhos diferentes quando a conex√£o √© migrada - porque todo o processo √© controlado apenas pelos dispositivos finais, n√£o pelas caixas intermedi√°rias. <br><br>  No entanto, pode haver um problema para as operadoras de telecomunica√ß√µes que usam roteamento anycast e ECMP, em que um IP pode potencialmente identificar centenas ou milhares de servidores.  Como os roteadores de borda nessas redes ainda n√£o sabem como lidar com o tr√°fego QUIC, pode acontecer que pacotes UDP da mesma conex√£o QUIC, mas com tuplas diferentes, sejam enviados para servidores diferentes, o que significa desconex√£o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d4/vq/us/d4vqusefrkw1ideoglo-_heq8py.png"></div><br><br>  Para evitar isso, os operadores podem precisar implementar um balanceador de n√≠vel mais inteligente.  Isso pode ser conseguido programaticamente sem afetar os pr√≥prios roteadores de borda (por exemplo, veja o projeto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Katran</a> no Facebook). <br><br><h2>  Qpack </h2><br>  Outro recurso √∫til do HTTP / 2 foi a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://blog.cloudflare.com/hpack-the-silent-killer-feature-of-">compacta√ß√£o de cabe√ßalho (HPACK)</a> , que permite que os dispositivos finais reduzam o tamanho dos dados enviados descartando solicita√ß√µes e respostas desnecess√°rias. <br><br>  Em particular, entre outras t√©cnicas, o HPACK usa tabelas din√¢micas com cabe√ßalhos que j√° foram enviados / recebidos de solicita√ß√µes / respostas HTTP anteriores, o que permite que os dispositivos se refiram em novas solicita√ß√µes / respostas a cabe√ßalhos encontrados anteriormente (em vez de envi√°-los novamente) . <br><br>  As tabelas HPACK devem ser sincronizadas entre o codificador (a parte que envia a solicita√ß√£o / resposta) e o decodificador (o lado receptor); caso contr√°rio, o decodificador simplesmente n√£o pode decodificar o que recebe. <br><br>  No caso do HTTP / 2 sobre TCP, essa sincroniza√ß√£o √© transparente porque a camada de transporte (TCP) entrega solicita√ß√µes / respostas na mesma ordem em que foram enviadas.  Ou seja, voc√™ pode enviar instru√ß√µes ao decodificador para atualizar as tabelas em uma solicita√ß√£o / resposta simples.  Mas com o QUIC, as coisas s√£o muito mais complicadas. <br><br>  O QUIC pode entregar v√°rias solicita√ß√µes / respostas HTTP em dire√ß√µes diferentes ao mesmo tempo, o que significa que o QUIC garante a ordem de entrega em uma dire√ß√£o, enquanto n√£o existe essa garantia no caso de v√°rias dire√ß√µes. <br><br>  Por exemplo, se um cliente envia uma solicita√ß√£o HTTP A no fluxo QUIC A, bem como uma solicita√ß√£o B no fluxo B, devido √† permuta√ß√£o de pacotes ou a perdas de rede, o servidor receber√° a solicita√ß√£o B antes da solicita√ß√£o A. E se a solicita√ß√£o B foi codificada como foi indicado no cabe√ßalho da solicita√ß√£o A, o servidor simplesmente n√£o poder√° decodificar a solicita√ß√£o B, pois ainda n√£o viu a solicita√ß√£o A. <br><br>  O protocolo gQUIC resolveu esse problema simplesmente tornando todos os cabe√ßalhos (mas n√£o os corpos) das solicita√ß√µes / respostas HTTP <b>seq√ºenciais</b> em um √∫nico fluxo gQUIC.  Isso garantiu que todos os cabe√ßalhos chegassem na ordem correta, independentemente do que acontecesse.  Este √© um esquema muito simples, com sua ajuda, as solu√ß√µes existentes podem continuar a usar c√≥digo aprimorado no HTTP / 2;  por outro lado, isso aumenta a probabilidade de bloquear o in√≠cio da fila, que o QUIC foi projetado para reduzir.  Portanto, o grupo de trabalho IETF QUIC desenvolveu um novo mapeamento entre HTTP e QUIC (HTTP / QUIC), bem como um novo princ√≠pio de compacta√ß√£o de cabe√ßalho, QPACK. <br><br>  No rascunho final das especifica√ß√µes HTTP / QUIC e QPACK, cada troca de solicita√ß√£o / resposta HTTP usa seu pr√≥prio fluxo QUIC bidirecional, portanto, o bloqueio do in√≠cio da fila n√£o ocorre.  Al√©m disso, para oferecer suporte ao QPACK, cada participante cria dois fluxos QUIC adicionais e unidirecionais, um para enviar atualiza√ß√µes de tabela e outro para confirmar seu recebimento.  Portanto, o codificador QPACK pode usar o link para a tabela din√¢mica somente depois que o decodificador confirmar seu recebimento. <br><br><h2>  Reflex√£o refrat√°ria </h2><br>  Um problema comum nos protocolos baseados em UDP √© sua suscetibilidade a ataques de reflex√£o, quando o invasor for√ßa um servidor a enviar uma quantidade enorme de dados √† v√≠tima.  O invasor falsifica seu IP para que o servidor pense que a solicita√ß√£o de dados veio do endere√ßo da v√≠tima. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4e/ee/ov/4eeeovjfl-9or5j0uq-9he0btrg.png"></div><br>  Esse tipo de ataque pode ser muito eficaz quando a resposta do servidor for incomparavelmente maior que a solicita√ß√£o.  Nesse caso, eles falam de "ganho". <br><br>  O TCP geralmente n√£o √© usado para esses ataques, porque os pacotes no handshake original (SYN, SYN + ACK, ...) t√™m o mesmo comprimento e, portanto, n√£o t√™m potencial para "amplifica√ß√£o". <br><br>  Por outro lado, o handshake QUIC √© muito assim√©trico: como no TLS, primeiro o servidor QUIC envia sua cadeia de certificados, que pode ser bastante grande, apesar de o cliente enviar apenas alguns bytes (a mensagem do cliente ClientHello TLS est√° embutida no pacote QUIC )  Por esse motivo, o pacote QUIC original deve ser aumentado para um determinado comprimento m√≠nimo, mesmo que o conte√∫do do pacote seja muito menor.  Seja como for, essa medida ainda n√£o √© muito eficaz, pois uma resposta t√≠pica do servidor cont√©m v√°rios pacotes e, portanto, pode ser mais do que um pacote de cliente ampliado. <br><br>  O protocolo QUIC tamb√©m define um mecanismo expl√≠cito de verifica√ß√£o de origem: o servidor, em vez de fornecer uma resposta grande, envia apenas um pacote de repeti√ß√£o com um token exclusivo, que o cliente envia ao servidor em um novo pacote.  Portanto, o servidor tem mais confian√ßa de que o cliente n√£o possui um endere√ßo IP substituto e voc√™ pode finalizar o handshake.  Menos a decis√£o - o tempo do aperto de m√£o aumenta, em vez de um passe, dois j√° s√£o necess√°rios. <br><br>  Uma solu√ß√£o alternativa √© reduzir a resposta do servidor para um tamanho em que o ataque de reflex√£o se torne menos eficaz - por exemplo, usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">certificados ECDSA</a> (geralmente eles s√£o muito menores que o RSA).  Tamb√©m experimentamos um mecanismo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">compacta√ß√£o de certificado TLS</a> usando algoritmos de compacta√ß√£o prontos para uso, como zlib e brotli;  esse √© um recurso que apareceu pela primeira vez no gQUIC, mas atualmente n√£o √© suportado no TLS. <br><br><h2>  Desempenho UDP </h2><br>  Um dos problemas constantes do QUIC √© o hardware e o software existentes que n√£o conseguem trabalhar com o QUIC.  J√° examinamos como o QUIC tenta lidar com caixas intermedi√°rias da rede, como roteadores, mas outra √°rea potencialmente problem√°tica √© o desempenho do envio / recebimento de dados entre dispositivos QUIC por UDP.  Por muitos anos, foram feitos esfor√ßos para otimizar ao m√°ximo as implementa√ß√µes de TCP, incluindo recursos internos de descarregamento em software (por exemplo, sistemas operacionais) e em hardware (interfaces de rede), mas nada disso se refere ao UDP. <br><br>  No entanto, √© apenas uma quest√£o de tempo at√© que as implementa√ß√µes do QUIC superem essas melhorias e benef√≠cios.  Veja os esfor√ßos recentes para implementar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">descarregamento de UDP no Linux</a> , o que permitiria que os aplicativos combinassem e transmitissem v√°rios segmentos UDP entre a pilha de rede do espa√ßo do usu√°rio e do espa√ßo do kernel, ao custo de aproximadamente um segmento;  outro exemplo √© o suporte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√† zeroc√≥pia para soquetes no Linux</a> , gra√ßas ao qual os aplicativos podem evitar o custo de copiar a mem√≥ria do espa√ßo do usu√°rio no espa√ßo do kernel. <br><br><h2>  Conclus√£o </h2><br>  Como o HTTP / 2 e o TLS 1.3, o protocolo QUIC deve trazer uma s√©rie de novos recursos que melhorar√£o o desempenho e a seguran√ßa dos sites e de outros participantes da infraestrutura da Internet.  O grupo de trabalho da IETF pretende lan√ßar a primeira vers√£o das especifica√ß√µes do QUIC at√© o final do ano, ent√£o √© hora de pensar em como podemos tirar o m√°ximo proveito dos benef√≠cios do QUIC. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt430436/">https://habr.com/ru/post/pt430436/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt430426/index.html">Rebranding da Western Digital Products: o que mudou?</a></li>
<li><a href="../pt430428/index.html">O site "Escher II" na nomea√ß√£o "Projeto Internet das Pessoas" Runet Pr√™mios 2018</a></li>
<li><a href="../pt430430/index.html">Fullstack - por que √© legal ou como aproveitar o trabalho</a></li>
<li><a href="../pt430432/index.html">A janela modal que voc√™ estava esperando. Ou como chamar um pop-up de diferentes bot√µes em JS puro</a></li>
<li><a href="../pt430434/index.html">Iniciando o visualizador de imagens do Windows XP no Windows moderno</a></li>
<li><a href="../pt430438/index.html">Sombras realistas para roguelike</a></li>
<li><a href="../pt430446/index.html">Mais uma vez sobre os profissionais da "escravid√£o m√≥vel"</a></li>
<li><a href="../pt430448/index.html">O que fornece o aprendizado de m√°quina no varejo: um exemplo de projeto</a></li>
<li><a href="../pt430450/index.html">Modelo de desenvolvimento usando CPU baseada em pilha como exemplo</a></li>
<li><a href="../pt430452/index.html">Fogo, √°gua e spray fino. Como os moradores e visitantes do Centro de Lakhta ser√£o protegidos do fogo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>