<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíì üí∏ ü¶å Blocos de constru√ß√£o de aplicativos distribu√≠dos. Primeira abordagem üîë üë©üèø‚Äçü§ù‚Äçüë©üèæ üè¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No √∫ltimo artigo, examinamos os fundamentos te√≥ricos da arquitetura reativa. √â hora de falar sobre fluxos de dados, maneiras de implementar sistemas r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Blocos de constru√ß√£o de aplicativos distribu√≠dos. Primeira abordagem</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446108/"><p><img src="https://habrastorage.org/webt/id/fv/eo/idfveo9cmr8y2uyidusx29gwvtc.jpeg"></p><br><p> No √∫ltimo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo,</a> examinamos os fundamentos te√≥ricos da arquitetura reativa.  √â hora de falar sobre fluxos de dados, maneiras de implementar sistemas reativos Erlang / Elixir e padr√µes de mensagens neles: </p><br><ul><li>  Solicitar resposta </li><li>  Resposta dividida em solicita√ß√£o </li><li>  Resposta com solicita√ß√£o </li><li>  Publicar-assinar </li><li>  Assinatura de publica√ß√£o invertida </li><li>  Distribui√ß√£o de tarefas <a name="habracut"></a></li></ul><br><h2 id="soa-msa-i-obmen-soobscheniyami">  SOA, MSA e sistema de mensagens </h2><br><p>  SOA, MSA - arquiteturas de sistema que definem as regras para a constru√ß√£o de sistemas, enquanto o sistema de mensagens fornece primitivas para sua implementa√ß√£o. </p><br><p>  N√£o quero promover essa ou aquela arquitetura de constru√ß√£o de sistemas.  Sou a favor do uso das pr√°ticas mais eficazes e √∫teis para um projeto e neg√≥cio em particular.  Qualquer que seja o paradigma que escolhermos, √© melhor criar blocos de sistema de olho no caminho Unix: componentes com conectividade m√≠nima que s√£o respons√°veis ‚Äã‚Äãpor entidades individuais.  Os m√©todos de API executam as a√ß√µes mais simples com entidades. </p><br><p>  Mensagens - como o nome indica, √© um intermedi√°rio de mensagens.  Seu principal objetivo √© receber e enviar mensagens.  Ele √© respons√°vel pelas interfaces para o envio de informa√ß√µes, a forma√ß√£o de canais l√≥gicos para transmiss√£o de informa√ß√µes no sistema, roteamento e balanceamento e o processamento de falhas no n√≠vel do sistema. <br>  As mensagens que est√£o sendo desenvolvidas n√£o est√£o tentando competir ou substituir o rabbitmq.  Suas principais caracter√≠sticas: </p><br><ul><li>  Distribui√ß√£o <br>  Os pontos de troca podem ser criados em todos os n√≥s do cluster, o mais pr√≥ximo poss√≠vel do c√≥digo que os utiliza. </li><li>  Simplicidade. <br>  Concentre-se em minimizar o c√≥digo padr√£o e a usabilidade. </li><li>  O melhor desempenho. <br>  N√£o estamos tentando repetir a funcionalidade do rabbitmq, mas apenas destacamos a camada de arquitetura e transporte, o mais simples poss√≠vel no OTP, minimizando os custos. </li><li>  Flexibilidade. <br>  Cada servi√ßo pode combinar muitos modelos de interc√¢mbio. </li><li>  Toler√¢ncia a falhas inerente ao design. </li><li>  Escalabilidade. <br>  As mensagens aumentam com o aplicativo.  √Ä medida que a carga aumenta, voc√™ pode mover os pontos de troca para m√°quinas individuais. </li></ul><br><p>  <em>Observa√ß√£o.</em>  Do ponto de vista da organiza√ß√£o do c√≥digo, os metaprojetos s√£o adequados para sistemas complexos com o Erlang / Elixir.  Todo o c√≥digo do projeto est√° em um reposit√≥rio - um projeto abrangente.  Ao mesmo tempo, os microsservi√ßos s√£o t√£o isolados quanto poss√≠vel e executam opera√ß√µes simples que s√£o respons√°veis ‚Äã‚Äãpor uma entidade separada.  Com essa abordagem, √© f√°cil oferecer suporte √† API de todo o sistema, basta fazer altera√ß√µes, √© conveniente escrever unidades e testes de integra√ß√£o. </p><br><p>  Os componentes do sistema interagem diretamente ou atrav√©s de um broker.  Do ponto de vista de mensagens, cada servi√ßo tem v√°rias fases da vida: </p><br><ul><li>  Inicializa√ß√£o de servi√ßo. <br>  Nesta fase, a configura√ß√£o e o lan√ßamento do processo e depend√™ncias de execu√ß√£o do servi√ßo ocorrem. </li><li>  Criando um ponto de troca. <br>  O servi√ßo pode usar o ponto de troca est√°tico especificado na configura√ß√£o do n√≥ ou criar pontos de troca dinamicamente. </li><li>  Registro de servi√ßo. <br>  Para que o servi√ßo possa atender a solicita√ß√µes, ele deve ser registrado no ponto de troca. </li><li>  Funcionamento normal. <br>  Servi√ßo produz um trabalho √∫til. </li><li>  Desligamento. <br>  Existem 2 tipos de desligamento: regular e de emerg√™ncia.  Com um servi√ßo regular, ele se desconecta do ponto de troca e para.  Em casos de emerg√™ncia, o sistema de mensagens executa um dos cen√°rios de failover. </li></ul><br><p>  Parece bastante complicado, mas nem tudo √© t√£o assustador no c√≥digo.  Exemplos de c√≥digo com coment√°rios ser√£o dados na an√°lise de modelos um pouco mais tarde. </p><br><h2 id="exchanges">  Trocas </h2><br><p>  Um ponto de troca √© um processo de mensagens que implementa a l√≥gica de intera√ß√£o com componentes dentro de um modelo de mensagens.  Em todos os exemplos abaixo, os componentes interagem por meio de pontos de troca, cuja combina√ß√£o forma mensagens. </p><br><h2 id="message-exchange-patterns-meps">  Padr√µes de troca de mensagens (MEPs) </h2><br><p>  Globalmente, os padr√µes de compartilhamento podem ser divididos em dois sentidos e um caminho.  O primeiro implica uma resposta √† mensagem recebida, o segundo n√£o.  Um exemplo cl√°ssico de um padr√£o bidirecional em uma arquitetura cliente-servidor √© o padr√£o Solicita√ß√£o-resposta.  Considere o modelo e suas modifica√ß√µes. </p><br><h3 id="requestresponse-ili-rpc">  Pedido - resposta ou RPC </h3><br><p>  O RPC √© usado quando precisamos obter uma resposta de outro processo.  Esse processo pode ser iniciado no mesmo site ou localizado em um continente diferente.  Abaixo est√° um diagrama da intera√ß√£o do cliente e servidor atrav√©s de mensagens. </p><br><p><img src="https://habrastorage.org/webt/pz/x9/hx/pzx9hxfkk0szgfugtdbpc1hwrak.png"></p><br><p>  Como o sistema de mensagens √© completamente ass√≠ncrono, para o cliente, a troca √© dividida em 2 fases: </p><br><ol><li><p>  Solicitar envio </p><br><pre><code class="erlang hljs">messaging:request(Exchange, ResponseMatchingTag, RequestDefinition, HandlerProcess).</code> </pre> <br><p>  <em>Troca</em> - um nome exclusivo para o ponto de troca <br>  <em>ResponseMatchingTag</em> - o r√≥tulo local para lidar com a resposta.  Por exemplo, no caso de enviar v√°rias solicita√ß√µes id√™nticas pertencentes a usu√°rios diferentes. <br>  <em>RequestDefinition</em> - corpo da solicita√ß√£o <br>  <em>HandlerProcess</em> - manipulador de PID.  Este processo receber√° uma resposta do servidor. </p><br></li><li><p>  Processamento de resposta </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_info</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(#'$msg'{exchange = EXCHANGE, tag = ResponseMatchingTag,message = ResponsePayload}, State)</span></span></span></span></code> </pre> <br><p>  <em>ResponsePayload</em> - resposta do servidor. </p><br></li></ol><br><p>  Para o servidor, o processo tamb√©m consiste em 2 fases: </p><br><ol><li>  Inicializa√ß√£o do Exchange Point </li><li>  Processando solicita√ß√µes recebidas </li></ol><br><p>  Vamos ilustrar este modelo com c√≥digo.  Suponha que precisamos implementar um servi√ßo simples que forne√ßa o √∫nico m√©todo de tempo exato. </p><br><h4 id="kod-servera">  C√≥digo do servidor </h4><br><p>  Retire a defini√ß√£o da API de servi√ßo em api.hrl: </p><br><pre> <code class="erlang hljs"><span class="hljs-comment"><span class="hljs-comment">%% ===================================================== %% entities %% ===================================================== -record(time, { unixtime :: non_neg_integer(), datetime :: binary() }). -record(time_error, { code :: non_neg_integer(), error :: term() }). %% ===================================================== %% methods %% ===================================================== -record(time_req, { opts :: term() }). -record(time_resp, { result :: #time{} | #time_error{} }).</span></span></code> </pre> <br><p>  Defina um controlador de servi√ßo em time_controller.erl </p><br><pre> <code class="erlang hljs"><span class="hljs-comment"><span class="hljs-comment">%%      .     gen_server    . %%  gen_server init(Args) -&gt; %%     messaging:monitor_exchange(req_resp, ?EXCHANGE, default, self()) {ok, #{}}. %%       .    ,      . handle_info(#exchange_die{exchange = ?EXCHANGE}, State) -&gt; erlang:send(self(), monitor_exchange), {noreply, State}; %%  API handle_info(#time_req{opts = _Opts}, State) -&gt; messaging:response_once(Client, #time_resp{ result = #time{ unixtime = time_utils:unixtime(now()), datetime = time_utils:iso8601_fmt(now())} }); {noreply, State}; %%   gen_server terminate(_Reason, _State) -&gt; messaging:demonitor_exchange(req_resp, ?EXCHANGE, default, self()), ok.</span></span></code> </pre> <br><h4 id="kod-klienta">  C√≥digo do cliente </h4><br><p>  Para enviar uma solicita√ß√£o a um servi√ßo, voc√™ pode chamar a API de solicita√ß√£o de mensagens em qualquer lugar do cliente: </p><br><pre> <code class="erlang hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> messaging:request(?EXCHANGE, tag, #time_req{opts = #{}}, self()) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> ok -&gt; ok; _ -&gt; <span class="hljs-comment"><span class="hljs-comment">%% repeat or fail logic end</span></span></code> </pre> <br><p>  Em um sistema distribu√≠do, a configura√ß√£o dos componentes pode ser muito diferente e, no momento da solicita√ß√£o, o sistema de mensagens ainda n√£o pode ser iniciado ou o controlador de servi√ßo n√£o estar√° pronto para atender √† solicita√ß√£o.  Portanto, precisamos verificar a resposta do sistema de mensagens e lidar com o caso de falha. <br>  Ap√≥s o envio bem-sucedido, o cliente receber√° uma resposta ou erro do servi√ßo. <br>  Manipule os dois casos em handle_info: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_info</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(#'$msg'{exchange = ?EXCHANGE, tag = tag, message = #time_resp{result = #time{unixtime = Utime}}}, State)</span></span></span><span class="hljs-function"> -&gt;</span></span> ?debugVal(Utime), {noreply, State}; handle_info(#'$msg'{exchange = ?EXCHANGE, tag = tag, message = #time_resp{result = #time_error{code = ErrorCode}}}, State) -&gt; ?debugVal({error, ErrorCode}), {noreply, State};</code> </pre> <br><h3 id="request-chunked-response">  Resposta dividida em solicita√ß√£o </h3><br><p>  Melhor n√£o permitir a transmiss√£o de grandes mensagens.  A capacidade de resposta e a opera√ß√£o est√°vel de todo o sistema dependem disso.  Se a resposta √† solicita√ß√£o consumir muita mem√≥ria, uma divis√£o em partes √© obrigat√≥ria. </p><br><p><img src="https://habrastorage.org/webt/dj/zv/6_/djzv6_lvreaj-iieegxoqemx-vi.png"></p><br><p>  Aqui est√£o alguns exemplos desses casos: </p><br><ul><li>  Os componentes trocam dados bin√°rios, como arquivos.  A divis√£o da resposta em pequenas partes ajuda a trabalhar eficientemente com arquivos de qualquer tamanho e a n√£o captar estouros de mem√≥ria. </li><li>  Listagens.  Por exemplo, precisamos selecionar todos os registros de uma grande tabela no banco de dados e transferi-los para outro componente. </li></ul><br><p>  Eu chamo essas respostas de locomotiva.  De qualquer forma, 1024 mensagens de 1 MB s√£o melhores que uma √∫nica mensagem de 1 GB. </p><br><p>  No cluster Erlang, obtemos um ganho adicional - reduzindo a carga no ponto de troca e na rede, j√° que as respostas s√£o enviadas imediatamente ao destinat√°rio, ignorando o ponto de troca. </p><br><h3 id="response-with-request">  Resposta com solicita√ß√£o </h3><br><p>  Essa √© uma modifica√ß√£o bastante rara do padr√£o RPC para a constru√ß√£o de sistemas interativos. </p><br><p><img src="https://habrastorage.org/webt/dg/t5/kt/dgt5ktnzqdttmiqv8jne7h6lneg.png"></p><br><h3 id="publish-subscribe-data-distribution-tree">  Publicar-assinar (√°rvore de distribui√ß√£o de dados) </h3><br><p>  Os sistemas orientados a eventos entregam dados aos consumidores, √† medida que os dados est√£o dispon√≠veis.  Assim, os sistemas s√£o mais propensos a empurrar modelos do que puxar ou pesquisar.  Esse recurso permite que voc√™ n√£o desperdice recursos consultando e aguardando dados constantemente. <br>  A figura mostra o processo de distribui√ß√£o de uma mensagem aos consumidores inscritos em um t√≥pico espec√≠fico. </p><br><p><img src="https://habrastorage.org/webt/yg/sp/lx/ygsplxxerjwdvci5gk3hhdn2jay.png"></p><br><p>  Exemplos cl√°ssicos do uso desse modelo s√£o a distribui√ß√£o do estado: o mundo dos jogos em jogos de computador, dados de mercado em trocas, informa√ß√µes √∫teis em feeds de dados. </p><br><p>  Considere o c√≥digo do assinante: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_Args)</span></span></span><span class="hljs-function"> -&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">%%   ,  = key messaging:subscribe(?SUBSCRIPTION, key, tag, self()), {ok, #{}}. handle_info(#exchange_die{exchange = ?SUBSCRIPTION}, State) -&gt; %%    ,    messaging:subscribe(?SUBSCRIPTION, key, tag, self()), {noreply, State}; %%    handle_info(#'$msg'{exchange = ?SUBSCRIPTION, message = Msg}, State) -&gt; ?debugVal(Msg), {noreply, State}; %%    -     terminate(_Reason, _State) -&gt; messaging:unsubscribe(?SUBSCRIPTION, key, tag, self()), ok.</span></span></code> </pre> <br><p>  A fonte pode chamar a fun√ß√£o de publica√ß√£o posterior em qualquer local conveniente: </p><br><pre> <code class="erlang hljs">messaging:publish_message(Exchange, Key, Message).</code> </pre> <br><p>  <em>Troca</em> - o nome do ponto de troca, <br>  <em>Chave</em> - chave de roteamento <br>  <em>Mensagem</em> - carga √∫til </p><br><h2 id="inverted-publish-subscribe">  Assinatura de publica√ß√£o invertida </h2><br><p><img src="https://habrastorage.org/webt/5h/qz/uq/5hqzuqda_rzuvaphv2q3nqjnvcg.png"></p><br><p>  Ao expandir pub-sub, voc√™ pode obter um padr√£o conveniente para o log.  O conjunto de fontes e consumidores pode ser completamente diferente.  A figura mostra um caso com um consumidor e muitas fontes. </p><br><h2 id="task-distribution-pattern">  Padr√£o de distribui√ß√£o de tarefas </h2><br><p>  Em quase todos os projetos, surgem tarefas de processamento diferido, como gerar relat√≥rios, entregar notifica√ß√µes, receber dados de sistemas de terceiros.  A taxa de transfer√™ncia de um sistema que executa essas tarefas √© facilmente escal√°vel, adicionando manipuladores.  Tudo o que resta para n√≥s √© formar um cluster de manipuladores e distribuir uniformemente tarefas entre eles. </p><br><p>  Considere as situa√ß√µes que surgem com o exemplo de 3 manipuladores.  Mesmo no est√°gio de distribui√ß√£o de tarefas, surge a quest√£o da imparcialidade da distribui√ß√£o e do excesso de processadores.  A distribui√ß√£o round-robin ser√° respons√°vel pela justi√ßa e, para evitar uma situa√ß√£o de excesso de manipuladores, introduzimos a restri√ß√£o <em>prefetch_limit</em> .  Nos modos transit√≥rios, o <em>prefetch_limit</em> impedir√° que um manipulador receba todas as tarefas. </p><br><p>  O sistema de mensagens gerencia filas e prioridade de processamento.  Os manipuladores recebem tarefas assim que ficam dispon√≠veis.  A tarefa pode ter √™xito ou falhar: </p><br><ul><li>  <code>messaging:ack(Tack)</code> - chamado em caso de processamento bem-sucedido de mensagens </li><li>  <code>messaging:nack(Tack)</code> - chamado em todas as situa√ß√µes de emerg√™ncia.  Depois que a tarefa retornar, o sistema de mensagens a transferir√° para outro manipulador. </li></ul><br><p><img src="https://habrastorage.org/webt/w6/yi/hc/w6yihc6yyunvigevthjggejkwjq.png"></p><br><p>  Suponha que ocorreu uma falha complexa durante o processamento de tr√™s tarefas: o manipulador 1, depois de receber a tarefa, travou antes que pudesse se comunicar com o ponto de troca.  Nesse caso, o ponto de troca ap√≥s o tempo limite de confirma√ß√£o expirar transferir√° o trabalho para outro manipulador.  O manipulador 3, por algum motivo, abandonou a tarefa e enviou nack, como resultado, a tarefa tamb√©m passou para outro manipulador que a concluiu com √™xito. </p><br><h2 id="predvaritelnyy-itog">  Resultado preliminar </h2><br><p>  Separamos os componentes b√°sicos dos sistemas distribu√≠dos e obtivemos um entendimento b√°sico de sua aplica√ß√£o no Erlang / Elixir. </p><br><p>  Ao combinar padr√µes b√°sicos, voc√™ pode criar paradigmas complexos para resolver problemas emergentes. </p><br><p>  Na parte final do ciclo, consideraremos as quest√µes gerais da organiza√ß√£o de servi√ßos, roteamento e balanceamento, e tamb√©m falaremos sobre o lado pr√°tico da escalabilidade e toler√¢ncia a falhas dos sistemas. </p><br><p>  O fim da segunda parte. </p><br><p>  Foto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Marius Christensen</a> <br>  Ilustra√ß√µes preparadas por websequencediagrams.com </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt446108/">https://habr.com/ru/post/pt446108/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt446096/index.html">O livro ‚ÄúTasteVill: Como fazer uma revolu√ß√£o no varejo, fazendo tudo errado‚Äù</a></li>
<li><a href="../pt446098/index.html">Centro de controle de v√¥o sovi√©tico dos tempos de "Vostok" e "Sunrise"</a></li>
<li><a href="../pt446100/index.html">Crie automaticamente arquivos de localiza√ß√£o Android e iOS a partir da planilha do Excel</a></li>
<li><a href="../pt446104/index.html">O paradoxo do Python</a></li>
<li><a href="../pt446106/index.html">Oleg Shelaev sobre GraalVM em jug.msk.ru</a></li>
<li><a href="../pt446110/index.html">WavesKit - Estrutura de Blockchain do PHP Waves</a></li>
<li><a href="../pt446112/index.html">WavesKit - framework PHP para trabalhar com a plataforma Waves</a></li>
<li><a href="../pt446114/index.html">Modem de 50 anos: uma vis√£o interna</a></li>
<li><a href="../pt446116/index.html">Uma sele√ß√£o de livros sobre como aprender, pensar e tomar decis√µes eficazes</a></li>
<li><a href="../pt446118/index.html">Open Rack v3: o que esperar do novo padr√£o de arquitetura de rack de servidor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>