<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤶🏻 🏹 ✊🏿 全文搜索：针对复杂任务的Elasticsearch特定功能 🚵🏿 🕉️ 🧑🏻‍🤝‍🧑🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好，我叫Andrey，我是一名开发人员。 很久以前-似乎是上周五-我们的团队进行了一个项目，他们需要搜索构成产品的成分。 假设香肠的成分。 在项目的开始阶段，搜索就不需要太多：显示所有包含一定量所需成分的配方； 重复N个成分。 

 但是，将来计划大幅增加产品和成分的数量，并且搜索不仅应应对不断...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>全文搜索：针对复杂任务的Elasticsearch特定功能</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413075/"><img src="https://habrastorage.org/webt/yb/hh/1r/ybhh1rxmqt9yswla3tfbiexyluo.png" alt="图片"><br><br> 大家好，我叫Andrey，我是一名开发人员。 很久以前-似乎是上周五-我们的团队进行了一个项目，他们需要搜索构成产品的成分。 假设香肠的成分。 在项目的开始阶段，搜索就不需要太多：显示所有包含一定量所需成分的配方； 重复N个成分。 <br><a name="habracut"></a><br> 但是，将来计划大幅增加产品和成分的数量，并且搜索不仅应应对不断增加的数据量，而且还应提供其他选项-例如，根据产品的主要成分自动编制产品说明。 <br><br>  <b>要求条件</b> <br><br><ul><li> 使用至少50,000个文档的数据库在Elacsticsearch上创建搜索。 </li><li> 提供对请求的高速响应-少于300毫秒。 </li><li> 为了确保请求量很小，并且即使在最差的移动Internet情况下也可以使用该服务。 </li><li> 从UX的角度来看，使搜索逻辑尽可能直观。 从本质上讲，该界面将反映搜索逻辑，反之亦然。 </li><li> 最小化系统元素之间的中间层数，以实现更高的性能和更少的依赖性。 </li><li> 随时提供机会以新条件补充算法（例如，自动生成产品说明）。 </li><li> 尽可能简单，方便地为项目的搜索部分提供进一步的支持。 </li></ul><br> 我们决定不着急并从简单开始。 <br><br> 首先，我们将产品组合的所有成分存储在一个数据库中，该数据库最初收到了10,000个条目。 不幸的是，即使以这种大小，即使考虑了join-s和索引的使用，搜索数据库也花费了太多时间。 并且在不久的将来，记录的数量应该会超过50,000，此外，该客户坚持使用Elasticsearch（以下简称ES），因为他遇到了这个工具，显然对他有热情。 我们以前没有使用过ES，但是我们知道它的优点并同意这种选择，因为例如，计划将我们经常有新条目（根据每天50到500的各种估计），这是必要的立即分发给用户。 <br><br> 我们决定放弃驱动程序级别的中间层，只使用REST请求，因为与数据库的同步仅在创建文档时进行，并且不再需要。 这是另一个优势-可以将搜索查询直接从浏览器发送到ES。 <br><br> 我们汇总了第一个原型，在该原型中，我们将结构从数据库（PostgreSQL）传输到ES文档： <br><br><pre><code class="php hljs">{<span class="hljs-string"><span class="hljs-string">"mappings"</span></span> : { <span class="hljs-string"><span class="hljs-string">"recipe"</span></span> : { <span class="hljs-string"><span class="hljs-string">"_source"</span></span> : { <span class="hljs-string"><span class="hljs-string">"enabled"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> }, <span class="hljs-string"><span class="hljs-string">"properties"</span></span> : { <span class="hljs-string"><span class="hljs-string">"recipe_id"</span></span> : {<span class="hljs-string"><span class="hljs-string">"type"</span></span> : <span class="hljs-string"><span class="hljs-string">"integer"</span></span>}, <span class="hljs-string"><span class="hljs-string">"recipe_name"</span></span> : {<span class="hljs-string"><span class="hljs-string">"type"</span></span> : <span class="hljs-string"><span class="hljs-string">"text"</span></span>}, <span class="hljs-string"><span class="hljs-string">"ingredients"</span></span> : { <span class="hljs-string"><span class="hljs-string">"type"</span></span> : <span class="hljs-string"><span class="hljs-string">"nested"</span></span>, <span class="hljs-string"><span class="hljs-string">"properties"</span></span>: { <span class="hljs-string"><span class="hljs-string">"ingredient_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"integer"</span></span>, <span class="hljs-string"><span class="hljs-string">"ingredient_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-string"><span class="hljs-string">"manufacturer_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"integer"</span></span>, <span class="hljs-string"><span class="hljs-string">"manufacturer_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-string"><span class="hljs-string">"percent"</span></span>: <span class="hljs-string"><span class="hljs-string">"float"</span></span> } } } } }}</code> </pre> <br> 基于此映射，我们大致获得以下文档（由于NDA，我们无法显示项目中的工作人员）： <br><br><pre> <code class="php hljs">{ <span class="hljs-string"><span class="hljs-string">"recipe_id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"recipe_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"AAA &amp; BBB"</span></span>, <span class="hljs-string"><span class="hljs-string">"ingredients"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"ingredient_id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"ingredient_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"AAA"</span></span>, <span class="hljs-string"><span class="hljs-string">"manufacturer_id"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"manufacturer_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Manufacturer 3"</span></span>, <span class="hljs-string"><span class="hljs-string">"percent"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-string"><span class="hljs-string">"ingredient_id"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"ingredient_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"BBB"</span></span>, <span class="hljs-string"><span class="hljs-string">"manufacturer_id"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"manufacturer_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Manufacturer 4"</span></span>, <span class="hljs-string"><span class="hljs-string">"percent"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> } ] }</code> </pre> <br> 所有这些都是使用Elasticsearch PHP软件包完成的。  Laravel的扩展（Elastiquent，Laravel Scout等）决定不使用它是出于一个原因-客户需要高性能，直到上面提到的“请求300毫秒之多”。 而且Laravel的所有软件包都充当了额外的开销，并且速度变慢了。 本可以直接在Guzzle上完成，但我们决定不走极端。 <br><br> 首先，最简单的配方搜索直接在阵列上完成。 是的，所有这些都被取出到配置文件中，但是相同的请求却太大了。 搜索是在附件文件（相同成分）上进行的，使用“应该”和“必须”在布尔表达式上进行搜索，还存在对附件文件进行强制传递的指令-结果，请求从一百行开始，其请求量从三千字节开始。 <br><br> 不要忘记对响应速度和大小的要求-到那时，API中的答案已经格式化，从而增加了有用的信息量：每个json对象中的键都减少为一个字母。 因此，在几千字节的ES中进行查询成为一种无法接受的奢侈。 <br><br> 那时，我们意识到以PHP关联数组的形式构建大型查询是一种沉迷的习惯。 此外，控制器变得完全不可读，请亲自查看： <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">searchSimilar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> $conditions[] = [ <span class="hljs-string"><span class="hljs-string">"nested"</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">"path"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"ingredients"</span></span>, <span class="hljs-string"><span class="hljs-string">"score_mode"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"max"</span></span>, <span class="hljs-string"><span class="hljs-string">"query"</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">"bool"</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">"must"</span></span> =&gt; [ [<span class="hljs-string"><span class="hljs-string">"term"</span></span> =&gt; [<span class="hljs-string"><span class="hljs-string">"ingredients.ingredient_id"</span></span> =&gt; $ingredient_id]], [<span class="hljs-string"><span class="hljs-string">"range"</span></span> =&gt; [<span class="hljs-string"><span class="hljs-string">"ingredients.percent"</span></span>=&gt;[ <span class="hljs-string"><span class="hljs-string">"lte"</span></span>=&gt;$percent + <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">"gte"</span></span>=&gt;$percent - <span class="hljs-number"><span class="hljs-number">5</span></span> ]]] ] ] ] ] ]; $parameters[<span class="hljs-string"><span class="hljs-string">'body'</span></span>][<span class="hljs-string"><span class="hljs-string">'query'</span></span>][<span class="hljs-string"><span class="hljs-string">'bool'</span></span>][<span class="hljs-string"><span class="hljs-string">'should'</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-string"><span class="hljs-string">'bool'</span></span>][<span class="hljs-string"><span class="hljs-string">'should'</span></span>] = $conditions; <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> $equal_conditions[] = [ <span class="hljs-string"><span class="hljs-string">"nested"</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">"path"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"flavors"</span></span>, <span class="hljs-string"><span class="hljs-string">"query"</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">"bool"</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">"must"</span></span> =&gt; [ [<span class="hljs-string"><span class="hljs-string">"term"</span></span> =&gt; [<span class="hljs-string"><span class="hljs-string">"ingredients.percent"</span></span> =&gt; $percent]] ] ] ] ] ]; $parameters[<span class="hljs-string"><span class="hljs-string">'body'</span></span>][<span class="hljs-string"><span class="hljs-string">'query'</span></span>][<span class="hljs-string"><span class="hljs-string">'bool'</span></span>][<span class="hljs-string"><span class="hljs-string">'should'</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-string"><span class="hljs-string">'bool'</span></span>][<span class="hljs-string"><span class="hljs-string">'must'</span></span>] = $equal_conditions; <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;client-&gt;search($parameters); }</code> </pre> <br> 抒情离题：当涉及到文档中的嵌套字段时，事实证明我们无法满足以下形式的查询： <br><br><pre> <code class="php hljs"><span class="hljs-string"><span class="hljs-string">"query"</span></span>: { <span class="hljs-string"><span class="hljs-string">"bool"</span></span>: { <span class="hljs-string"><span class="hljs-string">"nested"</span></span>: { <span class="hljs-string"><span class="hljs-string">"bool"</span></span>: { <span class="hljs-string"><span class="hljs-string">"should"</span></span>: [ ... ] } } } }</code> </pre> <br> 出于一个简单的原因-您无法在嵌套过滤器中执行多重搜索。 因此，我必须这样做： <br><br><pre> <code class="php hljs"><span class="hljs-string"><span class="hljs-string">"query"</span></span>: { <span class="hljs-string"><span class="hljs-string">"bool"</span></span>: { <span class="hljs-string"><span class="hljs-string">"should"</span></span>: [ {<span class="hljs-string"><span class="hljs-string">"nested"</span></span>: { <span class="hljs-string"><span class="hljs-string">"path"</span></span>: <span class="hljs-string"><span class="hljs-string">"flavors"</span></span>, <span class="hljs-string"><span class="hljs-string">"score_mode"</span></span>: <span class="hljs-string"><span class="hljs-string">"max"</span></span>, <span class="hljs-string"><span class="hljs-string">"query"</span></span>: { <span class="hljs-string"><span class="hljs-string">"bool"</span></span>: { ... } } }} ] } }</code> </pre> <br> 即 首先，声明了应满足条件的数组，并在每个条件内通过嵌套字段调用了搜索。 从Elasticsearch的角度来看，这是更正确和合乎逻辑的。 结果，当我们添加其他搜索词时，我们自己认为这是合乎逻辑的。 <br><br> 在这里，我们发现了ES内置的<s>Google</s>模板。 选择落在Mustache上-一个相当方便的无逻辑模板引擎。 实际上可以将整个请求主体和所有传输的数据放入其中，而无需进行更改，因此最终请求采用以下形式： <br><br><pre> <code class="php hljs">{ <span class="hljs-string"><span class="hljs-string">"template"</span></span>: <span class="hljs-string"><span class="hljs-string">"template1"</span></span>, <span class="hljs-string"><span class="hljs-string">"params"</span></span>: params{} }</code> </pre> <br> 模板的主体非常适度且易于阅读-仅JSON和Mustache本身的指令。 模板存储在Elasticsearch本身中，并按名称调用。 <br><br><pre> <code class="hljs smalltalk">/* search_similar.mustache */ { <span class="hljs-comment"><span class="hljs-comment">"query"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"bool"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"should"</span></span>: [ {<span class="hljs-comment"><span class="hljs-comment">"bool"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"minimum_should_match"</span></span>: {{ minimumShouldMatch }}, <span class="hljs-comment"><span class="hljs-comment">"should"</span></span>: [ {{<span class="hljs-symbol"><span class="hljs-symbol">#ingredientsList</span></span>}} // mustache         ingredientsList {{<span class="hljs-symbol"><span class="hljs-symbol">#ingredients</span></span>}} //         ingredients {<span class="hljs-comment"><span class="hljs-comment">"nested"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"path"</span></span>: <span class="hljs-comment"><span class="hljs-comment">"ingredients"</span></span>, <span class="hljs-comment"><span class="hljs-comment">"score_mode"</span></span>: <span class="hljs-comment"><span class="hljs-comment">"max"</span></span>, <span class="hljs-comment"><span class="hljs-comment">"query"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"bool"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"must"</span></span>: [ {<span class="hljs-comment"><span class="hljs-comment">"term"</span></span>: {<span class="hljs-comment"><span class="hljs-comment">"ingredients.flavor_id"</span></span>: {{ id }} }}, {<span class="hljs-comment"><span class="hljs-comment">"range"</span></span>: {<span class="hljs-comment"><span class="hljs-comment">"ingredients.percent"</span></span> : { <span class="hljs-comment"><span class="hljs-comment">"lte"</span></span>: {{ lte }}, <span class="hljs-comment"><span class="hljs-comment">"gte"</span></span>: {{ gte }} }}} ] } } }} {{^isLast}},{{/isLast}} //    {{/ingredients}} {{/ingredientsList}} ] }} ] } } } /*  */ { <span class="hljs-comment"><span class="hljs-comment">"template"</span></span>: <span class="hljs-comment"><span class="hljs-comment">"search_similar"</span></span>, <span class="hljs-comment"><span class="hljs-comment">"params"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"minimumShouldMatch"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">"ingredientsList"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"ingredients"</span></span>: [ {<span class="hljs-comment"><span class="hljs-comment">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">"lte"</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-comment"><span class="hljs-comment">"gte"</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-comment"><span class="hljs-comment">"isLast"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } ] } } }</code> </pre> <br> 结果，在输出中，我们得到了一个模板，我们只需将一系列必要的成分传递给模板。 从逻辑上讲，该请求与以下条件并没有太大区别： <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ingredients <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> recipes <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> recipes.id = ingredient.recipe_id <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> ingredients.id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ingredients.id <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ingredients.percent <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-number"><span class="hljs-number">10.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">20.0</span></span></code> </pre> <br> 但是他的工作速度更快，这是进一步提出要求的现成基础。 <br><br> 在这里，除了百分比搜索外，我们还需要其他几种类型的操作：按名称搜索配料，组和配方名称； 考虑到成分在配方中的容忍度，通过成分ID搜索； 相同的查询，但是在四个条件下计算了结果（随后重做了另一个任务），以及最终查询。 <br><br> 该请求需要以下逻辑：对于每种成分，有五个将其与任何组相关联的标签。 按照惯例，猪肉和牛肉是肉，鸡肉和火鸡是家禽。 每个标签都位于其自己的级别。 基于这些标签，我们可以为配方创建条件描述，这使我们能够自动生成搜索树和/或描述。 例如，香肠肉和牛奶加香料，肝脏和大豆，清真鸡肉。 单个配方可以包含具有相同标签的多种成分。 这样一来，我们就无需再用双手塞满标签链了-根据食谱的组成，我们已经可以清楚地描述它了。 随附文档的结构也已更改： <br><br><pre> <code class="php hljs">{ <span class="hljs-string"><span class="hljs-string">"ingredient_id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"ingredient_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"AAA"</span></span>, <span class="hljs-string"><span class="hljs-string">"manufacturer_id"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"manufacturer_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Manufacturer 3"</span></span>, <span class="hljs-string"><span class="hljs-string">"percent"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"level_1"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"level_2"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"level_3"</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"level_4"</span></span>: <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-string"><span class="hljs-string">"level_5"</span></span>: <span class="hljs-number"><span class="hljs-number">12</span></span> }</code> </pre> <br> 还需要根据配方的“纯度”条件来指定搜索。 例如，我们需要一个食谱，其中只有牛肉，盐和胡椒粉。 然后，我们必须淘汰仅在第一层上只有牛肉，在第二层上只有香料的食谱（香料的第一个标签为零）。 在这里，我不得不作弊：由于胡须是没有逻辑的模板，因此不能谈论任何计算。 此处要求以ES脚本语言-Painless在请求中实现脚本的一部分。 它的语法尽可能接近Java，因此没有困难。 结果，我们有了一个用于生成JSON的Mustache模板，其中部分计算（即排序和过滤）是在Painless上实现的： <br><br><pre> <code class="hljs django"><span class="xml"><span class="xml">"filter": [ </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{#levelsList}}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{#levels}}</span></span><span class="xml"><span class="xml"> {"script": { "script": " int total=0; for (ingredient in params._source.ingredients){ if ([0,</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{tag}}</span></span><span class="xml"><span class="xml">].contains(ingredient.level_</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{id}}</span></span><span class="xml"><span class="xml">)) total+=1; } return (total==params._source.ingredients.length); " }} </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{^isLast}}</span></span><span class="xml"><span class="xml">,</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{/isLast}}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{/levels}}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{/levelsList}}</span></span><span class="xml"><span class="xml"> ]</span></span></code> </pre><br> 在下文中，脚本主体经过格式化以提高可读性，不能在请求中使用换行符。 <br><br> 到那时，我们消除了对成分含量的耐受性，发现了一个瓶颈-我们只能考虑牛肉香肠，因为在那里找到了这种成分。 然后，我们添加了所有内容（在相同的Painless脚本上进行了过滤），条件是该成分应在合成中占主导地位： <br><br><pre> <code class="hljs django"><span class="xml"><span class="xml">"filter": [ {"script":{ "script": " double nest=0,rest=0; for (ingredient in params._source.ingredients){ if([</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{#tags}}</span></span><span class="xml"></span><span class="hljs-template-variable"><span class="xml"></span><span class="hljs-template-variable">{{tagId}}</span></span><span class="xml"></span><span class="hljs-template-variable"><span class="xml"></span><span class="hljs-template-variable">{{^isLast}}</span></span><span class="xml"><span class="xml">,</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{/isLast}}</span></span><span class="xml"></span><span class="hljs-template-variable"><span class="xml"></span><span class="hljs-template-variable">{{/tags}}</span></span><span class="xml"><span class="xml">].contains(flavor.level_</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{tags.0.levelId}}</span></span><span class="xml"><span class="xml">)){ nest+= ingredient.percent; }else{ if (ingredient.percent&gt;rest){rest = ingredient.percent} } } return(nest&gt;=rest); " }} ]</span></span></code> </pre> <br> 如您所见，Elasticsearch在此项目中缺少很多东西，因此必须通过“可用方式”进行组合。 但这不足为奇-该项目对于用于全文搜索的机器来说已经足够非典型了。 <br><br> 在项目的中间阶段之一，我们需要做以下事情：显示所有可用成分组的列表以及每个组的位置数量。 在这里，与普遍查询中出现的问题相同：在10,000个食谱中，根据内容生成了大约10组。 但是，这些组中总共有大约40,000种配方，根本与现实不符。 然后，我们开始研究并行查询。 <br><br> 在第一个请求中，我们收到了第一级所有组的列表，但没有条目数量。 此后，产生了一个多重请求：对于每个组，根据现行百分比的原则，要求接收实际食谱的数量。 所有这些请求都收集到一个中，然后发送到Elasticsearch。 一般请求的响应时间等于最慢请求的处理时间。 批量聚合可以并行化它们。  SQL中类似的逻辑（仅通过按查询中的条件分组）花费了大约15倍的时间。 <br><br><pre> <code class="hljs markdown">/<span class="hljs-bullet"><span class="hljs-bullet">*   *</span></span>/ $params = config('elastic.params'); $params[<span class="hljs-string"><span class="hljs-string">'body'</span></span>] = config('elastic.top_list'); return (Elastic::getClient()-&gt;search($params))[<span class="hljs-string"><span class="hljs-string">'aggregations'</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">'tags'</span></span>][<span class="hljs-string"><span class="hljs-string">'buckets'</span></span>]; /<span class="hljs-bullet"><span class="hljs-bullet">*   *</span></span>/</code> </pre><br> 之后，我们需要评估： <br><br><ol><li> 当前配方有多少种配方可用； </li><li> 我们还可以向组合物中添加哪些其他成分（有时我们添加了成分并得到了一个空样品）； </li><li> 在此级别中，我们可以将所选成分中的哪些成分标记为唯一。 </li></ol><br> 根据任务，我们结合了收到的针对配方列表的最后一个请求的逻辑和从所有可用组的列表中获取确切编号的逻辑： <br><br><pre> <code class="hljs smalltalk">/*  */ <span class="hljs-comment"><span class="hljs-comment">"aggs"</span></span> : { //      <span class="hljs-comment"><span class="hljs-comment">"tags"</span></span> :{ //    <span class="hljs-comment"><span class="hljs-comment">"terms"</span></span> :{ <span class="hljs-comment"><span class="hljs-comment">"field"</span></span> : <span class="hljs-comment"><span class="hljs-comment">"ingredients.level_{{ level }}"</span></span>, <span class="hljs-comment"><span class="hljs-comment">"order"</span></span> : {<span class="hljs-comment"><span class="hljs-comment">"_term"</span></span> : <span class="hljs-comment"><span class="hljs-comment">"asc"</span></span>}, <span class="hljs-comment"><span class="hljs-comment">"exclude"</span></span> : [ {{<span class="hljs-symbol"><span class="hljs-symbol">#exclude</span></span>}}{{ id }},{{/exclude}} <span class="hljs-number"><span class="hljs-number">0</span></span>] }, <span class="hljs-comment"><span class="hljs-comment">"aggs"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"reverse_nested"</span></span>: {} } //    ,    } } /*   */ foreach (<span class="hljs-string"><span class="hljs-string">$n</span></span>ot_only as <span class="hljs-string"><span class="hljs-string">$e</span></span>lement) { <span class="hljs-string"><span class="hljs-string">$p</span></span>arameters[<span class="hljs-string"><span class="hljs-string">'body'</span></span>][] = config(<span class="hljs-string"><span class="hljs-string">'elastic.params'</span></span>); <span class="hljs-string"><span class="hljs-string">$p</span></span>arameters[<span class="hljs-string"><span class="hljs-string">'body'</span></span>][] = self::getParamsBody( <span class="hljs-string"><span class="hljs-string">$b</span></span>ody, collect(<span class="hljs-string"><span class="hljs-string">$o</span></span>nly-&gt;all())-&gt;push(<span class="hljs-string"><span class="hljs-string">$e</span></span>lement), <span class="hljs-string"><span class="hljs-string">$m</span></span>ax_level, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ); } /*   */ <span class="hljs-string"><span class="hljs-string">$p</span></span>arameters[<span class="hljs-string"><span class="hljs-string">'body'</span></span>][] = config(<span class="hljs-string"><span class="hljs-string">'elastic.params'</span></span>); <span class="hljs-string"><span class="hljs-string">$p</span></span>arameters[<span class="hljs-string"><span class="hljs-string">'body'</span></span>][] = self::getParamsBody( <span class="hljs-string"><span class="hljs-string">$b</span></span>ody, <span class="hljs-string"><span class="hljs-string">$o</span></span>nly, <span class="hljs-string"><span class="hljs-string">$m</span></span>ax_level, <span class="hljs-string"><span class="hljs-string">$f</span></span>rom, <span class="hljs-string"><span class="hljs-string">$s</span></span>ize<span class="hljs-string"><span class="hljs-string">') ); /*     */ $parameters['</span></span>max_concurrent_searches<span class="hljs-string"><span class="hljs-string">'] = 1 + $not_only-&gt;count(); return (Elastic::getClient()-&gt;msearchTemplate($parameters))['</span></span>responses<span class="hljs-string"><span class="hljs-string">'];</span></span></code> </pre> <br> 结果，我们收到了一个请求，该请求查找了所有必要的食谱及其总数（取自响应[“ hits”] [“ total”]）。 为简单起见，此请求记录在列表的最后位置。 <br><br> 此外，通过汇总，我们收到了下一个级别的所有ID成分。 对于未标记为“唯一”的每种成分，我们创建了一个查询，在其中进行了相应的标记，然后简单地计算了找到的文档数。 如果它大于零，则认为该成分可用于分配键“单”。 我认为您可以在没有我的情况下还原整个模板，我们在输出中得到了： <br><br><pre> <code class="hljs smalltalk">{ <span class="hljs-comment"><span class="hljs-comment">"from"</span></span>: {{ from }}, <span class="hljs-comment"><span class="hljs-comment">"size"</span></span>: {{ size }}, <span class="hljs-comment"><span class="hljs-comment">"query"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"bool"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"must"</span></span>: [ {{<span class="hljs-symbol"><span class="hljs-symbol">#ingredientTags</span></span>}} {{<span class="hljs-symbol"><span class="hljs-symbol">#tagList</span></span>}} {<span class="hljs-comment"><span class="hljs-comment">"bool"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"should"</span></span>: [ {<span class="hljs-comment"><span class="hljs-comment">"term"</span></span>: {<span class="hljs-comment"><span class="hljs-comment">"level_{{ levelId }}"</span></span>: {{ tagId }} }} ] }} {{^isLast}},{{/isLast}} {{/tagList}} {{/ingredientTags}} ], <span class="hljs-comment"><span class="hljs-comment">"filter"</span></span>: [ {<span class="hljs-comment"><span class="hljs-comment">"script"</span></span>:{ <span class="hljs-comment"><span class="hljs-comment">"script"</span></span>: <span class="hljs-comment"><span class="hljs-comment">" double nest=0,rest=0; for(ingredient in params._source. ingredients){ if([{{#tags}}{{tagId}}{{^isLast}},{{/isLast}}{{/tags}}].contains(ingredient.level_{{tags.0.levelId}})){ nest+= ingredient.percent; }else{ if (ingredient.percent&gt;rest){ rest= ingredient.percent } } } return(nest&gt;=rest); "</span></span> }} {{<span class="hljs-symbol"><span class="hljs-symbol">#levelsList</span></span>}}, {{<span class="hljs-symbol"><span class="hljs-symbol">#levels</span></span>}} {<span class="hljs-comment"><span class="hljs-comment">"script"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"script"</span></span>: <span class="hljs-comment"><span class="hljs-comment">" int total=0; for(ingredient in params._source.ingredients){ if ([0,{{tag}}].contains(ingredient.level_{{id}})) total+=1; } return (total==params._source.ingredients.length); "</span></span> }} {{^isLast}},{{/isLast}} {{/levels}} {{/levelsList}} ] } }, <span class="hljs-comment"><span class="hljs-comment">"aggs"</span></span> : { <span class="hljs-comment"><span class="hljs-comment">"tags"</span></span> :{ <span class="hljs-comment"><span class="hljs-comment">"terms"</span></span> :{ <span class="hljs-comment"><span class="hljs-comment">"field"</span></span> : <span class="hljs-comment"><span class="hljs-comment">"ingredients.level_{{ level }}"</span></span>, <span class="hljs-comment"><span class="hljs-comment">"order"</span></span> : {<span class="hljs-comment"><span class="hljs-comment">"_term"</span></span> : <span class="hljs-comment"><span class="hljs-comment">"asc"</span></span>}, <span class="hljs-comment"><span class="hljs-comment">"exclude"</span></span> : [ {{<span class="hljs-symbol"><span class="hljs-symbol">#exclude</span></span>}}{{ id }},{{/exclude}} <span class="hljs-number"><span class="hljs-number">0</span></span>] }, <span class="hljs-comment"><span class="hljs-comment">"aggs"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">"reverse_nested"</span></span>: {} } } }, <span class="hljs-comment"><span class="hljs-comment">"sort"</span></span>: [ {<span class="hljs-comment"><span class="hljs-comment">"_score"</span></span>: {<span class="hljs-comment"><span class="hljs-comment">"order"</span></span>: <span class="hljs-comment"><span class="hljs-comment">"desc"</span></span>}} ] }</code> </pre><br> 当然，我们缓存了一部分模板和查询（例如，所有可用组的页面以及可用配方的数量），这在主页上增加了一些性能。 这一决定使得可以在50毫秒内收集主要数据。 <br><br>  <b>项目成果</b> <br><br> 我们在Elasticsearch的数据库中进行了至少50,000个文档的搜索，使您可以搜索产品中的成分，并通过其中包含的成分获得产品的描述。 很快该数据库将增长大约六倍（正在准备数据），因此我们对我们的结果以及将Elasticsearch用作搜索工具感到非常满意。 <br><br> 在性能问题上，我们满足了项目的要求，我们自己很高兴对请求的平均响应时间为250-300毫秒。 <br><br> 在开始使用Elasticsearch的三个月后，它似乎不再那么令人困惑和异常。 模板的优势非常明显：如果我们发现请求再次变得太大，我们只需将附加逻辑转移到模板，然后将原始请求再次发送到服务器，几乎没有任何更改。 <br><br>  “万事如意，谢谢你的鱼！”  （c） <br><br>  <b>PS</b>最后，我们还需要按名称中的俄语字符进行排序。 然后事实证明，Elasticsearch无法充分理解俄语字母。 有条件的香肠“超大猪肉9000卡路里”在分类内部变成了“ 9000”，排在最后。 事实证明，通过将俄语字符转换为u042B形式的unicode表示法，可以很容易地解决此问题。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN413075/">https://habr.com/ru/post/zh-CN413075/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN413063/index.html">在相变中测试自制保温杯</a></li>
<li><a href="../zh-CN413065/index.html">C＃8.0中计划的新功能</a></li>
<li><a href="../zh-CN413069/index.html">音频搜索，音频SEO和播客帮助-已开始使用Google专家</a></li>
<li><a href="../zh-CN413071/index.html">DeepMind教AI玩YouTube视频游戏</a></li>
<li><a href="../zh-CN413073/index.html">如何使用云：关于PD，IS和IaaS的30种材料，实用指南和技巧</a></li>
<li><a href="../zh-CN413077/index.html">255号移动开发人员的有趣材料摘要（5月28日至6月3日）</a></li>
<li><a href="../zh-CN413083/index.html">麻省理工学院的开发人员创建了具有精确动作协调性的仿生假体</a></li>
<li><a href="../zh-CN413087/index.html">男子汽车助手</a></li>
<li><a href="../zh-CN413091/index.html">在SpringBoot + Log4j2 + Maven中方便地记录日志</a></li>
<li><a href="../zh-CN413093/index.html">预期美国和中国的太空商人竞赛</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>