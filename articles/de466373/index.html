<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧜🏾 👨‍👦‍👦 🔪 Python TamTam Bot Entwicklung 🏇🏻 🧖 🎊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Lassen Sie mich mich vorstellen: Mein Name ist Sergey Agaltsov und ich bin ein "Programmierer im Leben". Dies bedeutet, dass ich seit lang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python TamTam Bot Entwicklung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/466373/"><p><img src="https://habrastorage.org/webt/hv/5y/zn/hv5yzn1xbdnmstacgsl-4bqqcfc.jpeg"></p><br><p>  Hallo Habr!  Lassen Sie mich mich vorstellen: Mein Name ist Sergey Agaltsov und ich bin ein "Programmierer im Leben".  Dies bedeutet, dass ich seit langem IT-Manager und von Beruf überhaupt kein Programmierer bin, aber ich benutze die Programmierung ständig, sowohl in meiner Haupttätigkeit als auch als Hobby.  Wie einer meiner ehemaligen Chefs oft sagte: "Seryoga! Sie sind wieder in die Programmierung gerutscht!"  Ich kann zwar nicht sagen, dass er oder jemand anderes jemals sehr unzufrieden damit war. </p><br><p>  Nach dem Erscheinen der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bot-API</a> im TamTam-Messenger habe ich als echter und daher fauler Programmierer zwei Python-Bibliotheken erstellt, um damit zu arbeiten: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Open Client API</a> (im Folgenden - OAC) - generierte es zunächst mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenAPI-Generator</a> basierend auf dem API-Schema und passte es dann unter Berücksichtigung der Merkmale des Generators an. </li><li>  Die Shell für diesen Client ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TamTamBot</a> (im Folgenden: TTB), was die Arbeit mit OAC vereinfacht. </li></ul><br><p>  Es gab also ein bestimmtes TamTam Python SDK. </p><br><p>  Ich tat es zuerst "für mich selbst, für die Seele", schlug aber auch vor, dass die TamTam-Community es auf Wunsch verwenden sollte.  Aber wie Sie wissen, bleibt keine einzige gute Tat ungestraft - die Leute werden gebeten, einen Schulungsartikel zu schreiben.  Und hier bin ich mit diesem Artikel.  Darin werde ich Ihnen erklären, wie Sie mit diesen Bibliotheken einen einfachen Bot entwickeln. </p><a name="habracut"></a><br><h1 id="zadacha">  Herausforderung </h1><br><p>  Entwickeln Sie einen Bot, der die Aktionen von Bot-Entwicklern vereinfachen soll.  Der Bot sollte im Modus der permanenten Abfrage der staatlichen Bot-API (Long Polling) arbeiten.  In diesem Artikel wird der Bot geschult, um die Innenseiten der an ihn gesendeten Nachricht anzuzeigen, und außerdem so konfiguriert, dass er der entwickelten Funktionalität entspricht. </p><br><p>  Es versteht sich, dass der Leser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Python 3</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">git</a> , installiert hat, das mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PyCharm-</a> Entwicklungsumgebung verbunden ist (die Entwicklungsumgebung kann unterschiedlich sein, aber die Geschichte basiert auf PyCharm).  Es ist wünschenswert, die Grundlagen von OOP zu verstehen. </p><br><h1 id="poluchenie-tokena-bota">  Einen Bot-Token bekommen </h1><br><p>  Das Token wird durch einen Aufruf an den spezialisierten Bot <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@PrimeBot erhalten</a> </p><br><p>  Wir finden diesen Bot in TamTam, geben den Befehl / create ein und beantworten die Fragen: </p><br><ul><li> Geben Sie den eindeutigen Kurznamen des Bots in lateinischen Buchstaben ein - dies ist der Benutzername des Bots, unter dem er über @ oder über einen Link des Formulars <code>https://tt.me/username</code> verfügbar sein wird.  Es gibt keine besonderen Einschränkungen für den Benutzernamen.  Insbesondere ist das Wort Bot optional. </li><li>  Geben Sie einen Namen ein - dies ist der Anzeigename des Bots.  Hier können Sie bereits das kyrillische Alphabet verwenden. </li></ul><br><p>  Wenn alles korrekt eingegeben wurde, wird der erstellte Bot zu den Kontakten hinzugefügt und im Gegenzug erhalten wir ein Token - eine Folge von Zeichen der Form: HDyDvomx6TfsXkgwfFCUY410fv-vbf4XVjr8JVSUu4c. </p><br><h1 id="pervichnaya-nastroyka">  Ersteinrichtung </h1><br><div class="spoiler">  <b class="spoiler_title">Zeigen</b> <div class="spoiler_text"><p>  Erstellen Sie ein Verzeichnis: </p><br><pre> <code class="plaintext hljs">mkdir ttBotDevHelper</code> </pre> <br><p>  Gehen Sie dazu: </p><br><pre> <code class="plaintext hljs">cd ttBotDevHelper/</code> </pre> <br><p>  Wir initialisieren das Git-Repository: </p><br><pre> <code class="plaintext hljs">git init</code> </pre> <br><p>  Laden Sie die erforderlichen Bibliotheken herunter und fügen Sie sie als Submodule von git hinzu: </p><br><pre> <code class="plaintext hljs">git submodule add https://github.com/asvbkr/openapi_client.git openapi_client git submodule add https://github.com/asvbkr/TamTamBot.git TamTamBot</code> </pre> <br><p>  Wir öffnen das erstellte Verzeichnis in PyCharm (z. B. im Explorer unter dem Kontextmenü "Ordner als PyCharm-Projekt öffnen") und erstellen eine Datei, die unser Bot enthalten wird - Datei / Neu / Python-Datei.  Geben Sie im angezeigten Dialogfeld den Namen ttBotDevHelper ein und beantworten Sie die Frage nach dem Hinzufügen zu git positiv. </p><br><p>  Jetzt müssen wir eine virtuelle Umgebung für unser Projekt erstellen. </p><br><p>  Um eine virtuelle Umgebung zu erstellen, wählen Sie Datei / Einstellungen und dann den Unterschlüssel Projektinterpreter auf der Registerkarte Projekt.  Klicken Sie anschließend rechts auf das Zahnradsymbol und wählen Sie Hinzufügen: </p><br><p><img src="https://habrastorage.org/webt/dg/js/qv/dgjsqvo0ygtsp12lehregxcm8po.png" alt="Bild"></p><br><p>  PyCharm bietet eine eigene Unterkunftsmöglichkeit an. </p><br><p><img src="https://habrastorage.org/webt/lp/gg/og/lpggogip_ekpmuoiegolvfxyk2s.png" alt="Bild"></p><br><p>  Es macht Sinn, ihm zuzustimmen. </p><br><p>  Nach dem Erstellen der virtuellen Umgebung wird der vorherige Bildschirm geöffnet, der jedoch bereits Informationen zur erstellten Umgebung enthält.  Auf diesem Bildschirm müssen Sie die erforderlichen Pakete installieren, indem Sie rechts auf das Symbol "+" klicken und die Paketnamen eingeben: </p><br><ul><li>  Anfragen </li><li>  sechs </li></ul><br><p>  Anschließend fügen wir dem Projekt die .gitignore-Datei mit folgenden Inhalten hinzu, mit Ausnahme der Dateien, die in git nicht benötigt werden: </p><br><pre> <code class="plaintext hljs">venv/ .idea/ # Byte-compiled / optimized / DLL files __pycache__/ *.py[cod] *$py.class *.log *.log.* .env ttb.sqlite3</code> </pre> <br><p>  Fügen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine Umgebungsvariable mit dem</a> Namen <code>TT_BOT_API_TOKEN</code> , in der wir den Wert des Tokens unseres Bots angeben, das von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tt.me/primebot</a> empfangen wurde, und starten Sie PyCharm neu. </p><br><p>  <strong>(!)</strong> Anstatt eine Umgebungsvariable direkt zur Betriebssystemumgebung hinzuzufügen, verwendet PyCharm optimalerweise eine spezielle .env-Datei.  Die Konfiguration wird unten erläutert. </p><br><p>  Herzlichen Glückwunsch, jetzt können Sie mit dem interessantesten Teil fortfahren - dem Schreiben Ihres Bots. </p></div></div><br><h1 id="zapusk-prosteyshego-bota">  Einfacher Bot-Start </h1><br><p>  Öffnen Sie die Datei ttBotDevHelper.py und schreiben Sie die ersten Zeilen: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: UTF-8 -*- from TamTamBot.TamTamBot import TamTamBot class BotDevHelper(TamTamBot): pass</span></span></code> </pre> <br><p>  Hier erstellen wir unsere Bot-Klasse basierend auf der TamTamBot-Klasse. </p><br><p>  PyCharm schlägt vor, dass die BotDevHelper-Klasse abstrakte Methoden enthält, die implementiert werden müssen.  Drücken Sie die Alt-Eingabetaste für den Klassennamen, wählen Sie "Abstrakte Methoden implementieren", wählen Sie alle von PyCharm vorgeschlagenen Methoden (2 davon) aus und klicken Sie auf OK.  Infolgedessen werden zwei leere Eigenschaftsmethoden hinzugefügt: Token und Beschreibung.  Wir ändern den resultierenden Code wie folgt: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: UTF-8 -*- import os from TamTamBot.TamTamBot import TamTamBot from TamTamBot.utils.lng import set_use_django class BotDevHelper(TamTamBot): @property def token(self): return os.environ.get('TT_BOT_API_TOKEN') @property def description(self): return '       .\n\n' \ 'This bot is an helper in the development and management of bots.' if __name__ == '__main__': set_use_django(False) BotDevHelper().polling()</span></span></code> </pre> <br><p>  Die <code>token</code> Eigenschaft gibt das Token unseres Bots zurück, dessen Wert aus der Umgebungsvariablen <code>TT_BOT_API_TOKEN</code> .  Die <code>description</code> Eigenschaft gibt eine erweiterte Beschreibung unseres Bots zurück, die den Benutzern angezeigt wird. </p><br><p>  Der Code am Ende der Datei wird benötigt, um unseren Bot im Statusabfragemodus auszuführen. </p><br><p>  Ich <code>TamTamBot</code> fest, dass die Basisklasse <code>TamTamBot</code> die Verwendung des Django-Webservers für die Arbeit im Web-Hook-Modus beinhaltet.  Aber jetzt ist die Aufgabe einfacher und wir brauchen kein Django, was wir in der <code>set_use_django(False)</code> .  Hier wird die <code>polling()</code> -Methode für das Objekt unserer Klasse aufgerufen, wodurch der Betrieb im erforderlichen Modus sichergestellt wird. </p><br><p>  Das notwendige Minimum ist erledigt.  Dieser Code funktioniert bereits ziemlich gut.  Führen Sie es aus, um zu laufen.  Drücken Sie dazu die Tastenkombination Strg-Umschalt-F10. </p><br><p>  Wenn Sie zuvor keine Umgebungsvariable direkt zum Betriebssystem hinzugefügt haben, tritt beim Start ein Fehler mit der Meldung "Kein Zugriffstoken" auf.  Um dies zu beheben, konfigurieren Sie PyCharm für die Verwendung der ENV-Datei. </p><br><div class="spoiler">  <b class="spoiler_title">Zeigen Sie wie</b> <div class="spoiler_text"><p>  Erstellen Sie eine .env-Textdatei.  Sein Inhalt sollte in unserem Fall wie folgt sein: </p><br><pre> <code class="plaintext hljs">TT_BOT_API_TOKEN=__</code> </pre> <br><p>  Jetzt müssen Sie es mit der Startkonfiguration in PyCharm verbinden: </p><br><p>  Wir wählen Konfiguration ausführen / bearbeiten und verbinden auf der Registerkarte EnvFile unsere .env-Datei: </p><br><p><img src="https://habrastorage.org/webt/2s/6s/ci/2s6scissf6roedcy6r26rjoi6ve.png" alt="Bild"></p><br><p>  Klicken Sie dann auf Übernehmen. </p></div></div><br><p>  Nachdem Sie den Bot gestartet haben, können Sie zu TamTam gehen, einen Dialog mit unserem Bot öffnen und auf die Schaltfläche "Start" klicken.  Der Bot meldet Informationen über seine verborgenen Superkräfte.  Dies bedeutet, dass der Bot arbeitet.  Während der Bot im Demo-Modus arbeitet, stehen 4 Befehle zur Verfügung.  Schau sie dir einfach an. </p><br><p>  Trotz der ausgesprochenen Meinung des Bots über seine Coolness deutet er schüchtern an, dass er bisher nichts tun kann.  Ihm alles beizubringen, was für die Eroberung der Welt notwendig ist, ist unsere Aufgabe. </p><br><h1 id="priyom-soobscheniya-istochnika-i-otpravka-otvetnogo-soobscheniya-s-vnutrennim-predstavleniem-soobscheniya-istochnika">  Empfangen einer Quellnachricht und Senden einer Antwortnachricht mit einer internen Darstellung der Quellnachricht </h1><br><p>  Wir werden die Methode <code>receive_text()</code> blockieren, deren Kontrolle beim Senden von Text an den Chat mit dem Bot übertragen wird: </p><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive_text</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, update)</span></span></span><span class="hljs-function">:</span></span> res = self.msg.send_message(NewMessageBody(<span class="hljs-string"><span class="hljs-string">f' : </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{update.message}</span></span></span><span class="hljs-string">'</span></span>, link=update.link), user_id=update.user_id) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bool(res)</code> </pre> <br><p>  Das <code>update</code> Objekt der <code>UpdateCmn</code> Klasse, das an diese Methode übergeben wird, enthält verschiedene nützliche Informationen und insbesondere alles, was wir jetzt benötigen: </p><br><ul><li>  <code>update.message</code> - ein Objekt, das die Nachricht selbst enthält; </li><li>  <code>update.link</code> - fertiger Antwortlink zu dieser Nachricht; </li><li>  <code>update.user_id</code> - Kennung des Benutzers, der die Nachricht gesendet hat. </li></ul><br><p>  Um eine Nachricht vom Bot zu senden, verwenden wir die Variable <code>self.msg</code> , die das <code>MessagesApi</code> Objekt enthält, das die im Abschnitt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nachrichten</a> der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">API-Beschreibung</a> beschriebenen Funktionen implementiert.  Dieses Objekt enthält die von uns <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>send_message()</code></a> Methode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>send_message()</code></a> , mit der Nachrichten gesendet werden können.  Dieser Methode muss mindestens ein Objekt der <code>NewMessageBody</code> Klasse und das Ziel übergeben werden - in unserem Fall die Benutzer-ID. </p><br><p>  In diesem Fall wird wiederum ein Objekt der <code>NewMessageBody</code> Klasse erstellt, indem eine Textdarstellung des <code>NewMessageBody</code> und ein Antwortlink zur <code>NewMessageBody</code> übertragen werden. </p><br><p>  Wir starten unseren Bot neu und überprüfen in einem Dialog mit dem Bot, ob der Bot eine Antwort auf eine unserer Nachrichten generiert, die die interne Darstellung des Quellnachrichtenobjekts enthält. </p><br><p>  Der Quellcode für diesen Status ist <a href="">hier</a> . </p><br><h1 id="dobavlenie-novoy-komandy-bota-s-parametrom---pokaz-vnutrennego-predstavleniya-soobscheniya-po-ego-identifikatoru">  Hinzufügen eines neuen Bot-Befehls mit einem Parameter - Zeigt die interne Darstellung der Nachricht anhand ihrer Kennung an </h1><br><p>  Bei der Entwicklung von Bots ist es häufig erforderlich, die interne Darstellung einer Nachricht anhand einer oder mehrerer bekannter Nachrichtenkennungen (Nachrichten-ID - Mitte) zu überprüfen.  Fügen Sie diese Funktionalität unserem Bot hinzu.  Dazu nehmen wir zunächst in einer separaten Methode die Funktionalität der Ausgabe von Informationen über die interne Darstellung von Nachrichten heraus: </p><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view_messages</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, update, list_mid, link=None)</span></span></span><span class="hljs-function">:</span></span> res = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> msgs = self.msg.get_messages(message_ids=list_mid) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> msgs: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> msg <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> msgs.messages: r = self.msg.send_message(NewMessageBody(<span class="hljs-string"><span class="hljs-string">f' </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{msg.body.mid}</span></span></span><span class="hljs-string">:\n`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{msg}</span></span></span><span class="hljs-string">`'</span></span>[:NewMessageBody.MAX_BODY_LENGTH], link=link), user_id=update.user_id) res = res <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res</code> </pre> <br><p>  Bei dieser Methode übergeben wir eine Liste von mid. </p><br><p>  Um Nachrichtenobjekte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>self.msg.get_messages</code></a> , verwenden wir die Methode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>self.msg.get_messages</code></a> , die eine Liste von Objekten in der Eigenschaft messages zurückgibt. </p><br><p>  Ferner wird eine Textdarstellung jeder der empfangenen Nachrichten in separaten Nachrichten an unseren Dialog gesendet.  Um Fehler zu vermeiden, wird der Text der generierten Nachricht durch die Konstante der maximalen Nachrichtenlänge - <code>NewMessageBody.MAX_BODY_LENGTH</code> - <code>NewMessageBody.MAX_BODY_LENGTH</code> . </p><br><p>  Fügen Sie dann eine Methode hinzu, die den Befehl verarbeitet.  Nennen <strong>wir</strong> es <strong>vmp</strong> .  Sie können die Mittelliste mit einem Leerzeichen an den Befehl übergeben. </p><br><p>  TTB ist so konzipiert, dass der Befehlshandler als Methode mit dem Namen <code>cmd_handler_%s</code> , wobei% s der Name des Befehls ist.  Das heißt,  Für den Befehl vmp heißt die Methode <code>cmd_handler_vmp</code> .  Ein Objekt der <code>UpdateCmn</code> Klasse wird an den Befehlshandler übergeben.  Darüber hinaus kann ein Befehl die Eigenschaft <code>cmd_args</code> enthalten, die ein Wörterbuch mit Zeilen und Wörtern enthält, die mit dem Befehl eingegeben wurden </p><br><p>  Der Code sieht folgendermaßen aus: </p><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cmd_handler_vmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, update)</span></span></span><span class="hljs-function">:</span></span> res = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> update.this_cmd_response: <span class="hljs-comment"><span class="hljs-comment">#    ,       if update.cmd_args: #        list_id = [] parts = update.cmd_args.get('c_parts') or [] if parts: for line in parts: for part in line: list_id.append(str(part)) if list_id: res = self.view_messages(update, list_id, update.link) return bool(res)</span></span></code> </pre> <br><p>  Wir starten den Bot neu.  Wenn Sie nun im Dialog des Bots einen Befehl wie <code>/vmp mid1 mid2</code> (Sie können die vorherigen Überprüfungen in der Mitte durchführen), erhalten wir im Gegenzug zwei Nachrichten mit einer internen Darstellung der <code>/vmp mid1 mid2</code> für jede der übertragenen Mitten. </p><br><p>  Der Quellcode für diesen Status ist <a href="">hier</a> . </p><br><h1 id="modifikaciya-komandy-bota-dlya-raboty-s-tekstovym-otvetom">  Änderung eines Bot-Befehls zum Arbeiten mit einer Textantwort </h1><br><p>  Sie können auch versuchen, die Nachricht von einem anderen Kanal / Chat weiterzuleiten.  In diesem Fall wird jedoch nur angezeigt, was in der Quellnachricht im Dialog mit dem Bot enthalten ist.  Insbesondere beim Senden einer Nachricht werden die Schaltflächeninformationen nicht gespeichert. </p><br><p>  Aber was ist, wenn wir Informationen über die ursprüngliche Nachricht sehen möchten?  In diesem Fall müssen Sie die Mitte der weitergeleiteten Nachricht übernehmen. </p><br><p>  Um diesen Modus zu implementieren, ändern wir den Befehl <strong>vmp</strong> so, dass beim Aufruf ohne Parameter erwartet wird, dass die Nachricht weitergeleitet wird. <strong>Danach</strong> nimmt er die Mitte der gesendeten Nachricht und zeigt Informationen dazu an. </p><br><p>  <strong>(!)</strong> Für den korrekten Betrieb dieser Funktionalität muss dem Bot die Berechtigung zum Lesen aus der Kanal- / Chat-Quelle erteilt werden. </p><br><p>  Wir ändern den Befehlscode wie folgt: </p><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cmd_handler_vmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, update)</span></span></span><span class="hljs-function">:</span></span> res = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> update.this_cmd_response: <span class="hljs-comment"><span class="hljs-comment">#    ,       if update.cmd_args: #        list_id = [] parts = update.cmd_args.get('c_parts') or [] if parts: for line in parts: for part in line: list_id.append(str(part)) if list_id: res = self.view_messages(update, list_id, update.link) else: #      self.msg.send_message(NewMessageBody(f' **  /    :'), user_id=update.user_id) update.required_cmd_response = True #       else: #    message = update.message link = message.link #       link #  -   . if link and link.type == MessageLinkType.FORWARD: res = self.view_messages(update, [link.message.mid], update.link) else: #         ,    . self.msg.send_message(NewMessageBody(f'.  **   /. , .'), user_id=update.user_id) return False return bool(res)</span></span></code> </pre> <br><p>  Und seitdem  Bei diesem Ansatz steigt das Risiko aufgrund des fehlenden Zugriffs auf Nachrichten. Anschließend fügen wir in der Methode <code>view_messages()</code> eine Überprüfung der Übereinstimmung mit der Anzahl der angeforderten / empfangenen Nachrichten hinzu: </p><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view_messages</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, update, list_mid, link=None)</span></span></span><span class="hljs-function">:</span></span> res = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> msgs = self.msg.get_messages(message_ids=list_mid) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> msgs: <span class="hljs-comment"><span class="hljs-comment">#    mid     if len(msgs.messages) &lt; len(list_mid): self.msg.send_message(NewMessageBody( f'     .    @{self.username}  /  .', link=update.link ), user_id=update.user_id) return False else: for msg in msgs.messages: r = self.msg.send_message(NewMessageBody(f' {msg.body.mid}:\n`{msg}`'[:NewMessageBody.MAX_BODY_LENGTH], link=link), user_id=update.user_id) res = res or r return res</span></span></code> </pre> <br><p>  Wir starten den Bot neu, geben den Befehl / vmp ein und nachdem die Eingabeaufforderung über die Notwendigkeit der Weiterleitung angezeigt wurde, leiten wir die Nachricht vom Kanal / Chat weiter.  Wenn der Bot das Recht hat, Nachrichten in diesem Kanal / Chat zu lesen, wird eine Textdarstellung des weitergeleiteten Nachrichtenobjekts angezeigt.  Wenn kein Zugriff besteht, meldet der Bot ein mögliches Problem und wartet auf die Weiterleitung von der richtigen Quelle. </p><br><h1 id="nastroyka-svoystv-bota">  Bot-Eigenschaften einstellen </h1><br><p>  Jetzt bleibt es Glanz zu bringen.  Schließen wir die <code>about</code> Eigenschaft, die den Text zurückgibt, den der Bot anzeigt, wenn er zu arbeiten beginnt, sowie den Befehl / start. </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta"> @property def about(self): return '       .'</span></span></code> </pre> <br><p>  Wir blockieren die Methode <code>get_commands()</code> , die die Liste der Befehle unseres Bots zurückgibt, die im Dialogfeld mit dem Bot angezeigt wird. </p><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_commands</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># type: () -&gt; [BotCommand] commands = [ BotCommand('start', ' '), BotCommand('menu', ' '), BotCommand('vmp', '  '), ] return commands</span></span></code> </pre> <br><p>  Deaktivieren Sie die Eigenschaft main_menu_buttons, die die Liste der Schaltflächen im Hauptmenü zurückgibt, die mit dem Befehl / menu aufgerufen werden. </p><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main_menu_buttons</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># type: () -&gt; [] buttons = [ #       -  [CallbackButtonCmd(' ', 'start')], #        - .    -  [CallbackButtonCmd('  ', 'vmp', intent=Intent.POSITIVE)], ] return buttons</span></span></code> </pre> <br><p>  Wir starten den Bot neu und stellen sicher, dass alles in Ordnung ist.  Herzlichen Glückwunsch, Ihr erster Bot wurde erstellt und hat trotz einiger Spielzeuge eine gewisse Funktionalität gefordert. </p><br><p>  Der Quellcode für diesen Status ist <a href="">hier</a> . </p><br><p>  Der funktionierende @ devhelpbot-Bot ist hier zu sehen. </p><br><p>  Das ist alles für jetzt.  Wenn das Thema von Interesse ist, kann ich in den folgenden Artikeln die Weiterentwicklung des Bots betrachten.  Fügen Sie beispielsweise benutzerdefinierte Schaltflächen hinzu (insbesondere Ja / Nein) und verarbeiten Sie diese, senden Sie verschiedene Arten von Inhalten (Dateien, Fotos usw.), arbeiten Sie im Webhook-Modus usw. </p><br><p>  Übrigens können Sie in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">speziellen Chat</a> schnell Fragen stellen.  Direkte Vorschläge / Ideen dort. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466373/">https://habr.com/ru/post/de466373/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466361/index.html">Wie Kosaken GICSP-Zertifikat erhalten</a></li>
<li><a href="../de466363/index.html">Slurm DevOps. Erster Tag. Git, CI / CD, IaC und der Grüne Dinosaurier</a></li>
<li><a href="../de466365/index.html">Entwicklung eines monolithischen Unix-ähnlichen Betriebssystems - Erste Schritte (1)</a></li>
<li><a href="../de466367/index.html">Android API-Level, Abwärts- und Vorwärtskompatibilität</a></li>
<li><a href="../de466371/index.html">Die drei wichtigsten Verkaufsbedenken bei der Arbeit mit Trendtechnologien</a></li>
<li><a href="../de466375/index.html">Museum DataArt. KUVT2 - lernen und spielen</a></li>
<li><a href="../de466379/index.html">Führen Sie die Desktop-Software auf dem Mikrocontroller aus</a></li>
<li><a href="../de466381/index.html">Wie sich Era LED-Lampen im Jahr 2019 verändert haben</a></li>
<li><a href="../de466383/index.html">Cryptocurrency Ocean: Überprüfung der 50 besten Projekte mit CoinMarketCap</a></li>
<li><a href="../de466385/index.html">Nachrichtenbroker verstehen. Erlernen der Mechanismen des Messaging über ActiveMQ und Kafka. Kapitel 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>