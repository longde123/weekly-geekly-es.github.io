<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💕 👈🏻 👨‍✈️ BGP如何工作 🦕 ☢️ 🧒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="今天我们来看一下BGP协议。 我们不会在很长一段时间内谈论它为什么以及为什么被用作唯一协议。 例如，有关此主题的信息很多。 

 那么，BGP是什么？ BGP是一种动态路由协议，它是唯一的EGP（外部网关协议）协议。 该协议用于在Internet上建立路由。 考虑如何在两个BGP路由器之间建立邻居。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>BGP如何工作</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450814/"> 今天我们来看一下BGP协议。 我们不会在很长一段时间内谈论它为什么以及为什么被用作唯一协议。 例如，有关此主题的信息很多。 <br><br> 那么，BGP是什么？  BGP是一种动态路由协议，它是唯一的EGP（外部网关协议）协议。 该协议用于在Internet上建立路由。 考虑如何在两个BGP路由器之间建立邻居。 <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/3fa/da6/dd3/3fada6dd3c41923367af475da9b0ae10.jpg" alt="我的形象"></a> <br> 考虑一下Router1和Router3之间的邻居。 我们将使用以下命令配置它们： <a name="habracut"></a><br><pre><code class="plaintext hljs">router bgp 10 network 192.168.12.0 network 192.168.13.0 neighbor 192.168.13.3 remote-as 10 router bgp 10 network 192.168.13.0 network 192.168.24.0 neighbor 192.168.13.1 remote-as 10</code> </pre> <br> 一个自治系统内的邻居是AS10。在路由器上（例如，在Router1上）输入数据后，该路由器尝试与Router3建立邻居关系。 什么也没发生的初始状态称为<b>Idle</b> 。 一旦在Router1上配置了bgp，它将开始侦听TCP端口179-它将进入<b>Connect</b>状态，并且当它尝试打开与Router3的会话时，它将进入<b>Active</b>状态。 <br><br> 在Router1和Router3之间建立会话之后，将进行Open消息交换。 当路由器1发送此消息时，此状态将称为“ <b>打开已发送”</b> 。 并且当它从Router3收到打开消息时，它将进入<b>打开确认</b>状态。 请更详细地考虑公开帖子： <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d9d/231/607/d9d2316070de22049a24da6d86cecb2b.jpg" alt="我的形象"></a> <br> 此消息传达有关路由器使用的BGP协议的信息。 通过交换打开消息，Router1和Router3相互传达有关其设置的信息。 传递了以下参数： <br><blockquote><ul><li>  <b>版本</b> ：这包括路由器使用的BGP版本。  BGP的当前版本是RFC 4271中描述的版本4。两个BGP路由器将尝试协商兼容版本，如果存在不匹配，则将没有BGP会话。 </li><li>  <b>我的AS</b> ：这包括BGP路由器的AS号，这些路由器必须在AS号上达成共识，并且还定义了它们将运行iBGP还是eBGP。 </li><li>  <b>保持时间</b> ：如果BGP在<b>保持时间</b>内没有收到来自另一方的任何keepalive消息或更新消息，则它将声明另一方“死亡”，并将拆除BGP会话。 默认情况下，Cisco IOS路由器上的保持时间设置为180秒，每60秒发送一次keepalive消息。 两个路由器必须就保持时间达成一致，否则就不会有BGP会话。 </li><li>  <b>BGP标识符</b> ：这是本地OSPF路由器ID，就像OSPF一样被选举： <br><ul><li> 使用通过bgp router-id命令手动配置的router-ID。 </li><li> 使用回送接口上的最高IP地址。 </li><li> 使用物理接口上的最高IP地址。 </li></ul></li><li>  <b>可选参数</b> ：在这里您将找到BGP路由器的一些可选功能。 已添加此字段，以便无需创建新版本即可将新功能添加到BGP。您可能会在这里找到以下内容： <br><br><ul><li> 支持MP-BGP（多协议BGP）。 </li><li> 支持路由刷新。 </li><li> 支持4字节的AS编号。 </li></ul></li></ul></blockquote> 要建立邻居，必须满足以下条件： <br><br><ul><li> 版本号。 当前版本4。 </li><li>  AS号必须与您配置的<b>邻居192.168.13.3 remote-as 10</b>匹配。 </li><li> 路由器ID必须不同于邻居。 </li></ul><br> 如果任何参数不满足这些条件，则路由器将在其中指示错误的地方发送<b>通知</b>消息。 发送和接收Open消息后，邻居关系进入<b>ESTABLISHED</b>状态。 之后，路由器可以交换有关路由的信息，并使用“ <b>更新”</b>消息进行此操作。 这是将Router1发送到Router3的更新消息： <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/853/f42/1f0/853f421f0a69f407c5ae4eae3423240c.jpg" alt="我的形象"></a> <br><br> 此处指示由Router1和Path属性报告的网络，类似于度量。 我们将更详细地讨论Path属性。 同样，保持活动消息在TCP会话中传输。 默认情况下，每60秒发送一次。 这是一个Keepalive计时器。 如果在保持计时器中未收到Keepalive消息，则将意味着与邻居的通信中断。 默认情况下，它等于-180秒。 <br><br> 有用的盘子： <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/853/f42/1f0/853f421f0a69f407c5ae4eae3423240c.jpg" alt="我的形象"></a> <br><br> 似乎已经弄清楚了路由器之间如何相互传递信息，现在让我们尝试弄清楚BGP协议的逻辑。 <br><br> 如在IGP协议中一样，要将路由发布到BGP表，使用network命令，但是操作逻辑不同。 如果在IGP中，在network命令中指定了路由之后，IGP将查看属于该子网的接口并将其包含在其表中，然后BGP中的network命令在路由表中查找并在network命令中查找与该路由的<b>精确</b>匹配。 如果找到这些路由，这些路由将落入BGP表中。 <br><blockquote> 在路由器的当前IP路由表中查找与network命令的参数完全匹配的路由； 如果存在IP路由，则将等效的NLRI放入本地BGP表中。 </blockquote> 现在，我们将BGP扩展到其余所有BGP，并了解如何在一个AS中选择​​路由。  BGP路由器收到邻居的路由后，便开始选择最佳路由。 在这里，您需要了解什么样的邻居可以是内部和外部邻居。 配置路由器是否了解配置的邻居是内部的还是外部的？ 如果在团队中： <br><br><pre> <code class="plaintext hljs">neighbor 192.168.13.3 remote-as 10</code> </pre> <br> 作为remote-as参数，指定了AS，它是通过router bgp 10命令在路由器本身上配置的，来自内部AS的路由被视为内部路由，来自外部AS的路由被视为外部路由。 对于每一个，接收和发送工作的逻辑不同。 考虑以下拓扑： <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/cea/5f8/2b0/cea5f82b050662b2632cab01f3de8e24.jpg" alt="我的形象"></a> <br><br> 每个路由器都有一个配置了ip的环回接口：xxxx 255.255.255.0-其中x是路由器的编号。 在Router9上，我们有一个地址为9.9.9.9 255.255.255.0的环回接口。 我们将在BGP上发布它，并查看其分布方式。 该路由将被传输到Router8和Router12。 对于Router8，此路由将转到Router6，但在Router5上，它将不在路由表中。 同样，在Router12上，该路由将进入表，但在Router11上，路由均不会。 让我们尝试找出答案。 考虑一下Router9正在向邻居发送哪些数据和参数，并报告此路由。 下面的数据包将从Router9发送到Router8。 <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/5e7/80b/ca0/5e780bca084e8f42dab14d03f62723b6.jpg" alt="我的形象"></a> <br> 路线信息由路径属性组成。 <br><br> 路径属性分为4类： <br><br><ol><li>  <b>众所周知的强制性</b> -所有BGP路由器都必须识别这些属性。 必须存在于所有更新中。 </li><li>  <b>众所周知的自由裁量权</b> -所有BGP路由器必须识别这些属性。 它们可能存在于更新中，但是它们的存在不是必需的。 </li><li>  <b>可选的传递</b> -可能不是所有BGP实现都认可。 如果路由器无法识别该属性，则会将更新标记为部分更新，然后将其发送给邻居，以保留无法识别的属性。 </li><li>  <b>可选的非传递性</b> -可能不会被所有BGP实现识别。 如果路由器无法识别该属性，则该属性将被忽略，并在传输到邻居期间被丢弃。 </li></ol><br>  BGP属性的示例： <br><br><ul><li>  <b>众所周知的强制性</b> ： <br><ul><li> 自治系统路径 </li><li> 下一跳 </li><li> 原产地 </li></ul><br></li><li>  <b>知名全权委托人</b> ： <br><ul><li> 当地偏好 </li><li> 原子聚集体 </li></ul></li><li>  <b>可选的传递</b> ： <br><ul><li> 聚合器 </li><li> 社区 </li></ul></li><li>  <b>可选的非传递性</b> ： <br><ul><li> 多出口鉴别器（MED） </li><li> 发起者ID </li><li> 集群列表 </li></ul></li></ul><br> 在这种情况下，我们将对Origin，下一跳，AS路径感兴趣。 由于路由在Router8和Router9之间（即，在同一AS内部）经过，因此被视为内部路由，因此我们将关注Origin。 <br><br> 原始属性-指示更新中如何接收路由。 可能的属性值： <br><br><ul><li>  0-IGP：在原始自治系统内获得的NLRI； </li><li>  1-EGP：NLRI通过外部网关协议（EGP）学习。  BGP的前身，未使用 </li><li>  2-不完整：NLRI是通过其他方式学习的 </li></ul><br> 在本例中，从数据包可以看出，它是0。当此路由传输到Router12时，此代码将具有代码-1。 <br><br> 接下来，下一跳。 下一跳属性 <br><br><ul><li> 这是到达目标网络的路径所经过的eBGP路由器的IP地址。 </li><li> 将前缀传递给另一个AS时，属性会更改。 </li></ul><br> 在iBGP的情况下，即在一个AS内，将指示下一跳了解或得知此路由的那一跳。 在我们的例子中，它将是192.168.89.9。 但是，当它将此路由从Router8传输到Router6时，Router8会对其进行更改并用其自己的路由替换。 下一跳将是-192.168.68.8。 这导致我们遵循两个规则： <br><br><ol><li> 如果路由器将路由传递到其内部邻居，则它不会更改Next-hop参数。 </li><li> 如果路由器将路由发送到其外部邻居，则它将下一跳更改为该路由器从其发送接口的ip。 </li></ol><br> 这使我们了解第一个问题-为什么在Router5和Router11的路由表中没有路由。 让我们更详细地考虑。 因此，Router6接收到路由信息9.9.9.0/24并将其安全地添加到路由表中： <br><br><pre> <code class="plaintext hljs">Router6#show ip route bgp Codes: L - local, C - connected, S - static, R - RIP, M - mobile, B - BGP D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2 E1 - OSPF external type 1, E2 - OSPF external type 2 i - IS-IS, su - IS-IS summary, L1 - IS-IS level-1, L2 - IS-IS level-2 ia - IS-IS inter area, * - candidate default, U - per-user static route o - ODR, P - periodic downloaded static route, H - NHRP, l - LISP a - application route + - replicated route, % - next hop override, p - overrides from PfR Gateway of last resort is not set 9.0.0.0/24 is subnetted, 1 subnets B 9.9.9.0 [20/0] via 192.168.68.8, 00:38:25</code> </pre> <br> 现在，Router6通过了Router5路由，并且没有更改第一个下一跳规则。 也就是说，Router5应该<b>通过192.168.68.8</b>添加<b>9.9.9.0 [20/0]</b> ，但是它没有到​​192.168.68.8的路由，因此不会添加此路由，尽管有关此路由的信息将存储在BGP表中： <br><br><pre> <code class="plaintext hljs">&lt;b&gt;Router5#show ip bgp BGP table version is 1, local router ID is 5.5.5.5 Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal, r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter, x best-external, a additional-path, c RIB-compressed, Origin codes: i - IGP, e - EGP, ? - incomplete RPKI validation codes: V valid, I invalid, N Not found Network Next Hop Metric LocPrf Weight Path * i 9.9.9.0/24 192.168.68.8 0 100 0 45 i&lt;/b&gt;</code> </pre> <br> 在Router11-Router12之间也会发生相同的情况。 为了避免这种情况，必须进行配置，以使将路由传递到其内部邻居的路由器6或路由器12将其IP地址替换为下一跳。 使用以下命令完成： <br><br><pre> <code class="plaintext hljs">neighbor 192.168.56.5 next-hop-self</code> </pre> <br> 执行此命令后，Router6将发送一条Update消息，其中对于路由为Next-hop的路由，Router6的Gi0 / 0接口的ip将被指示为192.168.56.6，此路由将已在路由表中。 <br><br> 让我们继续看一下此路由是否出现在Router7和Router10上。 它不会出现在路由表中，我们可能会认为问题与第一个具有Next-hop参数的问题类似，但是如果查看show ip bgp命令的输出，即使错误的Next-hop，我们也将发现那里的路由没有收到，表示该路由甚至没有传输。 这将导致我们存在另一个规则： <br><blockquote> 从内部邻居收到的路由不会传输到其他内部邻居。 </blockquote> 由于Router5收到了来自Router6的路由，因此不会将其传输到其其他内部邻居。 为了进行传输，您必须配置<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Route Reflector</a>功能或配置完全连接的邻域关系（全网格），即Router5-7将彼此成为邻居。 在这种情况下，我们将使用Route Reflector。 在Router5上，必须使用以下命令： <br><br><pre> <code class="plaintext hljs">neighbor 192.168.57.7 route-reflector-client</code> </pre> <br> 路由反射器在将路由传输到内部邻居时更改BGP的行为。 如果内部邻居被指定为<b>route-reflector-client</b> ，则内部路由将被通告给这些客户端。 <br><br> 路由没有出现在Router7上吗？ 也不要忘记下一跳。 经过这些操作后，路由也应该在Router7上，但这不会发生。 这将我们带到另一个规则： <br><blockquote> 下一跳规则仅适用于外部路由。 对于内部路由，不替换next-hop属性。 </blockquote><br> 我们遇到一种情况，您需要使用静态路由或IGP创建环境以将AS内部的所有路由通知路由器。 我们将在Router6和Router7上注册静态路由，然后在路由器表中获得所需的路由。 在AS 678中，我们的行为将有所不同-我们将在Router10上为192.168.112.0/24和Router12上的192.168.110.0/24编写静态路由。 接下来，我们建立Router10与Router12之间的邻居关系。 我们还将Router12配置为发送其下一跳到Router10： <br><br><pre> <code class="plaintext hljs">neighbor 192.168.110.10 next-hop-self</code> </pre> <br> 结果将是Router10将接收路由9.9.9.0/24，它将同时从Router7和Router12接收到。 让我们看看Router10做出的选择： <br><br><pre> <code class="plaintext hljs">Router10#show ip bgp BGP table version is 3, local router ID is 6.6.6.6 Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal, r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter, x best-external, a additional-path, c RIB-compressed, Origin codes: i - IGP, e - EGP, ? - incomplete RPKI validation codes: V valid, I invalid, N Not found Network Next Hop Metric LocPrf Weight Path *&gt;i 9.9.9.0/24 192.168.112.12 0 100 0 45 i 192.168.107.7 0 123 45 i</code> </pre> <br> 如我们所见，两条路由和一个箭头（&gt;）表示已选择通过192.168.112.12的路由。 <br> 让我们看看路线选择过程如何进行： <br><br><ol><li> 首先，在收到路由后，将检查其下一跳的可用性。 这就是为什么当我们在Router5上收到路由而未设置Next-hop-self时，该路由未进一步提交进行处理。 </li><li> 接下来是权重参数。 此参数不是路径属性（PA），并且不会在BGP消息中传输。 它是在每个路由器上本地配置的，仅用于在路由器本身上操纵路由选择。 考虑一个例子。 上面显示了Router10通过Router12（192.168.112.12）为9.9.9.0/24选择了路由。 要更改Wieght参数，可以使用route-map设置特定的路由，或使用以下命令为其邻居分配权重： <br><br><pre> <code class="plaintext hljs"> neighbor 192.168.107.7 weight 200</code> </pre> <br> 现在，从该邻居发出的所有路由都将具有这种权重。 让我们看一下此操作后路由选择如何变化： <br><br><pre> <code class="plaintext hljs">Router10#show bgp *Mar 2 11:58:13.956: %SYS-5-CONFIG_I: Configured from console by console BGP table version is 2, local router ID is 6.6.6.6 Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal, r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter, x best-external, a additional-path, c RIB-compressed, Origin codes: i - IGP, e - EGP, ? - incomplete RPKI validation codes: V valid, I invalid, N Not found Network Next Hop Metric LocPrf Weight Path *&gt; 9.9.9.0/24 192.168.107.7 200 123 45 i * i 192.168.112.12 0 100 0 45 i</code> </pre> <br> 如您所见，现在已选择通过Router7的路由，但这不会对其他路由器产生任何影响。 </li><li> 第三名-本地偏好。 此参数是众所周知的自由裁量属性，这意味着它的存在是可选的。 此参数仅在一个AS中有效，并且仅影响内部邻居的路径选择。 因此，仅在旨在内部邻居的更新消息中发送该消息。 在“为外部邻居更新消息”中，该字段不存在。 因此，他被任命为知名的全权委托人。 让我们尝试将其应用于Router5。 在Router5上，我们应该有两条用于9.9.9.0/24的路由-一个通过Router6，第二个通过Router7。 <br><br> 我们看： <br><br><pre> <code class="plaintext hljs">Router5#show bgp BGP table version is 2, local router ID is 5.5.5.5 Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal, r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter, x best-external, a additional-path, c RIB-compressed, Origin codes: i - IGP, e - EGP, ? - incomplete RPKI validation codes: V valid, I invalid, N Not found Network Next Hop Metric LocPrf Weight Path *&gt;i 9.9.9.0/24 192.168.56.6 0 100 0 45 i</code> </pre> <br> 但正如您所看到的，通过Router6的一条路由。 通过Router7的路由在哪里？ 也许它甚至在Router7上都不存在？ 我们看： <br><br><pre> <code class="plaintext hljs">Router#show bgp BGP table version is 10, local router ID is 7.7.7.7 Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal, r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter, x best-external, a additional-path, c RIB-compressed, Origin codes: i - IGP, e - EGP, ? - incomplete RPKI validation codes: V valid, I invalid, N Not found Network Next Hop Metric LocPrf Weight Path *&gt;i 9.9.9.0/24 192.168.56.6 0 100 0 45 i 192.168.107.10 0 678 45 i</code> </pre> <br> 奇怪，一切似乎都井井有条。 为什么不将其传输到Router5？ 事实是，BGP有一个规则： <br><blockquote> 路由器仅传输自己使用的那些路由。 </blockquote><br>  Router7使用通过Router5的路由，因此不会传送通过Router10的路由。 回到本地偏好。 让我们在Router7上设置Local Preference，看看Router5如何对此做出响应： <br><br><pre> <code class="plaintext hljs">route-map BGP permit 10 match ip address 10 set local-preference 250 access-list 10 permit any router bgp 123 neighbor 192.168.107.10 route-map BGP in&lt;/b&gt;</code> </pre> <br> 因此，我们创建了一个路由图，所有路由均落入该路由图，并告诉Router7在收到后将Local Preference参数更改为250，默认值为100。我们来看看Router5发生了什么： <br><br><pre> <code class="plaintext hljs">Router5#show bgp BGP table version is 8, local router ID is 5.5.5.5 Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal, r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter, x best-external, a additional-path, c RIB-compressed, Origin codes: i - IGP, e - EGP, ? - incomplete RPKI validation codes: V valid, I invalid, N Not found Network Next Hop Metric LocPrf Weight Path *&gt;i 9.9.9.0/24 192.168.57.7 0 250 0 678 45 i</code> </pre> <br> 正如我们现在看到的，Router5首选通过Router7的路由。 同样的情况也会出现在Router6上，尽管他选择通过Router8的路由会更有利可图。 我们还添加了此参数的更改要求重新启动邻居，以使更改生效。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a>阅读。 带有本地首选项。 转到下一个参数。 </li><li> 带有下一跳参数0.0.0.0的路由首选项，即本地或聚合路由。 输入network命令后，将自动为这些路由分配Weight参数，该参数等于最大值-32678： <br><br><pre> <code class="plaintext hljs">Router#show bgp BGP table version is 2, local router ID is 9.9.9.9 Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal, r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter, x best-external, a additional-path, c RIB-compressed, Origin codes: i - IGP, e - EGP, ? - incomplete RPKI validation codes: V valid, I invalid, N Not found Network Next Hop Metric LocPrf Weight Path *&gt; 9.9.9.0/24 0.0.0.0 0 32768 i</code> </pre> </li><li> 通过AS的最短路径。 选择了最短的参数AS_Path。 路由通过的AS越少，越好。 考虑在Router10上到达9.9.9.0/24的路由： <br><br><pre> <code class="plaintext hljs">Router10#show bgp BGP table version is 2, local router ID is 6.6.6.6 Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal, r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter, x best-external, a additional-path, c RIB-compressed, Origin codes: i - IGP, e - EGP, ? - incomplete RPKI validation codes: V valid, I invalid, N Not found Network Next Hop Metric LocPrf Weight Path * 9.9.9.0/24 192.168.107.7 0 123 45 i *&gt;i 192.168.112.12 0 100 0 45 i</code> </pre> <br> 如您所见，Router10选择了通过192.168.112.12的路由，因为AS_Path参数仅包含此路由的45，在其他情况下则包含123和45。 </li><li> 下一个参数是Origin。  IGP（使用BGP获得的路由）是否比EGP（使用先前的BGP获得的路由，现在不使用）好，而EGP优于不完整？  （通过其他方式接收，例如通过重新分配）。 </li><li> 下一个参数是MED。 我们有Wieght，它仅在路由器上本地工作。 有一个本地首选项仅在一个自治系统中起作用。 您可能会猜到，MED是将在自治系统之间传输的参数。 关于此选项的很好的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a> 。 </li></ol><br> 将不使用更多属性，但是如果两条路由具有相同的属性，则将使用以下规则： <br><br><ol><li> 选择通过最近的IGP邻居的路径。 </li><li> 选择最旧的路由作为eBGP路径。 </li><li> 选择通过具有最低BGP路由器ID的邻居的路径。 </li><li> 选择一条具有最低IP地址的邻居路径。 </li></ol><br>  <b>现在考虑BGP收敛的问题。</b> <br><br> 让我们看看如果路由器6通过路由器9丢失路由9.9.9.0/24时会发生什么。 关闭Gi0 / 1 Router6接口，该接口立即了解到与Router8的BGP会话已断开并且邻居已消失，这意味着从该接口收到的路由无效。  Router6立即发送更新消息，该消息在“撤回的路由”字段中指示网络9.9.9.0/24。  Router5收到类似消息后，立即将其发送到Router7。 但是，由于Router7具有通过Router10的路由，因此它将立即发送带有新路由的Update作为响应。 如果接口的状态无法检测到邻居的跌倒，则必须等待Hold Timer触发。 <br><br>  <b>联盟。</b> <br><br> 如果您还记得的话，那么我们谈到了您经常必须使用完全连接的拓扑这一事实。 在一个自治系统中使用大量路由器时，这可能会引起很大的问题，为避免这种情况，有必要使用联盟。 一个AS分为几个子AS，这使其无需完全连接的拓扑即可工作。 <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d55/6a8/741/d556a874120b70319381332cdddf739b.jpg" alt="我的形象"></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里的链接，该</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实验室</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">随后</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对GNS3配置。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如，使用这种拓扑，我们将必须将AS 2345中的所有路由器相互连接，但是使用联合会，我们只能在彼此直接连接的路由器之间建立邻居关系。让我们详细讨论一下。如果只有AS 2345，则</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">laForge会</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Picard </font></font></b><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">那里</font></b><font style="vertical-align: inherit;">进军，</font><b><font style="vertical-align: inherit;">并</font></b><font style="vertical-align: inherit;">告诉他的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Worf路由器</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但他们不会告诉</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crusher</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。另外，路由，路由器本身rasprastranyaet </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拉法格</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，不会被转移</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">破碎机</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">蠕虫</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，也不是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我必须建立一个路由反射器或完全连接的邻域关系。</font><font style="vertical-align: inherit;">通过将每个路由器的一个AS 2345分为4个子AS（2、3、4、5），我们最终得到了不同的操作逻辑。</font><font style="vertical-align: inherit;">一切都</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完美地描述</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资料来源：</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CCIE路由和交换v5.0官方证书指南，第2卷，第五版，Narbik Kocharians，Terry Vinson。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">网站</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xgu.ru</font></font></a> </li><li><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNS3Vault</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">网站</font><font style="vertical-align: inherit;">。</font></font></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN450814/">https://habr.com/ru/post/zh-CN450814/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN450802/index.html">旧版中断</a></li>
<li><a href="../zh-CN450804/index.html">汽车行业的3D金属印刷：从小处着手</a></li>
<li><a href="../zh-CN450806/index.html">当环境变量将过程加快40倍时</a></li>
<li><a href="../zh-CN450810/index.html">面试前快速检查IT专家能力的7种方法</a></li>
<li><a href="../zh-CN450812/index.html">PSR-14-PHP中的主要事件</a></li>
<li><a href="../zh-CN450816/index.html">负责的开发人员的HTTP标头</a></li>
<li><a href="../zh-CN450818/index.html">从高Ceph延迟到使用eBPF / BCC的内核补丁</a></li>
<li><a href="../zh-CN450820/index.html">FrontendConf计划委员会：框架，视野，世界经验和会议使命</a></li>
<li><a href="../zh-CN450822/index.html">消失的框架</a></li>
<li><a href="../zh-CN450824/index.html">CSS的状态</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>