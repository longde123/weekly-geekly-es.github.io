<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚷 👨🏿‍🎤 🤶🏽 Penyaringan linear optimal: mulai dari gradient descent hingga filter adaptif 😍 👳🏿 💢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mengembangkan topik abstrak pada spesialisasi master "Komunikasi dan Pemrosesan Sinyal" (TU Ilmenau), saya ingin melanjutkan salah satu topik utama ku...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Penyaringan linear optimal: mulai dari gradient descent hingga filter adaptif</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455497/"><p>  Mengembangkan topik abstrak pada spesialisasi master "Komunikasi dan Pemrosesan Sinyal" (TU Ilmenau), saya ingin melanjutkan salah satu topik utama kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Pemrosesan Sinyal Adaptif dan Array"</a> .  Yakni, dasar-dasar penyaringan adaptif. </p><br><p>  <u>Untuk siapa artikel ini pertama kali ditulis:</u> <u><br></u> <br>  1) untuk persaudaraan siswa dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spesialisasi asli</a> ; <br>  2) untuk guru yang menyiapkan seminar praktis, tetapi belum memutuskan alat - di bawah ini adalah contoh dalam <strong>python</strong> dan <strong>Matlab / Oktaf</strong> ; <br>  3) untuk siapa pun yang tertarik dengan topik pemfilteran. </p><br><p>  <u>Apa yang dapat ditemukan di bawah potongan:</u> <u><br></u> <br>  1) informasi dari teori, yang saya coba atur setepat mungkin, tetapi, menurut saya, secara informatif; <br>  2) contoh penggunaan filter: khususnya, sebagai bagian dari equalizer untuk antena array; <br>  3) tautan ke literatur dasar dan perpustakaan terbuka (dengan python), yang mungkin berguna untuk penelitian. </p><br><p>  Secara umum, selamat datang dan mari kita memilah semuanya berdasarkan poin. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2f1/98b/d67/2f198bd673789161db58ad770c629faf.jpg"></p><a name="habracut"></a><br><p>  <em>Orang termenung dalam foto itu akrab bagi banyak orang, saya pikir, Norbert Wiener.</em>  <em>Sebagian besar, kita akan mempelajari filter namanya.</em>  <em>Namun, orang tidak dapat gagal untuk menyebut rekan senegaranya - Andrei Nikolaevich Kolmogorov, yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikelnya tahun 1941</a> juga memberikan kontribusi signifikan terhadap pengembangan teori penyaringan yang optimal, yang bahkan dalam sumber bahasa Inggris disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">teori penyaringan Kolmogorov-Wiener</a> .</em> </p><br><h2 id="chto-rassmatrivaem">  Apa yang sedang kita pertimbangkan? </h2><br><p>  Hari ini kita sedang mempertimbangkan filter klasik dengan respon impuls terbatas (FIR, respon impuls terbatas), yang dapat dijelaskan oleh rangkaian sederhana berikut (Gbr. 1). </p><br><p><img src="https://habrastorage.org/webt/to/or/u7/tooru7vj_f6aj0oe9wvpcde28kw.png"></p><br><p>  <em>Fig. 1.</em>  <em>Skema filter FIR untuk mempelajari filter Wiener. [1.</em>  <em>hal.117]</em> </p><br><p>  Kami akan menulis dalam bentuk matriks apa yang sebenarnya akan di output dari stand ini: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43f/615/39b/43f61539ba1f68998b24c39a8c539706.svg" alt="e (n) = d (n) - \ hat {d} (n | \ mathcal {U} _n) = d (n) - \ mathbf {w} ^ H \ mathbf {u} \ qquad (1)"></div><br><p>  Menguraikan notasi: </p><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/6c5/882/04e/6c588204ed25c8bbb270106d7f08a4dd.svg" alt="e (n)">  Apakah perbedaan (kesalahan) antara sinyal yang diberikan dan yang diterima </li><li><img src="https://habrastorage.org/getpro/habr/post_images/771/807/bef/771807bef08a5612654d97e67695cf07.svg" alt="d (n)">  Adalah beberapa sinyal yang telah ditetapkan </li><li><img src="https://habrastorage.org/getpro/habr/post_images/960/b4e/a48/960b4ea48f3968f42c64eed1af640e1d.svg" alt="\ mathbf {u}">  Apakah vektor sampel atau, dengan kata lain, sinyal pada input filter </li><li><img src="https://habrastorage.org/getpro/habr/post_images/75f/f22/a5a/75ff22a5a4f95cbe489056bf704597f0.svg" alt="\ hat {d} (n | \ mathcal {U} _n)">  Apakah sinyal pada output filter </li><li><img src="https://habrastorage.org/getpro/habr/post_images/6f6/81f/9be/6f681f9be2ae30d1666fec498b59b3a3.svg" alt="\ mathbf {w} ^ H">  - ini adalah konjugasi Hermitian dari vektor koefisien filter - <u>itu adalah dalam pemilihan optimal mereka bahwa kemampuan beradaptasi dari filter terletak</u> </li></ul><br><p>  Anda mungkin sudah menebak bahwa kami akan mengusahakan perbedaan terkecil antara sinyal yang diberikan dan yang difilter, yaitu kesalahan terkecil.  Ini berarti bahwa kami menghadapi tugas pengoptimalan. </p><br><h2 id="chto-budem-optimizirovat">  Apa yang akan kami optimalkan? </h2><br><p>  Untuk mengoptimalkan, atau lebih tepatnya meminimalkan, kami tidak hanya akan <strong>mengartikan</strong> galat, <strong>galat kuadrat rata</strong> - <strong>rata</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MSE - Mean Sqared Error</a> ): </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b83/b62/193/b83b62193ca3490681c2cd8910e4d99a.svg" alt="MSE: J (\ mathbf {w}) = E \ {e (n) ^ 2 \} \ qquad (2)"></div><br><p>  dimana <img src="https://habrastorage.org/getpro/habr/post_images/c48/76a/b10/c4876ab1024579fa30ea997a45efd50a.svg" alt="J (\ mathbf {w})">  menunjukkan fungsi biaya vektor koefisien filter, dan <img src="https://habrastorage.org/getpro/habr/post_images/f39/8e4/ded/f398e4ded6db9e55108d575a9b7d2f1f.svg" alt="E \ {* \}">  menunjukkan tikar.  menunggu. </p><br><p>  Kuadrat dalam kasus ini sangat menyenangkan, karena itu berarti bahwa kita dihadapkan dengan masalah <em>pemrograman cembung</em> (saya googled hanya analog dari <em>optimasi cembung</em> Inggris), yang, pada gilirannya, menyiratkan <u>satu ekstrem tunggal</u> (dalam kasus kami, minimum). </p><br><p><img src="https://habrastorage.org/webt/hr/xj/mb/hrxjmbmimv7c2uvvicnuklqn9y0.png"></p><br><p>  <em>Fig. 2.</em>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Permukaan kesalahan kuadrat rata-rata</a> .</em> </p><br><p>  Fungsi kesalahan kami memiliki bentuk kanonik [1, hal. 121]: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5da/121/788/5da121788f801656b55ee459c2f4d56d.svg" alt="J (\ mathbf {w}) = \ sigma ^ 2_d - \ mathbf {w} ^ H \ mathbf {p} - \ mathbf {p} ^ H \ mathbf {w} + \ mathbf {w} ^ H \ mathbf { R} \ mathbf {w} \ qquad (3)"></div><br><p>  dimana <img src="https://habrastorage.org/getpro/habr/post_images/24f/50c/410/24f50c410ab0c2ca3dd302c630c734e8.svg" alt="\ sigma ^ 2_d">  Apakah varians dari sinyal yang diharapkan, <img src="https://habrastorage.org/getpro/habr/post_images/82c/861/559/82c86155992ccb2e83d6f9f3f9e92737.svg" alt="\ mathbf {p} = E \ {\ mathbf {u} (n) d ^ * (n) \}">  Apakah vektor korelasi silang antara vektor input dan sinyal yang diharapkan, dan <img src="https://habrastorage.org/getpro/habr/post_images/664/01c/a88/66401ca883516093b2e73b7d519588ac.svg" alt="\ mathbf {R} = E \ {\ mathbf {u} (n) \ mathbf {u} ^ H (n) \}">  Merupakan matriks autokorelasi dari sinyal input. </p><br><div class="spoiler">  <b class="spoiler_title">Kesimpulan dari rumus ini ada di sini (saya mencobanya lebih jelas).</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/q6/sw/p5/q6swp5meopsxauj7yvygkwuc7-g.png" width="650"></div></div><br><p>  Seperti yang kita catat di atas, jika kita berbicara tentang pemrograman cembung, maka kita akan memiliki satu ekstrem (minimum).  Jadi, untuk menemukan nilai minimum dari fungsi biaya (kesalahan root mean square kuadrat minimum), cukup untuk menemukan garis singgung dari kemiringan garis singgung atau, dengan kata lain, <u>turunan parsial sehubungan</u> dengan variabel yang kami pelajari: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cd/d0b/114/1cdd0b114b5457761dd27338b4ee57f4.svg" alt="\ frac {\ delta J (\ mathbf {w})} {\ delta w ^ *} = - \ mathbf {p} + \ mathbf {R} \ mathbf {w} \ qquad (4)"></div><br><p>  Dalam kasus terbaik ( <img src="https://habrastorage.org/getpro/habr/post_images/ac6/219/d1c/ac6219d1cc1885e6f5936e40b5c7a980.svg" alt="\ mathbf {w} = \ mathbf {w} _ {opt}">  ), kesalahan harus, tentu saja, minimal, yang berarti kita menyamakan turunannya dengan nol: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/777/46e/9a7/77746e9a7ab3ff9df3cf340da4b7238d.svg" alt="\ mathbf {R} \ mathbf {w} _ {opt} = \ mathbf {p} \ qquad (5)"></div><br><p>  Sebenarnya, ini dia, kompor kita, yang darinya kita akan menari lebih jauh: sebelum kita adalah <u>sistem persamaan linear</u> . </p><br><h2 id="kak-budem-reshat">  Bagaimana kita memutuskan? </h2><br><p>  Harus segera dicatat bahwa kedua solusi tersebut, yang akan kami pertimbangkan di bawah, dalam hal ini bersifat teoretis dan mendidik <img src="https://habrastorage.org/getpro/habr/post_images/1cf/d71/499/1cfd714992b16fcc961ad10bcc855134.svg" alt="\ mathbf {R}">  dan <img src="https://habrastorage.org/getpro/habr/post_images/1fa/0e8/e9e/1fa0e8e9e33d7dbd533901bbf025bd9f.svg" alt="\ mathbf {p}">  diketahui sebelumnya (yaitu, kami memiliki kemampuan untuk mengumpulkan statistik yang cukup untuk menghitungnya).  Namun, analisis contoh-contoh sederhana di sini adalah yang terbaik yang dapat Anda pikirkan untuk memahami pendekatan dasar. </p><br><h3 id="analiticheskoe-reshenie">  Solusi analitik </h3><br><p>  Masalah ini dapat dipecahkan, dengan kata lain, di dahi - menggunakan matriks terbalik: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/759/c3e/052/759c3e052c502aa04fe6da682a41ea2a.svg" alt="\ mathbf {w} _ {opt} = \ mathbf {R} ^ {- 1} \ mathbf {p} \ qquad (6)"></div><br><p>  Ungkapan seperti itu disebut persamaan Wiener - Hopf - masih berguna bagi kita sebagai referensi. </p><br><blockquote>  Tentu saja, untuk benar-benar teliti, mungkin akan lebih tepat untuk menuliskan kasus ini secara umum, mis.  tidak dengan <img src="https://habrastorage.org/getpro/habr/post_images/bd8/f0f/04a/bd8f0f04a92fe1055c350d4e32a8a256.svg" alt="^ {-}">  , dan dengan <img src="https://habrastorage.org/getpro/habr/post_images/017/3d5/ed9/0173d5ed99b25d00ec4245287142f165.svg" alt="^ +">  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">balik semu</a> ): <br><img src="https://habrastorage.org/getpro/habr/post_images/003/47f/bca/00347fbca15f40943c7fb7b20c38a3f9.svg" alt="\ mathbf {R} ^ + = \ mathbf {R} ^ H (\ mathbf {R} \ mathbf {R} ^ H) ^ {- 1}"><br><br>  Namun, matriks autokorelasi tidak boleh non-kuadrat atau tunggal, oleh karena itu, cukup tepat, kami percaya bahwa tidak ada kontradiksi. </blockquote><p>  Dari persamaan ini, secara analitik mungkin untuk menyimpulkan berapa nilai minimum dari fungsi biaya akan sama (yaitu, dalam kasus kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MMSE</a> - kesalahan rata-rata kuadrat minimum): </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c00/d2d/1f9/c00d2d1f9427762a17deae92ae3ea77c.svg" alt="J_ {min} = J (\ mathbf {w} _ {opt}) = \ sigma ^ 2_d - \ mathbf {p} ^ H \ mathbf {R} ^ {- 1} \ mathbf {p} \ qquad (7)"></div><br><div class="spoiler">  <b class="spoiler_title">Derivasi formula ada di sini (saya juga mencoba membuatnya lebih berwarna).</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ds/vh/nx/dsvhnxoudmo_qd4hesg_qkysdg8.jpeg"></p></div></div><br><p>  Nah, ada satu solusi. </p><br><h3 id="reshenie-iterativnym-metodom">  Solusi berulang </h3><br><p>  Namun, ya, adalah mungkin untuk menyelesaikan sistem persamaan linear tanpa membalikkan matriks autokorelasi - secara iteratif ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk menghemat perhitungan</a> ).  Untuk tujuan ini, pertimbangkan <strong>metode gradient descent</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">metode gradient descent</a> ) yang asli dan mudah dipahami. </p><br><p>  Inti dari algoritma dapat direduksi menjadi sebagai berikut: </p><br><ol><li>  Kami menetapkan variabel yang diinginkan ke beberapa nilai default (misalnya, <img src="https://habrastorage.org/getpro/habr/post_images/231/554/6f0/2315546f0e8aa127a8da693d41c53ff6.svg" alt="\ mathbf {w} (0) = \ mathbf {0}">  ) </li><li>  Pilih beberapa langkah <img src="https://habrastorage.org/getpro/habr/post_images/849/a42/16c/849a4216c1bc55877bc86f4a97513f7a.svg" alt="\ mu">  (bagaimana tepatnya kita memilih, kita akan bicara di bawah). </li><li>  Dan kemudian, seolah-olah, kita turun sepanjang permukaan asli kita (dalam kasus kami, ini adalah permukaan MSE) dengan langkah yang diberikan <img src="https://habrastorage.org/getpro/habr/post_images/849/a42/16c/849a4216c1bc55877bc86f4a97513f7a.svg" alt="\ mu">  dan kecepatan tertentu yang ditentukan oleh besarnya gradien. </li></ol><br><p>  Oleh karena itu nama: <em>gradien</em> - gradien atau <em>curam</em> - <em>keturunan</em> selangkah demi selangkah - keturunan. </p><br><p>  Gradien dalam kasus kami sudah diketahui: pada kenyataannya, kami menemukannya ketika kami membedakan fungsi biaya (permukaan cekung, bandingkan dengan [1, hal. 220]).  Kami menulis bagaimana rumus untuk pembaruan berulang variabel yang diinginkan (koefisien filter) akan terlihat seperti [1, p.  220]: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d6/4ff/7eb/6d64ff7eb98c4274e05a33a3eb127933.svg" alt="\ mathbf {w} (n + 1) = \ mathbf {w} (n) - \ mu [- \ mathbf {p} + \ mathbf {R} \ mathbf {w} (n)] \ qquad (8)"></div><br><p>  dimana <img src="https://habrastorage.org/getpro/habr/post_images/fd6/0b2/b5b/fd60b2b5be4b7e93a0d905dd970c314f.svg" alt="n">  Apakah nomor iterasi. </p><br><p>  Sekarang mari kita bicara tentang memilih ukuran langkah. </p><br><p>  Kami daftar tempat yang jelas: </p><br><ul><li>  langkah tidak boleh negatif atau nol </li><li>  langkahnya tidak boleh terlalu besar, jika tidak algoritma tidak akan konvergen (itu akan, seolah-olah, melompat dari ujung ke ujung, tanpa jatuh ke ekstrim) </li><li>  langkahnya, tentu saja, bisa sangat kecil, tetapi ini juga tidak sepenuhnya diinginkan - algoritma akan menghabiskan lebih banyak waktu </li></ul><br><p>  Mengenai filter Wiener, pembatasan, tentu saja, telah ditemukan sejak lama [1, p. 222-226]: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/67d/64a/b6c/67d64ab6cf46d3438791ccea853421fb.svg" alt="0 <\ mu <\ frac {2} {\ lambda_ {max}} \ qquad (9)"></div><br><p>  dimana <img src="https://habrastorage.org/getpro/habr/post_images/e5d/fa8/35d/e5dfa835ded907ecd7cf2b56d7061307.svg" alt="\ lambda_ {maks}">  Merupakan nilai eigen terbesar dari matriks autokorelasi <img src="https://habrastorage.org/getpro/habr/post_images/1cf/d71/499/1cfd714992b16fcc961ad10bcc855134.svg" alt="\ mathbf {R}">  . </p><br><blockquote>  Omong-omong, nilai eigen dan vektor adalah topik menarik yang terpisah dalam konteks penyaringan linier.  Bahkan ada seluruh <em>filter Eigen untuk</em> kasus ini (lihat Lampiran 1). </blockquote><p>  Tapi untungnya ini tidak semuanya.  Ada juga solusi adaptif yang optimal: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f4c/3c2/fdf/f4c3c2fdf8ae926094bb67b391cd896b.svg" alt="\ mu (n) = \ frac {\ mathbf {\ gamma} (n) ^ H \ mathbf {\ gamma} (n)} {\ mathbf {\ gamma} (n) ^ H \ mathbf {R} \ mathbf { \ gamma} (n)} \ qquad (10)"></div><br><p>  dimana <img src="https://habrastorage.org/getpro/habr/post_images/1b0/4a6/a31/1b04a6a318f99ec501290f59c0f924ac.svg" alt="\ mathbf {\ gamma} (n) = \ mathbf {p} - \ mathbf {R} \ mathbf {w} (n)">  Merupakan gradien negatif.  Seperti dapat dilihat dari rumus, langkah dihitung ulang ke dalam setiap iterasi, yaitu, ia beradaptasi. </p><br><div class="spoiler">  <b class="spoiler_title">Kesimpulan rumus ada di sini (banyak matematika - hanya melihat kutu buku terkenal yang sama seperti saya).</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/au/hq/0s/auhq0sxrspaduxdkclqctns1xtw.jpeg"></p></div></div><br><p>  Oke, untuk keputusan kedua, kami juga mengatur panggung. </p><br><h2 id="a-nelzya-li-na-primerah">  Tetapi apakah mungkin dengan contoh? </h2><br><p>  Demi kejelasan, kami akan melakukan simulasi kecil.  Kami akan menggunakan <strong>Python 3.6.4</strong> . </p><br><blockquote>  Saya akan segera mengatakan bahwa contoh-contoh ini adalah bagian dari salah satu tugas pekerjaan rumah, yang masing-masing ditawarkan kepada siswa untuk solusi dalam waktu dua minggu.  Saya menulis ulang bagian di bawah python (untuk mempopulerkan bahasa di kalangan insinyur radio).  Mungkin Anda akan menemukan beberapa opsi lain di Web dari mantan siswa lain. </blockquote><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.linalg <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> toeplitz <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convmtx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(h,n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> toeplitz(np.hstack([h, np.zeros(n<span class="hljs-number"><span class="hljs-number">-1</span></span>)]),\ np.hstack([h[<span class="hljs-number"><span class="hljs-number">0</span></span>], np.zeros(n<span class="hljs-number"><span class="hljs-number">-1</span></span>)])) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MSE_calc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sigmaS, R, p, w)</span></span></span><span class="hljs-function">:</span></span> w = w.reshape(w.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>) wH = np.conj(w).reshape(<span class="hljs-number"><span class="hljs-number">1</span></span>, w.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>]) p = p.reshape(p.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>) pH = np.conj(p).reshape(<span class="hljs-number"><span class="hljs-number">1</span></span>, p.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>]) MSE = sigmaS - np.dot(wH, p) - np.dot(pH, w) + np.dot(np.dot(wH, R), w) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MSE[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mu_opt_calc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(gamma, R)</span></span></span><span class="hljs-function">:</span></span> gamma = gamma.reshape(gamma.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>) gammaH = np.conj(gamma).reshape(<span class="hljs-number"><span class="hljs-number">1</span></span>, gamma.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>]) mu_opt = np.dot(gammaH, gamma) / np.dot(np.dot(gammaH, R), gamma) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mu_opt[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br><p>  Kami akan menggunakan filter linier kami untuk masalah <u>pemerataan saluran</u> , yang tujuan utamanya adalah untuk meratakan berbagai efek saluran ini pada sinyal yang bermanfaat. </p><br><blockquote>  Kode sumber dapat diunduh dalam satu file di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> atau di <a href="">sini</a> (ya, saya punya hobi - sunting Wikipedia). </blockquote><br><h3 id="model-sistemy">  Model sistem </h3><br><p>  Misalkan ada antena array (kami sudah memeriksanya di artikel tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MUSIK</a> ). </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/61a/9c2/da7/61a9c2da745081459f9001d0252936f1.png"></p><br><p>  <em>Fig.</em>  <em>3. Array antena linier non-directional (ULAA - array antena linear seragam) [2, hal.</em>  <em>32].</em> </p><br><p>  Tentukan parameter kisi awal: </p><br><pre> <code class="python hljs">M = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-comment"><span class="hljs-comment">#    (number of sensors)</span></span></code> </pre> <br><p>  Dalam tulisan ini, kami akan mempertimbangkan sesuatu seperti <u>saluran broadband dengan fading</u> , fitur karakteristik yang merupakan <u>propagasi multipath</u> .  Untuk kasus-kasus seperti itu, suatu pendekatan biasanya diterapkan di mana setiap balok dimodelkan menggunakan penundaan dari besarnya tertentu (Gbr. 4). </p><br><p><img src="https://habrastorage.org/webt/3t/tc/va/3ttcvau0o4njat-1beejefcudpy.png"></p><br><p>  <em>Fig.</em>  <em>4. Model saluran broadband dengan n penundaan tetap. [3, hal.</em>  <em>29].</em>  <em>Seperti yang Anda pahami, sebutan khusus tidak berperan - lebih lanjut kami akan menggunakan yang sedikit berbeda.</em> </p><br><p>  Model sinyal yang diterima untuk satu sensor dinyatakan sebagai berikut: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3f/c3f/2f0/a3fc3f2f0cd278622946ce2da28005fd.svg" alt="x (n) = \ sum_ {l = 0} ^ Lh (l) s (n-l) + \ nu (n)"></div><br><p>  Dalam hal ini <img src="https://habrastorage.org/getpro/habr/post_images/fd6/0b2/b5b/fd60b2b5be4b7e93a0d905dd970c314f.svg" alt="n">  menunjukkan nomor referensi, <img src="https://habrastorage.org/getpro/habr/post_images/e9f/c39/8e5/e9fc398e58e24442ddc2cf11684debbc.svg" alt="h (l)">  Apakah respons saluran sepanjang balok ke- <em>l</em> , <em>L</em> adalah jumlah register penundaan, <em>s</em> adalah sinyal yang ditransmisikan (berguna), <img src="https://habrastorage.org/getpro/habr/post_images/270/81a/400/27081a40025995898a2b982ff59a7e39.svg" alt="\ nu (n)">  - Kebisingan tambahan. </p><br><p>  Untuk beberapa sensor, rumusnya akan berbentuk: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0e/835/aa7/c0e835aa74d5dccf4ccdf625ebcc88b4.svg" alt="\ mathbf {x} (n) = \ mathbf {H} \ mathbf {s} (n) + \ mathbf {\ nu} (n)"></div><br><p>  dimana <img src="https://habrastorage.org/getpro/habr/post_images/b0e/184/0ed/b0e1840edef9169f3e1f52974bea066d.svg" alt="\ mathbf {x} (n)">  dan <img src="https://habrastorage.org/getpro/habr/post_images/270/81a/400/27081a40025995898a2b982ff59a7e39.svg" alt="\ mathbf {\ nu} (n)">  - Memiliki dimensi <img src="https://habrastorage.org/getpro/habr/post_images/132/724/0f2/1327240f26480a83dffca393bb730c44.svg" alt="M \ kali 1">  dimensi <img src="https://habrastorage.org/getpro/habr/post_images/ed0/8c1/e77/ed08c1e77cfaf357d5e90e9e2ae918aa.svg" alt="\ mathbf {H}">  sama dengan <img src="https://habrastorage.org/getpro/habr/post_images/25e/e63/fbb/25ee63fbb4a32f1a00d5c02aaea9b80c.svg" alt="M \ kali (M-L)">  , dan dimensi <img src="https://habrastorage.org/getpro/habr/post_images/5e3/d36/045/5e3d360455a5a33db6c17f93c119a694.svg" alt="\ mathbf {s} (n)">  sama dengan <img src="https://habrastorage.org/getpro/habr/post_images/6e2/fc1/636/6e2fc16365ac2698555dd979ed6b5eeb.svg" alt="(M-L) \ kali 1">  . </p><br><p>  Misalkan setiap sensor juga menerima sinyal dengan penundaan tertentu, karena timbulnya gelombang pada suatu sudut.  Matriks <img src="https://habrastorage.org/getpro/habr/post_images/ed0/8c1/e77/ed08c1e77cfaf357d5e90e9e2ae918aa.svg" alt="\ mathbf {H}">  dalam kasus kami, ini akan menjadi matriks konvolusional untuk vektor respons untuk setiap sinar.  Saya pikir kodenya akan lebih jelas: </p><br><pre> <code class="python hljs">h = np.array([<span class="hljs-number"><span class="hljs-number">0.722</span></span><span class="hljs-number"><span class="hljs-number">-1j</span></span>*<span class="hljs-number"><span class="hljs-number">0.779</span></span>, <span class="hljs-number"><span class="hljs-number">-0.257</span></span><span class="hljs-number"><span class="hljs-number">-1j</span></span>*<span class="hljs-number"><span class="hljs-number">0.722</span></span>, <span class="hljs-number"><span class="hljs-number">-0.789</span></span><span class="hljs-number"><span class="hljs-number">-1j</span></span>*<span class="hljs-number"><span class="hljs-number">1.862</span></span>]) L = len(h)<span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-comment"><span class="hljs-comment"># number of signal sources H = convmtx(h,ML) print(H.shape) print(H)</span></span></code> </pre> <br><p>  Kesimpulannya adalah: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) &gt;&gt;&gt; array([[ <span class="hljs-number"><span class="hljs-number">0.722</span></span><span class="hljs-number"><span class="hljs-number">-0.779j</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span> +<span class="hljs-number"><span class="hljs-number">0.j</span></span> , <span class="hljs-number"><span class="hljs-number">0.</span></span> +<span class="hljs-number"><span class="hljs-number">0.j</span></span> ], [<span class="hljs-number"><span class="hljs-number">-0.257</span></span><span class="hljs-number"><span class="hljs-number">-0.722j</span></span>, <span class="hljs-number"><span class="hljs-number">0.722</span></span><span class="hljs-number"><span class="hljs-number">-0.779j</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span> +<span class="hljs-number"><span class="hljs-number">0.j</span></span> ], [<span class="hljs-number"><span class="hljs-number">-0.789</span></span><span class="hljs-number"><span class="hljs-number">-1.862j</span></span>, <span class="hljs-number"><span class="hljs-number">-0.257</span></span><span class="hljs-number"><span class="hljs-number">-0.722j</span></span>, <span class="hljs-number"><span class="hljs-number">0.722</span></span><span class="hljs-number"><span class="hljs-number">-0.779j</span></span>], [ <span class="hljs-number"><span class="hljs-number">0.</span></span> +<span class="hljs-number"><span class="hljs-number">0.j</span></span> , <span class="hljs-number"><span class="hljs-number">-0.789</span></span><span class="hljs-number"><span class="hljs-number">-1.862j</span></span>, <span class="hljs-number"><span class="hljs-number">-0.257</span></span><span class="hljs-number"><span class="hljs-number">-0.722j</span></span>], [ <span class="hljs-number"><span class="hljs-number">0.</span></span> +<span class="hljs-number"><span class="hljs-number">0.j</span></span> , <span class="hljs-number"><span class="hljs-number">0.</span></span> +<span class="hljs-number"><span class="hljs-number">0.j</span></span> , <span class="hljs-number"><span class="hljs-number">-0.789</span></span><span class="hljs-number"><span class="hljs-number">-1.862j</span></span>]])</code> </pre> <br><p>  Selanjutnya, kami mengatur data awal untuk sinyal dan noise yang berguna: </p><br><pre> <code class="python hljs">sigmaS = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">#    (the signal's s(n) power) sigmaN = 0.01 #   (the noise's n(n) power)</span></span></code> </pre> <br><p>  Sekarang kita beralih ke korelasi. </p><br><pre> <code class="python hljs">Rxx = (sigmaS)*(np.dot(H,np.matrix(H).H))+(sigmaN)*np.identity(M) p = (sigmaS)*H[:,<span class="hljs-number"><span class="hljs-number">0</span></span>] p = p.reshape((len(p), <span class="hljs-number"><span class="hljs-number">1</span></span>))</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Derivasi formula di sini (juga selembar untuk yang paling putus asa).</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/hi/lh/ks/hilhksxoc_rkum_5ibn3m42ukxc.jpeg"></p></div></div><br><p>  Kami menemukan solusi untuk Wiener: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Solution of the Wiener-Hopf equation: wopt = np.dot(np.linalg.inv(Rxx), p) MSEopt = MSE_calc(sigmaS, Rxx, p, wopt)</span></span></code> </pre> <br><p>  Sekarang mari kita beralih ke metode gradient descent. </p><br><p>  Temukan nilai eigen terbesar sehingga batas atas langkah dapat diturunkan darinya (lihat rumus (9)): </p><br><pre> <code class="python hljs">lamda_max = max(np.linalg.eigvals(Rxx))</code> </pre> <br><p>  Sekarang mari kita atur beberapa langkah yang akan membuat sebagian kecil dari maksimum: </p><br><pre> <code class="python hljs">coeff = np.array([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.9</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0.2</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>]) mus = <span class="hljs-number"><span class="hljs-number">2</span></span>/lamda_max*coeff <span class="hljs-comment"><span class="hljs-comment"># different step sizes</span></span></code> </pre> <br><p>  Tentukan jumlah iterasi maksimum: </p><br><pre> <code class="python hljs">N_steps = <span class="hljs-number"><span class="hljs-number">100</span></span></code> </pre> <br><p>  Jalankan algoritme: </p><br><pre> <code class="python hljs">MSE = np.empty((len(mus), N_steps), dtype=complex) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> mu_idx, mu <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(mus): w = np.zeros((M,<span class="hljs-number"><span class="hljs-number">1</span></span>), dtype=complex) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> N_i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(N_steps): w = w - mu*(np.dot(Rxx, w) - p) MSE[mu_idx, N_i] = MSE_calc(sigmaS, Rxx, p, w)</code> </pre> <br><p>  Sekarang kita akan melakukan hal yang sama, tetapi untuk langkah adaptif (rumus (10)): </p><br><pre> <code class="python hljs">MSEoptmu = np.empty((<span class="hljs-number"><span class="hljs-number">1</span></span>, N_steps), dtype=complex) w = np.zeros((M,<span class="hljs-number"><span class="hljs-number">1</span></span>), dtype=complex) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> N_i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(N_steps): gamma = p - np.dot(Rxx,w) mu_opt = mu_opt_calc(gamma, Rxx) w = w - mu_opt*(np.dot(Rxx,w) - p) MSEoptmu[:, N_i] = MSE_calc(sigmaS, Rxx, p, w)</code> </pre> <br><p>  Anda harus mendapatkan sesuatu seperti ini: </p><br><div class="spoiler">  <b class="spoiler_title">Menggambar</b> <div class="spoiler_text"><pre> <code class="python hljs">x = [i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, N_steps+<span class="hljs-number"><span class="hljs-number">1</span></span>)] plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), dpi=<span class="hljs-number"><span class="hljs-number">300</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idx, item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(coeff): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> item == <span class="hljs-number"><span class="hljs-number">1</span></span>: item = <span class="hljs-string"><span class="hljs-string">''</span></span> plt.loglog(x, np.abs(MSE[idx, :]),\ label=<span class="hljs-string"><span class="hljs-string">'$\mu = '</span></span>+str(item)+<span class="hljs-string"><span class="hljs-string">'\mu_{max}$'</span></span>) plt.loglog(x, np.abs(MSEoptmu[<span class="hljs-number"><span class="hljs-number">0</span></span>, :]),\ label=<span class="hljs-string"><span class="hljs-string">'$\mu = \mu_{opt}$'</span></span>) plt.loglog(x, np.abs(MSEopt*np.ones((len(x), <span class="hljs-number"><span class="hljs-number">1</span></span>), dtype=complex)),\ label = <span class="hljs-string"><span class="hljs-string">'Wiener solution'</span></span>) plt.grid(<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) plt.xlabel(<span class="hljs-string"><span class="hljs-string">'Number of steps'</span></span>) plt.ylabel(<span class="hljs-string"><span class="hljs-string">'Mean-Square Error'</span></span>) plt.title(<span class="hljs-string"><span class="hljs-string">'Steepest descent'</span></span>) plt.legend(loc=<span class="hljs-string"><span class="hljs-string">'best'</span></span>) plt.minorticks_on() plt.grid(which=<span class="hljs-string"><span class="hljs-string">'major'</span></span>) plt.grid(which=<span class="hljs-string"><span class="hljs-string">'minor'</span></span>, linestyle=<span class="hljs-string"><span class="hljs-string">':'</span></span>) plt.show()</code> </pre> </div></div><br><p><img src="https://habrastorage.org/webt/il/fa/8d/ilfa8dmoxgt4sjitiyvwbdjga6m.png"></p><br><p>  <em>Fig.</em>  <em>5. Kurva belajar untuk langkah-langkah ukuran yang berbeda.</em> </p><br><p>  Pengencang demi berbicara poin utama pada gradient descent: </p><br><ul><li>  seperti yang diharapkan, langkah optimal memberikan konvergensi tercepat; </li><li>  tidak lagi berarti lebih baik: setelah melampaui batas atas, kita belum mencapai konvergensi sama sekali. </li></ul><br><p>  Jadi kami menemukan vektor optimal dari filter filter yang akan meningkatkan level efek saluran - kami <u>melatih equalizer</u> . </p><br><h2 id="a-est-chto-to-bolee-blizkoe-k-realnosti">  Apakah ada sesuatu yang lebih dekat dengan kenyataan? </h2><br><p>  Tentu saja!  Kami telah mengatakan beberapa kali bahwa mengumpulkan statistik (mis. Menghitung matriks dan vektor korelasi) dalam sistem waktu nyata jauh dari selalu merupakan kemewahan yang terjangkau.  Namun, umat manusia telah beradaptasi dengan kesulitan-kesulitan ini: alih-alih pendekatan <em>deterministik</em> dalam praktiknya, pendekatan <u>adaptif</u> digunakan.  Mereka dapat dibagi menjadi dua kelompok besar [1, hal.  246]: </p><br><ul><li>  <em>probabilistic (stochastic)</em> (mis. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SG</a> - Stochastic Gradient) </li><li>  dan berdasarkan pada metode <em>kuadrat terkecil</em> (misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LMS</a> - Least Mean Square atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RLS</a> - Recursive Least Squares) </li></ul><br><p>  Topik filter adaptif terwakili dengan baik dalam komunitas open-source (contoh untuk python): </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pyroomacoustics</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">padasip</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">adaptfilt</a> </li></ul><br><blockquote>  Dalam contoh kedua, saya terutama menyukai dokumentasi.  Namun berhati-hatilah!  Ketika saya menguji paket <strong>padasip</strong> , saya menemui kesulitan dalam menangani bilangan kompleks (secara default, float64 tersirat di sana).  Mungkin masalah yang sama mungkin muncul ketika bekerja dengan beberapa implementasi lainnya. </blockquote><p>  Algoritma, tentu saja, memiliki kelebihan dan kekurangannya sendiri, yang jumlahnya menentukan ruang lingkup algoritma. </p><br><p>  Mari kita lihat contoh-contoh berikut: kami akan mempertimbangkan tiga algoritma <em>SG</em> , <em>LMS</em> dan <em>RLS</em> yang telah kami sebutkan (kami akan memodelkan dalam bahasa MATLAB - Saya akui, sudah ada yang kosong, dan menulis ulang semuanya menjadi python keseragaman demi ... well ...). </p><br><p>  Penjelasan tentang algoritma <em>LMS</em> dan <em>RLS</em> dapat ditemukan, misalnya, di dock <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">padasip</a> . </p><br><div class="spoiler">  <b class="spoiler_title">Deskripsi SG dapat ditemukan di sini.</b> <div class="spoiler_text"><p>  Perbedaan utama dari gradient descent adalah gradient variabel: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/76f/9e3/fbb/76f9e3fbbb4c7643f5af595103791091.svg" alt="\ mathbf {w} [n] = \ mathbf {w} [n-1] + \ mu \ kiri (\ mathbf {\ hat {p}} [n] - \ mathbf {\ hat {R}} _ {xx } [n] \ mathbf {w} [n-1] \ kanan)"></div><br><p>  di </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/633/bac/0aa/633bac0aae95be15cd31a312b4e0d2c5.svg" alt="\ mathbf {\ hat {R}} _ {xx} [n] = \ frac {1} {n} \ kiri ((n-1) \ mathbf {\ hat {R}} _ {xx} [n-1 ] + \ mathbf {x} [n] \ mathbf {x} [n] ^ H \ kanan)"></div><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f7/bfd/f81/4f7bfdf81571e19eac474c7a8c380093.svg" alt="\ mathbf {\ hat {p}} [n] = \ frac {1} {n} \ kiri ((n-1) \ mathbf {\ hat {p}} [n-1] + \ mathbf {x} [ n] d [n] ^ * \ benar)"></div></div></div><br><p>  1) Kasus serupa dengan yang dipertimbangkan di atas. </p><br><div class="spoiler">  <b class="spoiler_title">Sumber (MatLab / Oktaf).</b> <div class="spoiler_text"><p>  Sumber dapat diunduh di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p></div></div><br><p><img src="https://habrastorage.org/webt/ff/zm/hq/ffzmhqsrnwvvc0hdrcyzhapropw.png"></p><br><p>  <em>Fig.</em>  <em>6. Kurva belajar untuk LMS, RLS dan SG.</em> </p><br><p>  Dapat segera dicatat bahwa dengan kesederhanaan relatifnya, algoritma LMS mungkin, pada prinsipnya, tidak mencapai solusi optimal dengan langkah yang relatif besar.  RLS memberikan hasil tercepat, tetapi juga bisa gagal dengan <em>faktor pelepasan yang</em> relatif kecil.  Sejauh ini, SG baik-baik saja, tetapi mari kita lihat contoh lain. </p><br><p>  2) Kasus saat saluran berubah waktu. </p><br><div class="spoiler">  <b class="spoiler_title">Sumber (MatLab / Oktaf).</b> <div class="spoiler_text"><p>  Sumber dapat diunduh di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p></div></div><br><p><img src="https://habrastorage.org/webt/v-/9d/sx/v-9dsxxwzr9jnbnswf0dmnvqrcu.png"></p><br><p>  <em>Fig.</em>  <em>7. Kurva belajar untuk LMS, RLS, dan SG (saluran berubah seiring waktu).</em> </p><br><p>  Dan di sini gambarnya sudah jauh lebih menarik: dengan perubahan tajam dalam respons saluran, LMS tampaknya menjadi solusi yang paling dapat diandalkan.  Siapa sangka.  Meskipun RLS dengan faktor lupa yang tepat juga memberikan hasil yang dapat diterima. </p><br><div class="spoiler">  <b class="spoiler_title">Beberapa kata tentang kinerja.</b> <div class="spoiler_text"><p>  Ya, tentu saja, masing-masing algoritma memiliki kompleksitas komputasi yang spesifik, tetapi menurut pengukuran saya, mesin lama saya dapat mengatasi satu ensemble untuk sekitar 120 μs per iterasi dalam kasus LMS dan SG dan sekitar 250 μs per iterasi dalam kasus RLS.  Artinya, perbedaannya, secara umum, sebanding. </p></div></div><br><p>  Dan itu saja untuk hari ini.  Terima kasih untuk semua orang yang melihat! </p><br><h2 id="literatura">  Sastra </h2><br><ol><li>  Teori filter Adaptif Haykin SS.  - Pearson Education India, 2005. </li><li>  Haykin, Simon, dan KJ Ray Liu.  Buku pegangan tentang pemrosesan array dan jaringan sensor.  Vol.  63. John Wiley &amp; Sons, 2010. hlm.  102-107 </li><li>  Arndt, D. (2015).  Pemodelan Saluran untuk Penerimaan Satelit Mobile Land (disertasi Doktor). </li></ol><br><h2 id="prilozhenie-1">  Lampiran 1 </h2><br><div class="spoiler">  <b class="spoiler_title">Filter eigen</b> <div class="spoiler_text"><p>  Tujuan utama filter semacam itu adalah untuk memaksimalkan Signal-to-Noise Ratio (SNR). </p><br><p><img src="https://habrastorage.org/webt/kk/v_/uu/kkv_uu-08dppu5i4yhkucc_b0ww.jpeg"></p><br><p>  Tetapi dilihat dari adanya korelasi dalam perhitungan, ini juga lebih merupakan konstruksi teoretis daripada solusi praktis. </p></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455497/">https://habr.com/ru/post/id455497/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455481/index.html">Tiga cerita tentang perburuan liar</a></li>
<li><a href="../id455483/index.html">Artis Ai-Da: robot humanoid mempersiapkan pameran solo pertamanya</a></li>
<li><a href="../id455485/index.html">Check Point Scripts - jalankan skrip langsung dari Smart Console</a></li>
<li><a href="../id455489/index.html">Menghubungkan solusi audio dan video pihak ketiga ke Tim Microsoft</a></li>
<li><a href="../id455493/index.html">Apa yang Baru di Versi Angular 8</a></li>
<li><a href="../id455499/index.html">Ekstraksi gigi bungsu: bagaimana ini dilakukan?</a></li>
<li><a href="../id455501/index.html">Bagaimana Hollywood Secara Diam-diam Menggunakan AI untuk Membuat Keputusan Pembuatan Film Kunci</a></li>
<li><a href="../id455503/index.html">19 konsep yang perlu Anda pelajari untuk menjadi pengembang Angular yang efektif</a></li>
<li><a href="../id455507/index.html">Ikhtisar Paket Python Datatable</a></li>
<li><a href="../id455509/index.html">Kisah mengapa saya masih menggunakan jQuery</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>