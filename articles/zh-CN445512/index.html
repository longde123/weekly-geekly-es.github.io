<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>❎ 🐥 😩 我们使PHP 7的速度是PHP 5的两倍的方式。第2部分：优化PHP 7.1中的字节码 💰 ✖️ 🛀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在故事的第一部分中 ，基于Zend Technologies 的 Dmitry Stogov在HighLoad ++上的演讲，我们了解了PHP的内部结构。 我们首先详细了解了基本数据结构中的哪些变化使PHP 7加速了两倍以上。 这可能已经停止，但是在7.1版中，开发人员走得更远，因为他们仍然有许多优...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们使PHP 7的速度是PHP 5的两倍的方式。第2部分：优化PHP 7.1中的字节码</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/445512/"> 在故事的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一部分中</a> ，基于Zend Technologies <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a> <strong>Dmitry Stogov</strong>在HighLoad ++上的演讲，我们了解了PHP的内部结构。 我们首先详细了解了基本数据结构中的哪些变化使PHP 7加速了两倍以上。 这可能已经停止，但是在7.1版中，开发人员走得更远，因为他们仍然有许多优化想法。 <br><br> 现在可以解释在这七个方面之前在JIT方面积累的经验，查看不使用JIT的7.0中的结果以及使用JIT的HHVM的结果。 在PHP 7.1中，决定不使用JIT，而是再次转向解释器。 如果较早的优化涉及解释器，那么在本文中，我们将使用为我们的JIT实现的类型推断来研究字节码的优化。 <br><br><img src="https://habrastorage.org/webt/km/1d/cu/km1dcunb58tbgkftxkwegfktjto.png"><br><br> 在削减的范围内，Dmitry Stogov将使用一个简单的示例演示所有工作原理。 <br><a name="habracut"></a><br><h3> 字节码优化 </h3><br> 以下是标准PHP编译器将函数编译到的字节码。 它是单次通过-快速且愚蠢，但能够在每个HTTP请求上再次执行其工作（如果未连接OPcache）。 <br><img src="https://habrastorage.org/webt/ur/rp/xe/urrpxeazkhjaoccg7lgswufya-o.png"><br><br><h3>  OPcache优化 </h3><br> 随着OPcache的出现，我们开始对其进行优化。  <strong>OPcache早已内置了</strong>一些优化方法，例如，狭缝优化方法-当我们通过窥视孔查看代码，寻找熟悉的模式并将其替换为启发式方法时。 这些方法在7.0中继续使用。 例如，我们有两个操作：加法和赋值。 <br><img src="https://habrastorage.org/webt/hn/qm/dg/hnqmdgqu4_etjvz7zxnzbfwgpve.png"><br><br> 它们可以组合为一个复合赋值操作，该操作直接对结果执行加法运算： <code>ASSIGN_ADD $sum, $i</code> 。 另一个示例是一个后递增变量，该变量理论上可以返回某种结果。 <br><img src="https://habrastorage.org/webt/re/gt/m4/regtm4l3qupkaynn4dulv8bliok.png"><br><br> 它可能不是标量值，必须将其删除。 为此，请使用其后的<code>FREE</code>指令。 但是，如果将其更改为预增量，则不需要<code>FREE</code>指令。 <br><img src="https://habrastorage.org/webt/xz/pd/0b/xzpd0bnqezhnqbcx3_zqseojbkq.png"><br><br> 最后，有两个<code>RETURN</code>语句：第一个是RETURN语句在源文本中的直接反映，第二个是由带有右括号的傻瓜编译器添加的。 此代码将永远无法到达，可以删除。 <br> 循环中只剩下四个指令。 似乎没有什么可以优化的了，但对我们而言却不是。 <br> 查看<code>$i++</code>及其相应的指令<code>PRE_INC</code>预递增。 每次执行时： <br><br><ul><li> 需要检查什么类型的变量； </li><li> 是否<code>is_long</code> ; </li><li> 执行增量 </li><li> 检查溢出； </li><li> 转到下一个 </li><li> 也许检查异常。 </li></ul><br> 但是一个人，只要看一下PHP代码，就会看到变量<code>$i</code>处于0到100的范围内，并且不会有溢出，也不需要类型检查，也不会有异常。  <strong>在PHP 7.1中，我们试图教导编译器理解这一点</strong> 。 <br><br><h3> 控制流程图的优化 </h3><img src="https://habrastorage.org/webt/6c/kc/ov/6ckcovmmyomlp00lnvxvcdqkxpk.png"><br><br> 为此，您需要推断类型，并输入类型，您必须首先构建计算机可以理解的数据流的形式表示。 但是，我们将从构建控件流图（控件依赖图）开始。 最初，我们将代码分为基本块-一组具有一个输入和一个输出的指令。 因此，我们在发生过渡的位置（即标签L0，L1）剪切代码。 我们还将其切入有条件和无条件分支运算符之后，然后将其与显示控制依赖关系的弧连接。 <br><img src="https://habrastorage.org/webt/jb/rd/a2/jbrda2sz2t2yukuja4uido5ptk8.png"><br><br> 所以我们得到了CFG。 <br><br><h3> 静态单作业表的优化 </h3><br> 好了，现在我们需要一个数据依赖项。 为此，我们使用“静态单一分配表”-优化编译器世界中的一种流行表示形式。 这意味着每个变量的值只能分配一次。 <br><img src="https://habrastorage.org/webt/io/se/cd/iosecdoawvlte3fa8hn-q5ga3ea.png"><br><br> 对于每个变量，我们添加一个索引或轮回编号。 在每个进行分配的地方，我们都放置一个新索引，并在其中使用它们-直到问号为止，因为它并不总是在任何地方都知道。 例如，在指令<code>IS_SMALLER</code> $ i中，i既可以来自编号为4的块L0，也可以来自编号为2的第一个块。 <br><br> 为了解决这个问题，SSA引入<strong>了Phi伪函数</strong> ，必要时将其插入basic-&gt; block的开头，获取从不同位置来到basic-block的一个变量的各种索引，并创建该变量的新轮回。 正是这些变量后来被用来消除歧义。 <br><img src="https://habrastorage.org/webt/ef/um/d8/efumd8l0ymc_8ffs0wwgraqso_q.png"><br><br> 以这种方式替换所有问号，我们将构建SSA。 <br><br><h3> 类型优化 </h3><br> 现在我们推论类型-好像试图直接在管理上执行此代码。 <br><img src="https://habrastorage.org/webt/jd/tl/zf/jdtlzfxasn7ioyfhmumpxosc6z0.png"><br><br> 在第一个块中，为变量分配了常量值-零，并且我们肯定知道这些变量的类型将是long。 接下来是Phi功能。  Long到达输入，我们不知道来自其他分支的其他变量的值。 <br><img src="https://habrastorage.org/webt/qr/bf/ji/qrbfjicsc1njj9g0uv7llwwlax8.png"><br><br> 我们相信输出phi（）我们会很长。 <br><img src="https://habrastorage.org/webt/ci/au/rx/ciaurxm91_qykojqstnrye1ixyo.png"><br><br> 我们进一步分发。 我们来介绍特定的功能，例如<code>ASSIGN_ADD</code>和<code>PRE_INC</code> 。 加长两个。 如果发生溢出，则结果可能是long或double。 <br><img src="https://habrastorage.org/webt/sh/h1/xk/shh1xkzcm6gnefcsrn1n4jncrwu.png"><br><br> 这些值再次落入Phi函数中，到达不同分支的可能类型集合的并集发生。 等等，我们继续传播，直到达到固定点，一切都安定下来。 <br><img src="https://habrastorage.org/webt/cp/wi/pc/cpwipcwroghcv7tflquaeblynp8.png"><br><br> 我们在程序中的每个点都有一组可能的类型值。 这已经很好了。 计算机已经知道<code>$i</code>只能是long或double，并且可以排除一些不必要的检查。 但是我们知道<code>$i</code>不可能获得双倍的<code>$i</code> 。 我们怎么知道 而且我们看到了一个条件，将<code>$i</code>在周期中的增长限制为可能的溢出。 我们将教计算机看到这一点。 <br><br><h3> 范围传播优化 </h3><br> 在<code>PRE_INC</code>指令中<code>PRE_INC</code>我们从未发现我只能是整数-它的成本是长整数或两倍。 发生这种情况是因为我们没有尝试推断可能的范围。 然后我们可以回答是否会发生溢出的问题。 <br><br> 范围的此输出以类似但略为复杂的方式进行。 结果，我们得到了具有索引2、4、6、7的固定范围的变量<code>$i</code> ，现在我们可以自信地说，增量<code>$i</code>不会导致溢出。 <br><img src="https://habrastorage.org/webt/pd/fu/od/pdfuod-a6kri95noggd--fjtgly.png"><br><br> 通过合并这两个结果，我们可以肯定地说双精度变量<code>$i</code>永远不会成为。 <br><img src="https://habrastorage.org/webt/pj/ls/v7/pjlsv7o9sb_sovt2klcfhv0rthg.png"><br><br> 我们得到的还不是优化，这是优化的信息！ 考虑一下<code>ASSIGN_ADD</code> 。 一般而言，该指令的总和的旧值可能是一个对象。 然后，添加后，旧值应已删除。 但是在我们的情况下，我们肯定知道有一个长或两倍，即一个标量值。 无需销毁，我们可以用<code>ADD</code>替换<code>ASSIGN_ADD</code>是一个更简单的说明。  <code>ADD</code>将<code>sum</code>变量用作参数和值。 <br><img src="https://habrastorage.org/webt/s5/ln/i7/s5lni7nz1-kiwnyo-ch9h1jfpds.png"><br><br> 对于预递增操作，我们可以确定操作数始终很长，并且不会发生溢出。 我们为此指令使用了高度专业的处理程序，该处理程序将仅执行必要的操作而不会进行任何检查。 <br><img src="https://habrastorage.org/webt/90/9v/vm/909vvmh7ygoi4cudrfek9r9igw0.png"><br><br> 现在，在循环末尾比较变量。 我们知道变量的值只会很长-您可以通过将其与100进行比较来立即检查该值。 如果以前我们将验证结果记录在一个临时变量中，然后再次检查该临时变量的是/否，那么现在可以使用一条指令来完成，即简化。 <br><img src="https://habrastorage.org/webt/y0/rl/gu/y0rlgu9ga2q1t9oxt_fdszkizei.png"><br><br> 字节码结果与原始结果相比。 <br><img src="https://habrastorage.org/webt/_c/k7/ed/_ck7edx3i303of0vmfgpx6cefz4.png"><br><br> 周期中仅剩3条指令，其中两条非常专业。 结果，右边的代码<strong>比</strong>原始代码<strong>快3倍</strong> 。 <br><br><h3> 高度专业的处理人员 </h3><br> 任何<strong>PHP爬网处理程序都只是一个C函数</strong> 。 左边是标准处理程序，右上角是高度专业化的处理程序。 左边的检查：操作数的类型，是否发生溢出，是否发生异常。 正确的仅添加一个，仅此而已。 它翻译成4条机器指令。 如果我们走得更远并进行JIT，则只需要一次<code>incl</code>指令。 <br><img src="https://habrastorage.org/webt/jg/zk/me/jgzkmezahf-1rxzvxrgvhdrhmiw.png"><br><br><h2> 接下来是什么？ </h2><br> 我们将继续提高没有JIT的PHP分支7的速度。 在典型的综合测试中， <strong>PHP 7.1会再次提高60％</strong> ，但是在实际应用中，这几乎无法取胜-在WordPress上仅为1-2％。 这不是特别有趣。 自2016年8月以来，冻结7.1分支以进行重大更改后，我们再次开始针对PHP 7.2或更确切地说PHP 8进行JIT研究。 <br><br> 在新的尝试中，我们使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DynAsm</a>生成代码，该代码由Mike Paul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为LuaJIT-2开发</a> 。 这样做很好，因为它<strong>可以非常快速地生成代码</strong> ：分钟数在LLVM上的JIT版本中编译的事实现在发生在0.1-0.2 s内。 今天， <strong>JIT上bench.php的加速</strong>比PHP 5 <strong>快75倍</strong> 。 <br><br> 实际应用没有加速，这是我们面临的下一个挑战。 在某种程度上，我们获得了最佳代码，但是在编译了太多PHP脚本之后，我们阻塞了处理器缓存，因此它无法更快地工作。 而且代码速度并不是实际应用中的瓶颈... <br><br> 也许DynAsm只能用于编译将由程序员或基于计数器的启发式方法选择的某些函数-函数被调用了多少次，其中重复了多少次循环，等等。 <br><br> 以下是我们的JIT为同一示例生成的机器代码。 最佳地编译了许多指令：递增为一条CPU指令，变量初始化为常数为两条。 在不填充类型的地方，您必须多花一点时间。 <br><img src="https://habrastorage.org/webt/fj/zh/n9/fjzhn9m8unce1eui5yhb7otreng.png"><br><br> 回到标题图片，与Mandelbrot测试中的类似语言相比，PHP显示了很好的结果（尽管数据在2016年底是相关的）。 <br><img src="https://habrastorage.org/webt/km/1d/cu/km1dcunb58tbgkftxkwegfktjto.png"><br>  <i>该图以秒为单位显示执行时间，越少越好。</i> <br><br> 也许<strong>曼德布罗不是最好的测试。</strong> 它是计算性的，但是很简单，并且在所有语言中均等地实现。 很高兴知道Wordpress在C ++中的运行速度有多快，但是几乎没有什么奇怪的东西可以重写它以进行检查，甚至重复所有PHP代码的转换。 如果您有一套更合适的基准的想法-建议。 <br><br><blockquote> 我们将于<strong>5月17</strong>日在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PHP俄罗斯</a> <strong>举行会议</strong> ，我们将讨论生态系统的前景和发展，以及将PHP用于真正复杂而酷炫的项目的经验。 已经与我们： <br><br><ul><li>  <strong>Nikita Popov</strong>是PHP内核最杰出的开发人员之一，他<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">将</a>在即将发布的PHP 7.4中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">告诉</a>我们什么。 </li><li>  <strong>Dmitry Stogov</strong>将讨论<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PHP 8中的</a>宏伟<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">计划</a> 。 </li><li>  RoadRunner应用程序服务器的作者<strong>Anton Titov</strong>将提出主题“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用RoadRunner开发混合PHP / Go应用程序</a> ”。 </li></ul><br> 当然，这还不是全部。 征稿<strong>截止日期</strong>仍然截止， <strong>直到4月1日，</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我们正在等待</a>那些能够应用现代方法和最佳实践来实现酷PHP服务的应用程序。 不要害怕与知名演讲者的竞争-我们<strong>正在寻找</strong>在实际项目<strong>中运用</strong>他们所做的<strong>工作的经验</strong> ，并将帮助证明您的案件的益处。 <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN445512/">https://habr.com/ru/post/zh-CN445512/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN445500/index.html">关于开放发行版，开放源代码和Elastic</a></li>
<li><a href="../zh-CN445502/index.html">Vivaldi 2.4-用两只手移动按钮</a></li>
<li><a href="../zh-CN445504/index.html">机器学习工具使IT服务管理（ITSM）更加高效</a></li>
<li><a href="../zh-CN445506/index.html">OS1：Rust for x86上的原始内核</a></li>
<li><a href="../zh-CN445510/index.html">管理期望或拒绝</a></li>
<li><a href="../zh-CN445514/index.html">展览Securika Moscow 2019最有趣</a></li>
<li><a href="../zh-CN445516/index.html">神经量子态-用神经网络表示波函数</a></li>
<li><a href="../zh-CN445518/index.html">老铁：迷失在历史深处的电子工具</a></li>
<li><a href="../zh-CN445520/index.html">Visual Studio Code扩展，可帮助您使用Git</a></li>
<li><a href="../zh-CN445524/index.html">显示分析（商店中商品排列的界面）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>