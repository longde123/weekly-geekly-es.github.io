<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçü§ù‚Äçüë®üèº üòè üõÄüèº noexcept-ctcheck o algunas macros simples para ayudar al compilador a escribir c√≥digo noexcept üè¥ üõÄüèº üßùüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Al desarrollar en C ++, debe escribir c√≥digo de vez en cuando en el que no se produzcan excepciones. Por ejemplo, cuando necesitamos escribir un inter...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>noexcept-ctcheck o algunas macros simples para ayudar al compilador a escribir c√≥digo noexcept</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466849/"><p>  Al desarrollar en C ++, debe escribir c√≥digo de vez en cuando en el que no se produzcan excepciones.  Por ejemplo, cuando necesitamos escribir un intercambio sin excepciones para tipos nativos o definir una declaraci√≥n de movimiento noexcept para nuestra clase, o implementar manualmente un destructor no trivial. </p><br><p>  En C ++ 11, el modificador noexcept se agreg√≥ al lenguaje, lo que permite al desarrollador comprender que no se pueden eliminar las excepciones de la funci√≥n marcada con noexcept.  Por lo tanto, las funciones con dicha marca se pueden usar de forma segura en contextos donde no deber√≠an surgir excepciones. </p><br><p>  Por ejemplo, si tengo estos tipos y funciones: </p><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first_resource</span></span></span><span class="hljs-class"> {</span></span>...}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">second_resource</span></span></span><span class="hljs-class"> {</span></span>...}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">release</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first_resource &amp; r)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(second_resource &amp; r)</span></span></span></span>;</code> </pre> <br><p>  y hay una cierta clase <code>resources_owner</code> que posee objetos como <code>first_resource</code> y <code>second_resource</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resources_owner</span></span></span><span class="hljs-class"> {</span></span> first_resource first_resource_; second_resource second_resource_; ... };</code> </pre> <br><p>  entonces puedo escribir el destructor <code>resources_owner</code> siguiente manera: </p><br><pre> <code class="cpp hljs">resources_owner::~resources_owner() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  release()   ,    . release(first_resource_); //    close()   ,  //   try-catch. try{ close(second_resource_); } catch(...) {} }</span></span></code> </pre> <br><p>  En cierto modo, noexcept en C ++ 11 hizo la vida de un desarrollador de C ++ m√°s f√°cil.  Pero la implementaci√≥n actual sin excepci√≥n en C ++ moderno tiene un lado desagradable ... </p><br><h1 id="kompilyator-ne-pomogaet-kontrolirovat-soderzhimoe-noexcept-funkciy-i-metodov">  El compilador no ayuda a controlar el contenido de las funciones y m√©todos noexcept </h1><a name="habracut"></a><br><p>  Supongamos que en el ejemplo anterior me equivoqu√©: por alguna raz√≥n, consider√© que <code>release()</code> marcado como noexcept, pero en realidad no lo es y puede arrojar excepciones.  Esto significa que cuando escribo un destructor usando una <code>release()</code> : </p><br><pre> <code class="cpp hljs">resources_owner::~resources_owner() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { release(first_resource_); <span class="hljs-comment"><span class="hljs-comment">//  try-catch   ... }</span></span></code> </pre> <br><p>  entonces suplico por problemas.  Tarde o temprano, esta <code>release()</code> arrojar√° una excepci√≥n y toda mi aplicaci√≥n se bloquear√° debido a que se llama autom√°ticamente <code>std::terminate()</code> .  Ser√° a√∫n peor si no se bloquea mi aplicaci√≥n, sino la de otra persona, en la que usaron mi biblioteca con un destructor tan problem√°tico para <code>resources_owner</code> . </p><br><p>  O otra variaci√≥n del mismo problema.  Supongamos que no me equivoqu√© al decir que <code>release()</code> marcado como noexcept.  Fue. </p><br><p>  Fue etiquetado en la versi√≥n 1.0 de una biblioteca de terceros de la que tom√© <code>first_resource</code> y <code>release()</code> .  Y luego, despu√©s de varios a√±os, actualic√© a la versi√≥n 3.0 de esta biblioteca, pero en la versi√≥n 3.0 <code>release()</code> ya no tiene un modificador noexcept. </p><br><p>  Bueno que?  La nueva versi√≥n principal, podr√≠an romper f√°cilmente la API. </p><br><p>  Solo ahora, lo m√°s probable, me olvidar√© de arreglar la implementaci√≥n del destructor <code>resources_owner</code> .  Y si en mi lugar, alguien m√°s est√° involucrado en el soporte de <code>resource_owner</code> , que nunca investig√≥ este destructor, entonces los cambios en la firma <code>release()</code> probablemente pasar√°n desapercibidos. </p><br><p>  Por lo tanto, personalmente no me gusta el hecho de que el compilador no advierte al programador de ninguna manera que el programador dentro del m√©todo / funci√≥n noexcept realiza una llamada a un m√©todo / funci√≥n de lanzamiento de excepciones. </p><br><p>  Ser√≠a mejor si el compilador emitiera tales advertencias. </p><br><h1 id="spasenie-utopayuschih-delo-ruk-samih-utopayuschih">  El rescate del ahogamiento es obra del ahogado. </h1><br><p>  OK, el compilador no da ninguna advertencia.  Y no se puede hacer nada con este simple desarrollador.  No trate con modificaciones del compilador de C ++ para sus propias necesidades.  Especialmente si tiene que usar no un compilador, sino diferentes versiones de diferentes compiladores de C ++. </p><br><p>  ¬øEs posible obtener ayuda del compilador sin entrar en sus menudillos?  Es decir  ¬øEs posible hacer alg√∫n tipo de herramientas para controlar el contenido de m√©todos / funciones no exceptuadas, incluso si se trata del m√©todo dendrofescal? </p><br><p>  Usted puede  Descuidado, pero posible. </p><br><h1 id="otkuda-nogi-rastut">  ¬øDe d√≥nde crecen las piernas? </h1><br><p>  El enfoque descrito en este art√≠culo se prob√≥ en la pr√°ctica al preparar la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pr√≥xima versi√≥n de nuestro peque√±o servidor HTTP integrado RESTinio</a> . </p><br><p>  El hecho es que a medida que RESTinio est√° lleno de funcionalidad, hemos perdido de vista los problemas de seguridad de excepci√≥n en varios lugares.  En particular, con el tiempo se hizo evidente que las excepciones a veces pueden salirse de las devoluciones de llamadas transferidas a Asio (lo que no deber√≠a ser as√≠), as√≠ como las excepciones, en principio, pueden salir volando cuando se limpian los recursos. </p><br><p>  Afortunadamente, en la pr√°ctica, estos problemas nunca se han manifestado, pero la deuda t√©cnica se ha acumulado y hay que hacer algo al respecto.  Y ten√≠as que hacer algo con el c√≥digo que ya estaba escrito.  Es decir  el c√≥digo de trabajo sin excepci√≥n debe convertirse en c√≥digo de trabajo sin excepci√≥n. </p><br><p>  Esto se hizo con la ayuda de varias macros, que se organizaron por c√≥digo en los lugares correctos.  Por ejemplo, un caso trivial: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Message_Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trigger_error_and_close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Message_Builder msg_builder )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// An exception from logger/msg_builder shouldn't prevent // a call to close(). restinio::utils::log_error_noexcept( m_logger, std::move(msg_builder) ); RESTINIO_ENSURE_NOEXCEPT_CALL( close() ); }</span></span></code> </pre> <br><p>  Y aqu√≠ hay un fragmento menos trivial: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ RESTINIO_STATIC_ASSERT_NOEXCEPT(m_context_table.empty()); RESTINIO_STATIC_ASSERT_NOEXCEPT( m_context_table.pop_response_context_nonchecked()); RESTINIO_STATIC_ASSERT_NOEXCEPT(m_context_table.front()); RESTINIO_STATIC_ASSERT_NOEXCEPT(m_context_table.front().dequeue_group()); RESTINIO_STATIC_ASSERT_NOEXCEPT(make_asio_compaible_error( <span class="hljs-keyword"><span class="hljs-keyword">asio_convertible_error_t</span></span>::write_was_not_executed)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; !m_context_table.empty(); m_context_table.pop_response_context_nonchecked() ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ec = make_asio_compaible_error( <span class="hljs-keyword"><span class="hljs-keyword">asio_convertible_error_t</span></span>::write_was_not_executed ); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; current_ctx = m_context_table.front(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( !current_ctx.empty() ) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> wg = current_ctx.dequeue_group(); restinio::utils::suppress_exceptions_quietly( [&amp;] { wg.invoke_after_write_notificator_if_exists( ec ); } ); } } }</code> </pre> <br><p>  El uso de estas macros me dio la mano varias veces, se√±alando lugares que hab√≠a percibido inadvertidamente como no, excepto que no lo eran. </p><br><p>  Por lo tanto, el enfoque que se describe a continuaci√≥n, por supuesto, es un liso hecho a s√≠ mismo con ruedas cuadradas, pero funciona ... Quiero decir, funciona. </p><br><p>  M√°s adelante en el art√≠culo, discutiremos la implementaci√≥n que se aisl√≥ del c√≥digo RESTinio en un conjunto separado de macros. </p><br><h1 id="sut-podhoda">  La esencia del enfoque. </h1><br><p>  La esencia del enfoque es pasar la declaraci√≥n / operador (stmt), que debe verificarse para noexcept, en una macro determinada.  Esta macro usa <code>static_assert(noexcept(stmt), msg)</code> para verificar que stmt es realmente noexcept, y luego sustituye stmt en el c√≥digo. </p><br><p>  B√°sicamente, esto es: </p><br><pre> <code class="cpp hljs">ENSURE_NOEXCEPT_STATEMENT(release(some_resource));</code> </pre> <br><p>  ser√° reemplazado por algo como: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(release(some_resource)), <span class="hljs-string"><span class="hljs-string">"release(some_resource) is expected to be noexcept"</span></span>); release(some_resource);</code> </pre> <br><h2 id="pochemu-byl-sdelan-vybor-v-polzu-makrosov">  ¬øPor qu√© se hizo la elecci√≥n a favor de las macros? </h2><br><p>  En principio, uno podr√≠a prescindir de macros y podr√≠a escribir <code>static_assert(noexcept(...))</code> directamente en el c√≥digo inmediatamente antes de las acciones que se verifican.  Pero las macros tienen al menos un par de virtudes que inclinan la balanza a favor del uso de macros espec√≠ficamente. </p><br><p>  Primero, las macros reducen la duplicaci√≥n de c√≥digo.  Hay una comparaci√≥n: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(release(some_resource)), <span class="hljs-string"><span class="hljs-string">"release(some_resource) is expected to be noexcept"</span></span>); release(some_resource);</code> </pre> <br><p>  y </p><br><pre> <code class="cpp hljs">ENSURE_NOEXCEPT_STATEMENT(release(some_resource));</code> </pre> <br><p>  Est√° claro que con las macros la expresi√≥n principal, es decir  <code>release(some_resource)</code> solo se puede escribir una vez.  Esto reduce la probabilidad de que el c√≥digo se "arrastre" con el tiempo, con su acompa√±amiento, cuando se realiz√≥ una correcci√≥n en un lugar y se olvid√≥ en el segundo. </p><br><p>  En segundo lugar, las macros y, en consecuencia, los controles ocultos detr√°s de ellos pueden deshabilitarse muy f√°cilmente.  Digamos, si la abundancia de static_assert-s comenz√≥ a afectar negativamente la velocidad de compilaci√≥n (aunque no not√© tal efecto).  O, lo que es m√°s importante, al actualizar alguna biblioteca de terceros, los errores de compilaci√≥n de static_assert ocultos detr√°s de las macros pueden rociarse directamente con el r√≠o.  La desactivaci√≥n temporal de las macros puede permitir una actualizaci√≥n sin problemas del c√≥digo, incluidas las macros de verificaci√≥n secuencialmente primero en un archivo, luego en el segundo, luego en el tercero, etc. </p><br><p>  Entonces, las macros, aunque son una caracter√≠stica obsoleta y muy controvertida en C ++, en este caso particular, la vida del desarrollador se simplifica. </p><br><h2 id="osnovnoy-makros-ensure_noexcept_statement">  Macro principal ENSURE_NOEXCEPT_STATEMENT </h2><br><p>  La macro principal ENSURE_NOEXCEPT_STATEMENT se implementa trivialmente: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ENSURE_NOEXCEPT_STATEMENT(stmt) \ do { \ static_assert(noexcept(stmt), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"this statement is expected to be noexcept: "</span></span></span><span class="hljs-meta"> #stmt); \ stmt; \ } while(false)</span></span></code> </pre> <br><p>  Se utiliza para verificar que los m√©todos / funciones a los que se llama no son, a excepci√≥n, y que sus llamadas no necesitan ser enmarcadas por bloques try-catch.  Por ejemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some_complex_container</span></span></span><span class="hljs-class"> {</span></span> one_container first_data_part_; another_container second_data_part_; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">friend</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(some_complex_container &amp; a, some_complex_container &amp; b)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap; <span class="hljs-comment"><span class="hljs-comment">//  swap  noexcept,    . ENSURE_NOEXCEPT_STATEMENT(swap(a.first_data_part_, b.first_data_part_)); ENSURE_NOEXCEPT_STATEMENT(swap(a.second_data_part_, b.second_data_part_)); ... } ... void clean() noexcept { //  clean()  noexcept,    . ENSURE_NOEXCEPT_STATEMENT(first_data_part_.clean()); ENSURE_NOEXCEPT_STATEMENT(second_data_part_.clean()); ... } ... };</span></span></code> </pre> <br><p>  Adem√°s, tambi√©n existe la macro ENSURE_NOT_NOEXCEPT_STATEMENT.  Se utiliza para garantizar que se requiera un bloqueo adicional de try-catch alrededor de la llamada para que las posibles excepciones no salgan volando: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some_resource_owner</span></span></span><span class="hljs-class"> {</span></span> some_resource resource_; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ~some_resource_owner() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  release   noexcept,  try-catch     //      . ENSURE_NOT_NOEXCEPT_STATEMENT(release(resource_)); } catch(...) {} ... } ... };</span></span></code> </pre> <br><h2 id="vspomogatelnye-makrosy-static_assert_noexcept-i-static_assert_not_noexcept">  Macros auxiliares STATIC_ASSERT_NOEXCEPT y STATIC_ASSERT_NOT_NOEXCEPT </h2><br><p>  Desafortunadamente, las macros ENSURE_NOEXCEPT_STATEMENT y ENSURE_NOT_NOEXCEPT_STATEMENT solo se pueden usar para declaraciones / declaraciones, pero no para expresiones que devuelven un valor.  Es decir  no puedes escribir con ENSURE_NOEXCEPT_STATEMENT as√≠: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> resource = ENSURE_NOEXCEPT_STATEMENT(acquire_resource(params));</code> </pre> <br><p>  Por lo tanto, ENSURE_NOEXCEPT_STATEMENT no se puede usar, por ejemplo, en bucles donde a menudo tiene que escribir algo como: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = something.get_first(); i != some_other_object; i = i.get_next()) {...}</code> </pre> <br><p>  y debe asegurarse de que las llamadas <code>get_first()</code> , <code>get_next()</code> , as√≠ como la asignaci√≥n de nuevos valores para i no arrojen una excepci√≥n. </p><br><p>  Para combatir tales situaciones, se escribieron las macros STATIC_ASSERT_NOEXCEPT y STATIC_ASSERT_NOT_NOEXCEPT, detr√°s de las cuales solo se ocultan static_assert s y nada m√°s.  Usando estas macros, puedo lograr el resultado que necesito de alguna manera (no se verific√≥ la compilaci√≥n de este fragmento en particular): </p><br><pre> <code class="cpp hljs">STATIC_ASSERT_NOEXCEPT(something.get_first()); STATIC_ASSERT_NOEXCEPT(something.get_first().get_next()); STATIC_ASSERT_NOEXCEPT(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::declval&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(something.get_first())&gt;() = something.get_first().get_next()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = something.get_first(); i != some_other_object; i = i.get_next()) {...}</code> </pre> <br><p>  Obviamente, esta no es la mejor soluci√≥n, porque  conduce a la duplicaci√≥n de c√≥digo y aumenta el riesgo de su "deslizamiento" con m√°s mantenimiento.  Pero como primer paso, estas macros simples resultaron √∫tiles. </p><br><h1 id="biblioteka-noexcept-ctcheck">  Biblioteca Noexcept-ctcheck </h1><br><p>  Cuando compart√≠ esta experiencia en mi blog y en Facebook, recib√≠ una propuesta para organizar los desarrollos anteriores en una biblioteca separada.  Lo que se hizo: github ahora tiene una peque√±a biblioteca de solo encabezado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">noexcept-compile-time-check (o noexcept-ctcheck, si guarda en letras)</a> .  Entonces, todo lo anterior puede tomar y probar.  Es cierto que los nombres de las macros son un poco m√°s largos de lo que se usa en el art√≠culo.  Es decir  NOEXCEPT_CTCHECK_ENSURE_NOEXCEPT_STATEMENT en lugar de ENSURE_NOEXCEPT_STATEMENT. </p><br><h2 id="chto-v-noexcept-ctcheck-ne-popalo-poka">  Lo que no entr√≥ en noexcept-ctcheck (¬øtodav√≠a?) </h2><br><p>  Existe el deseo de crear la macro ENSURE_NOEXCEPT_EXPRESSION, que podr√≠a usarse as√≠: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> resource = ENSURE_NOEXCEPT_EXPRESSION(acquire_resource(params));</code> </pre> <br><p>  En una primera aproximaci√≥n, podr√≠a verse as√≠: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ENSURE_NOEXCEPT_EXPRESSION(expr) \ ([&amp;]() noexcept -&gt; decltype(auto) { \ static_assert(noexcept(expr), #expr </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" is expected to be noexcept"</span></span></span><span class="hljs-meta">); \ return expr; \ }())</span></span></code> </pre> <br><p>  Pero hay vagas sospechas de que hay algunas trampas en las que no he pensado.  En general, las manos a√∫n no han alcanzado ENSURE_NOEXCEPT_EXPRESSION :( </p><br><h1 id="a-esli-pomechtat">  ¬øY si sue√±as? </h1><br><p>  Mi antiguo sue√±o es obtener un bloque noexcept en C ++ en el que el compilador mismo compruebe si se lanzan excepciones y emite advertencias si se pueden lanzar excepciones.  Me parece que esto facilitar√≠a la escritura de c√≥digo seguro de excepciones.  Y no solo en los casos obvios mencionados anteriormente (intercambio, operadores de movimiento, destructores).  Por ejemplo, un bloque noexcept podr√≠a ayudar en esta situaci√≥n: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">modify_some_complex_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   . one_container_.modify(); // ,   . ,      . //         try. noexcept { current_age_.increment(); } //    ,      . try { another_container_.modify(); ... } catch(...) { noexcept { //  ,     . current_age_.decrement(); one_container_.rollback_modifications(); } throw; } }</span></span></code> </pre> <br><p>  Aqu√≠, para la correcci√≥n del c√≥digo, es muy importante que las acciones realizadas dentro de los bloques noexcept no arrojen excepciones.  Y si el compilador puede rastrear esto, entonces esto ser√° de gran ayuda para el desarrollador. </p><br><p>  Pero quiz√°s un bloque noexcept es solo un caso especial de un problema m√°s general.  A saber: verificar las expectativas del programador de que alg√∫n bloque de c√≥digo tiene ciertas propiedades.  Ya sea la ausencia de excepciones, la ausencia de efectos secundarios, la ausencia de recursividad, carreras de datos, etc. </p><br><p>  Reflexiones sobre este tema hace un par de a√±os llevaron a la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">idea de implica y espera atributos</a> .  Esta idea no fue m√°s all√° de la publicaci√≥n del blog, porque  mientras ella se aleja de mis intereses y oportunidades actuales.  Pero de repente ser√° interesante para alguien y alguien presionar√° para crear algo m√°s viable. </p><br><h1 id="zaklyuchenie">  Conclusi√≥n </h1><br><p>  En este art√≠culo, trat√© de hablar sobre mi experiencia en la simplificaci√≥n de la escritura de c√≥digo seguro de excepci√≥n.  El uso de macros, por supuesto, no hace que el c√≥digo sea m√°s hermoso y compacto.  Pero funciona.  E incluso esas macros primitivas aumentan significativamente el coeficiente de mi sue√±o reparador.  Por lo tanto, si alguien m√°s no ha pensado en c√≥mo controlar el contenido de sus propios m√©todos / funciones sin excepci√≥n, entonces quiz√°s este art√≠culo lo inspire a pensar sobre este tema. </p><br><p>  Y si alguien encuentra una manera de simplificar su vida al escribir c√≥digo sin excepci√≥n, entonces ser√≠a interesante saber qu√© es este m√©todo, en qu√© ayuda y en qu√© no.  Y qu√© tan satisfecho est√° con lo que usa. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/466849/">https://habr.com/ru/post/466849/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../466833/index.html">Cosas importantes que debe saber sobre Tensorflow 2.0</a></li>
<li><a href="../466837/index.html">Fin de semana en bicicleta el√©ctrica con generador de gas.</a></li>
<li><a href="../466839/index.html">La historia de la creaci√≥n de Norton Commander. Parte 1/3</a></li>
<li><a href="../466841/index.html">Por qu√© una almohadilla t√©rmica, si hay una computadora port√°til: el estudio de la resistencia t√©rmica a nivel at√≥mico</a></li>
<li><a href="../466845/index.html">Entrevista inversa: ¬øqu√© preguntas hacerle a la empresa?</a></li>
<li><a href="../466851/index.html">L√≠nea Agilex - 10nm Intel FPGA</a></li>
<li><a href="../466855/index.html">Creaci√≥n de la defensa de la torre en la unidad: escenarios y olas de enemigos</a></li>
<li><a href="../466857/index.html">Ejecuci√≥n de la aplicaci√≥n en segundo plano en iOS 13</a></li>
<li><a href="../466859/index.html">Uso del Servicio de federaci√≥n de AD para autorizar a los usuarios de AWS con distribuci√≥n de derechos</a></li>
<li><a href="../466861/index.html">C√≥mo escapar de la realidad usando un hackathon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>