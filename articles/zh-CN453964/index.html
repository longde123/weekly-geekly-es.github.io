<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙋 😍 🐨 R语言的OOP（第1部分）：S3类 👃 🈯️ 🏐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="R是一种面向对象的语言。 在其中，绝对所有的东西都是对象，从函数开始并以表结尾。 


 反过来，R中的每个对象都属于一个类。 实际上，在我们周围的世界中，情况大致相同。 我们被对象包围，并且每个对象都可以归于一个类。 一个类确定可以用此对象执行的一组属性和操作。 





 例如，在任何厨房中都...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>R语言的OOP（第1部分）：S3类</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453964/"><p>  R是一种面向对象的语言。 在其中，绝对所有的东西都是对象，从函数开始并以表结尾。 </p><br><p> 反过来，R中的每个对象都属于一个类。 实际上，在我们周围的世界中，情况大致相同。 我们被对象包围，并且每个对象都可以归于一个类。 一个类确定可以用此对象执行的一组属性和操作。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6c5/79c/992/6c579c992140a44ceb85c0359165ec15.jpg" alt="图片"></p><a name="habracut"></a><br><p> 例如，在任何厨房中都有桌子和炉子。 厨房的桌子和炉子可以称为厨房设备。 通常，表格的属性受其尺寸，颜色和制成表格的材料的限制。 炉具的性能范围更广，至少必须具有功率，燃烧器数量和炉具类型（电或燃气）。 </p><br><p> 可以对对象执行的操作称为其方法。 分别对于桌子和盘子，这套方法也将有所不同。 您可以在桌子上吃晚餐，可以在上面做饭，但是不可能对通常使用火炉的食物进行热处理。 <br><img src="https://habrastorage.org/getpro/habr/post_images/8f8/8a9/06d/8f88a906d52701c8a5059106b2148fca.jpg" alt="图片"></p><br><h2 id="soderzhanie"> 目录内容 </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">类属性</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">广义函数</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">什么是S3类以及如何创建自己的类</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">自定义S3类的分配功能</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为通用打印功能开发自定义方法</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为此创建通用函数和方法</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">传承</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">什么时候可以使用自己的课程</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">结论</a> </li></ul><br><h2 id="svoystva-klassov"> 类属性 </h2><br><p> 在R中，每个对象也属于一个类。 根据类的不同，它具有一组特定的属性和方法。 就面向对象编程（OOP）而言，将一组属性和对象方法中的相似对象组合为组（类）的可能性称为<strong>封装</strong> 。 </p><br><p> 向量是R中最简单的对象类别；它具有长度的属性。 例如，我们将使用内置的矢量<em>字母</em> 。 </p><br><pre><code class="plaintext hljs">length(letters)</code> </pre> <br><pre> <code class="plaintext hljs">[1] 26</code> </pre> <br><p> 使用<code>length</code>函数，我们得到<em>字母</em>向量的长度。 现在，让我们尝试将相同的功能应用于<em>虹膜</em>内置日期框架。 </p><br><pre> <code class="plaintext hljs">length(iris)</code> </pre> <br><pre> <code class="plaintext hljs">[1] 5</code> </pre> <br><p> 用于表的<code>length</code>函数返回列数。 </p><br><p> 表还具有另一个属性，即维。 </p><br><pre> <code class="plaintext hljs">dim(iris)</code> </pre> <br><pre> <code class="plaintext hljs">[1] 150 5</code> </pre> <br><p> 上面示例中的<code>dim</code>功能显示信息， <em>虹膜</em>表中有150行和5列。 </p><br><p> 反过来，向量没有维。 </p><br><pre> <code class="plaintext hljs">dim(letters)</code> </pre><br><pre> <code class="plaintext hljs">NULL</code> </pre> <br><p> 因此，我们确保不同类的对象具有不同的属性集。 </p><br><h2 id="obobschyonnye-funkcii"> 广义函数 </h2><br><p>  R具有许多通用功能： <code>print</code> ， <code>plot</code> ， <code>summary</code>等。 这些功能对不同类的对象的作用不同。 </p><br><p> 以<code>plot</code>函数为例。 让我们通过传递<em>虹膜</em>表作为其主要参数来运行它。 </p><br><p> <code>plot(iris)</code> </p> <br><p>  <strong>结果：</strong> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0ae/432/7ba/0ae4327babecab1c6f76a19b311450d3.png" alt="绘图功能的结果"></p><br><p> 现在，我们尝试将具有正态分布的100个随机数的向量传递给<code>plot</code>函数。 </p><br><p> <code>plot(rnorm(100, 50, 30))</code> </p> <br><p>  <strong>结果：</strong> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/4f7/c3e/85d/4f7c3e85d80cbcdf4484d201bd17ec99.png" alt="绘图功能的结果"></p><br><p> 我们得到了不同的图，第一种情况是相关矩阵，第二种情况是散点图，在该图上沿x轴显示观察指标，沿y轴显示观察值。 </p><br><p> 因此， <code>plot</code>功能可以适应不同类别的工作。 如果我们回到OOP术语，那么确定传入对象的类并对不同类的对象执行各种操作的能力称为<strong>多态</strong> 。 这是由于以下事实：此函数只是用于为处理不同类而编写的各种方法的包装。 您可以使用以下命令对此进行验证： </p><br><pre> <code class="plaintext hljs">body(plot)</code> </pre> <br><pre> <code class="plaintext hljs">UseMethod("plot")</code> </pre> <br><p>  <code>body</code>命令将功能主体打印到R控制台。 如您所见，body函数的主体仅包含一个<code>UseMethod("plot")</code>命令。 </p><br><p> 即  <code>plot</code>函数只是根据传递给它的对象的类来启动写入它的众多方法之一。 如下查看其所有方法的列表。 </p><br><pre> <code class="plaintext hljs">methods(plot)</code> </pre> <br><pre> <code class="plaintext hljs"> [1] plot.acf* plot.data.frame* plot.decomposed.ts* [4] plot.default plot.dendrogram* plot.density* [7] plot.ecdf plot.factor* plot.formula* [10] plot.function plot.hclust* plot.histogram* [13] plot.HoltWinters* plot.isoreg* plot.lm* [16] plot.medpolish* plot.mlm* plot.ppr* [19] plot.prcomp* plot.princomp* plot.profile.nls* [22] plot.raster* plot.spec* plot.stepfun [25] plot.stl* plot.table* plot.ts [28] plot.tskernel* plot.TukeyHSD*</code> </pre> <br><p> 结果表明plot函数有29种方法，其中有<em>plot.default</em> ，如果该函数在输入中接收到一个未知类的对象，则默认情况下该函数起作用。 </p><br><p> 使用<code>methods</code>函数，您还可以获得一组具有针对任何类编写的方法的所有通用函数。 </p><br><pre> <code class="plaintext hljs">methods(, "data.frame")</code> </pre> <br><pre> <code class="plaintext hljs"> [1] $&lt;- [ [[ [[&lt;- [5] [&lt;- aggregate anyDuplicated as.data.frame [9] as.list as.matrix by cbind [13] coerce dim dimnames dimnames&lt;- [17] droplevels duplicated edit format [21] formula head initialize is.na [25] Math merge na.exclude na.omit [29] Ops plot print prompt [33] rbind row.names row.names&lt;- rowsum [37] show slotsFromS3 split split&lt;- [41] stack str subset summary [45] Summary t tail transform [49] type.convert unique unstack within</code> </pre> <br><h2 id="chto-takoe-s3-klass-i-kak-sozdat-sobstvennyy-klass"> 什么是S3类以及如何创建自己的类 </h2><br><p> 您可以创建R中的许多类。 最受欢迎的之一是S3。 </p><br><p> 此类是一个列表，其中存储了您创建的类的各种属性。 要创建自己的班级，只需创建一个<em>列表</em>并为其指定一个班级名称即可。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">《 R语言编程的艺术</a> 》一书给出了一个<em>雇员</em>类的示例，该类存储有关雇员的信息。 作为本文的示例，我还决定采用一个对象来存储有关员工的信息。 但是使它更加复杂和功能化。 </p><br><pre> <code class="plaintext hljs">#    employee1 &lt;- list(name = "Oleg", surname = "Petrov", salary = 1500, salary_datetime = Sys.Date(), previous_sallary = NULL, update = Sys.time()) #    class(employee1) &lt;- "emp"</code> </pre> <br><p> 因此，我们创建了自己的类，该类在其结构中存储以下数据： </p><br><ul><li> 员工姓名 </li><li> 员工姓 </li><li> 薪水 </li><li> 工资确定的时间 </li><li> 以前的薪水 </li><li> 最后更新信息的日期和时间 </li></ul><br><p> 之后，使用<code>class(employee1) &lt;- "emp"</code>命令<code>class(employee1) &lt;- "emp"</code>将<em>emp</em>类分配给对象。 </p><br><p> 为了方便创建<em>emp</em>类的对象<em>，</em>您可以编写一个函数。 </p><br><div class="spoiler">  <b class="spoiler_title">用于创建emp类对象的功能代码</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#     create_employee &lt;- function(name, surname, salary, salary_datetime = Sys.Date(), update = Sys.time()) { out &lt;- list(name = name, surname = surname, salary = salary, salary_datetime = salary_datetime, previous_sallary = NULL, update = update) class(out) &lt;- "emp" return(out) } #    emp    create_employee employee1 &lt;- create_employee("Oleg", "Petrov", 1500) #     class(employee1)</code> </pre> <br><pre> <code class="plaintext hljs">[1] "emp"</code> </pre> </div></div><br><h2 id="funkcii-prisvaivaniya-znacheniy-polzovatelskim-s3-klassam"> 自定义S3类的分配功能 </h2><br><p> 因此，我们创建了自己的<em>emp</em>类，但是到目前为止，这还没有给我们任何好处。 让我们看看为什么我们创建自己的类以及可以使用它做什么。 </p><br><p> 首先，您可以为创建的类编写赋值函数。 </p><br><div class="spoiler">  <b class="spoiler_title">[的分配功能</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">"[&lt;-.emp" &lt;- function(x, i, value) { if ( i == "salary" || i == 3 ) { cat(x$name, x$surname, "has changed salary from", x$salary, "to", value) x$previous_sallary &lt;- x$salary x$salary &lt;- value x$salary_datetime &lt;- Sys.Date() x$update &lt;- Sys.time() } else { cat( "You can`t change anything except salary" ) } return(x) }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">[[</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">"[[&lt;-.emp" &lt;- function(x, i, value) { if ( i == "salary" || i == 3 ) { cat(x$name, x$surname, "has changed salary from", x$salary, "to", value) x$previous_sallary &lt;- x$salary x$salary &lt;- value x$salary_datetime &lt;- Sys.Date() x$update &lt;- Sys.time() } else { cat( "You can`t change anything except salary" ) } return(x) }</code> </pre> </div></div><br><p> 创建时的赋值函数总是用引号引起来，如下所示： <code>"[&lt;-. " / "[[&lt;-. "</code> 。 他们有3个必需的参数。 </p><br><ul><li>  <strong>x-</strong>将为其分配值的对象； </li><li>  <strong>i-</strong>对象元素的名称/索引（名称，姓氏，薪水，salary_datetime，previous_sallary，更新）； </li><li>  <strong>value-</strong>分配的值。 </li></ul><br><p> 在函数的主体中，您将编写如何更改类的元素。 在我的情况下，我希望用户只能更改薪水<em>（</em>薪水<em>元素，其索引为3）</em> 。 因此，在函数内部，我编写了一个<code>if ( i == "salary" || i == 3 )</code>检查<code>if ( i == "salary" || i == 3 )</code> 。 如果用户尝试编辑其他属性， <code>"You can't change anything except salary"</code>收到消息<code>"You can't change anything except salary"</code> 。 </p><br><p>  <em>更改工资</em>元素<em>后，将</em>显示<em>一条</em>消息，其中包含员工的姓名和姓氏，其当前和新的工资水平。 当前薪水将传递到<em>previous_sallary</em>属性，并且为<em>薪水</em>分配新值。  <em>salary_datetime</em>和<em>update</em>属性的值也会更新。 </p><br><p> 现在，您可以尝试更改工资。 </p><br><pre> <code class="plaintext hljs">employee1["salary"] &lt;- 1750</code> </pre> <br><pre> <code class="plaintext hljs">Oleg Petrov has changed salary from 1500 to 1750</code> </pre> <br><h2 id="razrabotka-sobstvennyh-metodov-dlya-obobschyonnyh-funkciy"> 为通用功能开发自定义方法 </h2><br><p> 之前，您已经了解到R中存在一些通用函数，这些函数根据对象输入处接收的类来更改其行为。 </p><br><p> 您可以将方法添加到现有的通用函数中，甚至可以创建自己的通用函数。 </p><br><p>  <code>print</code>是最常用的通用函数之一。 每次您通过对象名称调用对象时都会触发此函数。 现在，我们创建的<em>emp</em>类对象的打印输出如下所示： </p><br><pre> <code class="plaintext hljs">$name [1] "Oleg" $surname [1] "Petrov" $salary [1] 1750 $salary_datetime [1] "2019-05-29" $previous_sallary [1] 1500 $update [1] "2019-05-29 11:13:25 EEST"</code> </pre><br><p> 让我们为打印功能编写方法。 </p><br><pre> <code class="plaintext hljs">print.emp &lt;- function(x) { cat("Name:", x$name, x$surname, "\n", "Current salary:", x$salary, "\n", "Days from last udpate:", Sys.Date() - x$salary_datetime, "\n", "Previous salary:", x$previous_sallary) }</code> </pre> <br><p> 现在，print函数可以打印<em>emp</em>类的对象。 只需在控制台中输入对象的名称并获得以下输出。 </p><br><pre> <code class="plaintext hljs">employee1</code> </pre> <br><pre> <code class="plaintext hljs">Name: Oleg Petrov Current salary: 1750 Days from last udpate: 0 Previous salary: 1500</code> </pre> <br><h2 id="sozdanie-obobschyonnoy-funkcii-i-metodov"> 创建通用功能和方法 </h2><br><p> 里面的大多数通用函数看起来都一样，只是使用<code>UseMethod</code>函数。 </p><br><pre> <code class="plaintext hljs">#   get_salary &lt;- function(x, ...) { UseMethod("get_salary") }</code> </pre> <br><p> 现在，我们将为其编写两种方法，一种方法用于处理<em>emp</em>类的对象，第二种方法将在默认情况下针对所有其他类的对象启动，而通用函数没有单独编写的方法。 </p><br><pre> <code class="plaintext hljs">#      emp get_salary.emp &lt;- function(x) x$salary #      get_salary.default &lt;- function(x) cat("Work only with emp class objects")</code> </pre> <br><p> 方法的名称由函数的名称和该方法将处理的对象的类组成。 如果您传递未写入该方法的类对象，则<em>默认</em>方法将在每次运行。 </p><br><pre> <code class="plaintext hljs">get_salary(employee1)</code> </pre> <br><pre> <code class="plaintext hljs">[1] 1750</code> </pre> <br><pre> <code class="plaintext hljs">get_salary(iris)</code> </pre> <br><pre> <code class="plaintext hljs">Work only with emp class objects</code> </pre> <br><h2 id="nasledovanie"> 传承 </h2><br><p> 学习面向对象的编程时会遇到另一个术语。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/816/718/892/8167188925cafe5b3224398c7d78b51d.png" alt="图片"></p><br><p> 图片中显示的所有内容都可以归类为<em>运输</em>类别。 实际上，所有这些对象都有一个通用的方法-运动和通用属性，例如速度。 但是，所有6个对象可以分为三个子类：土地，水和空气。 在这种情况下，子类将继承父类的属性，但还将具有其他属性和方法。 面向对象编程框架中的类似属性称为<strong>继承</strong> 。 </p><br><p> 在我们的示例中，我们可以将远程工作程序分配给<em>remote_emp</em>的单独子类。 这些员工将拥有其他财产：居住城市。 </p><br><pre> <code class="plaintext hljs">#    employee2 &lt;- list(name = "Ivan", surname = "Ivanov", salary = 500, salary_datetime = Sys.Date(), previous_sallary = NULL, update = Sys.time(), city = "Moscow") #    remote_emp class(employee2) &lt;- c("remote_emp", "emp") #    class(employee2)</code> </pre> <br><pre> <code class="plaintext hljs">[1] "remote_emp" "emp"</code> </pre> <br><p> 在分配一个类并创建一个子类时，我们使用一个向量，其中的第一个元素是子类的名称，然后是父类的名称。 </p><br><p> 在<strong>继承</strong>的情况下，为与父类一起使用而编写的所有通用函数和方法都将与其子类一起正确使用。 </p><br><pre> <code class="plaintext hljs">#    remote_emp   employee2</code> </pre> <br><pre> <code class="plaintext hljs">Name: Ivan Ivanov Current salary: 500 Days from last udpate: 0 Previous salary:</code> </pre> <br><pre> <code class="plaintext hljs">#   salary   remote_emp get_salary(employee2)</code> </pre> <br><pre> <code class="plaintext hljs">[1] 500</code> </pre> <br><p> 但是您可以为每个子类分别开发方法。 </p><br><pre> <code class="plaintext hljs">#     salary   remote_emp get_salary.remote_emp &lt;- function(x) { cat(x$surname, "remote from", x$city, "\n") return(x$salary) }</code> </pre> <br><pre> <code class="plaintext hljs">#   salary   remote_emp get_salary(employee2)</code> </pre> <br><pre> <code class="plaintext hljs">Ivanov remote from Moscow [1] 500</code> </pre> <br><p> 它的工作原理如下。 首先，泛型函数会寻找为<em>remote_emp</em>子类编写的方法，如果找不到，它将走得更远并寻找为父类<em>emp</em>编写的方法。 </p><br><h2 id="kogda-vam-mogut-prigoditsya-sobstvennye-klassy"> 什么时候可以使用自己的课程 </h2><br><p> 对于刚刚开始精通R语言之旅的人来说，创建自己的S3类的功能不太可能会有用。 </p><br><p> 就个人而言，他们在开发<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">rfacebookstat</a>软件包时派上了用场。 事实是，在Facebook API中，存在<em>action_breakdowns</em>参数以加载事件并响应各个组中的广告发布。 </p><br><p> 使用此类分组时，您会以以下格式的JSON结构形式获得响应： </p><br><pre> <code class="plaintext hljs">{ "action_name": "like", "action_type": "post_reaction", "value": 6 } { "action_type": "comment", "value": 4 }</code> </pre> <br><p> 不同<em>action_breakdowns</em>的元素数量和名称不同，因此对于每个元素，您都需要编写自己的解析器。 为了解决此问题，我使用了用于创建自定义S3类的功能以及带有一组方法的通用功能。 </p><br><p> 当请求具有分组的事件的统计信息时，根据参数的值，定义了一个类，该类分配给从API接收的响应。 响应被传递给泛型函数，并根据先前指定的类，确定了一种分析结果的方法。 谁愿意去研究实现细节，那么<a href="">在这里</a>您可以找到用于创建通用函数和方法的代码， <a href="">这就是</a>它们的用途。 </p><br><p> 就我而言，我使用类和方法在包内专门处理它们。 如果通常需要为包的用户提供一个用于处理所创建的类的接口，则必须将所有方法作为<code>S3method</code>指令包括在<code>S3method</code>文件中，如下所示。 </p><br><pre> <code class="plaintext hljs">S3method(_,) S3method("[&lt;-",emp) S3method("[[&lt;-",emp) S3method("print",emp)</code> </pre> <br><h2 id="zaklyuchenie"> 结论 </h2><br><p> 从文章标题可以明显看出，这只是第一部分，因为 在R中，除了<em>S3</em>类外，还有其他类： <em>S4</em> ， <em>R5</em> （ <em>RC</em> ）， <em>R6</em> 。 将来，我将尝试写每个OOP实现。 尽管如此，任何具有英语水平的人都允许他们自由阅读书籍，然后Headley Wickham十分简洁，并举例说明了他在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ Advanced R”</a>一书中涵盖的主题。 </p><br><p> 如果突然在一篇文章中我错过了有关S3类的一些重要信息，那么如果您在注释中写到这一点，将不胜感激。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN453964/">https://habr.com/ru/post/zh-CN453964/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN453952/index.html">“请求已经成熟”：Alexei Fedorov即将举行有关分布式系统的新会议</a></li>
<li><a href="../zh-CN453956/index.html">博物馆数据艺术。 视频端子ADM-3A。 车重，可靠，可宰</a></li>
<li><a href="../zh-CN453958/index.html">单一存储库：请</a></li>
<li><a href="../zh-CN453960/index.html">莫斯科全球DevOps训练营2019</a></li>
<li><a href="../zh-CN453962/index.html">Kotlin的RxSwift和Coroutines-AGIMA和GeekBrains的可选移动开发</a></li>
<li><a href="../zh-CN453968/index.html">取消学习有毒代码审查惯例</a></li>
<li><a href="../zh-CN453970/index.html">我们在powershell上编写Reverse socks5代理。第2部分</a></li>
<li><a href="../zh-CN453972/index.html">考古学家使用3D打印和扫描技术重新创建了一个拥有2000年历史的大头针</a></li>
<li><a href="../zh-CN453974/index.html">机器学习系统在语言材料上的竞争。 我们如何学习填补空白</a></li>
<li><a href="../zh-CN453976/index.html">针对IT专家的经济教育计划</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>