<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ½â€ğŸŒ¾ ğŸ‘¶ğŸ¿ ğŸ˜¡ Jika proyek Anda adalah "Teater" maka gunakan aktor ğŸ‘´ğŸ¼ ğŸ‘©ğŸ¿â€âœˆï¸ ğŸ§‘ğŸ¿â€ğŸ¤â€ğŸ§‘ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ada sebuah kisah tentang pengalaman menggunakan Model Aktor dalam satu proyek menarik mengembangkan sistem kontrol otomatis untuk teater. Di bawah ini...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jika proyek Anda adalah "Teater" maka gunakan aktor</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452464/"><p>  Ada sebuah kisah tentang pengalaman menggunakan Model Aktor dalam satu proyek menarik mengembangkan sistem kontrol otomatis untuk teater.  Di bawah ini saya akan memberi tahu kesan saya, tidak lebih dari itu. </p><a name="habracut"></a><br><p> Belum lama ini saya berpartisipasi dalam satu tugas menarik: modernisasi sistem kontrol otomatis (ACS) untuk batten hoist, tetapi sebenarnya itu adalah pengembangan ACS baru. </p><br><p>  Teater modern (terutama jika teater itu besar) adalah organisasi yang sangat kompleks.  Ada banyak orang, berbagai mekanisme dan sistem.  Salah satu sistem tersebut adalah ACS untuk penanganan pengangkatan dan pengaturan pemandangan.  Pertunjukan modern, seperti opera dan balet, semakin banyak menggunakan sarana teknis dari tahun ke tahun.  Pemandangan ini secara aktif digunakan oleh sutradara pertunjukan dan bahkan memainkan peran penting sendiri.  Sangat menarik untuk menemukan apa yang terjadi di balik tirai karena penonton biasa hanya dapat melihat aksi di tempat kejadian. </p><br><p>  Tetapi ini adalah artikel teknis, dan saya ingin berbagi pengalaman saya menggunakan Model Aktor untuk menulis sistem kontrol.  Dan bagikan kesan saya menggunakan salah satu kerangka aktor untuk C ++: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SObjectizer</a> . </p><br><p>  Mengapa kami memilih kerangka kerja ini?  Kami sudah lama melihatnya.  Ada banyak artikel dalam bahasa Rusia, dan memiliki dokumentasi yang luar biasa dan banyak contoh.  Proyek ini terlihat seperti proyek yang sudah matang.  Melihat contoh-contoh secara singkat telah menunjukkan bahwa pengembang SObjectizer menggunakan istilah yang sama (status, penghitung waktu, peristiwa, dll.) Dan kami tidak mengharapkan masalah besar untuk mempelajari dan menggunakannya.  Dan faktor penting lainnya: Tim SObjectizer sangat membantu dan selalu siap membantu kami.  Jadi kami memutuskan untuk mencoba. </p><br><h1 id="what-were-doing">  Apa yang kita lakukan </h1><br><p>  Mari kita bicara tentang target proyek kita.  Sistem reng hoen memiliki 62 reng (tabung logam).  Setiap reng sepanjang tahap.  Mereka tergantung pada tali secara paralel dengan celah 30-40cm, mulai dari tepi depan panggung.  Setiap reng bisa dinaikkan atau diturunkan.  Beberapa dari mereka digunakan dalam pertunjukan untuk pemandangan.  Pemandangan ditetapkan pada reng dan digerakkan naik / turun selama pertunjukan.  Perintah dari operator memulai pergerakan.  Sistem "engine-rope-counterbalance" mirip dengan yang digunakan pada elevator di bangunan tempat tinggal.  Mesin ditempatkan di luar panggung, sehingga penonton tidak melihatnya.  Semua mesin dibagi menjadi 8 kelompok, dan masing-masing kelompok memiliki 3 konverter frekuensi (FC).  Paling banyak tiga mesin dapat digunakan pada saat yang sama dalam sebuah grup, masing-masing terhubung ke FC terpisah.  Jadi kami memiliki sistem 62 mesin dan 24 FC, dan kami harus mengendalikan sistem ini. </p><br><p>  Tugas kami adalah mengembangkan antarmuka manusia-mesin (HMI) untuk mengendalikan sistem ini dan mengimplementasikan algoritma kontrol.  Sistem ini mencakup tiga stasiun kontrol.  Dua dari mereka ditempatkan tepat di atas panggung, dan satu di ruang mesin (stasiun ini digunakan oleh tukang listrik yang bertugas).  Ada juga blok kontrol dengan pengontrol di ruang mesin.  Kontroler ini melakukan perintah kontrol, melakukan modulasi lebar-pulsa (PWM), menghidupkan atau mematikan mesin, mengontrol posisi reng.  Dua stasiun kontrol di atas panggung memiliki layar, unit sistem, dan trackball sebagai perangkat penunjuk.  Stasiun kontrol terhubung melalui Ethernet.  Setiap stasiun kontrol terhubung dengan blok kontrol oleh saluran RS485.  Kedua stasiun di atas panggung dapat digunakan untuk mengontrol sistem secara bersamaan, tetapi hanya satu stasiun yang dapat aktif.  Stasiun aktif dipilih oleh operator;  stasiun kedua akan pasif;  stasiun pasif memiliki saluran RS485 dinonaktifkan. </p><br><h1 id="why-actors">  Mengapa Aktor? </h1><br><p>  Dari sudut pandang algoritma, sistem dibangun di atas peristiwa.  Data dari sensor, tindakan operator, kedaluwarsa timer ... Ini semua adalah contoh peristiwa.  Model Aktor bekerja dengan baik untuk algoritme seperti itu: aktor menangani peristiwa yang masuk dan membentuk beberapa tindakan keluar tergantung pada keadaan mereka saat ini.  Mekanika ini tersedia dalam SObjectizer di luar kotak. </p><br><p>  Prinsip-prinsip dasar untuk sistem tersebut adalah: aktor berinteraksi melalui pesan asinkron, aktor memiliki negara dan beralih dari satu negara ke negara lain, hanya pesan yang bermakna untuk keadaan saat ini ditangani. </p><br><p>  Sangat menarik bahwa aktor dipisahkan dari utas pekerja di SObjectizer.  Ini berarti bahwa Anda dapat menerapkan dan men-debug aktor Anda terlebih dahulu dan baru kemudian memutuskan utas pekerja apa yang akan digunakan untuk setiap aktor.  Ada "Dispatcher" yang menerapkan berbagai kebijakan terkait utas.  Misalnya, ada operator yang menyediakan utas pekerja terpisah untuk masing-masing aktor;  ada dispatcher thread-pool yang menyediakan kumpulan thread pekerja yang berukuran tetap;  ada operator yang menjalankan semua aktor pada utas yang sama. </p><br><p>  Kehadiran operator menyediakan cara yang sangat fleksibel untuk mengatur sistem aktor untuk kebutuhan kita.  Kita dapat mengelompokkan beberapa aktor untuk bekerja pada konteks yang sama.  Kami dapat mengubah jenis dispatcher hanya dengan satu baris kode.  Pengembang SObjectizer mengatakan bahwa menulis dispatcher khusus bukanlah tugas yang rumit.  Tetapi tidak perlu menulis dispatcher kita sendiri dalam proyek ini;  semua yang kami butuhkan ditemukan di SObjectizer. </p><br><p>  Namun fitur lain yang menarik adalah kerjasama aktor.  Kerja sama adalah sekelompok aktor yang dapat eksis jika dan hanya jika semua aktor telah mulai berhasil.  Kerjasama tidak dapat dimulai jika setidaknya salah satu aktornya gagal memulai.  Tampaknya ada analogi antara kerja sama SObjectizer dan polong dari Kubernetes, tetapi tampaknya juga kerja sama SObjectizer telah muncul sebelumnya ... </p><br><p>  Ketika seorang aktor dibuat itu ditambahkan ke kerja sama (kerja sama dapat berisi hanya satu aktor) dan terikat dengan beberapa operator.  Sangat mudah untuk membuat kerjasama dan aktor secara dinamis dan pengembang SObjectizer mengatakan bahwa ini adalah operasi yang agak murah. </p><br><p>  Semua aktor berinteraksi satu sama lain melalui "kotak pesan" (mbox).  Ini adalah konsep SObjectizer lain yang menarik dan kuat.  Ini memberikan cara pemrosesan pesan yang fleksibel. </p><br><p>  Pada awalnya, mungkin ada lebih dari satu penerima pesan di belakang mbox.  Ini cukup membantu.  Misalnya, mungkin ada mbox yang digunakan oleh sensor untuk menerbitkan data baru.  Aktor dapat membuat langganan untuk mbox itu, dan aktor yang berlangganan akan menerima data yang mereka inginkan.  Ini memungkinkan bekerja dengan cara "Terbitkan / Berlangganan". </p><br><p>  Kedua, pengembang SObjectizer telah mempertimbangkan kemungkinan pembuatan mbox khusus.  Relatif mudah membuat mbox khusus dengan pemrosesan khusus pesan masuk (seperti pemfilteran atau penyebaran di antara beberapa pelanggan berdasarkan konten pesan). </p><br><p>  Ada juga mbox pribadi untuk setiap aktor dan aktor dapat memberikan referensi ke mbox itu dalam pesan kepada aktor lain (yang memungkinkan untuk membalas langsung ke aktor tertentu). </p><br><p>  Dalam proyek kami, kami membagi semua objek yang dikendalikan menjadi delapan kelompok (satu kelompok untuk setiap kotak kontrol).  Tiga utas pekerja dibuat untuk setiap grup (karena hanya tiga mesin yang dapat bekerja pada saat yang bersamaan).  Itu memungkinkan kami untuk memiliki independensi di antara kelompok-kelompok mesin.  Itu juga diizinkan untuk bekerja secara tidak sinkron dengan mesin di dalam masing-masing kelompok. </p><br><p>  Perlu disebutkan bahwa SObjectizer-5 tidak memiliki mekanisme untuk interprocess atau / dan interaksi jaringan.  Ini adalah keputusan sadar pengembang SObjectizer;  mereka ingin membuat SObjectizer seringan mungkin.  Selain itu, dukungan transparan untuk jaringan telah ada di beberapa versi sebelumnya dari SObjectizer tetapi telah dihapus.  Itu tidak mengganggu kami karena mekanisme untuk jaringan sangat tergantung pada tugas, protokol yang digunakan dan kondisi lainnya.  Tidak ada solusi universal tunggal untuk semua kasus. </p><br><p>  Dalam kasus kami, kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">libuniset2</a> perpustakaan lama kami untuk komunikasi jaringan dan antar proses.  Akibatnya, libuniset2 mendukung komunikasi dengan sensor dan blok kontrol, dan SObjectizer mendukung aktor dan interaksi antara aktor di dalam satu proses tunggal. </p><br><p>  Seperti yang saya katakan sebelumnya ada 62 mesin.  Setiap mesin dapat dihubungkan ke FC (konverter frekuensi);  koordinat tujuan dapat ditentukan untuk reng yang sesuai;  kecepatan gerakan reng juga bisa ditentukan.  Dan sebagai tambahan untuk itu, setiap mesin memiliki status berikut: </p><br><ul><li>  siap bekerja; </li><li>  terhubung; </li><li>  bekerja; </li><li>  kerusakan; </li><li>  menghubungkan (keadaan transisi); </li><li>  disconnecting (keadaan transisi); </li></ul><br><p> Setiap mesin diwakili dalam sistem oleh aktor yang mengimplementasikan transisi antar negara, menangani data dari sensor dan mengeluarkan perintah.  Tidak sulit untuk membuat aktor di SObjectizer: cukup mewarisi kelas Anda dari <code>so_5::agent_t</code> .  Argumen pertama dari konstruktor aktor harus bertipe <code>context_t</code> , semua argumen lain dapat didefinisikan sesuai keinginan pengembang. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drive_A</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Drive_A( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx, ... ); ... }</code> </pre> <br><p>  Saya tidak akan menunjukkan penjelasan rinci tentang kelas dan metode karena ini bukan tutorial.  Saya hanya ingin menunjukkan betapa mudahnya semuanya dapat dilakukan di SObjectizer (dalam beberapa baris secara harfiah).  Biarkan saya mengingatkan Anda bahwa SObjectizer memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi yang</a> sangat baik dan banyak contoh. </p><br><h1 id="what-is-the-state-of-an-actor-what-are-we-talking-about">  Apa "keadaan" aktor?  Apa yang kita bicarakan </h1><br><p>  Penggunaan status dan transisi di antara keduanya adalah "topik asli" untuk sistem kontrol.  Konsep ini sangat baik untuk penanganan acara.  Konsep ini didukung dalam SObjectizer di tingkat API.  Negara dideklarasikan di dalam kelas aktor: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drive_A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Drive_A( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx, ... ); <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Drive_A(); <span class="hljs-comment"><span class="hljs-comment">//  state_t st_base {this}; state_t st_disabled{ initial_substate_of{st_base}, "disabled" }; state_t st_preinit{ substate_of{st_base}, "preinit" }; state_t st_off{ substate_of{st_base}, "off" }; state_t st_connecting{ substate_of{st_base}, "connecting" }; state_t st_disconnecting{ substate_of{st_base}, "disconnecting" }; state_t st_connected{ substate_of{st_base}, "connected" }; ... }</span></span></code> </pre> <br><p>  dan kemudian event-handler didefinisikan untuk setiap negara.  Terkadang perlu untuk melakukan sesuatu saat memasuki atau keluar dari negara.  Ini juga didukung di SObjectizer melalui penangan on_enter / on_exit.  Tampaknya pengembang SObjectizer memiliki latar belakang dalam pengembangan sistem kontrol. </p><br><h1 id="event-handlers">  Penangan acara </h1><br><p>  Event handler adalah tempat di mana logika aplikasi Anda diimplementasikan.  Seperti yang saya katakan sebelumnya, langganan dibuat untuk mbox tertentu dan negara tertentu.  Jika seorang aktor tidak memiliki status yang ditentukan secara eksplisit, ia berada dalam "default_state" khusus. </p><br><p>  Penangan yang berbeda dapat didefinisikan untuk acara yang sama di negara yang berbeda.  Jika Anda tidak mendefinisikan handler untuk beberapa acara, maka acara ini akan diabaikan (aktor tidak akan mengetahuinya). </p><br><p>  Ada sintaksis sederhana untuk mendefinisikan event handler.  Anda menentukan metode, dan tidak perlu menentukan tipe atau parameter templat tambahan.  Sebagai contoh: </p><br><pre> <code class="cpp hljs">so_subscribe(drv-&gt;so_mbox()) .in(st_base) .event( &amp;Drive_A::on_get_info ) .event( &amp;Drive_A::on_control ) .event( &amp;Drive_A::off_control );</code> </pre> <br><p>  Ini adalah contoh berlangganan acara dari mbox tertentu di st_base state.  Perlu disebutkan bahwa st_base adalah keadaan dasar untuk beberapa negara bagian lain dan langganan itu akan diwarisi oleh negara bagian yang diturunkan.  Pendekatan ini memungkinkan untuk menyingkirkan copy-dan-paste untuk penangan acara yang serupa di negara bagian yang berbeda.  Tetapi event handler yang diwarisi dapat didefinisikan ulang untuk keadaan tertentu atau acara dapat sepenuhnya dinonaktifkan ("ditekan"). </p><br><p>  Cara lain untuk mendefinisikan event handler adalah menggunakan fungsi lambda.  Ini adalah cara yang sangat mudah karena penangan acara sering hanya berisi satu atau dua baris kode: pengiriman sesuatu ke suatu tempat atau perubahan status: </p><br><pre> <code class="cpp hljs">so_subscribe(drv-&gt;so_mbox()) .in(st_disconnecting) .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">msg_disconnected_t</span></span>&amp; m) { ... st_off.activate(); }) .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">msg_failure_t</span></span>&amp; m ) { ... st_protection.activate(); });</code> </pre> <br><p>  Sintaks itu terlihat rumit pada awalnya, tetapi menjadi akrab setelah beberapa hari pengkodean aktif dan Anda bahkan mulai menyukainya.  Itu karena seluruh logika beberapa aktor bisa ringkas dan ditempatkan dalam satu layar.  Dalam contoh yang ditunjukkan di atas, ada transisi dari st_disconnected ke st_off atau st_protection.  Kode ini mudah dibaca. </p><br><p>  BTW, untuk kasus langsung, di mana hanya transisi negara diperlukan, ada sintaks khusus: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> mbox = drv-&gt;so_mbox(); st_off .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_connected_t</span></span>&gt;(mbox, st_connected) .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_failure_t</span></span>&gt;(mbox, st_protection) .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_on_limit_t</span></span>&gt;(mbox, st_protection) .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_on_t</span></span>&gt;(mbox, st_on);</code> </pre> <br><h1 id="the-control">  Kontrol </h1><br><p>  Bagaimana kontrolnya diatur?  Seperti disebutkan di atas ada dua stasiun kontrol untuk mengendalikan pergerakan reng.  Setiap stasiun kontrol memiliki layar, alat penunjuk (trackball) dan penentu kecepatan (dan kami tidak menghitung komputer di dalam stasiun dan beberapa aksesori tambahan). </p><br><p>  Ada dua mode kontrol: manual dan "mode skenario".  "Mode Skenario" akan dibahas nanti, dan sekarang mari kita bicara tentang mode manual.  Dalam mode ini, seorang operator memilih reng, menyiapkannya untuk gerakan (menghubungkan mesin ke FC), menetapkan tanda target untuk reng, dan ketika kecepatan diatur di atas nol, reng mulai bergerak. </p><br><p>  Penyetel kecepatan adalah aksesori fisik dalam bentuk "potensiometer dengan gagang", tetapi ada juga yang virtual yang ditampilkan di layar stasiun.  Semakin diputar, semakin tinggi kecepatan gerakannya.  Kecepatan maksimum dibatasi 1,5 meter per detik.  Penyetel kecepatan adalah satu untuk semua reng.  Ini berarti bahwa semua reng yang dipilih bergerak dengan kecepatan yang sama.  Reng bisa bergerak ke arah yang berlawanan (tergantung pilihan operator).  Jelas bahwa sulit bagi manusia untuk mengendalikan lebih dari beberapa reng.  Karena itu hanya kelompok kecil reng yang ditangani dalam mode manual.  Operator dapat mengontrol reng dari dua stasiun kontrol secara bersamaan.  Jadi ada setter kecepatan terpisah untuk setiap stasiun. </p><br><p>  Dari sudut pandang implementasi, tidak ada logika khusus dalam mode manual.  Perintah "menghubungkan mesin" pergi dari antarmuka grafis, diubah menjadi pesan yang sesuai dengan aktor, dan kemudian sedang ditangani oleh aktor itu.  Aktor beralih dari status "tidak aktif" ke "menghubungkan", dan kemudian ke status "terhubung".  Hal serupa terjadi dengan perintah untuk memposisikan batten dan mengatur kecepatan gerakan.  Semua perintah ini diteruskan ke aktor dalam bentuk pesan.  Tetapi perlu disebutkan bahwa "antarmuka grafis" dan "proses kontrol" adalah proses yang terpisah dan libuniset2 digunakan untuk IPC. </p><br><h1 id="the-scenario-mode-are-there-actors-again">  Mode Skenario (apakah ada Aktor lagi?) </h1><br><p>  Dalam praktiknya, mode manual hanya digunakan untuk kasus yang sangat sederhana atau selama latihan.  Mode kontrol utama adalah "mode skenario".  Dalam mode itu, setiap reng dipindahkan ke posisi tertentu dengan kecepatan tertentu sesuai dengan pengaturan skenario.  Dua perintah sederhana tersedia untuk operator dalam mode itu: </p><br><ul><li>  mempersiapkan (sekelompok mesin sedang terhubung ke FC); </li><li>  go (pergerakan grup dimulai). </li></ul><br><p>  Seluruh skenario dibagi menjadi "agenda".  "Agenda" menggambarkan satu gerakan sekelompok reng.  Ini berarti bahwa "agenda" termasuk beberapa reng dan berisi tujuan target dan kecepatan untuk mereka.  Pada kenyataannya, sebuah skenario terdiri dari tindakan, tindakan terdiri dari gambar, gambar terdiri dari agenda, dan agenda terdiri dari target untuk reng.  Tetapi dari sudut pandang kontrol, itu tidak masalah, karena hanya agenda yang mengandung parameter yang tepat dari pergerakan batal. </p><br><p>  Model Aktor sangat cocok dengan case itu.  Kami telah mengembangkan "pemain skenario" yang memunculkan sekelompok aktor khusus dan memulai mereka.  Kami telah mengembangkan dua jenis aktor: aktor pelaksana (mereka mengendalikan pergerakan reng) dan aktor koordinator (mereka mendistribusikan tugas di antara para pelaksana).  Pelaksana dibuat atas permintaan: ketika tidak ada pelaksana gratis, pelaksana baru akan dibuat.  Koordinator mengelola kumpulan pelaksana yang tersedia.  Akibatnya, kontrolnya kira-kira terlihat seperti ini: </p><br><ul><li>  seorang operator memuat skenario; </li><li>  "gulir" itu sampai agenda yang diperlukan; </li><li>  tekan tombol "siapkan" pada waktu yang tepat.  Pada saat itu pesan dikirim ke koordinator.  Pesan ini berisi data untuk setiap reng dari agenda; </li><li>  koordinator meninjau kumpulan pelaksana dan mendistribusikan tugas-tugas antara pelaksana bebas (pelaksana baru dibuat, jika perlu); </li><li>  setiap pelaksana menerima tugas dan melakukan tindakan persiapan (menghubungkan mesin ke FC, kemudian menunggu perintah "go"); </li><li>  operator menekan tombol "pergi" pada saat yang tepat; </li><li>  perintah "go" pergi ke koordinator, dan mendistribusikan perintah antara semua pelaksana yang saat ini digunakan. </li></ul><br><p>  Ada beberapa parameter tambahan dalam agenda.  Seperti "mulai gerakan hanya setelah N detik tertunda" atau "mulai gerakan hanya setelah perintah tambahan dari operator".  Karena itu, daftar negara bagian untuk pelaksana cukup panjang: "siap untuk perintah berikutnya", "siap untuk gerakan", "penundaan gerakan", "menunggu perintah operator", "bergerak", "selesai", "kegagalan". </p><br><p>  Ketika reng telah berhasil mencapai tanda target (atau ada kegagalan) pelaksana melaporkan kepada koordinator tentang penyelesaian tugas.  Koordinator menjawab dengan perintah untuk mematikan mesin (jika batal tidak berpartisipasi dalam agenda lagi) atau mengirim tugas baru kepada pelaksana.  Eksekutor mematikan mesin dan beralih ke status "menunggu" atau mulai memproses perintah baru. </p><br><p>  Karena SObjectizer memiliki API yang cukup bijaksana dan nyaman untuk bekerja dengan status, kode implementasi ternyata cukup ringkas.  Misalnya, penundaan sebelum perpindahan dijelaskan hanya dengan satu baris kode: </p><br><pre> <code class="cpp hljs">st_delay.time_limit( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds{target-&gt;delay()}, st_moving ); st_delay.activate(); ...</code> </pre> <br><p>  Metode <code>time_limit</code> menentukan jumlah waktu untuk tetap dalam status dan kondisi mana yang harus diaktifkan kemudian ( <code>st_moving</code> dalam contoh itu). </p><br><h1 id="protection-actors">  Aktor perlindungan </h1><br><p>  Tentu saja, kegagalan dapat terjadi.  Ada persyaratan untuk menangani kegagalan ini dengan benar.  Aktor juga digunakan untuk tugas seperti itu.  Mari kita lihat beberapa contoh: </p><br><ul><li>  perlindungan arus lebih; </li><li>  perlindungan dari kerusakan sensor; </li><li>  perlindungan dari gerakan dalam arah yang berlawanan (itu bisa terjadi jika ada sesuatu yang salah dengan sensor atau aktuator); </li><li>  perlindungan dari gerakan spontan (tanpa perintah); </li><li>  kontrol pelaksanaan perintah (pergerakan reng harus diperiksa). </li></ul><br><p>  Kita dapat melihat bahwa semua kasus itu swasembada, tetapi mereka harus dikontrol bersama, pada saat yang sama.  Ini berarti bahwa kegagalan dapat terjadi.  Tetapi setiap cek memiliki logikanya: kadang-kadang perlu untuk memeriksa batas waktu, kadang-kadang diperlukan untuk menganalisis beberapa nilai sebelumnya dari sensor.  Karena itu, perlindungan dilaksanakan dalam bentuk aktor kecil.  Aktor-aktor ini ditambahkan pada kerjasama dengan aktor utama yang mengimplementasikan logika kontrol.  Pendekatan ini memungkinkan penambahan kasus perlindungan baru dengan mudah: tambahkan saja aktor pelindung lain ke dalam kerja sama.  Kode aktor seperti itu biasanya singkat dan mudah dimengerti, karena hanya mengimplementasikan satu fungsi. </p><br><p>  Aktor pelindung juga memiliki beberapa negara.  Biasanya, mereka dihidupkan ketika mesin dihidupkan atau ketika sebuah reng mulai bergerak.  Ketika pelindung mendeteksi kegagalan / kegagalan, ia menerbitkan pemberitahuan (dengan kode perlindungan dan beberapa detail tambahan di dalamnya).  Aktor utama bereaksi terhadap pemberitahuan itu dan melakukan tindakan yang diperlukan (seperti mematikan mesin dan beralih ke keadaan terlindungi). </p><br><h1 id="as-the-conclusion">  Sebagai kesimpulan ... </h1><br><p>  ... artikel ini bukan merupakan terobosan tentunya.  Model Aktor digunakan dalam berbagai sistem untuk waktu yang cukup lama.  Tetapi itu adalah pengalaman pertama saya menggunakan Model Aktor untuk membangun sistem kontrol otomatis dalam proyek yang agak kecil.  Dan pengalaman ini ternyata cukup sukses.  Saya harap saya telah menunjukkan bahwa aktor cocok untuk algoritma kontrol: ada tempat untuk aktor di mana-mana. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kami</a> telah menerapkan sesuatu yang serupa dalam proyek-proyek sebelumnya (maksud saya negara bagian, pertukaran pesan, pengelolaan utas pekerja, dan sebagainya), tetapi itu bukan pendekatan terpadu.  Dengan menggunakan SObjectizer, kami mendapat alat kecil dan ringan yang memecahkan banyak masalah.  Kita tidak perlu lagi (secara eksplisit) menggunakan mekanisme sinkronisasi tingkat rendah (seperti mutex), tidak ada manajemen thread manual, tidak ada lagi statecharts tulisan tangan.  Semua ini disediakan oleh framework, terhubung secara logis dan diekspresikan dalam bentuk API yang nyaman, tetapi Anda tidak kehilangan kontrol pada detail.  Jadi itu pengalaman yang menyenangkan.  Jika Anda masih ragu, maka saya sarankan Anda untuk melihat Actor Model dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SObjectizer</a> pada khususnya.  Itu meninggalkan emosi positif. </p><br><p>  Model Aktor benar-benar berfungsi!  Terutama di teater. </p><br><p>  Artikel asli dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bahasa Rusia</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id452464/">https://habr.com/ru/post/id452464/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id452454/index.html">Masuk ke Azure DevOps menggunakan kredensial GitHub Anda</a></li>
<li><a href="../id452456/index.html">Microsoft Kaizala memungkinkan Indian Railways menghubungkan tiga juta karyawannya dengan layanan kesehatan</a></li>
<li><a href="../id452458/index.html">Awasi Anjing di kehidupan nyata, atau kerentanan serius dalam ACS</a></li>
<li><a href="../id452460/index.html">Memperkenalkan Terminal Windows</a></li>
<li><a href="../id452462/index.html">Tentang OOP</a></li>
<li><a href="../id452466/index.html">Keyboard braille</a></li>
<li><a href="../id452468/index.html">"Jika kamu perlu membunuh seseorang, maka kamu datang ke alamat"</a></li>
<li><a href="../id452474/index.html">Analisis wavelet. Bagian 2</a></li>
<li><a href="../id452478/index.html">Membuat tabel dalam sistem desain Figma dan implementasinya dalam Storybook (React)</a></li>
<li><a href="../id452480/index.html">Phoenix LiveView: ketika Anda tidak lagi membutuhkan JavaScript *</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>