<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👦🏾 🤹🏻 💃🏾 Siri-Schnellbefehle 💅🏿 👨🏾‍⚖️ ℹ️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eine der nützlichen (meiner Meinung nach) iOS 12-Funktionen, die auf der WWDC 2018 vorgestellt wurden, sind Siri Shortcuts . 


 Verknüpfung ( Verknüp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Siri-Schnellbefehle</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/414677/"><p><img src="https://habrastorage.org/webt/ge/mr/un/gemrunsbwx7gf07v5htwy9lytpu.png"></p><br><p>  Eine der nützlichen (meiner Meinung nach) iOS 12-Funktionen, die auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://">WWDC 2018 vorgestellt wurden,</a> sind <strong>Siri Shortcuts</strong> . </p><br><p>  Verknüpfung ( <em>Verknüpfung</em> ) - ein schneller Befehl, eine kurze Möglichkeit, eine Aktion unter Umgehung des Standardskripts auszuführen. </p><br><p>  In Ihren Anwendungen können Sie Verknüpfungen für einige Aktionen ausrichten.  Als Siri erfährt, wie und wann der Benutzer sie implementiert, beginnt er geschickt, zur richtigen Zeit und am richtigen Ort, um ihm diese Verknüpfungen anzubieten, und das Beste ist, dass der Benutzer sie mit Phrasen aufrufen kann, die er ihnen anhängen wird!  Unter der Katze mehr. </p><a name="habracut"></a><br><h2 id="kak-eto-rabotaet">  Wie funktioniert es? </h2><br><p>  Wir verwenden Anwendungen, die mit bestimmten Aktionen Verknüpfungen erstellen und an das System senden. </p><br><p>  Sie können diese Verknüpfungen unter <strong>Einstellungen → Siri und Suche</strong> anzeigen. <br><img src="https://habrastorage.org/webt/vp/z2/fd/vpz2fdo_rakpjpl-imiuvzkbyly.png"><br>  Der Screenshot oben zeigt die letzten drei Verknüpfungen, die das System von verschiedenen Anwendungen abgefangen hat.  Wenn Sie auf die Schaltfläche "Weitere Verknüpfungen" klicken, werden alle Verknüpfungen angezeigt, die von jeder Anwendung an das System gesendet wurden. </p><br><p>  Mit bestimmten Einstellungen im Verknüpfungserstellungscode bietet Siri dem Benutzer diese Verknüpfungen auf dem gesperrten Bildschirm, im Benachrichtigungs- und Suchcenter an und konzentriert sich darauf, wie oft wir diese Aktionen zu welcher Zeit, an welchen Wochentagen und wo auf andere Faktoren anwenden. </p><br><p>  Wenn Sie beispielsweise am Freitagabend normalerweise nach Geldautomaten suchen und dann trainiert haben, bietet Ihnen Siri am Freitagabend eine Verknüpfung mit dieser Aktion an. </p><br><p><img src="https://habrastorage.org/webt/ef/my/gu/efmyguxaczsetehquug_nyp7vnc.png"></p><br><p>  Wir können unseren Sprachbefehl zu jeder Verknüpfung hinzufügen, wenn wir auf das Symbol " <strong>+</strong> " klicken. </p><br><p>  Wir sagen einen Sprachbefehl, drücken "Fertig" und jetzt können wir die Aktion hinter der Verknüpfung mit der Stimme über Siri ausführen.  <em>Es stellt sich heraus, dass der Benutzer die Funktionalität Ihrer Anwendung über Siri ausführen kann, ohne die Anwendung selbst zu öffnen.</em>  Die Verknüpfung mit der Phrase bleibt in "Meine Verknüpfungen" erhalten. </p><br><h2 id="sozdanie-shortkatov">  Verknüpfungen erstellen </h2><br><p> Für die Entwicklung benötigen wir Xcode 10 und iOS 12. Zum Zeitpunkt des Schreibens befinden sich beide in der <strong>Beta-</strong> Phase. </p><br><p> Eine Verknüpfung kann entweder über <code>NSUserActivity</code> oder über <code>Intent</code> . </p><br><p>  Der erste Fall: </p><br><p>  Der Benutzer klickt auf die Verknüpfung, die den Befehl mit den Parametern ( <code>NSUserActivity</code> ) an unsere Anwendung <code>NSUserActivity</code> , und entscheidet, wie dieser Befehl verarbeitet werden soll (öffnen Sie das Fenster des aktuellen USD-Kurses oder das <code>NSUserActivity</code> unserer Lieblingspizza).  Dies ist die gute alte Spotlight-Verknüpfung, die wir alle kennen, die Siri jedoch geschickt anbietet. </p><br><p>  Zweiter Fall: </p><br><p>  Interessanter <code>Intent</code> über <code>Intent</code> erstellte Verknüpfungen, mit denen Sie einen Befehl sofort in der Siri-Oberfläche ausführen können, ohne Ihre Anwendung zu starten.  Zuvor waren die <code>Intent</code> für Apple schwierig: Geld überweisen, Nachrichten senden und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">andere</a> .  Jetzt haben wir Entwickler die Möglichkeit, unsere <code>Intent</code> zu erstellen! </p><br><p>  Unabhängig davon, wie die Verknüpfung erstellt wurde, durchläuft sie drei Phasen des Lebenszyklus: </p><br><ol><li>  Ankündigung ( <strong><em>Definieren</em></strong> ) </li><li>  Lieferung an das System ( <strong><em>Spenden</em></strong> ) </li><li>  Bearbeitung nach Anwendung ( <strong><em>Handle</em></strong> ) </li></ol><br><p><img src="https://habrastorage.org/webt/ie/7b/6z/ie7b6zoy5fd9mkx5ivjddp0agxc.png"></p><br><p>  Meine Forschung hat gezeigt, dass eine Anwendung nicht mehr als 20 Verknüpfungen zum System liefern kann. </p><br><p>  Darüber hinaus werden wir uns überlegen, wie wir unserer Anwendung die Möglichkeit geben können, Verknüpfungen zu erstellen und mit ihnen darin zu arbeiten. </p><br><h2 id="sozdanie-shortkatov-cherez-nsuseractivity">  Erstellen von Verknüpfungen über <code>NSUserActivity</code> </h2><br><p>  Lassen Sie uns den ersten einfachen Typ von Verknüpfungen analysieren, die über <code>NSUserActivity</code> geöffnet werden. </p><br><p>  Zum Beispiel haben wir in der mobilen Bankanwendung einen Geldautomaten-Suchbildschirm und ich suche oft nach ihnen.  Um mit einer Geldautomatenkarte auf den Bildschirm zu gelangen, muss ich die Anwendung starten, auf der Registerkarte zur Registerkarte „Mehr“ gehen, den Abschnitt „Info“ auswählen und dort auf die Schaltfläche „Geldautomaten“ klicken. <br>  Wenn wir eine Verknüpfung erstellen, die sofort zu diesem Bildschirm führt, kann der Benutzer mit einer Berührung darauf zugreifen, wenn Siri sie ihm beispielsweise auf einem gesperrten Bildschirm anbietet. </p><br><h3 id="obyavlyaem-shortkat-declare">  Verknüpfung deklarieren </h3><br><p>  Der erste Schritt besteht darin, einen Typ wie unsere <code>NSUserActivity</code> (wir können sagen, dass dies die Kennung ist) in der <em>info.playlist zu deklarieren</em> : </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>NSUserActivityTypes<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">array</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span>ru.tinkoff.demo.show-cashMachine<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">array</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Angekündigt. </p><br><h3 id="dostavlyaem-shortkat-v-sistemu-donate">  Liefern Sie die Verknüpfung an das System (Spenden) </h3><br><p>  Nach der Deklaration können wir <code>NSUserActivity</code> im Code unserer Anwendung mit dem Typ erstellen, den wir oben in <strong>info.playlist festgelegt haben</strong> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> activity = NSUserActivity(activityType: <span class="hljs-string"><span class="hljs-string">"ru.tinkoff.demo.show-cashMachine"</span></span>)</code> </pre> <br><p>  Damit die Aktivität in die Liste der Verknüpfungen des Systems aufgenommen werden kann, muss sie auf <code>title</code> und die Eigenschaft <code>isEligibleForSearch</code> auf <code>true</code> .  Andere Eigenschaften sind für das Hinzufügen zu Verknüpfungen nicht erforderlich, aber ihre Anwesenheit macht die Verknüpfung lesbarer und benutzerfreundlicher. </p><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//   (     ,   ) activity.title = " " if #available(iOS 12.0, *) { // ,             activity.suggestedInvocationPhrase = "  " //           activity.isEligibleForPrediction = true // (     ,   ) activity.isEligibleForSearch = true } //       let attributes = CSSearchableItemAttributeSet(itemContentType: "NSUserActivity.searchableItemContentType") ///    if let image = UIImage(named: "siriAtmIcon") { attributes.thumbnailData = UIImagePNGRepresentation(image) } ///   attributes.contentDescription = "     " ///     activity.contentAttributeSet = attributes</span></span></code> </pre> <br><p>  Feuer!  <code>NSUserActivity</code> ist, um es an das System zu liefern, der letzte Schritt. </p><br><p>  <code>ViewConroller</code> verfügt über eine <code>userActivity</code> Eigenschaft, der wir die oben erstellte <code>activity</code> zuweisen müssen: </p><br><pre> <code class="javascript hljs">self.userActivity = activity</code> </pre> <br><p>  Sobald diese Zeile ausgeführt wird, wird aus dieser Aktivität eine Verknüpfung erstellt.  Es wird an das System geliefert und in den Siri-Einstellungen ( <strong>Einstellungen → Siri und Suche</strong> ) angezeigt.  Dann kann Siri es dem Benutzer anbieten und der Benutzer kann ihm seinen Sprachbefehl zuweisen. </p><br><p>  <em><strong>Hinweis</strong> : In der Apple-Dokumentation heißt es, dass es nicht ausreicht, dem View Controller Aktivität <code>becomeCurrent()</code> , sondern die Methode <code>becomeCurrent()</code> für die <code>becomeCurrent()</code> .</em>  <em>Diese Aktion hat jedoch keine Aktivität auf mein System übertragen, und die Verknüpfung wurde nicht in der Liste angezeigt</em> </p><br><blockquote>  Rufen Sie als <code>becomeCurrent()</code> Methode <code>becomeCurrent()</code> für das Benutzeraktivitätsobjekt auf, um es als aktuell zu markieren, wodurch die Aktivität an Siri <code>becomeCurrent()</code> .  Alternativ können Sie das Objekt an ein UIViewController- oder UIResponder-Objekt anhängen, das die Aktivität auch als aktuell markiert. </blockquote><p>  Um zu überprüfen, ob alles funktioniert hat, öffnen Sie <strong>Einstellungen&gt; Siri und suchen Sie</strong> - die Verknüpfung, die auf unserer Aktivität basiert, sollte in der Liste enthalten sein. </p><br><h3 id="obrabotka-shortkata-prilozheniem-handle">  Verarbeiten von Verknüpfungen nach Anwendung (Handle) </h3><br><p>  Wenn ein Benutzer vom Benachrichtigungscenter aus durch die Verknüpfung navigiert oder diese per Spracheingabe aktiviert, wird die Anwendung gestartet, und wir müssen diese Verknüpfung verarbeiten. </p><br><p>  <code>activity</code> uns in <code>AppDelegate</code> 'eine Methode geworfen: </p><br><pre> <code class="javascript hljs">func application(_ application: UIApplication, <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> userActivity: NSUserActivity, <span class="hljs-attr"><span class="hljs-attr">restorationHandler</span></span>: @escaping ([UIUserActivityRestoring]?) -&gt; Void) -&gt; Bool { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> userActivity.activityType == <span class="hljs-string"><span class="hljs-string">"ru.tinkoff.demo.show-cashMachine"</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   ,     handleShowCashMachineActivity() return true } return false }</span></span></code> </pre> <br><h3 id="itogo">  Insgesamt </h3><br><p>  Eine NSUserActivity- <code>NSUserActivity</code> wird wie folgt erstellt: </p><br><ol><li>  Deklarieren Sie den Typ (Bezeichner) von <code>NSUserActivity</code> in <code>NSUserActivity</code> . </li><li>  Wir erstellen <code>NSUserActivity</code> im Code und konfigurieren </li><li>  <code>viewController'</code> . </li></ol><br><h2 id="sozdanie-golosovyh-komand-iz-prilozheniya">  Erstellen von Sprachbefehlen aus einer Anwendung </h2><br><p>  Wenn der Benutzer also <strong>Einstellungen&gt; Siri</strong> öffnet <strong>und sucht</strong> , wird eine Liste seiner Verknüpfungen angezeigt, die von verschiedenen Anwendungen erstellt wurden, einschließlich unserer.  Durch Klicken auf das „ <strong>+</strong> “ kann der Benutzer einen beliebigen Sprachbefehl erstellen und ihn der ausgewählten Verknüpfung zuordnen.  Jedes Mal, wenn die Eingabe der Einstellungen für den Benutzer unpraktisch ist, erkennen viele diese Möglichkeit nicht einmal. </p><br><p>  Es ist cool, dass Sie einer bestimmten Aktion direkt in der Anwendung einen Sprachbefehl hinzufügen können. </p><br><p>  Angenommen, ein Benutzer führt eine Aktion aus, die an das System übermittelt wird und die er speichern möchte.  Wir können die Schaltfläche " <em>Aktion zu Siri hinzufügen</em> " (Sie können die Schaltfläche nach Belieben benennen und zeichnen) auf dem Bildschirm unserer Anwendung <em>hinzufügen.</em> Durch Klicken darauf kann der Benutzer diese Aktion einem Sprachbefehl innerhalb der Anwendung zuordnen, ohne die Einstellungen aufzurufen. </p><br><p>  Durch Klicken auf die Schaltfläche sollten Sie den Bildschirm zum Hinzufügen eines Sprachbefehls zu einer Verknüpfung in Siri <code>INUIAddVoiceShortcutViewController</code> oder den Bildschirm zum Bearbeiten eines Sprachbefehls <code>INUIEditVoiceShortcutViewController</code> , falls bereits einer erstellt wurde, modal öffnen.  Die nicht umgesetzte <code>action</code> solchen Knopfes ist ungefähr wie folgt: </p><br><pre> <code class="hljs julia"> <span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> func addToSiriAction() { // <span class="hljs-number"><span class="hljs-number">1.</span></span>   ,       INVoiceShortcutCenter.shared.getAllVoiceShortcuts { (shortcuts, error) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> guard error == nil, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> shortcuts = shortcuts <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { // TODO: Handle error <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } // <span class="hljs-number"><span class="hljs-number">2.</span></span>     ,      <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> donatedShortcut: INVoiceShortcut? = shortcuts.first(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: { (shorcut) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> shorcut.__shortcut.userActivity?.activityType == <span class="hljs-string"><span class="hljs-string">"com.ba"</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> shortcut = donatedShortcut { // <span class="hljs-number"><span class="hljs-number">3.</span></span>     -     . //         <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> editVoiceShortcutViewController = INUIEditVoiceShortcutViewController(voiceShortcut: shortcut) editVoiceShortcutViewController.delegate = self self.present(editVoiceShortcutViewController, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, completion: nil) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { // <span class="hljs-number"><span class="hljs-number">4.</span></span>         <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> shortcut = INShortcut(userActivity: self.userActivity!) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> addVoiceShortcutViewController = INUIAddVoiceShortcutViewController(shortcut: shortcut) addVoiceShortcutViewController.delegate = self } } }</code> </pre> <br><p>  Die Bildschirme zum Hinzufügen und Bearbeiten eines Sprachbefehls für die Siri-Verknüpfung sehen also folgendermaßen aus: </p><br><p><img src="https://habrastorage.org/webt/ez/lk/ai/ezlkaihh3q9gvj4syqkizbwqy4c.png"></p><br><p>  Wir müssen auch die Delegate-Methoden dieser viewController implementieren, in denen sie <code>dismiss(animated: true, completion: nil)</code> ausblenden und gegebenenfalls den aktuellen Bildschirm aktualisieren müssen.  Wenn beispielsweise früher auf dem Bildschirm die Schaltfläche "Sprachbefehl hinzufügen" angezeigt wurde, sollte diese Schaltfläche nach dem Hinzufügen eines Sprachbefehls entweder verschwinden oder in "Sprachbefehl bearbeiten" geändert werden. </p><br><h2 id="shortkaty-sozdannye-pri-pomoschi-intent">  Absichtsverknüpfungen </h2><br><p>  Bisher haben wir nur über Verknüpfungen gesprochen, die eine Anwendung öffnen und dort <code>NSUserActivity</code> Daten an <code>NSUserActivity</code> . </p><br><p>  Zurück zu den über <code>Intent</code> erstellten Verknüpfungen, mit denen Sie einige Aktionen ausführen können, ohne die Anwendung zu öffnen.  Hier beginnt der Spaß. </p><br><p>  Stellen Sie sich vor, ein Benutzer bestellt seine Lieblingspizza.  Er wird es viele Male bestellen, wann immer er will, und er hat der Abkürzung dieser Pizza sogar einen Sprachbefehl hinzugefügt - und das vereinfacht sein Leben.  Aber wir können mehr für ihn tun - wir können sicherstellen, dass das System den Siri-Sprachbefehl nicht in die Anwendung wirft, sondern Bestellinformationen anzeigt und Pizza sofort in der Siri-Oberfläche bestellt!  Dies ist nur dann der Fall, wenn der Benutzer die Anwendung selbst nicht öffnen muss, um eine Aktion auszuführen. </p><br><p>  Gehen Sie zunächst zu den Projekteinstellungen, wählen Sie das Hauptziel und die Registerkarte Funktionen aus und aktivieren Sie den Zugriff auf Siri. </p><br><p>  Unsere Anwendung kann mit Siri interagieren, dies geschieht jedoch nicht im Hauptcode der Anwendung, sondern in einer separaten <strong>Zielerweiterung Intents Extensions</strong> </p><br><p>  Zu Beginn muss dieses Ziel erstellt werden: <strong>Datei → Neu → Ziel</strong> , <strong>Intents Extensions</strong> auswählen.  Xcode bietet an, eine weitere Zielerweiterung für das Fenster zu erstellen, in dem Ihre Aktionen in Siri angezeigt werden. Wenn dies erforderlich ist, stimmen wir zu. </p><br><p><img src="https://habrastorage.org/webt/ia/o_/pp/iao_pphchyfpr33hj6jluyy-ozc.jpeg"></p><br><h3 id="obyavlyaem-shortkat-declare-1">  Verknüpfung deklarieren </h3><br><p>  Die Hauptinnovation von SiriKit in iOS 12 ist die Möglichkeit, Ihre <code>Inetnts</code> zu erstellen, wie sie früher waren. </p><br><p><img src="https://habrastorage.org/webt/5a/66/6m/5a666mqkcm0li-cujpl7yexzrgm.png"></p><br><p>  Erstellen Sie dazu eine neue Datei: <strong>Datei → Neu → Datei</strong> , und wählen <strong>Sie</strong> im Abschnitt <strong>Ressource die</strong> <strong>Option SiriKit Intent Definition File</strong> aus. </p><br><p><img src="https://habrastorage.org/webt/qz/8l/lx/qz8llxznc1o05palhxxxcskrcbq.png"></p><br><p>  Als Ergebnis wird eine Datei mit der Erweiterung <em>.intentdefinition angezeigt</em> , in der Sie Ihre eigenen <em>Absichten</em> erstellen können.  Wir öffnen die Datei und wo unten " <strong>No Intents</strong> " steht, befindet sich ein " <strong>+</strong> " - Symbol - klicken Sie darauf.  " <strong>Neue Absicht</strong> ".  In der Liste wird eine Absicht angezeigt, zu der Sie Parameter hinzufügen können.  Bei einer Pizza-Bestellung können Sie die Anzahl der Pizzen und die Art der zu bestellenden Pizza als Parameter hinzufügen.  Für die Menge wählen wir den Typ <code>Integer</code> und für den <code>INObject</code> den Typ <code>Custom</code> , der im Code durch die Klasse <code>INObject</code> . </p><br><p>  Nun ein paar Zeilen Frustration: </p><br><p>  <strong>Der Benutzer kann keine unterschiedlichen Parameter an denselben gespeicherten Sprachbefehl übertragen.</strong>  <strong>Ach!</strong> </p><br><p><img src="https://habrastorage.org/webt/kn/z4/y-/knz4y-oo1kns8ehvzoojslxqycq.jpeg"></p><br><p>  Was sind die Parameter für: </p><br><p>  Angenommen, Sie erstellen eine Entität "Rate <code>%currency</code> ", wobei <code>currency</code> ein Entitätsparameter ist.  Dies bedeutet nicht, dass der Benutzer die Sätze "Den Wechselkurs des Dollars anzeigen", "Den Bitcoin-Wechselkurs anzeigen" usw. sagen kann.  Standardmäßig funktioniert dies nicht so.  Dies bedeutet jedoch, dass, wenn der Benutzer den Dollar-Wechselkurs betrachtete, die Verknüpfung "USD-Kurs anzeigen" erstellt wurde, dann, wenn er den Bitcoin-Wechselkurs betrachtete, die Verknüpfung "BTC-Kurs anzeigen" erstellt wurde  Mit anderen Worten, er kann mehrere Shorkatas haben, die auf derselben Absicht basieren, aber unterschiedliche Parameter haben.  Bei jeder der Verknüpfungen kann der Benutzer seinen Sprachbefehl erfragen. </p><br><p>  <em>Wenn Sie</em> eine Absicht in der <em>.intentdefinition-</em> Datei erstellen, generiert <em>Xcode</em> automatisch eine Klasse für diese Absicht (Hinweis: Sie wird nicht in den Projektdateien angezeigt, steht jedoch zur Verwendung zur Verfügung). Diese automatisch generierte Datei befindet sich nur in den Zielen, die die <em>.intentdefinition-</em> Datei besitzen. </p><br><p>  Nachdem wir die Absicht in der .intentdefinition-Datei erstellt haben <em>, können</em> wir unsere Absichten im Code erstellen. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intent = <span class="hljs-type"><span class="hljs-type">OrderPizzaIntent</span></span>()</code> </pre> <br><h3 id="dostavlyaem-shortkat-v-sistemu-donate-1">  Liefern Sie die Verknüpfung an das System (Spenden) </h3><br><p>  Damit diese Entität in die Liste der Verknüpfungen aufgenommen wird, müssen Sie sie einbetten.  Zu diesem Zweck wird ein <code>INInteraction</code> Objekt mit einer Instanz Ihrer Absicht erstellt und die .donate-Methode wird für diese <code>.donate</code> aufgerufen </p><br><pre> <code class="hljs lua">let intent = OrderPizzaIntentf() // ...   let interaction = INInteraction(intent: intent, response: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) interaction.donate { (<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> // ...   /  }</code> </pre> <br><p>  Nach dem Ausführen dieses Codes wird die absichtsbasierte Verknüpfung an das System gesendet und in den Siri-Einstellungen angezeigt. </p><br><h3 id="obrabatyvaem-shortkat-prilozheniem-handle">  Wir bearbeiten die Verknüpfungsanwendung (Handle) </h3><br><p>  Der nächste Schritt besteht darin, die Absicht zu verarbeiten, wenn der Benutzer im Sirjest des Siri darauf klickt oder sie mit einem Sprachbefehl anruft. </p><br><p>  Wir haben bereits eine Zielerweiterung für Siri erstellt und sie verfügt über eine vorab erstellte IntentHandler-Klasse, die eine einzige Methode hat - `` handle (for intent) `` </p><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntentHandler</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">INExtension</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> intent: INIntent)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Any</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> intent <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-type"><span class="hljs-type">OrderPizzaIntent</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">"Unhandled intent type: \(intent)"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">OrderPizzaIntentHandler</span></span>() } }</code> </pre> <br><blockquote>  Hinweis: Wenn der Compiler die Klasse Ihrer Absicht nicht sieht, haben Sie die <em>Zielerweiterungsdatei .intentdefinition</em> für Siri nicht hinzugefügt. </blockquote><p>  Bei dieser Methode bestimmen wir den Typ der eingehenden Absicht und erstellen für jeden Typ ein Handlerobjekt, das diese Absicht verarbeitet.  Erstellen Sie einen Handler für unser <code>OrderPizzaIntent</code> und implementieren Sie das <code>OrderPizzaIntentHandling</code> Protokoll darin, das bereits automatisch generiert wird, nachdem Sie Ihre Absicht in <em>.intentdefinition erstellt haben</em> . </p><br><p>  Das Protokoll enthält zwei Methoden zur <code>confirm</code> und <code>handle</code> .  Zunächst wird die <code>confirm</code> aufgerufen, bei der alle Daten überprüft und die Verfügbarkeit der Aktion überprüft werden.  Dann funktioniert der <code>handle</code> in einer kurzen Aktion, die ausgeführt werden muss. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderPizzaIntentHandler</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderPizzaIntentHandling</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">confirm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(intent: OrderPizzaIntent, completion: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(OrderPizzaIntentResponse)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//      // ... completion(OrderPizzaIntentResponse(code: OrderPizzaIntentResponseCode.ready, userActivity: nil)) } public func handle(intent: OrderPizzaIntent, completion: @escaping (OrderPizzaIntentResponse) -&gt; Void) { //     // ... completion(OrderPizzaIntentResponse(code: OrderPizzaIntentResponseCode.success, userActivity: nil)) } }</span></span></code> </pre> <br><p>  Beide Methoden müssen definitiv die <code>completion</code> mit der Antwort <code>OrderPizzaIntentResponse</code> (sie wird ebenfalls automatisch generiert), andernfalls wartet Siri nur lange und gibt dann einen Fehler aus. </p><br><h3 id="bolee-podrobnye-otvety-ot-siri">  Detailliertere Antworten von Siri </h3><br><p>  Es gibt einen standardmäßigen, automatisch generierten Satz von Antwortcodes - <code>enum OrderPizzaIntentResponseCode</code> , aber diese reichen möglicherweise nicht für eine <code>enum OrderPizzaIntentResponseCode</code> Oberfläche aus.  In der <code>confirm</code> beispielsweise verschiedene Fehler auftreten - die Pizza ist aufgebraucht, die Pizzeria funktioniert derzeit nicht usw.  und der Benutzer sollte anstelle der Standardnachricht "Anwendungsfehler" mehr über diese Fakten erfahren.  Denken Sie daran, dass wir <code>Intent</code> in der <em>.intentdefinition-</em> Datei erstellt haben?  Zusammen mit der Absicht selbst wurde die <code>Response</code> in der Sie Ihre eigenen Optionen für Fehler und erfolgreiche Antworten hinzufügen und diese mit den folgenden Parametern konfigurieren können: </p><br><p><img src="https://habrastorage.org/webt/xz/zg/fa/xzzgfawljagfnruxp_zjjdeug2m.png"></p><br><p>  Jetzt können wir dem Benutzer informativere Fehler und Antworten mitteilen: </p><br><pre> <code class="hljs lua">public func confirm(intent: OrderPizzaIntent, completion: @escaping (OrderPizzaIntentResponse) -&gt; Void) { guard let pizzaKindId = intent.kind?.identifier <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //         -     completion(OrderPizzaIntentResponse(code: .failure, userActivity: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pizzeriaManager.isPizzeriaClosed == <span class="hljs-literal"><span class="hljs-literal">true</span></span> { ///     -     completion(OrderPizzaIntentResponse(code: .failurePizzeriaClosed, userActivity: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pizzeriaManager.menu.isPizzaUnavailable(identifier: pizzaKindId) { ///      -     completion(OrderPizzaIntentResponse(code: .failurePizzaUnavailable(kind: intent.kind), userActivity: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } //     -    completion(OrderPizzaIntentResponse(code: .ready, userActivity: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) }</code> </pre> <br><h3 id="otrisovka-intenta">  <code>Intent</code> Rendern </h3><br><p>  Wenn wir eine <strong>Zielerweiterung</strong> für die Absichtserweiterungs- <strong>Benutzeroberfläche erstellt haben</strong> , können wir in Siri eine benutzerdefinierte Ansicht für die von uns benötigten Absichten zeichnen.  Wir haben <code>MainInterface.storyboard</code> und <code>IntentViewController</code> in denen wir ihr Design skizzieren können.  Dieser Ansichtscontroller implementiert das INUIHostedViewControlling-Protokoll und die Ansicht wird in der <code>configureView</code> Methode <code>configureView</code> </p><br><pre> <code class="hljs sql">// <span class="hljs-keyword"><span class="hljs-keyword">Prepare</span></span> your <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> controller <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the interaction <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> handle. func configureView(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">parameters</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;INParameter&gt;, <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> interaction: INInteraction, interactiveBehavior: INUIInteractiveBehavior, <span class="hljs-keyword"><span class="hljs-keyword">context</span></span>: INUIHostedViewContext, completion: @escaping (<span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;INParameter&gt;, CGSize) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Void</span></span>) { // <span class="hljs-keyword"><span class="hljs-keyword">Do</span></span> configuration here, <span class="hljs-keyword"><span class="hljs-keyword">including</span></span> preparing views <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> calculating a desired <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> presentation. completion(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">parameters</span></span>, self.desiredSize) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> desiredSize: CGSize { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.extensionContext!.hostedViewMaximumAllowedSize }</code> </pre> <br><p>  Damit diese Methode aufgerufen werden kann, müssen Sie den Namen unserer Absicht zum Array <code>NSExtension</code> -&gt; <code>NSExtensionAttributes</code> -&gt; <code>IntentsSupported</code> , das sich auf die Benutzeroberfläche des Erweiterungsziels Intents bezieht </p><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>NSExtension<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dict</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>NSExtensionAttributes<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dict</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>IntentsSupported<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">array</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span>OrderPizzaIntent<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">array</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dict</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Abhängig vom Design Ihrer Ansicht in Siri und der <code>interaction.intent</code> , die in die Methode eingeflossen ist, können Sie diese Ansicht nach Ihren Wünschen zeichnen.  Unten finden Sie Screenshots, wie unsere Absicht in Siri aussieht, auf der Suche und auf einem gesperrten Bildschirm. </p><br><p><img src="https://habrastorage.org/webt/wr/gh/sa/wrghsafmpp3qz3fiih1afdkrrou.png"></p><br><p>  Es ist zu beachten, dass der Benutzer nicht mit Schaltflächen, Bildlauf und anderen Steuerelementen in Ihrer Ansicht <code>interactiveBehavior = .none</code> , da die Methode mit dem ParameterinteractiveBehavior <code>interactiveBehavior = .none</code> wird. Dies führt sicherlich zu einer Reihe von Einschränkungen. </p><br><h3 id="itogo-1">  Insgesamt </h3><br><p>  Eine <code>Intent</code> Verknüpfung kann in der Siri-Oberfläche oder im Benachrichtigungscenter gerendert werden und eine Aktion ausführen, ohne die Anwendung zu öffnen.  Um es zu erstellen, benötigen Sie: </p><br><ol><li>  Aktivieren Sie die Funktionen zur Verwendung von Siri </li><li>  Erstellen Sie <strong>Intents Extensions</strong> und <strong>Intents Extensions UI</strong> </li><li>  Erstellen Sie eine <strong>SiriKit Intent Definition-Datei</strong> </li><li>  Wir erstellen unsere <code>Intent</code> in dieser Datei und weisen ihr Parameter zu. </li><li>  Erstellen Sie einen <code>IntentHandler</code> in dem wir die <code>hanlde</code> und <code>hanlde</code> implementieren </li></ol><br><h2 id="rekomendacii">  Empfehlungen </h2><br><h3 id="obschiy-kod-v-targete-rasshirenii-siri-i-v-osnovnom-prilozhenii">  Generischer Code im Siri-Erweiterungsziel und in der Hauptanwendung </h3><br><p>  Wenn Sie Code haben, der sowohl im Ziel für Siri als auch im Ziel des Hauptprojekts verwendet wird, gibt es zwei Möglichkeiten, um dieses Problem zu lösen: </p><br><ol><li>  Markieren Sie gemeinsame Klassen und fügen Sie sie beiden Zielen hinzu.  ( <strong>Ansicht → Dienstprogramme → Dateiinspektor anzeigen</strong> , fügen Sie im Abschnitt Zielmitgliedschaft Häkchen zu Zielen hinzu, die Zugriff auf die ausgewählte Datei benötigen.) </li><li>  Erstellen Sie ein oder mehrere Ziel-Frameworks und übernehmen Sie dort den allgemeinen Code. </li></ol><br><p>  Die letztere Methode ist vorzuziehen, da Sie diese Frameworks dann in anderen Erweiterungen und Projekten verwenden können.  Es ist auch erwähnenswert, dass es für diese Frameworks ratsam ist, das Flag " <code>Allow app extension API only</code> zu setzen. Bei der Entwicklung des Frameworks schwört der Compiler, wenn Sie versuchen, eine API zu verwenden, die für die Entwicklung von Erweiterungen illegal ist (z. B. <code>UIApplication</code> ). </p><br><p>  Freigegebene Ressourcen können über <strong>App-Gruppen</strong> zwischen Zielen <strong>durchsucht werden</strong> </p><br><h3 id="otladka">  Debuggen </h3><br><p>  Das Testen von Verknüpfungen hilft dabei: </p><br><ol><li>  Telefoneinstellungen <strong>Einstellungen → Entwickler</strong> : <strong>Letzte Verknüpfungen</strong> <strong>anzeigen</strong> und <strong>Spenden auf</strong> <strong>Sperrbildschirmschaltern</strong> <strong>anzeigen</strong> : </li></ol><br><p><img src="https://habrastorage.org/webt/lv/0s/v8/lv0sv8rxfrdw7tgeqaql7p9yyhy.png"></p><br><ol><li>  Um Intens zu testen, können Sie die Zielerweiterung sofort starten, indem Sie in Xcode die Phrase angeben, mit der Siri öffnet.  Wählen Sie dazu das Schema für die Zielerweiterung Siri aus </li></ol><br><p><img src="https://habrastorage.org/webt/lc/lf/vj/lclfvj0e18-jx73zrxkf0tasnyq.png"></p><br><p>  Klicken Sie auf dieses Ziel, klicken Sie auf <strong>Schema bearbeiten ...</strong> </p><br><p><img src="https://habrastorage.org/webt/de/fq/8n/defq8nu0ptzrcaib4bcbwrpfa0k.png"></p><br><p>  <strong>Geben Sie im</strong> Feld <strong>Siri Intent Query</strong> eine Phrase ein, mit der Siri bereits beginnt, als ob Sie es bereits gesagt hätten. </p><br><h2 id="itogo-2">  Insgesamt </h2><br><p>  Ich schlage vor, anzuhalten und zusammenzufassen, was wir getan haben: </p><br><ol><li>  Verknüpfungen können über <code>NSUserActivity</code> oder über <code>INIntent</code> </li><li>  Verknüpfungen müssen deklariert (deklarieren), an das System gemeldet (spenden) und verarbeitet (handhaben) werden. </li><li>  Sie können der Anwendung die Schaltfläche " <em>Zu Siri</em> hinzufügen" hinzufügen, indem Sie darauf klicken, dass der Benutzer eine Phrase für die Aktion hinzufügen und diese anschließend mit seiner Stimme aufrufen kann. </li><li>  Sie können zusätzlich zu den integrierten <code>Intents</code> Ihre eigenen <code>Intents</code> erstellen. </li><li>  Über absichtsbasierte <code>Intents</code> Sie Aktionen erstellen, die über die Siri-Oberfläche ausgeführt werden (entweder auf einem gesperrten Bildschirm oder bei der Suche), ohne die Anwendung selbst öffnen zu müssen. </li></ol><br><p>  In der Apple-Dokumentation befindet sich ein Link zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo-Projekt</a> , der zum Herunterladen und Fokussieren während der Entwicklung hilfreich ist. </p><br><p>  Ich möchte betonen, dass dieser Artikel zum Zeitpunkt des Schreibens eine API in der <code>beta</code> Phase ist.  Und ich fange oft Probleme und Fehler.  Während der Arbeit stieß ich regelmäßig auf Folgendes: </p><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sprachbefehle, die Intent in Siri öffnen, werden nicht geöffnet. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Anzeigen von Siri-Angeboten funktioniert nicht über den Sperrbildschirm. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Problem mit asynchronen Operationen in Zielen für Siri. </font></font></li></ul><br><h2 id="ssylki">  Referenzen </h2><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WWDC 2018, Sitzung 211: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einführung in Siri Shortcuts</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WWDC 2018, Sitzung 214: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bauen für Sprache mit Siri-Verknüpfungen</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apple Entwickler: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SiriKit</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apple Entwickler: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INUIHostedViewControlling</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apple </font><font style="vertical-align: inherit;">Demo </font></font><strong><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppe Chef</font></font></em></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Projekt</font></font></a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414677/">https://habr.com/ru/post/de414677/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414663/index.html">Professioneller Burnout: ein Wort an Experten</a></li>
<li><a href="../de414667/index.html">[Mini-Fan-Thema] FIFA-Meisterschaftstabelle im Terminal</a></li>
<li><a href="../de414669/index.html">Entwicklung eines neuen statischen Analysators: PVS-Studio Java</a></li>
<li><a href="../de414673/index.html">Nicht mehr Abibas: Chinas technologisches Wunder</a></li>
<li><a href="../de414675/index.html">IT Manager Karriere: Von der Kommandozeile zur Teamarbeit</a></li>
<li><a href="../de414679/index.html">Box-shadow.css</a></li>
<li><a href="../de414683/index.html">Die Geschichte der Erstellung einer mobilen Anwendung für Kinder, mit der Sie mit Ihrem Verstand Geld verdienen können. Fortsetzung</a></li>
<li><a href="../de414687/index.html">So führen Sie ein Team und sich selbst: 15 Bücher für einen Projektmanager</a></li>
<li><a href="../de414689/index.html">Offene Lektion "Webanwendungen und Microservices auf Spring Boot 2.0"</a></li>
<li><a href="../de414691/index.html">Hintergrund. YouTube Music und YouTube Premium: Was es ist und wie sie sich unterscheiden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>