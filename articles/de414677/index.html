<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¶üèæ ü§πüèª üíÉüèæ Siri-Schnellbefehle üíÖüèø üë®üèæ‚Äç‚öñÔ∏è ‚ÑπÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eine der n√ºtzlichen (meiner Meinung nach) iOS 12-Funktionen, die auf der WWDC 2018 vorgestellt wurden, sind Siri Shortcuts . 


 Verkn√ºpfung ( Verkn√ºp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Siri-Schnellbefehle</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/414677/"><p><img src="https://habrastorage.org/webt/ge/mr/un/gemrunsbwx7gf07v5htwy9lytpu.png"></p><br><p>  Eine der n√ºtzlichen (meiner Meinung nach) iOS 12-Funktionen, die auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://">WWDC 2018 vorgestellt wurden,</a> sind <strong>Siri Shortcuts</strong> . </p><br><p>  Verkn√ºpfung ( <em>Verkn√ºpfung</em> ) - ein schneller Befehl, eine kurze M√∂glichkeit, eine Aktion unter Umgehung des Standardskripts auszuf√ºhren. </p><br><p>  In Ihren Anwendungen k√∂nnen Sie Verkn√ºpfungen f√ºr einige Aktionen ausrichten.  Als Siri erf√§hrt, wie und wann der Benutzer sie implementiert, beginnt er geschickt, zur richtigen Zeit und am richtigen Ort, um ihm diese Verkn√ºpfungen anzubieten, und das Beste ist, dass der Benutzer sie mit Phrasen aufrufen kann, die er ihnen anh√§ngen wird!  Unter der Katze mehr. </p><a name="habracut"></a><br><h2 id="kak-eto-rabotaet">  Wie funktioniert es? </h2><br><p>  Wir verwenden Anwendungen, die mit bestimmten Aktionen Verkn√ºpfungen erstellen und an das System senden. </p><br><p>  Sie k√∂nnen diese Verkn√ºpfungen unter <strong>Einstellungen ‚Üí Siri und Suche</strong> anzeigen. <br><img src="https://habrastorage.org/webt/vp/z2/fd/vpz2fdo_rakpjpl-imiuvzkbyly.png"><br>  Der Screenshot oben zeigt die letzten drei Verkn√ºpfungen, die das System von verschiedenen Anwendungen abgefangen hat.  Wenn Sie auf die Schaltfl√§che "Weitere Verkn√ºpfungen" klicken, werden alle Verkn√ºpfungen angezeigt, die von jeder Anwendung an das System gesendet wurden. </p><br><p>  Mit bestimmten Einstellungen im Verkn√ºpfungserstellungscode bietet Siri dem Benutzer diese Verkn√ºpfungen auf dem gesperrten Bildschirm, im Benachrichtigungs- und Suchcenter an und konzentriert sich darauf, wie oft wir diese Aktionen zu welcher Zeit, an welchen Wochentagen und wo auf andere Faktoren anwenden. </p><br><p>  Wenn Sie beispielsweise am Freitagabend normalerweise nach Geldautomaten suchen und dann trainiert haben, bietet Ihnen Siri am Freitagabend eine Verkn√ºpfung mit dieser Aktion an. </p><br><p><img src="https://habrastorage.org/webt/ef/my/gu/efmyguxaczsetehquug_nyp7vnc.png"></p><br><p>  Wir k√∂nnen unseren Sprachbefehl zu jeder Verkn√ºpfung hinzuf√ºgen, wenn wir auf das Symbol " <strong>+</strong> " klicken. </p><br><p>  Wir sagen einen Sprachbefehl, dr√ºcken "Fertig" und jetzt k√∂nnen wir die Aktion hinter der Verkn√ºpfung mit der Stimme √ºber Siri ausf√ºhren.  <em>Es stellt sich heraus, dass der Benutzer die Funktionalit√§t Ihrer Anwendung √ºber Siri ausf√ºhren kann, ohne die Anwendung selbst zu √∂ffnen.</em>  Die Verkn√ºpfung mit der Phrase bleibt in "Meine Verkn√ºpfungen" erhalten. </p><br><h2 id="sozdanie-shortkatov">  Verkn√ºpfungen erstellen </h2><br><p> F√ºr die Entwicklung ben√∂tigen wir Xcode 10 und iOS 12. Zum Zeitpunkt des Schreibens befinden sich beide in der <strong>Beta-</strong> Phase. </p><br><p> Eine Verkn√ºpfung kann entweder √ºber <code>NSUserActivity</code> oder √ºber <code>Intent</code> . </p><br><p>  Der erste Fall: </p><br><p>  Der Benutzer klickt auf die Verkn√ºpfung, die den Befehl mit den Parametern ( <code>NSUserActivity</code> ) an unsere Anwendung <code>NSUserActivity</code> , und entscheidet, wie dieser Befehl verarbeitet werden soll (√∂ffnen Sie das Fenster des aktuellen USD-Kurses oder das <code>NSUserActivity</code> unserer Lieblingspizza).  Dies ist die gute alte Spotlight-Verkn√ºpfung, die wir alle kennen, die Siri jedoch geschickt anbietet. </p><br><p>  Zweiter Fall: </p><br><p>  Interessanter <code>Intent</code> √ºber <code>Intent</code> erstellte Verkn√ºpfungen, mit denen Sie einen Befehl sofort in der Siri-Oberfl√§che ausf√ºhren k√∂nnen, ohne Ihre Anwendung zu starten.  Zuvor waren die <code>Intent</code> f√ºr Apple schwierig: Geld √ºberweisen, Nachrichten senden und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">andere</a> .  Jetzt haben wir Entwickler die M√∂glichkeit, unsere <code>Intent</code> zu erstellen! </p><br><p>  Unabh√§ngig davon, wie die Verkn√ºpfung erstellt wurde, durchl√§uft sie drei Phasen des Lebenszyklus: </p><br><ol><li>  Ank√ºndigung ( <strong><em>Definieren</em></strong> ) </li><li>  Lieferung an das System ( <strong><em>Spenden</em></strong> ) </li><li>  Bearbeitung nach Anwendung ( <strong><em>Handle</em></strong> ) </li></ol><br><p><img src="https://habrastorage.org/webt/ie/7b/6z/ie7b6zoy5fd9mkx5ivjddp0agxc.png"></p><br><p>  Meine Forschung hat gezeigt, dass eine Anwendung nicht mehr als 20 Verkn√ºpfungen zum System liefern kann. </p><br><p>  Dar√ºber hinaus werden wir uns √ºberlegen, wie wir unserer Anwendung die M√∂glichkeit geben k√∂nnen, Verkn√ºpfungen zu erstellen und mit ihnen darin zu arbeiten. </p><br><h2 id="sozdanie-shortkatov-cherez-nsuseractivity">  Erstellen von Verkn√ºpfungen √ºber <code>NSUserActivity</code> </h2><br><p>  Lassen Sie uns den ersten einfachen Typ von Verkn√ºpfungen analysieren, die √ºber <code>NSUserActivity</code> ge√∂ffnet werden. </p><br><p>  Zum Beispiel haben wir in der mobilen Bankanwendung einen Geldautomaten-Suchbildschirm und ich suche oft nach ihnen.  Um mit einer Geldautomatenkarte auf den Bildschirm zu gelangen, muss ich die Anwendung starten, auf der Registerkarte zur Registerkarte ‚ÄûMehr‚Äú gehen, den Abschnitt ‚ÄûInfo‚Äú ausw√§hlen und dort auf die Schaltfl√§che ‚ÄûGeldautomaten‚Äú klicken. <br>  Wenn wir eine Verkn√ºpfung erstellen, die sofort zu diesem Bildschirm f√ºhrt, kann der Benutzer mit einer Ber√ºhrung darauf zugreifen, wenn Siri sie ihm beispielsweise auf einem gesperrten Bildschirm anbietet. </p><br><h3 id="obyavlyaem-shortkat-declare">  Verkn√ºpfung deklarieren </h3><br><p>  Der erste Schritt besteht darin, einen Typ wie unsere <code>NSUserActivity</code> (wir k√∂nnen sagen, dass dies die Kennung ist) in der <em>info.playlist zu deklarieren</em> : </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>NSUserActivityTypes<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">array</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span>ru.tinkoff.demo.show-cashMachine<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">array</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Angek√ºndigt. </p><br><h3 id="dostavlyaem-shortkat-v-sistemu-donate">  Liefern Sie die Verkn√ºpfung an das System (Spenden) </h3><br><p>  Nach der Deklaration k√∂nnen wir <code>NSUserActivity</code> im Code unserer Anwendung mit dem Typ erstellen, den wir oben in <strong>info.playlist festgelegt haben</strong> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> activity = NSUserActivity(activityType: <span class="hljs-string"><span class="hljs-string">"ru.tinkoff.demo.show-cashMachine"</span></span>)</code> </pre> <br><p>  Damit die Aktivit√§t in die Liste der Verkn√ºpfungen des Systems aufgenommen werden kann, muss sie auf <code>title</code> und die Eigenschaft <code>isEligibleForSearch</code> auf <code>true</code> .  Andere Eigenschaften sind f√ºr das Hinzuf√ºgen zu Verkn√ºpfungen nicht erforderlich, aber ihre Anwesenheit macht die Verkn√ºpfung lesbarer und benutzerfreundlicher. </p><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//   (     ,   ) activity.title = " " if #available(iOS 12.0, *) { // ,             activity.suggestedInvocationPhrase = "  " //           activity.isEligibleForPrediction = true // (     ,   ) activity.isEligibleForSearch = true } //       let attributes = CSSearchableItemAttributeSet(itemContentType: "NSUserActivity.searchableItemContentType") ///    if let image = UIImage(named: "siriAtmIcon") { attributes.thumbnailData = UIImagePNGRepresentation(image) } ///   attributes.contentDescription = "     " ///     activity.contentAttributeSet = attributes</span></span></code> </pre> <br><p>  Feuer!  <code>NSUserActivity</code> ist, um es an das System zu liefern, der letzte Schritt. </p><br><p>  <code>ViewConroller</code> verf√ºgt √ºber eine <code>userActivity</code> Eigenschaft, der wir die oben erstellte <code>activity</code> zuweisen m√ºssen: </p><br><pre> <code class="javascript hljs">self.userActivity = activity</code> </pre> <br><p>  Sobald diese Zeile ausgef√ºhrt wird, wird aus dieser Aktivit√§t eine Verkn√ºpfung erstellt.  Es wird an das System geliefert und in den Siri-Einstellungen ( <strong>Einstellungen ‚Üí Siri und Suche</strong> ) angezeigt.  Dann kann Siri es dem Benutzer anbieten und der Benutzer kann ihm seinen Sprachbefehl zuweisen. </p><br><p>  <em><strong>Hinweis</strong> : In der Apple-Dokumentation hei√üt es, dass es nicht ausreicht, dem View Controller Aktivit√§t <code>becomeCurrent()</code> , sondern die Methode <code>becomeCurrent()</code> f√ºr die <code>becomeCurrent()</code> .</em>  <em>Diese Aktion hat jedoch keine Aktivit√§t auf mein System √ºbertragen, und die Verkn√ºpfung wurde nicht in der Liste angezeigt</em> </p><br><blockquote>  Rufen Sie als <code>becomeCurrent()</code> Methode <code>becomeCurrent()</code> f√ºr das Benutzeraktivit√§tsobjekt auf, um es als aktuell zu markieren, wodurch die Aktivit√§t an Siri <code>becomeCurrent()</code> .  Alternativ k√∂nnen Sie das Objekt an ein UIViewController- oder UIResponder-Objekt anh√§ngen, das die Aktivit√§t auch als aktuell markiert. </blockquote><p>  Um zu √ºberpr√ºfen, ob alles funktioniert hat, √∂ffnen Sie <strong>Einstellungen&gt; Siri und suchen Sie</strong> - die Verkn√ºpfung, die auf unserer Aktivit√§t basiert, sollte in der Liste enthalten sein. </p><br><h3 id="obrabotka-shortkata-prilozheniem-handle">  Verarbeiten von Verkn√ºpfungen nach Anwendung (Handle) </h3><br><p>  Wenn ein Benutzer vom Benachrichtigungscenter aus durch die Verkn√ºpfung navigiert oder diese per Spracheingabe aktiviert, wird die Anwendung gestartet, und wir m√ºssen diese Verkn√ºpfung verarbeiten. </p><br><p>  <code>activity</code> uns in <code>AppDelegate</code> 'eine Methode geworfen: </p><br><pre> <code class="javascript hljs">func application(_ application: UIApplication, <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> userActivity: NSUserActivity, <span class="hljs-attr"><span class="hljs-attr">restorationHandler</span></span>: @escaping ([UIUserActivityRestoring]?) -&gt; Void) -&gt; Bool { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> userActivity.activityType == <span class="hljs-string"><span class="hljs-string">"ru.tinkoff.demo.show-cashMachine"</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   ,     handleShowCashMachineActivity() return true } return false }</span></span></code> </pre> <br><h3 id="itogo">  Insgesamt </h3><br><p>  Eine NSUserActivity- <code>NSUserActivity</code> wird wie folgt erstellt: </p><br><ol><li>  Deklarieren Sie den Typ (Bezeichner) von <code>NSUserActivity</code> in <code>NSUserActivity</code> . </li><li>  Wir erstellen <code>NSUserActivity</code> im Code und konfigurieren </li><li>  <code>viewController'</code> . </li></ol><br><h2 id="sozdanie-golosovyh-komand-iz-prilozheniya">  Erstellen von Sprachbefehlen aus einer Anwendung </h2><br><p>  Wenn der Benutzer also <strong>Einstellungen&gt; Siri</strong> √∂ffnet <strong>und sucht</strong> , wird eine Liste seiner Verkn√ºpfungen angezeigt, die von verschiedenen Anwendungen erstellt wurden, einschlie√ülich unserer.  Durch Klicken auf das ‚Äû <strong>+</strong> ‚Äú kann der Benutzer einen beliebigen Sprachbefehl erstellen und ihn der ausgew√§hlten Verkn√ºpfung zuordnen.  Jedes Mal, wenn die Eingabe der Einstellungen f√ºr den Benutzer unpraktisch ist, erkennen viele diese M√∂glichkeit nicht einmal. </p><br><p>  Es ist cool, dass Sie einer bestimmten Aktion direkt in der Anwendung einen Sprachbefehl hinzuf√ºgen k√∂nnen. </p><br><p>  Angenommen, ein Benutzer f√ºhrt eine Aktion aus, die an das System √ºbermittelt wird und die er speichern m√∂chte.  Wir k√∂nnen die Schaltfl√§che " <em>Aktion zu Siri hinzuf√ºgen</em> " (Sie k√∂nnen die Schaltfl√§che nach Belieben benennen und zeichnen) auf dem Bildschirm unserer Anwendung <em>hinzuf√ºgen.</em> Durch Klicken darauf kann der Benutzer diese Aktion einem Sprachbefehl innerhalb der Anwendung zuordnen, ohne die Einstellungen aufzurufen. </p><br><p>  Durch Klicken auf die Schaltfl√§che sollten Sie den Bildschirm zum Hinzuf√ºgen eines Sprachbefehls zu einer Verkn√ºpfung in Siri <code>INUIAddVoiceShortcutViewController</code> oder den Bildschirm zum Bearbeiten eines Sprachbefehls <code>INUIEditVoiceShortcutViewController</code> , falls bereits einer erstellt wurde, modal √∂ffnen.  Die nicht umgesetzte <code>action</code> solchen Knopfes ist ungef√§hr wie folgt: </p><br><pre> <code class="hljs julia"> <span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> func addToSiriAction() { // <span class="hljs-number"><span class="hljs-number">1.</span></span>   ,       INVoiceShortcutCenter.shared.getAllVoiceShortcuts { (shortcuts, error) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> guard error == nil, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> shortcuts = shortcuts <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { // TODO: Handle error <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } // <span class="hljs-number"><span class="hljs-number">2.</span></span>     ,      <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> donatedShortcut: INVoiceShortcut? = shortcuts.first(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: { (shorcut) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> shorcut.__shortcut.userActivity?.activityType == <span class="hljs-string"><span class="hljs-string">"com.ba"</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> shortcut = donatedShortcut { // <span class="hljs-number"><span class="hljs-number">3.</span></span>     -     . //         <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> editVoiceShortcutViewController = INUIEditVoiceShortcutViewController(voiceShortcut: shortcut) editVoiceShortcutViewController.delegate = self self.present(editVoiceShortcutViewController, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, completion: nil) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { // <span class="hljs-number"><span class="hljs-number">4.</span></span>         <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> shortcut = INShortcut(userActivity: self.userActivity!) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> addVoiceShortcutViewController = INUIAddVoiceShortcutViewController(shortcut: shortcut) addVoiceShortcutViewController.delegate = self } } }</code> </pre> <br><p>  Die Bildschirme zum Hinzuf√ºgen und Bearbeiten eines Sprachbefehls f√ºr die Siri-Verkn√ºpfung sehen also folgenderma√üen aus: </p><br><p><img src="https://habrastorage.org/webt/ez/lk/ai/ezlkaihh3q9gvj4syqkizbwqy4c.png"></p><br><p>  Wir m√ºssen auch die Delegate-Methoden dieser viewController implementieren, in denen sie <code>dismiss(animated: true, completion: nil)</code> ausblenden und gegebenenfalls den aktuellen Bildschirm aktualisieren m√ºssen.  Wenn beispielsweise fr√ºher auf dem Bildschirm die Schaltfl√§che "Sprachbefehl hinzuf√ºgen" angezeigt wurde, sollte diese Schaltfl√§che nach dem Hinzuf√ºgen eines Sprachbefehls entweder verschwinden oder in "Sprachbefehl bearbeiten" ge√§ndert werden. </p><br><h2 id="shortkaty-sozdannye-pri-pomoschi-intent">  Absichtsverkn√ºpfungen </h2><br><p>  Bisher haben wir nur √ºber Verkn√ºpfungen gesprochen, die eine Anwendung √∂ffnen und dort <code>NSUserActivity</code> Daten an <code>NSUserActivity</code> . </p><br><p>  Zur√ºck zu den √ºber <code>Intent</code> erstellten Verkn√ºpfungen, mit denen Sie einige Aktionen ausf√ºhren k√∂nnen, ohne die Anwendung zu √∂ffnen.  Hier beginnt der Spa√ü. </p><br><p>  Stellen Sie sich vor, ein Benutzer bestellt seine Lieblingspizza.  Er wird es viele Male bestellen, wann immer er will, und er hat der Abk√ºrzung dieser Pizza sogar einen Sprachbefehl hinzugef√ºgt - und das vereinfacht sein Leben.  Aber wir k√∂nnen mehr f√ºr ihn tun - wir k√∂nnen sicherstellen, dass das System den Siri-Sprachbefehl nicht in die Anwendung wirft, sondern Bestellinformationen anzeigt und Pizza sofort in der Siri-Oberfl√§che bestellt!  Dies ist nur dann der Fall, wenn der Benutzer die Anwendung selbst nicht √∂ffnen muss, um eine Aktion auszuf√ºhren. </p><br><p>  Gehen Sie zun√§chst zu den Projekteinstellungen, w√§hlen Sie das Hauptziel und die Registerkarte Funktionen aus und aktivieren Sie den Zugriff auf Siri. </p><br><p>  Unsere Anwendung kann mit Siri interagieren, dies geschieht jedoch nicht im Hauptcode der Anwendung, sondern in einer separaten <strong>Zielerweiterung Intents Extensions</strong> </p><br><p>  Zu Beginn muss dieses Ziel erstellt werden: <strong>Datei ‚Üí Neu ‚Üí Ziel</strong> , <strong>Intents Extensions</strong> ausw√§hlen.  Xcode bietet an, eine weitere Zielerweiterung f√ºr das Fenster zu erstellen, in dem Ihre Aktionen in Siri angezeigt werden. Wenn dies erforderlich ist, stimmen wir zu. </p><br><p><img src="https://habrastorage.org/webt/ia/o_/pp/iao_pphchyfpr33hj6jluyy-ozc.jpeg"></p><br><h3 id="obyavlyaem-shortkat-declare-1">  Verkn√ºpfung deklarieren </h3><br><p>  Die Hauptinnovation von SiriKit in iOS 12 ist die M√∂glichkeit, Ihre <code>Inetnts</code> zu erstellen, wie sie fr√ºher waren. </p><br><p><img src="https://habrastorage.org/webt/5a/66/6m/5a666mqkcm0li-cujpl7yexzrgm.png"></p><br><p>  Erstellen Sie dazu eine neue Datei: <strong>Datei ‚Üí Neu ‚Üí Datei</strong> , und w√§hlen <strong>Sie</strong> im Abschnitt <strong>Ressource die</strong> <strong>Option SiriKit Intent Definition File</strong> aus. </p><br><p><img src="https://habrastorage.org/webt/qz/8l/lx/qz8llxznc1o05palhxxxcskrcbq.png"></p><br><p>  Als Ergebnis wird eine Datei mit der Erweiterung <em>.intentdefinition angezeigt</em> , in der Sie Ihre eigenen <em>Absichten</em> erstellen k√∂nnen.  Wir √∂ffnen die Datei und wo unten " <strong>No Intents</strong> " steht, befindet sich ein " <strong>+</strong> " - Symbol - klicken Sie darauf.  " <strong>Neue Absicht</strong> ".  In der Liste wird eine Absicht angezeigt, zu der Sie Parameter hinzuf√ºgen k√∂nnen.  Bei einer Pizza-Bestellung k√∂nnen Sie die Anzahl der Pizzen und die Art der zu bestellenden Pizza als Parameter hinzuf√ºgen.  F√ºr die Menge w√§hlen wir den Typ <code>Integer</code> und f√ºr den <code>INObject</code> den Typ <code>Custom</code> , der im Code durch die Klasse <code>INObject</code> . </p><br><p>  Nun ein paar Zeilen Frustration: </p><br><p>  <strong>Der Benutzer kann keine unterschiedlichen Parameter an denselben gespeicherten Sprachbefehl √ºbertragen.</strong>  <strong>Ach!</strong> </p><br><p><img src="https://habrastorage.org/webt/kn/z4/y-/knz4y-oo1kns8ehvzoojslxqycq.jpeg"></p><br><p>  Was sind die Parameter f√ºr: </p><br><p>  Angenommen, Sie erstellen eine Entit√§t "Rate <code>%currency</code> ", wobei <code>currency</code> ein Entit√§tsparameter ist.  Dies bedeutet nicht, dass der Benutzer die S√§tze "Den Wechselkurs des Dollars anzeigen", "Den Bitcoin-Wechselkurs anzeigen" usw. sagen kann.  Standardm√§√üig funktioniert dies nicht so.  Dies bedeutet jedoch, dass, wenn der Benutzer den Dollar-Wechselkurs betrachtete, die Verkn√ºpfung "USD-Kurs anzeigen" erstellt wurde, dann, wenn er den Bitcoin-Wechselkurs betrachtete, die Verkn√ºpfung "BTC-Kurs anzeigen" erstellt wurde  Mit anderen Worten, er kann mehrere Shorkatas haben, die auf derselben Absicht basieren, aber unterschiedliche Parameter haben.  Bei jeder der Verkn√ºpfungen kann der Benutzer seinen Sprachbefehl erfragen. </p><br><p>  <em>Wenn Sie</em> eine Absicht in der <em>.intentdefinition-</em> Datei erstellen, generiert <em>Xcode</em> automatisch eine Klasse f√ºr diese Absicht (Hinweis: Sie wird nicht in den Projektdateien angezeigt, steht jedoch zur Verwendung zur Verf√ºgung). Diese automatisch generierte Datei befindet sich nur in den Zielen, die die <em>.intentdefinition-</em> Datei besitzen. </p><br><p>  Nachdem wir die Absicht in der .intentdefinition-Datei erstellt haben <em>, k√∂nnen</em> wir unsere Absichten im Code erstellen. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intent = <span class="hljs-type"><span class="hljs-type">OrderPizzaIntent</span></span>()</code> </pre> <br><h3 id="dostavlyaem-shortkat-v-sistemu-donate-1">  Liefern Sie die Verkn√ºpfung an das System (Spenden) </h3><br><p>  Damit diese Entit√§t in die Liste der Verkn√ºpfungen aufgenommen wird, m√ºssen Sie sie einbetten.  Zu diesem Zweck wird ein <code>INInteraction</code> Objekt mit einer Instanz Ihrer Absicht erstellt und die .donate-Methode wird f√ºr diese <code>.donate</code> aufgerufen </p><br><pre> <code class="hljs lua">let intent = OrderPizzaIntentf() // ...   let interaction = INInteraction(intent: intent, response: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) interaction.donate { (<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> // ...   /  }</code> </pre> <br><p>  Nach dem Ausf√ºhren dieses Codes wird die absichtsbasierte Verkn√ºpfung an das System gesendet und in den Siri-Einstellungen angezeigt. </p><br><h3 id="obrabatyvaem-shortkat-prilozheniem-handle">  Wir bearbeiten die Verkn√ºpfungsanwendung (Handle) </h3><br><p>  Der n√§chste Schritt besteht darin, die Absicht zu verarbeiten, wenn der Benutzer im Sirjest des Siri darauf klickt oder sie mit einem Sprachbefehl anruft. </p><br><p>  Wir haben bereits eine Zielerweiterung f√ºr Siri erstellt und sie verf√ºgt √ºber eine vorab erstellte IntentHandler-Klasse, die eine einzige Methode hat - `` handle (for intent) `` </p><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntentHandler</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">INExtension</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> intent: INIntent)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Any</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> intent <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-type"><span class="hljs-type">OrderPizzaIntent</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">"Unhandled intent type: \(intent)"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">OrderPizzaIntentHandler</span></span>() } }</code> </pre> <br><blockquote>  Hinweis: Wenn der Compiler die Klasse Ihrer Absicht nicht sieht, haben Sie die <em>Zielerweiterungsdatei .intentdefinition</em> f√ºr Siri nicht hinzugef√ºgt. </blockquote><p>  Bei dieser Methode bestimmen wir den Typ der eingehenden Absicht und erstellen f√ºr jeden Typ ein Handlerobjekt, das diese Absicht verarbeitet.  Erstellen Sie einen Handler f√ºr unser <code>OrderPizzaIntent</code> und implementieren Sie das <code>OrderPizzaIntentHandling</code> Protokoll darin, das bereits automatisch generiert wird, nachdem Sie Ihre Absicht in <em>.intentdefinition erstellt haben</em> . </p><br><p>  Das Protokoll enth√§lt zwei Methoden zur <code>confirm</code> und <code>handle</code> .  Zun√§chst wird die <code>confirm</code> aufgerufen, bei der alle Daten √ºberpr√ºft und die Verf√ºgbarkeit der Aktion √ºberpr√ºft werden.  Dann funktioniert der <code>handle</code> in einer kurzen Aktion, die ausgef√ºhrt werden muss. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderPizzaIntentHandler</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderPizzaIntentHandling</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">confirm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(intent: OrderPizzaIntent, completion: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(OrderPizzaIntentResponse)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//      // ... completion(OrderPizzaIntentResponse(code: OrderPizzaIntentResponseCode.ready, userActivity: nil)) } public func handle(intent: OrderPizzaIntent, completion: @escaping (OrderPizzaIntentResponse) -&gt; Void) { //     // ... completion(OrderPizzaIntentResponse(code: OrderPizzaIntentResponseCode.success, userActivity: nil)) } }</span></span></code> </pre> <br><p>  Beide Methoden m√ºssen definitiv die <code>completion</code> mit der Antwort <code>OrderPizzaIntentResponse</code> (sie wird ebenfalls automatisch generiert), andernfalls wartet Siri nur lange und gibt dann einen Fehler aus. </p><br><h3 id="bolee-podrobnye-otvety-ot-siri">  Detailliertere Antworten von Siri </h3><br><p>  Es gibt einen standardm√§√üigen, automatisch generierten Satz von Antwortcodes - <code>enum OrderPizzaIntentResponseCode</code> , aber diese reichen m√∂glicherweise nicht f√ºr eine <code>enum OrderPizzaIntentResponseCode</code> Oberfl√§che aus.  In der <code>confirm</code> beispielsweise verschiedene Fehler auftreten - die Pizza ist aufgebraucht, die Pizzeria funktioniert derzeit nicht usw.  und der Benutzer sollte anstelle der Standardnachricht "Anwendungsfehler" mehr √ºber diese Fakten erfahren.  Denken Sie daran, dass wir <code>Intent</code> in der <em>.intentdefinition-</em> Datei erstellt haben?  Zusammen mit der Absicht selbst wurde die <code>Response</code> in der Sie Ihre eigenen Optionen f√ºr Fehler und erfolgreiche Antworten hinzuf√ºgen und diese mit den folgenden Parametern konfigurieren k√∂nnen: </p><br><p><img src="https://habrastorage.org/webt/xz/zg/fa/xzzgfawljagfnruxp_zjjdeug2m.png"></p><br><p>  Jetzt k√∂nnen wir dem Benutzer informativere Fehler und Antworten mitteilen: </p><br><pre> <code class="hljs lua">public func confirm(intent: OrderPizzaIntent, completion: @escaping (OrderPizzaIntentResponse) -&gt; Void) { guard let pizzaKindId = intent.kind?.identifier <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //         -     completion(OrderPizzaIntentResponse(code: .failure, userActivity: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pizzeriaManager.isPizzeriaClosed == <span class="hljs-literal"><span class="hljs-literal">true</span></span> { ///     -     completion(OrderPizzaIntentResponse(code: .failurePizzeriaClosed, userActivity: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pizzeriaManager.menu.isPizzaUnavailable(identifier: pizzaKindId) { ///      -     completion(OrderPizzaIntentResponse(code: .failurePizzaUnavailable(kind: intent.kind), userActivity: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } //     -    completion(OrderPizzaIntentResponse(code: .ready, userActivity: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) }</code> </pre> <br><h3 id="otrisovka-intenta">  <code>Intent</code> Rendern </h3><br><p>  Wenn wir eine <strong>Zielerweiterung</strong> f√ºr die Absichtserweiterungs- <strong>Benutzeroberfl√§che erstellt haben</strong> , k√∂nnen wir in Siri eine benutzerdefinierte Ansicht f√ºr die von uns ben√∂tigten Absichten zeichnen.  Wir haben <code>MainInterface.storyboard</code> und <code>IntentViewController</code> in denen wir ihr Design skizzieren k√∂nnen.  Dieser Ansichtscontroller implementiert das INUIHostedViewControlling-Protokoll und die Ansicht wird in der <code>configureView</code> Methode <code>configureView</code> </p><br><pre> <code class="hljs sql">// <span class="hljs-keyword"><span class="hljs-keyword">Prepare</span></span> your <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> controller <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the interaction <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> handle. func configureView(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">parameters</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;INParameter&gt;, <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> interaction: INInteraction, interactiveBehavior: INUIInteractiveBehavior, <span class="hljs-keyword"><span class="hljs-keyword">context</span></span>: INUIHostedViewContext, completion: @escaping (<span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;INParameter&gt;, CGSize) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Void</span></span>) { // <span class="hljs-keyword"><span class="hljs-keyword">Do</span></span> configuration here, <span class="hljs-keyword"><span class="hljs-keyword">including</span></span> preparing views <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> calculating a desired <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> presentation. completion(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">parameters</span></span>, self.desiredSize) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> desiredSize: CGSize { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.extensionContext!.hostedViewMaximumAllowedSize }</code> </pre> <br><p>  Damit diese Methode aufgerufen werden kann, m√ºssen Sie den Namen unserer Absicht zum Array <code>NSExtension</code> -&gt; <code>NSExtensionAttributes</code> -&gt; <code>IntentsSupported</code> , das sich auf die Benutzeroberfl√§che des Erweiterungsziels Intents bezieht </p><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>NSExtension<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dict</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>NSExtensionAttributes<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dict</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>IntentsSupported<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">array</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span>OrderPizzaIntent<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">array</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dict</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Abh√§ngig vom Design Ihrer Ansicht in Siri und der <code>interaction.intent</code> , die in die Methode eingeflossen ist, k√∂nnen Sie diese Ansicht nach Ihren W√ºnschen zeichnen.  Unten finden Sie Screenshots, wie unsere Absicht in Siri aussieht, auf der Suche und auf einem gesperrten Bildschirm. </p><br><p><img src="https://habrastorage.org/webt/wr/gh/sa/wrghsafmpp3qz3fiih1afdkrrou.png"></p><br><p>  Es ist zu beachten, dass der Benutzer nicht mit Schaltfl√§chen, Bildlauf und anderen Steuerelementen in Ihrer Ansicht <code>interactiveBehavior = .none</code> , da die Methode mit dem ParameterinteractiveBehavior <code>interactiveBehavior = .none</code> wird. Dies f√ºhrt sicherlich zu einer Reihe von Einschr√§nkungen. </p><br><h3 id="itogo-1">  Insgesamt </h3><br><p>  Eine <code>Intent</code> Verkn√ºpfung kann in der Siri-Oberfl√§che oder im Benachrichtigungscenter gerendert werden und eine Aktion ausf√ºhren, ohne die Anwendung zu √∂ffnen.  Um es zu erstellen, ben√∂tigen Sie: </p><br><ol><li>  Aktivieren Sie die Funktionen zur Verwendung von Siri </li><li>  Erstellen Sie <strong>Intents Extensions</strong> und <strong>Intents Extensions UI</strong> </li><li>  Erstellen Sie eine <strong>SiriKit Intent Definition-Datei</strong> </li><li>  Wir erstellen unsere <code>Intent</code> in dieser Datei und weisen ihr Parameter zu. </li><li>  Erstellen Sie einen <code>IntentHandler</code> in dem wir die <code>hanlde</code> und <code>hanlde</code> implementieren </li></ol><br><h2 id="rekomendacii">  Empfehlungen </h2><br><h3 id="obschiy-kod-v-targete-rasshirenii-siri-i-v-osnovnom-prilozhenii">  Generischer Code im Siri-Erweiterungsziel und in der Hauptanwendung </h3><br><p>  Wenn Sie Code haben, der sowohl im Ziel f√ºr Siri als auch im Ziel des Hauptprojekts verwendet wird, gibt es zwei M√∂glichkeiten, um dieses Problem zu l√∂sen: </p><br><ol><li>  Markieren Sie gemeinsame Klassen und f√ºgen Sie sie beiden Zielen hinzu.  ( <strong>Ansicht ‚Üí Dienstprogramme ‚Üí Dateiinspektor anzeigen</strong> , f√ºgen Sie im Abschnitt Zielmitgliedschaft H√§kchen zu Zielen hinzu, die Zugriff auf die ausgew√§hlte Datei ben√∂tigen.) </li><li>  Erstellen Sie ein oder mehrere Ziel-Frameworks und √ºbernehmen Sie dort den allgemeinen Code. </li></ol><br><p>  Die letztere Methode ist vorzuziehen, da Sie diese Frameworks dann in anderen Erweiterungen und Projekten verwenden k√∂nnen.  Es ist auch erw√§hnenswert, dass es f√ºr diese Frameworks ratsam ist, das Flag " <code>Allow app extension API only</code> zu setzen. Bei der Entwicklung des Frameworks schw√∂rt der Compiler, wenn Sie versuchen, eine API zu verwenden, die f√ºr die Entwicklung von Erweiterungen illegal ist (z. B. <code>UIApplication</code> ). </p><br><p>  Freigegebene Ressourcen k√∂nnen √ºber <strong>App-Gruppen</strong> zwischen Zielen <strong>durchsucht werden</strong> </p><br><h3 id="otladka">  Debuggen </h3><br><p>  Das Testen von Verkn√ºpfungen hilft dabei: </p><br><ol><li>  Telefoneinstellungen <strong>Einstellungen ‚Üí Entwickler</strong> : <strong>Letzte Verkn√ºpfungen</strong> <strong>anzeigen</strong> und <strong>Spenden auf</strong> <strong>Sperrbildschirmschaltern</strong> <strong>anzeigen</strong> : </li></ol><br><p><img src="https://habrastorage.org/webt/lv/0s/v8/lv0sv8rxfrdw7tgeqaql7p9yyhy.png"></p><br><ol><li>  Um Intens zu testen, k√∂nnen Sie die Zielerweiterung sofort starten, indem Sie in Xcode die Phrase angeben, mit der Siri √∂ffnet.  W√§hlen Sie dazu das Schema f√ºr die Zielerweiterung Siri aus </li></ol><br><p><img src="https://habrastorage.org/webt/lc/lf/vj/lclfvj0e18-jx73zrxkf0tasnyq.png"></p><br><p>  Klicken Sie auf dieses Ziel, klicken Sie auf <strong>Schema bearbeiten ...</strong> </p><br><p><img src="https://habrastorage.org/webt/de/fq/8n/defq8nu0ptzrcaib4bcbwrpfa0k.png"></p><br><p>  <strong>Geben Sie im</strong> Feld <strong>Siri Intent Query</strong> eine Phrase ein, mit der Siri bereits beginnt, als ob Sie es bereits gesagt h√§tten. </p><br><h2 id="itogo-2">  Insgesamt </h2><br><p>  Ich schlage vor, anzuhalten und zusammenzufassen, was wir getan haben: </p><br><ol><li>  Verkn√ºpfungen k√∂nnen √ºber <code>NSUserActivity</code> oder √ºber <code>INIntent</code> </li><li>  Verkn√ºpfungen m√ºssen deklariert (deklarieren), an das System gemeldet (spenden) und verarbeitet (handhaben) werden. </li><li>  Sie k√∂nnen der Anwendung die Schaltfl√§che " <em>Zu Siri</em> hinzuf√ºgen" hinzuf√ºgen, indem Sie darauf klicken, dass der Benutzer eine Phrase f√ºr die Aktion hinzuf√ºgen und diese anschlie√üend mit seiner Stimme aufrufen kann. </li><li>  Sie k√∂nnen zus√§tzlich zu den integrierten <code>Intents</code> Ihre eigenen <code>Intents</code> erstellen. </li><li>  √úber absichtsbasierte <code>Intents</code> Sie Aktionen erstellen, die √ºber die Siri-Oberfl√§che ausgef√ºhrt werden (entweder auf einem gesperrten Bildschirm oder bei der Suche), ohne die Anwendung selbst √∂ffnen zu m√ºssen. </li></ol><br><p>  In der Apple-Dokumentation befindet sich ein Link zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo-Projekt</a> , der zum Herunterladen und Fokussieren w√§hrend der Entwicklung hilfreich ist. </p><br><p>  Ich m√∂chte betonen, dass dieser Artikel zum Zeitpunkt des Schreibens eine API in der <code>beta</code> Phase ist.  Und ich fange oft Probleme und Fehler.  W√§hrend der Arbeit stie√ü ich regelm√§√üig auf Folgendes: </p><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sprachbefehle, die Intent in Siri √∂ffnen, werden nicht ge√∂ffnet. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Anzeigen von Siri-Angeboten funktioniert nicht √ºber den Sperrbildschirm. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Problem mit asynchronen Operationen in Zielen f√ºr Siri. </font></font></li></ul><br><h2 id="ssylki">  Referenzen </h2><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WWDC 2018, Sitzung 211: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einf√ºhrung in Siri Shortcuts</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WWDC 2018, Sitzung 214: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bauen f√ºr Sprache mit Siri-Verkn√ºpfungen</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apple Entwickler: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SiriKit</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apple Entwickler: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INUIHostedViewControlling</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apple </font><font style="vertical-align: inherit;">Demo </font></font><strong><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppe Chef</font></font></em></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Projekt</font></font></a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414677/">https://habr.com/ru/post/de414677/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414663/index.html">Professioneller Burnout: ein Wort an Experten</a></li>
<li><a href="../de414667/index.html">[Mini-Fan-Thema] FIFA-Meisterschaftstabelle im Terminal</a></li>
<li><a href="../de414669/index.html">Entwicklung eines neuen statischen Analysators: PVS-Studio Java</a></li>
<li><a href="../de414673/index.html">Nicht mehr Abibas: Chinas technologisches Wunder</a></li>
<li><a href="../de414675/index.html">IT Manager Karriere: Von der Kommandozeile zur Teamarbeit</a></li>
<li><a href="../de414679/index.html">Box-shadow.css</a></li>
<li><a href="../de414683/index.html">Die Geschichte der Erstellung einer mobilen Anwendung f√ºr Kinder, mit der Sie mit Ihrem Verstand Geld verdienen k√∂nnen. Fortsetzung</a></li>
<li><a href="../de414687/index.html">So f√ºhren Sie ein Team und sich selbst: 15 B√ºcher f√ºr einen Projektmanager</a></li>
<li><a href="../de414689/index.html">Offene Lektion "Webanwendungen und Microservices auf Spring Boot 2.0"</a></li>
<li><a href="../de414691/index.html">Hintergrund. YouTube Music und YouTube Premium: Was es ist und wie sie sich unterscheiden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>