<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äç‚úàÔ∏è üë©üèæ‚Äç‚úàÔ∏è üôãüèæ Un peu sur la programmation de ESP8266 en C sous FreeRTOS üíÖüèø üë®üèº‚Äçüöí üë®üèΩ‚Äçüéì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il devrait y avoir une PAC, mais il n'y avait pas assez de budget pour cela. 

 Motiv√© par la r√©ponse de Tarson √† mon commentaire sur Programmation et...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Un peu sur la programmation de ESP8266 en C sous FreeRTOS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/406813/"> <i><b>Il devrait y avoir une PAC, mais il n'y avait pas assez de budget pour cela.</b></i> <br><br>  Motiv√© par la r√©ponse de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Tarson</a> √† mon commentaire sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Programmation et √©change de donn√©es avec ARDUINO via WIFI via ESP8266</a> , j'ai d√©cid√© d'√©crire sur les bases de la programmation ESP8266 en C sous FreeRTOS.  D√©tails sous la coupe. <br><a name="habracut"></a><br>  <b>√âtape 0 - appareil</b> <br><br>  Vous devez d'abord obtenir un appareil avec ESP8266, il est souhaitable que USB vers UART y soit s√©par√©, de sorte que vous n'ayez pas √† arr√™ter le programmeur.  Je passe mes exp√©riences inhumaines √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NodeMCU</a> . <br><br>  <b>Donc, √©tape 1 - collectez la cha√Æne d'outils</b> <br><br>  Vous devez d'abord obtenir un ordinateur sur lequel la distribution Linux est install√©e (j'ai OpenSUSE Leap).  Nous allons dans le github au lien <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tyts</a> , lisons les instructions d'assemblage, installons les d√©pendances n√©cessaires, clonons le r√©f√©rentiel et collectons.  J'ai clon√© dans / opt / ESP et avant d'assembler les r√®gles Makefile, en d√©finissant les variables: <br><br><pre><code class="bash hljs">STANDALONE = n VENDOR_SDK = 2.1.0</code> </pre> <br>  Ensuite, vous pouvez ajouter le chemin d'acc√®s aux binaires de la cha√Æne d'outils dans PATH dans ~ / .bashrc: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> PATH=/opt/ESP/esp-open-sdk/xtensa-lx106-elf/bin:<span class="hljs-variable"><span class="hljs-variable">$PATH</span></span></code> </pre><br>  <b>√âtape 2 - Obtenez le SDK</b> <br><br>  Nous allons dans github ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tynk</a> ), lisons les instructions, clonons (par exemple dans / opt / ESP).  Ensuite, nous d√©finissons la variable d'environnement ESP8266_SDK_PATH de notre mani√®re pr√©f√©r√©e (par exemple, via ~ / .bashrc): <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> ESP8266_SDK_PATH=/opt/ESP/esp-open-rtos</code> </pre><br>  <b>√âtape 3 - cr√©er un projet</b> <br><br>  Nous allons dans le r√©pertoire des exemples dans le r√©pertoire avec le SDK et copions tout exemple que vous aimez.  Nous importons / ouvrons le projet dans notre environnement de d√©veloppement pr√©f√©r√©, les masochistes peuvent utiliser un √©diteur de texte.  Je pr√©f√®re NetBeans - il a un bon support pour les projets C / C ++, y compris ceux bas√©s sur Makefile.  Le projet est assembl√© √† l'aide de make, il est assembl√© √† l'aide de make flash.  Dans le fichier local.mk, vous pouvez configurer les param√®tres de flashage de votre appareil (taille et mode d'acc√®s √† la m√©moire flash par exemple). <br><br>  <b>√âtape 4 - Programmation</b> <br><br>  Nous analysons les exigences, le domaine, compilons les sp√©cifications techniques conform√©ment √† GOST 34.602-89, apr√®s quoi vous pouvez commencer √† √©crire le code :) Je ne clignote pas les LED, car je ne les ai pas, donc en tant que HelloWorld, je vais lire les donn√©es du capteur AM2302 (c'est DHT22) et les envoyer via le protocole MQTT au serveur. <br><br>  Pour utiliser des modules suppl√©mentaires, par exemple MQTT ou DHT, ils doivent √™tre ajout√©s au Makefile: <br><br><pre> <code class="hljs ruby">PROGRAM=fffmeteo EXTRA_COMPONENTS = extras/paho_mqtt_c extras/dht <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> $(ESP8266_SDK_PATH)/common.mk</code> </pre><br><div class="spoiler">  <b class="spoiler_title">main.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdint.h&gt; #include &lt;limits.h&gt; #include &lt;FreeRTOS.h&gt; #include &lt;task.h&gt; #include &lt;queue.h&gt; #include &lt;semphr.h&gt; #define DEBUG #ifdef DEBUG #define debug(args...) printf("--- "); printf(args) #define SNTP_DEBUG_ENABLED true #else #define debug(args...) #define SNTP_DEBUG_ENABLED false #endif #define WIFI_SSID "kosmonaFFFt" #define WIFI_PASS "mysupermegapassword" #define MQTT_HOST "m11.cloudmqtt.com" #define MQTT_PORT 16464 #define MQTT_USER "kosmonaFFFt" #define MQTT_PASS "mysupermegapassword" #define MQTT_TOPIC "/meteo" #define NTP_SERVER "pool.ntp.org" #define UART0_BAUD 9600 #define STACK_SIZE 512 #define INIT_TASK_PRIORITY (configTIMER_TASK_PRIORITY + 1) #define MEASUREMENT_TASK_PRIORITY (INIT_TASK_PRIORITY + 1) #define SENDING_DATA_TASK_PRIORITY (MEASUREMENT_TASK_PRIORITY + 1) #define MEASUREMENTS_PERIOD_S 59 #define MAX_MEASUREMENTS_COUNT 16 #define SEND_PERIOD_S 120 #define RUN_SNTP_SYNC_PERIOD 5 #define MS(x) (x / portTICK_PERIOD_MS) #define AM2302_PIN 5 #ifdef __cplusplus extern "C" { #endif #ifdef __cplusplus } #endif #endif /* MAIN_H */</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">main.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sntp.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;esp/uart.h&gt; #include &lt;espressif/esp_common.h&gt; #include &lt;paho_mqtt_c/MQTTESP8266.h&gt; #include &lt;paho_mqtt_c/MQTTClient.h&gt; #include &lt;dht/dht.h&gt; //-----------------------------------------------------------------------------+ // Measurements task section. | //-----------------------------------------------------------------------------+ struct measurement_results { time_t timestamp; int am2302_humidity; int am2302_temperature; }; static QueueHandle_t measurements_queue; void measurement_task(void *arg) { int16_t humidity; int16_t temperature; struct measurement_results measurements; while (true) { debug("MEASUREMENTS: Start measurements...\n"); measurements.timestamp = time(NULL); bool success = dht_read_data(DHT_TYPE_DHT22, AM2302_PIN, &amp;humidity, &amp;temperature); if (success &amp;&amp; temperature &gt;= -500 &amp;&amp; temperature &lt;= 1500 &amp;&amp; humidity &gt;= 0 &amp;&amp; humidity &lt;= 1000) { measurements.am2302_humidity = humidity; measurements.am2302_temperature = temperature; } else { debug("MEASUREMENT: Error! Cannot read data from AM2302!!!\n"); measurements.am2302_humidity = INT_MIN; measurements.am2302_temperature = INT_MIN; } debug("MEASUREMENTS: Measurements finished...\n"); xQueueSendToBack(measurements_queue, &amp;measurements, MS(250)); vTaskDelay(MS(MEASUREMENTS_PERIOD_S * 1000)); } vTaskDelete(NULL); } //-----------------------------------------------------------------------------+ // Sending data task section. | //-----------------------------------------------------------------------------+ static uint8_t mqtt_buf[512]; static uint8_t mqtt_readbuf[128]; void sending_data_task(void *arg) { mqtt_network_t network; mqtt_network_new(&amp;network); mqtt_client_t client = mqtt_client_default; mqtt_packet_connect_data_t data = mqtt_packet_connect_data_initializer; uint8_t sntp_sync_counter = 0; while (true) { debug("MQTT: ConnectNetwork...\n"); int err = mqtt_network_connect(&amp;network, MQTT_HOST, MQTT_PORT); if (err) { debug("MQTT: Error!!! ConnectNetwork ERROR!\n"); vTaskDelay(MS(5 * 1000)); continue; } else { debug("MQTT: ConnectNetwork success...\n"); } // TODO: add check for errors!!! // TODO: replace magic constants!!! mqtt_client_new(&amp;client, &amp;network, 5000, mqtt_buf, 100, mqtt_readbuf, 100); data.willFlag = 0; data.MQTTVersion = 3; data.clientID.cstring = "fff"; data.username.cstring = MQTT_USER; data.password.cstring = MQTT_PASS; data.keepAliveInterval = 10; data.cleansession = 0; err = mqtt_connect(&amp;client, &amp;data); if (err) { debug("MQTT: Error!!! MQTTConnect ERROR!\n"); vTaskDelay(MS(5 * 1000)); continue; } else { debug("MQTT: MQTTConnect success...\n"); } struct measurement_results msg; while (xQueueReceive(measurements_queue, &amp;msg, 0) == pdTRUE) { if (msg.am2302_humidity == INT_MIN || msg.am2302_temperature == INT_MIN) { debug("MQTT: Got invalid message, no publishing!!!\n"); continue; } debug("MQTT: Got message to publish...\n"); debug(" timestamp: %ld\n", msg.timestamp); debug(" am2302_humidity: %.1f\n", msg.am2302_humidity / 10.0); debug(" am2302_temperature: %.1f\n", msg.am2302_temperature / 10.0); msg.timestamp = htonl(msg.timestamp); msg.am2302_humidity = htonl(msg.am2302_humidity); msg.am2302_temperature = htonl(msg.am2302_temperature); mqtt_message_t message; message.payload = &amp;msg; message.payloadlen = sizeof (msg); message.dup = 0; message.qos = MQTT_QOS1; message.retained = 0; err = mqtt_publish(&amp;client, MQTT_TOPIC, &amp;message); if (err) { debug("MQTT: Error!!! Error while publishing message!\n"); } else { debug("MQTT: Successfully publish message...\n"); } } mqtt_disconnect(&amp;client); mqtt_network_disconnect(&amp;network); ++sntp_sync_counter; if (sntp_sync_counter == RUN_SNTP_SYNC_PERIOD) { sntp_sync(NTP_SERVER, NULL, arg); sntp_sync_counter = 0; } vTaskDelay(MS(SEND_PERIOD_S * 1000)); } vTaskDelete(NULL); } //-----------------------------------------------------------------------------+ // Init task section. | //-----------------------------------------------------------------------------+ /** * This semaphore is taken during sntp sync and released after it finished. */ static SemaphoreHandle_t init_task_sem; /** * Set time and free init task semaphore. * @param error unused * @param arg unused */ void init_sntp_callback(int8_t error, void* arg) { time_t ts = time(NULL); debug("TIME: %s", ctime(&amp;ts)); xSemaphoreGive(init_task_sem); } /** * Connection parameters. */ static struct sdk_station_config STATION_CONFIG = { .ssid = WIFI_SSID, .password = WIFI_PASS, }; void init_task(void* arg) { debug("INIT: setting pins...\n"); gpio_set_pullup(AM2302_PIN, false, false); debug("INIT: Set station parameters...\n"); sdk_wifi_station_set_auto_connect(false); sdk_wifi_station_set_config(&amp;STATION_CONFIG); debug("Station parameters has been set.\n"); debug("INIT: Connecting to AP...\n"); sdk_wifi_station_connect(); while (sdk_wifi_station_get_connect_status() != STATION_GOT_IP) { vTaskDelay(MS(1000)); } debug("INIT: Connection to AP has been estabilished...\n"); debug("INIT: Start SNTP synchronization...\n"); init_task_sem = xSemaphoreCreateMutex(); if (!init_task_sem) { debug("INIT: Cannot create init task semaphore!!!"); return; } xSemaphoreTake(init_task_sem, 0); sntp_init(); sntp_sync(NTP_SERVER, init_sntp_callback, arg); BaseType_t result = pdFALSE; while (true) { debug("INIT: Trying to take init task semaphore...\n"); result = xSemaphoreTake(init_task_sem, MS(5 * 1000)); if (result == pdTRUE) { debug("INIT: Init task semaphore is taken...\n"); break; } } measurements_queue = xQueueCreate(MAX_MEASUREMENTS_COUNT, sizeof (struct measurement_results)); if (!measurements_queue) { debug("INIT: ERROR!!! Cannot create queue for measurements!\n"); goto fail; } result = xTaskCreate(measurement_task, "measurement_task", STACK_SIZE, NULL, MEASUREMENT_TASK_PRIORITY, NULL); if (result == pdFAIL) { debug("INIT: Measurement task creation failed!!!\n"); goto fail; } debug("INIT: Measurement task created...\n"); result = xTaskCreate(sending_data_task, "send_data_task", STACK_SIZE, NULL, SENDING_DATA_TASK_PRIORITY, NULL); if (result == pdFAIL) { debug("INIT: Send task creation failed!!!\n"); goto fail; } debug("INIT: Send data task created...\n"); fail: vSemaphoreDelete(init_task_sem); vTaskDelete(NULL); } //-----------------------------------------------------------------------------+ // Application entry point. | //-----------------------------------------------------------------------------+ void user_init(void) { debug("USER_INIT: SDK version: %s\n", sdk_system_get_sdk_version()); debug("USER_INIT: sizeof (int): %d\n", sizeof (int)); debug("USER_INIT: sizeof (float): %d\n", sizeof (float)); debug("USER_INIT: sizeof (time_t): %d\n", sizeof (time_t)); uart_set_baud(0, UART0_BAUD); BaseType_t result = xTaskCreate(init_task, (const char * const) "init_task", STACK_SIZE, NULL, INIT_TASK_PRIORITY, NULL); if (!result) { debug("USER_INIT: Cannot create init task!!!"); return; } }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">sntp.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SNTP_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SNTP_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;time.h&gt; #include &lt;stdint.h&gt; #ifdef __cplusplus extern "C" { #endif #define SNTP_ERR_OK 0 #define SNTP_ERR_CONTEXT -1 #define SNTP_ERR_DNS -2 #define SNTP_ERR_UDP_PCB_ALLOC -3 #define SNTP_ERR_PBUF_ALLOC -4 #define SNTP_ERR_SEND -5 #define SNTP_ERR_RECV_ADDR_PORT -6; #define SNTP_ERR_RECV_SIZE -7 #define SNTP_ERR_RECV_MODE -8 #define SNTP_ERR_RECV_STRATUM -9 typedef void (*sntp_sync_callback)(int8_t error, void *arg); void sntp_init(); void sntp_sync(char *server, sntp_sync_callback callback, void *callback_arg); time_t sntp_get_rtc_time(int32_t *us); void sntp_update_rtc(time_t t, uint32_t us); #ifdef __cplusplus } #endif #endif /* SNTP_H */</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">sntp.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sntp.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;time.h&gt; #include &lt;string.h&gt; #include &lt;lwip/ip_addr.h&gt; #include &lt;lwip/err.h&gt; #include &lt;lwip/dns.h&gt; #include &lt;lwip/udp.h&gt; #include &lt;esp/rtc_regs.h&gt; #include &lt;espressif/esp_common.h&gt; #define TIMER_COUNT RTC.COUNTER /** * Daylight settings. * Base calculated with value obtained from NTP server (64 bits). */ #define SNTP_BASE (*((uint64_t*) RTC.SCRATCH)) /** * Timer value when base was obtained. */ #define SNTP_TIME_REF (RTC.SCRATCH[2]) /** * Calibration value. */ #define SNTP_CALIBRATION (RTC.SCRATCH[3]) /** * SNTP modes. */ #define SNTP_MODE_CLIENT 0x03 #define SNTP_MODE_SERVER 0x04 #define SNTP_MODE_BROADCAST 0x05 /** * Kiss-of-death code. */ #define SNTP_STRATUM_KOD 0x00 #define SNTP_OFFSET_LI_VN_MODE 0 #define SNTP_OFFSET_STRATUM 1 #define SNTP_OFFSET_RECEIVE_TIME 32 #define DIFF_SEC_1900_1970 (2208988800UL) struct sntp_message { uint8_t li_vn_mode; uint8_t stratum; uint8_t poll; uint8_t precision; uint32_t root_delay; uint32_t root_dispersion; uint32_t reference_identifier; uint32_t reference_timestamp[2]; uint32_t originate_timestamp[2]; uint32_t receive_timestamp[2]; uint32_t transmit_timestamp[2]; } __attribute__ ((packed)); struct sntp_sync_context { ip_addr_t ip_address; sntp_sync_callback callback; void* callback_arg; }; void sntp_init() { SNTP_BASE = 0; SNTP_CALIBRATION = 1; SNTP_TIME_REF = TIMER_COUNT; } void on_dns_found(const char* name, ip_addr_t* ipaddr, void* arg); void on_udp_recv(void* arg, struct udp_pcb* pcb, struct pbuf* p, ip_addr_t* addr, u16_t port); void sntp_sync(char* server, sntp_sync_callback callback, void* callback_arg) { int result = ERR_OK; debug("SNTP: Start SNTP synchronization, allocating memory for context...\n"); struct sntp_sync_context* context = malloc(sizeof (struct sntp_sync_context)); if (!context) { debug("SNTP: Error!!! Cannot allocate memory for context!\n"); result = SNTP_ERR_CONTEXT; goto fail; } context-&gt;callback = callback; context-&gt;callback_arg = callback_arg; debug("SNTP: Context successfully allocated...\n"); debug("SNTP: Start DNS lookup...\n"); err_t err = dns_gethostbyname(server, &amp;(context-&gt;ip_address), on_dns_found, context); if (!(err == ERR_OK || err == ERR_INPROGRESS)) { debug("SNTP: Error!!! DNS lookup error!\n"); result = SNTP_ERR_DNS; goto fail; } return; fail: if (context) { free(context); } if (callback) { callback(result, callback_arg); } } // //============================================================================================================================================================== // void on_dns_found(const char* name, ip_addr_t* ipaddr, void* arg) { debug("SNTP: Start DNS lookup successfully finished...\n"); int result = ERR_OK; struct sntp_sync_context* context = arg; sntp_sync_callback callback = context-&gt;callback; void* callback_arg = context-&gt;callback_arg; debug("SNTP: Creating upd_pcb...\n"); struct udp_pcb* sntp_pcb = udp_new(); if (!sntp_pcb) { debug("SNTP: Error!!! Cannot allocate udp_pcb!\n"); result = SNTP_ERR_UDP_PCB_ALLOC; goto fail; } debug("SNTP: Successfully created upd_pcb...\n"); debug("SNTP: Allocating pbuf...\n"); struct pbuf* p = pbuf_alloc(PBUF_TRANSPORT, sizeof (struct sntp_message), PBUF_RAM); if (!p) { debug("SNTP: Error!!! DNS lookup error!\n"); result = SNTP_ERR_PBUF_ALLOC; goto fail; } struct sntp_message* message = p-&gt;payload; memset(message, 0, sizeof (struct sntp_message)); message-&gt;li_vn_mode = 0b00100011; // li = 00, vn = 4, mode = 3 debug("SNTP: Pbuf allocated successfully...\n"); debug("SNTP: Sending data to server...\n"); udp_recv(sntp_pcb, on_udp_recv, context); err_t err = udp_sendto(sntp_pcb, p, ipaddr, 123); pbuf_free(p); if (err != ERR_OK) { debug("SNTP: Error!!! data sending error!\n"); result = SNTP_ERR_SEND; goto fail; } debug("SNTP: Data sent...\n"); return; fail: if (context) { free(context); } if (sntp_pcb) { udp_remove(sntp_pcb); } if (callback) { callback(result, callback_arg); } } void on_udp_recv(void* arg, struct udp_pcb* pcb, struct pbuf* p, ip_addr_t* addr, u16_t port) { debug("SNTP: Response has successfully received...\n"); int result = ERR_OK; struct sntp_sync_context* context = arg; sntp_sync_callback callback = context-&gt;callback; void* callback_arg = context-&gt;callback_arg; debug("SNTP: Checking response size...\n"); if (p-&gt;tot_len &lt; sizeof (struct sntp_message)) { debug("SNTP: Error!!! Invalid response size!\n"); result = SNTP_ERR_RECV_SIZE; goto fail; } debug("SNTP: Response size is OK...\n"); debug("SNTP: Checking mode...\n"); u8_t mode = 0x0; pbuf_copy_partial(p, &amp;mode, sizeof (mode), SNTP_OFFSET_LI_VN_MODE); mode &amp;= 0b00000111; if (mode != SNTP_MODE_SERVER &amp;&amp; mode != SNTP_MODE_BROADCAST) { debug("SNTP: Error!!! Invalid mode!\n"); result = SNTP_ERR_RECV_MODE; goto fail; } debug("SNTP: Mode is OK...\n"); debug("SNTP: Checking stratum...\n"); u8_t stratum = 0x0; pbuf_copy_partial(p, &amp;stratum, sizeof (stratum), SNTP_OFFSET_STRATUM); if (stratum == SNTP_STRATUM_KOD) { debug("SNTP: Error!!! Kiss of death!\n"); result = SNTP_ERR_RECV_STRATUM; goto fail; } debug("SNTP: Stratum is OK...\n"); debug("SNTP: Updating system timer...\n"); uint32_t receive_time[2]; pbuf_copy_partial(p, &amp;receive_time, 2 * sizeof (uint32_t), SNTP_OFFSET_RECEIVE_TIME); time_t t = ntohl(receive_time[0]) - DIFF_SEC_1900_1970; uint32_t us = ntohl(receive_time[1]) / 4295; sntp_update_rtc(t, us); debug("SNTP: System timer updated...\n"); fail: if (context) { free(context); } if (pcb) { udp_remove(pcb); } if (callback) { callback(result, callback_arg); } } /** * Check if a timer wrap has occurred. Compensate sntp_base reference * if affirmative. * TODO: think about multitasking and race conditions. */ inline void sntp_check_timer_wrap(uint32_t current_value) { if (current_value &lt; SNTP_TIME_REF) { // Timer wrap has occurred, compensate by subtracting 2^32 to ref. SNTP_BASE -= 1LLU &lt;&lt; 32; } } /** * Return secs. If us is not a null pointer, fill it with usecs */ time_t sntp_get_rtc_time(int32_t *us) { time_t secs; uint32_t tim; uint64_t base; tim = TIMER_COUNT; // Check for timer wrap. sntp_check_timer_wrap(tim); base = SNTP_BASE + tim - SNTP_TIME_REF; secs = base * SNTP_CALIBRATION / (1000000U &lt;&lt; 12); if (us) { *us = base * SNTP_CALIBRATION % (1000000U &lt;&lt; 12); } return secs; } /** * Update RTC timer. Called by SNTP module each time it receives an update. */ void sntp_update_rtc(time_t t, uint32_t us) { // Apply daylight and timezone correction // DEBUG: Compute and print drift int64_t sntp_current = SNTP_BASE + TIMER_COUNT - SNTP_TIME_REF; int64_t sntp_correct = (((uint64_t) us + (uint64_t) t * 1000000U) &lt;&lt; 12) / SNTP_CALIBRATION; debug("RTC Adjust: drift = %ld ticks, cal = %d\n", (time_t) (sntp_correct - sntp_current), SNTP_CALIBRATION); SNTP_TIME_REF = TIMER_COUNT; SNTP_CALIBRATION = sdk_system_rtc_clock_cali_proc(); SNTP_BASE = (((uint64_t) us + (uint64_t) t * 1000000U) &lt;&lt; 12) / SNTP_CALIBRATION; } /** * Syscall implementation. doesn't seem to use tzp. */ int _gettimeofday_r(struct _reent* r, struct timeval* tp, void* tzp) { // Syscall defined by xtensa newlib defines tzp as void* // So it looks like it is not used. Also check tp is not NULL if (tzp || !tp) { return EINVAL; } tp-&gt;tv_sec = sntp_get_rtc_time((int32_t*) &amp; tp-&gt;tv_usec); return 0; }</span></span></span></span></code> </pre><br></div></div><br>  Digression lyrique sur la disponibilit√© de votre propre code de synchronisation horaire via SNTP: dans les extensions du SDK il y a d√©j√† un tel module, mais pour une raison quelconque je ne l'aimais pas (il y a longtemps, je ne me souviens pas pourquoi), j'ai donc copi√© ce code impudemment et l'ai modifi√© pour moi-m√™me. <br><br>  Tout fonctionne simplement: lorsque le contr√¥leur d√©marre, la t√¢che d'initialisation d√©marre, qui se connecte au point d'acc√®s, synchronise l'heure via SNTP, d√©marre la t√¢che de mesurer la temp√©rature avec l'humidit√© et d'envoyer des donn√©es au serveur, apr√®s quoi il se tue.  La t√¢che de mesure interroge le capteur toutes les 59 secondes et place les r√©sultats dans une file d'attente, la t√¢che d'envoi d√©marre toutes les 2 minutes, lit les donn√©es de la file d'attente et les envoie au serveur MQTT. <br><br>  Th√©oriquement, vous pouvez √©crire en C ++. <br><br>  <b>√âtape 5 - Conclusion, o√π sans lui</b> <br><br>  D'une mani√®re si simple, en utilisant le langage C et des mains avec un petit rayon de courbure, vous pouvez programmer le contr√¥leur ESP8266.  Le principal avantage de cette approche par rapport aux solutions de script (par exemple, LUA ou MicroPython) est un contr√¥le total sur la composition et les ressources du micrologiciel et la possibilit√© de cr√©er plus de fonctionnalit√©s avec des ressources de contr√¥leur limit√©es.  Il existe √©galement une option pour utiliser le SDK RTOS ou NONOS d'Espressif, mais je n'ai pas grandi avec le premier et je n'ai pas essay√© d'utiliser le second.  Si quelqu'un est int√©ress√©, ainsi que lorsque je le comprends moi-m√™me, je peux √©crire le tutoriel suivant sur OTA (mise √† jour du firmware par voie a√©rienne). <br><br>  Quelques r√©sultats de ce code: <br><br><div class="spoiler">  <b class="spoiler_title">Donn√©es re√ßues du serveur MQTT et t√©l√©charg√©es dans la base de donn√©es</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/db8/1b7/085/db81b70850ce4ef8afbb77536c57f973.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">D√©boguer l'√©chappement du contr√¥leur dans UART</b> <div class="spoiler_text"><pre> <code class="hljs delphi">SDK version: <span class="hljs-number"><span class="hljs-number">0.9</span></span>.<span class="hljs-number"><span class="hljs-number">9</span></span> --- USER_INIT: sizeof (int): <span class="hljs-number"><span class="hljs-number">4</span></span> --- USER_INIT: sizeof (float): <span class="hljs-number"><span class="hljs-number">4</span></span> --- USER_INIT: sizeof (time_t): <span class="hljs-number"><span class="hljs-number">4</span></span> mode : sta(<span class="hljs-number"><span class="hljs-number">18</span></span>:fe:<span class="hljs-number"><span class="hljs-number">34</span></span>:d2:c5:a7) add if0 --- INIT: setting pins... --- INIT: <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span> station parameters... --- Station parameters has been <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>. --- INIT: Connecting <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> AP... scandone add <span class="hljs-number"><span class="hljs-number">0</span></span> aid <span class="hljs-number"><span class="hljs-number">2</span></span> cnt connected <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> kosmonaFFFt, channel <span class="hljs-number"><span class="hljs-number">1</span></span> dhcp client start... ip:<span class="hljs-number"><span class="hljs-number">192.168</span></span>.<span class="hljs-number"><span class="hljs-number">1.21</span></span>,mask:<span class="hljs-number"><span class="hljs-number">255.255</span></span>.<span class="hljs-number"><span class="hljs-number">255.0</span></span>,gw:<span class="hljs-number"><span class="hljs-number">192.168</span></span>.<span class="hljs-number"><span class="hljs-number">1.1</span></span> --- INIT: Connection <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> AP has been estabilished... --- INIT: Start SNTP synchronization... --- SNTP: Start SNTP synchronization, allocating memory <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> context... --- SNTP: Context successfully allocated... --- SNTP: Start DNS lookup... --- INIT: Trying <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> take init task semaphore... --- SNTP: Start DNS lookup successfully finished... --- SNTP: Creating upd_pcb... --- SNTP: Successfully created upd_pcb... --- SNTP: Allocating pbuf... --- SNTP: Pbuf allocated successfully... --- SNTP: Sending data <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> server... --- SNTP: Data sent... --- SNTP: Response has successfully received... --- SNTP: Checking response size... --- SNTP: Response size <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> OK... --- SNTP: Checking mode... --- SNTP: Mode <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> OK... --- SNTP: Checking stratum... --- SNTP: Stratum <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> OK... --- SNTP: Updating system timer... --- RTC Adjust: drift = <span class="hljs-number"><span class="hljs-number">1220897578</span></span> ticks, cal = <span class="hljs-number"><span class="hljs-number">1</span></span> --- SNTP: System timer updated... --- TIME: Thu Sep <span class="hljs-number"><span class="hljs-number">21</span></span> <span class="hljs-number"><span class="hljs-number">19</span></span>:<span class="hljs-number"><span class="hljs-number">20</span></span>:<span class="hljs-number"><span class="hljs-number">36</span></span> <span class="hljs-number"><span class="hljs-number">2017</span></span> --- INIT: Init task semaphore <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> taken... --- MEASUREMENTS: Start measurements... --- MEASUREMENTS: Measurements finished... --- INIT: Measurement task created... --- MQTT: ConnectNetwork... --- INIT: Send data task created... --- MQTT: ConnectNetwork success... --- MQTT: MQTTConnect success... --- MQTT: Got <span class="hljs-keyword"><span class="hljs-keyword">message</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> publish... --- timestamp: <span class="hljs-number"><span class="hljs-number">1506021636</span></span> --- am2302_humidity: <span class="hljs-number"><span class="hljs-number">55.8</span></span> --- am2302_temperature: <span class="hljs-number"><span class="hljs-number">23.4</span></span> --- MQTT: Successfully publish <span class="hljs-keyword"><span class="hljs-keyword">message</span></span>... --- MEASUREMENTS: Start measurements... --- MEASUREMENTS: Measurements finished... --- MEASUREMENTS: Start measurements... --- MEASUREMENTS: Measurements finished... --- MQTT: ConnectNetwork... --- MQTT: ConnectNetwork success... --- MQTT: MQTTConnect success... --- MQTT: Got <span class="hljs-keyword"><span class="hljs-keyword">message</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> publish... --- timestamp: <span class="hljs-number"><span class="hljs-number">1506021694</span></span> --- am2302_humidity: <span class="hljs-number"><span class="hljs-number">55.2</span></span> --- am2302_temperature: <span class="hljs-number"><span class="hljs-number">23.8</span></span> --- MQTT: Successfully publish <span class="hljs-keyword"><span class="hljs-keyword">message</span></span>... --- MQTT: Got <span class="hljs-keyword"><span class="hljs-keyword">message</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> publish... --- timestamp: <span class="hljs-number"><span class="hljs-number">1506021751</span></span> --- am2302_humidity: <span class="hljs-number"><span class="hljs-number">56.5</span></span> --- am2302_temperature: <span class="hljs-number"><span class="hljs-number">24.4</span></span> --- MQTT: Successfully publish <span class="hljs-keyword"><span class="hljs-keyword">message</span></span>... --- MEASUREMENTS: Start measurements... --- MEASUREMENTS: Measurements finished... --- MEASUREMENTS: Start measurements... --- MEASUREMENTS: Measurements finished... --- MQTT: ConnectNetwork... --- MQTT: ConnectNetwork success... --- MQTT: MQTTConnect success... --- MQTT: Got <span class="hljs-keyword"><span class="hljs-keyword">message</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> publish... --- timestamp: <span class="hljs-number"><span class="hljs-number">1506021807</span></span> --- am2302_humidity: <span class="hljs-number"><span class="hljs-number">53.0</span></span> --- am2302_temperature: <span class="hljs-number"><span class="hljs-number">24.7</span></span> --- MQTT: Successfully publish <span class="hljs-keyword"><span class="hljs-keyword">message</span></span>... --- MQTT: Got <span class="hljs-keyword"><span class="hljs-keyword">message</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> publish... --- timestamp: <span class="hljs-number"><span class="hljs-number">1506021863</span></span> --- am2302_humidity: <span class="hljs-number"><span class="hljs-number">52.3</span></span> --- am2302_temperature: <span class="hljs-number"><span class="hljs-number">24.8</span></span> --- MQTT: Successfully publish <span class="hljs-keyword"><span class="hljs-keyword">message</span></span>... --- MEASUREMENTS: Start measurements... --- MEASUREMENTS: Measurements finished... --- MEASUREMENTS: Start measurements... --- MEASUREMENTS: Measurements finished... --- MQTT: ConnectNetwork... --- MQTT: ConnectNetwork success... --- MQTT: MQTTConnect success... --- MQTT: Got <span class="hljs-keyword"><span class="hljs-keyword">message</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> publish... --- timestamp: <span class="hljs-number"><span class="hljs-number">1506021919</span></span> --- am2302_humidity: <span class="hljs-number"><span class="hljs-number">52.0</span></span> --- am2302_temperature: <span class="hljs-number"><span class="hljs-number">24.9</span></span> --- MQTT: Successfully publish <span class="hljs-keyword"><span class="hljs-keyword">message</span></span>... --- MQTT: Got <span class="hljs-keyword"><span class="hljs-keyword">message</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> publish... --- timestamp: <span class="hljs-number"><span class="hljs-number">1506021975</span></span> --- am2302_humidity: <span class="hljs-number"><span class="hljs-number">53.3</span></span> --- am2302_temperature: <span class="hljs-number"><span class="hljs-number">25.2</span></span> --- MQTT: Successfully publish <span class="hljs-keyword"><span class="hljs-keyword">message</span></span>...</code> </pre> <br></div></div><br>  <b>PS Je</b> recommande d'utiliser minicom (console) ou cutecom (GUI) pour travailler avec UART sur PC. <br><br>  <b>Liens utiles:</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">API FreeRTOS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ESP RTOS SDK Guide</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr406813/">https://habr.com/ru/post/fr406813/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr406803/index.html">Rossvyaz √©tudie la possibilit√© de cr√©er une base de donn√©es IMEI unique de t√©l√©phones fonctionnant en F√©d√©ration de Russie</a></li>
<li><a href="../fr406805/index.html">L'interface cerveau-ordinateur n'est plus de la science-fiction</a></li>
<li><a href="../fr406807/index.html">La Marine am√©ricaine d√©cide d'utiliser des contr√¥leurs Xbox 360 au lieu de t√©l√©commandes co√ªteuses de 38 000 $</a></li>
<li><a href="../fr406809/index.html">Les plus grands avions Stratolaunch au monde ont test√© les moteurs et le syst√®me de carburant</a></li>
<li><a href="../fr406811/index.html">Comment se d√©roule le monde secret de la formation des robots Waymo</a></li>
<li><a href="../fr406815/index.html">Non, il est impossible de regretter tout le monde tout de suite</a></li>
<li><a href="../fr406817/index.html">Une cr√©ature vivante peut-elle avoir la taille d'une galaxie?</a></li>
<li><a href="../fr406819/index.html">Fonctionnement de la production automatis√©e de tonnage de gels</a></li>
<li><a href="../fr406821/index.html">Cr√©ation de papier avec Epson PaperLab</a></li>
<li><a href="../fr406823/index.html">Sym√©tries C, P, T (et leurs combinaisons)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>