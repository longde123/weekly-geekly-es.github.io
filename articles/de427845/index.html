<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👷🏻 👩🏻‍🔬 📿 Wie man eine Million Sterne in ein iPhone passt 🚩 👨🏻‍🏭 👩🏼‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eine so romantische Sache wie ein Sternenhimmel und eine so harte Sache wie die Optimierung des Speicherverbrauchs durch eine iOS-Anwendung können dur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie man eine Million Sterne in ein iPhone passt</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/427845/"><img src="https://habrastorage.org/webt/q7/xz/3_/q7xz3_mzwjft238rwmzhjpbnwqm.jpeg"><br><br>  Eine so romantische Sache wie ein Sternenhimmel und eine so harte Sache wie die Optimierung des Speicherverbrauchs durch eine iOS-Anwendung können durchaus zusammenpassen: Es lohnt sich, diesen Sternenhimmel in eine AR-Anwendung zu schieben, und die Frage nach dem gleichen Verbrauch wird sich sofort stellen. <br><br>  In so vielen anderen Fällen ist es nützlich, die Speichernutzung zu minimieren.  Dieser Text am Beispiel eines kleinen Projekts zeigt Optimierungsmethoden, die in völlig unterschiedlichen iOS-Anwendungen (und nicht nur in iOS-) nützlich sein können. <br><a name="habracut"></a><br>  Der Beitrag wurde auf der Grundlage einer Abschrift des Berichts von <b>Conrad Filer</b> von der Piter-Konferenz Mobius 2018 erstellt.  Wir fügen das Video und dann eine Textversion in der ersten Person bei: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/51PJjrh9yTA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Freut mich, alle willkommen zu heißen!  Mein Name ist Conrad Filer und unter dem spektakulären Namen "Eine Million Sterne in einem iPhone" werden wir diskutieren, wie Sie die Speichergröße Ihrer iOS-Anwendung minimieren können.  Bunt und in Beispielen. <br><br><h2>  Warum optimieren? </h2><br>  Was ermutigt uns generell zur Optimierung, was genau möchten wir erreichen?  Das wollen wir nicht: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/54b/0ef/fbf/54b0effbffa93a27e65a50000242046d.gif"></div><br><br>  Wir möchten nicht, dass der Benutzer wartet.  Das heißt, der erste Grund ist die <b>Verkürzung der Startzeit</b> . <br><br>  Ein weiterer Grund ist <b>die Verbesserung der Qualität</b> . <br><br><img src="https://habrastorage.org/webt/dj/6i/0w/dj6i0wxgzgv87xkdvnkiy6ddy48.jpeg"><br><br>  Wir können über die Qualität von Bildern, Ton und sogar KI sprechen.  "Optimierte KI" bedeutet, dass Sie mehr erreichen können - berechnen Sie beispielsweise das Spiel für eine größere Anzahl von Zügen vorwärts. <br><br>  Der dritte Grund ist sehr wichtig: <b>Einsparung von Batteriestrom</b> .  Durch die Optimierung wird der Akku weniger entladen.  Hier ist ein interessanter Vergleich, wenn auch aus der Android-Welt.  Hier verglichen Vulkan und OpenGL ES: <br><br><img src="https://habrastorage.org/webt/9n/ni/dx/9nnidxssdqtw_t2ibkdatsaapfm.jpeg"><br><br>  Die zweite ist schlechter für mobile Plattformen optimiert.  Wenn Sie die Geschwindigkeit des Batterieverbrauchs beobachten, können Sie feststellen, dass OpenGL ES für ein ähnliches Bild viel mehr Ressourcen verbraucht hat als Vulkan. <br><br>  Welche Art der Optimierung kann hier helfen?  Wenn der Benutzer beispielsweise in einem rundenbasierten Spiel über seinen Zug nachdenkt, können Sie die FPS auf Null reduzieren.  Wenn Sie eine 3D-Engine haben, ist es absolut ratsam, einfach alles auszuschalten, während der Benutzer nur auf den Bildschirm schaut. <br><br>  Darüber hinaus gibt es Zeiten, in denen Sie ohne einen optimierten Ansatz die eine oder andere erweiterte Funktion nicht implementieren können: Sie wird einfach nicht abgerufen. <br><br><h2>  Kein Fanatismus </h2><br>  Wenn man über Optimierung spricht, kann man sich nur an die These von Donald Knuth erinnern: „Wir sollten beispielsweise in 97% der Fälle die geringe Effizienz vergessen: Vorzeitige Optimierung ist die Wurzel aller Übel.  Obwohl wir unsere Fähigkeiten in diesen kritischen 3% nicht aufgeben sollten. " <br><br>  In 97% der Fälle sollten wir uns nicht um Effizienz kümmern, sondern vor allem darum, wie wir unseren Code verständlich, sicher und testbar machen können.  Wir entwickeln immer noch für mobile Geräte und nicht für Raumschiffe.  Die Unternehmen, in denen wir arbeiten, sollten nicht zu viel für die Unterstützung des von uns geschriebenen Codes bezahlen.  Darüber hinaus ist die Arbeitszeit des Entwicklers mit Kosten verbunden. Wenn Sie sie für die Optimierung von nicht wesentlichen Dingen ausgeben, geben Sie das Geld des Unternehmens aus.  Nun, die Tatsache, dass gut optimierter Code schwieriger zu verstehen ist, können Sie anhand der Beispiele sehen, die ich Ihnen heute zeigen werde. <br><br>  Im Allgemeinen sollten Sie nach Bedarf sinnvoll priorisieren und optimieren. <br><br><h2>  Die Ansätze </h2><br>  Wenn wir an der Optimierung arbeiten, überwachen wir normalerweise entweder die Leistung (lesen: Prozessorlast) oder die Menge des verwendeten Speichers.  Oft stehen diese beiden Optionen in Konflikt, und Sie müssen ein Gleichgewicht zwischen ihnen finden. <br><br>  Im Fall des Prozessors können wir die Anzahl der Prozessorzyklen reduzieren, die für unsere Operationen erforderlich sind.  Wie Sie wissen, sorgen weniger Prozessorzyklen für weniger Ladezeit, weniger Batterieverbrauch, bessere Qualität usw. <br><br>  Für iOS-Entwickler bietet Xcode Instruments ein praktisches Time Profiler-Tool.  Sie können damit die Anzahl der CPU-Zyklen verfolgen, die von verschiedenen Teilen Ihrer Anwendung verbracht wurden.  In diesem Bericht geht es nicht um Tools, daher werde ich jetzt nicht auf Details eingehen. Es gab ein gutes Video von WWDC dazu. <br><br>  Sie können ein anderes Ziel wählen - Optimierung aus Gründen des Gedächtnisses.  Wir werden versuchen sicherzustellen, dass unsere Anwendung beim Start in die kleinstmögliche Anzahl von RAM-Zellen passt.  Denken Sie daran, dass die umfangreichsten Anwendungen die ersten Kandidaten für ein erzwungenes Herunterfahren beim Reinigen sind, das das Betriebssystem ausführen muss.  Dies wirkt sich daher darauf aus, wie lange Ihre Anwendung im Hintergrund bleibt. <br><br>  Es ist auch wichtig, dass die RAM-Ressource für verschiedene Geräte ebenfalls unterschiedlich ist.  Wenn Sie sich beispielsweise für die Entwicklung für die Apple Watch entschieden haben, ist nicht genügend Speicher vorhanden, und Sie können damit auch optimieren. <br><br>  Schließlich macht manchmal eine kleine Menge an Speicher das Programm auch sehr schnell.  Ich werde ein Beispiel geben.  Hier sind die Strukturen unterschiedlicher Größe in Bytes: <br><br><img src="https://habrastorage.org/webt/mg/2c/_2/mg2c_2se8rpo_gwwnqlfbcaf2ks.jpeg"><br><br>  Element8 enthält 8 Bytes, Element16 - 16 usw. <br><br><img src="https://habrastorage.org/webt/ot/hq/l3/othql3uj6cujllgs99m_ypmkok8.jpeg"><br><br>  Wir werden Arrays erstellen, eines für jeden unserer Strukturtypen.  Die Dimension aller Arrays ist gleich - 10.000 Elemente.  Jede Struktur enthält eine andere Anzahl von Feldern (ansteigend);  Feld n ist das erste Feld und ist dementsprechend in allen Strukturen vorhanden. <br><br>  Versuchen wir nun Folgendes: Für jedes Array berechnen wir die Summe aller seiner Felder n.  Das heißt, jedes Mal werden wir die gleiche Anzahl von Elementen (10.000 Stück) summieren.  Der einzige Unterschied besteht darin, dass für jede Summe die Variable n aus Strukturen unterschiedlicher Größe extrahiert wird.  Uns interessiert, ob die Summierung dieselbe Zeit dauert. <br><br>  Das Ergebnis ist folgendes: <br><br><img src="https://habrastorage.org/webt/el/mu/k1/elmuk1tm_yaku9exe4xgbaw8gp4.jpeg"><br><br>  Die Grafik zeigt die Abhängigkeit der Summationszeit von der Größe der im Array verwendeten Struktur.  Es stellt sich heraus, dass das Abrufen des Feldes n von einer größeren Struktur länger ist und daher die Summierungsoperation länger dauert. <br>  Viele von Ihnen haben bereits verstanden, warum dies geschieht. <br><br>  Der Prozessor verfügt über L1-, L2-Caches (manchmal sogar L3 und L4).  Der Prozessor greift direkt und schnell auf diese Art von Speicher zu. <br><br><img src="https://habrastorage.org/webt/u1/yy/r9/u1yyr9z2pxbwcffecy8i_xoa5qq.jpeg"><br><br>  Es gibt Caches, um die Wiederverwendung von Daten zu beschleunigen.  Angenommen, wir arbeiten mit Arrays.  Wenn das vom Prozessor benötigte Array bereits in einem der Caches vorhanden ist, wurde es vom Prozessor bereits früher benötigt.  In diesem Moment forderte er sie aus dem Hauptspeicher an, legte sie in den Cache, führte alle erforderlichen Operationen mit ihnen durch, wonach diese Daten liegen blieben (keine Zeit hatten, von anderen gelöscht zu werden). <br><br><img src="https://habrastorage.org/webt/qt/cd/om/qtcdomuam8uo4cz2tnkevtmvxuk.jpeg"><br><br>  Die Größe der L1-, L2-Caches ist nicht so groß.  Das Array, das der Prozessor zum Arbeiten benötigt, kann größer sein.  Um die Operation für ein solches Array vollständig auszuführen, müssen wir es in Teilen in den Cache entladen und diese Teile einzeln bearbeiten.  Aufgrund ständiger Anforderungen an den Hauptspeicher dauert die Verarbeitung unseres Arrays viel länger. <br><br>  Versuchen Sie beim Programmieren von Datenstrukturen, die Caches zu berücksichtigen.  Es ist möglich, dass Sie durch Reduzieren der Größe Ihrer Datenstruktur die erfolgreiche Cache-Kapazität erreichen und die Operationen beschleunigen, die in Zukunft daran ausgeführt werden.  Die Interaktion mit dem Hauptspeicher war, ist und bleibt höchstwahrscheinlich ein wesentlicher Faktor für die Produktivität - selbst wenn Sie für moderne Hochleistungsgeräte auf Swift schreiben. <br><br><h2>  CPU vs RAM: verzögerte Initialisierung </h2><br>  Obwohl in einigen Fällen, wenn der verwendete Speicher reduziert wird, das Programm schneller zu arbeiten beginnt, gibt es Fälle, in denen diese beiden Metriken im Gegenteil in Konflikt stehen.  Ich werde ein Beispiel mit dem Konzept der verzögerten Initialisierung geben. <br><br>  Angenommen, wir haben eine makeHeavyObject () -Methode, die ein großes Objekt zurückgibt.  Diese Methode initialisiert die Variable lazilyCalculated. <br><br><img src="https://habrastorage.org/webt/-y/2v/4l/-y2v4lzluwid2sxmelau-qp9yiu.jpeg"><br><br>  Der Modifikator "Lazy" setzt die Variable "LazyCalculated" auf "Lazy Initialization".  Dies bedeutet, dass ihm nur dann ein Wert zugewiesen wird, wenn der erste Aufruf während der Ausführung erfolgt.  Dann funktioniert die Methode makeHeavyObject () und das resultierende Objekt wird der Variablen lazilyCalculated zugewiesen. <br><br>  Was ist das Plus hier?  Ab dem Moment der Initialisierung (wenn auch später, aber es wird ausgeführt) befindet sich ein Objekt im Speicher.  Sein Wert wird gezählt, er ist einsatzbereit - stellen Sie einfach eine Anfrage.  Eine andere Sache ist, dass unser Objekt groß ist und ab dem Moment der Initialisierung den Löwenanteil der Zellen im Gedächtnis einnimmt. <br><br>  Sie können auch in die andere Richtung gehen - speichern Sie den Wert des Feldes überhaupt nicht: <br><br><img src="https://habrastorage.org/webt/rd/dj/td/rddjtdebqiiyidg1vravbwzreli.jpeg"><br><br>  Bei jedem Link zum Feld lazilyCalculated wird die Methode makeHeavyObject () erneut ausgeführt.  Der Wert wird an den Abfragepunkt zurückgegeben, während er nicht im Speicher abgelegt wird.  Wie Sie sehen können, ist das Speichern einer Variablen optional. <br><br>  Was ist teurer - ein großes Objekt im Speicher zu speichern, aber keine CPU-Zeit zu verschwenden oder die Methode jedes Mal aufzurufen, wenn wir unser Feld benötigen, während gleichzeitig Speicherplatz gespart wird?  Sollten Sie einen vorgefertigten Wert zur Hand haben oder diesen im laufenden Betrieb berechnen?  Diese Art von Dilemma tritt häufig auf, wo immer Sie Ihre Berechnungen durchführen - auf einem Remote-Server oder auf Ihrem lokalen Computer, unabhängig davon, mit welchem ​​Cache Sie arbeiten müssen.  Sie müssen eine Entscheidung treffen, die auf den Systembeschränkungen in diesem speziellen Fall basiert. <br><br><h2>  Optimierungszyklus </h2><br><br><img src="https://habrastorage.org/webt/3y/jb/tz/3yjbtzvba5c5cmvdmyxws4ubev8.jpeg"><br><br>  Was auch immer Sie optimieren, Ihre Arbeit basiert in der Regel auf demselben Algorithmus.  Zunächst untersuchen Sie den Code, das Profil / die Kennzahl (in Xcode mit den entsprechenden Tools) und versuchen, die Engpässe zu identifizieren.  Ordnen Sie die Methoden im Wesentlichen danach an, wie lange die Ausführung dauert.  Schauen Sie sich dann die oberen Zeilen an, um festzustellen, was optimiert werden soll. <br><br>  Wenn Sie ein Objekt auswählen, stellen Sie sich die Aufgabe (oder stellen wissenschaftlich gesehen eine Hypothese auf): Durch Anwendung dieser oder anderer Optimierungsmethoden können Sie den ausgewählten Code schneller arbeiten lassen. <br><br>  Als nächstes versuchen Sie zu optimieren.  Nach jeder Änderung sehen Sie sich die Leistungsindikatoren an und bewerten, wie effektiv die Änderung war und wie weit Sie vorankommen konnten. <br><br>  Genau wie in einer wissenschaftlichen Arbeit: Spekulation, Experiment, Analyse der Ergebnisse.  Sie durchlaufen diesen Aktionszyklus immer wieder.  Die Praxis zeigt, dass die auf diese Weise konstruierte Arbeit es Ihnen wirklich ermöglicht, die Botneks einzeln zu eliminieren. <br><br><h2>  Unit-Tests </h2><br><br><img src="https://habrastorage.org/webt/yp/c3/zl/ypc3zlrxtbnbkp9cwekladdj-ug.jpeg"><br><br>  Kurz zu Unit-Tests: Wir haben einige Funktionen, die wir testen, einige Eingabedateneingaben und Ausgabedatenausgaben;  Wenn wir als Eingabe Eingaben erhalten, sollte unsere Funktion immer Ausgaben zurückgeben, und keine unserer Optimierungen sollte diese Eigenschaft verletzen. <br><br>  Unit-Tests helfen uns, die Aufschlüsselung zu verfolgen.  Wenn unsere Funktion als Reaktion auf Eingaben keine Ausgabe mehr zurückgibt, haben wir entweder direkt oder indirekt den alten Arbeitsablauf unserer Funktion geändert. <br><br>  Versuchen Sie nicht einmal, mit der Optimierung zu beginnen, wenn Sie nicht einen großzügigen Teil der Komponententests in Ihren Code geschrieben haben.  Sie sollten in der Lage sein, einen Regressionstest durchzuführen.  Wenn Sie sich GitHub my Commits in meiner Beispielanwendung ansehen, auf die ich noch eingehen werde, können Sie sehen, dass einige meiner Optimierungen Fehler mit sich gebracht haben. <br><br>  Und jetzt zum lustigen Teil, gehen wir weiter zu den Sternen. <br><br><h2>  Millionen Sterne </h2><br>  Es gibt eine große (riesige) Datenbank, die eine Million Sterne beschreibt.  Darüber hinaus habe ich mehrere Anwendungen erstellt.  Einer von ihnen verwendet Augmented Reality und zeichnet in Echtzeit Sterne von der Kamera des Telefons auf das Bild.  Jetzt werde ich es in Aktion demonstrieren: <br><br><img src="https://habrastorage.org/webt/cr/rs/jv/crrsjv1iezyd2hzyxdxpjricu0u.png"><br><br>  Ohne Lichter der Stadt kann eine Person bis zu 8.000 Sterne am Himmel unterscheiden.  Ich würde ungefähr 1,8 MB benötigen, um 8.000 Datensätze zu speichern.  Im Prinzip akzeptabel.  Aber ich wollte die Sterne hinzufügen, die eine Person durch ein Teleskop sehen kann - es stellte sich heraus, dass es ungefähr 120.000 Sterne waren (laut dem sogenannten Hipparcos-Katalog, der inzwischen veraltet ist).  Dies erforderte bereits 27 MB.  Und unter den modernen gemeinfreien Katalogen finden Sie einen mit rund 2.500.000 Sternen.  Eine solche Datenbank würde bereits etwa 560 MB belegen.  Wie Sie sehen, wird bereits viel Speicher benötigt.  Wir wollen aber nicht nur eine Datenbank, sondern eine darauf basierende Anwendung, in der es ARKit, SceneKit und andere Dinge gibt, die ebenfalls Speicher benötigen. <br><br>  Was tun? <br>  Wir werden die Sterne optimieren. <br><br><h2>  MemoryLayout-Tool </h2><br>  Sie können die Größe des gesamten Programms bewerten.  Für Schmuckarbeiten wie die Optimierung benötigen Sie jedoch Tools zum Schätzen der Größe jeder einzelnen Datenstruktur. <br><br>  Mit Swift können Sie dies ganz einfach tun - mithilfe von MemoryLayout &lt;&gt; -Objekten.  Sie deklarieren ein MemoryLayout &lt;&gt; und geben die für Sie interessante Datenstruktur als generischen Typ an.  Unter Bezugnahme auf die Eigenschaften des empfangenen Objekts können Sie nun eine Reihe nützlicher Informationen zu Ihrer Struktur erhalten. <br><br><img src="https://habrastorage.org/webt/4b/dy/ki/4bdykiugciapow4d-avqvmfhp7e.jpeg"><br><br>  Die size-Eigenschaft gibt die Anzahl der Bytes an, die von einer Instanz der Struktur belegt werden. <br>  Nun zur Schritt-Eigenschaft.  Möglicherweise haben Sie bemerkt, dass die Größe des Arrays in der Regel nicht der Summe der Größen seiner Bestandteile entspricht, sondern diese überschreitet.  Offensichtlich bleibt etwas „Luft“ zwischen den Elementen im Speicher.  Um den Abstand zwischen aufeinanderfolgenden Elementen in einem benachbarten Array abzuschätzen, verwenden wir die Eigenschaft stride.  Wenn Sie es mit der Anzahl der Elemente im Array multiplizieren, erhalten Sie seine Größe. <br><br><img src="https://habrastorage.org/webt/vo/9x/6i/vo9x6ivnzz5-nzdhowe4cvtox3u.jpeg"><br><br>  StarData, unsere experimentelle Struktur, in ihrem ursprünglichen, nicht optimierten Zustand: <br><br><img src="https://habrastorage.org/webt/no/ku/51/noku51vmtamzm8yk1cclohg1-ea.jpeg"><br><br>  Hier ist eine Datenstruktur zum Speichern von Daten über einen Stern.  Sie müssen sich nicht mit den Bedeutungen der einzelnen Elemente befassen.  Es ist jetzt wichtiger, auf die Typen zu achten: Float-Variablen, die die Koordinaten des Sterns speichern (tatsächlich Breiten- und Längengrad), mehrere Int32 für verschiedene IDs, String zum Speichern von Namen und Namen verschiedener Klassifikationen;  Es gibt einen Abstand, eine Farbe und einige andere Größen, die für die korrekte Anzeige eines Sterns erforderlich sind. <br><br>  Wir bitten um die Schritt-Eigenschaft: <br><br><img src="https://habrastorage.org/webt/ob/pu/l-/obpul-qs28mwnfqhfnay3b5ml-m.jpeg"><br><br>  Im Moment wiegt unsere Struktur 208 Bytes.  Eine Million solcher Strukturen benötigt 250 MB - das ist, wie Sie wissen, zu viel.  Daher ist eine Optimierung erforderlich. <br><br><h2>  Korrigieren Sie int </h2><br>  Die Tatsache, dass es verschiedene Arten von Int gibt, wird in den ersten Programmierstunden erklärt.  Das für uns bekannteste Int in Swift heißt Int8.  Es belegt 8 Bit (1 Byte) und kann Werte von -128 bis einschließlich 127 speichern.  Es gibt auch andere Ints: <br><ul><li>  Int16 hat eine Größe von 2 Bytes und einen Wertebereich von -32.768 bis 32.767. </li><li>  Int32 mit einer Größe von 4 Bytes reicht der Wertebereich von -2.147.483.648 bis 2.147.483.647; </li><li>  Int64 (oder nur Int) ist 8 Byte groß, der Wertebereich reicht von -9.223.372.036.854.775.808 bis 9.223.372.036.854.775.807. </li></ul><br><br>  Wahrscheinlich denken diejenigen von Ihnen, die sich mit Webentwicklung befasst und sich mit SQL befasst haben, bereits darüber nach.  Aber ja, wählen Sie zuerst das optimale Int.  In diesem Projekt habe ich mich, noch bevor ich mir Gedanken über die Optimierung gemacht habe, ein wenig vorzeitig optimiert (was, wie ich Ihnen gerade sagte, nicht erforderlich ist). <br><br>  Schauen wir uns zum Beispiel Felder mit ID an.  Wir wissen, dass wir ungefähr eine Million Sterne haben werden - nicht ein paar Zehntausende, aber keine Milliarde.  Für solche Felder ist es daher am besten, Int32 zu wählen.  Dann wurde mir klar, dass 4 Bytes für Float hier ausreichen.  Double belegt 8, String alle 24, addiert alles - es stellt sich heraus, 152 Bytes.  Wenn Sie sich erinnern, sagte uns früher MemoryLayout das 208. Warum?  Wir müssen tiefer graben. <br><br><img src="https://habrastorage.org/webt/ss/pd/-d/sspd-d52ece7xuninv1aivvbapi.jpeg"><br><br>  Schauen wir uns zunächst Optional an.  Optionale Typen unterscheiden sich darin, dass sie Null speichern, wenn kein Wert zugewiesen ist.  Dies gewährleistet Sicherheit bei der Interaktion mit Objekten.  Wie Sie wissen, kostet eine solche Kennzahl nicht kostenlos: Wenn Sie die size-Eigenschaft eines optionalen Typs anfordern, werden Sie feststellen, dass ein solcher Typ immer ein Byte mehr benötigt.  Wir zahlen für die Möglichkeit, sich für das Nullfeld zu registrieren. <br><br>  Wir möchten kein zusätzliches Byte für eine Variable ausgeben.  Gleichzeitig gefällt uns die Idee, die in optional enthalten ist, sehr gut.  Was soll ich mir einfallen lassen?  Versuchen wir, unsere Struktur umzusetzen. <br><br>  Wählen wir einen Wert aus, der für ein bestimmtes Feld vernünftigerweise als "ungültig" angesehen werden kann und gleichzeitig für den deklarierten Typ geeignet ist.  Für getHipId (Int32) kann es beispielsweise der Wert "-1" sein.  Dies bedeutet, dass unser Feld nicht initialisiert wird.  Hier ist ein solches Fahrrad optional, das auf ein zusätzliches Byte bei Null verzichtet. <br><br>  Mit einem solchen Trick haben wir natürlich auch eine potenzielle Verwundbarkeit.  Um uns vor Fehlern zu schützen, erstellen wir einen Getter für das Feld, der unsere neue Logik unabhängig verwaltet und den Feldwert auf Gültigkeit überprüft. <br><br><img src="https://habrastorage.org/webt/f8/_7/ar/f8_7ar0uns7lzeude7do0avszaw.jpeg"><br><br>  Ein solcher Getter abstrahiert uns die Komplexität einer erfundenen Lösung vollständig. <br>  Wenden Sie sich an unsere StarData.  Ersetzen Sie alle optionalen Typen durch reguläre und sehen Sie, was Schritt zeigt: <br><br><img src="https://habrastorage.org/webt/bw/v4/rf/bwv4rfqgdjkyle-jziflwtbdgjq.jpeg"><br>  Es stellt sich heraus, dass wir beim Eliminieren der Optionen nicht 9 Bytes (ein Byte für jede der neun Optionen), sondern 48 Bytes gespeichert haben. Die Überraschung ist angenehm, aber ich würde gerne wissen, warum dies passiert ist.  Und es geschah aufgrund der Ausrichtung der Daten im Speicher. <br><br><h2>  Datenausrichtung </h2><br>  Denken Sie daran, dass wir vor Swift in Objective-C geschrieben haben und es auf C basierte - und diese Situation geht auch auf C zurück. <br><br>  Durch das Platzieren von Strukturen im Speicher platzieren moderne Prozessoren ihre Elemente nicht in einem kontinuierlichen Strom (nicht „Schulter an Schulter“), sondern in einem Gitter, das inhomogen durch Hohlräume verdünnt ist.  Dies ist Datenausrichtung.  Sie können den Zugriff auf die erforderlichen Datenelemente im Speicher vereinfachen und beschleunigen. <br>  Datenausrichtungsregeln gelten je nach Typ für jede Variable: <br><br><ul><li>  Eine Variable vom Typ char kann am 1., 2., 3., 4. usw. beginnen.  Bytes, da es nur ein Byte an sich benötigt; </li><li>  Eine kurze Variable benötigt 2 Bytes, sodass sie am 2., 4., 6., 8. usw. beginnen kann.  ein Byte (d. h. von jedem geraden Byte); </li><li>  Eine Variable vom Typ float benötigt 4 Bytes, was bedeutet, dass sie mit jedem 4., 8., 12., 16. usw. beginnen kann.  ein Byte (d. h. jedes vierte Byte); </li><li>  Variablen vom Typ Double und String belegen jeweils 8 Byte, sodass sie mit dem 8., 16., 24., 32. usw. beginnen können.  Bytes </li><li>  usw. </li></ul><br><br>  MemoryLayout &lt;&gt; -Objekte verfügen über eine Ausrichtungseigenschaft, die die entsprechende Ausrichtungsregel für den angegebenen Typ zurückgibt. <br><br>  Könnten wir Kenntnisse über Ausrichtungsregeln anwenden, um Code zu optimieren?  Schauen wir uns ein Beispiel an.  Es gibt eine Benutzerstruktur: Für Vorname und Nachname verwenden wir eine reguläre Zeichenfolge, für Mittelname - eine optionale Zeichenfolge (der Benutzer hat möglicherweise keinen solchen Namen).  Im Speicher wird eine Instanz einer solchen Struktur wie folgt platziert: <br><br><img src="https://habrastorage.org/webt/ah/2y/iz/ah2yizmjxwar-9d6gycudjcspv0.jpeg"><br><br>  Wie Sie sehen können, verpflichten Sie die Ausrichtungsregeln, die nächsten 7 Bytes zu überspringen und 80 Bytes für die gesamte Struktur auszugeben, da der optionale mittlere Name 25 Bytes belegt (anstelle von Vielfachen von 8 24 Bytes).  Unabhängig davon, wie Sie Blöcke mit Zeichenfolgen austauschen, ist es hier unmöglich, mit einer geringeren Anzahl von Bytes zu rechnen. <br><br>  Und jetzt ein Beispiel für eine fehlgeschlagene Ausrichtung: <br><br><img src="https://habrastorage.org/webt/ea/ag/ch/eaagch2qax-7hpbvfbvrbkd4xog.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die BadAligned-Struktur deklariert zuerst isHidden vom Typ Bool (1 Byte), dann die Größe vom Typ Double (8 Byte), isInteractable vom Typ Bool (1 Byte) und schließlich das Alter vom Typ Int (ebenfalls 8 Byte). In dieser Reihenfolge deklariert, werden unsere Variablen so im Speicher abgelegt, dass die Gesamtstruktur 32 Bytes belegt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versuchen wir, die Reihenfolge der Deklaration der Felder zu ändern. Wir ordnen sie in aufsteigender Reihenfolge des belegten Volumens an und sehen, wie sich das Bild im Speicher ändert. </font></font><br><br><img src="https://habrastorage.org/webt/qt/de/mw/qtdemwpwvb_tvkd-gnhmx1pfnbm.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unsere Struktur benötigt nicht 32 Bytes, sondern 24. Sparen Sie 25%.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klingt nach einem Tetris-Spiel, nicht wahr? Swift verdankt die C-Sprache seinen Vorfahren. Wenn Sie Felder in einer großen Datenstruktur zufällig deklarieren, verbrauchen Sie mit größerer Wahrscheinlichkeit mehr Speicher als Sie könnten, wenn Ausrichtungsregeln gegeben sind. Versuchen Sie daher, sich an sie zu erinnern und beim Schreiben von Code zu berücksichtigen - dies ist nicht so schwierig. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenden wir uns noch einmal unseren StarData zu. Versuchen wir, die Felder in der Reihenfolge des zunehmenden belegten Volumens anzuordnen. </font></font><br><br><img src="https://habrastorage.org/webt/4r/jj/po/4rjjpozl7hnmfcnx9yb_e4q66xm.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuerst Float und Int32, dann Double und String. Nicht so komplizierter Tetris! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Schritt, den wir erhalten haben, beträgt 152 Bytes. Das heißt, durch die Optimierung der Implementierung von Optionen und die Arbeit mit der Ausrichtung konnten wir die Größe der Struktur von 208 auf 152 Byte reduzieren.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nähern wir uns der Grenze unserer Optimierungsmöglichkeiten? </font><font style="vertical-align: inherit;">Wahrscheinlich ja. </font><font style="vertical-align: inherit;">Es gibt jedoch noch etwas, das Sie und ich nicht ausprobiert haben - etwas ist um eine Größenordnung komplizierter, aber es kann Sie manchmal mit seinem Ergebnis in Erstaunen versetzen.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Domain Logic Accounting </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versuchen Sie, sich auf die Besonderheiten Ihres Dienstes zu konzentrieren. </font><font style="vertical-align: inherit;">Erinnern Sie sich an mein Beispiel mit Schach: Die Idee, den FPS-Indikator zu variieren, wenn sich nichts auf dem Bildschirm ändert, ist nur eine Optimierung unter Berücksichtigung der Domänenlogik der Anwendung.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen Sie sich StarData noch einmal an. Unser offensichtlicher „Engpass“ sind Felder vom Typ String, die wirklich viel Platz beanspruchen. Und hier sind die Einzelheiten wie folgt: Während der Laufzeit bleiben die meisten dieser Zeilen leer! Nur 146 Sterne haben einen "echten" Namen, der im Feld "Eigenname" angegeben ist. Und gl_id ist die ID des Sterns. Der Gliese-Katalog mit 3801 Sternen ist ebenfalls weit von einer Million entfernt. bayer_flamstedt - Flemsteads Bezeichnungen - werden den 3064. Sternen zugeordnet. Der Spektraltyp spectralType ist 4307 mi. Es stellt sich heraus, dass für die meisten Sterne die eingegebenen Zeichenfolgenvariablen leer sind und jeweils 24 Byte belegen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe mir den folgenden Ausweg ausgedacht. Lassen Sie uns ein assoziatives Array als zusätzliche Struktur erhalten. Als Schlüssel - eine eindeutige numerische Kennung vom Typ Int16 als Wert, abhängig vom Vorhandensein der charakteristischen Zeichenfolge - entweder deren Wert oder -1. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In unseren StarData neben ProperName, gl_id, bayer_flamstedt und spectralType schreiben wir den Index, der dem Schlüssel im Array entspricht. Wenn nötig, holen Sie sich die eine oder andere Zeichenfolge, wir fordern den Wert vom Array über den Index an. Es ist nicht erforderlich, dies manuell zu tun - wir implementieren besser einen praktischen sicheren Getter: </font></font><br><br><img src="https://habrastorage.org/webt/n7/i5/bi/n7i5bilqodef52ninsnoilrneci.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Getter ist hier sehr wichtig - es verbirgt die Komplexität unserer eigenen Implementierung vor uns. Ein Array kann als privat registriert werden, jetzt ist es nicht erforderlich, über seine Existenz Bescheid zu wissen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Natürlich hat diese Lösung ein Minus. Das Speichern von Speicher kann die Prozessorlast nur beeinflussen. Mit diesem Schema sind wir gezwungen, ständig auf unser assoziatives Array zuzugreifen. und in den meisten Fällen - vergebens, da die meisten Zeilen leer bleiben und Anfragen "-1" zurückgeben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher musste ich das Konzept der Anwendung leicht ändern. Es wurde beschlossen, dem Benutzer nur dann Informationen über den Stern bereitzustellen, wenn er auf diesen Stern klickt. Erst dann wird die Abfrage an das assoziative Array ausgeführt und die empfangenen Daten werden auf dem Bildschirm angezeigt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trotz der Abstraktion durch Getter müssen wir zugeben, dass wir durch die Einführung eines assoziativen Arrays den Code immer noch erheblich kompliziert haben. Dies geschieht normalerweise während der Optimierung. Daher ist es wichtig, qualitativ hochwertige Unit-Tests durchzuführen, um sicherzustellen, dass unser assoziatives Array nicht zu einem unerwarteten Zeitpunkt versagt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Insgesamt: Schritt gibt uns jetzt 64 Bytes! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist das alles Nein, jetzt müssen wir noch einmal über Ausrichtungsregeln nachdenken: Felder vom Typ Int16 höher anordnen. </font></font><br><br><img src="https://habrastorage.org/webt/qs/yh/hs/qsyhhsoleaji_jnucoeew5fjguq.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt ist alles. Wie Sie sehen, konnten wir mit einer kleinen Anzahl von im Wesentlichen einfachen Methoden die Größe der StarData-Struktur von 208 auf 56 Byte reduzieren. Eine Million Sterne belegen jetzt nicht mehr 500 MB, sondern 130. Viermal weniger!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vergessen Sie nicht die Gefahren einer vorzeitigen Optimierung. </font><font style="vertical-align: inherit;">Wenn Ihre Benutzerdatenstruktur für etwa 20 Benutzer verwendet wird, werden Sie dort nicht so viel gewinnen, dass es sinnvoll ist, dies zu tun. </font><font style="vertical-align: inherit;">Noch wichtiger ist, dass der nächste Entwickler den Code bequem pflegen kann. </font><font style="vertical-align: inherit;">Bitte sagen Sie später nicht "dieser Typ auf der Konferenz sagte, dass die Reihenfolge genau das sein sollte"! </font><font style="vertical-align: inherit;">Mach das nicht nur zum Spaß. </font><font style="vertical-align: inherit;">Für mich sind solche Dinge gute Unterhaltung, ich weiß nicht wie für Sie.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schnelle Compiler-Optimierung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die meisten Programmierer kennen den Schmerz eines langen (unerträglich langen) Zusammenbaus eines Projekts. Sie haben gerade eine kleine Änderung am Code vorgenommen und lehnen sich jetzt zurück und warten, bis der Build abgeschlossen ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Erstellungsprozess kann Ihnen jedoch etwas über Ihren Code erzählen. Dies ist ein ausgezeichneter Indikator für Botnekov. Sie müssen ihn nur an die Arbeit anpassen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Persönlich habe ich die Kompilierung in Xcode recherchiert. Als Werkzeug habe ich den folgenden Befehl verwendet: </font></font><br><br><img src="https://habrastorage.org/webt/1x/36/j6/1x36j61elqsczwzbjldxjmdewtq.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Befehl weist xCode an, die Kompilierungszeit jeder Funktion zu verfolgen und in die Datei culprits.txt zu schreiben. Der Inhalt der Datei wird auf dem Weg sortiert.</font></font><br><br><img src="https://habrastorage.org/webt/zz/ht/rp/zzhtrpbqbipvucqydinougkyzhu.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit meinem einfachen Instrument konnte ich interessante Dinge beobachten. </font><font style="vertical-align: inherit;">Einige Methoden können bis zu 2 Sekunden lang kompiliert werden, wobei nur drei Codezeilen enthalten sind. </font><font style="vertical-align: inherit;">Was könnte der Grund sein? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum Beispiel eine Typ-Compiler-Ausgabe. </font><font style="vertical-align: inherit;">Wenn Sie Typen nicht explizit angeben, muss Swift sie selbst erkennen. </font><font style="vertical-align: inherit;">Diese (ich muss sagen, nicht triviale) Operation erfordert Prozessorzeit, daher ist es aus Sicht des Compilers immer besser, den Typ anzugeben. </font><font style="vertical-align: inherit;">Durch explizites Schreiben der Typen konnte ich die Erstellungszeit der Anwendung einmal von 5 auf 2 (!) Minuten reduzieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber es gibt ein "aber": Code ohne Typen ist noch besser lesbar. </font><font style="vertical-align: inherit;">Und wir haben bereits über Prioritäten gesprochen. </font><font style="vertical-align: inherit;">Optimieren Sie nicht im Voraus: Die Lesbarkeit von Code wird zunächst teurer.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Serveroption </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher habe ich meine Anwendung nur mit Augmented Reality erwähnt. </font><font style="vertical-align: inherit;">Aber basierend auf einer Million Sternen habe ich auch eine Serveranwendung auf Swift erstellt. </font><font style="vertical-align: inherit;">Sie können </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ihn</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seinen Code auf GitHub sehen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dies ist ein API-Dienst, mit dem Sie Informationen über Sterne aus meiner riesigen Datenbank erhalten können. </font><font style="vertical-align: inherit;">Ich konnte es mit denselben Methoden optimieren, die ich für die Anwendung auf ARkit verwendet habe. </font><font style="vertical-align: inherit;">Das Ergebnis in diesem Fall wurde für mich buchstäblich greifbar: Als ich das Volumen auf 500 MB reduzierte, hatte ich die Möglichkeit, es auf einen kostenlosen Bluemix-Server zu stellen. </font><font style="vertical-align: inherit;">Infolgedessen kostet mich mein Service absolut kostenlos.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zusammenfassend </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abschließend eine kurze Zusammenfassung der wichtigsten Gedanken, die ich Ihnen heute ansprechen wollte: </font></font><br><br><ul><li>       .      .      ,          ,     ,           ? </li><li>    ,     unit-. ,          unit-.    ,          . Unit-    ,     . </li><li>   .      ,        .   ,   :   —  . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arbeiten Sie mit der Domänenlogik Ihrer Anwendung. </font><font style="vertical-align: inherit;">Das mächtigste Optimierungswerkzeug ist die geschickte Arbeit mit Domänenlogik. </font><font style="vertical-align: inherit;">Kennen Sie die Funktionen der Arbeit, die Besonderheiten Ihrer Anwendung - versuchen Sie, diese zu berücksichtigen, und suchen Sie nach Ihren "persönlichen" Lösungen.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAM vs. </font><font style="vertical-align: inherit;">CPU </font><font style="vertical-align: inherit;">Geben Sie Ihr Bestes, um das Gleichgewicht zwischen Speicher- und Prozessorauslastung zu halten. </font><font style="vertical-align: inherit;">Dies ist immer sehr schwierig, aber es ist immer noch möglich, in jedem Einzelfall ein bestimmtes Optimum zu finden.</font></font></li></ul><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Ihnen dieser Bericht von der Mobius-Konferenz gefallen hat, beachten Sie bitte, dass </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mobius 2018 Moskau</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vom 8. bis 9. Dezember stattfindet </font><font style="vertical-align: inherit;">, wo es auch viele interessante Dinge geben wird. </font><font style="vertical-align: inherit;">Seit dem 1. November sind die Ticketpreise gestiegen, daher ist es sinnvoll, jetzt eine Entscheidung zu treffen!</font></font></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427845/">https://habr.com/ru/post/de427845/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427833/index.html">Bericht der Joker-Konferenz 2018</a></li>
<li><a href="../de427837/index.html">Die ersten Tage im Entwicklungsteam - so wie es bei uns passiert</a></li>
<li><a href="../de427839/index.html">Benutzerautorisierung in Django durch GSSAPI und Delegierung von Benutzerrechten an den Server</a></li>
<li><a href="../de427841/index.html">Magic Leap Scam</a></li>
<li><a href="../de427843/index.html">Wie man richtig und falsch schläft</a></li>
<li><a href="../de427847/index.html">Neugier und Aufschub beim maschinellen Lernen</a></li>
<li><a href="../de427849/index.html">Gerade mit TM. v3.0</a></li>
<li><a href="../de427853/index.html">Reflexionen über TDD. Warum diese Methode nicht allgemein anerkannt ist</a></li>
<li><a href="../de427855/index.html">MOSDROID-Mitaps in FunCorp</a></li>
<li><a href="../de427857/index.html">Steuerliche und rechtliche Fragen für Anfänger</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>