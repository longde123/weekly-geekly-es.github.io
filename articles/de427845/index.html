<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∑üèª üë©üèª‚Äçüî¨ üìø Wie man eine Million Sterne in ein iPhone passt üö© üë®üèª‚Äçüè≠ üë©üèº‚Äçüè≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eine so romantische Sache wie ein Sternenhimmel und eine so harte Sache wie die Optimierung des Speicherverbrauchs durch eine iOS-Anwendung k√∂nnen dur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie man eine Million Sterne in ein iPhone passt</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/427845/"><img src="https://habrastorage.org/webt/q7/xz/3_/q7xz3_mzwjft238rwmzhjpbnwqm.jpeg"><br><br>  Eine so romantische Sache wie ein Sternenhimmel und eine so harte Sache wie die Optimierung des Speicherverbrauchs durch eine iOS-Anwendung k√∂nnen durchaus zusammenpassen: Es lohnt sich, diesen Sternenhimmel in eine AR-Anwendung zu schieben, und die Frage nach dem gleichen Verbrauch wird sich sofort stellen. <br><br>  In so vielen anderen F√§llen ist es n√ºtzlich, die Speichernutzung zu minimieren.  Dieser Text am Beispiel eines kleinen Projekts zeigt Optimierungsmethoden, die in v√∂llig unterschiedlichen iOS-Anwendungen (und nicht nur in iOS-) n√ºtzlich sein k√∂nnen. <br><a name="habracut"></a><br>  Der Beitrag wurde auf der Grundlage einer Abschrift des Berichts von <b>Conrad Filer</b> von der Piter-Konferenz Mobius 2018 erstellt.  Wir f√ºgen das Video und dann eine Textversion in der ersten Person bei: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/51PJjrh9yTA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Freut mich, alle willkommen zu hei√üen!  Mein Name ist Conrad Filer und unter dem spektakul√§ren Namen "Eine Million Sterne in einem iPhone" werden wir diskutieren, wie Sie die Speichergr√∂√üe Ihrer iOS-Anwendung minimieren k√∂nnen.  Bunt und in Beispielen. <br><br><h2>  Warum optimieren? </h2><br>  Was ermutigt uns generell zur Optimierung, was genau m√∂chten wir erreichen?  Das wollen wir nicht: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/54b/0ef/fbf/54b0effbffa93a27e65a50000242046d.gif"></div><br><br>  Wir m√∂chten nicht, dass der Benutzer wartet.  Das hei√üt, der erste Grund ist die <b>Verk√ºrzung der Startzeit</b> . <br><br>  Ein weiterer Grund ist <b>die Verbesserung der Qualit√§t</b> . <br><br><img src="https://habrastorage.org/webt/dj/6i/0w/dj6i0wxgzgv87xkdvnkiy6ddy48.jpeg"><br><br>  Wir k√∂nnen √ºber die Qualit√§t von Bildern, Ton und sogar KI sprechen.  "Optimierte KI" bedeutet, dass Sie mehr erreichen k√∂nnen - berechnen Sie beispielsweise das Spiel f√ºr eine gr√∂√üere Anzahl von Z√ºgen vorw√§rts. <br><br>  Der dritte Grund ist sehr wichtig: <b>Einsparung von Batteriestrom</b> .  Durch die Optimierung wird der Akku weniger entladen.  Hier ist ein interessanter Vergleich, wenn auch aus der Android-Welt.  Hier verglichen Vulkan und OpenGL ES: <br><br><img src="https://habrastorage.org/webt/9n/ni/dx/9nnidxssdqtw_t2ibkdatsaapfm.jpeg"><br><br>  Die zweite ist schlechter f√ºr mobile Plattformen optimiert.  Wenn Sie die Geschwindigkeit des Batterieverbrauchs beobachten, k√∂nnen Sie feststellen, dass OpenGL ES f√ºr ein √§hnliches Bild viel mehr Ressourcen verbraucht hat als Vulkan. <br><br>  Welche Art der Optimierung kann hier helfen?  Wenn der Benutzer beispielsweise in einem rundenbasierten Spiel √ºber seinen Zug nachdenkt, k√∂nnen Sie die FPS auf Null reduzieren.  Wenn Sie eine 3D-Engine haben, ist es absolut ratsam, einfach alles auszuschalten, w√§hrend der Benutzer nur auf den Bildschirm schaut. <br><br>  Dar√ºber hinaus gibt es Zeiten, in denen Sie ohne einen optimierten Ansatz die eine oder andere erweiterte Funktion nicht implementieren k√∂nnen: Sie wird einfach nicht abgerufen. <br><br><h2>  Kein Fanatismus </h2><br>  Wenn man √ºber Optimierung spricht, kann man sich nur an die These von Donald Knuth erinnern: ‚ÄûWir sollten beispielsweise in 97% der F√§lle die geringe Effizienz vergessen: Vorzeitige Optimierung ist die Wurzel aller √úbel.  Obwohl wir unsere F√§higkeiten in diesen kritischen 3% nicht aufgeben sollten. " <br><br>  In 97% der F√§lle sollten wir uns nicht um Effizienz k√ºmmern, sondern vor allem darum, wie wir unseren Code verst√§ndlich, sicher und testbar machen k√∂nnen.  Wir entwickeln immer noch f√ºr mobile Ger√§te und nicht f√ºr Raumschiffe.  Die Unternehmen, in denen wir arbeiten, sollten nicht zu viel f√ºr die Unterst√ºtzung des von uns geschriebenen Codes bezahlen.  Dar√ºber hinaus ist die Arbeitszeit des Entwicklers mit Kosten verbunden. Wenn Sie sie f√ºr die Optimierung von nicht wesentlichen Dingen ausgeben, geben Sie das Geld des Unternehmens aus.  Nun, die Tatsache, dass gut optimierter Code schwieriger zu verstehen ist, k√∂nnen Sie anhand der Beispiele sehen, die ich Ihnen heute zeigen werde. <br><br>  Im Allgemeinen sollten Sie nach Bedarf sinnvoll priorisieren und optimieren. <br><br><h2>  Die Ans√§tze </h2><br>  Wenn wir an der Optimierung arbeiten, √ºberwachen wir normalerweise entweder die Leistung (lesen: Prozessorlast) oder die Menge des verwendeten Speichers.  Oft stehen diese beiden Optionen in Konflikt, und Sie m√ºssen ein Gleichgewicht zwischen ihnen finden. <br><br>  Im Fall des Prozessors k√∂nnen wir die Anzahl der Prozessorzyklen reduzieren, die f√ºr unsere Operationen erforderlich sind.  Wie Sie wissen, sorgen weniger Prozessorzyklen f√ºr weniger Ladezeit, weniger Batterieverbrauch, bessere Qualit√§t usw. <br><br>  F√ºr iOS-Entwickler bietet Xcode Instruments ein praktisches Time Profiler-Tool.  Sie k√∂nnen damit die Anzahl der CPU-Zyklen verfolgen, die von verschiedenen Teilen Ihrer Anwendung verbracht wurden.  In diesem Bericht geht es nicht um Tools, daher werde ich jetzt nicht auf Details eingehen. Es gab ein gutes Video von WWDC dazu. <br><br>  Sie k√∂nnen ein anderes Ziel w√§hlen - Optimierung aus Gr√ºnden des Ged√§chtnisses.  Wir werden versuchen sicherzustellen, dass unsere Anwendung beim Start in die kleinstm√∂gliche Anzahl von RAM-Zellen passt.  Denken Sie daran, dass die umfangreichsten Anwendungen die ersten Kandidaten f√ºr ein erzwungenes Herunterfahren beim Reinigen sind, das das Betriebssystem ausf√ºhren muss.  Dies wirkt sich daher darauf aus, wie lange Ihre Anwendung im Hintergrund bleibt. <br><br>  Es ist auch wichtig, dass die RAM-Ressource f√ºr verschiedene Ger√§te ebenfalls unterschiedlich ist.  Wenn Sie sich beispielsweise f√ºr die Entwicklung f√ºr die Apple Watch entschieden haben, ist nicht gen√ºgend Speicher vorhanden, und Sie k√∂nnen damit auch optimieren. <br><br>  Schlie√ülich macht manchmal eine kleine Menge an Speicher das Programm auch sehr schnell.  Ich werde ein Beispiel geben.  Hier sind die Strukturen unterschiedlicher Gr√∂√üe in Bytes: <br><br><img src="https://habrastorage.org/webt/mg/2c/_2/mg2c_2se8rpo_gwwnqlfbcaf2ks.jpeg"><br><br>  Element8 enth√§lt 8 Bytes, Element16 - 16 usw. <br><br><img src="https://habrastorage.org/webt/ot/hq/l3/othql3uj6cujllgs99m_ypmkok8.jpeg"><br><br>  Wir werden Arrays erstellen, eines f√ºr jeden unserer Strukturtypen.  Die Dimension aller Arrays ist gleich - 10.000 Elemente.  Jede Struktur enth√§lt eine andere Anzahl von Feldern (ansteigend);  Feld n ist das erste Feld und ist dementsprechend in allen Strukturen vorhanden. <br><br>  Versuchen wir nun Folgendes: F√ºr jedes Array berechnen wir die Summe aller seiner Felder n.  Das hei√üt, jedes Mal werden wir die gleiche Anzahl von Elementen (10.000 St√ºck) summieren.  Der einzige Unterschied besteht darin, dass f√ºr jede Summe die Variable n aus Strukturen unterschiedlicher Gr√∂√üe extrahiert wird.  Uns interessiert, ob die Summierung dieselbe Zeit dauert. <br><br>  Das Ergebnis ist folgendes: <br><br><img src="https://habrastorage.org/webt/el/mu/k1/elmuk1tm_yaku9exe4xgbaw8gp4.jpeg"><br><br>  Die Grafik zeigt die Abh√§ngigkeit der Summationszeit von der Gr√∂√üe der im Array verwendeten Struktur.  Es stellt sich heraus, dass das Abrufen des Feldes n von einer gr√∂√üeren Struktur l√§nger ist und daher die Summierungsoperation l√§nger dauert. <br>  Viele von Ihnen haben bereits verstanden, warum dies geschieht. <br><br>  Der Prozessor verf√ºgt √ºber L1-, L2-Caches (manchmal sogar L3 und L4).  Der Prozessor greift direkt und schnell auf diese Art von Speicher zu. <br><br><img src="https://habrastorage.org/webt/u1/yy/r9/u1yyr9z2pxbwcffecy8i_xoa5qq.jpeg"><br><br>  Es gibt Caches, um die Wiederverwendung von Daten zu beschleunigen.  Angenommen, wir arbeiten mit Arrays.  Wenn das vom Prozessor ben√∂tigte Array bereits in einem der Caches vorhanden ist, wurde es vom Prozessor bereits fr√ºher ben√∂tigt.  In diesem Moment forderte er sie aus dem Hauptspeicher an, legte sie in den Cache, f√ºhrte alle erforderlichen Operationen mit ihnen durch, wonach diese Daten liegen blieben (keine Zeit hatten, von anderen gel√∂scht zu werden). <br><br><img src="https://habrastorage.org/webt/qt/cd/om/qtcdomuam8uo4cz2tnkevtmvxuk.jpeg"><br><br>  Die Gr√∂√üe der L1-, L2-Caches ist nicht so gro√ü.  Das Array, das der Prozessor zum Arbeiten ben√∂tigt, kann gr√∂√üer sein.  Um die Operation f√ºr ein solches Array vollst√§ndig auszuf√ºhren, m√ºssen wir es in Teilen in den Cache entladen und diese Teile einzeln bearbeiten.  Aufgrund st√§ndiger Anforderungen an den Hauptspeicher dauert die Verarbeitung unseres Arrays viel l√§nger. <br><br>  Versuchen Sie beim Programmieren von Datenstrukturen, die Caches zu ber√ºcksichtigen.  Es ist m√∂glich, dass Sie durch Reduzieren der Gr√∂√üe Ihrer Datenstruktur die erfolgreiche Cache-Kapazit√§t erreichen und die Operationen beschleunigen, die in Zukunft daran ausgef√ºhrt werden.  Die Interaktion mit dem Hauptspeicher war, ist und bleibt h√∂chstwahrscheinlich ein wesentlicher Faktor f√ºr die Produktivit√§t - selbst wenn Sie f√ºr moderne Hochleistungsger√§te auf Swift schreiben. <br><br><h2>  CPU vs RAM: verz√∂gerte Initialisierung </h2><br>  Obwohl in einigen F√§llen, wenn der verwendete Speicher reduziert wird, das Programm schneller zu arbeiten beginnt, gibt es F√§lle, in denen diese beiden Metriken im Gegenteil in Konflikt stehen.  Ich werde ein Beispiel mit dem Konzept der verz√∂gerten Initialisierung geben. <br><br>  Angenommen, wir haben eine makeHeavyObject () -Methode, die ein gro√ües Objekt zur√ºckgibt.  Diese Methode initialisiert die Variable lazilyCalculated. <br><br><img src="https://habrastorage.org/webt/-y/2v/4l/-y2v4lzluwid2sxmelau-qp9yiu.jpeg"><br><br>  Der Modifikator "Lazy" setzt die Variable "LazyCalculated" auf "Lazy Initialization".  Dies bedeutet, dass ihm nur dann ein Wert zugewiesen wird, wenn der erste Aufruf w√§hrend der Ausf√ºhrung erfolgt.  Dann funktioniert die Methode makeHeavyObject () und das resultierende Objekt wird der Variablen lazilyCalculated zugewiesen. <br><br>  Was ist das Plus hier?  Ab dem Moment der Initialisierung (wenn auch sp√§ter, aber es wird ausgef√ºhrt) befindet sich ein Objekt im Speicher.  Sein Wert wird gez√§hlt, er ist einsatzbereit - stellen Sie einfach eine Anfrage.  Eine andere Sache ist, dass unser Objekt gro√ü ist und ab dem Moment der Initialisierung den L√∂wenanteil der Zellen im Ged√§chtnis einnimmt. <br><br>  Sie k√∂nnen auch in die andere Richtung gehen - speichern Sie den Wert des Feldes √ºberhaupt nicht: <br><br><img src="https://habrastorage.org/webt/rd/dj/td/rddjtdebqiiyidg1vravbwzreli.jpeg"><br><br>  Bei jedem Link zum Feld lazilyCalculated wird die Methode makeHeavyObject () erneut ausgef√ºhrt.  Der Wert wird an den Abfragepunkt zur√ºckgegeben, w√§hrend er nicht im Speicher abgelegt wird.  Wie Sie sehen k√∂nnen, ist das Speichern einer Variablen optional. <br><br>  Was ist teurer - ein gro√ües Objekt im Speicher zu speichern, aber keine CPU-Zeit zu verschwenden oder die Methode jedes Mal aufzurufen, wenn wir unser Feld ben√∂tigen, w√§hrend gleichzeitig Speicherplatz gespart wird?  Sollten Sie einen vorgefertigten Wert zur Hand haben oder diesen im laufenden Betrieb berechnen?  Diese Art von Dilemma tritt h√§ufig auf, wo immer Sie Ihre Berechnungen durchf√ºhren - auf einem Remote-Server oder auf Ihrem lokalen Computer, unabh√§ngig davon, mit welchem ‚Äã‚ÄãCache Sie arbeiten m√ºssen.  Sie m√ºssen eine Entscheidung treffen, die auf den Systembeschr√§nkungen in diesem speziellen Fall basiert. <br><br><h2>  Optimierungszyklus </h2><br><br><img src="https://habrastorage.org/webt/3y/jb/tz/3yjbtzvba5c5cmvdmyxws4ubev8.jpeg"><br><br>  Was auch immer Sie optimieren, Ihre Arbeit basiert in der Regel auf demselben Algorithmus.  Zun√§chst untersuchen Sie den Code, das Profil / die Kennzahl (in Xcode mit den entsprechenden Tools) und versuchen, die Engp√§sse zu identifizieren.  Ordnen Sie die Methoden im Wesentlichen danach an, wie lange die Ausf√ºhrung dauert.  Schauen Sie sich dann die oberen Zeilen an, um festzustellen, was optimiert werden soll. <br><br>  Wenn Sie ein Objekt ausw√§hlen, stellen Sie sich die Aufgabe (oder stellen wissenschaftlich gesehen eine Hypothese auf): Durch Anwendung dieser oder anderer Optimierungsmethoden k√∂nnen Sie den ausgew√§hlten Code schneller arbeiten lassen. <br><br>  Als n√§chstes versuchen Sie zu optimieren.  Nach jeder √Ñnderung sehen Sie sich die Leistungsindikatoren an und bewerten, wie effektiv die √Ñnderung war und wie weit Sie vorankommen konnten. <br><br>  Genau wie in einer wissenschaftlichen Arbeit: Spekulation, Experiment, Analyse der Ergebnisse.  Sie durchlaufen diesen Aktionszyklus immer wieder.  Die Praxis zeigt, dass die auf diese Weise konstruierte Arbeit es Ihnen wirklich erm√∂glicht, die Botneks einzeln zu eliminieren. <br><br><h2>  Unit-Tests </h2><br><br><img src="https://habrastorage.org/webt/yp/c3/zl/ypc3zlrxtbnbkp9cwekladdj-ug.jpeg"><br><br>  Kurz zu Unit-Tests: Wir haben einige Funktionen, die wir testen, einige Eingabedateneingaben und Ausgabedatenausgaben;  Wenn wir als Eingabe Eingaben erhalten, sollte unsere Funktion immer Ausgaben zur√ºckgeben, und keine unserer Optimierungen sollte diese Eigenschaft verletzen. <br><br>  Unit-Tests helfen uns, die Aufschl√ºsselung zu verfolgen.  Wenn unsere Funktion als Reaktion auf Eingaben keine Ausgabe mehr zur√ºckgibt, haben wir entweder direkt oder indirekt den alten Arbeitsablauf unserer Funktion ge√§ndert. <br><br>  Versuchen Sie nicht einmal, mit der Optimierung zu beginnen, wenn Sie nicht einen gro√üz√ºgigen Teil der Komponententests in Ihren Code geschrieben haben.  Sie sollten in der Lage sein, einen Regressionstest durchzuf√ºhren.  Wenn Sie sich GitHub my Commits in meiner Beispielanwendung ansehen, auf die ich noch eingehen werde, k√∂nnen Sie sehen, dass einige meiner Optimierungen Fehler mit sich gebracht haben. <br><br>  Und jetzt zum lustigen Teil, gehen wir weiter zu den Sternen. <br><br><h2>  Millionen Sterne </h2><br>  Es gibt eine gro√üe (riesige) Datenbank, die eine Million Sterne beschreibt.  Dar√ºber hinaus habe ich mehrere Anwendungen erstellt.  Einer von ihnen verwendet Augmented Reality und zeichnet in Echtzeit Sterne von der Kamera des Telefons auf das Bild.  Jetzt werde ich es in Aktion demonstrieren: <br><br><img src="https://habrastorage.org/webt/cr/rs/jv/crrsjv1iezyd2hzyxdxpjricu0u.png"><br><br>  Ohne Lichter der Stadt kann eine Person bis zu 8.000 Sterne am Himmel unterscheiden.  Ich w√ºrde ungef√§hr 1,8 MB ben√∂tigen, um 8.000 Datens√§tze zu speichern.  Im Prinzip akzeptabel.  Aber ich wollte die Sterne hinzuf√ºgen, die eine Person durch ein Teleskop sehen kann - es stellte sich heraus, dass es ungef√§hr 120.000 Sterne waren (laut dem sogenannten Hipparcos-Katalog, der inzwischen veraltet ist).  Dies erforderte bereits 27 MB.  Und unter den modernen gemeinfreien Katalogen finden Sie einen mit rund 2.500.000 Sternen.  Eine solche Datenbank w√ºrde bereits etwa 560 MB belegen.  Wie Sie sehen, wird bereits viel Speicher ben√∂tigt.  Wir wollen aber nicht nur eine Datenbank, sondern eine darauf basierende Anwendung, in der es ARKit, SceneKit und andere Dinge gibt, die ebenfalls Speicher ben√∂tigen. <br><br>  Was tun? <br>  Wir werden die Sterne optimieren. <br><br><h2>  MemoryLayout-Tool </h2><br>  Sie k√∂nnen die Gr√∂√üe des gesamten Programms bewerten.  F√ºr Schmuckarbeiten wie die Optimierung ben√∂tigen Sie jedoch Tools zum Sch√§tzen der Gr√∂√üe jeder einzelnen Datenstruktur. <br><br>  Mit Swift k√∂nnen Sie dies ganz einfach tun - mithilfe von MemoryLayout &lt;&gt; -Objekten.  Sie deklarieren ein MemoryLayout &lt;&gt; und geben die f√ºr Sie interessante Datenstruktur als generischen Typ an.  Unter Bezugnahme auf die Eigenschaften des empfangenen Objekts k√∂nnen Sie nun eine Reihe n√ºtzlicher Informationen zu Ihrer Struktur erhalten. <br><br><img src="https://habrastorage.org/webt/4b/dy/ki/4bdykiugciapow4d-avqvmfhp7e.jpeg"><br><br>  Die size-Eigenschaft gibt die Anzahl der Bytes an, die von einer Instanz der Struktur belegt werden. <br>  Nun zur Schritt-Eigenschaft.  M√∂glicherweise haben Sie bemerkt, dass die Gr√∂√üe des Arrays in der Regel nicht der Summe der Gr√∂√üen seiner Bestandteile entspricht, sondern diese √ºberschreitet.  Offensichtlich bleibt etwas ‚ÄûLuft‚Äú zwischen den Elementen im Speicher.  Um den Abstand zwischen aufeinanderfolgenden Elementen in einem benachbarten Array abzusch√§tzen, verwenden wir die Eigenschaft stride.  Wenn Sie es mit der Anzahl der Elemente im Array multiplizieren, erhalten Sie seine Gr√∂√üe. <br><br><img src="https://habrastorage.org/webt/vo/9x/6i/vo9x6ivnzz5-nzdhowe4cvtox3u.jpeg"><br><br>  StarData, unsere experimentelle Struktur, in ihrem urspr√ºnglichen, nicht optimierten Zustand: <br><br><img src="https://habrastorage.org/webt/no/ku/51/noku51vmtamzm8yk1cclohg1-ea.jpeg"><br><br>  Hier ist eine Datenstruktur zum Speichern von Daten √ºber einen Stern.  Sie m√ºssen sich nicht mit den Bedeutungen der einzelnen Elemente befassen.  Es ist jetzt wichtiger, auf die Typen zu achten: Float-Variablen, die die Koordinaten des Sterns speichern (tats√§chlich Breiten- und L√§ngengrad), mehrere Int32 f√ºr verschiedene IDs, String zum Speichern von Namen und Namen verschiedener Klassifikationen;  Es gibt einen Abstand, eine Farbe und einige andere Gr√∂√üen, die f√ºr die korrekte Anzeige eines Sterns erforderlich sind. <br><br>  Wir bitten um die Schritt-Eigenschaft: <br><br><img src="https://habrastorage.org/webt/ob/pu/l-/obpul-qs28mwnfqhfnay3b5ml-m.jpeg"><br><br>  Im Moment wiegt unsere Struktur 208 Bytes.  Eine Million solcher Strukturen ben√∂tigt 250 MB - das ist, wie Sie wissen, zu viel.  Daher ist eine Optimierung erforderlich. <br><br><h2>  Korrigieren Sie int </h2><br>  Die Tatsache, dass es verschiedene Arten von Int gibt, wird in den ersten Programmierstunden erkl√§rt.  Das f√ºr uns bekannteste Int in Swift hei√üt Int8.  Es belegt 8 Bit (1 Byte) und kann Werte von -128 bis einschlie√ülich 127 speichern.  Es gibt auch andere Ints: <br><ul><li>  Int16 hat eine Gr√∂√üe von 2 Bytes und einen Wertebereich von -32.768 bis 32.767. </li><li>  Int32 mit einer Gr√∂√üe von 4 Bytes reicht der Wertebereich von -2.147.483.648 bis 2.147.483.647; </li><li>  Int64 (oder nur Int) ist 8 Byte gro√ü, der Wertebereich reicht von -9.223.372.036.854.775.808 bis 9.223.372.036.854.775.807. </li></ul><br><br>  Wahrscheinlich denken diejenigen von Ihnen, die sich mit Webentwicklung befasst und sich mit SQL befasst haben, bereits dar√ºber nach.  Aber ja, w√§hlen Sie zuerst das optimale Int.  In diesem Projekt habe ich mich, noch bevor ich mir Gedanken √ºber die Optimierung gemacht habe, ein wenig vorzeitig optimiert (was, wie ich Ihnen gerade sagte, nicht erforderlich ist). <br><br>  Schauen wir uns zum Beispiel Felder mit ID an.  Wir wissen, dass wir ungef√§hr eine Million Sterne haben werden - nicht ein paar Zehntausende, aber keine Milliarde.  F√ºr solche Felder ist es daher am besten, Int32 zu w√§hlen.  Dann wurde mir klar, dass 4 Bytes f√ºr Float hier ausreichen.  Double belegt 8, String alle 24, addiert alles - es stellt sich heraus, 152 Bytes.  Wenn Sie sich erinnern, sagte uns fr√ºher MemoryLayout das 208. Warum?  Wir m√ºssen tiefer graben. <br><br><img src="https://habrastorage.org/webt/ss/pd/-d/sspd-d52ece7xuninv1aivvbapi.jpeg"><br><br>  Schauen wir uns zun√§chst Optional an.  Optionale Typen unterscheiden sich darin, dass sie Null speichern, wenn kein Wert zugewiesen ist.  Dies gew√§hrleistet Sicherheit bei der Interaktion mit Objekten.  Wie Sie wissen, kostet eine solche Kennzahl nicht kostenlos: Wenn Sie die size-Eigenschaft eines optionalen Typs anfordern, werden Sie feststellen, dass ein solcher Typ immer ein Byte mehr ben√∂tigt.  Wir zahlen f√ºr die M√∂glichkeit, sich f√ºr das Nullfeld zu registrieren. <br><br>  Wir m√∂chten kein zus√§tzliches Byte f√ºr eine Variable ausgeben.  Gleichzeitig gef√§llt uns die Idee, die in optional enthalten ist, sehr gut.  Was soll ich mir einfallen lassen?  Versuchen wir, unsere Struktur umzusetzen. <br><br>  W√§hlen wir einen Wert aus, der f√ºr ein bestimmtes Feld vern√ºnftigerweise als "ung√ºltig" angesehen werden kann und gleichzeitig f√ºr den deklarierten Typ geeignet ist.  F√ºr getHipId (Int32) kann es beispielsweise der Wert "-1" sein.  Dies bedeutet, dass unser Feld nicht initialisiert wird.  Hier ist ein solches Fahrrad optional, das auf ein zus√§tzliches Byte bei Null verzichtet. <br><br>  Mit einem solchen Trick haben wir nat√ºrlich auch eine potenzielle Verwundbarkeit.  Um uns vor Fehlern zu sch√ºtzen, erstellen wir einen Getter f√ºr das Feld, der unsere neue Logik unabh√§ngig verwaltet und den Feldwert auf G√ºltigkeit √ºberpr√ºft. <br><br><img src="https://habrastorage.org/webt/f8/_7/ar/f8_7ar0uns7lzeude7do0avszaw.jpeg"><br><br>  Ein solcher Getter abstrahiert uns die Komplexit√§t einer erfundenen L√∂sung vollst√§ndig. <br>  Wenden Sie sich an unsere StarData.  Ersetzen Sie alle optionalen Typen durch regul√§re und sehen Sie, was Schritt zeigt: <br><br><img src="https://habrastorage.org/webt/bw/v4/rf/bwv4rfqgdjkyle-jziflwtbdgjq.jpeg"><br>  Es stellt sich heraus, dass wir beim Eliminieren der Optionen nicht 9 Bytes (ein Byte f√ºr jede der neun Optionen), sondern 48 Bytes gespeichert haben. Die √úberraschung ist angenehm, aber ich w√ºrde gerne wissen, warum dies passiert ist.  Und es geschah aufgrund der Ausrichtung der Daten im Speicher. <br><br><h2>  Datenausrichtung </h2><br>  Denken Sie daran, dass wir vor Swift in Objective-C geschrieben haben und es auf C basierte - und diese Situation geht auch auf C zur√ºck. <br><br>  Durch das Platzieren von Strukturen im Speicher platzieren moderne Prozessoren ihre Elemente nicht in einem kontinuierlichen Strom (nicht ‚ÄûSchulter an Schulter‚Äú), sondern in einem Gitter, das inhomogen durch Hohlr√§ume verd√ºnnt ist.  Dies ist Datenausrichtung.  Sie k√∂nnen den Zugriff auf die erforderlichen Datenelemente im Speicher vereinfachen und beschleunigen. <br>  Datenausrichtungsregeln gelten je nach Typ f√ºr jede Variable: <br><br><ul><li>  Eine Variable vom Typ char kann am 1., 2., 3., 4. usw. beginnen.  Bytes, da es nur ein Byte an sich ben√∂tigt; </li><li>  Eine kurze Variable ben√∂tigt 2 Bytes, sodass sie am 2., 4., 6., 8. usw. beginnen kann.  ein Byte (d. h. von jedem geraden Byte); </li><li>  Eine Variable vom Typ float ben√∂tigt 4 Bytes, was bedeutet, dass sie mit jedem 4., 8., 12., 16. usw. beginnen kann.  ein Byte (d. h. jedes vierte Byte); </li><li>  Variablen vom Typ Double und String belegen jeweils 8 Byte, sodass sie mit dem 8., 16., 24., 32. usw. beginnen k√∂nnen.  Bytes </li><li>  usw. </li></ul><br><br>  MemoryLayout &lt;&gt; -Objekte verf√ºgen √ºber eine Ausrichtungseigenschaft, die die entsprechende Ausrichtungsregel f√ºr den angegebenen Typ zur√ºckgibt. <br><br>  K√∂nnten wir Kenntnisse √ºber Ausrichtungsregeln anwenden, um Code zu optimieren?  Schauen wir uns ein Beispiel an.  Es gibt eine Benutzerstruktur: F√ºr Vorname und Nachname verwenden wir eine regul√§re Zeichenfolge, f√ºr Mittelname - eine optionale Zeichenfolge (der Benutzer hat m√∂glicherweise keinen solchen Namen).  Im Speicher wird eine Instanz einer solchen Struktur wie folgt platziert: <br><br><img src="https://habrastorage.org/webt/ah/2y/iz/ah2yizmjxwar-9d6gycudjcspv0.jpeg"><br><br>  Wie Sie sehen k√∂nnen, verpflichten Sie die Ausrichtungsregeln, die n√§chsten 7 Bytes zu √ºberspringen und 80 Bytes f√ºr die gesamte Struktur auszugeben, da der optionale mittlere Name 25 Bytes belegt (anstelle von Vielfachen von 8 24 Bytes).  Unabh√§ngig davon, wie Sie Bl√∂cke mit Zeichenfolgen austauschen, ist es hier unm√∂glich, mit einer geringeren Anzahl von Bytes zu rechnen. <br><br>  Und jetzt ein Beispiel f√ºr eine fehlgeschlagene Ausrichtung: <br><br><img src="https://habrastorage.org/webt/ea/ag/ch/eaagch2qax-7hpbvfbvrbkd4xog.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die BadAligned-Struktur deklariert zuerst isHidden vom Typ Bool (1 Byte), dann die Gr√∂√üe vom Typ Double (8 Byte), isInteractable vom Typ Bool (1 Byte) und schlie√ülich das Alter vom Typ Int (ebenfalls 8 Byte). In dieser Reihenfolge deklariert, werden unsere Variablen so im Speicher abgelegt, dass die Gesamtstruktur 32 Bytes belegt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versuchen wir, die Reihenfolge der Deklaration der Felder zu √§ndern. Wir ordnen sie in aufsteigender Reihenfolge des belegten Volumens an und sehen, wie sich das Bild im Speicher √§ndert. </font></font><br><br><img src="https://habrastorage.org/webt/qt/de/mw/qtdemwpwvb_tvkd-gnhmx1pfnbm.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unsere Struktur ben√∂tigt nicht 32 Bytes, sondern 24. Sparen Sie 25%.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klingt nach einem Tetris-Spiel, nicht wahr? Swift verdankt die C-Sprache seinen Vorfahren. Wenn Sie Felder in einer gro√üen Datenstruktur zuf√§llig deklarieren, verbrauchen Sie mit gr√∂√üerer Wahrscheinlichkeit mehr Speicher als Sie k√∂nnten, wenn Ausrichtungsregeln gegeben sind. Versuchen Sie daher, sich an sie zu erinnern und beim Schreiben von Code zu ber√ºcksichtigen - dies ist nicht so schwierig. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenden wir uns noch einmal unseren StarData zu. Versuchen wir, die Felder in der Reihenfolge des zunehmenden belegten Volumens anzuordnen. </font></font><br><br><img src="https://habrastorage.org/webt/4r/jj/po/4rjjpozl7hnmfcnx9yb_e4q66xm.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuerst Float und Int32, dann Double und String. Nicht so komplizierter Tetris! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Schritt, den wir erhalten haben, betr√§gt 152 Bytes. Das hei√üt, durch die Optimierung der Implementierung von Optionen und die Arbeit mit der Ausrichtung konnten wir die Gr√∂√üe der Struktur von 208 auf 152 Byte reduzieren.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√§hern wir uns der Grenze unserer Optimierungsm√∂glichkeiten? </font><font style="vertical-align: inherit;">Wahrscheinlich ja. </font><font style="vertical-align: inherit;">Es gibt jedoch noch etwas, das Sie und ich nicht ausprobiert haben - etwas ist um eine Gr√∂√üenordnung komplizierter, aber es kann Sie manchmal mit seinem Ergebnis in Erstaunen versetzen.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Domain Logic Accounting </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versuchen Sie, sich auf die Besonderheiten Ihres Dienstes zu konzentrieren. </font><font style="vertical-align: inherit;">Erinnern Sie sich an mein Beispiel mit Schach: Die Idee, den FPS-Indikator zu variieren, wenn sich nichts auf dem Bildschirm √§ndert, ist nur eine Optimierung unter Ber√ºcksichtigung der Dom√§nenlogik der Anwendung.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen Sie sich StarData noch einmal an. Unser offensichtlicher ‚ÄûEngpass‚Äú sind Felder vom Typ String, die wirklich viel Platz beanspruchen. Und hier sind die Einzelheiten wie folgt: W√§hrend der Laufzeit bleiben die meisten dieser Zeilen leer! Nur 146 Sterne haben einen "echten" Namen, der im Feld "Eigenname" angegeben ist. Und gl_id ist die ID des Sterns. Der Gliese-Katalog mit 3801 Sternen ist ebenfalls weit von einer Million entfernt. bayer_flamstedt - Flemsteads Bezeichnungen - werden den 3064. Sternen zugeordnet. Der Spektraltyp spectralType ist 4307 mi. Es stellt sich heraus, dass f√ºr die meisten Sterne die eingegebenen Zeichenfolgenvariablen leer sind und jeweils 24 Byte belegen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe mir den folgenden Ausweg ausgedacht. Lassen Sie uns ein assoziatives Array als zus√§tzliche Struktur erhalten. Als Schl√ºssel - eine eindeutige numerische Kennung vom Typ Int16 als Wert, abh√§ngig vom Vorhandensein der charakteristischen Zeichenfolge - entweder deren Wert oder -1. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In unseren StarData neben ProperName, gl_id, bayer_flamstedt und spectralType schreiben wir den Index, der dem Schl√ºssel im Array entspricht. Wenn n√∂tig, holen Sie sich die eine oder andere Zeichenfolge, wir fordern den Wert vom Array √ºber den Index an. Es ist nicht erforderlich, dies manuell zu tun - wir implementieren besser einen praktischen sicheren Getter: </font></font><br><br><img src="https://habrastorage.org/webt/n7/i5/bi/n7i5bilqodef52ninsnoilrneci.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Getter ist hier sehr wichtig - es verbirgt die Komplexit√§t unserer eigenen Implementierung vor uns. Ein Array kann als privat registriert werden, jetzt ist es nicht erforderlich, √ºber seine Existenz Bescheid zu wissen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nat√ºrlich hat diese L√∂sung ein Minus. Das Speichern von Speicher kann die Prozessorlast nur beeinflussen. Mit diesem Schema sind wir gezwungen, st√§ndig auf unser assoziatives Array zuzugreifen. und in den meisten F√§llen - vergebens, da die meisten Zeilen leer bleiben und Anfragen "-1" zur√ºckgeben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher musste ich das Konzept der Anwendung leicht √§ndern. Es wurde beschlossen, dem Benutzer nur dann Informationen √ºber den Stern bereitzustellen, wenn er auf diesen Stern klickt. Erst dann wird die Abfrage an das assoziative Array ausgef√ºhrt und die empfangenen Daten werden auf dem Bildschirm angezeigt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trotz der Abstraktion durch Getter m√ºssen wir zugeben, dass wir durch die Einf√ºhrung eines assoziativen Arrays den Code immer noch erheblich kompliziert haben. Dies geschieht normalerweise w√§hrend der Optimierung. Daher ist es wichtig, qualitativ hochwertige Unit-Tests durchzuf√ºhren, um sicherzustellen, dass unser assoziatives Array nicht zu einem unerwarteten Zeitpunkt versagt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Insgesamt: Schritt gibt uns jetzt 64 Bytes! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist das alles Nein, jetzt m√ºssen wir noch einmal √ºber Ausrichtungsregeln nachdenken: Felder vom Typ Int16 h√∂her anordnen. </font></font><br><br><img src="https://habrastorage.org/webt/qs/yh/hs/qsyhhsoleaji_jnucoeew5fjguq.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt ist alles. Wie Sie sehen, konnten wir mit einer kleinen Anzahl von im Wesentlichen einfachen Methoden die Gr√∂√üe der StarData-Struktur von 208 auf 56 Byte reduzieren. Eine Million Sterne belegen jetzt nicht mehr 500 MB, sondern 130. Viermal weniger!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vergessen Sie nicht die Gefahren einer vorzeitigen Optimierung. </font><font style="vertical-align: inherit;">Wenn Ihre Benutzerdatenstruktur f√ºr etwa 20 Benutzer verwendet wird, werden Sie dort nicht so viel gewinnen, dass es sinnvoll ist, dies zu tun. </font><font style="vertical-align: inherit;">Noch wichtiger ist, dass der n√§chste Entwickler den Code bequem pflegen kann. </font><font style="vertical-align: inherit;">Bitte sagen Sie sp√§ter nicht "dieser Typ auf der Konferenz sagte, dass die Reihenfolge genau das sein sollte"! </font><font style="vertical-align: inherit;">Mach das nicht nur zum Spa√ü. </font><font style="vertical-align: inherit;">F√ºr mich sind solche Dinge gute Unterhaltung, ich wei√ü nicht wie f√ºr Sie.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schnelle Compiler-Optimierung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die meisten Programmierer kennen den Schmerz eines langen (unertr√§glich langen) Zusammenbaus eines Projekts. Sie haben gerade eine kleine √Ñnderung am Code vorgenommen und lehnen sich jetzt zur√ºck und warten, bis der Build abgeschlossen ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Erstellungsprozess kann Ihnen jedoch etwas √ºber Ihren Code erz√§hlen. Dies ist ein ausgezeichneter Indikator f√ºr Botnekov. Sie m√ºssen ihn nur an die Arbeit anpassen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pers√∂nlich habe ich die Kompilierung in Xcode recherchiert. Als Werkzeug habe ich den folgenden Befehl verwendet: </font></font><br><br><img src="https://habrastorage.org/webt/1x/36/j6/1x36j61elqsczwzbjldxjmdewtq.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Befehl weist xCode an, die Kompilierungszeit jeder Funktion zu verfolgen und in die Datei culprits.txt zu schreiben. Der Inhalt der Datei wird auf dem Weg sortiert.</font></font><br><br><img src="https://habrastorage.org/webt/zz/ht/rp/zzhtrpbqbipvucqydinougkyzhu.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit meinem einfachen Instrument konnte ich interessante Dinge beobachten. </font><font style="vertical-align: inherit;">Einige Methoden k√∂nnen bis zu 2 Sekunden lang kompiliert werden, wobei nur drei Codezeilen enthalten sind. </font><font style="vertical-align: inherit;">Was k√∂nnte der Grund sein? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum Beispiel eine Typ-Compiler-Ausgabe. </font><font style="vertical-align: inherit;">Wenn Sie Typen nicht explizit angeben, muss Swift sie selbst erkennen. </font><font style="vertical-align: inherit;">Diese (ich muss sagen, nicht triviale) Operation erfordert Prozessorzeit, daher ist es aus Sicht des Compilers immer besser, den Typ anzugeben. </font><font style="vertical-align: inherit;">Durch explizites Schreiben der Typen konnte ich die Erstellungszeit der Anwendung einmal von 5 auf 2 (!) Minuten reduzieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber es gibt ein "aber": Code ohne Typen ist noch besser lesbar. </font><font style="vertical-align: inherit;">Und wir haben bereits √ºber Priorit√§ten gesprochen. </font><font style="vertical-align: inherit;">Optimieren Sie nicht im Voraus: Die Lesbarkeit von Code wird zun√§chst teurer.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Serveroption </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher habe ich meine Anwendung nur mit Augmented Reality erw√§hnt. </font><font style="vertical-align: inherit;">Aber basierend auf einer Million Sternen habe ich auch eine Serveranwendung auf Swift erstellt. </font><font style="vertical-align: inherit;">Sie k√∂nnen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ihn</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seinen Code auf GitHub sehen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dies ist ein API-Dienst, mit dem Sie Informationen √ºber Sterne aus meiner riesigen Datenbank erhalten k√∂nnen. </font><font style="vertical-align: inherit;">Ich konnte es mit denselben Methoden optimieren, die ich f√ºr die Anwendung auf ARkit verwendet habe. </font><font style="vertical-align: inherit;">Das Ergebnis in diesem Fall wurde f√ºr mich buchst√§blich greifbar: Als ich das Volumen auf 500 MB reduzierte, hatte ich die M√∂glichkeit, es auf einen kostenlosen Bluemix-Server zu stellen. </font><font style="vertical-align: inherit;">Infolgedessen kostet mich mein Service absolut kostenlos.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zusammenfassend </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abschlie√üend eine kurze Zusammenfassung der wichtigsten Gedanken, die ich Ihnen heute ansprechen wollte: </font></font><br><br><ul><li>       .      .      ,          ,     ,           ? </li><li>    ,     unit-. ,          unit-.    ,          . Unit-    ,     . </li><li>   .      ,        .   ,   :   ‚Äî  . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arbeiten Sie mit der Dom√§nenlogik Ihrer Anwendung. </font><font style="vertical-align: inherit;">Das m√§chtigste Optimierungswerkzeug ist die geschickte Arbeit mit Dom√§nenlogik. </font><font style="vertical-align: inherit;">Kennen Sie die Funktionen der Arbeit, die Besonderheiten Ihrer Anwendung - versuchen Sie, diese zu ber√ºcksichtigen, und suchen Sie nach Ihren "pers√∂nlichen" L√∂sungen.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAM vs. </font><font style="vertical-align: inherit;">CPU </font><font style="vertical-align: inherit;">Geben Sie Ihr Bestes, um das Gleichgewicht zwischen Speicher- und Prozessorauslastung zu halten. </font><font style="vertical-align: inherit;">Dies ist immer sehr schwierig, aber es ist immer noch m√∂glich, in jedem Einzelfall ein bestimmtes Optimum zu finden.</font></font></li></ul><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Ihnen dieser Bericht von der Mobius-Konferenz gefallen hat, beachten Sie bitte, dass </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mobius 2018 Moskau</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vom 8. bis 9. Dezember stattfindet </font><font style="vertical-align: inherit;">, wo es auch viele interessante Dinge geben wird. </font><font style="vertical-align: inherit;">Seit dem 1. November sind die Ticketpreise gestiegen, daher ist es sinnvoll, jetzt eine Entscheidung zu treffen!</font></font></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427845/">https://habr.com/ru/post/de427845/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427833/index.html">Bericht der Joker-Konferenz 2018</a></li>
<li><a href="../de427837/index.html">Die ersten Tage im Entwicklungsteam - so wie es bei uns passiert</a></li>
<li><a href="../de427839/index.html">Benutzerautorisierung in Django durch GSSAPI und Delegierung von Benutzerrechten an den Server</a></li>
<li><a href="../de427841/index.html">Magic Leap Scam</a></li>
<li><a href="../de427843/index.html">Wie man richtig und falsch schl√§ft</a></li>
<li><a href="../de427847/index.html">Neugier und Aufschub beim maschinellen Lernen</a></li>
<li><a href="../de427849/index.html">Gerade mit TM. v3.0</a></li>
<li><a href="../de427853/index.html">Reflexionen √ºber TDD. Warum diese Methode nicht allgemein anerkannt ist</a></li>
<li><a href="../de427855/index.html">MOSDROID-Mitaps in FunCorp</a></li>
<li><a href="../de427857/index.html">Steuerliche und rechtliche Fragen f√ºr Anf√§nger</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>