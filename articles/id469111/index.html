<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ’» ğŸ¤Ÿ ğŸ¤±ğŸ¿ Ganti Obyek dengan var: apa yang bisa salah? ğŸ›ŒğŸ» â™‰ï¸ ğŸ§‘ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya baru-baru ini menemukan situasi yang menggantikan Object dengan var di program Java 10 melempar pengecualian saat runtime. Saya menjadi tertarik ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ganti Obyek dengan var: apa yang bisa salah?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469111/"><p> Saya baru-baru ini menemukan situasi yang menggantikan Object dengan var di program Java 10 melempar pengecualian saat runtime.  Saya menjadi tertarik pada berapa banyak cara berbeda untuk mencapai efek ini, dan saya membahas masalah ini kepada masyarakat: </p><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1174191219620089856"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br><p>  Ternyata Anda dapat mencapai efek dengan berbagai cara.  Meskipun semuanya agak rumit, menarik untuk mengingat berbagai seluk-beluk bahasa dengan contoh tugas seperti itu.  Mari kita lihat metode apa yang ditemukan. </p><a name="habracut"></a><br><h2 id="uchastniki">  Anggota </h2><br><p>  Di antara responden ada banyak yang terkenal dan tidak terlalu banyak orang.  Ini adalah Sergey <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">bsideup</a> Egorov, karyawan penting, pembicara, salah satu pencipta Testcontainers.  Ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Victor Polishchuk</a> , terkenal karena laporan tentang perusahaan berdarah.  Juga dicatat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nikita Artyushov</a> dari Google;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dmitry Mikhailov</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Maccimo</a> .  Tapi saya sangat senang dengan kedatangan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wouter Coekaerts</a> .  Dia dikenal karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikelnya tahun lalu</a> , di mana dia berjalan melalui sistem tipe Java dan mengatakan betapa putus asa itu rusak.  Beberapa artikel ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">jbaruch</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">saya</a> bahkan digunakan dalam rilis keempat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java Puzzlers</a> . </p><br><h2 id="zadacha-i-resheniya">  Tugas dan solusi </h2><br><p> Jadi, esensi dari tugas kita adalah ini: ada program Java di mana ada deklarasi variabel dari bentuk <code>Object x = ...</code> (standar jujur <code>java.lang.Object</code> , tanpa subtitusi jenis).  Program mengkompilasi, menjalankan, dan mencetak sesuatu seperti "Oke."  Kami mengganti <code>Object</code> dengan <code>var</code> , membutuhkan inferensi tipe otomatis, setelah itu program terus mengkompilasi, tetapi crash saat diluncurkan dengan pengecualian. </p><br><p>  Solusi dapat secara kasar dibagi menjadi dua kelompok.  Yang pertama, setelah mengganti dengan var, variabel menjadi primitif (yaitu, awalnya autoboxing).  Tipe kedua tetap objek, tetapi lebih spesifik daripada <code>Object</code> .  Di sini Anda dapat menyorot subkelompok menarik yang menggunakan obat generik. </p><br><h3 id="boksing">  Tinju </h3><br><p>  Bagaimana cara membedakan suatu objek dari primitif?  Ada banyak cara berbeda.  Cara termudah adalah memeriksa identitas.  Solusi ini diusulkan oleh Nikita: </p><br><pre> <code class="java hljs">Object x = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x == <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Integer(<span class="hljs-number"><span class="hljs-number">1000</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(); System.out.println(<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>);</code> </pre> <br><p>  Ketika <code>x</code> adalah objek, tentu saja tidak bisa sama dengan referensi ke objek <code>new Integer(1000)</code> .  Dan jika itu adalah primitif, maka menurut aturan bahasa <code>new Integer(1000)</code> segera terungkap menjadi primitif juga, dan angka dibandingkan sebagai primitif. </p><br><p>  Cara lain adalah metode kelebihan beban.  Anda dapat menulis sendiri, tetapi Sergey datang dengan opsi yang lebih elegan: gunakan perpustakaan standar.  Metode <code>List.remove</code> , yang kelebihan beban dan dapat menghapus salah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu elemen dengan indeks</a> jika primitif dilewati, atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">elemen dengan nilai</a> jika objek dilewatkan.  Ini berulang kali menyebabkan bug dalam program nyata jika Anda menggunakan <code>List&lt;Integer&gt;</code> .  Untuk tugas kami, solusinya mungkin terlihat seperti ini: </p><br><pre> <code class="java hljs">Object x = <span class="hljs-number"><span class="hljs-number">1000</span></span>; List&lt;?&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); list.remove(x); System.out.println(<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>);</code> </pre> <br><p>  Sekarang kami mencoba untuk menghapus elemen yang tidak ada 1000 dari daftar kosong, ini hanya tindakan yang tidak berguna.  Tetapi jika kita mengganti <code>Object</code> dengan <code>var</code> , kita akan memanggil metode lain yang menghapus elemen dengan indeks 1000. Dan ini sudah mengarah ke <code>IndexOutOfBoundsException</code> . </p><br><p>  Metode ketiga adalah operator konversi tipe.  Kita dapat berhasil mengkonversi primitif lain ke tipe primitif, tetapi suatu objek dikonversi hanya jika ada pembungkus di atas tipe yang sama dengan yang akan kita konversi (maka anbox akan terjadi).  Sebenarnya, kita membutuhkan efek sebaliknya: pengecualian dalam kasus primitif, dan bukan dalam kasus objek, tetapi menggunakan try-catch ini mudah dicapai, yang digunakan Viktor: </p><br><pre> <code class="java hljs">Object x = <span class="hljs-number"><span class="hljs-number">40</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">"Oops :"</span></span> + (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)x); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ClassCastException e) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>); }</code> </pre> <br><p>  Di sini, <code>ClassCastException</code> adalah perilaku yang diharapkan, kemudian program keluar secara normal.  Tetapi setelah menggunakan <code>var</code> pengecualian ini menghilang, dan kami melempar sesuatu yang lain.  Saya ingin tahu apakah ini terinspirasi oleh kode asli dari perusahaan berdarah? .. </p><br><p>  Opsi konversi tipe lain diusulkan oleh Wouter.  Anda dapat menggunakan logika aneh dari operator <code>?:</code> .  Benar, kodenya hanya memberikan hasil yang berbeda, jadi Anda harus memodifikasinya sehingga ada pengecualian.  Jadi, menurut saya, cukup elegan: </p><br><pre> <code class="java hljs">Object x = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; System.out.println(String.valueOf(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span> ? x : <span class="hljs-number"><span class="hljs-number">100000000000L</span></span>).substring(<span class="hljs-number"><span class="hljs-number">12</span></span>) + <span class="hljs-string"><span class="hljs-string">"Ok"</span></span>);</code> </pre> <br><p>  Perbedaan antara metode ini adalah kita tidak menggunakan nilai <code>x</code> secara langsung, tetapi tipe <code>x</code> memengaruhi tipe ekspresi <code>false ? x : 100000000000L</code>  <code>false ? x : 100000000000L</code> .  Jika <code>x</code> adalah <code>Object</code> , maka jenis seluruh ekspresi adalah <code>Object</code> , dan kemudian kita hanya memiliki tinju, <code>String.valueOf()</code> akan <code>String.valueOf()</code> string sebesar <code>100000000000</code> , yang <code>substring(12)</code> adalah string kosong.  Jika Anda menggunakan <code>var</code> , maka tipe <code>x</code> menjadi <code>double</code> , dan karena itu tipenya <code>false ? x : 100000000000L</code>  <code>false ? x : 100000000000L</code> juga <code>double</code> , yaitu <code>100000000000L</code> akan berubah menjadi <code>1.0E11</code> , di mana ia jauh lebih sedikit dari 12 karakter, jadi memanggil hasil <code>substring</code> dalam <code>StringIndexOutOfBoundsException</code> . </p><br><p>  Akhirnya, kami mengambil keuntungan dari fakta bahwa suatu variabel sebenarnya dapat diubah setelah pembuatan.  Dan dalam variabel objek, tidak seperti primitif, Anda dapat meletakkan <code>null</code> .  Menempatkan <code>null</code> dalam variabel itu mudah, ada banyak cara.  Namun di sini, Wouter juga mengambil pendekatan kreatif menggunakan metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Integer.getInteger</code></a> konyol: </p><br><pre> <code class="java hljs">Object x = <span class="hljs-number"><span class="hljs-number">1</span></span>; x = Integer.getInteger(<span class="hljs-string"><span class="hljs-string">"moo"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>);</code> </pre> <br><p>  Tidak semua orang tahu bahwa metode ini membaca properti sistem yang disebut <code>moo</code> dan, jika ada, mencoba mengubahnya menjadi angka, jika tidak maka akan mengembalikan <code>null</code> .  Jika tidak ada properti, kami diam-diam menetapkan <code>null</code> ke objek, tetapi jatuh dari <code>NullPointerException</code> ketika mencoba untuk menetapkannya ke primitif (anboxing otomatis terjadi di sana).  Tentu saja bisa lebih mudah.  Versi kasar <code>x = null;</code>  itu tidak merangkak - tidak dikompilasi, tetapi kompiler akan menelannya sekarang: </p><br><pre> <code class="java hljs">Object x = <span class="hljs-number"><span class="hljs-number">1</span></span>; x = (Integer)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; System.out.println(<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>);</code> </pre> <br><h3 id="obektnyy-tip">  Jenis objek </h3><br><p>  Misalkan Anda tidak bisa lagi bermain dengan primitif.  Apa lagi yang bisa Anda pikirkan? </p><br><p>  Pertama, metode kelebihan beban paling sederhana yang diusulkan oleh Dmitry: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Object x = <span class="hljs-string"><span class="hljs-string">"Ok"</span></span>; sayWhat(x); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayWhat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object x)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(x); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayWhat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(); }</code> </pre> <br><p>  Menghubungkan metode kelebihan beban di Jawa terjadi secara statis, pada tahap kompilasi.  Metode sayWhat <code>sayWhat(Object)</code> , tetapi jika kita menyimpulkan tipe <code>x</code> secara otomatis, maka <code>String</code> <code>sayWhat(String)</code> , dan oleh karena itu metode <code>sayWhat(String)</code> lebih spesifik akan dihubungkan. </p><br><p>  Cara lain untuk membuat panggilan ambigu di Jawa adalah dengan menggunakan argumen variabel (varargs).  Wouter mengingat ini lagi: </p><br><pre> <code class="java hljs">Object x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[] {}; Arrays.asList(x).get(<span class="hljs-number"><span class="hljs-number">0</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>);</code> </pre> <br><p>  Ketika tipe variabel adalah <code>Object</code> , kompiler berpikir itu adalah argumen variabel dan membungkus array dalam array lain dari satu elemen, jadi <code>get()</code> berhasil memenuhi.  Jika Anda menggunakan <code>var</code> , tipe <code>Object[]</code> ditampilkan, dan tidak akan ada pembungkus tambahan.  Dengan cara ini kita mendapatkan daftar kosong, dan panggilan <code>get()</code> akan gagal. </p><br><p>  Maccimo memilih hardcore: ia memutuskan untuk memanggil <code>println</code> melalui API MethodHandle: </p><br><pre> <code class="java hljs">Object x = <span class="hljs-string"><span class="hljs-string">"Ok"</span></span>; MethodHandles.Lookup lookup = MethodHandles.lookup(); MethodHandle mh = lookup.findVirtual( PrintStream.class, <span class="hljs-string"><span class="hljs-string">"println"</span></span>, MethodType.methodType(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>.class, Object.class)); mh.invokeExact(System.out, x);</code> </pre> <br><p>  Metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>invokeExact</code></a> dan beberapa metode lain dari <code>java.lang.invoke</code> memiliki apa yang disebut "tanda tangan polimorfik".  Meskipun dideklarasikan sebagai metode vararg <code>invokeExact(Object... args)</code> , itu tidak terjadi dalam pengemasan array standar.  Sebagai gantinya, tanda tangan dihasilkan dalam bytecode yang cocok dengan jenis argumen yang sebenarnya dilewati.  Metode <code>invokeExact</code> dirancang untuk pemanggilan metode penanganan yang sangat cepat, sehingga metode ini tidak melakukan transformasi argumen standar seperti casting atau tinju.  Jenis metode pegangan diharapkan sesuai persis dengan tanda tangan panggilan.  Ini dicentang pada saat runtime, dan seperti dalam kasus <code>var</code> pertandingan rusak, kita mendapatkan <code>WrongMethodTypeException</code> . </p><br><h3 id="dzheneriki">  Generik </h3><br><p>  Tentu saja, parameterisasi jenis dapat menambahkan binar ke tugas apa pun di Jawa.  Dmitry membawa solusi yang mirip dengan kode yang awalnya saya temui.  Keputusan Dmitry sangat jelas, jadi saya akan menunjukkan: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Object x = foo(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder()); System.out.println(x); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T)<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>; }</code> </pre> <br><p>  Tipe <code>T</code> adalah output sebagai <code>StringBuilder</code> , tetapi dalam kode ini kompiler tidak diharuskan untuk memasukkan pemeriksaan tipe pada dial-peer ke dalam bytecode.  Sudah cukup baginya bahwa <code>StringBuilder</code> dapat ditugaskan ke <code>Object</code> , yang berarti semuanya baik-baik saja.  Tidak ada yang menentang fakta bahwa metode dengan nilai pengembalian <code>StringBuilder</code> benar-benar mengembalikan string jika Anda menetapkan hasilnya ke variabel tipe <code>Object</code> toh.  Kompiler dengan jujur â€‹â€‹memperingatkan bahwa Anda memiliki pemain yang tidak diperiksa, yang berarti bahwa ia mencuci tangannya.  Namun, ketika mengganti <code>x</code> dengan <code>var</code> tipe <code>x</code> juga ditampilkan sebagai <code>StringBuilder</code> , dan itu tidak mungkin lagi tanpa pengecekan tipe, karena menugaskan sesuatu yang lain ke variabel tipe <code>StringBuilder</code> tidak berharga.  Akibatnya, setelah berubah menjadi <code>var</code> program dengan aman crash dengan <code>ClassCastException</code> . </p><br><p>  Wouter menyarankan varian dari solusi ini menggunakan metode standar: </p><br><pre> <code class="java hljs">Object o = ((List&lt;String&gt;)(List)List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>)).get(<span class="hljs-number"><span class="hljs-number">0</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>);</code> </pre> <br><p>  Akhirnya, opsi lain dari Wouter: </p><br><pre> <code class="java hljs">Object x = <span class="hljs-string"><span class="hljs-string">""</span></span>; TreeSet&lt;?&gt; set = Stream.of(x) .collect(toCollection(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeSet&lt;&gt;((a, b) -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (set.contains(<span class="hljs-number"><span class="hljs-number">1</span></span>)) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>); }</code> </pre> <br><p>  Di sini, tergantung pada penggunaan <code>var</code> atau <code>Object</code> tipe aliran ditampilkan sebagai <code>Stream&lt;Object&gt;</code> atau sebagai <code>Stream&lt;String&gt;</code> .  Dengan demikian, tipe <code>TreeSet</code> dan tipe lambda pembanding ditampilkan.  Dalam kasus <code>var</code> , string harus datang ke lambda, jadi ketika membuat representasi runtime lambda, konversi tipe secara otomatis dimasukkan, yang memberikan <code>ClassCastException</code> ketika mencoba untuk melemparkan unit ke string. </p><br><p>  Secara umum, hasilnya sangat membosankan.  Jika Anda dapat menemukan metode yang berbeda secara mendasar untuk memecah <code>var</code> , kemudian tulis di komentar. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id469111/">https://habr.com/ru/post/id469111/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id469095/index.html">ML.NET dan Pembaruan Model Builder Dirilis: Apa yang Baru</a></li>
<li><a href="../id469097/index.html">Server web CentOS 8 dengan php7, node.js dan redis</a></li>
<li><a href="../id469099/index.html">Menguji tugas saat wawancara dengan pengembang - apakah masuk akal?</a></li>
<li><a href="../id469101/index.html">Belajar Bahasa Inggris: cara belajar berbicara sebagai penutur asli</a></li>
<li><a href="../id469109/index.html">Mainan Kayu, Bagian Tiga - 1989</a></li>
<li><a href="../id469115/index.html">Panduan Discovery.js: Mulai Cepat</a></li>
<li><a href="../id469117/index.html">Pemrograman di bawah BC 0010 pada tahun 2019</a></li>
<li><a href="../id469119/index.html">Alamat IPv4 di RIPE sudah berakhir. Benar-benar selesai ...</a></li>
<li><a href="../id469125/index.html">Tema gelap Thunderbird sebagai alasan untuk menjalankan penganalisis kode</a></li>
<li><a href="../id469127/index.html">Optimasi atau cara tidak menembak diri sendiri di kaki</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>