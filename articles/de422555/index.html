<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçü§ù‚Äçüë®üèª üë®üèª‚Äç‚öïÔ∏è üß§ Android-Multimodul-Architektur. Von A bis Z. üë®üèª‚ÄçüöÄ üë©üèæ‚Äçü§ù‚Äçüë©üèº üöú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! 

 Vor nicht allzu langer Zeit haben wir erkannt, dass eine mobile Anwendung nicht nur ein Thin Client ist, sondern eine wirklich gr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Android-Multimodul-Architektur. Von A bis Z.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/kaspersky/blog/422555/"> Hallo allerseits! <br><br>  Vor nicht allzu langer Zeit haben wir erkannt, dass eine mobile Anwendung nicht nur ein Thin Client ist, sondern eine wirklich gro√üe Anzahl sehr unterschiedlicher Logik, die optimiert werden muss.  Aus diesem Grund haben wir uns von den Ideen der sauberen Architektur inspirieren lassen, f√ºhlen, was DI ist, haben gelernt, wie man Dolch 2 verwendet, und jetzt k√∂nnen wir mit geschlossenen Augen jedes Merkmal in Ebenen aufteilen. <br><br>  Aber die Welt steht nicht still und mit der L√∂sung alter Probleme kommen neue.  Und der Name dieses neuen Problems ist Monomodularit√§t.  Sie erfahren dieses Problem normalerweise, wenn die Montagezeit in den Weltraum vergeht.  Genau so viele Berichte √ºber den √úbergang zur Multimodularit√§t ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eins</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei</a> ) beginnen. <br>  Aber aus irgendeinem Grund vergisst jeder gleichzeitig irgendwie, dass die Monomodularit√§t nicht nur die Montagezeit, sondern auch Ihre Architektur stark beeinflusst.  Hier beantworten Sie die Fragen.  Wie gro√ü ist Ihre AppComponent?  Sehen Sie im Code regelm√§√üig, dass Feature A aus irgendeinem Grund das Repository von Feature B abruft, obwohl es nicht so aussehen sollte, oder sollte es irgendwie mehr Top-Level sein?  Haben Features einen Vertrag?  Und wie organisieren Sie die Kommunikation zwischen Funktionen?  Gibt es Regeln? <br>  Sie haben das Gef√ºhl, dass wir das Problem mit den Ebenen gel√∂st haben, das hei√üt, vertikal scheint alles in Ordnung zu sein, aber horizontal l√§uft etwas schief?  Und nur die Pakete aufzuschl√ºsseln und die √úberpr√ºfung zu kontrollieren, l√∂st das Problem nicht. <br><br>  Und die Sicherheitsfrage f√ºr die Erfahreneren.  Mussten Sie bei der Umstellung auf Multimodularit√§t nicht die H√§lfte der Anwendung schaufeln, den Code immer von einem Modul auf ein anderes ziehen und einen angemessenen Zeitraum mit einem nicht zusammengestellten Projekt verbringen? <br><br>  In meinem Artikel m√∂chte ich Ihnen erz√§hlen, wie ich genau aus architektonischer Sicht zur Multimodularit√§t gekommen bin.  Welche Probleme haben mich gest√∂rt und wie ich versucht habe, sie schrittweise zu l√∂sen.  Und am Ende finden Sie einen Algorithmus f√ºr den Wechsel von Monomodularit√§t zu Multimodularit√§t ohne Tr√§nen und Schmerzen. <br><a name="habracut"></a><br>  Bei der Beantwortung der ersten Frage, wie gro√ü die AppComponent ist, kann ich gestehen - gro√ü, wirklich gro√ü.  Und es qu√§lte mich st√§ndig.  Wie ist es passiert?  Dies ist in erster Linie auf eine solche DI-Organisation zur√ºckzuf√ºhren.  Mit DI werden wir beginnen. <br><br><h2>  Wie ich es vorher getan habe </h2><br>  Ich denke, dass viele Menschen in ihren K√∂pfen so etwas wie dieses Diagramm der Abh√§ngigkeiten der Komponenten und der entsprechenden Bereiche gebildet haben: <br><img src="https://habrastorage.org/webt/f1/xm/so/f1xmsoakbmgcfys9rjuys_jmnvo.png"><br><br><h4>  Was haben wir hier? </h4><br>  <b>AppComponent</b> , die absolut alle Abh√§ngigkeiten mit <i>Singleton-</i> Bereichen absorbierte.  Ich denke, fast jeder hat diese Komponente. <br><br>  <b>FeatureComponents</b> .  Jedes Feature hatte seinen eigenen Bereich und war eine Unterkomponente von <i>AppComponent</i> oder ein Senior-Feature. <br>  Lassen Sie uns ein wenig auf die Funktionen eingehen.  Was ist eine Funktion?  Ich werde es in meinen eigenen Worten versuchen.  <b>Eine Funktion</b> ist ein logisch vollst√§ndiges, maximal unabh√§ngiges Programmmodul, das ein bestimmtes Benutzerproblem mit klar definierten externen Abh√§ngigkeiten l√∂st und in einem anderen Programm relativ einfach wieder verwendet werden kann.  Features k√∂nnen gro√ü und klein sein.  Funktionen k√∂nnen andere Funktionen enthalten.  Sie k√∂nnen auch andere Funktionen √ºber klar definierte externe Abh√§ngigkeiten verwenden oder ausf√ºhren.  Wenn wir unsere Anwendung (Kaspersky Internet Security f√ºr Android) verwenden, k√∂nnen Funktionen als Anti-Virus, Anti-Theft usw. betrachtet werden. <br><br>  <b>ScreenComponents</b> .  Eine Komponente f√ºr einen bestimmten Bildschirm, die ebenfalls einen eigenen Bereich hat und gleichzeitig eine Unterkomponente der entsprechenden Feature-Komponente ist. <br><br><h4>  Nun eine Liste von "warum so" </h4><br>  <b>Warum Unterkomponenten?</b> <br>  Bei Komponentenabh√§ngigkeiten hat mir die Tatsache nicht gefallen, dass eine Komponente von mehreren Komponenten gleichzeitig abh√§ngen kann, was meiner Meinung nach letztendlich zu einem Chaos der Komponenten und ihrer Abh√§ngigkeiten f√ºhren kann.  Wenn Sie eine strikte Eins-zu-Viele-Beziehung haben (eine Komponente und ihre Unterkomponenten), ist dies sicherer und offensichtlicher.  Dar√ºber hinaus stehen der Unterkomponente standardm√§√üig alle Abh√§ngigkeiten des √ºbergeordneten Elements zur Verf√ºgung, was ebenfalls praktischer ist. <br><br>  <b>Warum gibt es f√ºr jede Funktion einen Bereich?</b> <br>  Weil ich dann von den √úberlegungen ausgegangen bin, dass jedes Feature eine Art eigenen Lebenszyklus ist, der nicht mit dem anderer identisch ist, ist es logisch, einen eigenen Bereich zu erstellen.  Es gibt noch einen Punkt f√ºr viele geizige Dinge, den ich unten erw√§hnen werde. <br><br>  Da wir im Zusammenhang mit Clean √ºber Dolch 2 sprechen, werde ich auch den Moment erw√§hnen, in dem Abh√§ngigkeiten geliefert wurden.  Pr√§sentatoren, Interaktoren, Repositorys und andere Hilfsklassen von Abh√§ngigkeiten wurden √ºber den Konstruktor bereitgestellt.  In Tests ersetzen wir dann Stubs oder Moki durch den Konstruktor und testen unsere Klasse leise. <br>  Das Schlie√üen des Abh√§ngigkeitsgraphen erfolgt normalerweise in Aktivit√§ten, Fragmenten, manchmal Empf√§ngern und Diensten im Allgemeinen an den Wurzelstellen, von denen aus der Android etwas starten kann.  Die klassische Situation besteht darin, dass eine Aktivit√§t f√ºr ein Feature erstellt wird, die Feature-Komponente startet und in der Aktivit√§t lebt und im Feature selbst drei Bildschirme vorhanden sind, die in drei Fragmenten implementiert sind. <br><br>  Alles scheint also logisch zu sein.  Aber wie immer nimmt das Leben seine eigenen Anpassungen vor. <br><br><h2>  Lebensprobleme </h2><br><h3>  Beispielaufgabe </h3><br>  Schauen wir uns ein einfaches Beispiel aus unserer Anwendung an.  Wir haben eine Scannerfunktion und eine Diebstahlsicherung.  Beide Funktionen haben einen gesch√§tzten Kaufknopf.  Dar√ºber hinaus sendet ‚ÄûKaufen‚Äú nicht nur eine Anfrage, sondern auch eine Vielzahl unterschiedlicher Logik in Bezug auf den Kaufprozess.  Dies ist eine reine Gesch√§ftslogik mit einigen Dialogen f√ºr den sofortigen Kauf.  Das hei√üt, es gibt eine ganz andere Funktion f√ºr sich - Kauf.  Daher m√ºssen wir in zwei Funktionen die dritte Funktion verwenden. <br>  Aus Sicht der Benutzeroberfl√§che und der Navigation haben wir das folgende Bild.  Der Hauptbildschirm startet mit zwei Tasten: <br><img src="https://habrastorage.org/webt/ps/1o/qj/ps1oqjtlzdybdcj21pokcadin8u.png"><br><br>  Durch Klicken auf diese Schaltfl√§chen gelangen wir zur Funktion des Scanners oder der Diebstahlsicherung. <br>  Betrachten Sie die Funktion des Scanners: <br><img src="https://habrastorage.org/webt/p5/2g/yw/p52gywypiko82skvl0mn90hd5wq.png"><br><br>  Durch Klicken auf "Antiviren-Scan starten" wird eine Art Scan-Arbeit erledigt. Wenn Sie auf "Kaufen" klicken, m√∂chten wir nur kaufen, das hei√üt, wir ziehen die Funktion "K√§ufe" auf, aber auf "Hilfe" gelangen wir mit einer Hilfe zu einem einfachen Bildschirm. <br>  Die Funktion von Anti-Theft sieht fast gleich aus. <br><br><h3>  M√∂gliche L√∂sungen </h3><br>  Wie implementieren wir dieses Beispiel in Bezug auf DI?  Es gibt mehrere M√∂glichkeiten. <br><br><h4>  Erste Option </h4><br>  W√§hlen Sie eine <i>Kauffunktion</i> als <i><b>unabh√§ngige Komponente aus</b></i> , die nur von der <i>AppComponent abh√§ngt</i> . <br><img src="https://habrastorage.org/webt/ia/aq/t2/iaaqt2fi01u1lvjixbn9uspxgyi.png"><br><br>  Aber dann stehen wir vor dem Problem: Wie k√∂nnen Abh√§ngigkeiten von zwei verschiedenen Graphen (Komponenten) gleichzeitig in eine Klasse eingef√ºgt werden?  Nur durch schmutzige Kr√ºcken, was nat√ºrlich so ist. <br><br><h4>  Zweite Option </h4><br>  Wir w√§hlen die Kauffunktion in der Unterkomponente aus, die von der AppComponent abh√§ngt.  Und die Komponenten des Scanners und der Diebstahlsicherung k√∂nnen aus der Kaufkomponente zu Unterkomponenten gemacht werden. <br><img src="https://habrastorage.org/webt/wh/sh/y3/whshy3v3buimdjy2sfo6w1de3ys.png"><br><br>  Wie Sie verstehen, kann es in Anwendungen jedoch viele √§hnliche Situationen geben.  Dies bedeutet, dass die Tiefe der Abh√§ngigkeiten der Komponenten sehr gro√ü und komplex sein kann.  Ein solches Diagramm ist verwirrender, als Ihre Anwendung koh√§renter und verst√§ndlicher zu machen. <br><br><h4>  Dritte Option </h4><br>  Wir w√§hlen die Kauffunktion <b>nicht in einer separaten Komponente, sondern in einem separaten Dolchmodul</b> .  Zwei Wege sind weiter m√∂glich. <br><br>  <b>Erster Weg</b> <br>  <i>F√ºgen</i> wir allen Abh√§ngigkeiten die <i>Singleton-</i> <i>Bereichsfunktionen hinzu</i> und stellen eine Verbindung zur <i>AppComponent her</i> . <br><img src="https://habrastorage.org/webt/gx/wb/3h/gxwb3hokdqdrrcypwykypnym0n8.png"><br><br>  Die Option ist beliebt, f√ºhrt jedoch zu einer Aufbl√§hung der <i>AppComponent</i> .  Infolgedessen nimmt die Gr√∂√üe zu, enth√§lt alle Anwendungsklassen, und der springende Punkt bei der Verwendung von Dagger ist die bequemere √úbermittlung von Abh√§ngigkeiten an Klassen - √ºber Felder oder den Konstruktor und nicht √ºber Singletones.  Im Prinzip ist dies DI, aber wir vermissen architektonische Punkte und es stellt sich heraus, dass jeder √ºber jeden Bescheid wei√ü. <br>  Wenn Sie zu Beginn des Pfads nicht wissen, wo Sie eine Klasse welchem ‚Äã‚ÄãFeature zuordnen sollen, ist es im Allgemeinen einfacher, sie global zu gestalten.  Dies ist h√§ufig der Fall, wenn Sie mit Legacy arbeiten und versuchen, zumindest eine Art Architektur einzubringen. Au√üerdem kennen Sie den gesamten Code noch nicht gut.  Und dort weiteten sich tats√§chlich die Augen, und diese Handlungen sind gerechtfertigt.  Der Fehler ist, dass niemand diese <i>AppComponent</i> in <i>Angriff nehmen</i> m√∂chte, wenn sich mehr oder weniger alles abzeichnet. <br><br>  <b>Zweiter Weg</b> <br>  Dies ist eine Reduzierung aller Funktionen auf einen einzigen Bereich, z. B. <i>PerFeature</i> . <br><img src="https://habrastorage.org/webt/pm/5u/og/pm5uogvwcybvetc4nrfekteyqy4.png"><br><br>  Dann k√∂nnen wir das Dolchmodul des Einkaufs einfach und einfach mit den notwendigen Komponenten verbinden. <br>  Es scheint bequem.  Aber architektonisch stellt sich heraus, nicht isoliert.  Die Funktionen des Scanners und der Diebstahlsicherung wissen absolut alles √ºber die Kauffunktion, alle Innereien.  Es kann versehentlich etwas beteiligt sein.  Das hei√üt, die Kauffunktion verf√ºgt nicht √ºber eine eindeutige API, die Grenze zwischen den Funktionen ist verschwommen und es gibt keinen eindeutigen Vertrag.  Das ist schlecht.  Nun, im multimodularen Bereich wird das Gredloid sp√§ter schwierig sein. <br><br><h3>  Architektonischer Schmerz </h3><br>  Ehrlich gesagt habe ich lange Zeit die <b>dritte Option verwendet. Den ersten Weg</b> .  Dies war eine notwendige Ma√ünahme, als wir begannen, unser Erbe schrittweise auf normale Schienen zu √ºbertragen.  Aber wie ich bereits erw√§hnt habe, beginnen sich bei diesem Ansatz Ihre Funktionen ein wenig zu vermischen.  Jeder kann √ºber jeden Bescheid wissen, √ºber die Details der Implementierung und dies f√ºr jeden.  Und das Aufbl√§hen von <i>AppComponent zeigte</i> deutlich, dass etwas getan werden muss. <br>  √úbrigens w√ºrde die <b>dritte Option</b> beim Entladen von <i>AppComponent helfen</i> <b>. Der zweite Weg</b> .  Das Wissen √ºber Implementierungen und Mischfunktionen wird jedoch nirgendwo hingehen.  Nat√ºrlich w√§re es sehr schwierig, Funktionen zwischen Anwendungen wiederzuverwenden. <br><br><h3>  Zwischenschlussfolgerungen </h3><br>  Also, was wollen wir am Ende?  Welche Probleme wollen wir l√∂sen?  Gehen wir gleich zum Punkt, beginnend mit DI und weiter zur Architektur: <br><br><ul><li>  Ein praktischer DI-Mechanismus, mit dem Sie Funktionen in anderen Funktionen verwenden k√∂nnen (in unserem Beispiel m√∂chten wir die Einkaufsfunktion in Scanner und Diebstahlschutz verwenden), ohne Kr√ºcken und Schmerzen. </li><li>  Die d√ºnnste AppComponent. </li><li>  Features sollten keine Implementierungen anderer Features kennen. </li><li>  Die Funktionen sollten standardm√§√üig f√ºr niemanden zug√§nglich sein. Ich m√∂chte einen strengen Kontrollmechanismus. </li><li>  Es ist m√∂glich, die Funktion mit einer minimalen Anzahl von Gesten einer anderen Anwendung zuzuweisen. </li><li>  Ein logischer √úbergang zu Multimodularit√§t und Best Practices f√ºr diesen √úbergang. </li></ul><br>  Ich habe erst ganz am Ende speziell √ºber Multimodularit√§t gesprochen.  Wir werden sie erreichen, wir werden uns nicht √ºbertreffen. <br><br><h2>  "Auf neue Weise leben" </h2><br>  Jetzt werden wir versuchen, die obige Wunschliste schrittweise umzusetzen. <br>  Lass uns gehen! <br><br><h3>  DI-Verbesserungen </h3><br>  Beginnen wir mit dem gleichen DI. <br><br><h4>  Ablehnung einer gro√üen Anzahl von Bereichen </h4><br>  Wie ich oben schrieb, war mein Ansatz vor diesem: f√ºr jedes Feature seinen eigenen Umfang.  Tats√§chlich gibt es daraus keine besonderen Gewinne.  Erhalten Sie nur eine gro√üe Anzahl von Bereichen und eine gewisse Menge an Kopfschmerzen. <br>  Diese Kette ist v√∂llig ausreichend: <i>Singleton</i> - <i>PerFeature</i> - <i>PerScreen</i> . <br><br><h4>  Aufgabe von Unterkomponenten zugunsten von Komponentenabh√§ngigkeiten </h4><br>  Schon ein interessanter Punkt.  Mit <i>Unterkomponenten</i> scheinen Sie eine strengere Hierarchie zu haben, aber gleichzeitig haben Sie die H√§nde vollst√§ndig gebunden und es gibt keine M√∂glichkeit, irgendwie zu man√∂vrieren.  Dar√ºber hinaus kennt <i>AppComponent</i> alle Funktionen und Sie erhalten eine riesige generierte Klasse <i>DaggerAppComponent</i> . <br>  Mit <i>Komponentenabh√§ngigkeiten erhalten</i> Sie einen super coolen Vorteil.  In Komponentenabh√§ngigkeiten k√∂nnen Sie <b>keine Komponenten</b> angeben <b>, sondern saubere Schnittstellen</b> (dank Denis und Volodya).  Dank dieser Funktion k√∂nnen Sie beliebige Schnittstellenimplementierungen ersetzen. Dagger frisst alles.  Auch wenn die Komponente mit demselben Umfang diese Implementierung ist: <br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span>( dependencies = FeatureDependencies.class, modules = FeatureModule.class ) <span class="hljs-meta"><span class="hljs-meta">@PerFeature</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeatureComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } public interface FeatureDependencies { SomeDependency someDependency(); } @Component( modules = AnotherFeatureModule.class ) @PerFeature public abstract class AnotherFeatureComponent implements FeatureDependencies { // ... }</span></span></code> </pre> <br><br><h3>  Von DI-Verbesserungen zu architektonischen Verbesserungen </h3><br>  Wiederholen wir die Definition von Features.  <b>Eine Funktion</b> ist ein logisch vollst√§ndiges, maximal unabh√§ngiges Programmmodul, das ein bestimmtes Benutzerproblem mit klar definierten externen Abh√§ngigkeiten l√∂st und in einem anderen Programm relativ einfach wiederverwendet werden kann.  Einer der Schl√ºsselausdr√ºcke bei der Definition eines Features ist ‚Äûmit klar definierten externen Abh√§ngigkeiten‚Äú.  Beschreiben wir daher alles, was wir von der Au√üenwelt f√ºr Funktionen erwarten, in einer speziellen Oberfl√§che. <br>  Hier ist beispielsweise die externe Abh√§ngigkeitsschnittstelle der Einkaufsfunktion: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PurchaseFeatureDependencies</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">HttpClientApi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">httpClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  Oder die Schnittstelle der externen Abh√§ngigkeiten der Scannerfunktion: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerFeatureDependencies</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">DbClientApi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dbClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">HttpClientApi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">httpClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">SomeUtils </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someUtils</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//       PurchaseInteractor purchaseInteractor(); }</span></span></code> </pre><br>  Wie im Abschnitt √ºber DI erw√§hnt, k√∂nnen Abh√§ngigkeiten von jedem implementiert werden. Wie Sie m√∂chten, handelt es sich hierbei um reine Schnittstellen, und unsere Funktionen sind von diesem zus√§tzlichen Wissen befreit. <br><br>  Eine weitere wichtige Komponente eines ‚Äûreinen‚Äú Features ist das Vorhandensein einer klaren API, √ºber die die Au√üenwelt auf das Feature zugreifen kann. <br>  Hier sind die API-Funktionen von Shopping: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PurchaseFeatureApi</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">PurchaseInteractor </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">purchaseInteractor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  Das hei√üt, die Au√üenwelt kann einen <i>PurchaseInteractor erhalten</i> und versuchen, √ºber diesen einen Kauf zu t√§tigen.  Oben haben wir gesehen, dass der Scanner einen <i>PurchaseInteractor</i> ben√∂tigt, um den Kauf abzuschlie√üen. <br><br>  Und hier sind die API-Funktionen des Scanners: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerFeatureApi</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">ScannerStarter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scannerStarter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  Und sofort bringe ich die Schnittstelle und Implementierung von <i>ScannerStarter</i> : <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerStarter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context)</span></span></span></span>; } <span class="hljs-meta"><span class="hljs-meta">@PerFeature</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerStarterImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerStarter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ScannerStarterImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context)</span></span></span><span class="hljs-function"> </span></span>{ Class&lt;?&gt; cls = ScannerActivity.class; Intent intent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Intent(context, cls); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(intent); } }</code> </pre><br>  Hier ist es interessanter.  Tatsache ist, dass der Scanner und der Diebstahlschutz ziemlich geschlossene und isolierte Funktionen sind.  In meinem Beispiel werden diese Funktionen in separaten Aktivit√§ten mit eigener Navigation usw. gestartet. Das hei√üt, wir k√∂nnen hier einfach die Aktivit√§t starten.  Aktivit√§t stirbt - die Funktion stirbt.  Sie k√∂nnen auf der Grundlage des Prinzips ‚ÄûEinzelaktivit√§t‚Äú arbeiten und dann √ºber API-Funktionen beispielsweise einen FragmentManager und einen R√ºckruf √ºbergeben, √ºber den die Funktion meldet, dass sie abgeschlossen wurde.  Es gibt viele Variationen. <br>  Wir k√∂nnen auch sagen, dass wir das Recht haben, Funktionen wie Scanner und Diebstahlschutz als unabh√§ngige Anwendungen zu betrachten.  Im Gegensatz zu der Funktion des Kaufs, die eine Funktionserg√§nzung zu etwas darstellt, existiert sie irgendwie nicht besonders.  Ja, es ist unabh√§ngig, aber es ist eine logische Erg√§nzung zu anderen Funktionen. <br><br>  Wie Sie sich vorstellen k√∂nnen, muss es einen Punkt geben, der die Funktionen, ihre Implementierung und die erforderlichen Funktionen der Abh√§ngigkeit miteinander verbindet.  Dieser Punkt ist die Dolchkomponente. <br><div class="spoiler">  <b class="spoiler_title">Ein Beispiel f√ºr eine Funktionskomponente des Scanners:</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span>(modules = { ScannerFeatureModule.class, ScreenNavigationModule.class <span class="hljs-comment"><span class="hljs-comment">// ScannerFeatureDependencies - api    }, dependencies = ScannerFeatureDependencies.class) @PerFeature // ScannerFeatureApi - api   public abstract class ScannerFeatureComponent implements ScannerFeatureApi { private static volatile ScannerFeatureComponent sScannerFeatureComponent; //   public static ScannerFeatureApi initAndGet( ScannerFeatureDependencies scannerFeatureDependencies) { if (sScannerFeatureComponent == null) { synchronized (ScannerFeatureComponent.class) { if (sScannerFeatureComponent == null) { sScannerFeatureComponent = DaggerScannerFeatureComponent.builder() .scannerFeatureDependencies(scannerFeatureDependencies) .build(); } } } return sScannerFeatureComponent; } //           public static ScannerFeatureComponent get() { if (sScannerFeatureComponent == null) { throw new RuntimeException( "You must call 'initAndGet(ScannerFeatureDependenciesComponent scannerFeatureDependenciesComponent)' method" ); } return sScannerFeatureComponent; } //    (   ) public void resetComponent() { sScannerFeatureComponent = null; } public abstract void inject(ScannerActivity scannerActivity); //         Moxy public abstract ScannerScreenComponent scannerScreenComponent(); }</span></span></code> </pre><br></div></div><br>  Ich denke nichts Neues f√ºr dich. <br><br><h3>  √úbergang zur Multimodularit√§t </h3><br>  Sie und ich konnten also die Grenzen des Features durch die API seiner Abh√§ngigkeiten und die externe API klar definieren.  Wir haben auch herausgefunden, wie man alles in Dagger auf Touren bringt.  Und jetzt kommen wir zum n√§chsten logischen und interessanten Schritt - der Aufteilung in Module. <br>  √ñffnen Sie sofort einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Testfall</a> - es wird einfacher. <br>  Schauen wir uns das Bild allgemein an: <br><img src="https://habrastorage.org/webt/qq/uw/bg/qquwbgerknuk95cjefxfxqserxi.png"><br>  Schauen Sie sich die Paketstruktur des Beispiels an: <br><img src="https://habrastorage.org/webt/cs/_a/4a/cs_a4ap7km-ivyxwzk615blftby.png"><br>  Lassen Sie uns nun jeden Punkt sorgf√§ltig besprechen. <br><br>  Zun√§chst sehen wir vier gro√üe Bl√∂cke: <b>Application</b> , <b>API</b> , <b>Impl</b> und <b>Utils</b> .  In den <i>APIs</i> , <i>Impl</i> und <i>Utils stellen</i> Sie m√∂glicherweise fest, dass alle Module <b>entweder bei Core-</b> oder <b>Feature- beginnen</b> .  Lassen Sie uns zuerst √ºber sie sprechen. <br><br><h4>  Trennung in Kern und Merkmal </h4><br>  Ich teile alle Module in zwei Kategorien ein: <i>Core-</i> und <i>Feature-</i> . <br>  In <i>Feature-</i> , wie Sie vielleicht erraten haben, unsere Features.  Im <b>Kern gibt</b> es solche Dinge wie Dienstprogramme, Arbeiten mit einem Netzwerk, Datenbanken usw. Aber es gibt dort keine Funktionsschnittstellen.  Und der <i>Kern</i> ist kein Monolith.  Ich bin daf√ºr, das <i>Kernmodul</i> in logische Teile zu zerlegen und es nicht mit einigen anderen Funktionsschnittstellen zu laden. <br>  Schreiben Sie im Namen des Moduls zuerst den <i>Kern</i> oder das <i>Feature</i> .  Weiter im Modulnamen befindet sich ein logischer Name ( <i>Scanner</i> , <i>Netzwerk</i> usw.). <br><br><h4>  Nun zu vier gro√üen Bl√∂cken: Application, API, Impl und Utils </h4><br>  <b>API</b> <br>  Jedes <i>Feature</i> oder <i>Kernmodul ist</i> in <i>API</i> und <i>Impl unterteilt</i> .  Die <i>API</i> enth√§lt eine externe API, √ºber die Sie auf eine Funktion oder einen Kern zugreifen k√∂nnen.  Nur das und nichts weiter: <br><img src="https://habrastorage.org/webt/8_/gz/0c/8_gz0ckdfivle1avlexldnj_mdc.png"><br>  Au√üerdem kennt das <i>API-Modul</i> niemanden, es ist ein absolut isoliertes Modul. <br><br>  <b>Utils</b> <br>  Die einzige Ausnahme von der obigen Regel kann als ein v√∂llig zweckm√§√üiges Element angesehen werden, bei dem es keinen Sinn macht, in API und Implementierung einzubrechen. <br><br>  <b>Impl</b> <br>  Hier haben wir eine Unterteilung in <i>Core-Impl</i> und <i>Feature-Impl</i> . <br>  Die Module in <i>core-impl sind</i> ebenfalls v√∂llig unabh√§ngig.  Ihre einzige Abh√§ngigkeit ist das <i>API-Modul</i> .  Schauen Sie sich als Beispiel die <i>build.gradle des</i> <i>core-db-impl-Moduls an</i> : <br><pre> <code class="hljs powershell">// bla<span class="hljs-literal"><span class="hljs-literal">-bla</span></span><span class="hljs-literal"><span class="hljs-literal">-bla</span></span> dependencies { implementation project(<span class="hljs-string"><span class="hljs-string">':core-db-api'</span></span>) // bla<span class="hljs-literal"><span class="hljs-literal">-bla</span></span><span class="hljs-literal"><span class="hljs-literal">-bla</span></span> }</code> </pre><br>  Nun zu <i>Feature-Impl</i> .  Es gibt bereits den L√∂wenanteil der Anwendungslogik.  Die Module der <i>Feature-Impl-Gruppe</i> k√∂nnen etwas √ºber die Module der <i>API-</i> oder <i>Utils-</i> Gruppe wissen, aber sie wissen sicherlich nichts √ºber die anderen Module der <i>Impl-</i> Gruppe. <br>  Wie wir uns erinnern, werden alle externen Abh√§ngigkeiten des Features in den externen Abh√§ngigkeiten akkumuliert.  F√ºr eine Funktion von Scan sieht diese API beispielsweise wie folgt aus: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerFeatureDependencies</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// core-db-api DbClientApi dbClient(); // core-network-api HttpClientApi httpClient(); // core-utils SomeUtils someUtils(); // feature-purchase-api PurchaseInteractor purchaseInteractor(); }</span></span></code> </pre><br>  Dementsprechend <i>sieht build.gradle Feature-Scanner-Impl</i> folgenderma√üen aus: <br><pre> <code class="hljs powershell">// bla<span class="hljs-literal"><span class="hljs-literal">-bla</span></span><span class="hljs-literal"><span class="hljs-literal">-bla</span></span> dependencies { implementation project(<span class="hljs-string"><span class="hljs-string">':core-utils'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-network-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-db-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-purchase-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-scanner-api'</span></span>) // bla<span class="hljs-literal"><span class="hljs-literal">-bla</span></span><span class="hljs-literal"><span class="hljs-literal">-bla</span></span> }</code> </pre><br>  Sie fragen sich vielleicht, warum sich die API f√ºr externe Abh√§ngigkeiten nicht im API-Modul befindet.  Tatsache ist, dass dies ein Detail der Implementierung ist.  Das hei√üt, es handelt sich um eine bestimmte Implementierung, die bestimmte Abh√§ngigkeiten ben√∂tigt.  F√ºr den Abh√§ngigkeits-API-Scanner gibt es hier: <br><img src="https://habrastorage.org/webt/8y/7o/fj/8y7ofjd9oxd344hzqua8xcqtdci.png"><br><br>  <b>Kleiner architektonischer R√ºckzugsort</b> <br>  Lassen Sie uns all das oben <i>Genannte zusammenfassen</i> und einige architektonische Punkte in Bezug auf <i>Feature -...- Impl-Module</i> und deren Abh√§ngigkeiten von anderen Modulen verstehen. <br>  Ich habe zwei der beliebtesten Abh√§ngigkeitszuordnungsmuster f√ºr ein Modul kennengelernt: <br><br><ul><li>  Ein Modul kann √ºber jeden Bescheid wissen.  Es gibt keine Regeln.  Es gibt nichts zu kommentieren. </li><li>  Module kennen nur das <i>Kernmodul</i> .  Und im <i>Kernmodul sind</i> alle Schnittstellen aller Funktionen konzentriert.  Dieser Ansatz ist f√ºr mich nicht sehr ansprechend, da die Gefahr besteht, dass der <i>Kern</i> in eine andere M√ºllkippe verwandelt wird.  Wenn wir unser Modul in eine andere Anwendung √ºbertragen m√∂chten, m√ºssen wir diese Schnittstellen in eine andere Anwendung kopieren und im <i>Kern platzieren</i> .  Das bl√∂de Kopieren und Einf√ºgen von Schnittstellen an und f√ºr sich ist nicht sehr attraktiv und kann in Zukunft wiederverwendet werden, wenn die Schnittstellen aktualisiert werden k√∂nnen. </li></ul><br>  In unserem Beispiel bef√ºrworte ich Kenntnisse √ºber API und nur √ºber API-Module (also Utils-Gruppen).  Features wissen nichts √ºber Implementierungen. <br><br>  Es stellt sich jedoch heraus, dass Features andere Features kennen (nat√ºrlich √ºber API) und ausf√ºhren k√∂nnen.  K√∂nnte es ein Chaos sein? <br>  Faire Bemerkung.  Es ist schwer, einige super klare Regeln auszuarbeiten.  In allem sollte ein Ma√ü sein.  Wir haben dieses Problem bereits etwas weiter oben angesprochen und die Funktionen in unabh√§ngige Funktionen (Scanner und Diebstahlschutz) unterteilt - v√∂llig unabh√§ngig und getrennt - und Funktionen ‚Äûim Kontext‚Äú, dh sie werden immer als Teil von etwas gestartet (Kaufen) und implizieren normalerweise Gesch√§ftslogik ohne ui.  Aus diesem Grund sind sich Scanner und Diebstahlsicherung der K√§ufe bewusst. <br>  Ein weiteres Beispiel.  Stellen Sie sich vor, dass es in Anti-Theft so etwas wie das L√∂schen von Daten gibt, dh das L√∂schen absolut aller Daten vom Telefon.  Es gibt viel Gesch√§ftslogik, ui, es ist v√∂llig isoliert.  Daher ist es logisch, L√∂schdaten als separate Funktion zuzuweisen.  Und dann die Gabel.  Wenn L√∂schdaten immer nur von Anti-Theft gestartet werden und immer in Anti-Theft vorhanden sind, ist es logisch, dass Anti-Theft √ºber L√∂schdaten Bescheid wei√ü und diese selbst ausf√ºhrt.  Und das akkumulierende Modul App w√ºrde dann nur noch √ºber Diebstahlsicherung Bescheid wissen.  Wenn L√∂schdaten jedoch an einer anderen Stelle beginnen k√∂nnen oder in Anti-Theft nicht immer vorhanden sind (dh in verschiedenen Anwendungen unterschiedlich sein k√∂nnen), ist es logisch, dass Anti-Theft diese Funktion nicht kennt und nur etwas Externes sagt (√ºber Router, Durch einen R√ºckruf spielt es keine Rolle, dass der Benutzer die eine oder andere Taste gedr√ºckt hat, und was darunter zu starten ist, ist bereits Sache des Verbrauchers der Anti-Theft-Funktion (bestimmte Anwendung, bestimmte App). <br><br>  Es gibt auch eine interessante Frage zum √úbertragen von Funktionen auf eine andere Anwendung.  Wenn wir zum Beispiel den Scanner auf eine andere Anwendung √ºbertragen m√∂chten, m√ºssen wir zus√§tzlich zu den Modulen <i>: feature-scanner-api</i> und <i>: feature-scanner-impl</i> und den Modulen, von denen der Scanner abh√§ngt ( <i>: core-utils ,: core-network-), auch √ºbertragen. api ,: core-db-api ,: feature-purchase-api</i> ). <br>  Ja aber!  Erstens sind alle Ihre API-Module v√∂llig unabh√§ngig und es gibt nur Schnittstellen und Datenmodelle.  Keine Logik.  Und diese Module sind logisch klar voneinander getrennt, und <i>: core-utils</i> ist normalerweise ein gemeinsames Modul f√ºr alle Anwendungen. <br>  Zweitens k√∂nnen Sie API-Module in Form von aar sammeln und √ºber den Maven an eine andere Anwendung senden, oder Sie k√∂nnen sie in Form eines Gig-Submoduls verbinden.  Aber Sie werden eine Versionierung haben, es wird Kontrolle geben, es wird Integrit√§t geben. <br>  Somit sieht die Wiederverwendung des Moduls (genauer gesagt des Implementierungsmoduls) in einer anderen Anwendung viel einfacher, klarer und sicherer aus. <br><br><h4>  Anwendung </h4><br>  Es scheint, dass wir ein schlankes und verst√§ndliches Bild mit Funktionen, Modulen, ihren Abh√§ngigkeiten haben und das ist alles.  Jetzt kommen wir zu einem H√∂hepunkt - dies ist eine Kombination aus API und ihren Implementierungen, die alle erforderlichen Abh√§ngigkeiten usw. ersetzt, jedoch aus Sicht der Gredloi-Module.  Der Verbindungspunkt ist normalerweise die <i>App</i> selbst. <br>  In unserem Beispiel ist dieser Punkt √ºbrigens immer noch ein <i>Feature-Scanner-Beispiel</i> .  Mit dem oben beschriebenen Ansatz k√∂nnen Sie jede Ihrer Funktionen als separate Anwendung ausf√ºhren, was die Erstellungszeit w√§hrend der aktiven Entwicklung erheblich spart.  Sch√∂nheit! <br><br>  Betrachten wir zun√§chst, wie alles √ºber die <i>App</i> am Beispiel des bereits geliebten Scanners abl√§uft. <br><div class="spoiler">  <b class="spoiler_title">Erinnern Sie sich schnell an die Funktion:</b> <div class="spoiler_text">  Sci externe Abh√§ngigkeiten API ist: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerFeatureDependencies</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// core-db-api DbClientApi dbClient(); // core-network-api HttpClientApi httpClient(); // core-utils SomeUtils someUtils(); // feature-purchase-api PurchaseInteractor purchaseInteractor(); }</span></span></code> </pre><br>  Deshalb <i>: Feature-Scanner-Impl</i> h√§ngt von folgenden Modulen ab: <br><pre> <code class="hljs powershell">// bla<span class="hljs-literal"><span class="hljs-literal">-bla</span></span><span class="hljs-literal"><span class="hljs-literal">-bla</span></span> dependencies { implementation project(<span class="hljs-string"><span class="hljs-string">':core-utils'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-network-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-db-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-purchase-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-scanner-api'</span></span>) // bla<span class="hljs-literal"><span class="hljs-literal">-bla</span></span><span class="hljs-literal"><span class="hljs-literal">-bla</span></span> }</code> </pre><br></div></div><br>  Auf dieser Grundlage k√∂nnen wir eine Dolchkomponente erstellen, die die API externer Abh√§ngigkeiten implementiert: <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span>(dependencies = { CoreUtilsApi.class, CoreNetworkApi.class, CoreDbApi.class, PurchaseFeatureApi.class }) <span class="hljs-meta"><span class="hljs-meta">@PerFeature</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerFeatureDependenciesComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerFeatureDependencies</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre><br>  Ich habe diese Schnittstelle der <i>Einfachheit halber</i> in die <i>ScannerFeatureComponent</i> eingef√ºgt: <br><pre> <code class="hljs pgsql">@Component(modules = { ScannerFeatureModule.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, ScreenNavigationModule.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> }, dependencies = ScannerFeatureDependencies.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>) @PerFeature <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> abstract <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ScannerFeatureComponent implements ScannerFeatureApi { // bla-bla-bla @Component(dependencies = { CoreUtilsApi.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, CoreNetworkApi.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, CoreDbApi.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, PurchaseFeatureApi.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> }) @PerFeature interface ScannerFeatureDependenciesComponent extends ScannerFeatureDependencies { } }</code> </pre><br><br>  Nun die App.  App kennt alle Module, die sie ben√∂tigt ( <i>Core-, Feature-, API, Impl</i> ): <br><pre> <code class="hljs powershell">// bla<span class="hljs-literal"><span class="hljs-literal">-bla</span></span><span class="hljs-literal"><span class="hljs-literal">-bla</span></span> dependencies { implementation project(<span class="hljs-string"><span class="hljs-string">':core-utils'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-db-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-db-impl'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-network-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-network-impl'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-scanner-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-scanner-impl'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-antitheft-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-antitheft-impl'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-purchase-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-purchase-impl'</span></span>) // bla<span class="hljs-literal"><span class="hljs-literal">-bla</span></span><span class="hljs-literal"><span class="hljs-literal">-bla</span></span> }</code> </pre><br>  Erstellen Sie als N√§chstes eine Hilfsklasse.  Zum Beispiel <i>FeatureProxyInjector</i> .  Es wird helfen, alle Komponenten korrekt zu initialisieren, und √ºber diese Klasse werden wir uns den Funktionen zuwenden.  Mal sehen, wie die Scanner-Funktionskomponente initialisiert wird: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeatureProxyInjector</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// another... public static ScannerFeatureApi getFeatureScanner() { return ScannerFeatureComponent.initAndGet( DaggerScannerFeatureComponent_ScannerFeatureDependenciesComponent.builder() .coreDbApi(CoreDbComponent.get()) .coreNetworkApi(CoreNetworkComponent.get()) .coreUtilsApi(CoreUtilsComponent.get()) .purchaseFeatureApi(featurePurchaseGet()) .build() ); } }</span></span></code> </pre><br>  √Ñu√üerlich geben wir die Feature-Oberfl√§che ( <i>ScannerFeatureApi</i> ) an und initialisieren nur das gesamte Implementierungsabh√§ngigkeitsdiagramm (√ºber die <i>ScannerFeatureComponent.initAndGet (...)</i> -Methode). <br>  <i>DaggerPurchaseComponent_PurchaseFeatureDependenciesComponent</i> ist die Implementierung der von Dagger generierten <i>PurchaseFeatureDependenciesComponent</i> , √ºber die wir oben gesprochen haben, wobei wir die Implementierung von API-Modulen im Builder ersetzen. <br>  Das ist alles Magie.  Siehe das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel noch</a> einmal. <br><br>  Apropos <i>Beispiel</i> .  Zum <i>Beispiel m√ºssen</i> wir auch alle externen Abh√§ngigkeiten erf√ºllen <i>: feature-scanner-impl</i> .  Da dies jedoch ein Beispiel ist, k√∂nnen wir Dummy-Klassen ersetzen. <br>  Wie es aussehen wird: <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     ScannerFeatureDependencies public class ScannerFeatureDependenciesFake implements ScannerFeatureDependencies { @Override public DbClientApi dbClient() { return new DbClientFake(); } @Override public HttpClientApi httpClient() { return new HttpClientFake(); } @Override public SomeUtils someUtils() { return CoreUtilsComponent.get().someUtils(); } @Override public PurchaseInteractor purchaseInteractor() { return new PurchaseInteractorFake(); } } //  -  Application-   public class ScannerExampleApplication extends Application { @Override public void onCreate() { super.onCreate(); ScannerFeatureComponent.initAndGet( // ,     =) new ScannerFeatureDependenciesFake() ); } }</span></span></code> </pre><br>  Die Scannerfunktion selbst wird <i>beispielsweise</i> √ºber das Manifest gestartet, um zus√§tzliche leere Aktivit√§ten nicht zu blockieren: <br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">manifest</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:android</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://schemas.android.com/apk/res/android"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">package</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.example.scanner_example"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">application</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">".ScannerExampleApplication"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:allowBackup</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:icon</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@mipmap/ic_launcher"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:label</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@string/app_name"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:roundIcon</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@mipmap/ic_launcher_round"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:supportsRtl</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:theme</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@style/AppTheme"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--   --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">activity</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.example.scanner.presentation.view.ScannerActivity"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">action</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.intent.action.MAIN"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">category</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.intent.category.LAUNCHER"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">activity</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">application</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">manifest</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br><h2>  Algorithmus des √úbergangs von Monomodularit√§t zu Multimodularit√§t </h2><br>  Das Leben ist eine harte Sache.  Und die Realit√§t ist, dass wir alle mit Legacy arbeiten.  Wenn jetzt jemand ein brandneues Projekt s√§gt, bei dem Sie sofort alles segnen k√∂nnen, dann beneide ich Sie, Bruder.  Aber das ist bei mir nicht der Fall und dieser Typ ist auch falsch =). <br><br>  Wie √ºbersetzen Sie Ihre Anwendung in mehrere Module?  Ich habe haupts√§chlich von zwei Optionen geh√∂rt. <br>  Erster.  Partitionierung der Anwendung hier und jetzt.  Es stimmt, Ihr Projekt wird m√∂glicherweise ein oder zwei Monate lang nicht zusammengestellt =). <br>  Zweiter.  Versuchen Sie, die Funktionen schrittweise herauszuziehen.  Gleichzeitig erstrecken sich jedoch alle m√∂glichen Abh√§ngigkeiten dieser Merkmale.  Und hier beginnt der Spa√ü.  Der Abh√§ngigkeitscode kann einen anderen Code abrufen, das Ganze wird in das <i>gemeinsame Modul</i> , in das <i>Kernmodul</i> und umgekehrt usw. migriert.  Infolgedessen kann das Ziehen einer Funktion das Arbeiten mit einer anderen guten H√§lfte der Anwendung bedeuten.  Und wieder wird Ihr Projekt zu Beginn keinen angemessenen Zeitraum haben. <br><br>  Ich bef√ºrworte die schrittweise √úbertragung der Anwendung auf Multimodularit√§t, da wir parallel noch neue Funktionen sehen m√ºssen.  Die Schl√ºsselidee ist, dass <b>Sie diesen Code nicht sofort auch physisch in die Module ziehen sollten</b> , <b>wenn Ihr Modul einige der Abh√§ngigkeiten ben√∂tigt</b> .  Schauen wir uns den Algorithmus zum Entfernen von Modulen am Beispiel des Scanners an: <br><br><ul><li>  Erstellen Sie API-Funktionen und f√ºgen Sie sie in ein neues API-Modul ein.  Das hei√üt, um ein Modul vollst√§ndig zu erstellen <i>: Feature-Scanner-API</i> mit allen Schnittstellen. </li><li>  Erstellen <i>: Feature-Scanner-Impl</i> .  √úbertragen Sie den gesamten Code, der sich auf die Funktion bezieht, physisch auf dieses Modul.  Alles, wovon Ihre Funktion abh√§ngt, wird vom Studio sofort hervorgehoben. </li><li>  Identifizieren Sie Abh√§ngigkeiten von externen Features.  Erstellen Sie entsprechende Schnittstellen.  Diese Schnittstellen sind in logische API-Module unterteilt.  Das hei√üt, in unserem Beispiel erstellen Sie die Module <i>: Core-Utils: Core-Network-API: Core-DB-API: Feature-Purchase-API</i> mit den entsprechenden Schnittstellen. <br>  Ich rate Ihnen, sofort in den Namen und die Bedeutung der Module zu investieren.  Es ist klar, dass Schnittstellen und Module im Laufe der Zeit ein wenig gemischt, reduziert usw. werden k√∂nnen. Dies ist normal. </li><li>  Erstellen Sie eine API f√ºr externe Abh√§ngigkeiten ( <i>ScannerFeatureDependencies</i> ).  Abh√§ngig <i>: Feature-Scanner-Impl</i> registriert neu erstellte API-Module. </li><li>  Da wir das gesamte Erbe in der <i>App haben</i> , tun wir Folgendes.  In der <i>App</i> verbinden wir alle Module, die f√ºr das Feature erstellt wurden (Feature-API-Modul, Feature-Impl-Modul, Feature-API f√ºr externe Abh√§ngigkeitsabh√§ngigkeit). <br>  <b>Super wichtiger Punkt</b> .  Als N√§chstes erstellen wir in der <i>App</i> Implementierungen aller erforderlichen Schnittstellen f√ºr Feature-Abh√§ngigkeiten (in unserem Beispiel Scanner).  Diese Implementierungen sind wahrscheinlich nur Proxys von Ihren API-Abh√§ngigkeiten zur aktuellen Implementierung dieser Abh√§ngigkeiten im Projekt.  Ersetzen Sie beim Initialisieren einer Feature-Komponente die Implementierungsdaten. <br>  Schwierig in Worten, wollen Sie ein Beispiel?  Also ist er es schon!  √Ñhnliches gibt es bereits im Feature-Scanner-Beispiel.  Ich werde ihm noch einmal einen leicht angepassten Code geben: <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     ScannerFeatureDependencies  app- public class ScannerFeatureDependenciesLegacy implements ScannerFeatureDependencies { @Override public DbClientApi dbClient() { return new DbClientLegacy(); } @Override public HttpClientApi httpClient() { // -  // ,      return NetworkFabric.createHttpClientLegacy(); } @Override public SomeUtils someUtils() { return new SomeUtils(); } @Override public PurchaseInteractor purchaseInteractor() { return new PurchaseInteractorLegacy(); } } //  -   ScannerFeatureComponent.initAndGet( new ScannerFeatureDependenciesLegacy() );</span></span></code> </pre><br>  Das hei√üt, die Hauptbotschaft hier ist dies.  Lassen Sie den gesamten f√ºr die Funktion erforderlichen externen Code wie bisher in der <i>App verf√ºgbar</i> .  Und das Feature selbst funktioniert bereits auf normale Weise √ºber API (dh API-Abh√§ngigkeiten und API-Module).  In Zukunft wird die Implementierung schrittweise auf Module umgestellt.  Aber dann vermeiden wir ein endloses Spiel, indem wir den erforderlichen externen Code f√ºr das Feature vom Modul in das Modul ziehen.  Wir k√∂nnen uns in klaren Iterationen bewegen! </li><li>  Gewinn </li></ul><br>  Hier ist ein so einfacher, aber funktionierender Algorithmus, mit dem Sie Schritt f√ºr Schritt auf Ihr Ziel zugehen k√∂nnen. <br><br><h3>  Zus√§tzliche Tipps </h3><br>  <b>Wie gro√ü / klein sollten Features sein?</b> <br>  Es h√§ngt alles vom Projekt usw. ab.  Zu Beginn des √úbergangs zur Multimodularit√§t empfehle ich jedoch, sie in gro√üe Teile aufzuteilen.  Au√üerdem w√§hlen Sie bei Bedarf weitere Module aus diesen Modulen aus.  Aber nicht mahlen.  Tun Sie dies nicht: eine / mehrere Klassen = ein Modul. <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reinheit des App-Moduls</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Sie zur Multimodul- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">App</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wechseln </font><font style="vertical-align: inherit;">, haben wir eine Menge zu bieten, und von dort aus zucken Ihre hervorgehobenen Funktionen. Es ist m√∂glich, dass Sie im Laufe der Arbeit √Ñnderungen an diesem Erbe vornehmen m√ºssen, um dort etwas fertig zu stellen, oder Sie haben nur eine Version, und Sie sind nicht in der Lage, die Module zu zerschneiden. In diesem Fall m√∂chten Sie, dass die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">App</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und damit das gesamte Verm√§chtnis nur √ºber die API √ºber die hervorgehobenen Funktionen informiert wird, ohne √ºber die Implementierungen Bescheid zu wissen. </font><font style="vertical-align: inherit;">Tats√§chlich kombiniert </font><font style="vertical-align: inherit;">die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">App jedoch </font></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Api-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Impl-Module</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und daher </font><font style="vertical-align: inherit;">kennt </font><font style="vertical-align: inherit;">die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">App</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jeden. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Fall k√∂nnen Sie ein spezielles Modul erstellen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Adapter</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die der Verbindungspunkt von API und Impl sein wird, und die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">App</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird dann nur √ºber API Bescheid wissen. </font><font style="vertical-align: inherit;">Ich denke, die Idee ist klar. </font><font style="vertical-align: inherit;">Sie k√∂nnen ein Beispiel im Zweig </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clean_app sehen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ich m√∂chte hinzuf√ºgen, dass es bei Moxy oder besser MoxyReflector einige Probleme beim Aufteilen in Module gibt, weshalb ich ein weiteres zus√§tzliches Modul erstellen musste </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: stub-moxy-java</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Eine leichte Prise Magie, wo ohne. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die einzige √Ñnderung. </font><font style="vertical-align: inherit;">Dies funktioniert nur, wenn Ihre Funktion und die zugeh√∂rigen Abh√§ngigkeiten bereits physisch auf andere Module √ºbertragen wurden. </font><font style="vertical-align: inherit;">Wenn Sie eine Funktion erstellt haben, die Abh√§ngigkeiten jedoch weiterhin in der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">App vorhanden sind</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wie im obigen Algorithmus, funktioniert dies nicht.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachwort </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Artikel fiel ziemlich gro√ü aus. </font><font style="vertical-align: inherit;">Aber ich hoffe, dass es Ihnen im Kampf gegen die Monomodularit√§t wirklich hilft, zu verstehen, wie es sein sollte und wie Sie sich mit DI anfreunden k√∂nnen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie daran interessiert sind, in ein Problem mit der Build-Geschwindigkeit einzutauchen und alles zu messen, empfehle ich die Berichte von Denis Neklyudov und Zhenya Suworow (Mobius 2018 Piter, Videos sind noch nicht √∂ffentlich verf√ºgbar). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úber Gradle. </font><font style="vertical-align: inherit;">Der Unterschied zwischen API und Implementierung in Gradle wurde von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vova Tagakov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> perfekt gezeigt </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn Sie die Multi-Modul-Boilerplate reduzieren m√∂chten, k√∂nnen Sie hier mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diesem Artikel beginnen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich freue mich √ºber Kommentare, Korrekturen und Likes! </font><font style="vertical-align: inherit;">Alles sauberer Code!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de422555/">https://habr.com/ru/post/de422555/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de422545/index.html">M√∂glichkeiten zum Synchronisieren von Browser-Registerkarten</a></li>
<li><a href="../de422547/index.html">Um Spectre und Meltdown zu eliminieren, m√ºssen Sie m√∂glicherweise einen v√∂llig neuen Prozessortyp erstellen</a></li>
<li><a href="../de422549/index.html">Corda: Kotlin</a></li>
<li><a href="../de422551/index.html">So stehlen Sie Geld von einer kontaktlosen Karte und Apple Pay</a></li>
<li><a href="../de422553/index.html">Die offizielle Mega-Browser-Erweiterung stiehlt Dateifreigabedaten und Kryptow√§hrung</a></li>
<li><a href="../de422561/index.html">Wie Yandex Computer Vision einsetzte, um die Qualit√§t von Videosendungen zu verbessern. DeepHD-Technologie</a></li>
<li><a href="../de422565/index.html">Skillbox Friday Webinars: Alles f√ºr Programmierer und Designer</a></li>
<li><a href="../de422569/index.html">St√ºndliche Zeiterfassungs-App</a></li>
<li><a href="../de422571/index.html">Parallelisieren von Aufgaben mit Abh√§ngigkeiten - .NET-Beispiel</a></li>
<li><a href="../de422573/index.html">Das Reverse Engineering des Renderings von The Witcher 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>