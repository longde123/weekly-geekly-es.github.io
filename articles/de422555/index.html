<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🤝‍👨🏻 👨🏻‍⚕️ 🧤 Android-Multimodul-Architektur. Von A bis Z. 👨🏻‍🚀 👩🏾‍🤝‍👩🏼 🚜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! 

 Vor nicht allzu langer Zeit haben wir erkannt, dass eine mobile Anwendung nicht nur ein Thin Client ist, sondern eine wirklich gr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Android-Multimodul-Architektur. Von A bis Z.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/kaspersky/blog/422555/"> Hallo allerseits! <br><br>  Vor nicht allzu langer Zeit haben wir erkannt, dass eine mobile Anwendung nicht nur ein Thin Client ist, sondern eine wirklich große Anzahl sehr unterschiedlicher Logik, die optimiert werden muss.  Aus diesem Grund haben wir uns von den Ideen der sauberen Architektur inspirieren lassen, fühlen, was DI ist, haben gelernt, wie man Dolch 2 verwendet, und jetzt können wir mit geschlossenen Augen jedes Merkmal in Ebenen aufteilen. <br><br>  Aber die Welt steht nicht still und mit der Lösung alter Probleme kommen neue.  Und der Name dieses neuen Problems ist Monomodularität.  Sie erfahren dieses Problem normalerweise, wenn die Montagezeit in den Weltraum vergeht.  Genau so viele Berichte über den Übergang zur Multimodularität ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eins</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei</a> ) beginnen. <br>  Aber aus irgendeinem Grund vergisst jeder gleichzeitig irgendwie, dass die Monomodularität nicht nur die Montagezeit, sondern auch Ihre Architektur stark beeinflusst.  Hier beantworten Sie die Fragen.  Wie groß ist Ihre AppComponent?  Sehen Sie im Code regelmäßig, dass Feature A aus irgendeinem Grund das Repository von Feature B abruft, obwohl es nicht so aussehen sollte, oder sollte es irgendwie mehr Top-Level sein?  Haben Features einen Vertrag?  Und wie organisieren Sie die Kommunikation zwischen Funktionen?  Gibt es Regeln? <br>  Sie haben das Gefühl, dass wir das Problem mit den Ebenen gelöst haben, das heißt, vertikal scheint alles in Ordnung zu sein, aber horizontal läuft etwas schief?  Und nur die Pakete aufzuschlüsseln und die Überprüfung zu kontrollieren, löst das Problem nicht. <br><br>  Und die Sicherheitsfrage für die Erfahreneren.  Mussten Sie bei der Umstellung auf Multimodularität nicht die Hälfte der Anwendung schaufeln, den Code immer von einem Modul auf ein anderes ziehen und einen angemessenen Zeitraum mit einem nicht zusammengestellten Projekt verbringen? <br><br>  In meinem Artikel möchte ich Ihnen erzählen, wie ich genau aus architektonischer Sicht zur Multimodularität gekommen bin.  Welche Probleme haben mich gestört und wie ich versucht habe, sie schrittweise zu lösen.  Und am Ende finden Sie einen Algorithmus für den Wechsel von Monomodularität zu Multimodularität ohne Tränen und Schmerzen. <br><a name="habracut"></a><br>  Bei der Beantwortung der ersten Frage, wie groß die AppComponent ist, kann ich gestehen - groß, wirklich groß.  Und es quälte mich ständig.  Wie ist es passiert?  Dies ist in erster Linie auf eine solche DI-Organisation zurückzuführen.  Mit DI werden wir beginnen. <br><br><h2>  Wie ich es vorher getan habe </h2><br>  Ich denke, dass viele Menschen in ihren Köpfen so etwas wie dieses Diagramm der Abhängigkeiten der Komponenten und der entsprechenden Bereiche gebildet haben: <br><img src="https://habrastorage.org/webt/f1/xm/so/f1xmsoakbmgcfys9rjuys_jmnvo.png"><br><br><h4>  Was haben wir hier? </h4><br>  <b>AppComponent</b> , die absolut alle Abhängigkeiten mit <i>Singleton-</i> Bereichen absorbierte.  Ich denke, fast jeder hat diese Komponente. <br><br>  <b>FeatureComponents</b> .  Jedes Feature hatte seinen eigenen Bereich und war eine Unterkomponente von <i>AppComponent</i> oder ein Senior-Feature. <br>  Lassen Sie uns ein wenig auf die Funktionen eingehen.  Was ist eine Funktion?  Ich werde es in meinen eigenen Worten versuchen.  <b>Eine Funktion</b> ist ein logisch vollständiges, maximal unabhängiges Programmmodul, das ein bestimmtes Benutzerproblem mit klar definierten externen Abhängigkeiten löst und in einem anderen Programm relativ einfach wieder verwendet werden kann.  Features können groß und klein sein.  Funktionen können andere Funktionen enthalten.  Sie können auch andere Funktionen über klar definierte externe Abhängigkeiten verwenden oder ausführen.  Wenn wir unsere Anwendung (Kaspersky Internet Security für Android) verwenden, können Funktionen als Anti-Virus, Anti-Theft usw. betrachtet werden. <br><br>  <b>ScreenComponents</b> .  Eine Komponente für einen bestimmten Bildschirm, die ebenfalls einen eigenen Bereich hat und gleichzeitig eine Unterkomponente der entsprechenden Feature-Komponente ist. <br><br><h4>  Nun eine Liste von "warum so" </h4><br>  <b>Warum Unterkomponenten?</b> <br>  Bei Komponentenabhängigkeiten hat mir die Tatsache nicht gefallen, dass eine Komponente von mehreren Komponenten gleichzeitig abhängen kann, was meiner Meinung nach letztendlich zu einem Chaos der Komponenten und ihrer Abhängigkeiten führen kann.  Wenn Sie eine strikte Eins-zu-Viele-Beziehung haben (eine Komponente und ihre Unterkomponenten), ist dies sicherer und offensichtlicher.  Darüber hinaus stehen der Unterkomponente standardmäßig alle Abhängigkeiten des übergeordneten Elements zur Verfügung, was ebenfalls praktischer ist. <br><br>  <b>Warum gibt es für jede Funktion einen Bereich?</b> <br>  Weil ich dann von den Überlegungen ausgegangen bin, dass jedes Feature eine Art eigenen Lebenszyklus ist, der nicht mit dem anderer identisch ist, ist es logisch, einen eigenen Bereich zu erstellen.  Es gibt noch einen Punkt für viele geizige Dinge, den ich unten erwähnen werde. <br><br>  Da wir im Zusammenhang mit Clean über Dolch 2 sprechen, werde ich auch den Moment erwähnen, in dem Abhängigkeiten geliefert wurden.  Präsentatoren, Interaktoren, Repositorys und andere Hilfsklassen von Abhängigkeiten wurden über den Konstruktor bereitgestellt.  In Tests ersetzen wir dann Stubs oder Moki durch den Konstruktor und testen unsere Klasse leise. <br>  Das Schließen des Abhängigkeitsgraphen erfolgt normalerweise in Aktivitäten, Fragmenten, manchmal Empfängern und Diensten im Allgemeinen an den Wurzelstellen, von denen aus der Android etwas starten kann.  Die klassische Situation besteht darin, dass eine Aktivität für ein Feature erstellt wird, die Feature-Komponente startet und in der Aktivität lebt und im Feature selbst drei Bildschirme vorhanden sind, die in drei Fragmenten implementiert sind. <br><br>  Alles scheint also logisch zu sein.  Aber wie immer nimmt das Leben seine eigenen Anpassungen vor. <br><br><h2>  Lebensprobleme </h2><br><h3>  Beispielaufgabe </h3><br>  Schauen wir uns ein einfaches Beispiel aus unserer Anwendung an.  Wir haben eine Scannerfunktion und eine Diebstahlsicherung.  Beide Funktionen haben einen geschätzten Kaufknopf.  Darüber hinaus sendet „Kaufen“ nicht nur eine Anfrage, sondern auch eine Vielzahl unterschiedlicher Logik in Bezug auf den Kaufprozess.  Dies ist eine reine Geschäftslogik mit einigen Dialogen für den sofortigen Kauf.  Das heißt, es gibt eine ganz andere Funktion für sich - Kauf.  Daher müssen wir in zwei Funktionen die dritte Funktion verwenden. <br>  Aus Sicht der Benutzeroberfläche und der Navigation haben wir das folgende Bild.  Der Hauptbildschirm startet mit zwei Tasten: <br><img src="https://habrastorage.org/webt/ps/1o/qj/ps1oqjtlzdybdcj21pokcadin8u.png"><br><br>  Durch Klicken auf diese Schaltflächen gelangen wir zur Funktion des Scanners oder der Diebstahlsicherung. <br>  Betrachten Sie die Funktion des Scanners: <br><img src="https://habrastorage.org/webt/p5/2g/yw/p52gywypiko82skvl0mn90hd5wq.png"><br><br>  Durch Klicken auf "Antiviren-Scan starten" wird eine Art Scan-Arbeit erledigt. Wenn Sie auf "Kaufen" klicken, möchten wir nur kaufen, das heißt, wir ziehen die Funktion "Käufe" auf, aber auf "Hilfe" gelangen wir mit einer Hilfe zu einem einfachen Bildschirm. <br>  Die Funktion von Anti-Theft sieht fast gleich aus. <br><br><h3>  Mögliche Lösungen </h3><br>  Wie implementieren wir dieses Beispiel in Bezug auf DI?  Es gibt mehrere Möglichkeiten. <br><br><h4>  Erste Option </h4><br>  Wählen Sie eine <i>Kauffunktion</i> als <i><b>unabhängige Komponente aus</b></i> , die nur von der <i>AppComponent abhängt</i> . <br><img src="https://habrastorage.org/webt/ia/aq/t2/iaaqt2fi01u1lvjixbn9uspxgyi.png"><br><br>  Aber dann stehen wir vor dem Problem: Wie können Abhängigkeiten von zwei verschiedenen Graphen (Komponenten) gleichzeitig in eine Klasse eingefügt werden?  Nur durch schmutzige Krücken, was natürlich so ist. <br><br><h4>  Zweite Option </h4><br>  Wir wählen die Kauffunktion in der Unterkomponente aus, die von der AppComponent abhängt.  Und die Komponenten des Scanners und der Diebstahlsicherung können aus der Kaufkomponente zu Unterkomponenten gemacht werden. <br><img src="https://habrastorage.org/webt/wh/sh/y3/whshy3v3buimdjy2sfo6w1de3ys.png"><br><br>  Wie Sie verstehen, kann es in Anwendungen jedoch viele ähnliche Situationen geben.  Dies bedeutet, dass die Tiefe der Abhängigkeiten der Komponenten sehr groß und komplex sein kann.  Ein solches Diagramm ist verwirrender, als Ihre Anwendung kohärenter und verständlicher zu machen. <br><br><h4>  Dritte Option </h4><br>  Wir wählen die Kauffunktion <b>nicht in einer separaten Komponente, sondern in einem separaten Dolchmodul</b> .  Zwei Wege sind weiter möglich. <br><br>  <b>Erster Weg</b> <br>  <i>Fügen</i> wir allen Abhängigkeiten die <i>Singleton-</i> <i>Bereichsfunktionen hinzu</i> und stellen eine Verbindung zur <i>AppComponent her</i> . <br><img src="https://habrastorage.org/webt/gx/wb/3h/gxwb3hokdqdrrcypwykypnym0n8.png"><br><br>  Die Option ist beliebt, führt jedoch zu einer Aufblähung der <i>AppComponent</i> .  Infolgedessen nimmt die Größe zu, enthält alle Anwendungsklassen, und der springende Punkt bei der Verwendung von Dagger ist die bequemere Übermittlung von Abhängigkeiten an Klassen - über Felder oder den Konstruktor und nicht über Singletones.  Im Prinzip ist dies DI, aber wir vermissen architektonische Punkte und es stellt sich heraus, dass jeder über jeden Bescheid weiß. <br>  Wenn Sie zu Beginn des Pfads nicht wissen, wo Sie eine Klasse welchem ​​Feature zuordnen sollen, ist es im Allgemeinen einfacher, sie global zu gestalten.  Dies ist häufig der Fall, wenn Sie mit Legacy arbeiten und versuchen, zumindest eine Art Architektur einzubringen. Außerdem kennen Sie den gesamten Code noch nicht gut.  Und dort weiteten sich tatsächlich die Augen, und diese Handlungen sind gerechtfertigt.  Der Fehler ist, dass niemand diese <i>AppComponent</i> in <i>Angriff nehmen</i> möchte, wenn sich mehr oder weniger alles abzeichnet. <br><br>  <b>Zweiter Weg</b> <br>  Dies ist eine Reduzierung aller Funktionen auf einen einzigen Bereich, z. B. <i>PerFeature</i> . <br><img src="https://habrastorage.org/webt/pm/5u/og/pm5uogvwcybvetc4nrfekteyqy4.png"><br><br>  Dann können wir das Dolchmodul des Einkaufs einfach und einfach mit den notwendigen Komponenten verbinden. <br>  Es scheint bequem.  Aber architektonisch stellt sich heraus, nicht isoliert.  Die Funktionen des Scanners und der Diebstahlsicherung wissen absolut alles über die Kauffunktion, alle Innereien.  Es kann versehentlich etwas beteiligt sein.  Das heißt, die Kauffunktion verfügt nicht über eine eindeutige API, die Grenze zwischen den Funktionen ist verschwommen und es gibt keinen eindeutigen Vertrag.  Das ist schlecht.  Nun, im multimodularen Bereich wird das Gredloid später schwierig sein. <br><br><h3>  Architektonischer Schmerz </h3><br>  Ehrlich gesagt habe ich lange Zeit die <b>dritte Option verwendet. Den ersten Weg</b> .  Dies war eine notwendige Maßnahme, als wir begannen, unser Erbe schrittweise auf normale Schienen zu übertragen.  Aber wie ich bereits erwähnt habe, beginnen sich bei diesem Ansatz Ihre Funktionen ein wenig zu vermischen.  Jeder kann über jeden Bescheid wissen, über die Details der Implementierung und dies für jeden.  Und das Aufblähen von <i>AppComponent zeigte</i> deutlich, dass etwas getan werden muss. <br>  Übrigens würde die <b>dritte Option</b> beim Entladen von <i>AppComponent helfen</i> <b>. Der zweite Weg</b> .  Das Wissen über Implementierungen und Mischfunktionen wird jedoch nirgendwo hingehen.  Natürlich wäre es sehr schwierig, Funktionen zwischen Anwendungen wiederzuverwenden. <br><br><h3>  Zwischenschlussfolgerungen </h3><br>  Also, was wollen wir am Ende?  Welche Probleme wollen wir lösen?  Gehen wir gleich zum Punkt, beginnend mit DI und weiter zur Architektur: <br><br><ul><li>  Ein praktischer DI-Mechanismus, mit dem Sie Funktionen in anderen Funktionen verwenden können (in unserem Beispiel möchten wir die Einkaufsfunktion in Scanner und Diebstahlschutz verwenden), ohne Krücken und Schmerzen. </li><li>  Die dünnste AppComponent. </li><li>  Features sollten keine Implementierungen anderer Features kennen. </li><li>  Die Funktionen sollten standardmäßig für niemanden zugänglich sein. Ich möchte einen strengen Kontrollmechanismus. </li><li>  Es ist möglich, die Funktion mit einer minimalen Anzahl von Gesten einer anderen Anwendung zuzuweisen. </li><li>  Ein logischer Übergang zu Multimodularität und Best Practices für diesen Übergang. </li></ul><br>  Ich habe erst ganz am Ende speziell über Multimodularität gesprochen.  Wir werden sie erreichen, wir werden uns nicht übertreffen. <br><br><h2>  "Auf neue Weise leben" </h2><br>  Jetzt werden wir versuchen, die obige Wunschliste schrittweise umzusetzen. <br>  Lass uns gehen! <br><br><h3>  DI-Verbesserungen </h3><br>  Beginnen wir mit dem gleichen DI. <br><br><h4>  Ablehnung einer großen Anzahl von Bereichen </h4><br>  Wie ich oben schrieb, war mein Ansatz vor diesem: für jedes Feature seinen eigenen Umfang.  Tatsächlich gibt es daraus keine besonderen Gewinne.  Erhalten Sie nur eine große Anzahl von Bereichen und eine gewisse Menge an Kopfschmerzen. <br>  Diese Kette ist völlig ausreichend: <i>Singleton</i> - <i>PerFeature</i> - <i>PerScreen</i> . <br><br><h4>  Aufgabe von Unterkomponenten zugunsten von Komponentenabhängigkeiten </h4><br>  Schon ein interessanter Punkt.  Mit <i>Unterkomponenten</i> scheinen Sie eine strengere Hierarchie zu haben, aber gleichzeitig haben Sie die Hände vollständig gebunden und es gibt keine Möglichkeit, irgendwie zu manövrieren.  Darüber hinaus kennt <i>AppComponent</i> alle Funktionen und Sie erhalten eine riesige generierte Klasse <i>DaggerAppComponent</i> . <br>  Mit <i>Komponentenabhängigkeiten erhalten</i> Sie einen super coolen Vorteil.  In Komponentenabhängigkeiten können Sie <b>keine Komponenten</b> angeben <b>, sondern saubere Schnittstellen</b> (dank Denis und Volodya).  Dank dieser Funktion können Sie beliebige Schnittstellenimplementierungen ersetzen. Dagger frisst alles.  Auch wenn die Komponente mit demselben Umfang diese Implementierung ist: <br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span>( dependencies = FeatureDependencies.class, modules = FeatureModule.class ) <span class="hljs-meta"><span class="hljs-meta">@PerFeature</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeatureComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } public interface FeatureDependencies { SomeDependency someDependency(); } @Component( modules = AnotherFeatureModule.class ) @PerFeature public abstract class AnotherFeatureComponent implements FeatureDependencies { // ... }</span></span></code> </pre> <br><br><h3>  Von DI-Verbesserungen zu architektonischen Verbesserungen </h3><br>  Wiederholen wir die Definition von Features.  <b>Eine Funktion</b> ist ein logisch vollständiges, maximal unabhängiges Programmmodul, das ein bestimmtes Benutzerproblem mit klar definierten externen Abhängigkeiten löst und in einem anderen Programm relativ einfach wiederverwendet werden kann.  Einer der Schlüsselausdrücke bei der Definition eines Features ist „mit klar definierten externen Abhängigkeiten“.  Beschreiben wir daher alles, was wir von der Außenwelt für Funktionen erwarten, in einer speziellen Oberfläche. <br>  Hier ist beispielsweise die externe Abhängigkeitsschnittstelle der Einkaufsfunktion: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PurchaseFeatureDependencies</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">HttpClientApi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">httpClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  Oder die Schnittstelle der externen Abhängigkeiten der Scannerfunktion: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerFeatureDependencies</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">DbClientApi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dbClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">HttpClientApi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">httpClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">SomeUtils </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someUtils</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//       PurchaseInteractor purchaseInteractor(); }</span></span></code> </pre><br>  Wie im Abschnitt über DI erwähnt, können Abhängigkeiten von jedem implementiert werden. Wie Sie möchten, handelt es sich hierbei um reine Schnittstellen, und unsere Funktionen sind von diesem zusätzlichen Wissen befreit. <br><br>  Eine weitere wichtige Komponente eines „reinen“ Features ist das Vorhandensein einer klaren API, über die die Außenwelt auf das Feature zugreifen kann. <br>  Hier sind die API-Funktionen von Shopping: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PurchaseFeatureApi</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">PurchaseInteractor </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">purchaseInteractor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  Das heißt, die Außenwelt kann einen <i>PurchaseInteractor erhalten</i> und versuchen, über diesen einen Kauf zu tätigen.  Oben haben wir gesehen, dass der Scanner einen <i>PurchaseInteractor</i> benötigt, um den Kauf abzuschließen. <br><br>  Und hier sind die API-Funktionen des Scanners: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerFeatureApi</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">ScannerStarter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scannerStarter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  Und sofort bringe ich die Schnittstelle und Implementierung von <i>ScannerStarter</i> : <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerStarter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context)</span></span></span></span>; } <span class="hljs-meta"><span class="hljs-meta">@PerFeature</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerStarterImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerStarter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ScannerStarterImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context)</span></span></span><span class="hljs-function"> </span></span>{ Class&lt;?&gt; cls = ScannerActivity.class; Intent intent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Intent(context, cls); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(intent); } }</code> </pre><br>  Hier ist es interessanter.  Tatsache ist, dass der Scanner und der Diebstahlschutz ziemlich geschlossene und isolierte Funktionen sind.  In meinem Beispiel werden diese Funktionen in separaten Aktivitäten mit eigener Navigation usw. gestartet. Das heißt, wir können hier einfach die Aktivität starten.  Aktivität stirbt - die Funktion stirbt.  Sie können auf der Grundlage des Prinzips „Einzelaktivität“ arbeiten und dann über API-Funktionen beispielsweise einen FragmentManager und einen Rückruf übergeben, über den die Funktion meldet, dass sie abgeschlossen wurde.  Es gibt viele Variationen. <br>  Wir können auch sagen, dass wir das Recht haben, Funktionen wie Scanner und Diebstahlschutz als unabhängige Anwendungen zu betrachten.  Im Gegensatz zu der Funktion des Kaufs, die eine Funktionsergänzung zu etwas darstellt, existiert sie irgendwie nicht besonders.  Ja, es ist unabhängig, aber es ist eine logische Ergänzung zu anderen Funktionen. <br><br>  Wie Sie sich vorstellen können, muss es einen Punkt geben, der die Funktionen, ihre Implementierung und die erforderlichen Funktionen der Abhängigkeit miteinander verbindet.  Dieser Punkt ist die Dolchkomponente. <br><div class="spoiler">  <b class="spoiler_title">Ein Beispiel für eine Funktionskomponente des Scanners:</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span>(modules = { ScannerFeatureModule.class, ScreenNavigationModule.class <span class="hljs-comment"><span class="hljs-comment">// ScannerFeatureDependencies - api    }, dependencies = ScannerFeatureDependencies.class) @PerFeature // ScannerFeatureApi - api   public abstract class ScannerFeatureComponent implements ScannerFeatureApi { private static volatile ScannerFeatureComponent sScannerFeatureComponent; //   public static ScannerFeatureApi initAndGet( ScannerFeatureDependencies scannerFeatureDependencies) { if (sScannerFeatureComponent == null) { synchronized (ScannerFeatureComponent.class) { if (sScannerFeatureComponent == null) { sScannerFeatureComponent = DaggerScannerFeatureComponent.builder() .scannerFeatureDependencies(scannerFeatureDependencies) .build(); } } } return sScannerFeatureComponent; } //           public static ScannerFeatureComponent get() { if (sScannerFeatureComponent == null) { throw new RuntimeException( "You must call 'initAndGet(ScannerFeatureDependenciesComponent scannerFeatureDependenciesComponent)' method" ); } return sScannerFeatureComponent; } //    (   ) public void resetComponent() { sScannerFeatureComponent = null; } public abstract void inject(ScannerActivity scannerActivity); //         Moxy public abstract ScannerScreenComponent scannerScreenComponent(); }</span></span></code> </pre><br></div></div><br>  Ich denke nichts Neues für dich. <br><br><h3>  Übergang zur Multimodularität </h3><br>  Sie und ich konnten also die Grenzen des Features durch die API seiner Abhängigkeiten und die externe API klar definieren.  Wir haben auch herausgefunden, wie man alles in Dagger auf Touren bringt.  Und jetzt kommen wir zum nächsten logischen und interessanten Schritt - der Aufteilung in Module. <br>  Öffnen Sie sofort einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Testfall</a> - es wird einfacher. <br>  Schauen wir uns das Bild allgemein an: <br><img src="https://habrastorage.org/webt/qq/uw/bg/qquwbgerknuk95cjefxfxqserxi.png"><br>  Schauen Sie sich die Paketstruktur des Beispiels an: <br><img src="https://habrastorage.org/webt/cs/_a/4a/cs_a4ap7km-ivyxwzk615blftby.png"><br>  Lassen Sie uns nun jeden Punkt sorgfältig besprechen. <br><br>  Zunächst sehen wir vier große Blöcke: <b>Application</b> , <b>API</b> , <b>Impl</b> und <b>Utils</b> .  In den <i>APIs</i> , <i>Impl</i> und <i>Utils stellen</i> Sie möglicherweise fest, dass alle Module <b>entweder bei Core-</b> oder <b>Feature- beginnen</b> .  Lassen Sie uns zuerst über sie sprechen. <br><br><h4>  Trennung in Kern und Merkmal </h4><br>  Ich teile alle Module in zwei Kategorien ein: <i>Core-</i> und <i>Feature-</i> . <br>  In <i>Feature-</i> , wie Sie vielleicht erraten haben, unsere Features.  Im <b>Kern gibt</b> es solche Dinge wie Dienstprogramme, Arbeiten mit einem Netzwerk, Datenbanken usw. Aber es gibt dort keine Funktionsschnittstellen.  Und der <i>Kern</i> ist kein Monolith.  Ich bin dafür, das <i>Kernmodul</i> in logische Teile zu zerlegen und es nicht mit einigen anderen Funktionsschnittstellen zu laden. <br>  Schreiben Sie im Namen des Moduls zuerst den <i>Kern</i> oder das <i>Feature</i> .  Weiter im Modulnamen befindet sich ein logischer Name ( <i>Scanner</i> , <i>Netzwerk</i> usw.). <br><br><h4>  Nun zu vier großen Blöcken: Application, API, Impl und Utils </h4><br>  <b>API</b> <br>  Jedes <i>Feature</i> oder <i>Kernmodul ist</i> in <i>API</i> und <i>Impl unterteilt</i> .  Die <i>API</i> enthält eine externe API, über die Sie auf eine Funktion oder einen Kern zugreifen können.  Nur das und nichts weiter: <br><img src="https://habrastorage.org/webt/8_/gz/0c/8_gz0ckdfivle1avlexldnj_mdc.png"><br>  Außerdem kennt das <i>API-Modul</i> niemanden, es ist ein absolut isoliertes Modul. <br><br>  <b>Utils</b> <br>  Die einzige Ausnahme von der obigen Regel kann als ein völlig zweckmäßiges Element angesehen werden, bei dem es keinen Sinn macht, in API und Implementierung einzubrechen. <br><br>  <b>Impl</b> <br>  Hier haben wir eine Unterteilung in <i>Core-Impl</i> und <i>Feature-Impl</i> . <br>  Die Module in <i>core-impl sind</i> ebenfalls völlig unabhängig.  Ihre einzige Abhängigkeit ist das <i>API-Modul</i> .  Schauen Sie sich als Beispiel die <i>build.gradle des</i> <i>core-db-impl-Moduls an</i> : <br><pre> <code class="hljs powershell">// bla<span class="hljs-literal"><span class="hljs-literal">-bla</span></span><span class="hljs-literal"><span class="hljs-literal">-bla</span></span> dependencies { implementation project(<span class="hljs-string"><span class="hljs-string">':core-db-api'</span></span>) // bla<span class="hljs-literal"><span class="hljs-literal">-bla</span></span><span class="hljs-literal"><span class="hljs-literal">-bla</span></span> }</code> </pre><br>  Nun zu <i>Feature-Impl</i> .  Es gibt bereits den Löwenanteil der Anwendungslogik.  Die Module der <i>Feature-Impl-Gruppe</i> können etwas über die Module der <i>API-</i> oder <i>Utils-</i> Gruppe wissen, aber sie wissen sicherlich nichts über die anderen Module der <i>Impl-</i> Gruppe. <br>  Wie wir uns erinnern, werden alle externen Abhängigkeiten des Features in den externen Abhängigkeiten akkumuliert.  Für eine Funktion von Scan sieht diese API beispielsweise wie folgt aus: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerFeatureDependencies</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// core-db-api DbClientApi dbClient(); // core-network-api HttpClientApi httpClient(); // core-utils SomeUtils someUtils(); // feature-purchase-api PurchaseInteractor purchaseInteractor(); }</span></span></code> </pre><br>  Dementsprechend <i>sieht build.gradle Feature-Scanner-Impl</i> folgendermaßen aus: <br><pre> <code class="hljs powershell">// bla<span class="hljs-literal"><span class="hljs-literal">-bla</span></span><span class="hljs-literal"><span class="hljs-literal">-bla</span></span> dependencies { implementation project(<span class="hljs-string"><span class="hljs-string">':core-utils'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-network-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-db-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-purchase-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-scanner-api'</span></span>) // bla<span class="hljs-literal"><span class="hljs-literal">-bla</span></span><span class="hljs-literal"><span class="hljs-literal">-bla</span></span> }</code> </pre><br>  Sie fragen sich vielleicht, warum sich die API für externe Abhängigkeiten nicht im API-Modul befindet.  Tatsache ist, dass dies ein Detail der Implementierung ist.  Das heißt, es handelt sich um eine bestimmte Implementierung, die bestimmte Abhängigkeiten benötigt.  Für den Abhängigkeits-API-Scanner gibt es hier: <br><img src="https://habrastorage.org/webt/8y/7o/fj/8y7ofjd9oxd344hzqua8xcqtdci.png"><br><br>  <b>Kleiner architektonischer Rückzugsort</b> <br>  Lassen Sie uns all das oben <i>Genannte zusammenfassen</i> und einige architektonische Punkte in Bezug auf <i>Feature -...- Impl-Module</i> und deren Abhängigkeiten von anderen Modulen verstehen. <br>  Ich habe zwei der beliebtesten Abhängigkeitszuordnungsmuster für ein Modul kennengelernt: <br><br><ul><li>  Ein Modul kann über jeden Bescheid wissen.  Es gibt keine Regeln.  Es gibt nichts zu kommentieren. </li><li>  Module kennen nur das <i>Kernmodul</i> .  Und im <i>Kernmodul sind</i> alle Schnittstellen aller Funktionen konzentriert.  Dieser Ansatz ist für mich nicht sehr ansprechend, da die Gefahr besteht, dass der <i>Kern</i> in eine andere Müllkippe verwandelt wird.  Wenn wir unser Modul in eine andere Anwendung übertragen möchten, müssen wir diese Schnittstellen in eine andere Anwendung kopieren und im <i>Kern platzieren</i> .  Das blöde Kopieren und Einfügen von Schnittstellen an und für sich ist nicht sehr attraktiv und kann in Zukunft wiederverwendet werden, wenn die Schnittstellen aktualisiert werden können. </li></ul><br>  In unserem Beispiel befürworte ich Kenntnisse über API und nur über API-Module (also Utils-Gruppen).  Features wissen nichts über Implementierungen. <br><br>  Es stellt sich jedoch heraus, dass Features andere Features kennen (natürlich über API) und ausführen können.  Könnte es ein Chaos sein? <br>  Faire Bemerkung.  Es ist schwer, einige super klare Regeln auszuarbeiten.  In allem sollte ein Maß sein.  Wir haben dieses Problem bereits etwas weiter oben angesprochen und die Funktionen in unabhängige Funktionen (Scanner und Diebstahlschutz) unterteilt - völlig unabhängig und getrennt - und Funktionen „im Kontext“, dh sie werden immer als Teil von etwas gestartet (Kaufen) und implizieren normalerweise Geschäftslogik ohne ui.  Aus diesem Grund sind sich Scanner und Diebstahlsicherung der Käufe bewusst. <br>  Ein weiteres Beispiel.  Stellen Sie sich vor, dass es in Anti-Theft so etwas wie das Löschen von Daten gibt, dh das Löschen absolut aller Daten vom Telefon.  Es gibt viel Geschäftslogik, ui, es ist völlig isoliert.  Daher ist es logisch, Löschdaten als separate Funktion zuzuweisen.  Und dann die Gabel.  Wenn Löschdaten immer nur von Anti-Theft gestartet werden und immer in Anti-Theft vorhanden sind, ist es logisch, dass Anti-Theft über Löschdaten Bescheid weiß und diese selbst ausführt.  Und das akkumulierende Modul App würde dann nur noch über Diebstahlsicherung Bescheid wissen.  Wenn Löschdaten jedoch an einer anderen Stelle beginnen können oder in Anti-Theft nicht immer vorhanden sind (dh in verschiedenen Anwendungen unterschiedlich sein können), ist es logisch, dass Anti-Theft diese Funktion nicht kennt und nur etwas Externes sagt (über Router, Durch einen Rückruf spielt es keine Rolle, dass der Benutzer die eine oder andere Taste gedrückt hat, und was darunter zu starten ist, ist bereits Sache des Verbrauchers der Anti-Theft-Funktion (bestimmte Anwendung, bestimmte App). <br><br>  Es gibt auch eine interessante Frage zum Übertragen von Funktionen auf eine andere Anwendung.  Wenn wir zum Beispiel den Scanner auf eine andere Anwendung übertragen möchten, müssen wir zusätzlich zu den Modulen <i>: feature-scanner-api</i> und <i>: feature-scanner-impl</i> und den Modulen, von denen der Scanner abhängt ( <i>: core-utils ,: core-network-), auch übertragen. api ,: core-db-api ,: feature-purchase-api</i> ). <br>  Ja aber!  Erstens sind alle Ihre API-Module völlig unabhängig und es gibt nur Schnittstellen und Datenmodelle.  Keine Logik.  Und diese Module sind logisch klar voneinander getrennt, und <i>: core-utils</i> ist normalerweise ein gemeinsames Modul für alle Anwendungen. <br>  Zweitens können Sie API-Module in Form von aar sammeln und über den Maven an eine andere Anwendung senden, oder Sie können sie in Form eines Gig-Submoduls verbinden.  Aber Sie werden eine Versionierung haben, es wird Kontrolle geben, es wird Integrität geben. <br>  Somit sieht die Wiederverwendung des Moduls (genauer gesagt des Implementierungsmoduls) in einer anderen Anwendung viel einfacher, klarer und sicherer aus. <br><br><h4>  Anwendung </h4><br>  Es scheint, dass wir ein schlankes und verständliches Bild mit Funktionen, Modulen, ihren Abhängigkeiten haben und das ist alles.  Jetzt kommen wir zu einem Höhepunkt - dies ist eine Kombination aus API und ihren Implementierungen, die alle erforderlichen Abhängigkeiten usw. ersetzt, jedoch aus Sicht der Gredloi-Module.  Der Verbindungspunkt ist normalerweise die <i>App</i> selbst. <br>  In unserem Beispiel ist dieser Punkt übrigens immer noch ein <i>Feature-Scanner-Beispiel</i> .  Mit dem oben beschriebenen Ansatz können Sie jede Ihrer Funktionen als separate Anwendung ausführen, was die Erstellungszeit während der aktiven Entwicklung erheblich spart.  Schönheit! <br><br>  Betrachten wir zunächst, wie alles über die <i>App</i> am Beispiel des bereits geliebten Scanners abläuft. <br><div class="spoiler">  <b class="spoiler_title">Erinnern Sie sich schnell an die Funktion:</b> <div class="spoiler_text">  Sci externe Abhängigkeiten API ist: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerFeatureDependencies</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// core-db-api DbClientApi dbClient(); // core-network-api HttpClientApi httpClient(); // core-utils SomeUtils someUtils(); // feature-purchase-api PurchaseInteractor purchaseInteractor(); }</span></span></code> </pre><br>  Deshalb <i>: Feature-Scanner-Impl</i> hängt von folgenden Modulen ab: <br><pre> <code class="hljs powershell">// bla<span class="hljs-literal"><span class="hljs-literal">-bla</span></span><span class="hljs-literal"><span class="hljs-literal">-bla</span></span> dependencies { implementation project(<span class="hljs-string"><span class="hljs-string">':core-utils'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-network-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-db-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-purchase-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-scanner-api'</span></span>) // bla<span class="hljs-literal"><span class="hljs-literal">-bla</span></span><span class="hljs-literal"><span class="hljs-literal">-bla</span></span> }</code> </pre><br></div></div><br>  Auf dieser Grundlage können wir eine Dolchkomponente erstellen, die die API externer Abhängigkeiten implementiert: <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span>(dependencies = { CoreUtilsApi.class, CoreNetworkApi.class, CoreDbApi.class, PurchaseFeatureApi.class }) <span class="hljs-meta"><span class="hljs-meta">@PerFeature</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerFeatureDependenciesComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerFeatureDependencies</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre><br>  Ich habe diese Schnittstelle der <i>Einfachheit halber</i> in die <i>ScannerFeatureComponent</i> eingefügt: <br><pre> <code class="hljs pgsql">@Component(modules = { ScannerFeatureModule.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, ScreenNavigationModule.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> }, dependencies = ScannerFeatureDependencies.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>) @PerFeature <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> abstract <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ScannerFeatureComponent implements ScannerFeatureApi { // bla-bla-bla @Component(dependencies = { CoreUtilsApi.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, CoreNetworkApi.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, CoreDbApi.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, PurchaseFeatureApi.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> }) @PerFeature interface ScannerFeatureDependenciesComponent extends ScannerFeatureDependencies { } }</code> </pre><br><br>  Nun die App.  App kennt alle Module, die sie benötigt ( <i>Core-, Feature-, API, Impl</i> ): <br><pre> <code class="hljs powershell">// bla<span class="hljs-literal"><span class="hljs-literal">-bla</span></span><span class="hljs-literal"><span class="hljs-literal">-bla</span></span> dependencies { implementation project(<span class="hljs-string"><span class="hljs-string">':core-utils'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-db-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-db-impl'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-network-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-network-impl'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-scanner-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-scanner-impl'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-antitheft-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-antitheft-impl'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-purchase-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-purchase-impl'</span></span>) // bla<span class="hljs-literal"><span class="hljs-literal">-bla</span></span><span class="hljs-literal"><span class="hljs-literal">-bla</span></span> }</code> </pre><br>  Erstellen Sie als Nächstes eine Hilfsklasse.  Zum Beispiel <i>FeatureProxyInjector</i> .  Es wird helfen, alle Komponenten korrekt zu initialisieren, und über diese Klasse werden wir uns den Funktionen zuwenden.  Mal sehen, wie die Scanner-Funktionskomponente initialisiert wird: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeatureProxyInjector</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// another... public static ScannerFeatureApi getFeatureScanner() { return ScannerFeatureComponent.initAndGet( DaggerScannerFeatureComponent_ScannerFeatureDependenciesComponent.builder() .coreDbApi(CoreDbComponent.get()) .coreNetworkApi(CoreNetworkComponent.get()) .coreUtilsApi(CoreUtilsComponent.get()) .purchaseFeatureApi(featurePurchaseGet()) .build() ); } }</span></span></code> </pre><br>  Äußerlich geben wir die Feature-Oberfläche ( <i>ScannerFeatureApi</i> ) an und initialisieren nur das gesamte Implementierungsabhängigkeitsdiagramm (über die <i>ScannerFeatureComponent.initAndGet (...)</i> -Methode). <br>  <i>DaggerPurchaseComponent_PurchaseFeatureDependenciesComponent</i> ist die Implementierung der von Dagger generierten <i>PurchaseFeatureDependenciesComponent</i> , über die wir oben gesprochen haben, wobei wir die Implementierung von API-Modulen im Builder ersetzen. <br>  Das ist alles Magie.  Siehe das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel noch</a> einmal. <br><br>  Apropos <i>Beispiel</i> .  Zum <i>Beispiel müssen</i> wir auch alle externen Abhängigkeiten erfüllen <i>: feature-scanner-impl</i> .  Da dies jedoch ein Beispiel ist, können wir Dummy-Klassen ersetzen. <br>  Wie es aussehen wird: <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     ScannerFeatureDependencies public class ScannerFeatureDependenciesFake implements ScannerFeatureDependencies { @Override public DbClientApi dbClient() { return new DbClientFake(); } @Override public HttpClientApi httpClient() { return new HttpClientFake(); } @Override public SomeUtils someUtils() { return CoreUtilsComponent.get().someUtils(); } @Override public PurchaseInteractor purchaseInteractor() { return new PurchaseInteractorFake(); } } //  -  Application-   public class ScannerExampleApplication extends Application { @Override public void onCreate() { super.onCreate(); ScannerFeatureComponent.initAndGet( // ,     =) new ScannerFeatureDependenciesFake() ); } }</span></span></code> </pre><br>  Die Scannerfunktion selbst wird <i>beispielsweise</i> über das Manifest gestartet, um zusätzliche leere Aktivitäten nicht zu blockieren: <br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">manifest</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:android</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://schemas.android.com/apk/res/android"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">package</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.example.scanner_example"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">application</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">".ScannerExampleApplication"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:allowBackup</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:icon</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@mipmap/ic_launcher"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:label</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@string/app_name"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:roundIcon</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@mipmap/ic_launcher_round"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:supportsRtl</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:theme</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@style/AppTheme"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--   --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">activity</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.example.scanner.presentation.view.ScannerActivity"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">action</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.intent.action.MAIN"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">category</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.intent.category.LAUNCHER"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">activity</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">application</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">manifest</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br><h2>  Algorithmus des Übergangs von Monomodularität zu Multimodularität </h2><br>  Das Leben ist eine harte Sache.  Und die Realität ist, dass wir alle mit Legacy arbeiten.  Wenn jetzt jemand ein brandneues Projekt sägt, bei dem Sie sofort alles segnen können, dann beneide ich Sie, Bruder.  Aber das ist bei mir nicht der Fall und dieser Typ ist auch falsch =). <br><br>  Wie übersetzen Sie Ihre Anwendung in mehrere Module?  Ich habe hauptsächlich von zwei Optionen gehört. <br>  Erster.  Partitionierung der Anwendung hier und jetzt.  Es stimmt, Ihr Projekt wird möglicherweise ein oder zwei Monate lang nicht zusammengestellt =). <br>  Zweiter.  Versuchen Sie, die Funktionen schrittweise herauszuziehen.  Gleichzeitig erstrecken sich jedoch alle möglichen Abhängigkeiten dieser Merkmale.  Und hier beginnt der Spaß.  Der Abhängigkeitscode kann einen anderen Code abrufen, das Ganze wird in das <i>gemeinsame Modul</i> , in das <i>Kernmodul</i> und umgekehrt usw. migriert.  Infolgedessen kann das Ziehen einer Funktion das Arbeiten mit einer anderen guten Hälfte der Anwendung bedeuten.  Und wieder wird Ihr Projekt zu Beginn keinen angemessenen Zeitraum haben. <br><br>  Ich befürworte die schrittweise Übertragung der Anwendung auf Multimodularität, da wir parallel noch neue Funktionen sehen müssen.  Die Schlüsselidee ist, dass <b>Sie diesen Code nicht sofort auch physisch in die Module ziehen sollten</b> , <b>wenn Ihr Modul einige der Abhängigkeiten benötigt</b> .  Schauen wir uns den Algorithmus zum Entfernen von Modulen am Beispiel des Scanners an: <br><br><ul><li>  Erstellen Sie API-Funktionen und fügen Sie sie in ein neues API-Modul ein.  Das heißt, um ein Modul vollständig zu erstellen <i>: Feature-Scanner-API</i> mit allen Schnittstellen. </li><li>  Erstellen <i>: Feature-Scanner-Impl</i> .  Übertragen Sie den gesamten Code, der sich auf die Funktion bezieht, physisch auf dieses Modul.  Alles, wovon Ihre Funktion abhängt, wird vom Studio sofort hervorgehoben. </li><li>  Identifizieren Sie Abhängigkeiten von externen Features.  Erstellen Sie entsprechende Schnittstellen.  Diese Schnittstellen sind in logische API-Module unterteilt.  Das heißt, in unserem Beispiel erstellen Sie die Module <i>: Core-Utils: Core-Network-API: Core-DB-API: Feature-Purchase-API</i> mit den entsprechenden Schnittstellen. <br>  Ich rate Ihnen, sofort in den Namen und die Bedeutung der Module zu investieren.  Es ist klar, dass Schnittstellen und Module im Laufe der Zeit ein wenig gemischt, reduziert usw. werden können. Dies ist normal. </li><li>  Erstellen Sie eine API für externe Abhängigkeiten ( <i>ScannerFeatureDependencies</i> ).  Abhängig <i>: Feature-Scanner-Impl</i> registriert neu erstellte API-Module. </li><li>  Da wir das gesamte Erbe in der <i>App haben</i> , tun wir Folgendes.  In der <i>App</i> verbinden wir alle Module, die für das Feature erstellt wurden (Feature-API-Modul, Feature-Impl-Modul, Feature-API für externe Abhängigkeitsabhängigkeit). <br>  <b>Super wichtiger Punkt</b> .  Als Nächstes erstellen wir in der <i>App</i> Implementierungen aller erforderlichen Schnittstellen für Feature-Abhängigkeiten (in unserem Beispiel Scanner).  Diese Implementierungen sind wahrscheinlich nur Proxys von Ihren API-Abhängigkeiten zur aktuellen Implementierung dieser Abhängigkeiten im Projekt.  Ersetzen Sie beim Initialisieren einer Feature-Komponente die Implementierungsdaten. <br>  Schwierig in Worten, wollen Sie ein Beispiel?  Also ist er es schon!  Ähnliches gibt es bereits im Feature-Scanner-Beispiel.  Ich werde ihm noch einmal einen leicht angepassten Code geben: <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     ScannerFeatureDependencies  app- public class ScannerFeatureDependenciesLegacy implements ScannerFeatureDependencies { @Override public DbClientApi dbClient() { return new DbClientLegacy(); } @Override public HttpClientApi httpClient() { // -  // ,      return NetworkFabric.createHttpClientLegacy(); } @Override public SomeUtils someUtils() { return new SomeUtils(); } @Override public PurchaseInteractor purchaseInteractor() { return new PurchaseInteractorLegacy(); } } //  -   ScannerFeatureComponent.initAndGet( new ScannerFeatureDependenciesLegacy() );</span></span></code> </pre><br>  Das heißt, die Hauptbotschaft hier ist dies.  Lassen Sie den gesamten für die Funktion erforderlichen externen Code wie bisher in der <i>App verfügbar</i> .  Und das Feature selbst funktioniert bereits auf normale Weise über API (dh API-Abhängigkeiten und API-Module).  In Zukunft wird die Implementierung schrittweise auf Module umgestellt.  Aber dann vermeiden wir ein endloses Spiel, indem wir den erforderlichen externen Code für das Feature vom Modul in das Modul ziehen.  Wir können uns in klaren Iterationen bewegen! </li><li>  Gewinn </li></ul><br>  Hier ist ein so einfacher, aber funktionierender Algorithmus, mit dem Sie Schritt für Schritt auf Ihr Ziel zugehen können. <br><br><h3>  Zusätzliche Tipps </h3><br>  <b>Wie groß / klein sollten Features sein?</b> <br>  Es hängt alles vom Projekt usw. ab.  Zu Beginn des Übergangs zur Multimodularität empfehle ich jedoch, sie in große Teile aufzuteilen.  Außerdem wählen Sie bei Bedarf weitere Module aus diesen Modulen aus.  Aber nicht mahlen.  Tun Sie dies nicht: eine / mehrere Klassen = ein Modul. <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reinheit des App-Moduls</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Sie zur Multimodul- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">App</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wechseln </font><font style="vertical-align: inherit;">, haben wir eine Menge zu bieten, und von dort aus zucken Ihre hervorgehobenen Funktionen. Es ist möglich, dass Sie im Laufe der Arbeit Änderungen an diesem Erbe vornehmen müssen, um dort etwas fertig zu stellen, oder Sie haben nur eine Version, und Sie sind nicht in der Lage, die Module zu zerschneiden. In diesem Fall möchten Sie, dass die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">App</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und damit das gesamte Vermächtnis nur über die API über die hervorgehobenen Funktionen informiert wird, ohne über die Implementierungen Bescheid zu wissen. </font><font style="vertical-align: inherit;">Tatsächlich kombiniert </font><font style="vertical-align: inherit;">die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">App jedoch </font></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Api-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Impl-Module</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und daher </font><font style="vertical-align: inherit;">kennt </font><font style="vertical-align: inherit;">die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">App</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jeden. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Fall können Sie ein spezielles Modul erstellen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Adapter</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die der Verbindungspunkt von API und Impl sein wird, und die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">App</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird dann nur über API Bescheid wissen. </font><font style="vertical-align: inherit;">Ich denke, die Idee ist klar. </font><font style="vertical-align: inherit;">Sie können ein Beispiel im Zweig </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clean_app sehen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ich möchte hinzufügen, dass es bei Moxy oder besser MoxyReflector einige Probleme beim Aufteilen in Module gibt, weshalb ich ein weiteres zusätzliches Modul erstellen musste </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: stub-moxy-java</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Eine leichte Prise Magie, wo ohne. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die einzige Änderung. </font><font style="vertical-align: inherit;">Dies funktioniert nur, wenn Ihre Funktion und die zugehörigen Abhängigkeiten bereits physisch auf andere Module übertragen wurden. </font><font style="vertical-align: inherit;">Wenn Sie eine Funktion erstellt haben, die Abhängigkeiten jedoch weiterhin in der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">App vorhanden sind</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wie im obigen Algorithmus, funktioniert dies nicht.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachwort </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Artikel fiel ziemlich groß aus. </font><font style="vertical-align: inherit;">Aber ich hoffe, dass es Ihnen im Kampf gegen die Monomodularität wirklich hilft, zu verstehen, wie es sein sollte und wie Sie sich mit DI anfreunden können. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie daran interessiert sind, in ein Problem mit der Build-Geschwindigkeit einzutauchen und alles zu messen, empfehle ich die Berichte von Denis Neklyudov und Zhenya Suworow (Mobius 2018 Piter, Videos sind noch nicht öffentlich verfügbar). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Über Gradle. </font><font style="vertical-align: inherit;">Der Unterschied zwischen API und Implementierung in Gradle wurde von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vova Tagakov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> perfekt gezeigt </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn Sie die Multi-Modul-Boilerplate reduzieren möchten, können Sie hier mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diesem Artikel beginnen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich freue mich über Kommentare, Korrekturen und Likes! </font><font style="vertical-align: inherit;">Alles sauberer Code!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de422555/">https://habr.com/ru/post/de422555/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de422545/index.html">Möglichkeiten zum Synchronisieren von Browser-Registerkarten</a></li>
<li><a href="../de422547/index.html">Um Spectre und Meltdown zu eliminieren, müssen Sie möglicherweise einen völlig neuen Prozessortyp erstellen</a></li>
<li><a href="../de422549/index.html">Corda: Kotlin</a></li>
<li><a href="../de422551/index.html">So stehlen Sie Geld von einer kontaktlosen Karte und Apple Pay</a></li>
<li><a href="../de422553/index.html">Die offizielle Mega-Browser-Erweiterung stiehlt Dateifreigabedaten und Kryptowährung</a></li>
<li><a href="../de422561/index.html">Wie Yandex Computer Vision einsetzte, um die Qualität von Videosendungen zu verbessern. DeepHD-Technologie</a></li>
<li><a href="../de422565/index.html">Skillbox Friday Webinars: Alles für Programmierer und Designer</a></li>
<li><a href="../de422569/index.html">Stündliche Zeiterfassungs-App</a></li>
<li><a href="../de422571/index.html">Parallelisieren von Aufgaben mit Abhängigkeiten - .NET-Beispiel</a></li>
<li><a href="../de422573/index.html">Das Reverse Engineering des Renderings von The Witcher 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>