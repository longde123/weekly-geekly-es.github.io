<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐟 😘 👩‍⚖️ Recursos modernos em C ++ que todos os programadores precisam conhecer 🏂🏽 🧒🏽 🍫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O autor do material, cuja tradução publicamos hoje, diz que o C ++, em sua forma moderna, quando comparado ao que era esse idioma há vários anos, mudo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Recursos modernos em C ++ que todos os programadores precisam conhecer</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/451870/">  O autor do material, cuja tradução publicamos hoje, diz que o C ++, em sua forma moderna, quando comparado ao que era esse idioma há vários anos, mudou significativamente para melhor.  Obviamente, essas mudanças não aconteceram imediatamente.  Por exemplo, antigamente, o C ++ não possuía dinamismo.  Não foi fácil encontrar uma pessoa que pudesse dizer que tem sentimentos ternos por esse idioma.  Tudo mudou quando os responsáveis ​​pela padronização da linguagem decidiram dar lugar a inovações.  Em 2011, o C ++ se tornou uma linguagem dinâmica, uma linguagem em constante evolução e que causa emoções muito mais positivas aos programadores. <br><br>  Não pense que o idioma se tornou mais fácil.  Ainda pode ser chamada de uma das linguagens de programação mais complexas amplamente usadas, se não a mais complexa.  Mas o C ++ moderno se tornou muito mais amigável do que antes. <br><br><img src="https://habrastorage.org/webt/qk/ii/cx/qkiicxclyr6agfsxlcplndrkpd8.jpeg"><br><br>  Hoje falaremos sobre alguns dos novos recursos da linguagem (a partir do C ++ 11, que, a propósito, já tem 8 anos), que serão úteis para qualquer programador. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Palavra-chave automática</font> </h2><br>  Desde que a palavra <code>auto</code> chave <code>auto</code> apareceu no C ++ 11, a vida dos programadores se tornou mais fácil.  Graças a essa palavra-chave, o compilador pode gerar tipos de variáveis ​​em tempo de compilação, o que nos impede de sempre precisar especificar os tipos.  Isso acabou sendo muito conveniente, por exemplo, nos casos em que você precisa trabalhar com tipos de dados como <code>map&lt;string,vector&lt;pair&lt;int,int&gt;&gt;&gt;</code> .  Ao usar a palavra <code>auto</code> chave <code>auto</code> , há algumas coisas a considerar.  Considere um exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> an_int = <span class="hljs-number"><span class="hljs-number">26</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    ,     - int auto a_bool = false; //   bool auto a_float = 26.04; //   float auto ptr = &amp;a_float; //       auto data; // #1     ?    - .</span></span></code> </pre> <br>  Preste atenção à última linha deste exemplo, cujo comentário está marcado como <code>#1</code> (a seguir, de maneira semelhante, marcaremos as linhas que analisaremos após os exemplos).  Não há inicializador nesta linha, você não pode fazer isso.  O código localizado nesta linha impede que o compilador saiba qual deve ser o tipo da variável correspondente. <br><br>  Inicialmente, a palavra <code>auto</code> chave <code>auto</code> em C ++ era bastante limitada.  Em versões mais recentes do idioma, recursos adicionados <code>auto</code> .  Aqui está outro exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">merge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//            auto! {   std::vector&lt;int&gt; c = do_something(a, b);   return c; } std::vector&lt;int&gt; a = { ... }; // #1 -  std::vector&lt;int&gt; b = { ... }; // #2  -  auto c = merge(a,b); //      </span></span></span></span></code> </pre> <br>  As linhas <code>#1</code> e <code>#2</code> aplicam a inicialização variável usando chaves - outro novo recurso no C ++ 11. <br><br>  Lembre-se de que, ao usar a palavra <code>auto</code> chave <code>auto</code> , o compilador deve ter uma maneira de inferir o tipo da variável. <br><br>  Agora, uma pergunta interessante.  O que acontece se você usar um design como <code>auto a = {1, 2, 3}</code> ?  O que é isso  Vector ou causa de erro de compilação? <br><br>  De fato, uma construção do formulário <code>std::initializer_list&lt;type&gt;</code> apareceu no C ++ 11.  A lista entre parênteses de valores de inicialização será tratada como um contêiner usando a palavra <code>auto</code> chave <code>auto</code> . <br><br>  E, finalmente, como já mencionado, a inferência de tipo pelo compilador pode ser extremamente útil se você precisar trabalhar com estruturas de dados complexas.  Aqui está um exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">populate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    !   data.insert({"a",{1,4}});   data.insert({"b",{3,1}});   data.insert({"c",{2,3}}); } auto merge(auto data, auto upcoming_data) { //         auto result = data;   for(auto it: upcoming_data) {       result.insert(it);   }   return result; } int main() {   std::map&lt;std::string, std::pair&lt;int,int&gt;&gt; data;   populate(data);   std::map&lt;std::string, std::pair&lt;int,int&gt;&gt; upcoming_data;   upcoming_data.insert({"d",{5,3}});   auto final_data = merge(data,upcoming_data);   for(auto itr: final_data) {       auto [v1, v2] = itr.second; // #1               std::cout &lt;&lt; itr.first &lt;&lt; " " &lt;&lt; v1 &lt;&lt; " " &lt;&lt; v2 &lt;&lt; std:endl;   }   return 0; }</span></span></code> </pre> <br>  Dê uma olhada na linha <code>#1</code> .  A expressão <code>auto [v1,v2] = itr.second</code> representa um novo recurso do C ++ 17. Essa é a chamada decomposição ao declarar variáveis.  Nas versões anteriores do idioma, cada valor tinha que ser extraído individualmente.  Graças a esse mecanismo, executar essas operações se tornou muito mais conveniente. <br><br>  Além disso, se você precisar trabalhar com dados usando links, basta adicionar apenas um caractere a essa construção, convertendo-o no seguinte formato: <code>auto &amp;[v1,v2] = itr.second</code> . <br><br><h2>  <font color="#3AC1EF">Expressões lambda</font> </h2><br>  O C ++ 11 apresenta suporte para expressões lambda.  Eles se parecem com funções anônimas em JavaScript, podem ser comparados com objetos funcionais sem nomes.  Eles capturam variáveis ​​em vários escopos, dependendo de sua descrição, para as quais construções sintáticas compactas são usadas.  Além disso, eles podem ser atribuídos a variáveis. <br><br>  As expressões Lambda são uma ferramenta muito útil para os casos em que você precisa executar uma pequena operação no código, mas não deseja gravar uma função separada para isso.  Outro exemplo comum de seu uso é a criação de funções usadas na comparação de valores.  Por exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; data = {{<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}, {<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>}, {<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}}; <span class="hljs-comment"><span class="hljs-comment">//        std::sort(begin(data), end(data), [](auto a, auto b) { //   - auto!   return a.second &lt; b.second; });</span></span></code> </pre> <br>  Você pode encontrar muitas coisas interessantes neste pequeno exemplo. <br><br>  Primeiro, preste atenção à conveniência de usar a inicialização variável usando chaves.  A seguir, podemos ver as construções padrão <code>begin()</code> e <code>end()</code> , que também apareceram no C ++ 11. Em seguida, vem a função lambda, que é usada como um mecanismo para comparar dados.  Os parâmetros desta função são declarados usando a palavra <code>auto</code> chave <code>auto</code> , esse recurso apareceu no C ++ 14. Anteriormente, essa palavra-chave não podia ser usada para descrever os parâmetros das funções. <br><br>  Agora observe que a expressão lambda começa com colchetes - <code>[]</code> .  Essa é a chamada máscara de variáveis.  Ele determina o escopo da expressão, ou seja, permite controlar o relacionamento da expressão lambda com variáveis ​​e objetos locais. <br><br>  Aqui está um trecho <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">deste</a> repositório dedicado aos recursos modernos do C ++: <br><br><ul><li>  <code>[]</code> - a expressão não captura nada.  Isso significa que em uma expressão lambda é impossível usar variáveis ​​locais do escopo externo a ela.  Somente parâmetros podem ser usados ​​na expressão. </li><li>  <code>[=]</code> - a expressão captura os valores de objetos locais (ou seja, variáveis ​​locais, parâmetros).  Isso significa que eles podem ser usados, mas não modificados. </li><li>  <code>[&amp;]</code> - a expressão captura referências a objetos locais.  Eles podem ser modificados, conforme mostrado no exemplo a seguir. </li><li>  <code>[this]</code> - a expressão captura o valor <code>this</code> ponteiro. </li><li>  <code>[a, &amp;b]</code> - a expressão captura o valor do objeto <code>a</code> e uma referência ao objeto <code>b</code> . </li></ul><br>  Como resultado, se dentro da função lambda você precisar converter os dados para outro formato, poderá usar os mecanismos acima.  Considere um exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; data = {<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> factor = <span class="hljs-number"><span class="hljs-number">7</span></span>; for_each(begin(data), end(data), [&amp;factor](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &amp;val) { <span class="hljs-comment"><span class="hljs-comment">//    factor     val = val * factor;   factor--; // #1   - ,  -    factor   }); for(int val: data) {   std::cout &lt;&lt; val &lt;&lt; ' '; // 14 24 20 4 3 6 9 }</span></span></code> </pre> <br>  Aqui, se a variável <code>factor</code> fosse acessada por valor (a variável mask <code>[factor]</code> seria usada para descrever a expressão lambda), na linha <code>#1</code> o valor do <code>factor</code> não poderia ser alterado - simplesmente porque não teríamos direito a executando tal operação.  Neste exemplo, temos o direito de tais ações.  Em tais situações, é importante não abusar dos recursos que acessam variáveis ​​fornecidas por referência. <br><br>  Além disso, observe que <code>val</code> também <code>val</code> acessado por referência.  Isso garante que as alterações de dados que ocorrem na função lambda afetem o <code>vector</code> . <br><br><h2>  <font color="#3AC1EF">Expressões de inicialização variáveis ​​dentro das construções if e switch</font> </h2><br>  Eu realmente gostei dessa inovação do C ++ 17 logo depois que descobri.  Considere um exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; input = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = input.find(<span class="hljs-number"><span class="hljs-number">7</span></span>); it==input.end()){ <span class="hljs-comment"><span class="hljs-comment">//   - ,  -    std::cout &lt;&lt; 7 &lt;&lt; " not found" &lt;&lt; std:endl; } else {   //    else      it   std::cout &lt;&lt; 7 &lt;&lt; " is there!" &lt;&lt; std::endl; }</span></span></code> </pre> <br>  Acontece que agora você pode inicializar as variáveis ​​e comparar com o uso delas em um bloco <code>if</code> ou <code>switch</code> .  Isso ajuda a escrever um código preciso.  Aqui está uma descrição esquemática da estrutura em consideração: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( init-statement(x); condition(x)) {   <span class="hljs-comment"><span class="hljs-comment">//    } else {   //     x   //    }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Executando cálculos em tempo de compilação usando constexpr</font> </h2><br>  A <code>constexpr</code> nos oferece grandes oportunidades.  Suponha que tenhamos algum tipo de expressão que precisa ser calculada, enquanto seu valor, após inicializá-lo com a variável correspondente, não será alterado.  Essa expressão pode ser calculada antecipadamente e usada como macro.  Ou, o que se tornou possível no C ++ 11, use a <code>constexpr</code> . <br><br>  Os programadores se esforçam para minimizar a quantidade de computação realizada durante a execução do programa.  Como resultado, se determinadas operações puderem ser executadas durante o processo de compilação e, assim, remover a carga do sistema durante a execução do programa, isso terá um bom efeito no comportamento do programa durante a execução.  Aqui está um exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; constexpr long long fact(long long n) { //       constexpr return n == 1 ? 1 : (fact(n-1) * n); } int main() { const long long bigval = fact(20); std::cout&lt;&lt;bigval&lt;&lt;std::endl; }</span></span></span></span></code> </pre> <br>  Este é um exemplo muito comum de uso do <code>constexpr</code> . <br><br>  Como declaramos a função para calcular o fatorial como <code>constexpr</code> , o compilador pode pré-calcular o valor do <code>fact(20)</code> no momento da compilação do programa.  Como resultado, após a compilação, a string <code>const long long bigval = fact(20);</code>  pode ser substituído por <code>const long long bigval = 2432902008176640000;</code>  . <br><br>  Observe que o argumento passado para a função é representado por uma constante.  Esse é um recurso importante do uso de funções declaradas usando a <code>constexpr</code> .  Os argumentos passados ​​para eles também devem ser declarados com a <code>constexpr</code> - <code>constexpr</code> ou com a palavra-chave <code>const</code> .  Caso contrário, essas funções se comportarão como funções comuns, ou seja, durante a compilação, seus valores não serão calculados com antecedência. <br><br>  As variáveis ​​também podem ser declaradas usando a <code>constexpr</code> .  Nesse caso, como você pode imaginar, os valores dessas variáveis ​​devem ser calculados em tempo de compilação.  Se isso não puder ser feito, uma mensagem de erro de compilação será exibida. <br><br>  É interessante notar que, mais tarde, em C ++ 17, as construções <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">constexpr-if</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">constexpr-lambda</a> apareceram. <br><br><h2>  <font color="#3AC1EF">Estruturas de dados de tupla</font> </h2><br>  Como a estrutura de dados do <code>pair</code> a estrutura de dados da <code>tuple</code> (tupla) é uma coleção de valores de diferentes tipos de tamanho fixo.  Aqui está um exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user_info = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-string"><span class="hljs-string">"Chowdhury"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  auto     //    std::get&lt;0&gt;(user_info); std::get&lt;1&gt;(user_info); std::get&lt;2&gt;(user_info); //  C++ 11     tie std::string first_name, last_name, age; std::tie(first_name, last_name, age) = user_info; //  C++ 17, ,       auto [first_name, last_name, age] = user_info;</span></span></code> </pre> <br>  Às vezes, em vez de uma estrutura de dados de <code>tuple</code> , é mais conveniente usar <code>std::array</code> .  Essa estrutura de dados é semelhante às matrizes simples usadas na linguagem C, equipadas com recursos adicionais da biblioteca padrão C ++.  Essa estrutura de dados apareceu no C ++ 11. <br><br><h2>  <font color="#3AC1EF">Inferência automática do tipo de argumento do modelo de classe</font> </h2><br>  O nome desse recurso parece bastante longo e complexo, mas na verdade não há nada complicado aqui.  A idéia principal aqui é que, no C ++ 17, a saída de tipos de argumentos de modelo também é executada para modelos de classe padrão.  Anteriormente, isso era suportado apenas para modelos funcionais.  Como resultado, acontece que eles costumavam escrever assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; user = {<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>};</code> </pre> <br>  Com o lançamento do C ++ 17, essa construção agora pode ser substituída por: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair user = {<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>};</code> </pre> <br>  A inferência de tipo é feita implicitamente.  Esse mecanismo é ainda mais conveniente quando se trata de tuplas.  Ou seja, antes eu tinha que escrever o seguinte: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; user (<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-string"><span class="hljs-string">"Chy"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>);</code> </pre> <br>  Agora, a mesma coisa se parece com isso: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">tuple </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">user2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"M"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"Chy"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">25</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre> <br>  Vale ressaltar que esses recursos não parecerão algo digno de atenção para aqueles que não estão particularmente familiarizados com os modelos C ++. <br><br><h2>  <font color="#3AC1EF">Ponteiros inteligentes</font> </h2><br>  Trabalhar com ponteiros em C ++ pode ser um verdadeiro pesadelo.  Graças à liberdade que a linguagem oferece ao programador, às vezes é muito difícil para ele, como se costuma dizer, "não dar um tiro no pé".  Em muitos casos, os indicadores estão pressionando por uma "chance" do programador. <br><br>  Felizmente, o C ++ 11 introduziu indicadores inteligentes que são muito mais convenientes do que indicadores comuns.  Eles ajudam o programador a evitar vazamentos de memória, liberando recursos quando possível.  Além disso, eles fornecem uma garantia de segurança para exceções. <br><br><h2>  <font color="#3AC1EF">Sumário</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aqui está um</a> bom repositório, que, acreditamos, será interessante para quem seguir as inovações do C ++.  Algo novo está constantemente aparecendo nesse idioma.  Aqui abordamos apenas alguns recursos modernos do idioma.  De fato, existem muitos deles.  É possível que ainda falemos sobre eles. <br><br>  <b>Caros leitores!</b>  Quais recursos modernos do C ++ você considera mais interessantes e úteis? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt451870/">https://habr.com/ru/post/pt451870/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt451858/index.html">Criando um disjuntor simples baseado em cache no Spring</a></li>
<li><a href="../pt451860/index.html">Matemáticos descobriram a maneira perfeita de multiplicar números</a></li>
<li><a href="../pt451862/index.html">Musical Lightning, de Joe Diprim: um engenheiro autodidata faz bobinas de Tesla para entretenimento e ganhos</a></li>
<li><a href="../pt451864/index.html">Vulnerabilidade crítica ao nível de EternalBlue no RCE detectada no sistema operacional Windows</a></li>
<li><a href="../pt451866/index.html">Escolha os nós mais próximos na rede</a></li>
<li><a href="../pt451872/index.html">Python é um assistente para encontrar voos baratos para quem gosta de viajar</a></li>
<li><a href="../pt451874/index.html">Principais tendências de SEO no Google</a></li>
<li><a href="../pt451876/index.html">Data center de Frankfurt: data center de Telehouse</a></li>
<li><a href="../pt451878/index.html">Transmissão ao vivo de vídeo estéreo para óculos VR (Oculus Go)</a></li>
<li><a href="../pt451880/index.html">DevPRO'19: vista do estande da Wrike</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>