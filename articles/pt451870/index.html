<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêü üòò üë©‚Äç‚öñÔ∏è Recursos modernos em C ++ que todos os programadores precisam conhecer üèÇüèΩ üßíüèΩ üç´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O autor do material, cuja tradu√ß√£o publicamos hoje, diz que o C ++, em sua forma moderna, quando comparado ao que era esse idioma h√° v√°rios anos, mudo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Recursos modernos em C ++ que todos os programadores precisam conhecer</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/451870/">  O autor do material, cuja tradu√ß√£o publicamos hoje, diz que o C ++, em sua forma moderna, quando comparado ao que era esse idioma h√° v√°rios anos, mudou significativamente para melhor.  Obviamente, essas mudan√ßas n√£o aconteceram imediatamente.  Por exemplo, antigamente, o C ++ n√£o possu√≠a dinamismo.  N√£o foi f√°cil encontrar uma pessoa que pudesse dizer que tem sentimentos ternos por esse idioma.  Tudo mudou quando os respons√°veis ‚Äã‚Äãpela padroniza√ß√£o da linguagem decidiram dar lugar a inova√ß√µes.  Em 2011, o C ++ se tornou uma linguagem din√¢mica, uma linguagem em constante evolu√ß√£o e que causa emo√ß√µes muito mais positivas aos programadores. <br><br>  N√£o pense que o idioma se tornou mais f√°cil.  Ainda pode ser chamada de uma das linguagens de programa√ß√£o mais complexas amplamente usadas, se n√£o a mais complexa.  Mas o C ++ moderno se tornou muito mais amig√°vel do que antes. <br><br><img src="https://habrastorage.org/webt/qk/ii/cx/qkiicxclyr6agfsxlcplndrkpd8.jpeg"><br><br>  Hoje falaremos sobre alguns dos novos recursos da linguagem (a partir do C ++ 11, que, a prop√≥sito, j√° tem 8 anos), que ser√£o √∫teis para qualquer programador. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Palavra-chave autom√°tica</font> </h2><br>  Desde que a palavra <code>auto</code> chave <code>auto</code> apareceu no C ++ 11, a vida dos programadores se tornou mais f√°cil.  Gra√ßas a essa palavra-chave, o compilador pode gerar tipos de vari√°veis ‚Äã‚Äãem tempo de compila√ß√£o, o que nos impede de sempre precisar especificar os tipos.  Isso acabou sendo muito conveniente, por exemplo, nos casos em que voc√™ precisa trabalhar com tipos de dados como <code>map&lt;string,vector&lt;pair&lt;int,int&gt;&gt;&gt;</code> .  Ao usar a palavra <code>auto</code> chave <code>auto</code> , h√° algumas coisas a considerar.  Considere um exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> an_int = <span class="hljs-number"><span class="hljs-number">26</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    ,     - int auto a_bool = false; //   bool auto a_float = 26.04; //   float auto ptr = &amp;a_float; //       auto data; // #1     ?    - .</span></span></code> </pre> <br>  Preste aten√ß√£o √† √∫ltima linha deste exemplo, cujo coment√°rio est√° marcado como <code>#1</code> (a seguir, de maneira semelhante, marcaremos as linhas que analisaremos ap√≥s os exemplos).  N√£o h√° inicializador nesta linha, voc√™ n√£o pode fazer isso.  O c√≥digo localizado nesta linha impede que o compilador saiba qual deve ser o tipo da vari√°vel correspondente. <br><br>  Inicialmente, a palavra <code>auto</code> chave <code>auto</code> em C ++ era bastante limitada.  Em vers√µes mais recentes do idioma, recursos adicionados <code>auto</code> .  Aqui est√° outro exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">merge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//            auto! {   std::vector&lt;int&gt; c = do_something(a, b);   return c; } std::vector&lt;int&gt; a = { ... }; // #1 -  std::vector&lt;int&gt; b = { ... }; // #2  -  auto c = merge(a,b); //      </span></span></span></span></code> </pre> <br>  As linhas <code>#1</code> e <code>#2</code> aplicam a inicializa√ß√£o vari√°vel usando chaves - outro novo recurso no C ++ 11. <br><br>  Lembre-se de que, ao usar a palavra <code>auto</code> chave <code>auto</code> , o compilador deve ter uma maneira de inferir o tipo da vari√°vel. <br><br>  Agora, uma pergunta interessante.  O que acontece se voc√™ usar um design como <code>auto a = {1, 2, 3}</code> ?  O que √© isso  Vector ou causa de erro de compila√ß√£o? <br><br>  De fato, uma constru√ß√£o do formul√°rio <code>std::initializer_list&lt;type&gt;</code> apareceu no C ++ 11.  A lista entre par√™nteses de valores de inicializa√ß√£o ser√° tratada como um cont√™iner usando a palavra <code>auto</code> chave <code>auto</code> . <br><br>  E, finalmente, como j√° mencionado, a infer√™ncia de tipo pelo compilador pode ser extremamente √∫til se voc√™ precisar trabalhar com estruturas de dados complexas.  Aqui est√° um exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">populate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    !   data.insert({"a",{1,4}});   data.insert({"b",{3,1}});   data.insert({"c",{2,3}}); } auto merge(auto data, auto upcoming_data) { //         auto result = data;   for(auto it: upcoming_data) {       result.insert(it);   }   return result; } int main() {   std::map&lt;std::string, std::pair&lt;int,int&gt;&gt; data;   populate(data);   std::map&lt;std::string, std::pair&lt;int,int&gt;&gt; upcoming_data;   upcoming_data.insert({"d",{5,3}});   auto final_data = merge(data,upcoming_data);   for(auto itr: final_data) {       auto [v1, v2] = itr.second; // #1               std::cout &lt;&lt; itr.first &lt;&lt; " " &lt;&lt; v1 &lt;&lt; " " &lt;&lt; v2 &lt;&lt; std:endl;   }   return 0; }</span></span></code> </pre> <br>  D√™ uma olhada na linha <code>#1</code> .  A express√£o <code>auto [v1,v2] = itr.second</code> representa um novo recurso do C ++ 17. Essa √© a chamada decomposi√ß√£o ao declarar vari√°veis.  Nas vers√µes anteriores do idioma, cada valor tinha que ser extra√≠do individualmente.  Gra√ßas a esse mecanismo, executar essas opera√ß√µes se tornou muito mais conveniente. <br><br>  Al√©m disso, se voc√™ precisar trabalhar com dados usando links, basta adicionar apenas um caractere a essa constru√ß√£o, convertendo-o no seguinte formato: <code>auto &amp;[v1,v2] = itr.second</code> . <br><br><h2>  <font color="#3AC1EF">Express√µes lambda</font> </h2><br>  O C ++ 11 apresenta suporte para express√µes lambda.  Eles se parecem com fun√ß√µes an√¥nimas em JavaScript, podem ser comparados com objetos funcionais sem nomes.  Eles capturam vari√°veis ‚Äã‚Äãem v√°rios escopos, dependendo de sua descri√ß√£o, para as quais constru√ß√µes sint√°ticas compactas s√£o usadas.  Al√©m disso, eles podem ser atribu√≠dos a vari√°veis. <br><br>  As express√µes Lambda s√£o uma ferramenta muito √∫til para os casos em que voc√™ precisa executar uma pequena opera√ß√£o no c√≥digo, mas n√£o deseja gravar uma fun√ß√£o separada para isso.  Outro exemplo comum de seu uso √© a cria√ß√£o de fun√ß√µes usadas na compara√ß√£o de valores.  Por exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; data = {{<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}, {<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>}, {<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}}; <span class="hljs-comment"><span class="hljs-comment">//        std::sort(begin(data), end(data), [](auto a, auto b) { //   - auto!   return a.second &lt; b.second; });</span></span></code> </pre> <br>  Voc√™ pode encontrar muitas coisas interessantes neste pequeno exemplo. <br><br>  Primeiro, preste aten√ß√£o √† conveni√™ncia de usar a inicializa√ß√£o vari√°vel usando chaves.  A seguir, podemos ver as constru√ß√µes padr√£o <code>begin()</code> e <code>end()</code> , que tamb√©m apareceram no C ++ 11. Em seguida, vem a fun√ß√£o lambda, que √© usada como um mecanismo para comparar dados.  Os par√¢metros desta fun√ß√£o s√£o declarados usando a palavra <code>auto</code> chave <code>auto</code> , esse recurso apareceu no C ++ 14. Anteriormente, essa palavra-chave n√£o podia ser usada para descrever os par√¢metros das fun√ß√µes. <br><br>  Agora observe que a express√£o lambda come√ßa com colchetes - <code>[]</code> .  Essa √© a chamada m√°scara de vari√°veis.  Ele determina o escopo da express√£o, ou seja, permite controlar o relacionamento da express√£o lambda com vari√°veis ‚Äã‚Äãe objetos locais. <br><br>  Aqui est√° um trecho <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">deste</a> reposit√≥rio dedicado aos recursos modernos do C ++: <br><br><ul><li>  <code>[]</code> - a express√£o n√£o captura nada.  Isso significa que em uma express√£o lambda √© imposs√≠vel usar vari√°veis ‚Äã‚Äãlocais do escopo externo a ela.  Somente par√¢metros podem ser usados ‚Äã‚Äãna express√£o. </li><li>  <code>[=]</code> - a express√£o captura os valores de objetos locais (ou seja, vari√°veis ‚Äã‚Äãlocais, par√¢metros).  Isso significa que eles podem ser usados, mas n√£o modificados. </li><li>  <code>[&amp;]</code> - a express√£o captura refer√™ncias a objetos locais.  Eles podem ser modificados, conforme mostrado no exemplo a seguir. </li><li>  <code>[this]</code> - a express√£o captura o valor <code>this</code> ponteiro. </li><li>  <code>[a, &amp;b]</code> - a express√£o captura o valor do objeto <code>a</code> e uma refer√™ncia ao objeto <code>b</code> . </li></ul><br>  Como resultado, se dentro da fun√ß√£o lambda voc√™ precisar converter os dados para outro formato, poder√° usar os mecanismos acima.  Considere um exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; data = {<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> factor = <span class="hljs-number"><span class="hljs-number">7</span></span>; for_each(begin(data), end(data), [&amp;factor](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &amp;val) { <span class="hljs-comment"><span class="hljs-comment">//    factor     val = val * factor;   factor--; // #1   - ,  -    factor   }); for(int val: data) {   std::cout &lt;&lt; val &lt;&lt; ' '; // 14 24 20 4 3 6 9 }</span></span></code> </pre> <br>  Aqui, se a vari√°vel <code>factor</code> fosse acessada por valor (a vari√°vel mask <code>[factor]</code> seria usada para descrever a express√£o lambda), na linha <code>#1</code> o valor do <code>factor</code> n√£o poderia ser alterado - simplesmente porque n√£o ter√≠amos direito a executando tal opera√ß√£o.  Neste exemplo, temos o direito de tais a√ß√µes.  Em tais situa√ß√µes, √© importante n√£o abusar dos recursos que acessam vari√°veis ‚Äã‚Äãfornecidas por refer√™ncia. <br><br>  Al√©m disso, observe que <code>val</code> tamb√©m <code>val</code> acessado por refer√™ncia.  Isso garante que as altera√ß√µes de dados que ocorrem na fun√ß√£o lambda afetem o <code>vector</code> . <br><br><h2>  <font color="#3AC1EF">Express√µes de inicializa√ß√£o vari√°veis ‚Äã‚Äãdentro das constru√ß√µes if e switch</font> </h2><br>  Eu realmente gostei dessa inova√ß√£o do C ++ 17 logo depois que descobri.  Considere um exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; input = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = input.find(<span class="hljs-number"><span class="hljs-number">7</span></span>); it==input.end()){ <span class="hljs-comment"><span class="hljs-comment">//   - ,  -    std::cout &lt;&lt; 7 &lt;&lt; " not found" &lt;&lt; std:endl; } else {   //    else      it   std::cout &lt;&lt; 7 &lt;&lt; " is there!" &lt;&lt; std::endl; }</span></span></code> </pre> <br>  Acontece que agora voc√™ pode inicializar as vari√°veis ‚Äã‚Äãe comparar com o uso delas em um bloco <code>if</code> ou <code>switch</code> .  Isso ajuda a escrever um c√≥digo preciso.  Aqui est√° uma descri√ß√£o esquem√°tica da estrutura em considera√ß√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( init-statement(x); condition(x)) {   <span class="hljs-comment"><span class="hljs-comment">//    } else {   //     x   //    }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Executando c√°lculos em tempo de compila√ß√£o usando constexpr</font> </h2><br>  A <code>constexpr</code> nos oferece grandes oportunidades.  Suponha que tenhamos algum tipo de express√£o que precisa ser calculada, enquanto seu valor, ap√≥s inicializ√°-lo com a vari√°vel correspondente, n√£o ser√° alterado.  Essa express√£o pode ser calculada antecipadamente e usada como macro.  Ou, o que se tornou poss√≠vel no C ++ 11, use a <code>constexpr</code> . <br><br>  Os programadores se esfor√ßam para minimizar a quantidade de computa√ß√£o realizada durante a execu√ß√£o do programa.  Como resultado, se determinadas opera√ß√µes puderem ser executadas durante o processo de compila√ß√£o e, assim, remover a carga do sistema durante a execu√ß√£o do programa, isso ter√° um bom efeito no comportamento do programa durante a execu√ß√£o.  Aqui est√° um exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; constexpr long long fact(long long n) { //       constexpr return n == 1 ? 1 : (fact(n-1) * n); } int main() { const long long bigval = fact(20); std::cout&lt;&lt;bigval&lt;&lt;std::endl; }</span></span></span></span></code> </pre> <br>  Este √© um exemplo muito comum de uso do <code>constexpr</code> . <br><br>  Como declaramos a fun√ß√£o para calcular o fatorial como <code>constexpr</code> , o compilador pode pr√©-calcular o valor do <code>fact(20)</code> no momento da compila√ß√£o do programa.  Como resultado, ap√≥s a compila√ß√£o, a string <code>const long long bigval = fact(20);</code>  pode ser substitu√≠do por <code>const long long bigval = 2432902008176640000;</code>  . <br><br>  Observe que o argumento passado para a fun√ß√£o √© representado por uma constante.  Esse √© um recurso importante do uso de fun√ß√µes declaradas usando a <code>constexpr</code> .  Os argumentos passados ‚Äã‚Äãpara eles tamb√©m devem ser declarados com a <code>constexpr</code> - <code>constexpr</code> ou com a palavra-chave <code>const</code> .  Caso contr√°rio, essas fun√ß√µes se comportar√£o como fun√ß√µes comuns, ou seja, durante a compila√ß√£o, seus valores n√£o ser√£o calculados com anteced√™ncia. <br><br>  As vari√°veis ‚Äã‚Äãtamb√©m podem ser declaradas usando a <code>constexpr</code> .  Nesse caso, como voc√™ pode imaginar, os valores dessas vari√°veis ‚Äã‚Äãdevem ser calculados em tempo de compila√ß√£o.  Se isso n√£o puder ser feito, uma mensagem de erro de compila√ß√£o ser√° exibida. <br><br>  √â interessante notar que, mais tarde, em C ++ 17, as constru√ß√µes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">constexpr-if</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">constexpr-lambda</a> apareceram. <br><br><h2>  <font color="#3AC1EF">Estruturas de dados de tupla</font> </h2><br>  Como a estrutura de dados do <code>pair</code> a estrutura de dados da <code>tuple</code> (tupla) √© uma cole√ß√£o de valores de diferentes tipos de tamanho fixo.  Aqui est√° um exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user_info = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-string"><span class="hljs-string">"Chowdhury"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  auto     //    std::get&lt;0&gt;(user_info); std::get&lt;1&gt;(user_info); std::get&lt;2&gt;(user_info); //  C++ 11     tie std::string first_name, last_name, age; std::tie(first_name, last_name, age) = user_info; //  C++ 17, ,       auto [first_name, last_name, age] = user_info;</span></span></code> </pre> <br>  √Äs vezes, em vez de uma estrutura de dados de <code>tuple</code> , √© mais conveniente usar <code>std::array</code> .  Essa estrutura de dados √© semelhante √†s matrizes simples usadas na linguagem C, equipadas com recursos adicionais da biblioteca padr√£o C ++.  Essa estrutura de dados apareceu no C ++ 11. <br><br><h2>  <font color="#3AC1EF">Infer√™ncia autom√°tica do tipo de argumento do modelo de classe</font> </h2><br>  O nome desse recurso parece bastante longo e complexo, mas na verdade n√£o h√° nada complicado aqui.  A id√©ia principal aqui √© que, no C ++ 17, a sa√≠da de tipos de argumentos de modelo tamb√©m √© executada para modelos de classe padr√£o.  Anteriormente, isso era suportado apenas para modelos funcionais.  Como resultado, acontece que eles costumavam escrever assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; user = {<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>};</code> </pre> <br>  Com o lan√ßamento do C ++ 17, essa constru√ß√£o agora pode ser substitu√≠da por: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair user = {<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>};</code> </pre> <br>  A infer√™ncia de tipo √© feita implicitamente.  Esse mecanismo √© ainda mais conveniente quando se trata de tuplas.  Ou seja, antes eu tinha que escrever o seguinte: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; user (<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-string"><span class="hljs-string">"Chy"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>);</code> </pre> <br>  Agora, a mesma coisa se parece com isso: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">tuple </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">user2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"M"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"Chy"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">25</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre> <br>  Vale ressaltar que esses recursos n√£o parecer√£o algo digno de aten√ß√£o para aqueles que n√£o est√£o particularmente familiarizados com os modelos C ++. <br><br><h2>  <font color="#3AC1EF">Ponteiros inteligentes</font> </h2><br>  Trabalhar com ponteiros em C ++ pode ser um verdadeiro pesadelo.  Gra√ßas √† liberdade que a linguagem oferece ao programador, √†s vezes √© muito dif√≠cil para ele, como se costuma dizer, "n√£o dar um tiro no p√©".  Em muitos casos, os indicadores est√£o pressionando por uma "chance" do programador. <br><br>  Felizmente, o C ++ 11 introduziu indicadores inteligentes que s√£o muito mais convenientes do que indicadores comuns.  Eles ajudam o programador a evitar vazamentos de mem√≥ria, liberando recursos quando poss√≠vel.  Al√©m disso, eles fornecem uma garantia de seguran√ßa para exce√ß√µes. <br><br><h2>  <font color="#3AC1EF">Sum√°rio</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aqui est√° um</a> bom reposit√≥rio, que, acreditamos, ser√° interessante para quem seguir as inova√ß√µes do C ++.  Algo novo est√° constantemente aparecendo nesse idioma.  Aqui abordamos apenas alguns recursos modernos do idioma.  De fato, existem muitos deles.  √â poss√≠vel que ainda falemos sobre eles. <br><br>  <b>Caros leitores!</b>  Quais recursos modernos do C ++ voc√™ considera mais interessantes e √∫teis? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt451870/">https://habr.com/ru/post/pt451870/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt451858/index.html">Criando um disjuntor simples baseado em cache no Spring</a></li>
<li><a href="../pt451860/index.html">Matem√°ticos descobriram a maneira perfeita de multiplicar n√∫meros</a></li>
<li><a href="../pt451862/index.html">Musical Lightning, de Joe Diprim: um engenheiro autodidata faz bobinas de Tesla para entretenimento e ganhos</a></li>
<li><a href="../pt451864/index.html">Vulnerabilidade cr√≠tica ao n√≠vel de EternalBlue no RCE detectada no sistema operacional Windows</a></li>
<li><a href="../pt451866/index.html">Escolha os n√≥s mais pr√≥ximos na rede</a></li>
<li><a href="../pt451872/index.html">Python √© um assistente para encontrar voos baratos para quem gosta de viajar</a></li>
<li><a href="../pt451874/index.html">Principais tend√™ncias de SEO no Google</a></li>
<li><a href="../pt451876/index.html">Data center de Frankfurt: data center de Telehouse</a></li>
<li><a href="../pt451878/index.html">Transmiss√£o ao vivo de v√≠deo est√©reo para √≥culos VR (Oculus Go)</a></li>
<li><a href="../pt451880/index.html">DevPRO'19: vista do estande da Wrike</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>