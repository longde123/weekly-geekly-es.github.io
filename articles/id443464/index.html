<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚯 🤚 🧓🏻 Panduan Lengkap untuk Mengganti Ekspresi di Jawa 12 👨‍🎨 🐁 🔠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="switch lama yang baik switch ada di Jawa sejak hari pertama. Kita semua menggunakannya dan terbiasa dengannya - terutama kebiasaannya. (Apakah ada ora...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Panduan Lengkap untuk Mengganti Ekspresi di Jawa 12</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443464/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/pq/lt/a6/pqlta6vh4m5bec2xrtku1smn7em.jpeg"></div><br><p> <code>switch</code> lama yang baik <code>switch</code> ada di Jawa sejak hari pertama.  Kita semua menggunakannya dan terbiasa dengannya - terutama kebiasaannya.  (Apakah ada orang lain yang kesal karena <code>break</code> ?) Tetapi sekarang semuanya mulai berubah: di Java 12, <strong>sakelar</strong> alih-alih operator telah menjadi ekspresi: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE -&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FALSE -&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FILE_NOT_FOUND -&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UncheckedIOException( <span class="hljs-string"><span class="hljs-string">"This is ridiculous!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileNotFoundException()); <span class="hljs-comment"><span class="hljs-comment">// as we'll see in "Exhaustiveness", `default` is not necessary default -&gt; throw new IllegalArgumentException("Seriously?!"); };</span></span></code> </pre> <br><p>  <strong>Switch sekarang</strong> memiliki kemampuan untuk mengembalikan hasil kerjanya, yang dapat ditugaskan ke variabel;  Anda juga dapat menggunakan sintaks gaya lambda, yang memungkinkan Anda untuk menyingkirkan pass-through untuk semua <code>case</code> di mana tidak ada pernyataan <code>break</code> . </p><br><p>  Dalam panduan ini, saya akan memberi tahu Anda tentang semua yang perlu Anda ketahui tentang beralih ekspresi di Jawa 12. </p><a name="habracut"></a><br><h2 id="predvaritelnyy-obzor">  Pratinjau </h2><br><p>  Menurut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spesifikasi awal bahasa</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ekspresi saklar</a> baru mulai diimplementasikan di Jawa 12. </p><br><p>  Ini berarti bahwa konstruk kontrol ini dapat diubah dalam versi spesifikasi bahasa yang akan datang. </p><br><p>  Untuk mulai menggunakan versi baru <code>switch</code> Anda perlu menggunakan opsi baris perintah <code>--enable-preview</code> baik saat kompilasi maupun saat startup program (Anda juga harus menggunakan <code>--release 12</code> saat mengkompilasi - catatan oleh penerjemah). </p><br><p>  Jadi perlu diingat bahwa <strong>switch</strong> , sebagai ekspresi, saat ini tidak memiliki sintaks akhir di Java 12. </p><br><p>  Jika Anda memiliki keinginan untuk bermain dengan semua ini sendiri, maka Anda dapat mengunjungi proyek demo Java X saya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a> . </p><br><h2 id="problema-s-operatorami-v-switch">  Masalah dengan pernyataan dalam switch </h2><br><p>  Sebelum kita beralih ke tinjauan umum inovasi, mari kita cepat mengevaluasi satu situasi.  Misalkan kita dihadapkan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">boulean ternary</a> "mengerikan" dan ingin mengubahnya menjadi boulean biasa.  Inilah salah satu cara untuk melakukan ini: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE: result = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// don't forget to `break` or you're screwed! break; case FALSE: result = false; break; case FILE_NOT_FOUND: // intermediate variable for demo purposes; // wait for it... var ex = new UncheckedIOException("This is ridiculous!", new FileNotFoundException()); throw ex; default: // ... here we go: // can't declare another variable with the same name var ex2 = new IllegalArgumentException("Seriously?!"); throw ex2; }</span></span></code> </pre> <br><p>  Setuju bahwa ini sangat merepotkan.  Seperti banyak opsi <strong>sakelar</strong> lain yang ditemukan di "nature", contoh di atas hanya menghitung nilai variabel dan menetapkannya, tetapi implementasinya dilewati (nyatakan <code>result</code> pengidentifikasi dan gunakan nanti), diulangi ( <code>break</code> saya 'dan selalu hasil dari copy-paste) dan rawan kesalahan (lupa cabang lain? Oh!).  Jelas ada sesuatu untuk diperbaiki. </p><br><p>  Mari kita coba selesaikan masalah ini dengan menempatkan <strong>sakelar</strong> pada metode terpisah: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toBoolean</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bool ternaryBool)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FALSE: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FILE_NOT_FOUND: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UncheckedIOException(<span class="hljs-string"><span class="hljs-string">"This is ridiculous!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileNotFoundException()); <span class="hljs-comment"><span class="hljs-comment">// without default branch, the method wouldn't compile default: throw new IllegalArgumentException("Seriously?!"); } }</span></span></code> </pre> <br><p>  Ini jauh lebih baik: tidak ada variabel dummy, tidak ada <code>break</code> mengacaukan kode dan pesan penyusun tentang tidak adanya <code>default</code> (bahkan jika ini tidak perlu, seperti dalam kasus ini). </p><br><p>  Tetapi, jika Anda memikirkannya, kami tidak diharuskan membuat metode hanya untuk menghindari fitur bahasa yang canggung.  Dan ini bahkan tanpa mempertimbangkan bahwa refactoring seperti itu tidak selalu memungkinkan.  Tidak, kami membutuhkan solusi yang lebih baik! </p><br><h2 id="predstavlyaem-switch-vyrazheniya">  Memperkenalkan ekspresi saklar! </h2><br><p>  Seperti yang saya tunjukkan di awal artikel, dimulai dengan Java 12 ke atas, Anda dapat memecahkan masalah di atas sebagai berikut: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE -&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FALSE -&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FILE_NOT_FOUND -&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UncheckedIOException( <span class="hljs-string"><span class="hljs-string">"This is ridiculous!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileNotFoundException()); <span class="hljs-comment"><span class="hljs-comment">// as we'll see in "Exhaustiveness", `default` is not necessary default -&gt; throw new IllegalArgumentException("Seriously?!"); };</span></span></code> </pre> <br><p>  Saya pikir ini cukup jelas: jika <code>ternartBool</code> adalah <code>TRUE</code> , maka <code>result</code> 'akan disetel ke <code>true</code> (dengan kata lain, <code>TRUE</code> berubah menjadi <code>true</code> ).  <code>FALSE</code> menjadi <code>false</code> . </p><br><p>  Dua pikiran segera muncul: </p><br><ul><li>  <code>switch</code> mungkin memiliki hasil; </li><li>  ada apa dengan panah? </li></ul><br><p>  Sebelum mempelajari detail fitur <strong>sakelar</strong> baru, pada awalnya saya akan berbicara tentang dua aspek utama ini. </p><br><h3 id="vyrazhenie-ili-operator">  Ekspresi atau pernyataan </h3><br><p>  Anda mungkin terkejut bahwa <strong>peralihan</strong> sekarang menjadi ekspresi.  Tapi apa yang dia lakukan sebelumnya? </p><br><p>  Sebelum Java 12, sebuah <strong>saklar</strong> adalah operator - sebuah konstruksi imperatif yang mengontrol aliran kontrol. </p><br><p>  Pikirkan perbedaan antara versi lama dan baru dari <strong>saklar</strong> sebagai perbedaan antara <code>if</code> dan operator ternary.  Mereka berdua memeriksa kondisi logis dan melakukan percabangan tergantung pada hasilnya. </p><br><p>  Perbedaannya adalah bahwa <code>if</code> hanya mengeksekusi blok yang sesuai, sedangkan operator ternary mengembalikan beberapa hasil: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(condition) { result = doThis(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result = doThat(); } result = condition ? doThis() : doThat();</code> </pre> <br><p>  Hal yang sama berlaku untuk <strong>switch</strong> : sebelum Java 12, jika Anda ingin menghitung nilai dan menyimpan hasilnya, Anda akan menugaskannya ke variabel (dan kemudian <code>break</code> ), atau mengembalikannya dari metode yang dibuat khusus untuk <code>switch</code> . </p><br><p>  Sekarang, seluruh ekspresi <strong>pernyataan switch</strong> dievaluasi (cabang yang sesuai dipilih untuk dieksekusi), dan hasil perhitungan dapat ditugaskan ke variabel. </p><br><p>  Perbedaan lain antara ekspresi dan pernyataan adalah bahwa <strong>pernyataan switch</strong> , karena merupakan bagian dari pernyataan, harus diakhiri dengan tanda titik koma, tidak seperti <strong>pernyataan switch</strong> klasik. </p><br><h3 id="strelka-ili-dvoetochie">  Panah atau titik dua </h3><br><p>  Contoh pengantar menggunakan sintaks gaya lambda baru dengan panah antara label dan bagian yang berjalan.  Penting untuk dipahami bahwa untuk ini, tidak perlu menggunakan <code>switch</code> sebagai ekspresi.  Faktanya, contoh di bawah ini setara dengan kode yang diberikan di awal artikel: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FALSE: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FILE_NOT_FOUND: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UncheckedIOException( <span class="hljs-string"><span class="hljs-string">"This is ridiculous!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileNotFoundException()); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"Seriously?!!?"</span></span>); };</code> </pre> <br><p>  Perhatikan bahwa sekarang Anda dapat menggunakan <code>break</code> dengan suatu nilai!  Ini sangat cocok dengan <code>switch</code> gaya lama yang menggunakan <code>break</code> tanpa makna.  Jadi dalam hal apa panah berarti ekspresi daripada operator, mengapa ada di sini?  Hanya sintaks hipster? </p><br><p>  Secara historis, tanda titik dua hanya menandai titik masuk ke blok pernyataan.  Dari titik ini, eksekusi semua kode di bawah ini dimulai, bahkan ketika label lain ditemukan.  Sebagai <code>switch</code> kami mengetahui hal ini sebagai melintas ke <code>case</code> berikutnya (fall-through): label <code>case</code> menentukan ke mana aliran kontrol melompat.  Untuk melengkapinya, Anda perlu <code>break</code> atau <code>return</code> . </p><br><p>  Pada gilirannya, menggunakan panah berarti hanya blok di sebelah kanannya yang akan dieksekusi.  Dan tidak ada "gagal." </p><br><h2 id="podrobnee-ob-evolyucii-switch">  Lebih lanjut tentang evolusi saklar </h2><br><h3 id="neskolko-metok-na-case">  Banyak tag pada kasing </h3><br><p>  Sejauh ini, setiap <code>case</code> hanya <code>case</code> satu label.  Tetapi sekarang semuanya telah berubah - satu <code>case</code> dapat sesuai dengan beberapa label: </p><br><pre> <code class="java hljs">String result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE, FALSE -&gt; <span class="hljs-string"><span class="hljs-string">"sane"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// `default, case FILE_NOT_FOUND -&gt; ...` does not work // (neither does other way around), but that makes // sense because using only `default` suffices default -&gt; "insane"; };</span></span></code> </pre> <br><p>  Perilaku harus jelas: <code>TRUE</code> dan <code>FALSE</code> menghasilkan hasil yang sama - ungkapan "waras" dievaluasi. </p><br><p>  Ini adalah inovasi yang lumayan bagus yang menggantikan banyak penggunaan <code>case</code> ketika diperlukan untuk mengimplementasikan transisi pass-through ke <code>case</code> berikutnya. </p><br><h3 id="tipy-za-predelami-enum">  Jenis Di Luar Enum </h3><br><p>  Semua <code>switch</code> contoh dalam artikel ini menggunakan <code>enum</code> .  Bagaimana dengan tipe lain?  Pernyataan dan <code>switch</code> juga dapat berfungsi dengan <code>String</code> , <code>int</code> , (periksa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> ) <code>short</code> , <code>byte</code> , <code>char</code> , dan pembungkusnya.  Sejauh ini tidak ada yang berubah di sini, meskipun gagasan untuk menggunakan tipe data seperti <code>float</code> dan <code>long</code> masih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">valid</a> (dari paragraf kedua hingga paragraf terakhir). </p><br><h2 id="podrobnee-o-strelke">  Lebih lanjut tentang panah </h2><br><p>  Mari kita lihat dua properti khusus untuk bentuk panah dari catatan pemisah: </p><br><ul><li>  kurangnya transisi ujung ke ujung ke <code>case</code> selanjutnya; </li><li>  blok operator. </li></ul><br><h3 id="otsutstvie-skvoznogo-perehoda-k-sleduyuschemu-case">  Tidak ada pass-through ke case selanjutnya </h3><br><p>  Inilah yang dikatakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JEP 325</a> tentang ini: </p><br><blockquote>  Desain saat ini dari <code>switch</code> di Jawa terkait erat dengan bahasa seperti C dan C ++ dan mendukung semantik end-to-end secara default.  Meskipun cara tradisional pengendalian ini sering berguna untuk menulis kode tingkat rendah (seperti parser untuk pengkodean biner), karena <code>switch</code> digunakan dalam kode tingkat yang lebih tinggi, kesalahan pendekatan ini mulai lebih besar daripada fleksibilitasnya. </blockquote><p>  Saya sepenuhnya setuju dan menyambut kesempatan untuk menggunakan <strong>sakelar</strong> tanpa perilaku default: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE, FALSE -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Bool was sane"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// in colon-form, if `ternaryBool` is `TRUE` or `FALSE`, // we would see both messages; in arrow-form, only one // branch is executed default -&gt; System.out.println("Bool was insane"); }</span></span></code> </pre> <br><p>  Penting untuk mengetahui bahwa ini tidak ada hubungannya dengan apakah Anda menggunakan <strong>sakelar</strong> sebagai ekspresi atau pernyataan.  Faktor penentu di sini adalah panah terhadap usus besar. </p><br><h3 id="bloki-operatorov">  Blok Operator </h3><br><p>  Seperti dalam kasus lambdas, panah dapat menunjuk ke salah satu operator (seperti di atas) atau blok yang disorot dengan kurung kurawal: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(Bool.random()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"Bool true"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// return with `break`, not `return` break true; } case FALSE -&gt; { System.out.println("Bool false"); break false; } case FILE_NOT_FOUND -&gt; { var ex = new UncheckedIOException("This is ridiculous!", new FileNotFoundException()); throw ex; } default -&gt; { var ex = new IllegalArgumentException("Seriously?!"); throw ex; } };</span></span></code> </pre> <br><p>  Blok yang harus dibuat untuk operator multi-line memiliki keuntungan tambahan (yang tidak diperlukan saat menggunakan titik dua), yang berarti bahwa untuk menggunakan nama variabel yang sama di cabang yang berbeda, <code>switch</code> tidak memerlukan pemrosesan khusus. </p><br><p>  Jika Anda merasa tidak biasa keluar dari blok menggunakan <code>break</code> daripada <code>return</code> , maka jangan khawatir - ini juga membingungkan saya dan tampak aneh.  Tapi kemudian saya memikirkannya dan sampai pada kesimpulan bahwa itu masuk akal, karena ia mempertahankan gaya lama dari <code>switch</code> , yang menggunakan <code>break</code> tanpa nilai. </p><br><h2 id="podrobnee-o-vyrazheniyah-switch">  Pelajari lebih lanjut tentang pergantian pernyataan </h2><br><p>  Dan last but not least, spesifikasi menggunakan <code>switch</code> sebagai ekspresi: </p><br><ul><li>  banyak ekspresi; </li><li>  pengembalian awal ( <code>return</code> awal); </li><li>  cakupan semua nilai. </li></ul><br><p>  Harap perhatikan bahwa tidak masalah bentuk apa yang digunakan! </p><br><h3 id="mnozhestvennye-vyrazheniya">  Beragam ekspresi </h3><br><p>  Beralih ekspresi adalah beberapa ekspresi.  Ini berarti bahwa mereka tidak memiliki tipe mereka sendiri, tetapi dapat menjadi salah satu dari beberapa tipe.  Paling sering, ekspresi lambda digunakan sebagai ekspresi seperti: <code>s -&gt; s + " "</code> , mungkin <code>Function&lt;String, String&gt;</code> , tetapi mungkin juga <code>Function&lt;Serializable, Object&gt;</code> atau <code>UnaryOperator&lt;String&gt;</code> . </p><br><p>  Menggunakan ekspresi saklar, suatu tipe ditentukan oleh interaksi antara di mana <strong>saklar</strong> digunakan dan tipe cabangnya.  Jika ekspresi sakelar ditetapkan ke variabel yang diketik, diteruskan sebagai argumen, atau digunakan dalam konteks di mana tipe persisnya diketahui (ini disebut tipe target), maka semua cabangnya harus cocok dengan tipe itu.  Inilah yang telah kami lakukan sejauh ini: </p><br><pre> <code class="java hljs">String result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE, FALSE -&gt; <span class="hljs-string"><span class="hljs-string">"sane"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"insane"</span></span>; };</code> </pre> <br><p>  Sebagai hasilnya, <code>switch</code> ditugaskan ke variabel <code>result</code> dari tipe <code>String</code> .  Oleh karena itu, <code>String</code> adalah tipe target, dan semua cabang harus mengembalikan hasil dari tipe <code>String</code> . </p><br><p>  Hal yang sama terjadi di sini: </p><br><pre> <code class="java hljs">Serializable serializableMessage = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (bool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE, FALSE -&gt; <span class="hljs-string"><span class="hljs-string">"sane"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// note that we don't throw the exception! // but it's `Serializable`, so it matches the target type default -&gt; new IllegalArgumentException("insane"); };</span></span></code> </pre> <br><p>  Apa yang akan terjadi sekarang? </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// compiler infers super type of `String` and // `IllegalArgumentException` ~&gt; `Serializable` var serializableMessage = switch (bool) { case TRUE, FALSE -&gt; "sane"; // note that we don't throw the exception! default -&gt; new IllegalArgumentException("insane"); };</span></span></code> </pre> <br><p>  (Untuk penggunaan jenis var, baca di artikel terakhir kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">26 rekomendasi untuk menggunakan jenis var di Jawa</a> - catatan oleh penerjemah) </p><br><p>  Jika tipe target tidak diketahui, karena fakta bahwa kami menggunakan var, tipe tersebut dihitung dengan menemukan supertipe paling spesifik dari tipe yang dibuat oleh cabang. </p><br><h3 id="ranniy-vozvrat">  Kembali lebih awal </h3><br><p>  Konsekuensi dari perbedaan antara ekspresi dan <code>switch</code> adalah bahwa Anda dapat menggunakan <code>return</code> untuk keluar dari <code>switch</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sanity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bool ternaryBool)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ternaryBool) { <span class="hljs-comment"><span class="hljs-comment">// `return` is only possible from block case TRUE, FALSE -&gt; { return "sane"; } default -&gt; { return "This is ridiculous!"; } }; }</span></span></code> </pre> <br><p>  ... Anda tidak dapat menggunakan <code>return</code> di dalam ekspresi ... </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sanity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bool ternaryBool)</span></span></span><span class="hljs-function"> </span></span>{ String result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ternaryBool) { <span class="hljs-comment"><span class="hljs-comment">// this does not compile - error: // "return outside of enclosing switch expression" case TRUE, FALSE -&gt; { return "sane"; } default -&gt; { return "This is ridiculous!"; } }; }</span></span></code> </pre> <br><p>  Ini masuk akal apakah Anda menggunakan panah atau titik dua. </p><br><h3 id="pokrytie-vseh-variantov">  Mencakup semua opsi </h3><br><p>  Jika Anda menggunakan <code>switch</code> sebagai operator, maka tidak masalah jika semua opsi dicakup atau tidak.  Tentu saja, Anda dapat melewatkan <code>case</code> secara tidak sengaja, dan kode tidak akan berfungsi dengan benar, tetapi kompiler tidak peduli - Anda, IDE Anda dan alat analisis kode Anda akan dibiarkan begitu saja. </p><br><p>  Berpindah ekspresi memperparah masalah ini.  Di mana harus beralih pergi jika label yang diinginkan hilang?  Satu-satunya jawaban yang dapat diberikan Java adalah mengembalikan <code>null</code> untuk tipe referensi dan nilai default untuk primitif.  Ini akan menyebabkan banyak kesalahan dalam kode utama. </p><br><p>  Untuk mencegah hasil seperti itu, kompiler dapat membantu Anda.  Untuk pernyataan pergantian, kompiler akan bersikeras bahwa semua opsi yang mungkin tercakup.  Mari kita lihat contoh yang mungkin menyebabkan kesalahan kompilasi: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// compile error: // "the switch expression does not cover all possible input values" boolean result = switch (ternaryBool) { case TRUE -&gt; true; // no case for `FALSE` case FILE_NOT_FOUND -&gt; throw new UncheckedIOException( "This is ridiculous!", new FileNotFoundException()); };</span></span></code> </pre> <br><p>  Solusi berikut ini menarik: menambahkan cabang <code>default</code> pasti akan memperbaiki kesalahan, tetapi ini bukan satu-satunya solusi - Anda masih dapat menambahkan <code>case</code> untuk <code>FALSE</code> . </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// compiles without `default` branch because // all cases for `ternaryBool` are covered boolean result = switch (ternaryBool) { case TRUE -&gt; true; case FALSE -&gt; false; case FILE_NOT_FOUND -&gt; throw new UncheckedIOException( "This is ridiculous!", new FileNotFoundException()); };</span></span></code> </pre> <br><p>  Ya, kompiler akhirnya akan dapat menentukan apakah semua nilai enum tertutup (apakah semua opsi sudah habis), dan tidak menetapkan nilai default yang tidak berguna!  Mari kita duduk sejenak dalam ucapan terima kasih sunyi. </p><br><p>  Meskipun, ini masih menimbulkan satu pertanyaan.  Bagaimana jika seseorang mengambil dan mengubah <strong>Bool</strong> gila menjadi <strong>Boolean</strong> angka empat dengan menambahkan nilai keempat?  Jika Anda mengkompilasi ulang ekspresi sakelar untuk <strong>Bool yang</strong> diperluas, Anda akan mendapatkan kesalahan kompilasi (ekspresi tidak lagi lengkap).  Tanpa kompilasi ulang, ini akan berubah menjadi masalah run-time.  Untuk menangkap masalah ini, kompiler pergi ke cabang <code>default</code> , yang berperilaku sama dengan yang kami gunakan sejauh ini, melempar pengecualian. </p><br><p>  Di Java 12, merentang semua nilai tanpa cabang <code>default</code> hanya berfungsi untuk <code>enum</code> , tetapi ketika <code>switch</code> menjadi lebih kuat di versi Java yang akan datang, ia juga bisa bekerja dengan tipe arbitrer.  Jika label <code>case</code> tidak hanya dapat memverifikasi kesetaraan, tetapi juga membuat perbandingan (misalnya, _ &lt;5 -&gt; ...) - ini akan mencakup semua opsi untuk jenis numerik. </p><br><h2 id="razmyshlenie">  Berpikir </h2><br><p>  Kami belajar dari artikel bahwa Java 12 mengubah <code>switch</code> menjadi ekspresi, memberikannya fitur baru: </p><br><ul><li>  sekarang satu <code>case</code> dapat sesuai dengan beberapa label; </li><li>  Bentuk tanda panah baru <code>case … -&gt; …</code> mengikuti sintaks ekspresi lambda: <br><ul><li>  operator atau blok tunggal diperbolehkan; </li><li>  melewati ke <code>case</code> berikutnya dicegah; </li></ul></li><li>  sekarang seluruh ekspresi dievaluasi sebagai nilai, yang kemudian dapat ditugaskan ke variabel atau diteruskan sebagai bagian dari pernyataan yang lebih besar; </li><li>  multi ekspresi: jika tipe target diketahui, maka semua cabang harus sesuai dengannya.  Kalau tidak, tipe tertentu didefinisikan yang cocok dengan semua cabang; </li><li>  <code>break</code> dapat mengembalikan nilai dari blok; </li><li>  untuk ekspresi <code>switch</code> menggunakan <code>enum</code> , kompiler memeriksa ruang lingkup semua nilainya.  Jika <code>default</code> ada, cabang ditambahkan yang melempar pengecualian. </li></ul><br><p>  Di mana itu akan membawa kita?  Pertama, karena ini bukan versi terakhir dari <code>switch</code> , Anda masih punya waktu untuk meninggalkan umpan balik pada milis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Amber</a> jika Anda tidak setuju dengan sesuatu. </p><br><p>  Kemudian, dengan asumsi <strong>saklar</strong> tetap seperti saat ini, saya pikir bentuk panah akan menjadi opsi default baru.  Tanpa melalui bagian ke <code>case</code> berikutnya dan dengan ekspresi lambda singkat (sangat alami untuk memiliki kasus dan satu pernyataan dalam satu baris), <code>switch</code> terlihat jauh lebih kompak dan tidak mempengaruhi keterbacaan kode.  Saya yakin bahwa saya hanya akan menggunakan titik dua jika saya perlu melewati bagian ini. </p><br><p>  Apa yang kamu pikirkan  Puas dengan apa yang terjadi? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443464/">https://habr.com/ru/post/id443464/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443452/index.html">Militer Rusia akan membuat Internet tertutup mereka sendiri</a></li>
<li><a href="../id443456/index.html">Kami mengundang Anda ke Yandex NLP selama seminggu</a></li>
<li><a href="../id443458/index.html">6 bug sistem yang menghibur dalam pengoperasian Kubernetes [dan solusinya]</a></li>
<li><a href="../id443460/index.html">11 jawaban tentang Yandex.Directory</a></li>
<li><a href="../id443462/index.html">Kamera peretasan: vektor serangan, alat pencarian kerentanan dan anti-pelacakan</a></li>
<li><a href="../id443466/index.html">Raja pembangunan</a></li>
<li><a href="../id443468/index.html">Alat pemantauan jaringan apa yang telah menjadi pemimpin dalam versi Gartner</a></li>
<li><a href="../id443470/index.html">Sejarah mengetik pada contoh satu proyek besar</a></li>
<li><a href="../id443472/index.html">Punya masalah untuk pergi ke cloud? 7 tips tentang cara tidak mengacaukan</a></li>
<li><a href="../id443476/index.html">Bagaimana SimCity menginspirasi seluruh generasi perencana kota</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>