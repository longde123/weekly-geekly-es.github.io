<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîò üõ°Ô∏è ‚ùÑÔ∏è Construire une architecture de microservices sur Golang et gRPC, partie 1 üöæ üßôüèº üçñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction √† l'architecture des microservices 
 Partie 1 sur 10 


 Adaptation d'articles d'Ewan Valentine. 


 Il s'agit d'une s√©rie de dix parties...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Construire une architecture de microservices sur Golang et gRPC, partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425653/"><h2 id="vvedenie-v-mikroservisnuyu-arhitekturu">  Introduction √† l'architecture des microservices </h2><br><h4 id="chast-1-iz-10">  Partie 1 sur 10 </h4><br><p>  Adaptation d'articles d'Ewan Valentine. </p><br><p>  Il s'agit d'une s√©rie de dix parties, je vais essayer d'√©crire une fois par mois sur la construction de microservices sur Golang.  J'utiliserai protobuf et gRPC comme protocole de transport principal. </p><br><p>  La pile que j'ai utilis√©e: golang, mongodb, grpc, docker, Google Cloud, Kubernetes, NATS, CircleCI, Terraform et go-micro. </p><br><p>  Pourquoi ai-je besoin de √ßa?  Puisqu'il m'a fallu beaucoup de temps pour le comprendre et r√©soudre les probl√®mes accumul√©s.  Je voulais √©galement partager avec vous ce que j'ai appris sur la cr√©ation, le test et le d√©ploiement de microservices sur Go et d'autres nouvelles technologies. </p><br><p>  Dans cette partie, je veux montrer les concepts et technologies de base pour la construction de microservices.  √âcrivons une impl√©mentation simple.  Le projet comprendra les entit√©s suivantes: </p><br><ul><li>  cargaison </li><li>  inventaire </li><li>  essai </li><li>  les utilisateurs </li><li>  les r√¥les </li><li>  authentification </li></ul><a name="habracut"></a><br><img src="https://habrastorage.org/webt/rw/x9/gb/rwx9gbtjbpn9m44olxapvk2ecgq.jpeg"><br><p>  Pour aller plus loin, vous devez installer Golang et les biblioth√®ques n√©cessaires, ainsi que cr√©er un r√©f√©rentiel git. </p><br><h2 id="teoriya">  Th√©orie </h2><br><h4 id="chto-takoe-mikroservisnaya-arhitektura">  Qu'est-ce que l'architecture de microservice? </h4><br><p>  Les microservices isolent une fonctionnalit√© distincte dans un service, autosuffisant en termes de fonction ex√©cut√©e par ce service.  Pour la compatibilit√© avec d'autres services, il poss√®de une interface bien connue et pr√©d√©finie. <br>  Les microservices communiquent entre eux √† l'aide de messages transmis par un interm√©diaire, un courtier de messages. </p><br><img src="https://habrastorage.org/webt/tr/aq/dm/traqdmhafa_yvh0haprr05w7rgo.png"><br><p>  Gr√¢ce √† l'architecture de microservice, l'application ne peut pas √™tre mise √† l'√©chelle en totalit√©, mais en partie.  Par exemple, si le service d'autorisation ¬´tressaute¬ª plus souvent que d'autres, nous pouvons augmenter le nombre d'instances.  Ce concept est conforme aux concepts du cloud computing et de la conteneurisation en g√©n√©ral. </p><br><h4 id="pochemu-golang">  Pourquoi Golang </h4><br><p>  Les microservices sont pris en charge dans presque toutes les langues, apr√®s tout, les microservices sont un concept, pas une structure ou un outil sp√©cifique.  Cependant, certaines langues sont mieux adapt√©es et, en outre, prennent mieux en charge les microservices que d'autres.  Une langue avec un grand soutien est le Golang. </p><br><h4 id="poznakomimsya-s-protobufgrpc">  Rencontrez protobuf / gRPC </h4><br><p>  Comme mentionn√© pr√©c√©demment, les microservices sont divis√©s en bases de code distinctes, l'un des probl√®mes importants associ√©s aux microservices est la communication.  Si vous avez un monolithe, vous pouvez simplement appeler le code directement depuis un autre endroit de votre programme. </p><br><p>  Pour r√©soudre le probl√®me de communication, nous pouvons utiliser l'approche REST traditionnelle et transf√©rer des donn√©es au format JSON ou XML via HTTP.  Mais cette approche a ses inconv√©nients, par exemple, qu'avant d'envoyer un message, vous devez coder vos donn√©es et les d√©coder √† nouveau du c√¥t√© de la r√©ception.  Et cela est une surcharge et augmente la complexit√© du code. </p><br><p>  Il y a une solution!  Il s'agit du protocole <strong>gRPC</strong> - un protocole binaire l√©ger qui √©limine la transmission des en-t√™tes HTTP, et cela nous fera √©conomiser quelques octets.  Le futur HTTP2 implique √©galement l'utilisation de donn√©es binaires, ce qui parle √† nouveau en faveur de gRPC.  HTTP2 permet une communication bidirectionnelle, et c'est g√©nial! </p><br><p>  GRPC vous permet √©galement de d√©finir l'interface de votre service dans un format convivial - c'est&gt; <strong>protobuf</strong> . </p><br><h2 id="praktika">  Pratique </h2><br><p>  Cr√©ez le fichier /project/consigment.proto. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Documentation officielle de protobuf</a> </p><br><div class="spoiler">  <b class="spoiler_title">consigment.proto</b> <div class="spoiler_text"><pre><code class="plaintext hljs">//consigment.proto syntax = "proto3"; package go.micro.srv.consignment; service ShippingService { rpc CreateConsignment(Consignment) returns (Response) {} } message Consignment { string id = 1; string description = 2; int32 weight = 3; repeated Container containers = 4; string vessel_id = 5; } message Container { string id = 1; string customer_id = 2; string origin = 3; string user_id = 4; } message Response { bool created = 1; Consignment consignment = 2; }</code> </pre> </div></div><br><p>  Il s'agit d'un exemple simple qui contient le service que vous souhaitez fournir √† d'autres services: le service ShippingService, puis nous d√©finirons nos messages.  Protobuf est un protocole typ√© statiquement, et nous pouvons cr√©er des types personnalis√©s (similaires aux structures de golang).  Ici, le conteneur est imbriqu√© dans le lot. </p><br><p>  Installez les biblioth√®ques, le compilateur et compilez notre protocole: </p><br><pre> <code class="bash hljs">$ go get -u google.golang.org/grpc $ go get -u github.com/golang/protobuf/protoc-gen-go $ sudo apt install protobuf-compiler $ mkdir consignment &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> consignment $ protoc -I=. --go_out=plugins=grpc:. consignment.proto</code> </pre> <br><p>  La sortie doit √™tre un fichier: </p><br><div class="spoiler">  <b class="spoiler_title">consignment.pb.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Code generated by protoc-gen-go. DO NOT EDIT. // source: consignment.proto package consignment import ( fmt "fmt" proto "github.com/golang/protobuf/proto" context "golang.org/x/net/context" grpc "google.golang.org/grpc" math "math" ) // Reference imports to suppress errors if they are not otherwise used. var _ = proto.Marshal var _ = fmt.Errorf var _ = math.Inf // This is a compile-time assertion to ensure that this generated file // is compatible with the proto package it is being compiled against. // A compilation error at this line likely means your copy of the // proto package needs to be updated. const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package type Consignment struct { Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"` Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"` Weight int32 `protobuf:"varint,3,opt,name=weight,proto3" json:"weight,omitempty"` Containers []*Container `protobuf:"bytes,4,rep,name=containers,proto3" json:"containers,omitempty"` VesselId string `protobuf:"bytes,5,opt,name=vessel_id,json=vesselId,proto3" json:"vessel_id,omitempty"` XXX_NoUnkeyedLiteral struct{} `json:"-"` XXX_unrecognized []byte `json:"-"` XXX_sizecache int32 `json:"-"` } func (m *Consignment) Reset() { *m = Consignment{} } func (m *Consignment) String() string { return proto.CompactTextString(m) } func (*Consignment) ProtoMessage() {} func (*Consignment) Descriptor() ([]byte, []int) { return fileDescriptor_3804bf87090b51a9, []int{0} } func (m *Consignment) XXX_Unmarshal(b []byte) error { return xxx_messageInfo_Consignment.Unmarshal(m, b) } func (m *Consignment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) { return xxx_messageInfo_Consignment.Marshal(b, m, deterministic) } func (m *Consignment) XXX_Merge(src proto.Message) { xxx_messageInfo_Consignment.Merge(m, src) } func (m *Consignment) XXX_Size() int { return xxx_messageInfo_Consignment.Size(m) } func (m *Consignment) XXX_DiscardUnknown() { xxx_messageInfo_Consignment.DiscardUnknown(m) } var xxx_messageInfo_Consignment proto.InternalMessageInfo func (m *Consignment) GetId() int32 { if m != nil { return m.Id } return 0 } func (m *Consignment) GetDescription() string { if m != nil { return m.Description } return "" } func (m *Consignment) GetWeight() int32 { if m != nil { return m.Weight } return 0 } func (m *Consignment) GetContainers() []*Container { if m != nil { return m.Containers } return nil } func (m *Consignment) GetVesselId() string { if m != nil { return m.VesselId } return "" } type Container struct { Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"` CustomerId string `protobuf:"bytes,2,opt,name=customer_id,json=customerId,proto3" json:"customer_id,omitempty"` Origin string `protobuf:"bytes,3,opt,name=origin,proto3" json:"origin,omitempty"` UserId string `protobuf:"bytes,4,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"` XXX_NoUnkeyedLiteral struct{} `json:"-"` XXX_unrecognized []byte `json:"-"` XXX_sizecache int32 `json:"-"` } func (m *Container) Reset() { *m = Container{} } func (m *Container) String() string { return proto.CompactTextString(m) } func (*Container) ProtoMessage() {} func (*Container) Descriptor() ([]byte, []int) { return fileDescriptor_3804bf87090b51a9, []int{1} } func (m *Container) XXX_Unmarshal(b []byte) error { return xxx_messageInfo_Container.Unmarshal(m, b) } func (m *Container) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) { return xxx_messageInfo_Container.Marshal(b, m, deterministic) } func (m *Container) XXX_Merge(src proto.Message) { xxx_messageInfo_Container.Merge(m, src) } func (m *Container) XXX_Size() int { return xxx_messageInfo_Container.Size(m) } func (m *Container) XXX_DiscardUnknown() { xxx_messageInfo_Container.DiscardUnknown(m) } var xxx_messageInfo_Container proto.InternalMessageInfo func (m *Container) GetId() int32 { if m != nil { return m.Id } return 0 } func (m *Container) GetCustomerId() string { if m != nil { return m.CustomerId } return "" } func (m *Container) GetOrigin() string { if m != nil { return m.Origin } return "" } func (m *Container) GetUserId() string { if m != nil { return m.UserId } return "" } type Response struct { Created bool `protobuf:"varint,1,opt,name=created,proto3" json:"created,omitempty"` Consignment *Consignment `protobuf:"bytes,2,opt,name=consignment,proto3" json:"consignment,omitempty"` XXX_NoUnkeyedLiteral struct{} `json:"-"` XXX_unrecognized []byte `json:"-"` XXX_sizecache int32 `json:"-"` } func (m *Response) Reset() { *m = Response{} } func (m *Response) String() string { return proto.CompactTextString(m) } func (*Response) ProtoMessage() {} func (*Response) Descriptor() ([]byte, []int) { return fileDescriptor_3804bf87090b51a9, []int{2} } func (m *Response) XXX_Unmarshal(b []byte) error { return xxx_messageInfo_Response.Unmarshal(m, b) } func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) { return xxx_messageInfo_Response.Marshal(b, m, deterministic) } func (m *Response) XXX_Merge(src proto.Message) { xxx_messageInfo_Response.Merge(m, src) } func (m *Response) XXX_Size() int { return xxx_messageInfo_Response.Size(m) } func (m *Response) XXX_DiscardUnknown() { xxx_messageInfo_Response.DiscardUnknown(m) } var xxx_messageInfo_Response proto.InternalMessageInfo func (m *Response) GetCreated() bool { if m != nil { return m.Created } return false } func (m *Response) GetConsignment() *Consignment { if m != nil { return m.Consignment } return nil } func init() { proto.RegisterType((*Consignment)(nil), "Consignment") proto.RegisterType((*Container)(nil), "Container") proto.RegisterType((*Response)(nil), "Response") } func init() { proto.RegisterFile("consignment.proto", fileDescriptor_3804bf87090b51a9) } var fileDescriptor_3804bf87090b51a9 = []byte{ // 281 bytes of a gzipped FileDescriptorProto 0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x91, 0xbf, 0x4e, 0x33, 0x31, 0x10, 0xc4, 0xbf, 0xcb, 0xff, 0x5b, 0x7f, 0x02, 0xc5, 0x05, 0x58, 0x50, 0x70, 0xba, 0x2a, 0xa2, 0x70, 0x11, 0x9e, 0x00, 0xa5, 0x4a, 0xeb, 0xd0, 0xa3, 0x60, 0xaf, 0x2e, 0x2b, 0x11, 0xfb, 0x64, 0x3b, 0xe1, 0x75, 0x78, 0x54, 0x74, 0xbe, 0x1c, 0x18, 0x51, 0xce, 0xac, 0x67, 0xf7, 0xa7, 0x31, 0x2c, 0xb5, 0xb3, 0x81, 0x1a, 0x7b, 0x44, 0x1b, 0x65, 0xeb, 0x5d, 0x74, 0xf5, 0x67, 0x01, 0x6c, 0xf3, 0xe3, 0xf2, 0x2b, 0x18, 0x91, 0x11, 0x45, 0x55, 0xac, 0xa6, 0x6a, 0x44, 0x86, 0x57, 0xc0, 0x0c, 0x06, 0xed, 0xa9, 0x8d, 0xe4, 0xac, 0x18, 0x55, 0xc5, 0xaa, 0x54, 0xb9, 0xc5, 0x6f, 0x60, 0xf6, 0x81, 0xd4, 0x1c, 0xa2, 0x18, 0xa7, 0xd4, 0x45, 0xf1, 0x47, 0x00, 0xed, 0x6c, 0xdc, 0x93, 0x45, 0x1f, 0xc4, 0xa4, 0x1a, 0xaf, 0xd8, 0x1a, 0xe4, 0x66, 0xb0, 0x54, 0x36, 0xe5, 0xf7, 0x50, 0x9e, 0x31, 0x04, 0x7c, 0x7f, 0x25, 0x23, 0xa6, 0xe9, 0xc6, 0xa2, 0x37, 0xb6, 0xa6, 0x3e, 0x42, 0xf9, 0x9d, 0xfa, 0xc3, 0xf7, 0x00, 0x4c, 0x9f, 0x42, 0x74, 0x47, 0xf4, 0x5d, 0xb6, 0xe7, 0x83, 0xc1, 0xda, 0x9a, 0x0e, 0xcf, 0x79, 0x6a, 0xc8, 0x26, 0xbc, 0x52, 0x5d, 0x14, 0xbf, 0x85, 0xf9, 0x29, 0xf4, 0xa1, 0x49, 0x3f, 0xe8, 0xe4, 0xd6, 0xd4, 0x2f, 0xb0, 0x50, 0x18, 0x5a, 0x67, 0x03, 0x72, 0x01, 0x73, 0xed, 0x71, 0x1f, 0xb1, 0x3f, 0xb9, 0x50, 0x83, 0xe4, 0x12, 0x58, 0x56, 0x66, 0xba, 0xcb, 0xd6, 0xff, 0x65, 0x56, 0xa5, 0xca, 0x1f, 0xac, 0x9f, 0xe1, 0x7a, 0x77, 0xa0, 0xb6, 0x25, 0xdb, 0xec, 0xd0, 0x9f, 0x49, 0x23, 0x97, 0xb0, 0xdc, 0xa4, 0x6d, 0x79, 0xff, 0xbf, 0x56, 0xdc, 0x95, 0x72, 0x40, 0xa9, 0xff, 0xbd, 0xcd, 0xd2, 0x8f, 0x3d, 0x7d, 0x05, 0x00, 0x00, 0xff, 0xff, 0x84, 0x5c, 0xa4, 0x06, 0xc6, 0x01, 0x00, 0x00, } // Reference imports to suppress errors if they are not otherwise used. var _ context.Context var _ grpc.ClientConn // This is a compile-time assertion to ensure that this generated file // is compatible with the grpc package it is being compiled against. const _ = grpc.SupportPackageIsVersion4 // ShippingServiceClient is the client API for ShippingService service. // // For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream. type ShippingServiceClient interface { CreateConsignment(ctx context.Context, in *Consignment, opts ...grpc.CallOption) (*Response, error) } type shippingServiceClient struct { cc *grpc.ClientConn } func NewShippingServiceClient(cc *grpc.ClientConn) ShippingServiceClient { return &amp;shippingServiceClient{cc} } func (c *shippingServiceClient) CreateConsignment(ctx context.Context, in *Consignment, opts ...grpc.CallOption) (*Response, error) { out := new(Response) err := c.cc.Invoke(ctx, "/ShippingService/CreateConsignment", in, out, opts...) if err != nil { return nil, err } return out, nil } // ShippingServiceServer is the server API for ShippingService service. type ShippingServiceServer interface { CreateConsignment(context.Context, *Consignment) (*Response, error) } func RegisterShippingServiceServer(s *grpc.Server, srv ShippingServiceServer) { s.RegisterService(&amp;_ShippingService_serviceDesc, srv) } func _ShippingService_CreateConsignment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) { in := new(Consignment) if err := dec(in); err != nil { return nil, err } if interceptor == nil { return srv.(ShippingServiceServer).CreateConsignment(ctx, in) } info := &amp;grpc.UnaryServerInfo{ Server: srv, FullMethod: "/ShippingService/CreateConsignment", } handler := func(ctx context.Context, req interface{}) (interface{}, error) { return srv.(ShippingServiceServer).CreateConsignment(ctx, req.(*Consignment)) } return interceptor(ctx, in, info, handler) } var _ShippingService_serviceDesc = grpc.ServiceDesc{ ServiceName: "ShippingService", HandlerType: (*ShippingServiceServer)(nil), Methods: []grpc.MethodDesc{ { MethodName: "CreateConsignment", Handler: _ShippingService_CreateConsignment_Handler, }, }, Streams: []grpc.StreamDesc{}, Metadata: "consignment.proto", }</span></span></code> </pre> <br><p>  Si, alors quelque chose s'est mal pass√©.  Faites attention aux arguments -I est le chemin o√π le compilateur recherche les fichiers, --go_out o√π un nouveau fichier sera cr√©√©.  Il y a toujours de l'aide </p><br><pre> <code class="bash hljs">$ protoc -h</code> </pre> </div></div><br><p>  Il s'agit du code g√©n√©r√© automatiquement par les biblioth√®ques gRPC / protobuf afin que vous puissiez associer votre d√©finition de protobuf √† votre propre code. </p><br><h4 id="napishem-maingo">  Nous √©crirons main.go </h4><br><div class="spoiler">  <b class="spoiler_title">main.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> seaport <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net"</span></span> <span class="hljs-comment"><span class="hljs-comment">//    pbf "seaport/consignment" "golang.org/x/net/context" "google.golang.org/grpc" "google.golang.org/grpc/reflection" ) const ( port = ":50051" ) //IRepository -   type IRepository interface { Create(*pbf.Consignment) (*pbf.Consignment, error) } // Repository -    , //        type Repository struct { consignments []*pbf.Consignment } //Create -    func (repo *Repository) Create(consignment *pbf.Consignment) (*pbf.Consignment, error) { updated := append(repo.consignments, consignment) repo.consignments = updated return consignment, nil } //         //       .     //         . . type service struct { repo IRepository } // CreateConsignment -        , //    create,      //     gRPC. func (s *service) CreateConsignment(ctx context.Context, req *pbf.Consignment) (*pbf.Response, error) { //      consignment, err := s.repo.Create(req) if err != nil { return nil, err } //   `Response`, //        return &amp;pbf.Response{Created: true, Consignment: consignment}, nil } func main() { repo := &amp;Repository{} //   gRPC    tcp lis, err := net.Listen("tcp", port) if err != nil { log.Fatalf("failed to listen: %v", err) } s := grpc.NewServer() //      gRPC,    //        //  `Response`,       pbf.RegisterShippingServiceServer(s, &amp;service{repo}) //      gRPC. reflection.Register(s) if err := s.Serve(lis); err != nil { log.Fatalf("failed to serve: %v", err) } }</span></span></code> </pre> </div></div><br><p>  Veuillez lire attentivement les commentaires laiss√©s dans le code.  Apparemment, nous cr√©ons ici une logique d'impl√©mentation dans laquelle nos m√©thodes gRPC interagissent en utilisant les formats g√©n√©r√©s, cr√©ant un nouveau serveur gRPC sur le port 50051. Maintenant, notre service gRPC y vivra. <br>  Vous pouvez l'ex√©cuter avec <strong>$ go run main.go</strong> , mais vous ne verrez rien et vous ne pourrez pas l'utiliser ... Alors, cr√©ons un client pour le voir en action. </p><br><p>  Cr√©ons une interface de ligne de commande qui prend un fichier JSON et interagit avec notre service gRPC. </p><br><p>  Dans le r√©pertoire racine, cr√©ez un nouveau sous-r√©pertoire de <strong>$ mkdir consignment-cli</strong> .  Dans ce r√©pertoire, cr√©ez un fichier cli.go avec le contenu suivant: </p><br><div class="spoiler">  <b class="spoiler_title">cli.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"encoding/json"</span></span> <span class="hljs-string"><span class="hljs-string">"io/ioutil"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"os"</span></span> pbf <span class="hljs-string"><span class="hljs-string">"seaport/consignment"</span></span> <span class="hljs-string"><span class="hljs-string">"golang.org/x/net/context"</span></span> <span class="hljs-string"><span class="hljs-string">"google.golang.org/grpc"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( address = <span class="hljs-string"><span class="hljs-string">"localhost:50051"</span></span> defaultFilename = <span class="hljs-string"><span class="hljs-string">"consignment.json"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">//    func parseFile(file string) (*pbf.Consignment, error) { var consignment *pbf.Consignment data, err := ioutil.ReadFile(file) if err != nil { return nil, err } json.Unmarshal(data, &amp;consignment) return consignment, err } func main() { //     conn, err := grpc.Dial(address, grpc.WithInsecure()) if err != nil { log.Fatalf("  : %v", err) } defer conn.Close() client := pbf.NewShippingServiceClient(conn) //    consignment.json, //          file := defaultFilename if len(os.Args) &gt; 1 { file = os.Args[1] } consignment, err := parseFile(file) if err != nil { log.Fatalf("   : %v", err) } r, err := client.CreateConsignment(context.Background(), consignment) if err != nil { log.Fatalf("  : %v", err) } log.Printf(": %t", r.Created) }</span></span></code> </pre> </div></div><br><p>  Cr√©ez maintenant un lot (consignment-cli / consignment.json): </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"  "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">"containers"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"customer_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"user_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"origin"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"vessel_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span> }</code> </pre> <br><p>  Maintenant, si vous ex√©cutez <strong>$ go run main.go √†</strong> partir du package <strong>seaport</strong> , puis ex√©cutez <strong>$ go run cli.go</strong> dans un panneau de terminal s√©par√©.  Vous devriez voir le message ¬´Cr√©√©: vrai¬ª. <br>  Mais comment v√©rifier exactement ce qui a √©t√© cr√©√©?  Mettons √† jour notre service √† l'aide de la m√©thode GetConsignments afin que nous puissions afficher tous nos lots cr√©√©s. </p><br><div class="spoiler">  <b class="spoiler_title">consigment.proto</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//consigment.proto syntax = "proto3"; service ShippingService{ rpc CreateConsignment(Consignment) returns (Response) {} //    rpc GetConsignments(GetRequest) returns (Response) {} } message Consignment { int32 id = 1; string description = 2; int32 weight = 3; repeated Container containers = 4; string vessel_id = 5; } message Container { int32 id =1; string customer_id =2; string origin = 3; string user_id = 4; } //    message GetRequest {} message Response { bool created = 1; Consignment consignment = 2; //     //     repeated Consignment consignments = 3; }</span></span></code> </pre> </div></div><br><p>  Donc, ici, nous avons cr√©√© une nouvelle m√©thode sur notre service appel√©e <strong>GetConsignments</strong> , nous avons √©galement cr√©√© une nouvelle <strong>GetRequest</strong> , qui ne contient encore rien.  Nous avons √©galement ajout√© un champ de lots envoy√©s √† notre message de r√©ponse.  Vous remarquerez que le type ici a le mot-cl√© r√©p√©t√© jusqu'au type.  Comme vous l'avez probablement devin√©, cela signifie simplement de traiter ce champ comme un tableau de ces types. </p><br><p>  Ne vous pr√©cipitez pas pour ex√©cuter le programme, l'impl√©mentation de nos m√©thodes gRPC est bas√©e sur la correspondance de l'interface cr√©√©e par la biblioth√®que protobuf, nous devons nous assurer que notre impl√©mentation correspond √† notre d√©finition de proto. </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//seaport/main.go //IRepository -   type IRepository interface { Create(*pbf.Consignment) (*pbf.Consignment, error) GetAll() []*pbf.Consignment } //GetAll -       func (repo *Repository) GetAll() []*pbf.Consignment { return repo.consignments } //GetConsignments -         func (s *service) GetConsignments(ctx context.Context, req *pbf.GetRequest) (*pbf.Response, error) { consignments := s.repo.GetAll() return &amp;pbf.Response{Consignments: consignments}, nil }</span></span></code> </pre> <br><p>  Ici, nous avons inclus notre nouvelle m√©thode GetConsignments, mis √† jour notre r√©f√©rentiel et notre interface, respectivement cr√©√©s dans la d√©finition consignments.proto.  Si vous ex√©cutez √† nouveau <strong>$ go run main.go</strong> , le programme devrait fonctionner √† nouveau. </p><br><p>  Mettons √† jour notre outil cli pour inclure la possibilit√© d'appeler cette m√©thode et il est possible de lister nos parties: </p><br><div class="spoiler">  <b class="spoiler_title">cli.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"encoding/json"</span></span> <span class="hljs-string"><span class="hljs-string">"io/ioutil"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"os"</span></span> pbf <span class="hljs-string"><span class="hljs-string">"seaport/consignment"</span></span> <span class="hljs-string"><span class="hljs-string">"golang.org/x/net/context"</span></span> <span class="hljs-string"><span class="hljs-string">"google.golang.org/grpc"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( address = <span class="hljs-string"><span class="hljs-string">"localhost:50051"</span></span> defaultFilename = <span class="hljs-string"><span class="hljs-string">"consignment.json"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">//    func parseFile(file string) (*pbf.Consignment, error) { var consignment *pbf.Consignment data, err := ioutil.ReadFile(file) if err != nil { return nil, err } json.Unmarshal(data, &amp;consignment) return consignment, err } func main() { //     conn, err := grpc.Dial(address, grpc.WithInsecure()) if err != nil { log.Fatalf("  : %v", err) } defer conn.Close() client := pbf.NewShippingServiceClient(conn) //    consignment.json, //          file := defaultFilename if len(os.Args) &gt; 1 { file = os.Args[1] } consignment, err := parseFile(file) if err != nil { log.Fatalf("   : %v", err) } r, err := client.CreateConsignment(context.Background(), consignment) if err != nil { log.Fatalf("  : %v", err) } log.Printf(": %t", r.Created) getAll, err := client.GetConsignments(context.Background(), &amp;pbf.GetRequest{}) if err != nil { log.Fatalf("    : %v", err) } for _, cns := range getAll.Consignments { fmt.Printf("Id: %v\n", cns.GetId()) fmt.Printf("Description: %v\n", cns.GetDescription()) fmt.Printf("Weight: %d\n", cns.GetWeight()) fmt.Printf("VesselId: %v\n", cns.GetVesselId()) for _, cnt := range cns.GetContainers() { fmt.Printf("\tId: %v\n", cnt.GetId()) fmt.Printf("\tUserId: %v\n", cnt.GetUserId()) fmt.Printf("\tCustomerId: %v\n", cnt.GetCustomerId()) fmt.Printf("\tOrigin: %v\n", cnt.GetOrigin()) } } }</span></span></code> </pre> </div></div><br><p>  Ajoutez le code ci-dessus √† cli.go et ex√©cutez <strong>$ go run cli.go √† nouveau</strong> .  Le client ex√©cutera CreateConsignment puis appellera GetConsignments.  Et vous devriez voir que dans la liste des r√©ponses contient la composition du parti. </p><br><p>  Ainsi, nous avons le premier microservice et le premier client √† interagir avec lui en utilisant protobuf et gRPC. </p><br><p>  La prochaine partie de cette s√©rie comprendra l'int√©gration go-micro, qui est une base puissante pour la cr√©ation de microservices bas√©s sur gRPC.  Nous allons √©galement cr√©er notre deuxi√®me service.  Consid√©rez le travail de nos services dans les conteneurs Docker, dans la prochaine partie de cette s√©rie d'articles. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr425653/">https://habr.com/ru/post/fr425653/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr425641/index.html">Les r√©sidents de la ville canadienne ont d√©velopp√© un "service Uber" avec des bus, pas des voitures</a></li>
<li><a href="../fr425643/index.html">√âv√©nements num√©riques √† Moscou du 8 au 14 octobre</a></li>
<li><a href="../fr425645/index.html">SpaceX et SAOCOM - 1A Nouvelle mission. Termin√©</a></li>
<li><a href="../fr425647/index.html">Test de l'interface utilisateur: v√©rification du syst√®me √† diff√©rentes r√©solutions</a></li>
<li><a href="../fr425649/index.html">BDSM, Gore et la poursuite du d√©veloppeur Drupal</a></li>
<li><a href="../fr425657/index.html">L'in√©vitabilit√© de la punition, l'efficacit√© des contr√¥les brusques</a></li>
<li><a href="../fr425659/index.html">La conception interactive ne doit pas √™tre compliqu√©e.</a></li>
<li><a href="../fr425661/index.html">22 conseils pour un d√©veloppeur Angular. Partie 1</a></li>
<li><a href="../fr425663/index.html">22 conseils pour un d√©veloppeur Angular. 2e partie</a></li>
<li><a href="../fr425665/index.html">Git: correction de bugs et correction de commits</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>