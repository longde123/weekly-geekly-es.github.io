<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé´ üèâ ‚òÅÔ∏è Nous estimons le d√©bit du canal MIMO (l'algorithme de versement d'eau est inclus) üßòüèº üò≥ üöæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©face 


 Au cours de l'√©t√© 2016, √† partir d'un √©v√©nement bien connu, votre humble serviteur, parmi un groupe d'autres √©tudiants, a pu assister √† de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous estimons le d√©bit du canal MIMO (l'algorithme de versement d'eau est inclus)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448570/"><p><img src="https://habrastorage.org/getpro/habr/post_images/0d0/672/437/0d067243758eedce24dc51cb947b5581.jpg"></p><br><h1 id="predislovie">  Pr√©face </h1><br><p>  Au cours de l'√©t√© 2016, √† partir d'un √©v√©nement bien connu, votre humble serviteur, parmi un groupe d'autres √©tudiants, a pu assister √† des conf√©rences du professeur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Martin Haardt</a> sur des sujets <strong>MIMO</strong> , organis√©es par lui dans le cadre du programme de master international <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">"Communication et traitement du signal"</a> .  Mais, malheureusement, une semaine et demie sur deux, je suis tomb√© assez malade - et donc un certain nombre de sujets sont tomb√©s hors de mon champ de compr√©hension ... Cependant, apr√®s un certain temps, analyser les bases du MIMO est devenu mon hobby - ne pas laisser l'affaire inachev√©e. </p><br><p>  Petit √† petit, tout cela s'est transform√© en une s√©rie de petits <em>s√©minaires abstraits</em> , qu'il serait probablement faux de ne pas partager.  Et aujourd'hui, en l'honneur <strong>de la Journ√©e de la communication</strong> , je voudrais discuter avec vous du sujet de la bande passante du canal MIMO - un sujet simple, mais qui pose toujours certaines difficult√©s aux √©tudiants (et pas seulement aux √©tudiants). </p><br><p>  Il peut sembler aux gens non impliqu√©s qu'une augmentation du nombre d'antennes de r√©ception et d'√©mission dans le cadre de la technologie susmentionn√©e augmente la bande passante du syst√®me de la m√™me quantit√©: par exemple, si vous mettez <strong>2</strong> antennes du c√¥t√© de r√©ception et <strong>2</strong> antennes du c√¥t√© d'√©mission (MIMO 2x2), le d√©bit augmentera d√©finitivement <strong>2</strong> fois.  Mais est-ce m√™me vrai en th√©orie?  Essayons de le comprendre! </p><a name="habracut"></a><br><blockquote>  Une version plus formelle en anglais peut √™tre trouv√©e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">sur le lien</a> et dans mon <a href="" rel="nofollow">r√©f√©rentiel GitHub</a> . <br>  Dans cet article, nous ne consid√©rerons pas les probl√®mes de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">corr√©lation d'antenne</a> et d'autres probl√®mes d'impl√©mentation.  Nous nous limitons √† une th√©orie distill√©e - pour commencer. </blockquote><br><h1 id="model-prinyatogo-signala">  Mod√®le de signal re√ßu </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/308/f3d/94b/308f3d94b67d28b58f43b6c934fdefd7.png"></p><br><p>  Avant de commencer √† parler de bande passante, nous traiterons d'abord de la description math√©matique du signal re√ßu.  Cette partie doit √™tre prise avec beaucoup de soin, car beaucoup proviendra de cette formule.  Ainsi, le signal re√ßu peut √™tre repr√©sent√© comme: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a11/4ec/2f2/a114ec2f2cdbad23ee05bedbe4ca698f.svg" alt="\ mathbf {y} = \ sqrt {\ frac {P} {M_T}} \ mathbf {H} \ mathbf {s} + \ mathbf {n} \ qquad (1)"></div><br><p>  o√π <img src="https://habrastorage.org/getpro/habr/post_images/d01/0b8/a41/d010b8a414d72f3ae43997a3a0c383db.svg" alt="P">  - puissance d'√©mission, <img src="https://habrastorage.org/getpro/habr/post_images/790/f98/5f1/790f985f11719c2994f91faf218ad311.svg" alt="M_T">  - nombre d'antennes d'√©mission, <img src="https://habrastorage.org/getpro/habr/post_images/704/f4d/c83/704f4dc83e43715dbca37e74095e21fd.svg" alt="\ mathbf {s}">  - caract√®res transmis <img src="https://habrastorage.org/getpro/habr/post_images/0c8/028/7f3/0c80287f3b7d3378c2e2c69a374282d7.svg" alt="\ mathbf {n}">  - bruit additif, et <img src="https://habrastorage.org/getpro/habr/post_images/e79/cb6/ae8/e79cb6ae8d0e454f94b42ad408308b72.svg" alt="\ mathbf {H}">  - matrice des coefficients de transmission du canal (en fait, le processus d'√©vanouissement). </p><br><p>  Le signal transmis peut √©galement √™tre peint un peu plus en d√©tail: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/399/0f5/eb0/3990f5eb08f290f19a1288c2c5772792.svg" alt="s_i = \ gamma_i d_i \ quad i = 1,2, .. M_T \ qquad (2)"></div><br><p>  o√π <img src="https://habrastorage.org/getpro/habr/post_images/1bb/7b2/fbc/1bb7b2fbccba41b76c9d4173d75920a6.svg" alt="di">  - l'un des signaux d'information ( <img src="https://habrastorage.org/getpro/habr/post_images/3da/909/c1e/3da909c1e9bfc42a2d72c4cb9eaf46cd.svg" alt="E \ {\ mathbf {d} \ mathbf {d} ^ H \} = M_T">  ) et <img src="https://habrastorage.org/getpro/habr/post_images/c81/04b/c49/c8104bc49b2fd2a61cc8b9299bc02b3d.svg" alt="\ gamma_i">  - amplification d'un certain chemin de propagation d'une onde EM (gain de chemin). </p><br><p>  <u>Indiquons ce qu'est le renforcement du chemin:</u> <br>  Le renforcement du chemin de propagation (ou du poids de l'antenne) signifie la distribution de la puissance de sortie proportionnelle √† la "force" d'un chemin particulier.  En d'autres termes, nous voulons allouer plus de puissance aux bons canaux (chemins de propagation) et moins d'√©nergie aux mauvais canaux. </p><br><p>  Le poids des antennes est limit√© par le nombre d'antennes d'√©mission: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cbb/3c5/de0/cbb3c5de0a1de4ab81447d7e251f85a4.svg" alt="\ sum ^ r_ {i = 1} \ gamma_i = M_T \ qquad (3)"></div><br><p>  o√π <img src="https://habrastorage.org/getpro/habr/post_images/cd2/a49/a17/cd2a49a1779b4e360712e1013ed124a7.svg" alt="r">  Est le <strong>rang de la</strong> matrice de canaux. </p><br><p>  En parlant de ce dernier. </p><br><p>  Dimension de la matrice <img src="https://habrastorage.org/getpro/habr/post_images/e79/cb6/ae8/e79cb6ae8d0e454f94b42ad408308b72.svg" alt="\ mathbf {H}">  compose <img src="https://habrastorage.org/getpro/habr/post_images/043/a05/2ed/043a052edaf7736764222d480a9bdf44.svg" alt="M_R \ fois M_T">  o√π <img src="https://habrastorage.org/getpro/habr/post_images/e8c/d2b/287/e8cd2b287c02798716d1728e3080ebeb.svg" alt="M_R">  - nombre d'antennes de r√©ception. <br>  Pour plusieurs mesures de temps, le canal ressemblera √† ceci: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6fb/9e2/0c2/6fb9e20c2a79856e2d952dd1897813ec.png"></p><br><blockquote>  <strong>Pour r√©f√©rence:</strong> <br>  Peut-√™tre pour des calculs et des mod√®les plus complexes, vous voudrez peut-√™tre utiliser l'un des outils les plus populaires pour cela - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">MatLab</a> .  Dans ce cas, il convient de consid√©rer qu'une structure de donn√©es l√©g√®rement diff√©rente y est utilis√©e: les lignes sont des mesures de temps (instantan√©s), le nombre de colonnes correspond au nombre d'antennes d'√©mission <img src="https://habrastorage.org/getpro/habr/post_images/790/f98/5f1/790f985f11719c2994f91faf218ad311.svg" alt="M_T">  , la dimension lat√©rale correspond √† <img src="https://habrastorage.org/getpro/habr/post_images/e8c/d2b/287/e8cd2b287c02798716d1728e3080ebeb.svg" alt="M_R">  . </blockquote><p>  La formule (1) peut facilement √™tre adapt√©e pour des cas particuliers de MIMO. </p><br><p>  <strong>MISO</strong> ( <strong>M</strong> ultiple Input <strong>S</strong> ingle Output - plusieurs antennes d'√©mission et une de r√©ception): </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/faa/99b/800/faa99b80083c385e9efcec4c39e135b9.svg" alt="y = \ sqrt {\ frac {P} {M_T}} \ mathbf {h} \ mathbf {s} + n \ qquad (4)"></div><br><p>  o√π <img src="https://habrastorage.org/getpro/habr/post_images/e0b/43a/394/e0b43a394e4da4c710d883c2040a101f.svg" alt="\ mathbf {h}">  Est un vecteur <img src="https://habrastorage.org/getpro/habr/post_images/198/8ce/bbb/1988cebbb6865548743db331b96b8691.svg" alt="1 \ fois M_T">  . </p><br><p>  <strong>SIMO</strong> (sortie unique √† un seul <strong>M</strong> ultiple - plusieurs antennes de r√©ception et une antenne d'√©mission): </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d4/4ce/713/1d44ce713b6479b18db31b6eea465139.svg" alt="y = \ sqrt {P} \ mathbf {h} s + \ mathbf {n} \ qquad (5)"></div><br><p>  o√π <img src="https://habrastorage.org/getpro/habr/post_images/e0b/43a/394/e0b43a394e4da4c710d883c2040a101f.svg" alt="\ mathbf {h}">  Est un vecteur <img src="https://habrastorage.org/getpro/habr/post_images/255/44a/e75/25544ae75110da1c6751c23ef7057e7d.svg" alt="M_R \ fois 1"></p><br><p>  <strong>SISO</strong> ( <strong>S</strong> ingle Single <strong>S</strong> ingle <strong>O</strong> utput - une antenne c√¥t√© r√©ception et √©mission): </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dff/17e/6a9/dff17e6a9569811683f776e4e9b87b9a.svg" alt="y = \ sqrt {P} hs + n \ qquad (6)"></div><br><p>  Cela semble simple. </p><br><p>  Toute autre consid√©ration peut √™tre divis√©e en <strong>deux</strong> grands cas: les informations d'√©tat de canal (CSI - informations d'√©tat de canal) sont <em>inconnues de l'</em> √©metteur ( <strong>CU</strong> - Canal inconnu) et les informations d'√©tat de canal sont <em>connues de l'</em> √©metteur ( <strong>CK</strong> - Canal connu). </p><br><p>  Ci-dessus, nous avons examin√© le cas o√π le canal est <strong>inconnu</strong> de l'√©metteur ( <strong>cas en boucle ouverte</strong> , transmission sans retour).  En d'autres termes, faute d'informations n√©cessaires, nous ne pouvons choisir aucune direction efficace, et donc nous suivons le chemin le plus simple: nous transmettons une puissance √©gale √† travers toutes les antennes (chemins, chemins de propagation).  Par cons√©quent, le gain de chaque gain de chemin est de <strong>1</strong> : </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39e/f6d/75b/39ef6d75b2d7666174e1f1570c433b07.svg" alt="\ gamma_i = 1, \ quad i = 1,2, .. M_T \ qquad (7)"></div><br><p>  Cependant, nous r√©p√©tons: nous voulons allouer <strong>plus de</strong> puissance aux <strong>bons</strong> canaux (chemins de propagation) et <strong>moins d'</strong> √©nergie aux <strong>mauvais</strong> canaux. </p><br><p>  La question se pose: <u>comment r√©partir efficacement le pouvoir?</u> </p><br><p>  Si le canal <strong>est connu</strong> ( <strong>cas en boucle ferm√©e</strong> - avec r√©troaction), nous pouvons utiliser des sc√©narios de transmission avanc√©s avec quelques algorithmes de traitement du signal suppl√©mentaires.  Par exemple, avec des approches lin√©aires telles que le <em>pr√©-codage</em> et le <strong>post-traitement</strong> . </p><br><p>  Nous comprendrons ce que signifient les deux derniers termes. </p><br><p>  Si nous avons <strong>CSI</strong> du c√¥t√© √©mission, c'est-√†-dire  matrice <img src="https://habrastorage.org/getpro/habr/post_images/e79/cb6/ae8/e79cb6ae8d0e454f94b42ad408308b72.svg" alt="\ mathbf {H}">  , nous pouvons traiter math√©matiquement cette matrice m√™me.  Par exemple, appliquer l'algorithme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">SVD</a> (Singular Value Decomposition). </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6bb/95a/fd3/6bb95afd35a66bb0b6421818b985d561.png"></p><br><p>  Notez que la matrice <img src="https://habrastorage.org/getpro/habr/post_images/1da/072/a41/1da072a419fecc8ecc89c0fa5f6fcd6d.svg" alt="\ mathbf {\ Sigma}">  Est une matrice diagonale, et les √©l√©ments de sa diagonale (valeurs singuli√®res) sont, par essence, des coefficients de transmission de chemins de propagation uniques.  En d'autres termes, si nous r√©alisons la multiplication de notre signal par une matrice de valeurs singuli√®res <img src="https://habrastorage.org/getpro/habr/post_images/1da/072/a41/1da072a419fecc8ecc89c0fa5f6fcd6d.svg" alt="\ mathbf {\ Sigma}">  plut√¥t que le canal complet <img src="https://habrastorage.org/getpro/habr/post_images/e79/cb6/ae8/e79cb6ae8d0e454f94b42ad408308b72.svg" alt="\ mathbf {H}">  , le canal <strong>MIMO</strong> se d√©composera en un r√©seau de canaux <strong>SISO</strong> parall√®les. </p><br><p>  La matrice de pr√©codage lin√©aire (filtre) doit donc √™tre <img src="https://habrastorage.org/getpro/habr/post_images/0dc/438/f04/0dc438f04dcae00f8f6be6e90cc305d7.svg" alt="\ mathbf {F} = \ mathbf {V} _s">  , et la matrice de post-traitement lin√©aire (d√©modulateur) <img src="https://habrastorage.org/getpro/habr/post_images/7d4/715/f1a/7d4715f1a45bb371053c241af4f13904.svg" alt="\ mathbf {D} = \ mathbf {U} ^ H_s">  ( <em>H</em> signifie conjugaison hermitienne). </p><br><blockquote>  De toute √©vidence, pour le cas avec un canal inconnu <img src="https://habrastorage.org/getpro/habr/post_images/262/9d2/195/2629d21955e2a9cd73b9be24a5a947eb.svg" alt="\ mathbf {F}">  et <img src="https://habrastorage.org/getpro/habr/post_images/21b/7c1/06d/21b7c106daa35c36f96c5ae499233ec0.svg" alt="\ mathbf {D}">  matrices d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">identit√©</a> √©gales. </blockquote><p>  Maintenant, sachant tout ce qui pr√©c√®de, red√©finissons le mod√®le du signal re√ßu: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38b/56d/23d/38b56d23d403a6a8910ad66923db4118.svg" alt="\ mathbf {Dy} = \ mathbf {D} \ left (\ sqrt {\ frac {P} {M_t}} \ mathbf {H} \ mathbf {F} \ mathbf {s} + \ mathbf {n} \ right) = \ mathbf {U} ^ H_s \ mathbf {y} = \ sqrt {\ frac {P} {M_t}} \ mathbf {U} ^ H_s \ mathbf {H} \ mathbf {V} _s \ mathbf {s} + \ mathbf {U} ^ H_s \ mathbf {n} = \ sqrt {\ frac {P} {M_t}} \ mathbf {\ Sigma} _s \ mathbf {s} + \ mathbf {\ hat {n}} = \ mathbf {\ hat {y}} \ qquad (8)"></div><br><p>  Notez que: </p><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/feb/dae/d36/febdaed369cb465bf821b996e5e5cb61.svg" alt="\ mathbf {\ hat {n}}">  a les m√™mes propri√©t√©s statistiques que <img src="https://habrastorage.org/getpro/habr/post_images/0c8/028/7f3/0c80287f3b7d3378c2e2c69a374282d7.svg" alt="\ mathbf {n}">  ; </li><li>  Valeurs propres <img src="https://habrastorage.org/getpro/habr/post_images/bff/f9f/d6d/bfff9fd6d698c1d0e8011e5f9a9c6585.svg" alt="\ mathbf {HH} ^ H">  sont les carr√©s des valeurs singuli√®res de la matrice de canal <img src="https://habrastorage.org/getpro/habr/post_images/e79/cb6/ae8/e79cb6ae8d0e454f94b42ad408308b72.svg" alt="\ mathbf {H}">  ( <img src="https://habrastorage.org/getpro/habr/post_images/5d9/204/19e/5d920419e86666fa5a5de6669e965466.svg" alt="\ sigma_i = \ sqrt {\ lambda_i}">  ) </li></ul><br><p>  Sch√©matiquement, cela peut √™tre repr√©sent√© comme: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/e66/ce5/f41/e66ce5f41bd4d57670aad51ad5409adc.png" alt="sch" width="500" height="600"><br><p>  <em>Fig.</em>  <em>1. Le sch√©ma de pr√©-codage et de post-traitement [1, p.67].</em> </p><br><img src="https://habrastorage.org/getpro/habr/post_images/072/138/b29/072138b29e56f44939c260426c564153.png" alt="parall" width="500" height="600"><br><p>  <em>Fig.</em>  <em>2. Sch√©ma de d√©composition modale</em> <em><img src="https://habrastorage.org/getpro/habr/post_images/e79/cb6/ae8/e79cb6ae8d0e454f94b42ad408308b72.svg" alt="\ mathbf {H}"></em>  <em>lorsque le canal est connu de l'√©metteur et du r√©cepteur [1, p.67].</em> </p><br><p>  Les bases sont d√©mont√©es - on peut passer directement √† la <strong>bande passante</strong> ! </p><br><h1 id="propusknaya-sposobnost-capacity">  Capacit√© </h1><br><p>  Je pense que tous ceux qui ont √©tudi√© la <strong>th√©orie de l'information se</strong> souviennent que le terme bande passante nous est venu de cette discipline particuli√®re.  Habituellement (√† mon √¢ge √©tudiant), la consid√©ration √©tait concentr√©e sur le cas classique du canal AWGN, mais la formule peut √™tre d√©riv√©e relativement facilement pour le cas d'un canal MIMO avec d√©coloration. </p><br><blockquote>  Afin de ne pas retaper les calculs des livres, j'ai essay√© de tout arranger plus ou moins color√© et √† la main - pour donner des formules de vie, pour ainsi dire.  J'esp√®re que ce format sera moins fastidieux. </blockquote><p>  Donc, encore une fois, nous √©crivons le mod√®le de signal: </p><br><img src="https://habrastorage.org/webt/rh/x_/gc/rhx_gc1lr_rmqj6eaeewoewhvce.png"><br><p>  Passons maintenant √† la d√©termination du d√©bit gr√¢ce aux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">informations mutuelles</a> . </p><br><img src="https://habrastorage.org/webt/40/rb/cf/40rbcfuupxwyyx0ztm58nhubpqc.png"><br><p>  Nous √©crivons la matrice d'autocovariance du signal re√ßu et de ses composants: </p><br><img src="https://habrastorage.org/webt/hd/ke/nz/hdkenzy3rhhgoysafzwopgnij7u.png"><br><p>  Et nous les utilisons pour d√©terminer l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">entropie diff√©rentielle</a> : </p><br><img src="https://habrastorage.org/webt/ev/cj/mm/evcjmmt0qlyjudk_7xqn2ldimec.png"><br><p>  Remplacer (4) et (5) dans (2): </p><br><img src="https://habrastorage.org/webt/ww/ud/gd/wwudgdbvqd6orus-tfnp3azhly0.png"><br><p>  Et maintenant, nous substituons (6) √† (1): </p><br><img src="https://habrastorage.org/webt/2i/3c/p4/2i3cp4tj0nf_4s-rnistbmcw0rm.png"><br><p>  Nous continuons de raisonner.  Prenons le premier cas: le canal est inconnu ( <strong>C</strong> hannel <strong>U</strong> inconnu).  Cela signifie pour nous qu'il est impossible de choisir la direction de transmission optimale, et donc les signaux transmis seront ind√©pendants et auront la m√™me puissance (√©qui-aliment√©).  Sur la base de la condition maximale ( <img src="https://habrastorage.org/getpro/habr/post_images/b55/710/37c/b5571037cdb68260d690fba1e74c122b.svg" alt="Tr \ {\ mathbf {R} _ {ss} \} = M_T">  ), on peut prendre la matrice d'autocovariance des caract√®res transmis √©gale √† la matrice d'identit√©.  Ensuite, nous avons: </p><br><img src="https://habrastorage.org/webt/nn/bd/_p/nnbd_pjhgqezwomw944_71x0vw4.png"><br><p>  Nous utilisons la propri√©t√© de d√©terminants suivante: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbb/866/f57/fbb866f57bd5076cb0d56869fe5ecde0.svg" alt="det \ left (\ mathbf {I} _m + \ mathbf {AB} \ right) = det \ left (\ mathbf {I} _n + \ mathbf {BA} \ right)"></div><br><p>  C'est notre cas, et nous pouvons √©changer les matrices afin que <img src="https://habrastorage.org/getpro/habr/post_images/698/669/b9e/698669b9ea8fc3b7983608348382cc36.svg" alt="\ mathbf {Q} \ mathbf {Q} ^ H = \ mathbf {I}">  (√† partir des propri√©t√©s EVD).  Restera: </p><br><img src="https://habrastorage.org/webt/pk/no/dq/pknodqpt0rpcbvfp0z9eisl7imq.png"><br><p>  En passant des matrices aux sommes, nous avons: </p><br><img src="https://habrastorage.org/webt/u_/gm/k9/u_gmk95fp05y8obm7odpf-wo2lq.png" width="600"><br><p>  Cette formule illustre une fois de plus l'approche consistant √† consid√©rer le MIMO comme des canaux SISO parall√®les. <br>  Pour le cas avec le canal connu ( <strong>C</strong> hannel <strong>K</strong> connu), les poids d'antenne seront ajout√©s √† la formule: </p><br><img src="https://habrastorage.org/webt/vr/ht/bl/vrhtblex4vq8soaxqoa1tokmmre.png"><br><p>  Nous √©crivons √©galement des formules pour des cas particuliers: </p><br><img src="https://habrastorage.org/webt/y-/f5/7y/y-f57yb-4yc4-yeegeblpmr6-hy.png"><br><blockquote>  <strong>Remarque</strong> : <br>  Pour les cas de <strong>SIMO</strong> et <strong>MISO, ce n'est</strong> pas en vain que les carr√©s de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">norme Frobenius</a> apparaissent dans le dossier <img src="https://habrastorage.org/getpro/habr/post_images/c16/a79/bd1/c16a79bd16d4f7febf57f4dc4cefd303.svg" alt="|| \ mathbf {h} || _F ^ 2">  - d'un point de vue math√©matique, ils sont √©quivalents aux valeurs propres <img src="https://habrastorage.org/getpro/habr/post_images/f99/9f8/c65/f999f8c65e413f78334f6f3db0a438a6.svg" alt="\ mathbf {h} \ mathbf {h} ^ H">  .  Par cons√©quent, si vous devez calculer rapidement quelque chose √† la main - voici un moyen. </blockquote><p>  Eh bien, j'esp√®re que mon √©criture et mon anglais n'interf√®rent pas beaucoup avec la perception de l'information, mais quand m√™me, parlons du <strong>point principal</strong> : </p><br><ul><li>  Oui, la bande passante du canal <strong>MIMO</strong> peut √™tre consid√©r√©e comme la <strong>somme de la</strong> bande passante des canaux <strong>SISO</strong> . </li><li>  Cependant, ce montant est limit√© par le <strong>rang de la</strong> cha√Æne! </li></ul><br><h2 id="algoritm-water-pouring">  Algorithme de versement d'eau </h2><br><p>  Comme le montre la formule de bande passante connue du c√¥t√© √©mission du canal (CK - Channel Known), la distribution d'√©nergie sur les antennes peut √™tre optimis√©e.  Pour ce faire, nous utilisons l'algorithme Water-versing ( <em>remplissage d'eau</em> ) [1, p. 68-69]: </p><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> linalg <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> LA <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waterpouring</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Mt, SNR_dB, H_chan)</span></span></span><span class="hljs-function">:</span></span> SNR = <span class="hljs-number"><span class="hljs-number">10</span></span>**(SNR_dB/<span class="hljs-number"><span class="hljs-number">10</span></span>) r = LA.matrix_rank(H_chan) H_sq = np.dot(H_chan,np.matrix(H_chan, dtype=complex).H) lambdas = LA.eigvals(H_sq) lambdas = np.sort(lambdas)[::<span class="hljs-number"><span class="hljs-number">-1</span></span>] p = <span class="hljs-number"><span class="hljs-number">1</span></span>; gammas = np.zeros((r,<span class="hljs-number"><span class="hljs-number">1</span></span>)) flag = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> flag == <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: lambdas_r_p_1 = lambdas[<span class="hljs-number"><span class="hljs-number">0</span></span>:(r-p+<span class="hljs-number"><span class="hljs-number">1</span></span>)] inv_lambdas_sum = np.sum(<span class="hljs-number"><span class="hljs-number">1</span></span>/lambdas_r_p_1) mu = ( Mt / (r - p + <span class="hljs-number"><span class="hljs-number">1</span></span>) ) * ( <span class="hljs-number"><span class="hljs-number">1</span></span> + (<span class="hljs-number"><span class="hljs-number">1</span></span>/SNR) * inv_lambdas_sum) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idx, item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(lambdas_r_p_1): gammas[idx] = mu - (Mt/(SNR*item)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> gammas[rp] &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment">#due to Python starts from 0 gammas[rp] = 0 #due to Python starts from 0 p = p + 1 else: flag = False res = [] for gamma in gammas: res.append(float(gamma)) return np.array(res)</span></span></code> </pre> <br><p>  Test: </p><br><pre> <code class="python hljs">Mt = <span class="hljs-number"><span class="hljs-number">3</span></span> SNR_db = <span class="hljs-number"><span class="hljs-number">10</span></span> H_chan = np.array([[<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>],[<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>], [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>]], dtype = float) gammas = waterpouring(Mt, SNR_db, H_chan) print(<span class="hljs-string"><span class="hljs-string">'Rank of the matrix: '</span></span>+str(LA.matrix_rank(H_chan))) print(<span class="hljs-string"><span class="hljs-string">'Gammas:\n'</span></span>+str(gammas)) &gt;&gt;&gt; Rank of the matrix: <span class="hljs-number"><span class="hljs-number">2</span></span> &gt;&gt;&gt; Gammas: &gt;&gt;&gt; [<span class="hljs-number"><span class="hljs-number">1.545</span></span> <span class="hljs-number"><span class="hljs-number">1.455</span></span>]</code> </pre> <br><p>  Eh bien, cela semble raisonnable: <br>  1) le nombre d'antennes d'√©mission concern√©es est √©gal au <strong>rang du</strong> canal; <br>  2) la somme des <strong>poids des</strong> antennes est √©gale au nombre d'antennes d'√©mission. </p><br><h2 id="dva-predelnyh-sluchaya">  Deux cas limites </h2><br><p>  Et maintenant, soyons un peu distraits et r√©solvons les probl√®mes de compr√©hension. </p><br><p>  Trouvons, par exemple, ce que les coefficients seront √©gaux √† <img src="https://habrastorage.org/getpro/habr/post_images/c81/04b/c49/c8104bc49b2fd2a61cc8b9299bc02b3d.svg" alt="\ gamma_i">  avec SNR tendant √† <img src="https://habrastorage.org/getpro/habr/post_images/279/496/46c/27949646c03ab2b1b12c79632ddc20bf.svg" alt="+ \ infty">  et <img src="https://habrastorage.org/getpro/habr/post_images/60b/863/8b2/60b8638b28b303b1718d37bee487ac72.svg" alt="- \ infty">  (sur une √©chelle logarithmique, bien s√ªr, car il n'y a pas de pouvoirs n√©gatifs). </p><br><p>  On rappelle la formule de correspondance entre d√©cibels et temps: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/109/e43/006/109e430066ec30bab3ea15fc12b24b5a.svg" alt="SNR_ {dB} = 10log_ {10} \ left (\ frac {S} {N} \ right)"></div><br><p>  o√π <img src="https://habrastorage.org/getpro/habr/post_images/5bf/27c/73c/5bf27c73c71f303844ee4973cab18377.svg" alt="S">  - puissance du signal transmis (pour nos t√¢ches, elle √©quivaut √† l'√©nergie du symbole <img src="https://habrastorage.org/getpro/habr/post_images/072/074/880/072074880bc38a00e1970f944ed4cf99.svg" alt="E_s">  ) et <img src="https://habrastorage.org/getpro/habr/post_images/a1e/39d/a1c/a1e39da1c84981d7264baa207047222a.svg" alt="N">  - puissance du bruit (dans notre probl√®me est √©gal √† la densit√© spectrale du bruit <img src="https://habrastorage.org/getpro/habr/post_images/69a/ad3/04d/69aad304d9c25b25096b8e1cc83127e0.svg" alt="N_0">  ) </p><br><p>  Donc, sur une √©chelle lin√©aire sera: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/60d/387/38e/60d38738e895ea76af6cc9fcfb1dd0b6.svg" alt="\ frac {E_s} {N_0} \ equiv \ frac {S} {N} = 10 ^ {SNR_ {dB} / 10}"></div><br><p>  Nous regardons les formules de base de l'algorithme: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62a/6ee/46c/62a6ee46c3a82d81a5b1bddd0f625ea8.svg" alt="\ mu = \ frac {M_T} {(r-p + 1)} \ left [1 + \ frac {N_0} {E_s} \ sum_ {i = 1} ^ {r-p + 1} \ frac {1} {\ lambda_i} \ droite]"></div><br><p>  o√π <img src="https://habrastorage.org/getpro/habr/post_images/d76/c4d/c2b/d76c4dc2b17f00a09c864bf2d24ab365.svg" alt="p">  Est un it√©rateur commen√ßant par 1, <img src="https://habrastorage.org/getpro/habr/post_images/cd2/a49/a17/cd2a49a1779b4e360712e1013ed124a7.svg" alt="r">  Est le rang de la matrice des canaux, <img src="https://habrastorage.org/getpro/habr/post_images/4a1/9e2/b6a/4a19e2b6a9b67e2a8e0682126d49684a.svg" alt="\ lambda_i">  - i-√®me valeur propre du "carr√©" de la matrice de canal.  Les gammas sont calcul√©s √† l'aide de la formule suivante: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f5/2eb/aff/4f52ebaffbebeba87ac646dadd57d2cd.svg" alt="\ gamma_i = \ left (\ mu - \ frac {M_TN_0} {E_s \ lambda_i} \ right) \ quad i = 1,2, ..., r-p + 1"></div><br><p>  Nous commen√ßons √† raisonner: </p><br><p>  Si <img src="https://habrastorage.org/getpro/habr/post_images/734/618/09c/73461809c5cedcf8d9c19312c41a4d7a.svg" alt="SNR_ {dB} \ √† + \ infty">  alors <img src="https://habrastorage.org/getpro/habr/post_images/4ae/0cd/4f4/4ae0cd4f42acfe2e7b83ea1781a19667.svg" alt="\ frac {E_s} {N_0} \ to + \ infty">  .  Par cons√©quent <img src="https://habrastorage.org/getpro/habr/post_images/c58/ff3/050/c58ff30508740ab8078825a703e9e651.svg" alt="\ frac {N_0} {E_s} \ √† 0">  .  Pour la premi√®re it√©ration, il reste: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/05a/3a2/84f/05a3a284fd68bd18f8bbcb5608edf314.svg" alt="\ mu = \ frac {M_T} {r}"></div><br><p>  Substitut au gamma: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47e/e82/af3/47ee82af3923910da61acce90e57ccc3.svg" alt="\ gamma_i = \ mu = \ frac {M_T} {r} \ quad i = 1,2, ..., r"></div><br><p>  Nous r√©sumons: </p><br><p>  Avec une √©nergie de transmission infiniment grande ou un bruit infinit√©simal, rien de sp√©cial n‚Äôa besoin d‚Äô√™tre invent√©, disons-le - nous r√©partissons √©galement la puissance entre les antennes de transmission (en tenant compte du rang de la matrice des canaux). </p><br><p>  Nous raisonnons plus loin: </p><br><p>  Et que signifie le cas du SNR <img src="https://habrastorage.org/getpro/habr/post_images/60b/863/8b2/60b8638b28b303b1718d37bee487ac72.svg" alt="- \ infty">  ?  Ici nous n'entrerons m√™me pas dans les math√©matiques, nous raisonnerons logiquement: ce cas correspond soit √† un bruit infiniment grand soit √† une puissance d'√©mission nulle.  Donc, de cette fa√ßon et cela, notre syst√®me, consid√©rons, ne fonctionne pas.  Par cons√©quent, la question avec les gammas dispara√Æt automatiquement ... </p><br><p>  Ce sont parfois des questions que l'on rencontre lors d'un examen avec un professeur. </p><br><h1 id="schitaem-propusknuyu-sposobnost-nakonec-to">  Compter le d√©bit (enfin!) </h1><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">siso_capacity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(H_chan, SNR_dB)</span></span></span><span class="hljs-function">:</span></span> SNR = <span class="hljs-number"><span class="hljs-number">10</span></span>**(SNR_dB/<span class="hljs-number"><span class="hljs-number">10</span></span>) c = np.log2(<span class="hljs-number"><span class="hljs-number">1</span></span> + SNR*(np.abs(H_chan)**<span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openloop_capacity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(H_chan, SNR_dB)</span></span></span><span class="hljs-function">:</span></span> SNR = <span class="hljs-number"><span class="hljs-number">10</span></span>**(SNR_dB/<span class="hljs-number"><span class="hljs-number">10</span></span>) Mt = np.shape(H_chan)[<span class="hljs-number"><span class="hljs-number">1</span></span>] H_sq = np.dot(H_chan,np.matrix(H_chan, dtype=complex).H) lambdas = LA.eigvals(H_sq) lambdas = np.sort(lambdas)[::<span class="hljs-number"><span class="hljs-number">-1</span></span>] c = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> eig <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> lambdas: c = c + np.log2(<span class="hljs-number"><span class="hljs-number">1</span></span> + SNR*eig/Mt) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> np.real(c) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">closedloop_capacity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(H_chan, SNR_dB)</span></span></span><span class="hljs-function">:</span></span> SNR = <span class="hljs-number"><span class="hljs-number">10</span></span>**(SNR_dB/<span class="hljs-number"><span class="hljs-number">10</span></span>) Mt = np.shape(H_chan)[<span class="hljs-number"><span class="hljs-number">1</span></span>] H_sq = np.dot(H_chan,np.matrix(H_chan, dtype=complex).H) lambdas = LA.eigvals(H_sq) lambdas = np.real(np.sort(lambdas))[::<span class="hljs-number"><span class="hljs-number">-1</span></span>] c = <span class="hljs-number"><span class="hljs-number">0</span></span> gammas = waterpouring(Mt, SNR_dB, H_chan) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idx, item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(lambdas): c = c + np.log2(<span class="hljs-number"><span class="hljs-number">1</span></span> + SNR*item*gammas[idx]/Mt) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> np.real(c) Mr = <span class="hljs-number"><span class="hljs-number">4</span></span> Mt = <span class="hljs-number"><span class="hljs-number">4</span></span> H_chan = (np.random.randn(Mr,Mt) \ + <span class="hljs-number"><span class="hljs-number">1j</span></span>*np.random.randn(Mr, Mt))/np.sqrt(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-comment"><span class="hljs-comment">#Rayleigh flat fading c = openloop_capacity(H_chan, 10) print(c) c = closedloop_capacity(H_chan, 10) print(c) c = siso_capacity(H_chan[0,0], 10) print(c) &gt;&gt;&gt; 11.978909197556913 &gt;&gt;&gt; 12.342571770086721 &gt;&gt;&gt; 3.9058582578551193</span></span></code> </pre> <br><p>  Semble fonctionner.  Nous passons √† des √©valuations plus substantielles. </p><br><h2 id="ergodic-capacity">  Capacit√© ergodique </h2><br><p>  Comme le montrent les exemples ci-dessus, nous travaillons avec des processus al√©atoires.  Et, franchement, c'est une erreur de tirer des conclusions sur les processus al√©atoires dans une impl√©mentation.  M√™me si le canal est <em>constant</em> au sens statistique, une moyenne sur un ensemble suffisamment grand est n√©cessaire. </p><br><p>  Ici, le concept de <strong>capacit√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">ergodique</a></strong> nous <strong>est</strong> utile: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc3/664/e69/cc3664e69c54efa0d98127e7f65bf6ea.svg" alt="\ hat {C} = E \ left \ {C \ right \} \ qquad (9)"></div><br><p>  o√π <img src="https://habrastorage.org/getpro/habr/post_images/a73/317/bad/a73317bad2bf7d6419c448e2051efdc9.svg" alt="E \ {* \}">  d√©signe le mat.  attente (valeur attendue). </p><br><p>  Nous mod√©lisons. </p><br><pre> <code class="python hljs">Mr = <span class="hljs-number"><span class="hljs-number">4</span></span> Mt = <span class="hljs-number"><span class="hljs-number">4</span></span> counter = <span class="hljs-number"><span class="hljs-number">1000</span></span> SNR_dBs = [i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">21</span></span>)] C_MIMO_CU = np.empty((len(SNR_dBs), counter)) C_MIMO_CK = np.empty((len(SNR_dBs), counter)) C_SISO = np.empty((len(SNR_dBs), counter)) C_SIMO = np.empty((len(SNR_dBs), counter)) C_MISO_CU = np.empty((len(SNR_dBs), counter)) C_MISO_CK = np.empty((len(SNR_dBs), counter)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(counter): H_MIMO = (np.random.randn(Mr,Mt) + <span class="hljs-number"><span class="hljs-number">1j</span></span>*np.random.randn(Mr, Mt))/np.sqrt(<span class="hljs-number"><span class="hljs-number">2</span></span>) H_SISO = H_MIMO[<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>] H_SIMO = H_MIMO[:,<span class="hljs-number"><span class="hljs-number">0</span></span>].reshape(Mr,<span class="hljs-number"><span class="hljs-number">1</span></span>) H_MISO = H_MIMO[<span class="hljs-number"><span class="hljs-number">0</span></span>,:].reshape(<span class="hljs-number"><span class="hljs-number">1</span></span>,Mt) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idx, SNR_dB <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(SNR_dBs): C_MIMO_CU[idx, c] = openloop_capacity(H_MIMO, SNR_dB) C_MIMO_CK[idx, c] = closedloop_capacity(H_MIMO, SNR_dB) C_SISO[idx, c] = siso_capacity(H_SISO, SNR_dB) C_SIMO[idx, c] = openloop_capacity(H_SIMO, SNR_dB) C_MISO_CU[idx, c] = openloop_capacity(H_MISO, SNR_dB) C_MISO_CK[idx, c] = closedloop_capacity(H_MISO, SNR_dB) C_MIMO_CU_erg = np.mean(C_MIMO_CU, axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) C_MIMO_CK_erg = np.mean(C_MIMO_CK, axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) C_SISO_erg = np.mean(C_SISO, axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) C_SIMO_erg = np.mean(C_SIMO, axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) C_MISO_CU_erg = np.mean(C_MISO_CU, axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) C_MISO_CK_erg = np.mean(C_MISO_CK, axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>), dpi=<span class="hljs-number"><span class="hljs-number">600</span></span>) plt.plot(SNR_dBs, C_MIMO_CU_erg,<span class="hljs-string"><span class="hljs-string">'g-o'</span></span>, label=<span class="hljs-string"><span class="hljs-string">'$M_R=4$, $M_T=4$ (CU)'</span></span>) plt.plot(SNR_dBs, C_MIMO_CK_erg,<span class="hljs-string"><span class="hljs-string">'g-v'</span></span>, label=<span class="hljs-string"><span class="hljs-string">'$M_R=4$, $M_T=4$ (CK)'</span></span>) plt.plot(SNR_dBs, C_MISO_CU_erg, <span class="hljs-string"><span class="hljs-string">'m-o'</span></span>, label=<span class="hljs-string"><span class="hljs-string">'$M_R=1$, $M_T=4$ (CU)'</span></span>) plt.plot(SNR_dBs, C_MISO_CK_erg, <span class="hljs-string"><span class="hljs-string">'m-v'</span></span>, label=<span class="hljs-string"><span class="hljs-string">'$M_R=1$, $M_T=4$ (CK)'</span></span>) plt.plot(SNR_dBs, C_SISO_erg, <span class="hljs-string"><span class="hljs-string">'k-'</span></span>, label=<span class="hljs-string"><span class="hljs-string">'$M_R=1$, $M_T=1$'</span></span>) plt.plot(SNR_dBs, C_SIMO_erg, <span class="hljs-string"><span class="hljs-string">'c-'</span></span>, label=<span class="hljs-string"><span class="hljs-string">'$M_R=4$, $M_T=1$'</span></span>) plt.title(<span class="hljs-string"><span class="hljs-string">"Ergodic Capacity"</span></span>) plt.xlabel(<span class="hljs-string"><span class="hljs-string">'SNR (dB)'</span></span>) plt.ylabel(<span class="hljs-string"><span class="hljs-string">'Capacity (bps/Hz)'</span></span>) plt.legend() plt.minorticks_on() plt.grid(which=<span class="hljs-string"><span class="hljs-string">'major'</span></span>) plt.grid(which=<span class="hljs-string"><span class="hljs-string">'minor'</span></span>, linestyle=<span class="hljs-string"><span class="hljs-string">':'</span></span>) plt.show()</code> </pre> <br><p><img src="https://habrastorage.org/webt/5z/il/br/5zilbr1ijigrduhc3pqpzn7qsuc.png"><br>  <em>Fig.3.</em>  <em>Courbes de bande passante pour diff√©rents sch√©mas de transmission.</em>  <em>Comparer avec [1, p.</em>  <em>74].</em> </p><br><p>  Nous voyons donc que </p><br><ul><li>  on s'attend √† ce que le cas <strong>MIMO</strong> soit sup√©rieur aux autres, et avec l'augmentation du <strong>SNR, le</strong> besoin de conna√Ætre la matrice des canaux diminue (voir l'exemple avec les infinis). </li><li>  <strong>SIMO est</strong> sup√©rieur √† <strong>MISO</strong> si l'√©metteur ne <em>conna√Æt</em> pas le canal (la puissance dans MISO est partag√©e entre toutes les antennes, mais pas de mani√®re optimale) et co√Øncide avec <strong>MISO</strong> dans le cas d'un canal <em>connu</em> . </li><li>  <strong>SISO</strong> devrait fouetter la queue. </li></ul><br><p>  Et Sa Majest√© r√®gne sur le <strong>rang de la matrice des canaux</strong> , ce qui ne nous permet pas de comparer sans ambigu√Øt√© l'augmentation du nombre d'antennes avec l'augmentation de la vitesse de transmission. </p><br><p>  De telles choses. </p><br><h2 id="literatura">  Litt√©rature </h2><br><p>  (bien qu'il n'y ait qu'un seul livre, mais quel livre!) </p><br><ol><li>  Paulraj, Arogyaswami, Rohit Nabar et Dhananjay Gore. <br>  Introduction aux communications sans fil spatio-temporelles.  Cambridge University Press, 2003. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr448570/">https://habr.com/ru/post/fr448570/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr448552/index.html">ProLiant Series 100 - Le jeune fr√®re perdu</a></li>
<li><a href="../fr448558/index.html">Est-il possible de rendre des images r√©alistes sans nombres √† virgule flottante?</a></li>
<li><a href="../fr448560/index.html">Plan de transformation de l'IA: comment g√©rer une entreprise √† l'√®re de l'IA?</a></li>
<li><a href="../fr448562/index.html">Google aide la police √† localiser des appareils √† proximit√© de sc√®nes de crime √† l'aide de donn√©es de localisation</a></li>
<li><a href="../fr448564/index.html">Le premier du groupe - le premier √† tomber: √©valuation des risques de leadership dans des groupes d'animaux auto-organis√©s</a></li>
<li><a href="../fr448572/index.html">La communication humaine devient un objet de luxe</a></li>
<li><a href="../fr448574/index.html">Une t√¢che de la routine SEO: solution en 3 √©tapes</a></li>
<li><a href="../fr448576/index.html">Transistor Story Part 2: Du creuset de la guerre</a></li>
<li><a href="../fr448580/index.html">CQ CQ CQ Joyeuses F√™tes, Radio Amateur! #WorldAmateurRadioDay</a></li>
<li><a href="../fr448582/index.html">Cr√©er une calculatrice de pourboires sur Kotlin: comment √ßa marche?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>