<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游냤 游뎻 游닖 MVCC-2. Capas, Archivos, P치ginas 游 游뚽 久엂잺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La 칰ltima vez que hablamos sobre la consistencia de los datos, observamos la diferencia entre los diferentes niveles de aislamiento de transacciones a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-2. Capas, Archivos, P치ginas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/444536/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La 칰ltima vez</a> que hablamos sobre la consistencia de los datos, observamos la diferencia entre los diferentes niveles de aislamiento de transacciones a trav칠s de los ojos del usuario, y descubrimos por qu칠 es importante saberlo.  Ahora estamos comenzando a aprender c칩mo PostgreSQL implementa el aislamiento basado en instant치neas y las versiones m칰ltiples. <br><br>  En este art칤culo, veremos c칩mo se ubican f칤sicamente los datos en archivos y p치ginas.  Esto nos aleja del tema del aislamiento, pero tal digresi칩n es necesaria para comprender m치s material.  Necesitamos entender c칩mo funciona el almacenamiento de datos de bajo nivel. <br><br><h1>  Relaciones </h1><br>  Si mira dentro de las tablas e 칤ndices, resulta que est치n organizados de manera similar.  Tanto eso como otro: objetos base que contienen algunos datos que consisten en l칤neas. <br><br>  El hecho de que la tabla consta de filas est치 fuera de toda duda;  para el 칤ndice, esto es menos obvio.  Sin embargo, imagine un 치rbol B: consta de nodos que contienen valores indexados y enlaces a otros nodos o filas de la tabla.  Estos nodos pueden considerarse l칤neas de 칤ndice, de hecho, tal como est치n. <br><br>  De hecho, todav칤a hay varios objetos organizados de manera similar: secuencias (esencialmente tablas de una sola fila), vistas materializadas (esencialmente tablas que recuerdan la consulta).  Y luego est치n las vistas habituales, que por s칤 mismas no almacenan datos, pero en todos los dem치s sentidos son similares a las tablas. <br><br>  Todos estos objetos en PostgreSQL se denominan la <em>relaci칩n de</em> palabra com칰n.  La palabra es extremadamente desafortunada porque es un t칠rmino de la teor칤a relacional.  Puede establecer un paralelismo entre la relaci칩n y la tabla (vista), pero ciertamente no entre la relaci칩n y el 칤ndice.  Pero sucedi칩: las ra칤ces acad칠micas de PostgreSQL se hacen sentir.  Creo que al principio se llamaba tablas y vistas, y el resto creci칩 con el tiempo. <br><a name="habracut"></a><br>  Adem치s, por simplicidad, solo hablaremos de tablas e 칤ndices, pero el resto de las <em>relaciones</em> est치n estructuradas exactamente de la misma manera. <br><br><h1>  Capas (horquillas) y archivos </h1><br>  Por lo general, cada relaci칩n tiene varias <em>capas</em> (horquillas).  Las capas son de varios tipos y cada una de ellas contiene un cierto tipo de datos. <br><br>  Si hay una capa, al principio est치 representada por un solo <em>archivo</em> .  El nombre del archivo consta de un identificador num칠rico al que se puede agregar el final correspondiente al nombre de la capa. <br><br>  El archivo crece gradualmente y cuando su tama침o alcanza 1 GB, se crea el siguiente archivo de la misma capa (a veces, estos archivos se denominan <em>segmentos</em> ).  El n칰mero de segmento se agrega al final del nombre del archivo. <br><br>  La limitaci칩n de tama침o de archivo de 1 GB ha surgido hist칩ricamente para admitir varios sistemas de archivos, algunos de los cuales no pueden funcionar con archivos grandes.  La restricci칩n se puede cambiar al construir PostgreSQL ( <code>./configure --with-segsize</code> ). <br><br>  Por lo tanto, varios archivos pueden corresponder a una relaci칩n en un disco.  Por ejemplo, para una mesa peque침a habr치 3 de ellos. <br><br>  Todos los archivos de objetos que pertenecen a un espacio de tabla y una base de datos se colocar치n en un directorio.  Esto debe tenerse en cuenta porque los sistemas de archivos generalmente no funcionan muy bien con una gran cantidad de archivos en un directorio. <br><br>  Solo tenga en cuenta que los archivos, a su vez, se dividen en <em>p치ginas</em> (o <em>bloques</em> ), generalmente de 8 KB.  Hablaremos sobre la estructura interna de las p치ginas a continuaci칩n. <br><br><img src="https://habrastorage.org/webt/oz/ur/4z/ozur4zenihys-v-7wl5rnxyi8em.png"><br><br>  Ahora veamos los tipos de capas. <br><br>  <strong>La capa principal</strong> son los datos en s칤: la misma tabla o filas de 칤ndice.  La capa principal existe para cualquier relaci칩n (excepto para las representaciones que no contienen datos). <br><br>  Los nombres de los archivos en la capa principal consisten solo en un identificador num칠rico.  Aqu칤 hay una ruta de ejemplo al archivo de tabla que creamos la 칰ltima vez: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/41493/41496 (1 row)</code> </pre><br>  쮻e d칩nde vienen estos identificadores?  El directorio base corresponde al espacio de tabla pg_default, el siguiente subdirectorio corresponde a la base de datos y el archivo que nos interesa ya est치 en 칠l: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_database <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> datname = <span class="hljs-string"><span class="hljs-string">'test'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> oid ------- 41493 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfilenode <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfilenode ------------- 41496 (1 row)</code> </pre><br>  La ruta es relativa, se cuenta desde el directorio de datos (PGDATA).  Adem치s, casi todas las rutas en PostgreSQL se cuentan desde PGDATA.  Gracias a esto, puede transferir PGDATA de forma segura a otro lugar: no contiene nada (a menos que necesite configurar la ruta a las bibliotecas en LD_LIBRARY_PATH). <br><br>  Buscamos m치s en el sistema de archivos: <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41496</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 8192 /var/lib/postgresql/11/main/base/41493/41496</code> </pre><br>  <strong>Existe una capa de inicializaci칩n</strong> solo para tablas no registradas (creadas con UNLOGGED) y sus 칤ndices.  Dichos objetos no son diferentes de los ordinarios, excepto que las acciones con ellos no se registran en el registro de pregrabaci칩n.  Debido a esto, trabajar con ellos es m치s r치pido, pero en caso de falla es imposible restaurar los datos en un estado consistente.  Por lo tanto, al restaurar PostgreSQL simplemente elimina todas las capas de dichos objetos y escribe la capa de inicializaci칩n en el lugar de la capa principal.  El resultado es un "maniqu칤".  Hablaremos sobre el diario en detalle, pero en un ciclo diferente. <br><br>  La tabla de cuentas se registra en diario, por lo que no hay una capa de inicializaci칩n para ella.  Pero para el experimento, puede deshabilitar el registro: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNLOGGED</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/41493/41507 (1 row)</code> </pre><br>  La capacidad de habilitar y deshabilitar el diario sobre la marcha, como se puede ver en el ejemplo, implica sobrescribir datos en archivos con diferentes nombres. <br><br>  La capa de inicializaci칩n tiene el mismo nombre que la capa principal, pero con el sufijo "_init": <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_init</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 0 /var/lib/postgresql/11/main/base/41493/41507_init</code> </pre><br>  <strong>Mapa del espacio libre</strong> (mapa del espacio libre): una capa en la que hay un espacio vac칤o dentro de las p치ginas.  Este lugar cambia constantemente: cuando se agregan nuevas versiones de cadenas, disminuye, mientras que la limpieza aumenta.  El mapa de espacio libre se utiliza al insertar nuevas versiones de filas para encontrar r치pidamente una p치gina adecuada en la que se ajusten los datos que se agregar치n. <br><br>  El mapa de espacio libre tiene el sufijo "_fsm".  Pero el archivo no aparece de inmediato, sino solo si es necesario.  La forma m치s f치cil de lograr esto es limpiar la mesa (por qu칠, hablemos a su debido tiempo): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> accounts;</code> </pre><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_fsm</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 24576 /var/lib/postgresql/11/main/base/41493/41507_fsm</code> </pre><br>  <strong>Un</strong> mapa de visibilidad es una capa en la que las p치ginas que contienen solo versiones actuales de cadenas est치n marcadas con un bit.  En t칠rminos generales, esto significa que cuando una transacci칩n intenta leer una l칤nea de dicha p치gina, la l칤nea se puede mostrar sin verificar su visibilidad.  Examinaremos en detalle c칩mo sucede esto en los siguientes art칤culos. <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_vm</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 8192 /var/lib/postgresql/11/main/base/41493/41507_vm</code> </pre><br><h1>  P치ginas </h1><br>  Como ya dijimos, los archivos se dividen l칩gicamente en p치ginas. <br><br>  Por lo general, una p치gina tiene un tama침o de 8 KB.  El tama침o dentro de algunos l칤mites se puede cambiar (16 KB o 32 KB), pero solo durante el ensamblaje ( <code>./configure --with-blocksize</code> ).  La instancia ensamblada y en ejecuci칩n puede funcionar con p치ginas de un solo tama침o. <br><br>  Independientemente de a qu칠 capa pertenecen los archivos, el servidor los utiliza aproximadamente de la misma manera.  Las p치ginas se leen primero en la memoria cach칠 del b칰fer, donde los procesos pueden leerlas y modificarlas;  luego, si es necesario, las p치ginas se devuelven al disco. <br><br>  Cada p치gina tiene un marcado interno y generalmente contiene las siguientes secciones: <br><br><pre>        0 + ----------------------------------- +
           El |  rumbo |
       24 + ----------------------------------- +
           El |  matriz de punteros a cadenas de versi칩n |
    inferior + ----------------------------------- +
           El |  espacio libre |
    superior + ----------------------------------- +
           El |  versiones de fila |
  especial + ----------------------------------- +
           El |  치rea especial |
 tama침o de p치gina + ----------------------------------- +
</pre><br>  El tama침o de estas secciones es f치cil de descubrir con la extensi칩n de inspecci칩n de la p치gina de "investigaci칩n": <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pageinspect; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> lower, upper, special, pagesize <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> page_header(get_raw_page(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> lower | upper | special | pagesize -------+-------+---------+---------- 40 | 8016 | 8192 | 8192 (1 row)</code> </pre><br>  Aqu칤 miramos el <strong>t칤tulo de la</strong> primera p치gina (cero) de la tabla.  Adem치s del tama침o de las 치reas restantes, el encabezado contiene otra informaci칩n sobre la p치gina, pero a칰n no nos interesa. <br><br>  Al final de la p치gina hay un <strong>치rea especial</strong> , en nuestro caso, vac칤a.  Se usa solo para 칤ndices, y luego no para todos.  El "fondo" aqu칤 corresponde a la imagen;  quiz치s ser칤a m치s correcto decir "en direcciones altas". <br><br>  A continuaci칩n del 치rea especial est치n <strong>las versiones de fila</strong> : los mismos datos que almacenamos en la tabla, m치s informaci칩n general. <br><br>  En la parte superior de la p치gina, inmediatamente despu칠s del encabezado, se encuentra la tabla de contenido: una <strong>matriz de punteros</strong> a la versi칩n de las l칤neas disponibles en la p치gina. <br><br>  Entre las versiones de l칤neas y punteros puede haber <strong>espacio libre</strong> (que est치 marcado en el mapa de espacio libre).  Tenga en cuenta que no hay fragmentaci칩n dentro de la p치gina, todo el espacio libre siempre est치 representado por un fragmento. <br><br><h2>  Punteros </h2><br>  쯇or qu칠 son necesarios los punteros a las versiones de cadena?  El hecho es que las filas de 칤ndice deben referirse de alguna manera a la versi칩n de las filas en la tabla.  Est치 claro que el enlace debe contener el n칰mero de archivo, el n칰mero de p치gina en el archivo y alguna indicaci칩n de la versi칩n de la l칤nea.  Un desplazamiento desde el comienzo de la p치gina podr칤a usarse como una indicaci칩n, pero esto es inconveniente.  No podr칤amos mover la versi칩n de la l칤nea dentro de la p치gina porque romper칤a los enlaces existentes.  Y esto conducir칤a a la fragmentaci칩n del espacio dentro de las p치ginas y otras consecuencias desagradables.  Por lo tanto, el 칤ndice se refiere al n칰mero de 칤ndice y el puntero se refiere a la posici칩n actual de la versi칩n de fila en la p치gina.  Resulta el direccionamiento indirecto. <br><br>  Cada puntero ocupa exactamente 4 bytes y contiene: <br><br><ul><li>  enlace a la versi칩n de la cadena; </li><li>  la longitud de esta versi칩n de la cadena; </li><li>  varios bits que determinan el estado de la versi칩n de una cadena. </li></ul><br><h2>  Formato de datos </h2><br>  El formato de datos en el disco coincide completamente con la representaci칩n de los datos en la RAM.  La p치gina se lee en la memoria cach칠 del b칰fer "tal cual", sin ninguna transformaci칩n.  Por lo tanto, los archivos de datos de una plataforma son incompatibles con otras plataformas. <br><br>  Por ejemplo, en la arquitectura x86, el orden de bytes se adopta del menos significativo al m치s alto (little-endian), z / Architecture usa el orden inverso (big-endian), y en ARM el orden de cambio. <br><br>  Muchas arquitecturas proporcionan alineaci칩n de datos a trav칠s de los l칤mites de palabras de m치quina.  Por ejemplo, en un sistema x86 de 32 bits, los enteros (tipo entero, ocupa 4 bytes) se alinear치n en el borde de las palabras de 4 bytes, as칤 como los n칰meros de coma flotante de precisi칩n doble (tipo de precisi칩n doble, 8 bytes).  Y en un sistema de 64 bits, los valores dobles se alinear치n en el borde de las palabras de 8 bytes.  Esta es otra raz칩n de incompatibilidad. <br><br>  Debido a la alineaci칩n, el tama침o de la fila de la tabla depende del orden de los campos.  Por lo general, este efecto no es muy notable, pero en algunos casos puede conducir a un aumento significativo de tama침o.  Por ejemplo, si coloca los campos char (1) y entero mezclados, generalmente se perder치n 3 bytes entre ellos.  Puede ver m치s sobre esto en la presentaci칩n de Nikolai Shaplov " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">What's Inside It</a> ". <br><br><h1>  Versiones de cadenas y tostadas </h1><br>  Acerca de c칩mo se organizan las versiones de cadenas desde adentro, hablaremos en detalle la pr칩xima vez.  Hasta ahora, lo 칰nico importante para nosotros es que cada versi칩n debe caber completamente en una p치gina: PostgreSQL no proporciona una forma de "continuar" la l칤nea en la p치gina siguiente.  En cambio, se utiliza una tecnolog칤a llamada TOAST (T칠cnica de almacenamiento de atributos de gran tama침o).  El nombre en s칤 sugiere que la cadena se puede cortar en tostadas. <br><br>  Hablando en serio, TOAST involucra varias estrategias.  Los valores de los atributos "largos" se pueden enviar a una tabla de servicio separada, previamente cortada en peque침as tostadas.  Otra opci칩n es comprimir el valor para que la versi칩n de la fila todav칤a se ajuste a una p치gina de tabla normal.  Y es posible tanto eso como otro: al principio comprimir, y solo luego cortar y enviar. <br><br>  Para cada tabla principal, si es necesario, se crea una tabla TOAST separada (pero una para todos los atributos).  La necesidad est치 determinada por la presencia de atributos potencialmente largos en la tabla.  Por ejemplo, si una tabla tiene una columna de tipo num칠rico o texto, se crear치 una tabla TOAST de inmediato, incluso si no se utilizan valores largos. <br><br>  Dado que la tabla TOAST es esencialmente una tabla normal, todav칤a tiene el mismo conjunto de capas.  Y esto duplica la cantidad de archivos que "sirven" la tabla. <br><br>  Inicialmente, las estrategias est치n determinadas por los tipos de datos de columna.  Puede verlos con el comando <code>\d+</code> en psql, pero como tambi칠n muestra mucha otra informaci칩n, utilizaremos la solicitud en el directorio del sistema: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> attname, atttypid::<span class="hljs-type"><span class="hljs-type">regtype</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> attstorage <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'p'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'plain'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'e'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'external'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'m'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'main'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'x'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'extended'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_attribute <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> attrelid = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attnum &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><pre> <code class="plaintext hljs"> attname | atttypid | storage ---------+----------+---------- id | integer | plain number | text | extended client | text | extended amount | numeric | main (4 rows)</code> </pre><br>  Los nombres de las estrategias tienen los siguientes significados: <br><br><ul><li>  plain - TOAST no se usa (se usa para tipos de datos obviamente "cortos", como el entero); </li><li>  extendido: tanto la compresi칩n como el almacenamiento en una tabla TOAST separada est치n permitidos; </li><li>  externo: los valores largos se almacenan en la tabla TOAST sin comprimir; </li><li>  main - los valores largos se comprimen primero y solo en la tabla TOAST si la compresi칩n no ayud칩. </li></ul><br>  En t칠rminos generales, el algoritmo es el siguiente.  PostgreSQL quiere que al menos 4 l칤neas quepan en una p치gina.  Por lo tanto, si el tama침o de la l칤nea excede la cuarta parte de la p치gina, teniendo en cuenta el encabezado (con una p치gina normal de 8K, esto es 2040 bytes), se debe aplicar TOAST a parte de los valores.  Actuamos en el orden descrito a continuaci칩n y nos detenemos tan pronto como la l칤nea deja de exceder el umbral: <br><br><ol><li>  Primero, clasificamos los atributos con estrategias externas y extendidas, pasando del m치s largo al m치s corto.  Los atributos extendidos se comprimen (si esto tiene un efecto) y, si el valor en s칤 excede un cuarto de la p치gina, se env칤a inmediatamente a la tabla TOAST.  Los atributos externos se manejan de la misma manera, pero no se comprimen. </li><li>  Si despu칠s de la primera pasada la versi칩n de la fila a칰n no se ajusta, enviamos los atributos restantes con las estrategias externas y extendidas a la tabla TOAST. </li><li>  Si esto tampoco ayuda, intente comprimir los atributos con la estrategia principal, mientras los deja en la p치gina de la tabla. </li><li>  Y solo si despu칠s de eso la fila a칰n no es lo suficientemente corta, los atributos principales se env칤an a la tabla TOAST. </li></ol><br>  A veces puede ser 칰til cambiar la estrategia para algunas columnas.  Por ejemplo, si se sabe de antemano que los datos de la columna no est치n comprimidos, puede establecer una estrategia externa para ello; esto ahorrar치 en intentos de compresi칩n in칰tiles.  Esto se hace de la siguiente manera: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> number <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STORAGE external</span></span>;</code> </pre><br>  Repitiendo la solicitud, obtenemos: <br><br><pre> <code class="plaintext hljs"> attname | atttypid | storage ---------+----------+---------- id | integer | plain number | text | external client | text | extended amount | numeric | main</code> </pre><br>  Las tablas e 칤ndices TOAST se encuentran en un esquema pg_toast separado y, por lo tanto, generalmente no son visibles.  Para las tablas temporales, se utiliza el esquema pg_toast_temp_ <em>N</em> , similar al pg_temp_ <em>N.</em> habitual <em>.</em> <br><br>  Por supuesto, si lo desea, nadie se molesta en echar un vistazo a la mec치nica interna del proceso.  Digamos que hay tres atributos potencialmente largos en la tabla de cuentas, por lo que debe ser una tabla TOAST.  Aqu칤 esta: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relnamespace::<span class="hljs-type"><span class="hljs-type">regnamespace</span></span>, relname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> reltoastrelid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span> );</code> </pre><pre> <code class="plaintext hljs"> relnamespace | relname --------------+---------------- pg_toast | pg_toast_33953 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \d+ pg_toast.pg_toast_33953</code> </pre><pre> <code class="plaintext hljs">TOAST table "pg_toast.pg_toast_33953" Column | Type | Storage ------------+---------+--------- chunk_id | oid | plain chunk_seq | integer | plain chunk_data | bytea | plain</code> </pre><br>  Es l칩gico que para las "tostadas" en las que se corta la l칤nea, se aplica la estrategia simple: la TOSTADA del segundo nivel no existe. <br><br>  El 칤ndice PostgreSQL se oculta con m치s cuidado, pero tambi칠n es f치cil de encontrar: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> indexrelid::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_index <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> indrelid = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'pg_toast_33953'</span></span> );</code> </pre><pre> <code class="plaintext hljs"> indexrelid ------------------------------- pg_toast.pg_toast_33953_index (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \d pg_toast.pg_toast_33953_index</code> </pre><pre> <code class="plaintext hljs">Unlogged index "pg_toast.pg_toast_33953_index" Column | Type | Key? | Definition -----------+---------+------+------------ chunk_id | oid | yes | chunk_id chunk_seq | integer | yes | chunk_seq primary key, btree, for table "pg_toast.pg_toast_33953"</code> </pre><br>  La columna del cliente utiliza la estrategia extendida: los valores en ella se comprimir치n.  Comprobar: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> client = repeat(<span class="hljs-string"><span class="hljs-string">'A'</span></span>,<span class="hljs-number"><span class="hljs-number">3000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_toast.pg_toast_33953;</code> </pre><pre> <code class="plaintext hljs"> chunk_id | chunk_seq | chunk_data ----------+-----------+------------ (0 rows)</code> </pre><br>  No hay nada en la tabla TOAST: los caracteres que se repiten se comprimen perfectamente y luego el valor cabe en una p치gina de tabla normal. <br><br>  Ahora deje que el nombre del cliente consista en caracteres aleatorios: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> client = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> string_agg( chr(trunc(<span class="hljs-number"><span class="hljs-number">65</span></span>+random()*<span class="hljs-number"><span class="hljs-number">26</span></span>)::<span class="hljs-type"><span class="hljs-type">integer</span></span>), <span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3000</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RETURNING</span></span> left(client,<span class="hljs-number"><span class="hljs-number">10</span></span>) || <span class="hljs-string"><span class="hljs-string">'...'</span></span> || right(client,<span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ------------------------- TCKGKZZSLI...RHQIOLWRRX (1 row)</code> </pre><br>  Esta secuencia no se puede comprimir y cae en la tabla TOAST: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> chunk_id, chunk_seq, length(chunk_data), left(encode(chunk_data,<span class="hljs-string"><span class="hljs-string">'escape'</span></span>)::<span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) || <span class="hljs-string"><span class="hljs-string">'...'</span></span> || right(encode(chunk_data,<span class="hljs-string"><span class="hljs-string">'escape'</span></span>)::<span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_toast.pg_toast_33953;</code> </pre><pre> <code class="plaintext hljs"> chunk_id | chunk_seq | length | ?column? ----------+-----------+--------+------------------------- 34000 | 0 | 2000 | TCKGKZZSLI...ZIPFLOXDIW 34000 | 1 | 1000 | DDXNNBQQYH...RHQIOLWRRX (2 rows)</code> </pre><br>  Como puede ver, los datos se cortan en fragmentos de 2000 bytes. <br><br>  Al acceder a un valor "largo", PostgreSQL autom치ticamente, transparente para la aplicaci칩n, restaura el valor original y lo devuelve al cliente. <br><br>  Por supuesto, se gastan muchos recursos en compresi칩n en rodajas y recuperaci칩n posterior.  Por lo tanto, almacenar datos voluminosos en PostgreSQL no es una buena idea, especialmente si se usa activamente y no se requiere l칩gica transaccional para ellos (como un ejemplo: originales escaneados de documentos contables).  Una alternativa m치s rentable podr칤a ser almacenar dichos datos en el sistema de archivos y, en el DBMS, los nombres de los archivos correspondientes. <br><br>  Una tabla TOAST se usa solo cuando se refiere a un valor "largo".  Adem치s, la tabla de tostado tiene su propio control de versiones: si la actualizaci칩n de datos no afecta el valor "largo", la nueva versi칩n de la fila se referir치 al mismo valor en la tabla de TOAST; esto ahorra espacio. <br><br>  Tenga en cuenta que TOAST solo funciona para tablas, pero no para 칤ndices.  Esto impone un l칤mite en el tama침o de las claves indexadas. <br><blockquote>  Puede leer m치s sobre la organizaci칩n interna de datos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en la documentaci칩n</a> . <br></blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Continuar치</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/444536/">https://habr.com/ru/post/444536/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444524/index.html">Lambdas: de C ++ 11 a C ++ 20. Parte 1</a></li>
<li><a href="../444526/index.html">Pila DOTS: C ++ y C #</a></li>
<li><a href="../444528/index.html">Situaci칩n: Jap칩n puede limitar la descarga de contenido de la red: entendemos y discutimos</a></li>
<li><a href="../444530/index.html">El futuro de la inyecci칩n de dependencia en Android</a></li>
<li><a href="../444534/index.html">Escaneo de vulnerabilidades y desarrollo seguro. Parte 1</a></li>
<li><a href="../444540/index.html">Intel est치 listo para comenzar la producci칩n de memoria MRAM</a></li>
<li><a href="../444542/index.html">Transmisi칩n en vivo y calendario de conferencias para SmartMail Conf: Machine Learning</a></li>
<li><a href="../444544/index.html">Algo sobre centros de datos distribuidos para empresas</a></li>
<li><a href="../444546/index.html">쮺칩mo y por qu칠 trabajar m치s lento? El m칠todo de Sergey Korolev</a></li>
<li><a href="../444548/index.html">Experiencia personal: c칩mo participamos en la promoci칩n de startups hispanas en Am칠rica Latina</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>