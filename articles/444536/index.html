<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐶 🕕 📯 MVCC-2. Capas, Archivos, Páginas 🧒 🚦 ⛴️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La última vez que hablamos sobre la consistencia de los datos, observamos la diferencia entre los diferentes niveles de aislamiento de transacciones a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-2. Capas, Archivos, Páginas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/444536/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La última vez</a> que hablamos sobre la consistencia de los datos, observamos la diferencia entre los diferentes niveles de aislamiento de transacciones a través de los ojos del usuario, y descubrimos por qué es importante saberlo.  Ahora estamos comenzando a aprender cómo PostgreSQL implementa el aislamiento basado en instantáneas y las versiones múltiples. <br><br>  En este artículo, veremos cómo se ubican físicamente los datos en archivos y páginas.  Esto nos aleja del tema del aislamiento, pero tal digresión es necesaria para comprender más material.  Necesitamos entender cómo funciona el almacenamiento de datos de bajo nivel. <br><br><h1>  Relaciones </h1><br>  Si mira dentro de las tablas e índices, resulta que están organizados de manera similar.  Tanto eso como otro: objetos base que contienen algunos datos que consisten en líneas. <br><br>  El hecho de que la tabla consta de filas está fuera de toda duda;  para el índice, esto es menos obvio.  Sin embargo, imagine un árbol B: consta de nodos que contienen valores indexados y enlaces a otros nodos o filas de la tabla.  Estos nodos pueden considerarse líneas de índice, de hecho, tal como están. <br><br>  De hecho, todavía hay varios objetos organizados de manera similar: secuencias (esencialmente tablas de una sola fila), vistas materializadas (esencialmente tablas que recuerdan la consulta).  Y luego están las vistas habituales, que por sí mismas no almacenan datos, pero en todos los demás sentidos son similares a las tablas. <br><br>  Todos estos objetos en PostgreSQL se denominan la <em>relación de</em> palabra común.  La palabra es extremadamente desafortunada porque es un término de la teoría relacional.  Puede establecer un paralelismo entre la relación y la tabla (vista), pero ciertamente no entre la relación y el índice.  Pero sucedió: las raíces académicas de PostgreSQL se hacen sentir.  Creo que al principio se llamaba tablas y vistas, y el resto creció con el tiempo. <br><a name="habracut"></a><br>  Además, por simplicidad, solo hablaremos de tablas e índices, pero el resto de las <em>relaciones</em> están estructuradas exactamente de la misma manera. <br><br><h1>  Capas (horquillas) y archivos </h1><br>  Por lo general, cada relación tiene varias <em>capas</em> (horquillas).  Las capas son de varios tipos y cada una de ellas contiene un cierto tipo de datos. <br><br>  Si hay una capa, al principio está representada por un solo <em>archivo</em> .  El nombre del archivo consta de un identificador numérico al que se puede agregar el final correspondiente al nombre de la capa. <br><br>  El archivo crece gradualmente y cuando su tamaño alcanza 1 GB, se crea el siguiente archivo de la misma capa (a veces, estos archivos se denominan <em>segmentos</em> ).  El número de segmento se agrega al final del nombre del archivo. <br><br>  La limitación de tamaño de archivo de 1 GB ha surgido históricamente para admitir varios sistemas de archivos, algunos de los cuales no pueden funcionar con archivos grandes.  La restricción se puede cambiar al construir PostgreSQL ( <code>./configure --with-segsize</code> ). <br><br>  Por lo tanto, varios archivos pueden corresponder a una relación en un disco.  Por ejemplo, para una mesa pequeña habrá 3 de ellos. <br><br>  Todos los archivos de objetos que pertenecen a un espacio de tabla y una base de datos se colocarán en un directorio.  Esto debe tenerse en cuenta porque los sistemas de archivos generalmente no funcionan muy bien con una gran cantidad de archivos en un directorio. <br><br>  Solo tenga en cuenta que los archivos, a su vez, se dividen en <em>páginas</em> (o <em>bloques</em> ), generalmente de 8 KB.  Hablaremos sobre la estructura interna de las páginas a continuación. <br><br><img src="https://habrastorage.org/webt/oz/ur/4z/ozur4zenihys-v-7wl5rnxyi8em.png"><br><br>  Ahora veamos los tipos de capas. <br><br>  <strong>La capa principal</strong> son los datos en sí: la misma tabla o filas de índice.  La capa principal existe para cualquier relación (excepto para las representaciones que no contienen datos). <br><br>  Los nombres de los archivos en la capa principal consisten solo en un identificador numérico.  Aquí hay una ruta de ejemplo al archivo de tabla que creamos la última vez: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/41493/41496 (1 row)</code> </pre><br>  ¿De dónde vienen estos identificadores?  El directorio base corresponde al espacio de tabla pg_default, el siguiente subdirectorio corresponde a la base de datos y el archivo que nos interesa ya está en él: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_database <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> datname = <span class="hljs-string"><span class="hljs-string">'test'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> oid ------- 41493 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfilenode <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfilenode ------------- 41496 (1 row)</code> </pre><br>  La ruta es relativa, se cuenta desde el directorio de datos (PGDATA).  Además, casi todas las rutas en PostgreSQL se cuentan desde PGDATA.  Gracias a esto, puede transferir PGDATA de forma segura a otro lugar: no contiene nada (a menos que necesite configurar la ruta a las bibliotecas en LD_LIBRARY_PATH). <br><br>  Buscamos más en el sistema de archivos: <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41496</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 8192 /var/lib/postgresql/11/main/base/41493/41496</code> </pre><br>  <strong>Existe una capa de inicialización</strong> solo para tablas no registradas (creadas con UNLOGGED) y sus índices.  Dichos objetos no son diferentes de los ordinarios, excepto que las acciones con ellos no se registran en el registro de pregrabación.  Debido a esto, trabajar con ellos es más rápido, pero en caso de falla es imposible restaurar los datos en un estado consistente.  Por lo tanto, al restaurar PostgreSQL simplemente elimina todas las capas de dichos objetos y escribe la capa de inicialización en el lugar de la capa principal.  El resultado es un "maniquí".  Hablaremos sobre el diario en detalle, pero en un ciclo diferente. <br><br>  La tabla de cuentas se registra en diario, por lo que no hay una capa de inicialización para ella.  Pero para el experimento, puede deshabilitar el registro: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNLOGGED</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/41493/41507 (1 row)</code> </pre><br>  La capacidad de habilitar y deshabilitar el diario sobre la marcha, como se puede ver en el ejemplo, implica sobrescribir datos en archivos con diferentes nombres. <br><br>  La capa de inicialización tiene el mismo nombre que la capa principal, pero con el sufijo "_init": <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_init</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 0 /var/lib/postgresql/11/main/base/41493/41507_init</code> </pre><br>  <strong>Mapa del espacio libre</strong> (mapa del espacio libre): una capa en la que hay un espacio vacío dentro de las páginas.  Este lugar cambia constantemente: cuando se agregan nuevas versiones de cadenas, disminuye, mientras que la limpieza aumenta.  El mapa de espacio libre se utiliza al insertar nuevas versiones de filas para encontrar rápidamente una página adecuada en la que se ajusten los datos que se agregarán. <br><br>  El mapa de espacio libre tiene el sufijo "_fsm".  Pero el archivo no aparece de inmediato, sino solo si es necesario.  La forma más fácil de lograr esto es limpiar la mesa (por qué, hablemos a su debido tiempo): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> accounts;</code> </pre><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_fsm</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 24576 /var/lib/postgresql/11/main/base/41493/41507_fsm</code> </pre><br>  <strong>Un</strong> mapa de visibilidad es una capa en la que las páginas que contienen solo versiones actuales de cadenas están marcadas con un bit.  En términos generales, esto significa que cuando una transacción intenta leer una línea de dicha página, la línea se puede mostrar sin verificar su visibilidad.  Examinaremos en detalle cómo sucede esto en los siguientes artículos. <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_vm</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 8192 /var/lib/postgresql/11/main/base/41493/41507_vm</code> </pre><br><h1>  Páginas </h1><br>  Como ya dijimos, los archivos se dividen lógicamente en páginas. <br><br>  Por lo general, una página tiene un tamaño de 8 KB.  El tamaño dentro de algunos límites se puede cambiar (16 KB o 32 KB), pero solo durante el ensamblaje ( <code>./configure --with-blocksize</code> ).  La instancia ensamblada y en ejecución puede funcionar con páginas de un solo tamaño. <br><br>  Independientemente de a qué capa pertenecen los archivos, el servidor los utiliza aproximadamente de la misma manera.  Las páginas se leen primero en la memoria caché del búfer, donde los procesos pueden leerlas y modificarlas;  luego, si es necesario, las páginas se devuelven al disco. <br><br>  Cada página tiene un marcado interno y generalmente contiene las siguientes secciones: <br><br><pre>        0 + ----------------------------------- +
           El |  rumbo |
       24 + ----------------------------------- +
           El |  matriz de punteros a cadenas de versión |
    inferior + ----------------------------------- +
           El |  espacio libre |
    superior + ----------------------------------- +
           El |  versiones de fila |
  especial + ----------------------------------- +
           El |  área especial |
 tamaño de página + ----------------------------------- +
</pre><br>  El tamaño de estas secciones es fácil de descubrir con la extensión de inspección de la página de "investigación": <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pageinspect; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> lower, upper, special, pagesize <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> page_header(get_raw_page(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> lower | upper | special | pagesize -------+-------+---------+---------- 40 | 8016 | 8192 | 8192 (1 row)</code> </pre><br>  Aquí miramos el <strong>título de la</strong> primera página (cero) de la tabla.  Además del tamaño de las áreas restantes, el encabezado contiene otra información sobre la página, pero aún no nos interesa. <br><br>  Al final de la página hay un <strong>área especial</strong> , en nuestro caso, vacía.  Se usa solo para índices, y luego no para todos.  El "fondo" aquí corresponde a la imagen;  quizás sería más correcto decir "en direcciones altas". <br><br>  A continuación del área especial están <strong>las versiones de fila</strong> : los mismos datos que almacenamos en la tabla, más información general. <br><br>  En la parte superior de la página, inmediatamente después del encabezado, se encuentra la tabla de contenido: una <strong>matriz de punteros</strong> a la versión de las líneas disponibles en la página. <br><br>  Entre las versiones de líneas y punteros puede haber <strong>espacio libre</strong> (que está marcado en el mapa de espacio libre).  Tenga en cuenta que no hay fragmentación dentro de la página, todo el espacio libre siempre está representado por un fragmento. <br><br><h2>  Punteros </h2><br>  ¿Por qué son necesarios los punteros a las versiones de cadena?  El hecho es que las filas de índice deben referirse de alguna manera a la versión de las filas en la tabla.  Está claro que el enlace debe contener el número de archivo, el número de página en el archivo y alguna indicación de la versión de la línea.  Un desplazamiento desde el comienzo de la página podría usarse como una indicación, pero esto es inconveniente.  No podríamos mover la versión de la línea dentro de la página porque rompería los enlaces existentes.  Y esto conduciría a la fragmentación del espacio dentro de las páginas y otras consecuencias desagradables.  Por lo tanto, el índice se refiere al número de índice y el puntero se refiere a la posición actual de la versión de fila en la página.  Resulta el direccionamiento indirecto. <br><br>  Cada puntero ocupa exactamente 4 bytes y contiene: <br><br><ul><li>  enlace a la versión de la cadena; </li><li>  la longitud de esta versión de la cadena; </li><li>  varios bits que determinan el estado de la versión de una cadena. </li></ul><br><h2>  Formato de datos </h2><br>  El formato de datos en el disco coincide completamente con la representación de los datos en la RAM.  La página se lee en la memoria caché del búfer "tal cual", sin ninguna transformación.  Por lo tanto, los archivos de datos de una plataforma son incompatibles con otras plataformas. <br><br>  Por ejemplo, en la arquitectura x86, el orden de bytes se adopta del menos significativo al más alto (little-endian), z / Architecture usa el orden inverso (big-endian), y en ARM el orden de cambio. <br><br>  Muchas arquitecturas proporcionan alineación de datos a través de los límites de palabras de máquina.  Por ejemplo, en un sistema x86 de 32 bits, los enteros (tipo entero, ocupa 4 bytes) se alinearán en el borde de las palabras de 4 bytes, así como los números de coma flotante de precisión doble (tipo de precisión doble, 8 bytes).  Y en un sistema de 64 bits, los valores dobles se alinearán en el borde de las palabras de 8 bytes.  Esta es otra razón de incompatibilidad. <br><br>  Debido a la alineación, el tamaño de la fila de la tabla depende del orden de los campos.  Por lo general, este efecto no es muy notable, pero en algunos casos puede conducir a un aumento significativo de tamaño.  Por ejemplo, si coloca los campos char (1) y entero mezclados, generalmente se perderán 3 bytes entre ellos.  Puede ver más sobre esto en la presentación de Nikolai Shaplov " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">What's Inside It</a> ". <br><br><h1>  Versiones de cadenas y tostadas </h1><br>  Acerca de cómo se organizan las versiones de cadenas desde adentro, hablaremos en detalle la próxima vez.  Hasta ahora, lo único importante para nosotros es que cada versión debe caber completamente en una página: PostgreSQL no proporciona una forma de "continuar" la línea en la página siguiente.  En cambio, se utiliza una tecnología llamada TOAST (Técnica de almacenamiento de atributos de gran tamaño).  El nombre en sí sugiere que la cadena se puede cortar en tostadas. <br><br>  Hablando en serio, TOAST involucra varias estrategias.  Los valores de los atributos "largos" se pueden enviar a una tabla de servicio separada, previamente cortada en pequeñas tostadas.  Otra opción es comprimir el valor para que la versión de la fila todavía se ajuste a una página de tabla normal.  Y es posible tanto eso como otro: al principio comprimir, y solo luego cortar y enviar. <br><br>  Para cada tabla principal, si es necesario, se crea una tabla TOAST separada (pero una para todos los atributos).  La necesidad está determinada por la presencia de atributos potencialmente largos en la tabla.  Por ejemplo, si una tabla tiene una columna de tipo numérico o texto, se creará una tabla TOAST de inmediato, incluso si no se utilizan valores largos. <br><br>  Dado que la tabla TOAST es esencialmente una tabla normal, todavía tiene el mismo conjunto de capas.  Y esto duplica la cantidad de archivos que "sirven" la tabla. <br><br>  Inicialmente, las estrategias están determinadas por los tipos de datos de columna.  Puede verlos con el comando <code>\d+</code> en psql, pero como también muestra mucha otra información, utilizaremos la solicitud en el directorio del sistema: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> attname, atttypid::<span class="hljs-type"><span class="hljs-type">regtype</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> attstorage <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'p'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'plain'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'e'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'external'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'m'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'main'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'x'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'extended'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_attribute <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> attrelid = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attnum &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><pre> <code class="plaintext hljs"> attname | atttypid | storage ---------+----------+---------- id | integer | plain number | text | extended client | text | extended amount | numeric | main (4 rows)</code> </pre><br>  Los nombres de las estrategias tienen los siguientes significados: <br><br><ul><li>  plain - TOAST no se usa (se usa para tipos de datos obviamente "cortos", como el entero); </li><li>  extendido: tanto la compresión como el almacenamiento en una tabla TOAST separada están permitidos; </li><li>  externo: los valores largos se almacenan en la tabla TOAST sin comprimir; </li><li>  main - los valores largos se comprimen primero y solo en la tabla TOAST si la compresión no ayudó. </li></ul><br>  En términos generales, el algoritmo es el siguiente.  PostgreSQL quiere que al menos 4 líneas quepan en una página.  Por lo tanto, si el tamaño de la línea excede la cuarta parte de la página, teniendo en cuenta el encabezado (con una página normal de 8K, esto es 2040 bytes), se debe aplicar TOAST a parte de los valores.  Actuamos en el orden descrito a continuación y nos detenemos tan pronto como la línea deja de exceder el umbral: <br><br><ol><li>  Primero, clasificamos los atributos con estrategias externas y extendidas, pasando del más largo al más corto.  Los atributos extendidos se comprimen (si esto tiene un efecto) y, si el valor en sí excede un cuarto de la página, se envía inmediatamente a la tabla TOAST.  Los atributos externos se manejan de la misma manera, pero no se comprimen. </li><li>  Si después de la primera pasada la versión de la fila aún no se ajusta, enviamos los atributos restantes con las estrategias externas y extendidas a la tabla TOAST. </li><li>  Si esto tampoco ayuda, intente comprimir los atributos con la estrategia principal, mientras los deja en la página de la tabla. </li><li>  Y solo si después de eso la fila aún no es lo suficientemente corta, los atributos principales se envían a la tabla TOAST. </li></ol><br>  A veces puede ser útil cambiar la estrategia para algunas columnas.  Por ejemplo, si se sabe de antemano que los datos de la columna no están comprimidos, puede establecer una estrategia externa para ello; esto ahorrará en intentos de compresión inútiles.  Esto se hace de la siguiente manera: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> number <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STORAGE external</span></span>;</code> </pre><br>  Repitiendo la solicitud, obtenemos: <br><br><pre> <code class="plaintext hljs"> attname | atttypid | storage ---------+----------+---------- id | integer | plain number | text | external client | text | extended amount | numeric | main</code> </pre><br>  Las tablas e índices TOAST se encuentran en un esquema pg_toast separado y, por lo tanto, generalmente no son visibles.  Para las tablas temporales, se utiliza el esquema pg_toast_temp_ <em>N</em> , similar al pg_temp_ <em>N.</em> habitual <em>.</em> <br><br>  Por supuesto, si lo desea, nadie se molesta en echar un vistazo a la mecánica interna del proceso.  Digamos que hay tres atributos potencialmente largos en la tabla de cuentas, por lo que debe ser una tabla TOAST.  Aquí esta: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relnamespace::<span class="hljs-type"><span class="hljs-type">regnamespace</span></span>, relname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> reltoastrelid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span> );</code> </pre><pre> <code class="plaintext hljs"> relnamespace | relname --------------+---------------- pg_toast | pg_toast_33953 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \d+ pg_toast.pg_toast_33953</code> </pre><pre> <code class="plaintext hljs">TOAST table "pg_toast.pg_toast_33953" Column | Type | Storage ------------+---------+--------- chunk_id | oid | plain chunk_seq | integer | plain chunk_data | bytea | plain</code> </pre><br>  Es lógico que para las "tostadas" en las que se corta la línea, se aplica la estrategia simple: la TOSTADA del segundo nivel no existe. <br><br>  El índice PostgreSQL se oculta con más cuidado, pero también es fácil de encontrar: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> indexrelid::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_index <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> indrelid = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'pg_toast_33953'</span></span> );</code> </pre><pre> <code class="plaintext hljs"> indexrelid ------------------------------- pg_toast.pg_toast_33953_index (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \d pg_toast.pg_toast_33953_index</code> </pre><pre> <code class="plaintext hljs">Unlogged index "pg_toast.pg_toast_33953_index" Column | Type | Key? | Definition -----------+---------+------+------------ chunk_id | oid | yes | chunk_id chunk_seq | integer | yes | chunk_seq primary key, btree, for table "pg_toast.pg_toast_33953"</code> </pre><br>  La columna del cliente utiliza la estrategia extendida: los valores en ella se comprimirán.  Comprobar: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> client = repeat(<span class="hljs-string"><span class="hljs-string">'A'</span></span>,<span class="hljs-number"><span class="hljs-number">3000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_toast.pg_toast_33953;</code> </pre><pre> <code class="plaintext hljs"> chunk_id | chunk_seq | chunk_data ----------+-----------+------------ (0 rows)</code> </pre><br>  No hay nada en la tabla TOAST: los caracteres que se repiten se comprimen perfectamente y luego el valor cabe en una página de tabla normal. <br><br>  Ahora deje que el nombre del cliente consista en caracteres aleatorios: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> client = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> string_agg( chr(trunc(<span class="hljs-number"><span class="hljs-number">65</span></span>+random()*<span class="hljs-number"><span class="hljs-number">26</span></span>)::<span class="hljs-type"><span class="hljs-type">integer</span></span>), <span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3000</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RETURNING</span></span> left(client,<span class="hljs-number"><span class="hljs-number">10</span></span>) || <span class="hljs-string"><span class="hljs-string">'...'</span></span> || right(client,<span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ------------------------- TCKGKZZSLI...RHQIOLWRRX (1 row)</code> </pre><br>  Esta secuencia no se puede comprimir y cae en la tabla TOAST: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> chunk_id, chunk_seq, length(chunk_data), left(encode(chunk_data,<span class="hljs-string"><span class="hljs-string">'escape'</span></span>)::<span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) || <span class="hljs-string"><span class="hljs-string">'...'</span></span> || right(encode(chunk_data,<span class="hljs-string"><span class="hljs-string">'escape'</span></span>)::<span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_toast.pg_toast_33953;</code> </pre><pre> <code class="plaintext hljs"> chunk_id | chunk_seq | length | ?column? ----------+-----------+--------+------------------------- 34000 | 0 | 2000 | TCKGKZZSLI...ZIPFLOXDIW 34000 | 1 | 1000 | DDXNNBQQYH...RHQIOLWRRX (2 rows)</code> </pre><br>  Como puede ver, los datos se cortan en fragmentos de 2000 bytes. <br><br>  Al acceder a un valor "largo", PostgreSQL automáticamente, transparente para la aplicación, restaura el valor original y lo devuelve al cliente. <br><br>  Por supuesto, se gastan muchos recursos en compresión en rodajas y recuperación posterior.  Por lo tanto, almacenar datos voluminosos en PostgreSQL no es una buena idea, especialmente si se usa activamente y no se requiere lógica transaccional para ellos (como un ejemplo: originales escaneados de documentos contables).  Una alternativa más rentable podría ser almacenar dichos datos en el sistema de archivos y, en el DBMS, los nombres de los archivos correspondientes. <br><br>  Una tabla TOAST se usa solo cuando se refiere a un valor "largo".  Además, la tabla de tostado tiene su propio control de versiones: si la actualización de datos no afecta el valor "largo", la nueva versión de la fila se referirá al mismo valor en la tabla de TOAST; esto ahorra espacio. <br><br>  Tenga en cuenta que TOAST solo funciona para tablas, pero no para índices.  Esto impone un límite en el tamaño de las claves indexadas. <br><blockquote>  Puede leer más sobre la organización interna de datos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en la documentación</a> . <br></blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Continuará</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/444536/">https://habr.com/ru/post/444536/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444524/index.html">Lambdas: de C ++ 11 a C ++ 20. Parte 1</a></li>
<li><a href="../444526/index.html">Pila DOTS: C ++ y C #</a></li>
<li><a href="../444528/index.html">Situación: Japón puede limitar la descarga de contenido de la red: entendemos y discutimos</a></li>
<li><a href="../444530/index.html">El futuro de la inyección de dependencia en Android</a></li>
<li><a href="../444534/index.html">Escaneo de vulnerabilidades y desarrollo seguro. Parte 1</a></li>
<li><a href="../444540/index.html">Intel está listo para comenzar la producción de memoria MRAM</a></li>
<li><a href="../444542/index.html">Transmisión en vivo y calendario de conferencias para SmartMail Conf: Machine Learning</a></li>
<li><a href="../444544/index.html">Algo sobre centros de datos distribuidos para empresas</a></li>
<li><a href="../444546/index.html">¿Cómo y por qué trabajar más lento? El método de Sergey Korolev</a></li>
<li><a href="../444548/index.html">Experiencia personal: cómo participamos en la promoción de startups hispanas en América Latina</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>