<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëâüèΩ ü§öüèª üå∞ Testes de UI codificados do Visual Studio: teoria e pr√°tica da aplica√ß√£o em nossa empresa üîê ‚ô¶Ô∏è üë©üèΩ‚Äç‚úàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Os testes automatizados da interface do usu√°rio s√£o um t√≥pico que at√© os desenvolvedores experientes desconfiam. Al√©m disso, a tecnologia desses teste...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Testes de UI codificados do Visual Studio: teoria e pr√°tica da aplica√ß√£o em nossa empresa</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/416171/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ae/e4d/592/2aee4d592fcaceeb418e5833c067dcbd.png" alt="Quadro 2"></div><br>  Os testes automatizados da interface do usu√°rio s√£o um t√≥pico que at√© os desenvolvedores experientes desconfiam.  Al√©m disso, a tecnologia desses testes n√£o √© algo extraordin√°rio e, no caso dos testes de interface do usu√°rio codificados do Visual Studio, √© uma extens√£o do sistema de testes de unidade interno do Visual Studio Team Test.  Neste artigo, quero discutir o t√≥pico dos testes de interface do usu√°rio em geral, bem como nossa experi√™ncia pessoal de usar os Testes de UI codificados do Visual Studio ao trabalhar no analisador est√°tico PVS-Studio. <br><a name="habracut"></a><br><h2>  O b√°sico </h2><br>  Primeiro, vamos tentar descobrir por que os testes de interface do usu√°rio n√£o s√£o t√£o populares entre os desenvolvedores quanto, por exemplo, os testes de unidade cl√°ssicos. <br><br>  Existem muitas ‚Äúpir√¢mides de teste‚Äù na rede que mostram a distribui√ß√£o ideal ideal do n√∫mero de testes nas camadas de aplicativos.  Todas as pir√¢mides s√£o semelhantes e cont√™m uma id√©ia geral: o maior n√∫mero poss√≠vel de testes deve estar o mais pr√≥ximo poss√≠vel do c√≥digo.  E vice-versa.  Vou dar um exemplo de uma dessas pir√¢mides, que cont√©m recomenda√ß√µes adicionais sobre a propor√ß√£o do n√∫mero de testes em porcentagem. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/430/7b5/b4b/4307b5b4b72a27aade942e0ff1747545.png" alt="Quadro 4"></div><br>  Na base da pir√¢mide est√£o os testes de unidade.  De fato, esses testes s√£o mais f√°ceis de fazer no est√°gio de desenvolvimento e ser√£o executados muito rapidamente.  No topo da pir√¢mide, por outro lado, h√° testes de interface automatizados.  Esses testes n√£o devem ser muitos, pois a complexidade de sua cria√ß√£o, bem como o tempo de execu√ß√£o, s√£o bastante grandes.  Al√©m disso, n√£o est√° claro a quem confiar a cria√ß√£o de testes de interface do usu√°rio.  Na verdade, estamos falando em emular a√ß√µes do usu√°rio.  Tudo isso est√° muito longe do c√≥digo do aplicativo, ent√£o os desenvolvedores relutam em fazer esse tipo de trabalho.  E para fazer testes automatizados de alta qualidade de interfaces sem a participa√ß√£o (ou com participa√ß√£o m√≠nima) dos programadores, √© necess√°rio o uso de ferramentas pagas.  A combina√ß√£o de todos esses fatores geralmente leva ao fato de que os testes de interface do usu√°rio n√£o funcionam, limitando-se a testes manuais √∫nicos de novas funcionalidades.  Al√©m disso, os testes de interface s√£o extremamente caros, n√£o apenas no est√°gio de desenvolvimento, mas tamb√©m durante o ciclo de vida do aplicativo.  Mesmo uma pequena altera√ß√£o na interface do usu√°rio pode levar a erros na execu√ß√£o de muitos testes e √† necessidade de modific√°-los. <br><br>  Observo que, atualmente, nosso sistema de teste geralmente cumpre as recomenda√ß√µes.  O n√∫mero de testes automatizados da GUI (45) √© aproximadamente um d√©cimo do n√∫mero total de testes do PVS-Studio.  Ao mesmo tempo, o n√∫mero de testes de unidade n√£o √© t√£o grande, mas eles s√£o complementados por v√°rios outros sistemas de teste: <br><br><ul><li> Testes de desempenho dos analisadores (C / C ++ / C # / Java), durante os quais eles checam um grande conjunto de projetos de teste em diferentes sistemas operacionais (Windows, Linux, macOS) e comparam os logs de novos avisos com os de refer√™ncia; </li><li>  Testes de recursos espec√≠ficos (rastreando o lan√ßamento de compiladores, etc.); </li><li>  Testes externos de aplicativos de linha de comando; </li><li>  Testes de montagem, instala√ß√£o e implanta√ß√£o corretas; </li><li>  Testes de documenta√ß√£o. </li></ul><br>  No est√°gio inicial de seu desenvolvimento, o analisador PVS-Studio era um aplicativo para encontrar erros ao transportar o c√≥digo C / C ++ para uma plataforma de 64 bits.  Sim, e ele foi chamado naquela √©poca de uma maneira diferente, "Viva64".  A hist√≥ria do produto pode ser encontrada no artigo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como o projeto PVS-Studio come√ßou h√° 10 anos</a> ".  Ap√≥s a integra√ß√£o ao Visual Studio 2005, o analisador adquiriu uma interface gr√°fica do usu√°rio, essencialmente a interface do pr√≥prio IDE do Visual Studio, na qual, ap√≥s a instala√ß√£o do plug-in, um menu adicional apareceu para acessar a funcionalidade do analisador.  O card√°pio era de dois ou tr√™s itens, ent√£o n√£o havia nada para testar l√°.  E o Visual Studio naquela √©poca n√£o continha nenhuma ferramenta interna para testar GUIs. <br><br><h2>  Testes e alternativas de interface do usu√°rio codificada do Visual Studio </h2><br>  Tudo mudou com o lan√ßamento do Visual Studio 2010, que introduziu um sistema integrado para a cria√ß√£o de testes de interface do usu√°rio: Visual Studio Coded UI Tests (CUIT).  Com base no sistema de teste de unidade do Visual Studio Team Test, a CUIT usou inicialmente a tecnologia Microsoft Active Accessibility (MSAA) para acessar os elementos visuais da interface.  No futuro, a tecnologia foi aprimorada e atualmente √© um modelo desenvolvido de automa√ß√£o da interface do usu√°rio para testar o c√≥digo UIA (UI Automation).  Ele permite que o sistema de teste acesse campos abertos (nome do objeto, nome da classe interna do objeto, estado atual do objeto, seu lugar na estrutura hier√°rquica da interface etc.) dos elementos da interface do usu√°rio COM e .NET, e o sistema permite emular os efeitos desses elementos atrav√©s de dispositivos de entrada padr√£o (mouse, teclado).  Imediatamente, s√£o suportados modos de grava√ß√£o de a√ß√µes do usu√°rio ao interagir com uma interface (semelhante √†s macros do Visual Studio), automa√ß√£o da cria√ß√£o de um "mapa de interface" (propriedades de controles, par√¢metros de pesquisa e acesso a eles), juntamente com a gera√ß√£o autom√°tica de c√≥digo de controle.  No futuro, todas as informa√ß√µes acumuladas s√£o f√°ceis de modificar e manter atualizadas, al√©m de personalizar as sequ√™ncias de teste conforme desejado, al√©m de possuir habilidades m√≠nimas de programa√ß√£o. <br><br>  Al√©m disso, como eu disse anteriormente, agora, ao criar testes de interface do usu√°rio inteligentes e complexos, voc√™ pode prescindir de nenhuma habilidade de programa√ß√£o, desde que use ferramentas pagas especializadas.  Bem, se n√£o houver desejo ou capacidade de usar ambientes de teste propriet√°rios, h√° muitos produtos e estruturas gratuitos.  O sistema de testes de interface do usu√°rio codificada do Visual Studio √© uma solu√ß√£o intermedi√°ria que permite n√£o apenas automatizar o processo de cria√ß√£o de testes de interface do usu√°rio, tanto quanto poss√≠vel.  Com sua ajuda, √© f√°cil criar seq√º√™ncias de teste arbitr√°rias nas linguagens de programa√ß√£o C # ou VB. <br><br>  Tudo isso pode reduzir significativamente o custo de cria√ß√£o e manuten√ß√£o da relev√¢ncia dos testes da GUI.  A estrutura usada √© simples de entender e, em geral, pode ser representada na forma de um diagrama. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10b/b6a/756/10bb6a7561749453f882bfa0c86b9f43.png" alt="Quadro 1"></div><br>  Entre os principais elementos, os chamados "adaptadores de interface" devem ser observados, que est√£o no n√≠vel mais baixo de abstra√ß√£o.  Essa camada interage com os elementos finitos da interface do usu√°rio e seus recursos podem ser expandidos usando adaptadores adicionais.  Acima, h√° uma camada que oculta as tecnologias de acesso √† GUI do restante do c√≥digo, incluindo interfaces de acesso ao programa e o c√≥digo real do aplicativo de teste, que inclui todos os elementos necess√°rios para a automa√ß√£o de teste.  A tecnologia √© extens√≠vel, cada n√≠vel pode ser complementado com os elementos necess√°rios dentro da estrutura da estrutura. <br><br>  Os principais recursos do CUIT da Microsoft incluem: <br><br><ul><li>  Teste funcional de interfaces de usu√°rio.  Aplicativos cl√°ssicos baseados no Windows, aplicativos da web e servi√ßos, WPF s√£o suportados </li><li>  Gera√ß√£o de c√≥digo (inclusive autom√°tica) em VB / C # </li><li>  Capacidade de integrar no processo de montagem </li><li>  Lan√ßamentos locais ou remotos, coleta de relat√≥rios </li><li>  Disponibilidade de grava√ß√£o e reprodu√ß√£o de sequ√™ncias de teste </li><li>  Boa extensibilidade </li></ul><br>  Apesar de v√°rias dificuldades associadas ao CUIT, o uso dessa tecnologia de teste √© preferido por v√°rios motivos: <br><br><ul><li>  Intera√ß√£o eficaz de desenvolvedores e testadores em uma √∫nica ferramenta e linguagem de programa√ß√£o </li><li>  Recursos adicionais de trabalho com a ‚Äúplaca de interface‚Äù, permitindo a identifica√ß√£o de controles ‚Äúon the fly‚Äù, sincroniza√ß√£o de elementos e conclus√£o de sequ√™ncias de teste </li><li>  Ajuste fino do mecanismo de reprodu√ß√£o, que permite, juntamente com as configura√ß√µes b√°sicas, como um atraso entre opera√ß√µes, um tempo limite de pesquisa de elemento, etc., usar mecanismos especializados no c√≥digo.  Por exemplo, bloqueando o segmento atual at√© que o controle seja ativado (visualizado) usando os <i>m√©todos</i> <i>WaitForControlExist</i> ou <i>WaitForReady</i> com a enumera√ß√£o <i>WaitForReadyLevel</i> , etc. </li><li>  Capacidade de programar testes de complexidade ilimitada </li></ul><br>  N√£o vou aprofundar os aspectos te√≥ricos da tecnologia de testes de interface do usu√°rio codificada do Visual Studio, todos eles s√£o detalhados na documenta√ß√£o relevante.  L√°, voc√™ encontra instru√ß√µes detalhadas para criar o teste de interface do usu√°rio mais simples com base nesse sistema.  E sim, o sistema n√£o √© gratuito, voc√™ precisar√° do Visual Studio Enterprise para trabalhar com ele. <br><br>  A tecnologia descrita n√£o √© a √∫nica no mercado.  Existem muitas outras solu√ß√µes.  Todos os sistemas alternativos de teste de interface do usu√°rio podem ser divididos em pagos e gratuitos.  Al√©m disso, a escolha de um sistema espec√≠fico nem sempre depender√° do seu pre√ßo.  Por exemplo, a capacidade de criar testes sem a necessidade de programa√ß√£o pode servir como um fator importante, mas, ao mesmo tempo, os testes podem n√£o ser suficientemente flex√≠veis.  Tamb√©m √© importante oferecer suporte ao ambiente de teste necess√°rio - sistemas operacionais e aplicativos.  Finalmente, os recursos puramente espec√≠ficos do aplicativo e sua interface podem influenciar a escolha.  Aqui est√£o alguns sistemas e tecnologias populares para testar GUIs. <br><br>  <i>Pago</i> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TestComplete</a> (SmartBear), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Teste Funcional Unificado</a> (Micro Focus), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Squish</a> (froglogic), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ferramentas de Teste Automatizadas</a> (Ranorex), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Funcional de Berinjela</a> (berinjela), etc. <br><br>  <i>Gr√°tis</i> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AutoIt</a> (windows), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Selenium</a> (web), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Katalon Studio</a> (web, mobile), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sahi</a> (web), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Robot Framework</a> (web), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LDTP</a> (Linux Desktop Testing Project), frameworks de c√≥digo aberto: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TestStack.White</a> + <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">UIAutomationVerify</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">,.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Biblioteca de automa√ß√£o NET do Windows</a> , etc. <br><br>  Obviamente, esta lista n√£o est√° completa.  No entanto, √© √≥bvio que os sistemas livres geralmente se concentram em um sistema operacional espec√≠fico ou em uma tecnologia de teste.  A regra geral √© que, entre os sistemas pagos, voc√™ encontrar√° muito mais rapidamente algo adequado especificamente para suas necessidades, o desenvolvimento e a manuten√ß√£o de testes ser√£o mais f√°ceis e a lista de ambientes de teste suportados √© exaustiva. <br><br>  No nosso caso, n√£o havia problema de escolha: com o lan√ßamento do Visual Studio 2010 com a adi√ß√£o de Testes de IU codificados, tornou-se poss√≠vel adicionar facilmente um conjunto de testes funcionais ao nosso ambiente de teste para testar a interface do usu√°rio do plug-in PVS-Studio para Visual Studio. <br><br><h2>  Testes de UI do PVS-Studio </h2><br>  Portanto, os testes de GUI em nossa empresa s√£o utilizados h√° mais de 6 anos.  O conjunto inicial de testes de interface do usu√°rio para o Visual Studio 2010 foi baseado na √∫nica tecnologia MSAA (Microsoft Active Accessibility) dispon√≠vel naquele momento.  Com o lan√ßamento do Visual Studio 2012, a tecnologia MSAA se desenvolveu significativamente e agora √© chamada de UIA (UI Automation).  Foi decidido continuar usando o UIA e deixar os testes baseados no MSAA para testar o plug-in do Visual Studio 2010 (oferecemos suporte e teste de plug-ins para todas as vers√µes do Visual Studio, come√ßando com o Visual Studio 2010). <br><br>  Como resultado, criamos dois "ramos" de testes de interface do usu√°rio.  Al√©m disso, no projeto de teste, esses dois ramos usavam um mapa de interface comum e c√≥digo compartilhado.  No c√≥digo, parecia algo assim (m√©todo para redefinir as configura√ß√µes do Visual Studio para o padr√£o antes de executar o teste): <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetVSSettings</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TestingMode mode)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-meta"><span class="hljs-meta">#region MSAA Mode </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (mode == TestingMode.MSAA) { .... return; } #endregion </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//UIA Mode .... }</span></span></span></span></code> </pre> <br>  Ao fazer altera√ß√µes na interface do plug-in, foi necess√°rio fazer altera√ß√µes nas duas ramifica√ß√µes dos testes da interface do usu√°rio e, ao adicionar novas funcionalidades, foi necess√°rio duplicar o elemento da interface no mapa: ou seja, criar dois elementos diferentes para cada uma das tecnologias MSAA e UIA.  Tudo isso exigiu muito esfor√ßo n√£o apenas para criar ou modificar testes, mas tamb√©m para manter o ambiente de teste em um estado est√°vel.  Vou me debru√ßar sobre esse aspecto com mais detalhes. <br><br>  De acordo com minhas observa√ß√µes, a estabilidade do ambiente de teste ao testar a GUI √© um problema significativo.  Isso se deve principalmente √† forte depend√™ncia de tais testes em muitos fatores externos.  De fato, as a√ß√µes do usu√°rio s√£o emuladas: pressionando teclas, movendo o cursor do mouse, cliques do mouse etc.  H√° muitas coisas que podem "dar errado".  Por exemplo, se durante o teste algu√©m interage com um teclado conectado ao servidor de teste.  Al√©m disso, inesperadamente, a resolu√ß√£o do monitor pode n√£o ser suficiente para exibir qualquer controle e n√£o ser√° encontrada pelo ambiente de teste. <br><br>  Aguardando: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f07/57b/2fb/f0757b2fb7075dcfac29b66f81832b69.png" alt="Quadro 3"></div><br>  Realidade: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/jd/rh/ty/jdrhtyxluox8lhxhab_btiuhjp8.png"></div><br>  Um elemento do mapa da interface ajustado de forma descuidada (e n√£o encontrada mais tarde) √© praticamente o l√≠der do comportamento do problema.  Por exemplo, ao criar um novo controle, o assistente de mapa da interface Testes de IU Codificados do Visual Studio usa os crit√©rios de pesquisa padr√£o Igual a ele.  Ou seja, √© necess√°ria a correspond√™ncia exata dos nomes das propriedades com os valores especificados.  Isso geralmente funciona, mas √†s vezes a estabilidade da execu√ß√£o do teste pode ser significativamente aprimorada usando os crit√©rios de pesquisa menos rigorosos "Cont√©m" em vez de "Igual a".  Este √© apenas um exemplo de um ‚Äúajuste‚Äù que voc√™ pode encontrar ao trabalhar nos testes de interface do usu√°rio. <br><br>  Por fim, alguns de seus testes podem consistir em executar uma a√ß√£o e aguardar mais um resultado, que, por exemplo, est√° associado √† exibi√ß√£o de uma janela.  Nesse caso, para o problema de procurar um elemento, ser√£o adicionadas perguntas sobre como definir o atraso da reprodu√ß√£o at√© que a janela apare√ßa e sincronizar o trabalho.  Alguns desses problemas podem ser resolvidos por m√©todos de estrutura padr√£o ( <i>WaitForControlExist</i> , etc.), enquanto para outros ser√° necess√°rio inventar algoritmos engenhosos. <br><br>  Enfrentamos um problema semelhante ao trabalhar em um dos testes do nosso plugin.  Neste teste, um ambiente vazio do Visual Studio √© aberto primeiro e, em seguida, uma certa solu√ß√£o de teste √© carregada l√°, que √© totalmente testada usando o PVS-Studio (menu ‚ÄúPVS-Studio‚Äù -&gt; ‚ÄúVerificar‚Äù -&gt; ‚ÄúSolu√ß√£o‚Äù).  O problema foi determinar quando a verifica√ß√£o seria conclu√≠da.  Dependendo de v√°rias condi√ß√µes, a verifica√ß√£o nem sempre pode levar o mesmo tempo, portanto, tempos limite simples n√£o funcionam aqui.  Al√©m disso, voc√™ n√£o pode usar os mecanismos padr√£o para suspender o fluxo de teste e aguardar a apar√™ncia (ou oculta√ß√£o) de qualquer controle, pois n√£o h√° nada a que anexar.  Durante a verifica√ß√£o, uma janela com o status do trabalho √© exibida, mas essa janela pode estar oculta e a verifica√ß√£o continuar√°.  I.e.  esta janela n√£o pode ser guiada (al√©m disso, possui a configura√ß√£o "N√£o fechar ap√≥s a an√°lise ser conclu√≠da").  E eu queria tornar o algoritmo mais geral, para us√°-lo em v√°rios testes relacionados √† verifica√ß√£o de projetos e √† espera pela conclus√£o desse processo.  Uma solu√ß√£o foi encontrada.  Ap√≥s o in√≠cio do teste e at√© sua conclus√£o, o pr√≥prio item de menu ‚ÄúPVS-Studio‚Äù -&gt; ‚ÄúCheck‚Äù -&gt; ‚ÄúSolution‚Äù fica inativo.  N√≥s apenas tivemos que verificar a propriedade ‚ÄúEnabled‚Äù deste item de menu em um determinado intervalo de tempo (atrav√©s do objeto de mapa da interface) e, se for constatado que o elemento se tornou ativo, considere o processo de verifica√ß√£o de decis√£o completo. <br><br>  Portanto, no caso de testes de interface do usu√°rio, n√£o basta criar testes.  √â necess√°rio um ajuste sutil e meticuloso em cada caso.  √â necess√°rio entender e sincronizar toda a sequ√™ncia de a√ß√µes executadas.  Por exemplo, o item do menu de contexto n√£o ser√° encontrado at√© que este menu seja exibido na tela, etc.  Tamb√©m √© necess√°ria uma prepara√ß√£o cuidadosa do ambiente de teste.  Nesse caso, voc√™ pode contar com a opera√ß√£o est√°vel dos testes e com os resultados adequados. <br><br>  Deixe-me lembr√°-lo de que o sistema de testes de interface do usu√°rio em nossa empresa est√° em desenvolvimento desde 2010.  Durante esse per√≠odo, v√°rias d√∫zias de sequ√™ncias de teste foram criadas e muitos c√≥digos auxiliares foram escritos.  Testes de aplicativos independentes foram adicionados aos testes de plug-in ao longo do tempo.  Nesse ponto, a antiga ramifica√ß√£o de testes de plug-ins do Visual Studio 2010 havia perdido sua relev√¢ncia e foi abandonada, mas era simplesmente imposs√≠vel cortar esse c√≥digo "morto" do projeto.  Primeiramente, como mostrei anteriormente, o c√≥digo foi profundamente integrado aos m√©todos de teste.  Em segundo lugar, mais da metade dos elementos da placa de interface existente pertencia √† antiga tecnologia MSAA, mas foram reutilizados (em vez de duplicados) em muitos novos testes junto com os elementos UIA (isso √© poss√≠vel devido √† continuidade da tecnologia).  Ao mesmo tempo, a massa do c√≥digo gerado automaticamente e o conte√∫do dos m√©todos de teste foram vinculados aos elementos "antigos". <br><br>  No outono de 2017, havia uma necessidade de melhorar o sistema de testes de interface do usu√°rio.  Em geral, os testes funcionaram bem, mas de tempos em tempos alguns testes "travavam" por motivos desconhecidos.  Mais precisamente, o motivo geralmente era encontrar um controle.  Em cada caso, eu tive que percorrer a √°rvore do mapa de interface para um elemento espec√≠fico e verificar seus crit√©rios de pesquisa e outras configura√ß√µes.  √Äs vezes, uma redefini√ß√£o do software dessas configura√ß√µes ajudava antes de executar o teste.  Dado o mapa de interface que cresceu (e em muitos aspectos, de v√°rias maneiras) pela placa de interface, bem como a presen√ßa de c√≥digo "morto", esse processo exigiu um esfor√ßo consider√°vel. <br><br>  Por algum tempo, a tarefa "estava esperando por seu her√≥i", at√© que finalmente chegou a mim. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3b/a0e/940/c3ba0e9405d26985a0519cf66544ca36.png" alt="Quadro 5"></div><br>  N√£o vou aborrec√™-lo com uma descri√ß√£o das nuances.  S√≥ posso dizer que o trabalho n√£o foi dif√≠cil, mas exigiu consider√°vel perseveran√ßa e aten√ß√£o.  Tudo sobre tudo me levou cerca de duas semanas.  Passei metade desse tempo refatorando as placas de c√≥digo e interface.  No tempo restante, ele se envolveu na estabiliza√ß√£o da execu√ß√£o do teste, que basicamente se resumia a um ajuste mais preciso dos crit√©rios de busca por elementos visuais (edi√ß√£o do mapa da interface), al√©m de alguma otimiza√ß√£o do c√≥digo. <br><br>  Como resultado, conseguimos reduzir o tamanho do c√≥digo dos m√©todos de teste em cerca de 30%, e o n√∫mero de controles na √°rvore do mapa de interface foi reduzido pela metade.  Mas o mais importante, os testes de interface do usu√°rio come√ßaram a mostrar um desempenho mais est√°vel e requerem menos aten√ß√£o.  E a queda come√ßou a ocorrer com mais frequ√™ncia devido a raz√µes para fazer altera√ß√µes na funcionalidade do analisador ou ao detectar inconsist√™ncias (erros).  Na verdade, para esses fins, precisamos de um sistema de testes de interface do usu√°rio. <br><br>  Assim, atualmente, o sistema de testes autom√°ticos da interface PVS-Studio possui as seguintes caracter√≠sticas b√°sicas: <br><br><ul><li>  Teste de interface do usu√°rio codificada do Visual Studio </li><li>  45 cen√°rios </li><li>  4.095 linhas de c√≥digo para m√©todos de teste </li><li>  19.889 linhas de c√≥digo gerado automaticamente (excluindo o tamanho do arquivo xml para armazenar as configura√ß√µes do Mapa da UI) </li><li>  1 hora 34 minutos de execu√ß√£o (valor m√©dio de acordo com os resultados das √∫ltimas 30 partidas) </li><li>  Trabalhar em um servidor dedicado (executando o utilit√°rio MSTest.exe) </li><li>  Monitoramento de desempenho e an√°lise de relat√≥rio de desempenho (Jenkins) </li></ul><br><h2>  Conclus√£o </h2><br>  Concluindo, desejo fornecer uma lista de crit√©rios de sucesso para testes autom√°ticos de GUI, que se baseiam em uma an√°lise de nossa experi√™ncia com essa tecnologia (alguns crit√©rios se aplicam a outras tecnologias de teste, por exemplo, testes de unidade). <br><br>  <i>Ferramentas adequadas</i> .  Escolha o ambiente para criar e executar o CUIT de acordo com os recursos do seu aplicativo, bem como o ambiente de teste.  As solu√ß√µes pagas nem sempre fazem sentido, mas geralmente ajudam a resolver um problema com muita efici√™ncia. <br><br>  <i>Configura√ß√£o de infraestrutura de alta qualidade</i> .  N√£o salve ao desenvolver uma placa de interface.  Simplifique o trabalho da estrutura ao procurar elementos, descrevendo cuidadosamente todas as suas propriedades e definindo crit√©rios de pesquisa inteligente.  Preste aten√ß√£o √†s possibilidades de outras modifica√ß√µes. <br><br>  <i>Minimiza√ß√£o do trabalho manual</i> .  Sempre que poss√≠vel, certifique-se de usar meios autom√°ticos para gerar c√≥digo e gravar sequ√™ncias.  Portanto, voc√™ acelerar√° significativamente o desenvolvimento e minimizar√° a probabilidade de erros (nem sempre √© f√°cil encontrar o motivo do travamento do teste da interface do usu√°rio, especialmente se um erro for cometido no c√≥digo para trabalhar com a estrutura). <br><br>  <i>Testes inteligentes simples e independentes</i> .  Quanto mais simples seus testes, melhor.  Tente fazer um teste separado para testar um controle espec√≠fico ou uma situa√ß√£o simulada.  Verifique tamb√©m se os testes s√£o independentes um do outro.  A queda de um dos testes n√£o deve afetar todo o processo. <br><br>  <i>Nomes amig√°veis</i> .  Use prefixos nos nomes de testes semelhantes.  Muitos ambientes permitem executar testes filtrando por nome.  Use tamb√©m o agrupamento de testes sempre que poss√≠vel. <br><br>  <i>Tempo de execu√ß√£o isolado</i> .  Verifique se os testes s√£o executados em um servidor dedicado com impacto externo m√≠nimo.  Desconecte todos os dispositivos de entrada do usu√°rio externo, forne√ßa a resolu√ß√£o de tela necess√°ria para o seu aplicativo ou use um manequim de hardware que simule uma conex√£o de monitor de alta resolu√ß√£o.  Verifique se, durante o teste, outros aplicativos que interagem, por exemplo, com a √°rea de trabalho e exibem mensagens, n√£o est√£o em execu√ß√£o.  Tamb√©m √© necess√°rio planejar a hora de in√≠cio e considerar a dura√ß√£o m√°xima dos testes. <br><br>  <i>An√°lise de relat√≥rios emitidos</i> .  Forne√ßa um formul√°rio simples e claro para relatar o progresso.  Use sistemas de integra√ß√£o cont√≠nua para despachar testes, bem como obter e analisar rapidamente os resultados dos testes. <br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br>  Se voc√™ deseja compartilhar este artigo com um p√∫blico que fala ingl√™s, use o link para a tradu√ß√£o: Sergey Khrenov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Testes de UI codificados do Visual Studio: teoria e experi√™ncia do usu√°rio da empresa</a> <br><br><div class="spoiler">  <b class="spoiler_title">Voc√™ leu o artigo e tem uma pergunta?</b> <div class="spoiler_text">  Muitas vezes, nossos artigos recebem as mesmas perguntas.  Reunimos as <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">respostas</a> aqui: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Respostas √†s perguntas dos leitores dos artigos sobre PVS-Studio, vers√£o 2015</a> .  Por favor, veja a lista. </div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt416171/">https://habr.com/ru/post/pt416171/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt416159/index.html">Como fomos encarregados de comparar um ouri√ßo</a></li>
<li><a href="../pt416161/index.html">10 raz√µes para n√£o usar o k8s</a></li>
<li><a href="../pt416163/index.html">Aprenda o OpenGL. Li√ß√£o 5.6 - Mapeamento de paralaxe</a></li>
<li><a href="../pt416167/index.html">Peter Norwig: Aprenda Programa√ß√£o em ... 10 Anos</a></li>
<li><a href="../pt416169/index.html">Contentores para adultos (parte 01): um guia pr√°tico de terminologia</a></li>
<li><a href="../pt416175/index.html">Resultados da competi√ß√£o de jovens desenvolvedores de aplicativos AR Epson Moverio BT-300</a></li>
<li><a href="../pt416177/index.html">F√≥rmula de Tupper e implementa√ß√£o do algoritmo em Python</a></li>
<li><a href="../pt416179/index.html">Uma porta que nos recebe pelo nome e se abre apenas para funcion√°rios do departamento</a></li>
<li><a href="../pt416181/index.html">Modula√ß√£o de amplitude nos dedos</a></li>
<li><a href="../pt416183/index.html">Teste de dados: requisitos e n√≠veis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>