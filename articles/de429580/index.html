<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤹🏻 👩🏼‍🔧 👩🏽‍💻 Mikrointeraktionen in iOS. Yandex Vortrag 🌰 🤲🏻 🚓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einigen Wochen fand im Yandex-Büro eine Sonderveranstaltung der CocoaHeads-Community statt - größer als herkömmliche Mitaps. Entwickler Anton Serg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mikrointeraktionen in iOS. Yandex Vortrag</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/429580/">  Vor einigen Wochen fand im Yandex-Büro eine Sonderveranstaltung der CocoaHeads-Community statt - größer als herkömmliche Mitaps.  Entwickler Anton Sergeev sprach bei diesem Treffen über das Mikrointeraktionsmodell, das UX-Designer normalerweise verwenden, sowie darüber, wie die darin enthaltenen Ideen in die Praxis umgesetzt werden können.  Anton achtete am meisten auf Animation. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/JoVBQCwX8ys" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - Es ist mir sehr wichtig, dass es mir eine Ehre war, die Gäste zu treffen.  Ich sehe hier diejenigen, mit denen ich schon sehr lange zusammen bin, mit denen ich kürzlich zusammen war und mit denen ich mich noch nicht getroffen habe.  Willkommen bei CocoaHeads. <a name="habracut"></a><br><br>  Ich erzähle Ihnen von Mikrointeraktionen.  Dies ist ein kleiner Clickbait - wir sind Ingenieure, Entwickler, wir werden mehr über den Softwareteil sprechen, aber beginnen wir mit einem sehr humanitären Thema wie Mikrointeraktionen.  Infolgedessen werden wir dieses humanitäre Thema im technischen Teil anwenden, um zu lernen, wie sehr kleine visuelle Komponenten wie Knöpfe, kleine Lader und Balken effizienter und einfacher gestaltet werden können.  Sie sind mit Animationen gesättigt, und verzweigter Animationscode kann oft sehr kompliziert aussehen. Die Wartung ist äußerst schwierig. <br><br>  Aber zuerst ein wenig Ablenkung.  Denken Sie darüber nach, erinnern Sie sich, als Sie beschlossen, Entwickler zu werden?  Ich erinnere mich deutlich daran.  Alles begann mit einem Tisch.  Einmal habe ich beschlossen, ObjC zu lernen.  Modische Sprache, Spaß, einfach so, ohne weitreichende Pläne.  Ich fand anscheinend ein Buch, Big Nerd Ranch, und fing an, Kapitel für Kapitel zu lesen, jede Übung zu machen, zu überprüfen, zu lesen, bis ich den Tisch erreichte.  Dann habe ich mich zuerst mit dem Delegatenmuster vertraut gemacht, genauer mit seiner Unterart „Datenquelle“, Datenquelle.  Dieses Paradigma erscheint mir jetzt sehr einfach: Es gibt eine Datenquelle, Delegierter, alles ist einfach.  Aber dann hat es mich umgehauen: Wie kann ich eine Tabelle von völlig anderen Daten trennen?  Sie haben einmal eine Tabelle auf einem Blatt Papier gesehen, in die Sie unendlich viele Zeilen und vollständig abstrakte Daten einfügen können.  Es hat mich sehr beeinflusst.  Ich erkannte, dass Programmierung und Entwicklung enorme Möglichkeiten bieten und es sehr interessant sein wird, sie anzuwenden.  Seitdem habe ich mich entschieden, Entwickler zu werden. <br><br>  Während der Entwicklung wurden verschiedene Muster angetroffen.  Riesige, sogenannte Architekturen, die die gesamte Anwendung beschreiben.  Kleine, die in Dutzende auf Knopfdruck passen.  Es ist wichtig zu verstehen, dass all diese Muster nicht aus der Luft stammen, sondern aus dem humanitären Bereich.  Das gleiche Delegatenmuster.  Die Delegation erschien lange vor der Programmierung, und die Programmierung übernimmt all diese humanitären Dinge für eine effizientere Arbeit. <br><br>  Heute werde ich über einen anderen Ansatz sprechen, der eine andere humanitäre Sache übernimmt.  Insbesondere über Mikrointeraktionen. <br><br>  Alles begann mit einem Lader.  Bei der vorherigen Arbeit vor Yandex hatte ich die Aufgabe, den Google Material Design Loader zu wiederholen.  Es gibt zwei davon, eine unbestimmte, eine andere definierte.  Ich hatte die Aufgabe, sie zu einer zu kombinieren, er musste sowohl sicher als auch unbestimmt sein können, aber es gab strenge Anforderungen - damit es extrem reibungslos lief.  Wir können jederzeit von einem Zustand in einen anderen wechseln, und alles sollte reibungslos und genau animiert sein. <br><br>  Ich bin ein kluger Entwickler, ich habe alles getan.  Ich habe mehr als 1000 Zeilen unverständlichen Nudelcodes erhalten.  Es hat funktioniert, aber ich erhielt einen coolen Kommentar zur Codeüberprüfung: "Ich hoffe wirklich, dass niemand diesen Code jemals bearbeiten wird."  Und für mich ist es praktisch ungeeignet.  Ich habe schrecklichen Code geschrieben.  Es hat cool funktioniert, es war eine meiner besten Animationen, aber der Code war schrecklich. <br><br>  Heute werde ich versuchen, den Ansatz zu beschreiben, den ich gefunden habe, nachdem ich diesen Job verlassen habe. <br><br><img src="https://habrastorage.org/webt/w6/93/ez/w693ezlmyrpdyxgcxluxx0scxdo.jpeg"><br><br>  Beginnen wir mit dem humanitärsten Thema - Mikrointeraktionsmodellen.  Wie sind sie eingebettet und wo sind sie im Allgemeinen in unseren Anwendungen versteckt?  Lassen Sie uns dieses Modell in unserer technischen Welt weiter verwenden.  Überlegen Sie, wie UIView, das sich mit Anzeige und Animation befasst, wie dies funktioniert.  Insbesondere werden wir viel über den CAAction-Mechanismus sprechen, der eng in UIView, CALayer, integriert ist und mit diesem zusammenarbeitet.  Und dann betrachten Sie kleine Beispiele. <br><br>  Definition zuerst.  Anscheinend hat der Autor das Präfix "Mikro" wirklich gemocht, aber es gibt keine Makro- oder Nano-Wechselwirkungen, die Größe spielt keine Rolle.  Der Einfachheit halber werden wir sie einfach Interaktionen nennen.  Dies ist ein so praktisches Modell, mit dem Sie jede Interaktion mit der Anwendung von Anfang bis Ende beschreiben können.  Es besteht aus vier Punkten: einem Auslöser, einer Geschäftslogik, die in dieser Interaktion implementiert werden muss, einem Feedback, um dem Benutzer etwas zu vermitteln, und einer Änderung des Anwendungsstatus. <br><br>  Ich werde eine Geschichte mit drei verschiedenen Rollen erzählen.  Ich werde mit dem Benutzer beginnen, als das Wichtigste in der Entwicklung.  Als ich mich auf den Bericht vorbereitete, wurde ich krank.  Ich musste eine Apotheke finden und öffnete Yandex.Map.  Ich habe die Anwendung geöffnet, sieh sie dir an, sie sieht mich an, aber es passiert nichts.  Dann wurde mir klar, dass ich der Benutzer bin, ich bin der Hauptbenutzer. Ich gebe Anweisungen, was für die Anwendung zu tun ist.  Ich orientierte mich, klickte auf die Schaltfläche "Suchen", gab "Apotheke" ein, klickte auf "OK", die Anwendung erledigte die interne Arbeit, fand die erforderlichen Apotheken neben mir und zeigte sie auf dem Bildschirm an. <br><br>  Ich suchte nach der richtigen und stellte fest, dass zusätzlich zu den Apotheken eine spezielle Schaltfläche auf dem Bildschirm angezeigt wurde - um eine Route zu erstellen.  Somit ist die Anwendung in einen neuen Zustand versetzt worden.  Ich klickte darauf und ging in die Apotheke.  Ich bin aus irgendeinem Grund in diese Anwendung gegangen - um eine Apotheke zu finden.  Ich habe sie erreicht.  Ich bin ein glücklicher Benutzer. <br><br>  Bevor diese Anwendung erschien und ich nach etwas darin suchen konnte, wurde sie zuerst entwickelt.  Was dachte der UX-Designer, als er diesen Prozess entwickelte?  Alles begann mit der Tatsache, dass es notwendig war, aus einer Stummschaltungsszene herauszukommen, wenn sich Benutzer und Anwendung gegenseitig ansehen und nichts passiert.  Dafür wurde eine Art Auslöser benötigt.  Alles hat einen Anfang, und auch hier musste man irgendwo anfangen. <br><br>  Der Auslöser wurde ausgewählt - Suchtaste.  Beim Klicken war es notwendig, das Problem aus technischer Sicht zu lösen.  Daten auf dem Server anfordern, Antwort analysieren, Modell irgendwie aktualisieren, analysieren.  Fordern Sie die aktuelle Position der Benutzer und mehr an.  Wir haben diese Daten erhalten und wissen genau, wo sich alle Apotheken befinden. <br><br>  Es scheint möglich zu sein, dies zu beenden.  Immerhin haben wir das Problem gelöst, alle Apotheken gefunden.  Es gibt nur ein Problem: Der Benutzer weiß immer noch nichts über diese Apotheken.  Er muss es vermitteln. <br><br>  Irgendwie packen wir unsere Lösung für dieses Problem und bringen sie ihm in einem schönen Paket, damit er es versteht.  Es ist so passiert, dass Benutzer Menschen sind, sie interagieren mit der Außenwelt über die Sinne.  Der aktuelle Stand der Technik ist so, dass wir als Entwickler mobiler Anwendungen nur drei Sinne haben: Sehen - wir können etwas auf dem Bildschirm zeigen, Hören - wir können es in den Lautsprechern reproduzieren und ein taktiles Gefühl können wir den Benutzer in die Hand drücken. <br><br>  Aber der Mensch ist viel funktionaler.  Der aktuelle Stand der Technik ist jedoch so, dass wir uns derzeit nur auf diese drei verlassen können.  In diesem Fall wählen wir einen Bildschirm aus, zeigen auf der Karte die nächstgelegenen Apotheken und eine Liste mit detaillierteren Informationen zu diesen Apotheken.  Und es scheint, dass dies genau alles ist, der Benutzer Apotheken gefunden hat und alles in Ordnung ist. <br><br>  Aber es gibt ein Problem.  Als der Benutzer die Anwendung eingab, befand er sich in einem Kontext, in dem er nicht wusste, wo sich die Apotheken befanden.  Und seine Aufgabe war es, sie zu finden.  Aber jetzt hat sich der Kontext geändert, er weiß, wo die Apotheken sind, er muss nicht mehr nach ihnen suchen.  Er hatte die folgende Aufgabe - Wegbeschreibungen zur nächsten Apotheke zu bekommen.  Aus diesem Grund müssen zusätzliche Steuerelemente auf dem Bildschirm angezeigt werden. Dies ist insbesondere eine Schaltfläche zum Erstellen einer Route, dh zum Übertragen der Anwendung in einen anderen Status, in dem sie bereit ist, neue Trigger für die nächsten Interaktionen wieder zu akzeptieren. <br><br>  Stellen Sie sich vor, der UX-Designer hat sich all das ausgedacht, kommt zum Entwickler und beginnt in Farben zu beschreiben, wie der Benutzer auf die Schaltfläche klickt, wie und was passiert, wie gesucht wird, wie der Benutzer zufrieden ist, wie wir die DAU erhöhen und so weiter.  Der Stapel ungelöster Fragen des Entwicklers lief im ersten Satz an einer anderen Stelle über, als wir den Button zum ersten Mal erwähnten. <br><br>  Er hört geduldig auf alles und am Ende, wenn es endet, sagt er, dass das cool ist, aber lassen Sie uns den Knopf besprechen.  Dies ist ein wichtiges Element. <br><br>  Während der Diskussion stellt sich heraus, dass die Schaltfläche von Natur aus ein Auslöser ist, sie enthält Logik in sich, nach der sie Nachrichten vom System empfangen kann, insbesondere über Benutzerklicks auf den Bildschirm.  Basierend auf diesem Klick kann eine Ereigniskette gestartet werden, die mit der Tatsache beginnt, dass dieselbe Schaltfläche Nachrichten an verschiedene Objekte sendet, in denen die Notwendigkeit zum Starten verschiedener Prozesse angegeben wird. In diesem Fall werden Informationen auf dem Server angefordert. <br><br>  Wenn die Taste gedrückt wird, ändert sie ihren Status und wird gedrückt.  Wenn der Benutzer loslässt, wird er nicht mehr gedrückt.  Das heißt, es gibt dem Benutzer Feedback, damit er versteht, was von dieser Schaltfläche zu erwarten ist.  Und die Taste kann in verschiedenen Zuständen gedrückt, nicht gedrückt, aktiv oder inaktiv sein und sich nach unterschiedlicher Logik von einem Zustand in einen anderen bewegen. <br><br>  So haben wir gesehen, dass dasselbe Mikrointeraktionsmodell, das aus einem Auslöser, einer Geschäftslogik, Rückmeldungen und Statusänderungen besteht, unsere Anwendung auf verschiedenen Skalen beschreiben kann, wie auf der Skala eines gesamten Benutzerfalls, einer riesigen Suche nach der nächsten Apotheke. also in Bezug auf einen kleinen Knopf. <br><br>  Und dies ist ein sehr praktisches Modell, mit dem Sie die Interaktion innerhalb des Teams vereinfachen und programmgesteuert vier Entitäten trennen können: Trigger, Geschäftslogik, Feedback und Statusänderung.  Mal sehen, was uns UIKit bietet, um es zu nutzen.  Und bietet nicht nur, sondern nutzt.  Bei der Implementierung verschiedener Animationen, der kleinen Komponenten der UIView-Unterklassen, wird nur dieser Mechanismus verwendet und nicht anders. <br><br>  Beginnen wir mit UIView, wie es in dieses Modell passt.  Dann werden wir CALayer betrachten, das es uns bietet, um diese Staaten zu unterstützen, und wir werden den Wirkungsmechanismus als den interessantesten Moment betrachten. <br><br>  Beginnen wir mit dem UIView.  Wir verwenden es, um einige Rechtecke auf dem Bildschirm anzuzeigen.  Tatsächlich weiß UIView jedoch nicht, wie es sich selbst zeichnen soll, sondern verwendet dafür ein anderes CALayer-Objekt.  Tatsächlich ist UIView verpflichtet, Nachrichten über das Berühren des Systems sowie über andere Aufrufe der API zu empfangen, die wir in unseren Unterklassen von UIView definiert haben.  Somit implementiert UIView selbst die Triggerlogik, dh den Start einiger Prozesse, die diese Nachrichten vom System empfangen. <br><br>  UIView kann seine Delegierten auch über aufgetretene Ereignisse benachrichtigen und Nachrichten an Abonnenten senden, um beispielsweise UIControl-Unterklassen zu unterschiedlichen Ereignissen zu machen.  Auf diese Weise wird die Geschäftslogik dieses UIView implementiert.  Nicht alle von ihnen haben Geschäftslogik, viele von ihnen sind nur Anzeigeelemente und haben kein Feedback im Sinne von Geschäftslogik. <br><br><img src="https://habrastorage.org/webt/ur/9o/tu/ur9otu78v5xkyy3knr8ze443pl8.jpeg"><br><br>  Wir haben uns zwei Punkte angesehen, einen Auslöser und eine Geschäftslogik.  Und wo sind Feedback und Statusänderungen in UIView verborgen?  Um dies zu verstehen, müssen wir uns daran erinnern, dass UIView nicht für sich existiert.  Beim Erstellen wird eine Hintergrundschicht erstellt, eine Unterklasse von CALayer. <br><br><img src="https://habrastorage.org/webt/_y/dw/wt/_ydwwtnnokhkvxeuj5kl02v4qaa.jpeg"><br><br>  Und ernennt sich zu seinem Delegierten.  Um zu verstehen, wie UIView CALayer verwendet, kann es in verschiedenen Zuständen existieren. <br><br>  Wie kann man einen Staat von einem anderen unterscheiden?  Sie unterscheiden sich in der Menge der Daten, die irgendwo gespeichert werden müssen.  Wir werden prüfen, welche Funktionen CALayer für UIView bereitstellt, damit der Status gespeichert wird. <br><br><img src="https://habrastorage.org/webt/ls/2x/7f/ls2x7f_qs_-ysgeirsunqki1o7o.jpeg"><br><br>  Unsere Oberfläche wird etwas erweitert, die Interaktion zwischen UIView und CALayer, UIView hat eine zusätzliche Aufgabe - das Repository in CALayer zu aktualisieren. <br><br>  Eine wenig bekannte Tatsache, die nur wenige Leute verwenden: CALayer kann sich wie ein assoziatives Array verhalten, was bedeutet, dass wir beliebige Daten auf jeden Schlüssel wie folgt schreiben können: setValue (_: forKey :). <br><br><img src="https://habrastorage.org/webt/hy/l_/r9/hyl_r9663azms_wx4qlf1f12ctw.jpeg"><br><br>  Diese Methode ist in allen NSObject-Unterklassen vorhanden, stürzt jedoch im Gegensatz zu vielen anderen nicht ab, wenn ein Schlüssel empfangen wird, der nicht damit überschrieben wird.  Und er schreibt es richtig auf, und dann können wir es lesen.  Dies ist eine sehr praktische Sache, die es ermöglicht, ohne Unterklassen von CALayer zu erstellen, Daten dort zu schreiben und sie dann zu lesen und zu konsultieren.  Aber dies ist ein sehr primitives einfaches Repository, in der Tat ein Wörterbuch.  CALayer ist viel progressiver.  Es unterstützt Stile. <br><br>  Dies wird durch die Style-Eigenschaft implementiert, über die jeder CALayer verfügt.  Standardmäßig ist es Null, aber wir können es neu definieren und verwenden. <br><br><img src="https://habrastorage.org/webt/ow/x1/ox/owx1ox1elo1_go_6jxikiuc6fws.jpeg"><br><br>  Im Allgemeinen ist dies ein reguläres Wörterbuch und nichts weiter, aber es hat eine Besonderheit darüber, wie CALayer damit arbeitet, wenn wir nach dem Wert für Key fragen, einer anderen Methode, die NSObject hat.  Es wirkt sehr interessant, es sucht rekursiv nach den notwendigen Werten im Stilwörterbuch.  Wenn wir einen vorhandenen Stil mit dem Stilschlüssel in einen neuen Stil packen und dort einige Schlüssel schreiben, sieht dies jedoch folgendermaßen aus. <br><br><img src="https://habrastorage.org/webt/xd/m3/z1/xdm3z1vyiscv35nd1jspq5aujve.jpeg"><br><br>  Schauen Sie sich zuerst die Wurzel an, dann das Landesinnere und so weiter, bis es Sinn macht.  Wenn Stil gleich Null wird, macht es keinen Sinn, weiter zu schauen. <br><br>  Auf diese Weise kann UIView mithilfe der von CALayer bereitgestellten Infrastruktur Statusänderungen organisieren, das interne CALayer-Repository aktualisieren, entweder mithilfe von style, einem sehr leistungsstarken Repository, das einen Stapel simulieren kann, oder mithilfe eines regulären assoziativen Arrays, das ebenfalls sehr effizient und sehr nützlich ist . <br><br>  Beginnen Sie mit der Speicherung und beginnen Sie mit CAAction.  Ich werde dir mehr über ihn erzählen. <br><br><img src="https://habrastorage.org/webt/r7/ay/kz/r7aykzzyhz25wrbcddkax9-oyzm.jpeg"><br><br>  Es gibt eine neue Aufgabe für UIView - Aktionen von CALayer anzufordern.  Was sind Aktionen? <br><br><img src="https://habrastorage.org/webt/rk/yi/le/rkyile_6v-vwfrq0d98sgeq4obs.jpeg"><br><br>  CAAction ist nur ein Protokoll, für das nur eine Methode ausgeführt wird.  Apple liebt im Allgemeinen Kinothemen, Action hier als "Kamera, Motor!".  Dieser „Motor“ ist nur eine Aktion, und nicht nur dieser Name wurde verwendet.  Die Ausführungsmethode bedeutet, dass eine Aktion gestartet wird, die gestartet, ausgeführt und beendet werden kann. Dies ist die wichtigste.  Diese Methode ist sehr allgemein gehalten, hat nur eine Ereigniszeichenfolge und alles andere kann von einem beliebigen Typ sein.  In ObjC ist dies alles ID und ein normales NSDictionary. <br><br><img src="https://habrastorage.org/webt/3u/q-/6z/3uq-6zsnqrcdp_ijgpmbvljcxui.jpeg"><br><br>  Es gibt Klassen in UIKit, die das CAAction-Protokoll erfüllen.  Das erste ist Animation.  Erstens wissen wir, dass Animation zu einer Ebene hinzugefügt werden kann, aber dies ist eine sehr einfache Sache.  Eine übergeordnete Abstraktion darüber besteht darin, eine Aktion mit den erforderlichen Parametern mit einer Ebene auszuführen. <br><br>  Die zweite wichtige Ausnahme ist NSNull.  Wir wissen, dass er mit keiner Methode aufgerufen werden kann, aber er erfüllt das CAAction-Protokoll, und dies geschieht, um bequem in Schichten nach CAAction zu suchen. <br><br><img src="https://habrastorage.org/webt/nm/34/9d/nm349dj4-hpwpaf2jshz4bjr6ee.jpeg"><br><br>  Wie bereits erwähnt, ist UIView ein Delegat an CALayer, und eine der Delegatenmethoden ist action (für: forKey :).  Die Ebene hat eine Methode, Aktion für Schlüssel. <br><br><img src="https://habrastorage.org/webt/xh/1s/wz/xh1swzwsz49zo9iythd65yntg5a.jpeg"><br><br>  Wir können es jederzeit auf der Ebene aufrufen, und es wird jederzeit die richtige Aktion oder Null geben, da es auch geben kann.  Der Algorithmus ist eine sehr ungewöhnliche Suche.  Der Pseudocode ist hier geschrieben, schauen wir uns die Zeilen an.  Nach Erhalt einer solchen Nachricht konsultiert er zunächst den Delegierten.  Ein Delegat kann entweder null zurückgeben, was bedeutet, dass die Suche an anderer Stelle fortgesetzt werden soll, oder er kann eine gültige Aktion zurückgeben, ein gültiges Objekt, das das CAAction-Protokoll erfüllt.  Es gibt jedoch eine logische Regel: Wenn NSNull zurückgegeben wird, das dieses Protokoll erfüllt, wird es später in nil konvertiert.  Das heißt, wenn wir Null zurückgeben, bedeutet dies tatsächlich "Suche beenden".  Es gibt keine Aktion und es ist nicht notwendig. <br><br>  Aber es gibt folgendes.  Nachdem er sich mit dem Delegierten beraten hatte und der Delegierte gleich Null zurückgekehrt war, suchte er weiter.  Zuerst im Aktionswörterbuch, über das die Ebene verfügt, und dann wird rekursiv im Stilwörterbuch gesucht, wo es auch ein Wörterbuch mit dem Aktionsschlüssel geben kann, in das viele Aktionen geschrieben werden können, und es kann auch rekursiv nach ihnen suchen.  Wenn es dort nicht geklappt hat, fragt er die Klasse nach der Standardaktion für die Key-Methode, die von CALayer definiert wird und bis vor kurzem etwas zurückgegeben hat. In den letzten Versionen von iOS wird jedoch in letzter Zeit immer Null zurückgegeben. <br><br>  Verstand die Theorie.  Mal sehen, wie alles in der Praxis angewendet wird. <br><br>  Es gibt Ereignisse, sie haben Schlüssel, einige Aktionen finden für diese Ereignisse statt.  Grundsätzlich können zwei verschiedene Arten von Ereignissen unterschieden werden.  Das erste ist die Animation gespeicherter Eigenschaften.  Angenommen, wenn wir Viewcolor = red in View aufrufen, ist es theoretisch möglich, zu animieren. <br><br><img src="https://habrastorage.org/webt/2i/6p/sc/2i6pscholbhv-jvln05rlepz1ru.jpeg"><br><br>  Welcher Bericht über Muster ohne Schaltung?  Ich habe ein paar gezeichnet.  UIView verfügt über eine Art Schnittstelle, die wir für Unterklassen definiert haben oder die vom System mit Ereignissen empfangen wird.  Die Aufgabe von UIView besteht darin, die gewünschte Aktion anzufordern, den internen Speicher zu aktualisieren und die aufgetretene Aktion zu starten.  Die Reihenfolge ist in Bezug auf die Anforderung sehr wichtig: Aktion, nur dann die Aktion aktualisieren und erst dann den Speicher und die Aktion aktualisieren. <br><br><img src="https://habrastorage.org/webt/b4/qu/mm/b4qumm17wvgwfhycn1ld3z7tuka.jpeg"><br><br>  Was passiert, wenn wir bei UIView backgroundColor aktualisieren?  Wir wissen, dass in UIView alles, was mit der Anzeige auf dem Bildschirm zu tun hat, immer noch ein Proxy für CALayer ist.  Er speichert alles, was er erhält, für alle Fälle zwischen, aber gleichzeitig sendet alles CALayer, und er befasst sich weiter mit der gesamten Logik von CALayer.     CALayer,      ?    . <br><br><img src="https://habrastorage.org/webt/wd/gd/-p/wdgd-peskdkf3x9pt9ta408lpa8.jpeg"><br><br>     .   ,     .         CALayer   ,    backgroundColor,     store,       run,     CALayer    .       ,   ,      ,     . <br><br>      UIView,    backgroundColor  UIView,       ,   ,     ,   . <br><br><img src="https://habrastorage.org/webt/nm/34/9d/nm349dj4-hpwpaf2jshz4bjr6ee.jpeg"><br><br>   ,   .   ,  UIView    CALayer,     .  Alles ist sehr einfach. <br><br>        ,    - .    ,     NSNull,  ,     .      ,  CALayer      . <br><br>       ,  UIView   ,  .         .       ? <br><br><img src="https://habrastorage.org/webt/hb/bp/j_/hbbpj_qzzphg6b_dvw-mhbmceak.jpeg"><br><br>    ,   .  UIView   ,  read only,      ,  inheritedAnimationDuration.    .      ,      .      . <br><br>    ?          duration,      .        ,   run, ,      . <br><br><img src="https://habrastorage.org/webt/a6/4u/n9/a64un9twddqprjgzjvzwnppwnpk.jpeg"><br><br>       ,   CAAction,  backgroundcolor  opacity,     UIView .  ,      ,  ,  ,  .          .    setValue forKey    ,        ,     ,   ,       ,      ,   . <br><br>     ,       ,    ,   ,   . <br><br>    —      . ,    «»  «»   .    . <br><br>    . <br><br><img src="https://habrastorage.org/webt/l6/je/7m/l6je7mjo7fnwwxyvfql1y-yuy0q.jpeg"><br><br>     . ,        ,         ,    .               UIView   CALayer,       ,    , CAAction, ,  ,   . <br><br><img src="https://habrastorage.org/webt/q6/uo/jq/q6uojqtnrhojwxpuuwzxtuentju.jpeg"><br><br><img src="https://habrastorage.org/webt/jg/ax/_s/jgax_s_wow82hbtxeax_29d3brw.jpeg"><br><br> ,     ,    ,       .            ,       .    . <br><br>    .   - . <br><br>             CAAction,    ,   .   ,    ,    ,  . <br><br><img src="https://habrastorage.org/webt/pa/0b/b8/pa0bb8gtuowzwknknhve-btxbsw.jpeg"><br><br>   ,       , ,    home,    .     ,    . ,      . <br><br><img src="https://habrastorage.org/webt/hw/5r/l8/hw5rl8bhdrs4fvmi503inw7iauq.jpeg"><br><br>      .   - . <br><br><img src="https://habrastorage.org/webt/bp/np/di/bpnpdiveiwjnqlxotgrvlr5egj8.jpeg"><br><br>   ,  -    , -   .     ,    ,    .     ,   . <br><br>      ,    ,      . <br><br><img src="https://habrastorage.org/webt/hj/ub/55/hjub55ptyxd7nbmmr9jur-zn3sy.jpeg"><br><br>   ,   CAAction      ,   .     ,   UIControl,  - ,   - ,     ,      ,  -   . <br><br> ,  .  ,  UIView  -,     ,   -   ,       ,   ,      . <br><br>    —     .       . <br><br>   ?    .  ,          .      —   .      activating,      inactive  active.        ,  ,        . <br><br><img src="https://habrastorage.org/webt/rz/lt/hw/rzlthwfk8lmduvkc_ltfagvorbk.jpeg"><br><br>    .   ,  onOrderIn  onOrderOut.  ,      UIKit,        . <br><br>  ,   -, — ,    . <br><br><img src="https://habrastorage.org/webt/q4/8t/2v/q48t2v7xemofbmsmaydyaivlgqw.jpeg"><br><br>    .      UIView  ,      : isActive  progress.        .        CAAction,     . <br><br>   ,   .   ,  , 30 CAACtion,    .          ,   30 ,        NSNull.     15     15 .    .      —  .   ,   —      . <br><br> ,         .     . <br><br>   .  ,        ,    : , -,     . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Indem wir alle Wechselwirkungen in diese vier Teile zerlegen, können wir die Logik des einen mit dem anderen nicht stören, vereinfachen. </font><font style="vertical-align: inherit;">Versuchen Sie daher, Ihre Anwendungen und verschiedene Aufgaben mithilfe dieser Mikrointeraktionen zu analysieren. </font><font style="vertical-align: inherit;">Denken Sie daran, dass UIKit eine riesige Infrastruktur bietet, um dies bequem und schön zu tun. </font><font style="vertical-align: inherit;">Vernachlässige sie nicht. </font><font style="vertical-align: inherit;">Oft gibt es sehr alte Methoden, sie werden selten verwendet, aber sie sind sehr wichtig und helfen Ihnen, Ihre Elemente schön, einfach und schnell zu realisieren.</font></font> Vielen Dank für Ihre Aufmerksamkeit. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de429580/">https://habr.com/ru/post/de429580/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de429568/index.html">Reduzieren Sie mit Zextras Backup die Ausfallzeiten von Zimbra bei Serverabstürzen</a></li>
<li><a href="../de429570/index.html">Einem Agenten beibringen, Mario Kart mit Filtern zu spielen</a></li>
<li><a href="../de429572/index.html">Abfangen privater Konversationen in Skype mit Devicelock DLP</a></li>
<li><a href="../de429574/index.html">Kostenloser Check Point für Anfängerkurs bei CheckMates</a></li>
<li><a href="../de429578/index.html">Welche Fehler sind im Infer.NET-Code versteckt?</a></li>
<li><a href="../de429582/index.html">Analoge Anzeige der Computerlast</a></li>
<li><a href="../de429586/index.html">So bestimmen Sie den besten Zeitpunkt für den Handel an der Börse</a></li>
<li><a href="../de429588/index.html">Die ganze Wahrheit über RTOS. Artikel Nr. 20. Semaphoren: Nebendienstleistungen und Datenstrukturen</a></li>
<li><a href="../de429590/index.html">Sprachanalyse für SOLR-basierte Call Center</a></li>
<li><a href="../de429592/index.html">Wie Bankkarten die Wirtschaft beeinflussen und warum der Spielball nicht abhebt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>