<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïäÔ∏è üßíüèæ üë©üèø‚Äçü§ù‚Äçüë©üèΩ Toda la verdad sobre RTOS. Art√≠culo # 24. Colas: servicios auxiliares y estructuras de datos. ü§¶üèæ üíÇ üôéüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este art√≠culo, continuaremos considerando las colas. 

 Servicios de colas secundarias 
 Nucleus RTOS tiene cuatro llamadas API que proporcionan fu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toda la verdad sobre RTOS. Art√≠culo # 24. Colas: servicios auxiliares y estructuras de datos.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432804/"><img src="https://habrastorage.org/webt/j7/rf/kj/j7rfkj7abgipgl8ohotufkmukwa.jpeg"><br><br>  En este art√≠culo, continuaremos considerando las colas. <br><br><h2>  Servicios de colas secundarias </h2><br>  Nucleus RTOS tiene cuatro llamadas API que proporcionan funciones auxiliares relacionadas con las colas: restablecer una cola, recibir informaci√≥n de la cola, obtener el n√∫mero de colas en una aplicaci√≥n y obtener punteros a todas las colas en una aplicaci√≥n.  Las primeras tres funciones se implementan en Nucleus SE. <br><a name="habracut"></a><br>  Art√≠culos anteriores de la serie: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Colas: introducci√≥n y servicios b√°sicos.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Buzones: servicios auxiliares y estructuras de datos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Buzones: Introducci√≥n y servicios b√°sicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sem√°foros: servicios auxiliares y estructuras de datos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sem√°foros: introducci√≥n y servicios b√°sicos.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Grupos de banderas de eventos: servicios auxiliares y estructuras de datos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Grupos de banderas de eventos: Introducci√≥n y servicios b√°sicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Se√±ales</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Particiones de memoria: servicios y estructuras de datos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Secciones de memoria: introducci√≥n y servicios b√°sicos.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estructuras de datos de tareas y llamadas de API no compatibles</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Servicios para trabajar con tareas.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas: configuraci√≥n e introducci√≥n a la API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Programador: funciones avanzadas y preservaci√≥n del contexto</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Programador: implementaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nucleus SE: dise√±o interno y despliegue</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">N√∫cleo SE: Introducci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Otros servicios RTOS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Interacci√≥n de tareas y sincronizaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas, cambio de contexto e interrupciones</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas y planificaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RTOS: estructura y modo en tiempo real</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RTOS: introducci√≥n.</a> <br><br><h3>  Restablecer cola </h3><br>  Esta llamada a la API restablece la cola a su estado original no utilizado.  Se perder√°n todos los mensajes almacenados en la cola.  Cualquier tarea pausada en la cola se reanudar√° con el c√≥digo de retorno <b>NUSE_QUEUE_WAS_RESET</b> . <br><br>  <b><i>Llamada de restablecimiento de cola en Nucleus RTOS</i></b> <br>  Prototipo de llamada de servicio: <br>  <b>ESTADO NU_Reset_Queue (cola NU_QUEUE *);</b> <br><br>  Par√°metros: <br>  <b>cola</b> : un puntero a un bloque de control de cola proporcionado por el usuario. <br><br>  Valor de retorno: <br>  <b>NU_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NU_INVALID_QUEUE</b> : puntero de cola no v√°lido. <br><br>  <b><i>Llamada de restablecimiento de cola en Nucleus SE</i></b> <br>  Esta llamada de utilidad admite la funcionalidad principal de la API Nucleus RTOS. <br><br>  Prototipo de llamada de servicio: <br>  <b>ESTADO NUSE_Queue_Reset (cola NUSE_QUEUE);</b> <br><br>  Par√°metros: <br>  <b>cola</b> - √≠ndice (ID) de la cola volcada. <br><br>  Valor de retorno: <br>  <b>NUSE_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NUSE_INVALID_QUEUE</b> : √≠ndice de cola no v√°lido. <br><br>  <b><i>Implementaci√≥n de restablecimiento de cola en Nucleus SE</i></b> <br>  El c√≥digo de la funci√≥n <b>NUSE_Queue_Reset</b> (despu√©s de verificar los par√°metros) es bastante simple.  Los √≠ndices de la cabecera y la cola de la cola, as√≠ como el contador de mensajes en la cola, tienen asignado un valor cero. <br><br>  Si se activa el bloqueo de tareas, el c√≥digo adicional es responsable de restaurar las tareas suspendidas: <br><br><pre><code class="plaintext hljs">while (NUSE_Queue_Blocking_Count[queue] != 0) { U8 index; /* check whether any tasks are blocked */ /* on this queue */ for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_QUEUE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == queue)) { NUSE_Task_Blocking_Return[index] = NUSE_QUEUE_WAS_RESET; NUSE_Task_Status[index] = NUSE_READY; break; } } NUSE_Queue_Blocking_Count[queue]--; } #if NUSE_SCHEDULER_TYPE == NUSE_PRIORITY_SCHEDULER NUSE_Reschedule(NUSE_NO_TASK); #endif</code> </pre> <br>  A cada tarea en pausa en la cola se le asigna un estado "listo" con un c√≥digo de retorno de <b>NUSE_QUEUE_WAS_RESET</b> .  Una vez completado este proceso, si se utiliza el planificador prioritario, se <b>llama a la</b> funci√≥n <b>NUSE_Reschedule ()</b> , ya que una o m√°s tareas con alta prioridad pueden estar listas para ejecutarse. <br><br><h3>  Obteniendo informaci√≥n de la cola </h3><br>  Esta llamada de servicio proporciona informaci√≥n de la cola.  La implementaci√≥n de esta llamada en Nucleus SE difiere de Nucleus RTOS en que devuelve menos informaci√≥n, ya que la denominaci√≥n de objetos, la longitud variable del mensaje y el orden de pausa de la tarea no son compatibles, y el bloqueo de la tarea puede desactivarse. <br><br>  <b><i>Convocatoria de informaci√≥n de cola en Nucleus RTOS</i></b> <br>  Prototipo de llamada de servicio: <br><br>  <b>ESTADO NU_Queue_Information (NU_QUEUE * queue, CHAR * name, VOID ** start_address, UNSIGNED * queue_size, UNSIGNED * available, UNSIGNED * messages, OPTION * message_type, UNSIGNED * message_size, OPTION * suspend_type, UNSIGNED * first_task_k_</b> <br><br>  Par√°metros: <br><br>  <b>cola</b> : un puntero a un bloque de control de cola proporcionado por el usuario; <br>  <b>nombre</b> : puntero a la regi√≥n de 8 caracteres para el nombre del mensaje en la cola; <br>  <b>start_address</b> : un puntero a un puntero en el que se escribir√° la direcci√≥n del comienzo del √°rea de datos de la cola; <br>  <b>queue_size</b> : un puntero a una variable para almacenar el n√∫mero total de elementos <b>SIN FIRMAR</b> en la cola; <br>  <b>disponible</b> : un puntero a una variable para almacenar el n√∫mero de elementos <b>SIN FIRMAR</b> disponibles en la cola; <br>  mensajes: un puntero a una variable para almacenar el n√∫mero actual de mensajes en la cola; <br>  <b>message_type</b> : un puntero a una variable para almacenar el tipo de mensajes admitidos por la cola.  Los valores v√°lidos son <b>NU_FIXED_SIZE</b> y <b>NU_VARIABLE</b> ; <br>  <b>message_size</b> : un puntero a una variable para almacenar el n√∫mero de elementos de datos <b>SIN FIRMAR</b> en cada mensaje de la cola.  Si la cola admite mensajes de longitud variable, este n√∫mero indica la longitud m√°xima del mensaje; <br>  <b>suspend_type</b> : un puntero a una variable para almacenar el tipo de suspensi√≥n de tareas.  Los valores v√°lidos son <b>NU_FIFO</b> y <b>NU_PRIORITY</b> ; <br>  <b>task_waiting</b> : un puntero a una variable para almacenar el n√∫mero de tareas suspendidas en esta cola; <br>  <b>first_task</b> : puntero al puntero de la tarea, en el que se coloca el puntero de la primera tarea suspendida. <br><br>  Valor de retorno: <br><br>  <b>NU_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NU_INVALID_QUEUE</b> : puntero de cola no v√°lido. <br><br>  <b><i>Llame para obtener informaci√≥n sobre la cola en Nucleus SE</i></b> <br>  Esta llamada a la API admite la funcionalidad principal de la API Nucleus RTOS. <br><br>  Prototipo de llamada de servicio: <br><br>  <b>ESTADO NUSE_Queue_Information (cola NUSE_QUEUE, ADDR * start_address, U8 * queue_size, U8 * disponible, U8 * mensajes, U8 * task_waiting, NUSE_TASK * first_task);</b> <br><br>  Par√°metros: <br><br>  <b>cola</b> - √≠ndice de la cola sobre la que se solicita informaci√≥n; <br>  <b>start_address</b> : un puntero a una variable de tipo <b>ADDR</b> , en la que se almacenar√° la direcci√≥n del comienzo del √°rea de datos de la cola; <br>  <b>queue_size</b> : un puntero a una variable de tipo <b>U8</b> , que almacenar√° el n√∫mero total de mensajes que pueden caber en la cola; <br>  <b>disponible</b> : un puntero a una variable de tipo <b>U8</b> , que almacenar√° el n√∫mero de lugares libres en la cola; <br>  <b>mensajes</b> : un puntero a una variable de tipo <b>U8</b> , que almacenar√° el n√∫mero actual de mensajes en la cola; <br>  <b>task_waiting</b> : un puntero a una variable en la que se almacenar√° el n√∫mero de tareas suspendidas en esta cola (no se devuelve nada si el bloqueo de tareas est√° desactivado); <br>  <b>first_task</b> : un puntero a una variable del tipo <b>NUSE_TASK</b> en la que se almacenar√° el √≠ndice de la primera tarea suspendida (no se devuelve nada si el bloqueo de la tarea est√° desactivado). <br><br>  Valor de retorno: <br><br>  <b>NUSE_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NUSE_INVALID_QUEUE</b> : √≠ndice de cola no v√°lido; <br>  <b>NUSE_INVALID_POINTER</b> : uno o m√°s par√°metros de puntero son incorrectos. <br><br>  <b><i>Implementaci√≥n de visualizaci√≥n de informaci√≥n de cola en Nucleus SE</i></b> <br><br>  Implementar esta llamada a la API es bastante simple: <br><br><pre> <code class="plaintext hljs">*start_address = NUSE_Queue_Data[queue]; *queue_size = NUSE_Queue_Size[queue]; *available = NUSE_Queue_Size[queue] - NUSE_Queue_Items[queue]; *messages = NUSE_Queue_Items[queue]; #if NUSE_BLOCKING_ENABLE *tasks_waiting = NUSE_Queue_Blocking_Count[queue]; if (NUSE_Queue_Blocking_Count[queue] != 0) { U8 index; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_QUEUE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == queue)) { *first_task = index; break; } } } else { *first_task = 0; } #else *tasks_waiting = 0; *first_task = 0; #endif</code> </pre><br>  La funci√≥n devuelve el estado de la cola.  Luego, si se activa el bloqueo de tareas, se devuelve el n√∫mero de tareas pendientes y el √≠ndice de la primera de ellas (de lo contrario, ambos par√°metros se establecen en 0). <br><br><h3>  Obtener el n√∫mero de colas </h3><br>  Esta llamada de utilidad devuelve el n√∫mero de colas configuradas en la aplicaci√≥n.  En Nucleus RTOS, su n√∫mero puede cambiar con el tiempo, y el valor de retorno indicar√° el n√∫mero actual de colas.  En Nucleus SE, el valor de retorno se establece durante la fase de construcci√≥n y no se puede cambiar. <br><br>  <b><i>Llamar al contador de colas en Nucleus RTOS</i></b> <br>  Prototipo de llamada de servicio: <br>  <b>NU_Nuevo_Establecido_Cosas (ANULADO);</b> <br><br>  Par√°metros: <br>  Est√°n ausentes <br><br>  Valor de retorno: <br>  El n√∫mero de colas creadas en el sistema. <br><br>  <b><i>Llamar al contador de colas en Nucleus SE</i></b> <br>  Esta llamada a la API admite la funcionalidad principal de la API Nucleus RTOS. <br><br>  Prototipo de llamada de servicio: <br>  <b>U8 NUSE_Queue_Count (nulo);</b> <br><br>  Par√°metros: <br>  Est√°n ausentes <br><br>  Valor de retorno: <br>  El n√∫mero de colas configuradas en la aplicaci√≥n. <br><br>  <b><i>Implementaci√≥n del contador de cola en Nucleus SE</i></b> <br>  La implementaci√≥n de esta llamada a la API es muy simple: se <b>devuelve</b> el valor del s√≠mbolo <b>#define</b> <b>NUSE_QUEUE_NUMBER</b> . <br><br><h2>  Estructuras de datos </h2><br>  Las colas usan cinco o seis estructuras de datos (que est√°n en RAM o ROM), que son conjuntos de tablas (como otros objetos de Nucleus SE), cuyo n√∫mero y tama√±o corresponden al n√∫mero de colas en la aplicaci√≥n y los par√°metros seleccionados. <br><br><h3>  Datos del kernel en RAM </h3><br>  Estos datos tienen la siguiente estructura: <br><br>  <b>NUSE_Queue_Head []</b> es una matriz de punteros de tipo <b>U8</b> , tiene una entrada para cada cola configurada y apunta al encabezado de la cola de mensajes.  Se utiliza como √≠ndice de direcci√≥n en <b>NUSE_Queue_Data []</b> (ver m√°s abajo); <br>  <b>NUSE_Queue_Tail []</b> es una matriz de tipo <b>U8</b> , tiene una entrada para cada cola configurada en la aplicaci√≥n y apunta a la cola de la cola de mensajes.  Se utiliza como √≠ndice de direcci√≥n en <b>NUSE_Queue_Data []</b> (ver m√°s abajo); <br>  <b>NUSE_Queue_Items []</b> es una matriz de tipo <b>U8</b> , tiene una entrada para cada cola configurada y es un contador de mensajes en la cola.  Estos datos pueden considerarse redundantes, ya que estos valores pueden obtenerse a trav√©s de los √≠ndices del principio y el final de la cola, sin embargo, almacenar el contador simplifica el c√≥digo; <br>  <b>NUSE_Queue_Blocking_Count []</b> : esta matriz de tipo <b>U8</b> contiene contadores del n√∫mero de tareas suspendidas en cada cola.  Esta matriz solo se crea si el soporte de bloqueo de tareas est√° activado. <br><br>  Estas estructuras de datos se inicializan a ceros mediante la funci√≥n <b>NUSE_Init_Queue ()</b> cuando se inicia Nucleus SE.  Esto es l√≥gico, ya que todas las colas se crean vac√≠as (no se usan). <br><br>  Las siguientes son las definiciones de estas estructuras en el archivo <b>nuse_init.c</b> : <br><br><pre> <code class="plaintext hljs">RAM U8 NUSE_Queue_Head[NUSE_QUEUE_NUMBER]; RAM U8 NUSE_Queue_Tail[NUSE_QUEUE_NUMBER]; RAM U8 NUSE_Queue_Items[NUSE_QUEUE_NUMBER]; #if NUSE_BLOCKING_ENABLE RAM U8 NUSE_Queue_Blocking_Count[NUSE_QUEUE_NUMBER]; #endif</code> </pre><br><h3>  Datos de usuario RAM </h3><br>  El usuario es responsable de proporcionar un √°rea de RAM para almacenar cada cola.  El tama√±o de esta √°rea debe contener una matriz de tipo <b>ADDR</b> , en el que cada registro corresponde a un mensaje en la cola <br><br><h3>  Datos ROM </h3><br>  Estos datos tienen la siguiente estructura: <br><br>  <b>NUSE_Queue_Data []</b> : una matriz de tipo <b>ADDR</b> , tiene una entrada para cada cola configurada y apunta al √°rea de datos de la cola (ver. Datos de RAM del usuario); <br>  <b>NUSE_Queue_Size []</b> : una matriz de tipo <b>U8</b> , tiene una entrada para cada cola configurada y muestra el n√∫mero m√°ximo de mensajes que puede recibir cada cola. <br><br>  Estas estructuras de datos se declaran e inicializan (est√°ticamente) en el archivo <b>nuse_config.c</b> : <br><br><pre> <code class="plaintext hljs">ROM ADDR *NUSE_Queue_Data[NUSE_QUEUE_NUMBER] = { /* addresses of queue data areas ------ */ }; ROM U8 NUSE_Queue_Size[NUSE_QUEUE_NUMBER] = { /* queue sizes ------ */ };</code> </pre><br><h3>  La cantidad de memoria para las colas. </h3><br>  Como todos los objetos del n√∫cleo de Nucleus SE, la cantidad de memoria necesaria para las colas es f√°cilmente predecible. <br><br>  La cantidad de datos en ROM (en bytes) para todas las colas en la aplicaci√≥n se puede calcular de la siguiente manera: <br>  <b>NUSE_QUEUE_NUMBER * (sizeof (ADDR) + 1)</b> <br><br>  La cantidad de datos del kernel en RAM (en bytes) para todas las colas en la aplicaci√≥n con el bloqueo de tareas activado se calcula de la siguiente manera: <br>  <b>NUSE_QUEUE_NUMBER * 3</b> <br><br>  Si el bloqueo est√° desactivado: <br>  <b>NUSE_QUEUE_NUMBER * 4</b> <br><br>  La cantidad de datos de usuario en RAM (en bytes) para la cola con el √≠ndice de <b>cola</b> : <br>  <b>NUSE_Queue_Size [cola] * sizeof (ADDR)</b> <br><br><h2>  Llamadas API no realizadas </h2><br>  Cuatro llamadas API que se pueden encontrar en Nucleus RTOS no se implementan en Nucleus SE: <br><br><h3>  Creaci√≥n de cola </h3><br>  Esta llamada a la API crea una cola; en Nucleus SE, esto no es necesario, ya que las colas se crean est√°ticamente. <br><br>  Prototipo de llamada de servicio: <br>  <b>ESTADO NU_Create_Queue (NU_QUEUE * queue, char * name, VOID * start_address, UNSIGNED queue_size, OPTION message_size, UNSIGNED message_size, OPTION suspend_type);</b> <br><br>  Par√°metros: <br><br>  <b>cola</b> : un puntero a una unidad de control proporcionada por el usuario; se usa para administrar colas en otras llamadas API; <br>  <b>nombre</b> : un puntero a un nombre de cola de 7 caracteres con un byte de terminaci√≥n nulo; <br>  <b>start_address</b> : direcci√≥n del comienzo de la cola; <br>  <b>message_type</b> : tipo de mensaje admitido por la cola.  Puede tomar los valores <b>NU_FIXED_SIZE</b> o <b>NU_VARIABLE_SIZE</b> ; <br>  <b>message_size</b> : si la cola admite mensajes de una longitud fija, este par√°metro establece la longitud exacta de cada mensaje; de ‚Äã‚Äãlo contrario, si la cola admite mensajes de longitud variable, este valor es la longitud m√°xima del mensaje; <br>  <b>suspend_type</b> : determina el tipo de tareas de suspensi√≥n en la cola.  Puede tomar los valores <b>NU_FIFO</b> y <b>NU_PRIORITY</b> , que significan el principio de FIFO (Primero en <b>entrar</b> , primero en salir) o el principio de prioridad de suspensi√≥n de tareas, respectivamente. <br><br>  Valor de retorno: <br><br>  <b>NU_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NU_INVALID_QUEUE</b> : puntero nulo al bloque de control de cola ( <b>NULL</b> ), o el puntero ya est√° en uso; <br>  <b>NU_INVALID_MEMORY</b> : √°rea de memoria no v√°lida especificada en <b>start_address</b> ; <br>  <b>NU_INVALID_MESSAGE</b> : par√°metro de tipo de <b>mensaje</b> no v√°lido; <br>  <b>NU_INVALID_SIZE</b> : la cola no admite mensajes de esta longitud, o el tama√±o de la cola y / o la longitud del mensaje es 0; <br>  <b>NU_INVALID_SUSPEND</b> : par√°metro inv√°lido <b>suspend_type</b> . <br><br><h3>  Eliminar cola </h3><br>  Esta llamada a la API elimina la cola creada anteriormente.  Nucleus SE no necesita esto porque las colas se crean de forma est√°tica y no se pueden eliminar. <br><br>  Prototipo de llamada de servicio: <br>  <b>ESTADO NU_Delete_Queue (cola NU_QUEUE *);</b> <br><br>  Par√°metros: <br>  <b>cola</b> : un puntero a un bloque de control de cola. <br><br>  Valor de retorno: <br>  <b>NU_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NU_INVALID_QUEUE</b> : puntero de cola no v√°lido. <br><br><h3>  Punteros de cola </h3><br>  Esta llamada a la API crea una lista secuencial de punteros a todas las colas en el sistema.  Nucleus SE no necesita esto porque las colas se identifican usando un √≠ndice simple, no un puntero. <br><br>  Prototipo de llamada de servicio: <br>  <b>NU_Queue_Pointers SIN FIRMAR (NU_QUEUE ** pointer_list, UNSIGNED maximum_pointers);</b> <br><br>  Par√°metros: <br>  <b>pointer_list</b> : puntero a una matriz de punteros <b>NU_QUEUE</b> .  Esta matriz se llenar√° con punteros a las colas creadas en el sistema; <br>  <b>maximum_pointers</b> : el n√∫mero m√°ximo de punteros en la matriz. <br><br>  Valor de retorno: <br>  El n√∫mero de punteros <b>NU_QUEUE</b> en la matriz. <br><br><h3>  En cola (Broadcast to Queue) </h3><br>  Esta llamada a la API pasa el mensaje a todas las tareas suspendidas en la cola que est√°n esperando mensajes de la cola especificada.  Esta caracter√≠stica no se implementa en Nucleus SE ya que agrega redundancia. <br><br>  Prototipo de llamada de servicio: <br>  <b>ESTADO NU_Broadcast_To_Queue (NU_QUEUE * queue, VOID * message, UNSIGNED size, UNSIGNED suspend);</b> <br><br>  Par√°metros: <br><br>  <b>cola</b> - un puntero a un bloque de control de cola; <br>  <b>mensaje</b> : puntero al mensaje transmitido; <br>  <b>tama√±o</b> : el n√∫mero de elementos <b>NO FIRMADOS</b> en el mensaje.  Si la cola admite mensajes de longitud variable, este par√°metro debe ser igual o menor que la longitud del mensaje admitida por la cola.  Si la cola admite mensajes de una longitud fija, este par√°metro debe ser igual a la longitud del mensaje admitido por la cola; <br>  <b>suspen</b> : indica si se suspende la tarea de llamada si la cola ya est√° llena.  Puede ser <b>NU_NO_SUSPEND</b> , <b>NU_SUSPEND</b> o un valor de tiempo de espera. <br><br>  Valor de retorno: <br><br>  <b>NU_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NU_INVALID_QUEUE</b> : puntero de cola no v√°lido; <br>  <b>NU_INVALID_POINTER</b> : puntero nulo a un mensaje ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> : la longitud del mensaje especificado no es compatible con la longitud especificada al crear la cola; <br>  <b>NU_INVALID_SUSPEND</b> : intenta pausar una tarea desde un hilo no asociado con la tarea; <br>  <b>NU_QUEUE_FULL</b> : no hay suficiente espacio en la cola para el mensaje; <br>  <b>NU_TIMEOUT</b> : la cola sigue llena despu√©s de que expira el tiempo de espera; <br>  <b>NU_QUEUE_DELETED</b> : la cola se elimin√≥ mientras se suspendi√≥ la tarea; <br>  <b>NU_QUEUE_RESET</b> : la cola se restableci√≥ mientras se suspend√≠a la tarea. <br><br><h2>  Nucleus RTOS Compatible </h2><br>  Al igual que con todos los dem√°s objetos de Nucleus SE, mi objetivo era maximizar la compatibilidad del c√≥digo de la aplicaci√≥n con Nucleus RTOS.  Las colas no son una excepci√≥n y, desde el punto de vista del usuario, se implementan de la misma manera que en Nucleus RTOS.  Tambi√©n hay una cierta incompatibilidad, que consider√© aceptable, dado que, como resultado, el c√≥digo ser√° m√°s comprensible y m√°s eficiente en t√©rminos de la cantidad de memoria requerida.  De lo contrario, las llamadas a la API de Nucleus RTOS se pueden transferir casi directamente a Nucleus SE. <br><br><h3>  Identificadores de objetos </h3><br>  En Nucleus RTOS, todos los objetos se describen mediante una estructura de datos (unidades de control) que tiene un tipo de datos espec√≠fico.  Un puntero a esta unidad de control sirve como un identificador para la cola.  Decid√≠ que en Nucleus SE, se necesita un enfoque diferente para el uso eficiente de la memoria: todos los objetos del n√∫cleo se describen mediante un conjunto de tablas en RAM y / o ROM.  El tama√±o de estas tablas est√° determinado por el n√∫mero de objetos configurados de cada tipo.  El identificador de un objeto particular es el √≠ndice en esta tabla.  As√≠ que <b>defin√≠ NUSE_QUEUE</b> como el equivalente de <b>U8</b> , una variable (no un puntero) de este tipo sirve como identificador de la cola.  Esta ligera incompatibilidad es f√°cil de manejar si el c√≥digo se transfiere de Nucleus SE a Nucleus RTOS y viceversa.  Por lo general, no se realizan operaciones en identificadores de objetos que no sean mover y almacenar. <br><br>  Nucleus RTOS tambi√©n admite nombres de colas.  Estos nombres se usan solo para la depuraci√≥n.  Los exclu√≠ de Nucleus SE para ahorrar memoria. <br><br><h3>  Tama√±o y tipo de mensaje </h3><br>  En Nucleus RTOS, se puede configurar una cola para procesar mensajes que consisten en cualquier n√∫mero de elementos <b>sin firmar</b> .  En Nucleus SE, las colas se simplifican y solo admiten mensajes de tipo <b>ADDR</b> individuales.  Los canales de datos de Nucleus SE son un poco m√°s flexibles y pueden ser una alternativa √∫til a las colas en algunos casos.  Los canales ser√°n cubiertos en los pr√≥ximos dos art√≠culos de esta serie. <br><br>  Nucleus SE tambi√©n admite colas de mensajes de longitud variable, que especifican solo la longitud m√°xima del mensaje durante la creaci√≥n.  Nucleus SE no admite longitudes de mensaje variables <br><br><h3>  Tama√±o de cola </h3><br>  En Nucleus SE, el n√∫mero m√°ximo de mensajes en una cola es 256, ya que todas las variables y constantes son del tipo <b>U8</b> .  Nucleus RTOS no tiene tales limitaciones. <br><br><h3>  Llamadas API no realizadas </h3><br>  Nucleus RTOS admite diez llamadas de gesti√≥n de colas.  De estos, cuatro no est√°n implementados en Nucleus SE.  Los detalles de estas llamadas, as√≠ como los motivos de tal decisi√≥n, se pueden encontrar en este art√≠culo anterior, en la secci√≥n "Llamadas API no realizadas". <br><br>  El pr√≥ximo art√≠culo discutir√° los canales de transmisi√≥n de datos. <br><br>  <b>Sobre el autor:</b> Colin Walls ha trabajado en la industria electr√≥nica durante m√°s de treinta a√±os, dedicando la mayor parte de su tiempo al firmware.  Ahora es ingeniero de firmware en Mentor Embedded (una divisi√≥n de Mentor Graphics).  Colin Walls a menudo habla en conferencias y seminarios, autor de numerosos art√≠culos t√©cnicos y dos libros sobre firmware.  Vive en el Reino Unido.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Blog</a> profesional <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de Colin</a> , correo electr√≥nico: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es432804/">https://habr.com/ru/post/es432804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es432794/index.html">Bret Victor: algunas palabras sobre Douglas Engelbart</a></li>
<li><a href="../es432796/index.html">M√≥dulo de c√≥mputo, modelos 2019</a></li>
<li><a href="../es432798/index.html">Mejor sistema operativo de seguridad: comparaci√≥n Titan</a></li>
<li><a href="../es432800/index.html">Investigaci√≥n de incidentes de seguridad con StaffCop Enterprise 4.4</a></li>
<li><a href="../es432802/index.html">Seis plataformas de aprendizaje de programaci√≥n automatizadas gratuitas</a></li>
<li><a href="../es432806/index.html">Superinteligencia: una idea que persigue a las personas inteligentes</a></li>
<li><a href="../es432808/index.html">Salarios en AI: donde hay m√°s dinero y a qui√©n buscan en Rusia</a></li>
<li><a href="../es432810/index.html">Primeras multas para GDPR: quien ya ha sido castigado</a></li>
<li><a href="../es432812/index.html">Escribimos robots comerciales utilizando el marco gr√°fico StockSharp. Parte 1</a></li>
<li><a href="../es432814/index.html">Integraci√≥n de Cake y TeamCity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>