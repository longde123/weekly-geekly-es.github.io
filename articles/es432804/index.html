<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕊️ 🧒🏾 👩🏿‍🤝‍👩🏽 Toda la verdad sobre RTOS. Artículo # 24. Colas: servicios auxiliares y estructuras de datos. 🤦🏾 💂 🙎🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este artículo, continuaremos considerando las colas. 

 Servicios de colas secundarias 
 Nucleus RTOS tiene cuatro llamadas API que proporcionan fu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toda la verdad sobre RTOS. Artículo # 24. Colas: servicios auxiliares y estructuras de datos.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432804/"><img src="https://habrastorage.org/webt/j7/rf/kj/j7rfkj7abgipgl8ohotufkmukwa.jpeg"><br><br>  En este artículo, continuaremos considerando las colas. <br><br><h2>  Servicios de colas secundarias </h2><br>  Nucleus RTOS tiene cuatro llamadas API que proporcionan funciones auxiliares relacionadas con las colas: restablecer una cola, recibir información de la cola, obtener el número de colas en una aplicación y obtener punteros a todas las colas en una aplicación.  Las primeras tres funciones se implementan en Nucleus SE. <br><a name="habracut"></a><br>  Artículos anteriores de la serie: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Artículo 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Colas: introducción y servicios básicos.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Artículo # 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Buzones: servicios auxiliares y estructuras de datos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Artículo # 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Buzones: Introducción y servicios básicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Artículo # 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Semáforos: servicios auxiliares y estructuras de datos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Artículo # 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Semáforos: introducción y servicios básicos.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Artículo # 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Grupos de banderas de eventos: servicios auxiliares y estructuras de datos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Artículo # 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Grupos de banderas de eventos: Introducción y servicios básicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Artículo # 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Señales</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Artículo # 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Particiones de memoria: servicios y estructuras de datos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Artículo # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Secciones de memoria: introducción y servicios básicos.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Artículo 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estructuras de datos de tareas y llamadas de API no compatibles</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Artículo # 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Servicios para trabajar con tareas.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Artículo # 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas: configuración e introducción a la API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Artículo # 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Programador: funciones avanzadas y preservación del contexto</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Artículo # 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Programador: implementación</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Artículo # 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nucleus SE: diseño interno y despliegue</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Artículo # 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Núcleo SE: Introducción</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Artículo # 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Otros servicios RTOS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Artículo # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Interacción de tareas y sincronización</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Artículo # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas, cambio de contexto e interrupciones</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Artículo # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas y planificación</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Artículo # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RTOS: estructura y modo en tiempo real</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Artículo # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RTOS: introducción.</a> <br><br><h3>  Restablecer cola </h3><br>  Esta llamada a la API restablece la cola a su estado original no utilizado.  Se perderán todos los mensajes almacenados en la cola.  Cualquier tarea pausada en la cola se reanudará con el código de retorno <b>NUSE_QUEUE_WAS_RESET</b> . <br><br>  <b><i>Llamada de restablecimiento de cola en Nucleus RTOS</i></b> <br>  Prototipo de llamada de servicio: <br>  <b>ESTADO NU_Reset_Queue (cola NU_QUEUE *);</b> <br><br>  Parámetros: <br>  <b>cola</b> : un puntero a un bloque de control de cola proporcionado por el usuario. <br><br>  Valor de retorno: <br>  <b>NU_SUCCESS</b> : la llamada se completó correctamente; <br>  <b>NU_INVALID_QUEUE</b> : puntero de cola no válido. <br><br>  <b><i>Llamada de restablecimiento de cola en Nucleus SE</i></b> <br>  Esta llamada de utilidad admite la funcionalidad principal de la API Nucleus RTOS. <br><br>  Prototipo de llamada de servicio: <br>  <b>ESTADO NUSE_Queue_Reset (cola NUSE_QUEUE);</b> <br><br>  Parámetros: <br>  <b>cola</b> - índice (ID) de la cola volcada. <br><br>  Valor de retorno: <br>  <b>NUSE_SUCCESS</b> : la llamada se completó correctamente; <br>  <b>NUSE_INVALID_QUEUE</b> : índice de cola no válido. <br><br>  <b><i>Implementación de restablecimiento de cola en Nucleus SE</i></b> <br>  El código de la función <b>NUSE_Queue_Reset</b> (después de verificar los parámetros) es bastante simple.  Los índices de la cabecera y la cola de la cola, así como el contador de mensajes en la cola, tienen asignado un valor cero. <br><br>  Si se activa el bloqueo de tareas, el código adicional es responsable de restaurar las tareas suspendidas: <br><br><pre><code class="plaintext hljs">while (NUSE_Queue_Blocking_Count[queue] != 0) { U8 index; /* check whether any tasks are blocked */ /* on this queue */ for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_QUEUE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == queue)) { NUSE_Task_Blocking_Return[index] = NUSE_QUEUE_WAS_RESET; NUSE_Task_Status[index] = NUSE_READY; break; } } NUSE_Queue_Blocking_Count[queue]--; } #if NUSE_SCHEDULER_TYPE == NUSE_PRIORITY_SCHEDULER NUSE_Reschedule(NUSE_NO_TASK); #endif</code> </pre> <br>  A cada tarea en pausa en la cola se le asigna un estado "listo" con un código de retorno de <b>NUSE_QUEUE_WAS_RESET</b> .  Una vez completado este proceso, si se utiliza el planificador prioritario, se <b>llama a la</b> función <b>NUSE_Reschedule ()</b> , ya que una o más tareas con alta prioridad pueden estar listas para ejecutarse. <br><br><h3>  Obteniendo información de la cola </h3><br>  Esta llamada de servicio proporciona información de la cola.  La implementación de esta llamada en Nucleus SE difiere de Nucleus RTOS en que devuelve menos información, ya que la denominación de objetos, la longitud variable del mensaje y el orden de pausa de la tarea no son compatibles, y el bloqueo de la tarea puede desactivarse. <br><br>  <b><i>Convocatoria de información de cola en Nucleus RTOS</i></b> <br>  Prototipo de llamada de servicio: <br><br>  <b>ESTADO NU_Queue_Information (NU_QUEUE * queue, CHAR * name, VOID ** start_address, UNSIGNED * queue_size, UNSIGNED * available, UNSIGNED * messages, OPTION * message_type, UNSIGNED * message_size, OPTION * suspend_type, UNSIGNED * first_task_k_</b> <br><br>  Parámetros: <br><br>  <b>cola</b> : un puntero a un bloque de control de cola proporcionado por el usuario; <br>  <b>nombre</b> : puntero a la región de 8 caracteres para el nombre del mensaje en la cola; <br>  <b>start_address</b> : un puntero a un puntero en el que se escribirá la dirección del comienzo del área de datos de la cola; <br>  <b>queue_size</b> : un puntero a una variable para almacenar el número total de elementos <b>SIN FIRMAR</b> en la cola; <br>  <b>disponible</b> : un puntero a una variable para almacenar el número de elementos <b>SIN FIRMAR</b> disponibles en la cola; <br>  mensajes: un puntero a una variable para almacenar el número actual de mensajes en la cola; <br>  <b>message_type</b> : un puntero a una variable para almacenar el tipo de mensajes admitidos por la cola.  Los valores válidos son <b>NU_FIXED_SIZE</b> y <b>NU_VARIABLE</b> ; <br>  <b>message_size</b> : un puntero a una variable para almacenar el número de elementos de datos <b>SIN FIRMAR</b> en cada mensaje de la cola.  Si la cola admite mensajes de longitud variable, este número indica la longitud máxima del mensaje; <br>  <b>suspend_type</b> : un puntero a una variable para almacenar el tipo de suspensión de tareas.  Los valores válidos son <b>NU_FIFO</b> y <b>NU_PRIORITY</b> ; <br>  <b>task_waiting</b> : un puntero a una variable para almacenar el número de tareas suspendidas en esta cola; <br>  <b>first_task</b> : puntero al puntero de la tarea, en el que se coloca el puntero de la primera tarea suspendida. <br><br>  Valor de retorno: <br><br>  <b>NU_SUCCESS</b> : la llamada se completó correctamente; <br>  <b>NU_INVALID_QUEUE</b> : puntero de cola no válido. <br><br>  <b><i>Llame para obtener información sobre la cola en Nucleus SE</i></b> <br>  Esta llamada a la API admite la funcionalidad principal de la API Nucleus RTOS. <br><br>  Prototipo de llamada de servicio: <br><br>  <b>ESTADO NUSE_Queue_Information (cola NUSE_QUEUE, ADDR * start_address, U8 * queue_size, U8 * disponible, U8 * mensajes, U8 * task_waiting, NUSE_TASK * first_task);</b> <br><br>  Parámetros: <br><br>  <b>cola</b> - índice de la cola sobre la que se solicita información; <br>  <b>start_address</b> : un puntero a una variable de tipo <b>ADDR</b> , en la que se almacenará la dirección del comienzo del área de datos de la cola; <br>  <b>queue_size</b> : un puntero a una variable de tipo <b>U8</b> , que almacenará el número total de mensajes que pueden caber en la cola; <br>  <b>disponible</b> : un puntero a una variable de tipo <b>U8</b> , que almacenará el número de lugares libres en la cola; <br>  <b>mensajes</b> : un puntero a una variable de tipo <b>U8</b> , que almacenará el número actual de mensajes en la cola; <br>  <b>task_waiting</b> : un puntero a una variable en la que se almacenará el número de tareas suspendidas en esta cola (no se devuelve nada si el bloqueo de tareas está desactivado); <br>  <b>first_task</b> : un puntero a una variable del tipo <b>NUSE_TASK</b> en la que se almacenará el índice de la primera tarea suspendida (no se devuelve nada si el bloqueo de la tarea está desactivado). <br><br>  Valor de retorno: <br><br>  <b>NUSE_SUCCESS</b> : la llamada se completó correctamente; <br>  <b>NUSE_INVALID_QUEUE</b> : índice de cola no válido; <br>  <b>NUSE_INVALID_POINTER</b> : uno o más parámetros de puntero son incorrectos. <br><br>  <b><i>Implementación de visualización de información de cola en Nucleus SE</i></b> <br><br>  Implementar esta llamada a la API es bastante simple: <br><br><pre> <code class="plaintext hljs">*start_address = NUSE_Queue_Data[queue]; *queue_size = NUSE_Queue_Size[queue]; *available = NUSE_Queue_Size[queue] - NUSE_Queue_Items[queue]; *messages = NUSE_Queue_Items[queue]; #if NUSE_BLOCKING_ENABLE *tasks_waiting = NUSE_Queue_Blocking_Count[queue]; if (NUSE_Queue_Blocking_Count[queue] != 0) { U8 index; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_QUEUE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == queue)) { *first_task = index; break; } } } else { *first_task = 0; } #else *tasks_waiting = 0; *first_task = 0; #endif</code> </pre><br>  La función devuelve el estado de la cola.  Luego, si se activa el bloqueo de tareas, se devuelve el número de tareas pendientes y el índice de la primera de ellas (de lo contrario, ambos parámetros se establecen en 0). <br><br><h3>  Obtener el número de colas </h3><br>  Esta llamada de utilidad devuelve el número de colas configuradas en la aplicación.  En Nucleus RTOS, su número puede cambiar con el tiempo, y el valor de retorno indicará el número actual de colas.  En Nucleus SE, el valor de retorno se establece durante la fase de construcción y no se puede cambiar. <br><br>  <b><i>Llamar al contador de colas en Nucleus RTOS</i></b> <br>  Prototipo de llamada de servicio: <br>  <b>NU_Nuevo_Establecido_Cosas (ANULADO);</b> <br><br>  Parámetros: <br>  Están ausentes <br><br>  Valor de retorno: <br>  El número de colas creadas en el sistema. <br><br>  <b><i>Llamar al contador de colas en Nucleus SE</i></b> <br>  Esta llamada a la API admite la funcionalidad principal de la API Nucleus RTOS. <br><br>  Prototipo de llamada de servicio: <br>  <b>U8 NUSE_Queue_Count (nulo);</b> <br><br>  Parámetros: <br>  Están ausentes <br><br>  Valor de retorno: <br>  El número de colas configuradas en la aplicación. <br><br>  <b><i>Implementación del contador de cola en Nucleus SE</i></b> <br>  La implementación de esta llamada a la API es muy simple: se <b>devuelve</b> el valor del símbolo <b>#define</b> <b>NUSE_QUEUE_NUMBER</b> . <br><br><h2>  Estructuras de datos </h2><br>  Las colas usan cinco o seis estructuras de datos (que están en RAM o ROM), que son conjuntos de tablas (como otros objetos de Nucleus SE), cuyo número y tamaño corresponden al número de colas en la aplicación y los parámetros seleccionados. <br><br><h3>  Datos del kernel en RAM </h3><br>  Estos datos tienen la siguiente estructura: <br><br>  <b>NUSE_Queue_Head []</b> es una matriz de punteros de tipo <b>U8</b> , tiene una entrada para cada cola configurada y apunta al encabezado de la cola de mensajes.  Se utiliza como índice de dirección en <b>NUSE_Queue_Data []</b> (ver más abajo); <br>  <b>NUSE_Queue_Tail []</b> es una matriz de tipo <b>U8</b> , tiene una entrada para cada cola configurada en la aplicación y apunta a la cola de la cola de mensajes.  Se utiliza como índice de dirección en <b>NUSE_Queue_Data []</b> (ver más abajo); <br>  <b>NUSE_Queue_Items []</b> es una matriz de tipo <b>U8</b> , tiene una entrada para cada cola configurada y es un contador de mensajes en la cola.  Estos datos pueden considerarse redundantes, ya que estos valores pueden obtenerse a través de los índices del principio y el final de la cola, sin embargo, almacenar el contador simplifica el código; <br>  <b>NUSE_Queue_Blocking_Count []</b> : esta matriz de tipo <b>U8</b> contiene contadores del número de tareas suspendidas en cada cola.  Esta matriz solo se crea si el soporte de bloqueo de tareas está activado. <br><br>  Estas estructuras de datos se inicializan a ceros mediante la función <b>NUSE_Init_Queue ()</b> cuando se inicia Nucleus SE.  Esto es lógico, ya que todas las colas se crean vacías (no se usan). <br><br>  Las siguientes son las definiciones de estas estructuras en el archivo <b>nuse_init.c</b> : <br><br><pre> <code class="plaintext hljs">RAM U8 NUSE_Queue_Head[NUSE_QUEUE_NUMBER]; RAM U8 NUSE_Queue_Tail[NUSE_QUEUE_NUMBER]; RAM U8 NUSE_Queue_Items[NUSE_QUEUE_NUMBER]; #if NUSE_BLOCKING_ENABLE RAM U8 NUSE_Queue_Blocking_Count[NUSE_QUEUE_NUMBER]; #endif</code> </pre><br><h3>  Datos de usuario RAM </h3><br>  El usuario es responsable de proporcionar un área de RAM para almacenar cada cola.  El tamaño de esta área debe contener una matriz de tipo <b>ADDR</b> , en el que cada registro corresponde a un mensaje en la cola <br><br><h3>  Datos ROM </h3><br>  Estos datos tienen la siguiente estructura: <br><br>  <b>NUSE_Queue_Data []</b> : una matriz de tipo <b>ADDR</b> , tiene una entrada para cada cola configurada y apunta al área de datos de la cola (ver. Datos de RAM del usuario); <br>  <b>NUSE_Queue_Size []</b> : una matriz de tipo <b>U8</b> , tiene una entrada para cada cola configurada y muestra el número máximo de mensajes que puede recibir cada cola. <br><br>  Estas estructuras de datos se declaran e inicializan (estáticamente) en el archivo <b>nuse_config.c</b> : <br><br><pre> <code class="plaintext hljs">ROM ADDR *NUSE_Queue_Data[NUSE_QUEUE_NUMBER] = { /* addresses of queue data areas ------ */ }; ROM U8 NUSE_Queue_Size[NUSE_QUEUE_NUMBER] = { /* queue sizes ------ */ };</code> </pre><br><h3>  La cantidad de memoria para las colas. </h3><br>  Como todos los objetos del núcleo de Nucleus SE, la cantidad de memoria necesaria para las colas es fácilmente predecible. <br><br>  La cantidad de datos en ROM (en bytes) para todas las colas en la aplicación se puede calcular de la siguiente manera: <br>  <b>NUSE_QUEUE_NUMBER * (sizeof (ADDR) + 1)</b> <br><br>  La cantidad de datos del kernel en RAM (en bytes) para todas las colas en la aplicación con el bloqueo de tareas activado se calcula de la siguiente manera: <br>  <b>NUSE_QUEUE_NUMBER * 3</b> <br><br>  Si el bloqueo está desactivado: <br>  <b>NUSE_QUEUE_NUMBER * 4</b> <br><br>  La cantidad de datos de usuario en RAM (en bytes) para la cola con el índice de <b>cola</b> : <br>  <b>NUSE_Queue_Size [cola] * sizeof (ADDR)</b> <br><br><h2>  Llamadas API no realizadas </h2><br>  Cuatro llamadas API que se pueden encontrar en Nucleus RTOS no se implementan en Nucleus SE: <br><br><h3>  Creación de cola </h3><br>  Esta llamada a la API crea una cola; en Nucleus SE, esto no es necesario, ya que las colas se crean estáticamente. <br><br>  Prototipo de llamada de servicio: <br>  <b>ESTADO NU_Create_Queue (NU_QUEUE * queue, char * name, VOID * start_address, UNSIGNED queue_size, OPTION message_size, UNSIGNED message_size, OPTION suspend_type);</b> <br><br>  Parámetros: <br><br>  <b>cola</b> : un puntero a una unidad de control proporcionada por el usuario; se usa para administrar colas en otras llamadas API; <br>  <b>nombre</b> : un puntero a un nombre de cola de 7 caracteres con un byte de terminación nulo; <br>  <b>start_address</b> : dirección del comienzo de la cola; <br>  <b>message_type</b> : tipo de mensaje admitido por la cola.  Puede tomar los valores <b>NU_FIXED_SIZE</b> o <b>NU_VARIABLE_SIZE</b> ; <br>  <b>message_size</b> : si la cola admite mensajes de una longitud fija, este parámetro establece la longitud exacta de cada mensaje; de ​​lo contrario, si la cola admite mensajes de longitud variable, este valor es la longitud máxima del mensaje; <br>  <b>suspend_type</b> : determina el tipo de tareas de suspensión en la cola.  Puede tomar los valores <b>NU_FIFO</b> y <b>NU_PRIORITY</b> , que significan el principio de FIFO (Primero en <b>entrar</b> , primero en salir) o el principio de prioridad de suspensión de tareas, respectivamente. <br><br>  Valor de retorno: <br><br>  <b>NU_SUCCESS</b> : la llamada se completó correctamente; <br>  <b>NU_INVALID_QUEUE</b> : puntero nulo al bloque de control de cola ( <b>NULL</b> ), o el puntero ya está en uso; <br>  <b>NU_INVALID_MEMORY</b> : área de memoria no válida especificada en <b>start_address</b> ; <br>  <b>NU_INVALID_MESSAGE</b> : parámetro de tipo de <b>mensaje</b> no válido; <br>  <b>NU_INVALID_SIZE</b> : la cola no admite mensajes de esta longitud, o el tamaño de la cola y / o la longitud del mensaje es 0; <br>  <b>NU_INVALID_SUSPEND</b> : parámetro inválido <b>suspend_type</b> . <br><br><h3>  Eliminar cola </h3><br>  Esta llamada a la API elimina la cola creada anteriormente.  Nucleus SE no necesita esto porque las colas se crean de forma estática y no se pueden eliminar. <br><br>  Prototipo de llamada de servicio: <br>  <b>ESTADO NU_Delete_Queue (cola NU_QUEUE *);</b> <br><br>  Parámetros: <br>  <b>cola</b> : un puntero a un bloque de control de cola. <br><br>  Valor de retorno: <br>  <b>NU_SUCCESS</b> : la llamada se completó correctamente; <br>  <b>NU_INVALID_QUEUE</b> : puntero de cola no válido. <br><br><h3>  Punteros de cola </h3><br>  Esta llamada a la API crea una lista secuencial de punteros a todas las colas en el sistema.  Nucleus SE no necesita esto porque las colas se identifican usando un índice simple, no un puntero. <br><br>  Prototipo de llamada de servicio: <br>  <b>NU_Queue_Pointers SIN FIRMAR (NU_QUEUE ** pointer_list, UNSIGNED maximum_pointers);</b> <br><br>  Parámetros: <br>  <b>pointer_list</b> : puntero a una matriz de punteros <b>NU_QUEUE</b> .  Esta matriz se llenará con punteros a las colas creadas en el sistema; <br>  <b>maximum_pointers</b> : el número máximo de punteros en la matriz. <br><br>  Valor de retorno: <br>  El número de punteros <b>NU_QUEUE</b> en la matriz. <br><br><h3>  En cola (Broadcast to Queue) </h3><br>  Esta llamada a la API pasa el mensaje a todas las tareas suspendidas en la cola que están esperando mensajes de la cola especificada.  Esta característica no se implementa en Nucleus SE ya que agrega redundancia. <br><br>  Prototipo de llamada de servicio: <br>  <b>ESTADO NU_Broadcast_To_Queue (NU_QUEUE * queue, VOID * message, UNSIGNED size, UNSIGNED suspend);</b> <br><br>  Parámetros: <br><br>  <b>cola</b> - un puntero a un bloque de control de cola; <br>  <b>mensaje</b> : puntero al mensaje transmitido; <br>  <b>tamaño</b> : el número de elementos <b>NO FIRMADOS</b> en el mensaje.  Si la cola admite mensajes de longitud variable, este parámetro debe ser igual o menor que la longitud del mensaje admitida por la cola.  Si la cola admite mensajes de una longitud fija, este parámetro debe ser igual a la longitud del mensaje admitido por la cola; <br>  <b>suspen</b> : indica si se suspende la tarea de llamada si la cola ya está llena.  Puede ser <b>NU_NO_SUSPEND</b> , <b>NU_SUSPEND</b> o un valor de tiempo de espera. <br><br>  Valor de retorno: <br><br>  <b>NU_SUCCESS</b> : la llamada se completó correctamente; <br>  <b>NU_INVALID_QUEUE</b> : puntero de cola no válido; <br>  <b>NU_INVALID_POINTER</b> : puntero nulo a un mensaje ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> : la longitud del mensaje especificado no es compatible con la longitud especificada al crear la cola; <br>  <b>NU_INVALID_SUSPEND</b> : intenta pausar una tarea desde un hilo no asociado con la tarea; <br>  <b>NU_QUEUE_FULL</b> : no hay suficiente espacio en la cola para el mensaje; <br>  <b>NU_TIMEOUT</b> : la cola sigue llena después de que expira el tiempo de espera; <br>  <b>NU_QUEUE_DELETED</b> : la cola se eliminó mientras se suspendió la tarea; <br>  <b>NU_QUEUE_RESET</b> : la cola se restableció mientras se suspendía la tarea. <br><br><h2>  Nucleus RTOS Compatible </h2><br>  Al igual que con todos los demás objetos de Nucleus SE, mi objetivo era maximizar la compatibilidad del código de la aplicación con Nucleus RTOS.  Las colas no son una excepción y, desde el punto de vista del usuario, se implementan de la misma manera que en Nucleus RTOS.  También hay una cierta incompatibilidad, que consideré aceptable, dado que, como resultado, el código será más comprensible y más eficiente en términos de la cantidad de memoria requerida.  De lo contrario, las llamadas a la API de Nucleus RTOS se pueden transferir casi directamente a Nucleus SE. <br><br><h3>  Identificadores de objetos </h3><br>  En Nucleus RTOS, todos los objetos se describen mediante una estructura de datos (unidades de control) que tiene un tipo de datos específico.  Un puntero a esta unidad de control sirve como un identificador para la cola.  Decidí que en Nucleus SE, se necesita un enfoque diferente para el uso eficiente de la memoria: todos los objetos del núcleo se describen mediante un conjunto de tablas en RAM y / o ROM.  El tamaño de estas tablas está determinado por el número de objetos configurados de cada tipo.  El identificador de un objeto particular es el índice en esta tabla.  Así que <b>definí NUSE_QUEUE</b> como el equivalente de <b>U8</b> , una variable (no un puntero) de este tipo sirve como identificador de la cola.  Esta ligera incompatibilidad es fácil de manejar si el código se transfiere de Nucleus SE a Nucleus RTOS y viceversa.  Por lo general, no se realizan operaciones en identificadores de objetos que no sean mover y almacenar. <br><br>  Nucleus RTOS también admite nombres de colas.  Estos nombres se usan solo para la depuración.  Los excluí de Nucleus SE para ahorrar memoria. <br><br><h3>  Tamaño y tipo de mensaje </h3><br>  En Nucleus RTOS, se puede configurar una cola para procesar mensajes que consisten en cualquier número de elementos <b>sin firmar</b> .  En Nucleus SE, las colas se simplifican y solo admiten mensajes de tipo <b>ADDR</b> individuales.  Los canales de datos de Nucleus SE son un poco más flexibles y pueden ser una alternativa útil a las colas en algunos casos.  Los canales serán cubiertos en los próximos dos artículos de esta serie. <br><br>  Nucleus SE también admite colas de mensajes de longitud variable, que especifican solo la longitud máxima del mensaje durante la creación.  Nucleus SE no admite longitudes de mensaje variables <br><br><h3>  Tamaño de cola </h3><br>  En Nucleus SE, el número máximo de mensajes en una cola es 256, ya que todas las variables y constantes son del tipo <b>U8</b> .  Nucleus RTOS no tiene tales limitaciones. <br><br><h3>  Llamadas API no realizadas </h3><br>  Nucleus RTOS admite diez llamadas de gestión de colas.  De estos, cuatro no están implementados en Nucleus SE.  Los detalles de estas llamadas, así como los motivos de tal decisión, se pueden encontrar en este artículo anterior, en la sección "Llamadas API no realizadas". <br><br>  El próximo artículo discutirá los canales de transmisión de datos. <br><br>  <b>Sobre el autor:</b> Colin Walls ha trabajado en la industria electrónica durante más de treinta años, dedicando la mayor parte de su tiempo al firmware.  Ahora es ingeniero de firmware en Mentor Embedded (una división de Mentor Graphics).  Colin Walls a menudo habla en conferencias y seminarios, autor de numerosos artículos técnicos y dos libros sobre firmware.  Vive en el Reino Unido.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Blog</a> profesional <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de Colin</a> , correo electrónico: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es432804/">https://habr.com/ru/post/es432804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es432794/index.html">Bret Victor: algunas palabras sobre Douglas Engelbart</a></li>
<li><a href="../es432796/index.html">Módulo de cómputo, modelos 2019</a></li>
<li><a href="../es432798/index.html">Mejor sistema operativo de seguridad: comparación Titan</a></li>
<li><a href="../es432800/index.html">Investigación de incidentes de seguridad con StaffCop Enterprise 4.4</a></li>
<li><a href="../es432802/index.html">Seis plataformas de aprendizaje de programación automatizadas gratuitas</a></li>
<li><a href="../es432806/index.html">Superinteligencia: una idea que persigue a las personas inteligentes</a></li>
<li><a href="../es432808/index.html">Salarios en AI: donde hay más dinero y a quién buscan en Rusia</a></li>
<li><a href="../es432810/index.html">Primeras multas para GDPR: quien ya ha sido castigado</a></li>
<li><a href="../es432812/index.html">Escribimos robots comerciales utilizando el marco gráfico StockSharp. Parte 1</a></li>
<li><a href="../es432814/index.html">Integración de Cake y TeamCity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>