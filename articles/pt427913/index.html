<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌽 🧝🏿 📢 Prólogo divertido # 2 📦 🐛 📼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá, comunidade de desenvolvedores , preciso terminar o trabalho. 


 Na minha obra anterior , houve um telefonema para mostrar como a linguagem Prolo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Prólogo divertido # 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427913/"><p>  Olá, <em>comunidade de desenvolvedores</em> , preciso terminar o trabalho. </p><br><p>  Na minha <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">obra</a> anterior <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">, houve</a> um telefonema para mostrar como a linguagem Prolog pode ser usada e para mostrar que seria engraçado.  Transforme-o em um exercício. </p><br><p>  Vou tentar continuar <del>  mostrar </del>  para demonstrar. </p><br><p>  Lembro-me brevemente da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tarefa:</a> </p><br><div class="spoiler">  <b class="spoiler_title">Correspondência curinga</b> <div class="spoiler_text"><p>  Dada uma sequência (s) de entrada e um padrão (p), implemente a correspondência de padrões curinga com suporte para '?'  e ' <em>'.</em> <em><br></em>  <em>'?'</em>  <em>Corresponde a qualquer caractere único.</em> <em><br></em>  <em>'</em> ' Corresponde a qualquer sequência de caracteres (incluindo a sequência vazia). <br>  A correspondência deve abranger toda a cadeia de entrada (não parcial). </p></div></div><br><p>  Não foi possível provar a integridade da solução.  No site que fornece a tarefa, existem 1808 testes que não podem ser vistos imediatamente, você precisa escrever um programa e fazer outro teste como erro. </p><br><p>  Hardcore, consegui 66 dele e verifiquei minha decisão - enquanto tudo funcionava.  Mas não pode ser assim tão simples. </p><br><p>  Por que tantos testes, quero verificar mais ... </p><br><p>  Vou tentar reescrever esta solução no idioma <del>  compreensível </del>  disponível neste sistema (eles refletem a popularidade das linguagens de programação modernas). </p><br><p>  Então, escolha Python. </p><a name="habracut"></a><br><p>  O poder do Prolog está no procedimento de busca, cujas raízes estão nos métodos de provar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">teoremas</a> .  Simplificando, ele possui um mecanismo de unificação e pesquisa embutido com um retorno.  É ainda mais simples dizer correspondência e pesquisa de profundidade através da árvore de decisão. </p><br><p>  E o Python é o Pascal moderno (já existem três idiomas com a letra "P"), e os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">alunos podem</a> escrever programas nele. </p><br><p>  Agora, reescreverei a solução estabelecida na implementação anterior e implementarei rapidamente uma pesquisa de prólogo semelhante com um retorno. </p><br><p>  Em seguida, iniciá-lo-ei no sistema de teste e verei se a movimentação (código) estava correta. </p><br><h1 id="prisoedinyaytes">  Inscreva-se agora. </h1><br><p>  Na entrada, a sequência e o padrão testados: </p><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(st,pat)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> st==<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pat==<span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pat&gt;<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pat[<span class="hljs-number"><span class="hljs-number">0</span></span>]==<span class="hljs-string"><span class="hljs-string">'*'</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> test(st,pat[<span class="hljs-number"><span class="hljs-number">1</span></span>:]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> st&gt;<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pat&gt;<span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> st[<span class="hljs-number"><span class="hljs-number">0</span></span>]==pat[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> pat[<span class="hljs-number"><span class="hljs-number">0</span></span>]==<span class="hljs-string"><span class="hljs-string">'?'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> test(st[<span class="hljs-number"><span class="hljs-number">1</span></span>:],pat[<span class="hljs-number"><span class="hljs-number">1</span></span>:]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pat[<span class="hljs-number"><span class="hljs-number">0</span></span>]==<span class="hljs-string"><span class="hljs-string">'*'</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> test(st[<span class="hljs-number"><span class="hljs-number">1</span></span>:],pat) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p>  Parece ser muito semelhante à implementação do Prolog: </p><br><pre> <code class="hljs powershell">test_pattrn([],[]). test_pattrn([<span class="hljs-type"><span class="hljs-type">Ch</span></span>|<span class="hljs-type"><span class="hljs-type">UnpTail</span></span>],[<span class="hljs-type"><span class="hljs-type">Ch</span></span>|<span class="hljs-type"><span class="hljs-type">PatTail</span></span>]):<span class="hljs-literal"><span class="hljs-literal">-test_pattrn</span></span>(UnpTail,PatTail). test_pattrn([<span class="hljs-type"><span class="hljs-type">Ch</span></span>|<span class="hljs-type"><span class="hljs-type">UnpTail</span></span>],[<span class="hljs-string"><span class="hljs-string">'?'</span></span>|<span class="hljs-type"><span class="hljs-type">PatTail</span></span>]):<span class="hljs-literal"><span class="hljs-literal">-test_pattrn</span></span>(UnpTail,PatTail). test_pattrn([<span class="hljs-type"><span class="hljs-type">Ch</span></span>|<span class="hljs-type"><span class="hljs-type">UnpTail</span></span>],[<span class="hljs-string"><span class="hljs-string">'*'</span></span>|<span class="hljs-type"><span class="hljs-type">PatTail</span></span>]):<span class="hljs-literal"><span class="hljs-literal">-test_pattrn</span></span>(UnpTail,[<span class="hljs-string"><span class="hljs-string">'*'</span></span>|<span class="hljs-type"><span class="hljs-type">PatTail</span></span>]). test_pattrn(Str,[<span class="hljs-string"><span class="hljs-string">'*'</span></span>|<span class="hljs-type"><span class="hljs-type">PatTail</span></span>]):<span class="hljs-literal"><span class="hljs-literal">-test_pattrn</span></span>(Str,PatTail).</code> </pre><br><p>  Cinco soluções, caso contrário, uma mentira. </p><br><p>  Mas como fazer uma pesquisa com retorno ?, para isso eu uso yield, como é chamado lá, cálculos inacabados (preguiçosos), fechamento, um elemento da abordagem funcional, diga-me ... Ele retornará algo do qual será possível buscar a solução a seguir, mas se Se isso não levar à resposta correta, iremos para a ramificação do programa com o próximo rendimento, essa é a diferença do retorno. </p><br><p>  Essa função aceitará o resultado do primeiro teste () se for verdade, tudo está bem; caso contrário, ele tentará iterar novamente e haverá uma pesquisa profunda semelhante ao comportamento da saída do prólogo. </p><br><p>  Aqui, o retorno é especificamente necessário aqui: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type(r)==bool: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r==<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> nr <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> r: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> run(nr):<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre><br><h1 id="proveryaem-1">  Verificação 1 </h1><br><p><img src="https://habrastorage.org/webt/b_/bd/qy/b_bdqy_ehypljwck0ihcbarfwhc.png"></p><br><p>  Uau, este é o resultado, "939/1808 casos de teste foram aprovados".  e "Status: limite de tempo excedido". <br>  Isso é exatamente o que eu esperava, uma solução declarativa nem sempre leva a uma implementação com tempo eficiente.  As palavras transparentes não são rápidas. </p><br><p>  Mas, aqui está o resultado do python, testaremos o teste aberto na implementação desde o primeiro artigo e mediremos o tempo: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time pt=time.time() print(run(test(<span class="hljs-string"><span class="hljs-string">"babaaababaabababbbbbbaabaabbabababbaababbaaabbbaaab"</span></span>,<span class="hljs-string"><span class="hljs-string">"***bba**a*bbba**aab**b"</span></span>))) print(time.time()-pt)</code> </pre> <br><p>  O tempo de execução do Python é 11,10963249206543 seg., Mas um pouco demais. </p><br><p>  Mecanismo de teste avançado para Prolog: </p><br><pre> <code class="hljs ruby">%unit-tests framework assert_are_equal(Goal, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)<span class="hljs-symbol"><span class="hljs-symbol">:-get_time</span></span>(St),<span class="hljs-keyword"><span class="hljs-keyword">not</span></span>(Goal),!,get_time(Fin),Per is Fin-St,writeln(Goal-&gt;<span class="hljs-symbol"><span class="hljs-symbol">ok:</span></span>Per/sec). assert_are_equal(Goal, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)<span class="hljs-symbol"><span class="hljs-symbol">:-</span></span> get_time(St),Goal, !,get_time(Fin),Per is Fin-St,writeln(Goal-&gt;<span class="hljs-symbol"><span class="hljs-symbol">ok:</span></span>Per/sec). assert_are_equal(Goal, Exp)<span class="hljs-symbol"><span class="hljs-symbol">:-writeln</span></span>(Goal-&gt;<span class="hljs-symbol"><span class="hljs-symbol">failed:</span></span>expected-Exp). <span class="hljs-symbol"><span class="hljs-symbol">:-assert_are_equal</span></span>(isMatch(aaabababaaabaababbbaaaabbbbbbabbbbabbbabbaabbababab,<span class="hljs-string"><span class="hljs-string">'*ab***ba**b*b*aaab*b'</span></span>),<span class="hljs-literal"><span class="hljs-literal">true</span></span>).</code> </pre><br><p>  E aqui está o resultado do Prolog (começando não no editor on-line, localmente, no mesmo hardware que o anterior): </p><br><pre> <code class="hljs markdown">isMatch(aaabababaaabaababbbaaaabbbbbbabbbbabbbabbaabbababab,<span class="hljs-emphasis"><span class="hljs-emphasis">*ab*</span></span><span class="hljs-strong"><span class="hljs-strong">**ba**</span></span>b<span class="hljs-emphasis"><span class="hljs-emphasis">*b*</span></span>aaab*b)-&gt;ok:2.208951950073242/sec</code> </pre> <br><p>  Parece que não estou usando bem o python ((, preciso aprimorá-lo, não é mais tão óbvio: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(st,pat)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> st==pat: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pat&gt;<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pat[<span class="hljs-number"><span class="hljs-number">0</span></span>]==<span class="hljs-string"><span class="hljs-string">'*'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> test(st,pat[<span class="hljs-number"><span class="hljs-number">1</span></span>:]):<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> st&gt;<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pat&gt;<span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> st[<span class="hljs-number"><span class="hljs-number">0</span></span>]==pat[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> pat[<span class="hljs-number"><span class="hljs-number">0</span></span>]==<span class="hljs-string"><span class="hljs-string">'?'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> test(st[<span class="hljs-number"><span class="hljs-number">1</span></span>:],pat[<span class="hljs-number"><span class="hljs-number">1</span></span>:]):<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pat[<span class="hljs-number"><span class="hljs-number">0</span></span>]==<span class="hljs-string"><span class="hljs-string">'*'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> test(st[<span class="hljs-number"><span class="hljs-number">1</span></span>:],pat):<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time pt=time.time() print(test(<span class="hljs-string"><span class="hljs-string">"babaaababaabababbbbbbaabaabbabababbaababbaaabbbaaab"</span></span>,<span class="hljs-string"><span class="hljs-string">"***bba**a*bbba**aab**b"</span></span>)) print(time.time()-pt)</code> </pre> <br><p>  Aqui está o resultado: 3.921879768371582 seg.  (isso é mais próximo do original).  Voltamos ao árbitro: </p><br><p><img src="https://habrastorage.org/webt/js/sj/q2/jssjq2qynkpuiuxxhgkauok69e8.png"></p><br><p>  E mais uma vez. </p><br><p><img src="https://habrastorage.org/webt/ak/fa/cs/akfacs0zye38rbwjujdmtprshru.png"></p><br><p>  Concluo que a passagem total dos testes ultrapassa o prazo, porque as duas últimas opções são resolvidas muito rapidamente. </p><br><p>  Precisamos de uma ordem de otimização de magnitude. </p><br><h1 id="proveryaem-2-nuzhna-optimizaciya">  Verificação 2. Precisamos de otimização. </h1><br><p>  O que implora com certeza é a busca pela primeira vez. </p><br><p>  Não continue a decisão de cada ramo até que possamos mentir e retornar a outro ramo, mas observe as decisões por níveis, descendo ao mesmo tempo para cada opção e gradualmente indo além. </p><br><p>  Vou tentar transformá-lo em python e depois demonstrarei o prólogo. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(st,pat)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> st==pat: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> res=[] <span class="hljs-comment"><span class="hljs-comment">#     ,    if pat&gt;"" and pat[0]=='*':res+=[(st,pat[1:])] if st&gt;"" and pat&gt;"": stt=st[1:] if st[0]==pat[0] or pat[0]=='?':res+=[(stt,pat[1:])] if pat[0]=='*':res+=[(stt,pat)] return res def run(st,pat): lev=[(st,pat)] while len(lev)!=0: nxt=set() ##        for s,p in lev: one=test(s,p) if one==True:return True else:nxt.update(set(one)) lev=nxt return False</span></span></code> </pre><br><p>  Já existe o resultado para o teste 939, apenas 0,01585698127746582 seg. <br>  e ... URA esta decisão é tomada </p><br><p><img src="https://habrastorage.org/webt/uk/cl/tg/ukcltg11trpklqys9xew7kiqou8.png"></p><br><h1 id="prolog">  Prólogo </h1><br><p>  Vou tentar mostrar como implementar uma pesquisa abrangente, em uma implementação declarativa.  Para fazer isso, existem predicados especiais de segunda ordem que podem coletar soluções em uma lista, por exemplo, bagof, setof, findall. </p><br><blockquote>  bagof (+ Modelo ,: Objetivo, -Bag) <br>  Unifique o Bag com as alternativas do Template.  Se o Objetivo tiver variáveis ​​livres além da compartilhada com o Modelo, o bagof / 3 retornará às alternativas dessas variáveis ​​livres, unificando o Saco às alternativas correspondentes do Modelo.  A construção + Var ^ Objetivo diz ao bagof / 3 para não vincular Var no Objetivo.  bagof / 3 falhará se a meta não tiver soluções. <br>  setof (+ Modelo, + Objetivo, -Set) <br>  Equivalente a bagof / 3, mas classifica o resultado usando sort / 2 para obter uma lista classificada de alternativas sem duplicatas. </blockquote><p>  O predicado Setof funciona bem desde  ele já sabe como remover duplicatas (em python, eu tive que aprender sobre conjuntos). </p><br><p>  Então, criarei um predicado que obtém uma solução de um nível, coleciono-o com outro predicado e vou mais fundo, eis a solução completa: </p><br><pre> <code class="hljs powershell">atom_to_list(Str,[<span class="hljs-type"><span class="hljs-type">Ch</span></span>|<span class="hljs-type"><span class="hljs-type">T</span></span>]) :- atom_concat(Ch,Rest,Str),atom_length(Ch,<span class="hljs-number"><span class="hljs-number">1</span></span>), atom_to_list(Rest,T). %  pattrn(X:X,true). %-      pattrn([<span class="hljs-type"><span class="hljs-type">Ch</span></span>|<span class="hljs-type"><span class="hljs-type">UnpTail</span></span>]:[<span class="hljs-type"><span class="hljs-type">Ch</span></span>|<span class="hljs-type"><span class="hljs-type">PatTail</span></span>],UnpTail:PatTail). pattrn([<span class="hljs-type"><span class="hljs-type">_</span></span>|<span class="hljs-type"><span class="hljs-type">UnpTail</span></span>]:[<span class="hljs-string"><span class="hljs-string">'?'</span></span>|<span class="hljs-type"><span class="hljs-type">PatTail</span></span>],UnpTail:PatTail). pattrn([<span class="hljs-type"><span class="hljs-type">_</span></span>|<span class="hljs-type"><span class="hljs-type">UnpTail</span></span>]:[<span class="hljs-string"><span class="hljs-string">'*'</span></span>|<span class="hljs-type"><span class="hljs-type">PatTail</span></span>],UnpTail:[<span class="hljs-string"><span class="hljs-string">'*'</span></span>|<span class="hljs-type"><span class="hljs-type">PatTail</span></span>]). pattrn(Str:[<span class="hljs-string"><span class="hljs-string">'*'</span></span>|<span class="hljs-type"><span class="hljs-type">PatTail</span></span>],Str:PatTail). %  true,     ,     next_level(Lev):<span class="hljs-literal"><span class="hljs-literal">-member</span></span>(true,Lev),!. next_level(Lev):<span class="hljs-literal"><span class="hljs-literal">-setof</span></span>(One,SP^(member(SP,Lev),pattrn(SP,One)),Next),!, next_level(Next). test_pattrn(Str,Pat):<span class="hljs-literal"><span class="hljs-literal">-next_level</span></span>([<span class="hljs-type"><span class="hljs-type">Str</span></span>:<span class="hljs-type"><span class="hljs-type">Pat</span></span>]). isMatch(S,P) :- atom_to_list(S,SL), atom_to_list(P,PL),!, test_pattrn(SL,PL),!. %unit<span class="hljs-literal"><span class="hljs-literal">-tests</span></span> framework assert_are_equal(Goal, false):<span class="hljs-literal"><span class="hljs-literal">-get_time</span></span>(St),not(Goal),!,get_time(Fin),Per is Fin<span class="hljs-literal"><span class="hljs-literal">-St</span></span>, writeln(Goal-&gt;ok:Per/sec). assert_are_equal(Goal, true):- get_time(St),Goal, !,get_time(Fin),Per is Fin<span class="hljs-literal"><span class="hljs-literal">-St</span></span>, writeln(Goal-&gt;ok:Per/sec). assert_are_equal(Goal, Exp):<span class="hljs-literal"><span class="hljs-literal">-writeln</span></span>(Goal-&gt;failed:expected<span class="hljs-literal"><span class="hljs-literal">-Exp</span></span>). %all test :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(aa,a),false). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(aa,<span class="hljs-string"><span class="hljs-string">'*'</span></span>),true). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(cb,<span class="hljs-string"><span class="hljs-string">'?a'</span></span>),false). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(adceb,<span class="hljs-string"><span class="hljs-string">'*a*b'</span></span>),true). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(acdcb,<span class="hljs-string"><span class="hljs-string">'a*c?b'</span></span>),false). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(aab,<span class="hljs-string"><span class="hljs-string">'c*a*b'</span></span>),false). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(mississippi,<span class="hljs-string"><span class="hljs-string">'m??*ss*?i*pi'</span></span>),false). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(abefcdgiescdfimde,<span class="hljs-string"><span class="hljs-string">'ab*cd?i*de'</span></span>),true). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(zacabz,<span class="hljs-string"><span class="hljs-string">'*a?b*'</span></span>),false). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(leetcode,<span class="hljs-string"><span class="hljs-string">'*e*t?d*'</span></span>),false). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(aaaa,<span class="hljs-string"><span class="hljs-string">'***a'</span></span>),true). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(b,<span class="hljs-string"><span class="hljs-string">'*?*?*'</span></span>),false). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(aaabababaaabaababbbaaaabbbbbbabbbbabbbabbaabbababab,<span class="hljs-string"><span class="hljs-string">'*ab***ba**b*b*aaab*b'</span></span>),true). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(abbbbbbbaabbabaabaa,<span class="hljs-string"><span class="hljs-string">'*****a*ab'</span></span>),false). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(aaabababaaabaababbbaaaabbbbbbabbbbabbbabbaabbababab,<span class="hljs-string"><span class="hljs-string">'*ab***ba**b*b*aaab*b'</span></span>),true). :<span class="hljs-literal"><span class="hljs-literal">-assert_are_equal</span></span>(isMatch(babaaababaabababbbbbbaabaabbabababbaababbaaabbbaaab,<span class="hljs-string"><span class="hljs-string">'***bba**a*bbba**aab**b'</span></span>),false).</code> </pre> <br><p>  Aqui você pode ver que a regra que anteriormente executou a pesquisa pelo modelo, como se estivesse fazendo uma transição ao longo da face no gráfico, agora se transformou em um conjunto de fatos que contêm possíveis transições (relações entre estados) - essa é uma descrição do gráfico e não um código que o implementa. </p><br><p>  E a execução resulta com tempo em segundos: </p><br><pre> <code class="hljs erlang-repl">isMatch(aa, a)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.00010013580322265625</span></span>/sec isMatch(aa, *)-&gt;ok:<span class="hljs-number"><span class="hljs-number">4.00543212890625e-5</span></span>/sec isMatch(cb, ?a)-&gt;ok:<span class="hljs-number"><span class="hljs-number">3.981590270996094e-5</span></span>/sec isMatch(adceb, *a*b)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.0001399517059326172</span></span>/sec isMatch(acdcb, a*c?b)-&gt;ok:<span class="hljs-number"><span class="hljs-number">9.989738464355469e-5</span></span>/sec isMatch(aab, c*a*b)-&gt;ok:<span class="hljs-number"><span class="hljs-number">4.00543212890625e-5</span></span>/sec isMatch(mississippi, m??*ss*?i*pi)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.0003399848937988281</span></span>/sec isMatch(abefcdgiescdfimde, ab*cd?i*de)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.0003600120544433594</span></span>/sec isMatch(zacabz, *a?b*)-&gt;ok:<span class="hljs-number"><span class="hljs-number">9.989738464355469e-5</span></span>/sec isMatch(leetcode, *e*t?d*)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.00020003318786621094</span></span>/sec isMatch(aaaa, ***a)-&gt;ok:<span class="hljs-number"><span class="hljs-number">9.989738464355469e-5</span></span>/sec isMatch(b, *?*?*)-&gt;ok:<span class="hljs-number"><span class="hljs-number">6.008148193359375e-5</span></span>/sec isMatch(aaabababaaabaababbbaaaabbbbbbabbbbabbbabbaabbababab, *ab***ba**b*b*aaab*b)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.0040400028228759766</span></span>/sec isMatch(abbbbbbbaabbabaabaa, *****a*ab)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.0006201267242431641</span></span>/sec isMatch(aaabababaaabaababbbaaaabbbbbbabbbbabbbabbaabbababab, *ab***ba**b*b*aaab*b)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.003679990768432617</span></span>/sec isMatch(babaaababaabababbbbbbaabaabbabababbaababbaaabbbaaab, ***bba**a*bbba**aab**b)-&gt;ok:<span class="hljs-number"><span class="hljs-number">0.002460002899169922</span></span>/sec</code> </pre> <br><p>  E essa já é uma solução bem-sucedida, não apenas logicamente, mas também com o tempo. </p><br><h1 id="vyvody">  Conclusões </h1><br><p>  Em um artigo anterior, eu queria ver interesse no tópico de uma abordagem declarativa.  O tópico "niasilil tal abordagem" foi aberto imediatamente, mas o interesse ainda pode ser demonstrado.  Aqui eu mostrei que há um problema de desempenho, o que está escrito claramente não funciona rapidamente.  Tentativas de criar um prólogo paralelo não tiveram êxito.  Talvez aqui esteja a questão do futuro, pode um computador quântico? <br>  Total usamos quebra-cabeças no site acima para um passatempo agradável com sabedoria. </p><br><p>  Bem, da próxima vez, haverá uma tentativa de resolver imediatamente mais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma tarefa difícil de maneira</a> eficaz. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt427913/">https://habr.com/ru/post/pt427913/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt427901/index.html">Como não usar a API de fluxo do Node.js.</a></li>
<li><a href="../pt427905/index.html">Mineração de alimentos ou encruzilhada através dos olhos de um hacker</a></li>
<li><a href="../pt427907/index.html">Tiro com drone, rake, hackers, autodesenvolvimento e carreira de um fotógrafo / videógrafo: novo podcast GLPH</a></li>
<li><a href="../pt427909/index.html">Python: como reduzir o consumo de memória pela metade adicionando apenas uma linha de código?</a></li>
<li><a href="../pt427911/index.html">Paixões de escritório</a></li>
<li><a href="../pt427915/index.html">Presunção de estupidez</a></li>
<li><a href="../pt427917/index.html">Resposta ao post da Presunção da Mente</a></li>
<li><a href="../pt427919/index.html">Portando COM para Linux</a></li>
<li><a href="../pt427921/index.html">4 vídeos sobre procrastinação</a></li>
<li><a href="../pt427923/index.html">Como adicionei um novo dispositivo ao SmartThings Hub, parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>