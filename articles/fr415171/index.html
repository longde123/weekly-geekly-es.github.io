<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÇüèæ üë± ü•ß Lois de r√©flexion dans Go üìü üçí üë®‚Äç‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je vous pr√©sente la traduction de l'article "Les lois de la r√©flexion" du cr√©ateur de la langue. 

 La r√©flexion est la capacit√© d'un p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lois de r√©flexion dans Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415171/">  Bonjour, Habr!  Je vous pr√©sente la traduction de l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Les lois de la r√©flexion"</a> du cr√©ateur de la langue. <br><br>  La r√©flexion est la capacit√© d'un programme √† explorer sa propre structure, en particulier √† travers les types.  Il s'agit d'une forme de m√©taprogrammation et d'une grande source de confusion. <br>  Dans Go, la r√©flexion est largement utilis√©e, par exemple, dans les packages test et fmt.  Dans cet article, nous allons essayer de nous d√©barrasser de la ¬´magie¬ª en expliquant comment fonctionne la r√©flexion dans Go. <br><a name="habracut"></a><br><h3>  Types et interfaces </h3><br>  La r√©flexion √©tant bas√©e sur un syst√®me de types, rafra√Æchissons nos connaissances sur les types dans Go. <br>  Go est tap√© de fa√ßon statique.  Chaque variable a un et un seul type statique fix√© au moment de la compilation: <code>int, float32, *MyType, []byte</code> ... Si nous d√©clarons: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j MyInt</code> </pre> <br>  alors <code>i</code> est de type <code>int</code> et <code>j</code> est de type <code>MyInt</code> .  Les variables <code>i</code> et <code>j</code> ont des types statiques diff√©rents et, bien qu'elles aient le m√™me type de base, elles ne peuvent pas √™tre affect√©es l'une √† l'autre sans conversion. <br><br>  L'une des cat√©gories de types importantes sont les interfaces, qui sont des ensembles de m√©thodes fixes.  Une interface peut stocker n'importe quelle valeur sp√©cifique (non-interface) tant que cette valeur impl√©mente les m√©thodes de l'interface.  Une paire bien connue d'exemples est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">io.Reader et io.Writer</a> , les types Reader et Writer du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">package io</a> : <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Reader -  ,    Read(). type Reader interface { Read(p []byte) (n int, err error) } // Writer -  ,    Write(). type Writer interface { Write(p []byte) (n int, err error) }</span></span></code> </pre> <br>  Il est dit que tout type qui impl√©mente la m√©thode <code>Read()</code> ou <code>Write()</code> avec cette signature impl√©mente respectivement <code>io.Reader</code> ou <code>io.Writer</code> .  Cela signifie qu'une variable de type <code>io.Reader</code> peut contenir n'importe quelle valeur de type Read (): <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r io.Reader r = os.Stdin r = bufio.NewReader(r) r = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(bytes.Buffer)</code> </pre> <br>  Il est important de comprendre que <code>r</code> peut recevoir n'importe quelle valeur qui impl√©mente <code>io.Reader</code> .  Go est de type statique et le type statique <code>r</code> est <code>io.Reader</code> . <br><br>  Un exemple extr√™mement important d'un type d'interface est l'interface vide: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}</code> </pre> <br>  Il s'agit d'un ensemble vide de m√©thodes ‚àÖ et est impl√©ment√© par n'importe quelle valeur. <br>  Certains disent que les interfaces Go sont des variables typ√©es dynamiquement, mais c'est une erreur.  Ils sont typ√©s statiquement: une variable avec un type d'interface a toujours le m√™me type statique, et bien qu'au moment de l'ex√©cution la valeur stock√©e dans la variable d'interface puisse changer le type, cette valeur satisfera toujours l'interface.  (Pas d' <code>undefined</code> , de <code>NaN</code> ou d'autres choses qui cassent la logique du programme.) <br><br>  Cela doit √™tre compris - la r√©flexion et les interfaces sont √©troitement li√©es. <br><br><h3>  Repr√©sentation interne de l'interface </h3><br>  Russ Cox a √©crit un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article de blog</a> d√©taill√© sur la configuration d'une interface dans Go.  Pas moins bon article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">est sur Habr'e</a> .  Il n'est pas n√©cessaire de r√©p√©ter toute l'histoire, les principaux points sont mentionn√©s. <br><br>  Une variable de type d'interface contient une paire: la valeur sp√©cifique affect√©e √† la variable et un descripteur de type pour cette valeur.  Plus pr√©cis√©ment, la valeur est l'√©l√©ment de donn√©es de base qui impl√©mente l'interface, et le type d√©crit le type complet de cet √©l√©ment.  Par exemple, apr√®s <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r io.Reader tty, err := os.OpenFile(<span class="hljs-string"><span class="hljs-string">"/dev/tty"</span></span>, os.O_RDWR, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } r = tty</code> </pre> <br>  <code>r</code> contient, sch√©matiquement, une paire <code>(, ) --&gt; (tty, *os.File)</code> .  Notez que le type <code>*os.File</code> impl√©mente des m√©thodes autres que <code>Read()</code> ;  m√™me si la valeur d'interface ne donne acc√®s qu'√† la m√©thode Read (), la valeur √† l'int√©rieur contient toutes les informations sur le type de cette valeur.  C'est pourquoi nous pouvons faire de telles choses: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> w io.Writer w = r.(io.Writer)</code> </pre> <br>  L'expression dans cette affectation est une instruction de type;  il pr√©tend que l'√©l√©ment √† l'int√©rieur de <code>r</code> impl√©mente √©galement <code>io.Writer</code> , et donc nous pouvons l'assigner √† <code>w</code> .  Une fois attribu√©, <code>w</code> contiendra une paire <code>(tty, *os.File)</code> .  C'est la m√™me paire qu'en <code>r</code> .  Le type statique de l'interface d√©termine quelles m√©thodes peuvent √™tre appel√©es sur la variable d'interface, bien qu'un ensemble plus large de m√©thodes puisse avoir une valeur sp√©cifique √† l'int√©rieur. <br><br>  En continuant, nous pouvons faire ce qui suit: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> empty <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} empty = w</code> </pre> <br>  et la valeur vide du champ vide contiendra √† nouveau la m√™me paire <code>(tty, *os.File)</code> .  C'est pratique: une interface vide peut contenir n'importe quelle valeur et toutes les informations dont nous aurons besoin. <br><br>  Nous n'avons pas besoin d'une assertion de type ici, car il est connu que <code>w</code> satisfait une interface vide.  Dans l'exemple o√π nous avons transf√©r√© la valeur de <code>Reader</code> √† <code>Writer</code> , nous devions utiliser explicitement une assertion de type, car <code>Writer</code> m√©thodes <code>Writer</code> ne sont pas un sous-ensemble de <code>Reader</code> .  Tenter de convertir une valeur qui ne correspond pas √† l'interface provoquera la panique. <br><br>  Un d√©tail important est qu'une paire √† l'int√©rieur d'une interface a toujours une forme (valeur, type sp√©cifique) et ne peut pas avoir de forme (valeur, interface).  Les interfaces ne prennent pas en charge les interfaces en tant que valeurs. <br><br>  Nous sommes maintenant pr√™ts √† √©tudier la r√©flexion. <br><br><h3>  La premi√®re loi de <s>r√©flexion</s> refl√®te </h3><br><ul><li>  La r√©flexion s'√©tend de l'interface √† la r√©flexion de l'objet. </li></ul><br>  Au niveau de base, la r√©flexion n'est qu'un m√©canisme pour examiner une paire de type et de valeur stock√©e dans une variable d'interface.  Pour commencer, il y a deux types que nous devons conna√Ætre: <code>reflect.Type</code> et <code>reflect.Value</code> .  Ces deux types donnent acc√®s au contenu de la variable d'interface et sont retourn√©s par des fonctions simples, reflect.TypeOf () et reflect.ValueOf (), respectivement.  Ils extraient des parties de la signification de l'interface.  (De plus, <code>reflect.Value</code> facile √† obtenir <code>reflect.Type</code> , mais ne m√©langeons pas les concepts de <code>Value</code> et de <code>Type</code> pour le moment.) <br><br>  Commen√ßons par <code>TypeOf()</code> : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"reflect"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"type:"</span></span>, reflect.TypeOf(x)) }</code> </pre> <br>  Le programme affichera <br> <code>type: float64</code> <br> <br>  Le programme est similaire √† la transmission d'une variable simple <code>float64 x</code> √† <code>reflect.TypeOf()</code> .  Voyez-vous l'interface?  Et c'est - <code>reflect.TypeOf()</code> accepte une interface vide, selon la d√©claration de fonction: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// TypeOf()  reflect.Type    . func TypeOf(i interface{}) Type</span></span></code> </pre> <br>  Lorsque nous appelons <code>reflect.TypeOf(x)</code> , <code>x</code> abord stock√© dans une interface vide, qui est ensuite pass√©e en argument;  <code>reflect.TypeOf()</code> d√©compresse cette interface vide pour restaurer les informations de type. <br><br>  La fonction <code>reflect.ValueOf()</code> , bien s√ªr, restaure la valeur (ci-apr√®s, nous ignorerons le mod√®le et nous concentrerons sur le code): <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"value:"</span></span>, reflect.ValueOf(x).String())</code> </pre> <br>  imprimera <br> <code>value: &lt;float64 Value&gt;</code> <br>  (Nous appelons la m√©thode <code>String()</code> explicitement car, par d√©faut, le package fmt se <code>reflect.Value</code> pour <code>reflect.Value</code> et imprime une valeur sp√©cifique.) <br>  Les deux <code>reflect.Type</code> et <code>reflect.Value</code> ont de nombreuses m√©thodes qui vous permettent de les explorer et de les modifier.  Un exemple important est celui de <code>reflect.Value</code> qui a une m√©thode <code>Type()</code> qui renvoie le type de valeur.  <code>reflect.Type</code> et <code>reflect.Value</code> ont une m√©thode <code>Kind()</code> qui retourne une constante indiquant quel √©l√©ment primitif est stock√©: <code>Uint, Float64, Slice</code> ... Ces constantes sont d√©clar√©es dans l'√©num√©ration dans le package reflect.  <code>Value</code> m√©thodes de <code>Value</code> avec des noms comme <code>Int()</code> et <code>Float()</code> nous permettent d'extraire des valeurs (comme int64 et float64) enferm√©es √† l'int√©rieur: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> v := reflect.ValueOf(x) fmt.Println(<span class="hljs-string"><span class="hljs-string">"type:"</span></span>, v.Type()) fmt.Println(<span class="hljs-string"><span class="hljs-string">"kind is float64:"</span></span>, v.Kind() == reflect.Float64) fmt.Println(<span class="hljs-string"><span class="hljs-string">"value:"</span></span>, v.Float())</code> </pre> <br>  imprimera <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: float64 kind <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> float64: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: <span class="hljs-number"><span class="hljs-number">3.4</span></span></code> </pre> <br>  Il existe √©galement des m√©thodes telles que <code>SetInt()</code> et <code>SetFloat()</code> , mais pour les utiliser, nous devons comprendre la settability, le sujet de la troisi√®me loi de la r√©flexion. <br><br>  La biblioth√®que de r√©flexion a quelques propri√©t√©s que vous devez mettre en √©vidence.  Premi√®rement, pour garder l'API simple, les m√©thodes <code>Value</code> ¬´getter¬ª et ¬´setter¬ª agissent sur le plus grand type pouvant contenir une valeur: <code>int64</code> pour tous les entiers <code>int64</code> .  Autrement dit, la m√©thode <code>Int()</code> de la valeur <code>Value</code> renvoie <code>int64</code> et la valeur <code>SetInt()</code> prend <code>int64</code> ;  une conversion en type r√©el peut √™tre n√©cessaire: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span> = <span class="hljs-string"><span class="hljs-string">'x'</span></span> v := reflect.ValueOf(x) fmt.Println(<span class="hljs-string"><span class="hljs-string">"type:"</span></span>, v.Type()) fmt.Println(<span class="hljs-string"><span class="hljs-string">"kind is uint8: "</span></span>, v.Kind() == reflect.Uint8) x = <span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span>(v.Uint()) <span class="hljs-comment"><span class="hljs-comment">// v.Uint  uint64.</span></span></code> </pre> <br>  sera <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span> kind is <span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre><br>  Ici, <code>v.Uint()</code> renverra <code>uint64</code> , une instruction de type explicite est n√©cessaire. <br><br>  La deuxi√®me propri√©t√© est que la r√©flexion <code>Kind()</code> de l'objet d√©crit le type de base, pas le type statique.  Si l'objet de r√©flexion contient une valeur d'un type entier d√©fini par l'utilisateur, comme dans <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x MyInt = <span class="hljs-number"><span class="hljs-number">7</span></span> v := reflect.ValueOf(x) <span class="hljs-comment"><span class="hljs-comment">// v   Value.</span></span></code> </pre> <br>  <code>v.Kind() == reflect.Int</code> , bien que le type statique de <code>x</code> soit <code>MyInt</code> , pas <code>int</code> .  En d'autres termes, <code>Kind()</code> ne peut pas distinguer <code>int</code> de <code>MyInt</code> , <code>MyInt</code> <code>Type()</code> .  <code>Kind</code> ne peut accepter que les valeurs des types int√©gr√©s. <br><br><h3>  La deuxi√®me loi de la <s>r√©flexion</s> refl√®te </h3><br><ul><li>  La r√©flexion s'√©tend de l'objet r√©fl√©chi √† l'interface. </li></ul><br>  Comme la r√©flexion physique, la r√©flexion dans Go cr√©e son contraire. <br><br>  Ayant <code>reflect.Value</code> , nous pouvons restaurer la valeur de l'interface en utilisant la m√©thode <code>Interface()</code> ;  La m√©thode regroupe les informations de type et de valeur dans l'interface et renvoie le r√©sultat: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Interface   v  interface{}. func (v Value) Interface() interface{}</span></span></code> </pre>  bvt <br>  A titre d'exemple: <br><br><pre> <code class="go hljs">y := v.Interface().(<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>) <span class="hljs-comment"><span class="hljs-comment">// y   float64. fmt.Println(y)</span></span></code> </pre> <br>  <code>float64</code> la valeur de <code>float64</code> repr√©sent√©e par reflet object <code>v</code> . <br>  Mais nous pouvons faire encore mieux.  Les arguments de <code>fmt.Println()</code> et <code>fmt.Printf()</code> sont pass√©s en tant <code>fmt.Printf()</code> vides, qui sont ensuite d√©compress√©es par le package fmt en interne, comme dans les exemples pr√©c√©dents.  Par cons√©quent, tout ce qui est n√©cessaire pour imprimer correctement le contenu de <code>reflect.Value</code> est de transmettre le r√©sultat de la m√©thode <code>Interface()</code> √† la fonction de sortie format√©e: <br><br><pre> <code class="go hljs">fmt.Println(v.Interface())</code> </pre> <br>  (Pourquoi pas <code>fmt.Println(v)</code> ? Parce que <code>v</code> est de type <code>reflect.Value</code> ; nous voulons obtenir la valeur contenue √† l'int√©rieur.) Puisque notre valeur est <code>float64</code> , nous pouvons m√™me utiliser le format √† virgule flottante si nous voulons: <br><br><pre> <code class="go hljs">fmt.Printf(<span class="hljs-string"><span class="hljs-string">"value is %7.1e\n"</span></span>, v.Interface())</code> </pre> <br>  affichera dans un cas sp√©cifique <br> <code>3.4e+00</code> <br> <br>  Encore une fois, il n'est pas n√©cessaire de <code>v.Interface()</code> type de r√©sultat <code>v.Interface()</code> dans <code>float64</code> ;  une valeur d'interface vide contient des informations sur une valeur sp√©cifique √† l'int√©rieur, et <code>fmt.Printf()</code> restaurera. <br>  En bref, la m√©thode <code>Interface()</code> est l'inverse de la fonction <code>ValueOf()</code> , sauf que son r√©sultat est toujours du type <code>interface{}</code> statique <code>interface{}</code> . <br><br>  R√©p√©ter: la r√©flexion s'√©tend des valeurs d'interface aux objets de r√©flexion et vice versa. <br><br><h3>  Troisi√®me loi de <s>r√©flexion</s> r√©flexion </h3><br><ul><li>  Pour modifier l'objet de r√©flexion, la valeur doit √™tre r√©glable. </li></ul><br>  La troisi√®me loi est la plus subtile et la plus d√©routante.  Nous commen√ßons par les premiers principes. <br>  Ce code ne fonctionne pas, mais il m√©rite attention. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> v := reflect.ValueOf(x) v.SetFloat(<span class="hljs-number"><span class="hljs-number">7.1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br>  Si vous ex√©cutez ce code, il se bloquera de panique avec un message critique: <br> <code>panic: reflect.Value.SetFloat   </code> <br>  Le probl√®me n'est pas que le litt√©ral <code>7.1</code> pas trait√©;  c'est ce que <code>v</code> pas installable.  <code>reflect.Value</code> est une propri√©t√© de <code>reflect.Value</code> , et pas tous les <code>reflect.Value</code> ont. <br>  La m√©thode <code>reflect.Value.CanSet()</code> d√©finie;  dans notre cas: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> v := reflect.ValueOf(x) fmt.Println(<span class="hljs-string"><span class="hljs-string">"settability of v:"</span></span>, v.CanSet())</code> </pre> <br>  imprimera: <br> <code>settability of v: false</code> <br> <br>  Une erreur s'est produite lors de l'appel de la m√©thode <code>Set()</code> sur une valeur non g√©r√©e.  Mais qu'est-ce que l'installabilit√©? <br><br>  La durabilit√© est un peu comme l'adressabilit√©, mais plus stricte.  Il s'agit d'une propri√©t√© dans laquelle l'objet de r√©flexion peut modifier la valeur stock√©e utilis√©e pour cr√©er l'objet de r√©flexion.  La durabilit√© est d√©termin√©e par le fait que l'objet de r√©flexion contient l'√©l√©ment source ou seulement une copie de celui-ci.  Quand on √©crit: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> v := reflect.ValueOf(x)</code> </pre> <br>  nous transmettons une copie de <code>x</code> √† <code>reflect.ValueOf()</code> , de sorte que l'interface est cr√©√©e en tant qu'argument pour <code>reflect.ValueOf()</code> - c'est une copie de <code>x</code> , pas <code>x</code> lui-m√™me.  Ainsi, si la d√©claration: <br><br><pre> <code class="go hljs">v.SetFloat(<span class="hljs-number"><span class="hljs-number">7.1</span></span>)</code> </pre> <br>  s'il √©tait ex√©cut√©, il ne mettrait pas √† jour <code>x</code> , bien que <code>v</code> semble avoir √©t√© cr√©√© √† partir de <code>x</code> .  Au lieu de cela, il mettrait √† jour la copie de <code>x</code> stock√©e dans la valeur de <code>v</code> , et <code>x</code> lui-m√™me ne serait pas affect√©.  Ceci est interdit afin de ne pas causer de probl√®mes, et l'installabilit√© est une propri√©t√© utilis√©e pour √©viter un probl√®me. <br><br>  Cela ne devrait pas para√Ætre √©trange.  Il s'agit d'une situation courante dans les v√™tements inhabituels.  Pensez √† passer <code>x</code> √† une fonction: <br> <code>f(x)</code> <br> <br>  Nous ne nous attendons pas √† ce que <code>f()</code> puisse changer <code>x</code> , car nous avons pass√© une copie de la valeur de <code>x</code> , pas <code>x</code> lui-m√™me.  Si nous voulons que <code>f()</code> change directement <code>x</code> , nous devons passer un pointeur vers <code>x</code> √† notre fonction: <br> <code>f(&amp;x)</code> <br> <br>  C'est simple et familier, et la r√©flexion fonctionne de la m√™me mani√®re.  Si nous voulons changer <code>x</code> utilisant la r√©flexion, nous devons fournir √† la biblioth√®que de r√©flexion un pointeur sur la valeur que nous voulons changer. <br><br>  Faisons-le.  Tout d'abord, nous initialisons <code>x</code> comme d'habitude, puis cr√©ons un <code>reflect.Value p</code> qui pointe vers lui. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> p := reflect.ValueOf(&amp;x) <span class="hljs-comment"><span class="hljs-comment">//   x. fmt.Println("type of p:", p.Type()) fmt.Println("settability of p:", p.CanSet())</span></span></code> </pre> <br>  affichera <br> <code>type of p: *float64 <br> settability of p: false</code> <br> <br>  L'objet Reflection <code>p</code> ne peut pas √™tre d√©fini, mais ce n'est pas le <code>p</code> que nous voulons d√©finir, c'est le pointeur <code>*p</code> .  Pour obtenir ce vers quoi <code>p</code> pointe, nous appelons la m√©thode <code>Value.Elem()</code> , qui prend la valeur indirectement via le pointeur et stocke le r√©sultat dans <code>reflect.Value v</code> : <br><br><pre> <code class="go hljs">v := p.Elem() fmt.Println(<span class="hljs-string"><span class="hljs-string">"settability of v:"</span></span>, v.CanSet())</code> </pre> <br>  Maintenant, <code>v</code> est un objet installable; <br> <code>settability of v: true</code> <br>  et comme il repr√©sente <code>x</code> , nous pouvons enfin utiliser <code>v.SetFloat()</code> pour changer la valeur de <code>x</code> : <br><br><pre> <code class="go hljs">v.SetFloat(<span class="hljs-number"><span class="hljs-number">7.1</span></span>) fmt.Println(v.Interface()) fmt.Println(x)</code> </pre> <br>  conclusion comme pr√©vu <br> <code>7.1 <br> 7.1</code> <br>  R√©fl√©chir peut √™tre difficile √† comprendre, mais il fait exactement ce que fait le langage, bien qu'avec l'aide de <code>reflection.Value</code> . <code>reflect.Type</code> et <code>reflection.Value</code> . <code>reflect.Type</code> , ce qui peut cacher ce qui se passe.  Gardez √† l'esprit cette <code>reflection.Value</code> besoin de l'adresse d'une variable pour la changer. <br><br><h3>  Structures </h3><br>  Dans notre exemple pr√©c√©dent, <code>v</code> pas un pointeur, il en √©tait juste d√©riv√©.  Une mani√®re courante de cr√©er cette situation consiste √† utiliser la r√©flexion pour modifier les champs de structure.  Tant que nous avons l'adresse de la structure, nous pouvons changer ses champs. <br><br>  Voici un exemple simple qui analyse la valeur de la structure <code>t</code> .  Nous cr√©ons un objet de r√©flexion avec l'adresse de la structure afin de la modifier ult√©rieurement.  Ensuite, d√©finissez typeOfT sur son type et parcourez les champs √† l'aide d'appels de m√©thode simples (voir le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">package pour une description d√©taill√©e</a> ).  Notez que nous <code>reflect.Value</code> noms de champs du type de structure, mais les champs eux-m√™mes sont des <code>reflect.Value</code> r√©guliers. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { A <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> B <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } t := T{<span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-string"><span class="hljs-string">"skidoo"</span></span>} s := reflect.ValueOf(&amp;t).Elem() typeOfT := s.Type() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; s.NumField(); i++ { f := s.Field(i) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%d: %s %s = %v\n"</span></span>, i, typeOfT.Field(i).Name, f.Type(), f.Interface()) }</code> </pre> <br>  Le programme affichera <br> <code>0: A int = 23 <br> 1: B string = skidoo</code> <br>  Un autre point sur l'installabilit√© est affich√© ici: les noms des champs <code>T</code> en majuscules (export√©s), car seuls les champs export√©s sont param√©trables. <br>  Puisque <code>s</code> contient un objet de r√©flexion installable, nous pouvons changer le champ de structure. <br><br><pre> <code class="go hljs">s.Field(<span class="hljs-number"><span class="hljs-number">0</span></span>).SetInt(<span class="hljs-number"><span class="hljs-number">77</span></span>) s.Field(<span class="hljs-number"><span class="hljs-number">1</span></span>).SetString(<span class="hljs-string"><span class="hljs-string">"Sunset Strip"</span></span>) fmt.Println(<span class="hljs-string"><span class="hljs-string">"t is now"</span></span>, t)</code> </pre> <br>  R√©sultat: <br> <code>t is now {77 Sunset Strip}</code> <br>  Si nous changeons le programme pour que <code>s</code> cr√©√© √† partir de <code>t</code> plut√¥t que <code>&amp;t</code> , les appels √† <code>SetInt()</code> et <code>SetString()</code> se termineraient en panique, car les champs <code>t</code> ne seraient pas param√©trables. <br><br><h3>  Conclusion </h3><br>  Rappelons les lois de la r√©flexion: <br><br><ul><li>  La r√©flexion s'√©tend de l'interface √† la r√©flexion de l'objet. </li><li>  La r√©flexion s'√©tend de la r√©flexion d'un objet √† l'interface. </li><li>  Pour modifier l'objet de r√©flexion, la valeur doit √™tre d√©finie. </li></ul><br>  Publi√© par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rob Pike</a> . <br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/2q/04/ha/2q04hardrnhhnrnuyb6dk0quvue.png" width="350"></a> </div> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><br></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr415171/">https://habr.com/ru/post/fr415171/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr415159/index.html">Annonce de la conf√©rence DevOps DevOops 2018</a></li>
<li><a href="../fr415163/index.html">R√©seau sans fil dans une usine pharmaceutique sp√©cialement gard√©e et sp√©cialement prot√©g√©e √† certains endroits en Russie</a></li>
<li><a href="../fr415165/index.html">Version Node.js 10.5: multithreading pr√™t √† l'emploi</a></li>
<li><a href="../fr415167/index.html">Ouvrir la le√ßon ¬´Multithreading en Java. Primitives de synchronisation de base ¬ª</a></li>
<li><a href="../fr415169/index.html">Compression et d√©duplication: r√©duisez la taille de l'archive et de la sauvegarde du courrier √† l'aide de l'hiver ZxPowerstore</a></li>
<li><a href="../fr415175/index.html">Entretien avec un membre de l'Expo Augmented World</a></li>
<li><a href="../fr415177/index.html">Bienvenue</a></li>
<li><a href="../fr415181/index.html">[Iekaterinbourg, annonce] Mitap des analystes - sur les premiers analystes et CBAP, sur les m√©triques, sur le secteur public et les types d'analystes</a></li>
<li><a href="../fr415183/index.html">Extension Web multi-navigateur pour les scripts personnalis√©s Partie 1</a></li>
<li><a href="../fr415185/index.html">Vid√©o conf√©rence gratuite 3CX WebMeeting: pr√©sentation des fonctionnalit√©s</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>