<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💇🏾 ㊗️ 🌟 Cara akhirnya mulai menulis tes dan tidak menyesalinya ⛽️ 💇 ▶️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Datang ke proyek baru, saya secara teratur menemukan salah satu situasi berikut: 



1. Tidak ada tes sama sekali. 
2. Ada beberapa tes, mereka jarang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara akhirnya mulai menulis tes dan tidak menyesalinya</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/custis/blog/427603/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/vr/v7/q_/vrv7q_kwfiqd5f7qx7jxwukv62g.jpeg"></a> <br><br>  Datang ke proyek baru, saya secara teratur menemukan salah satu situasi berikut: <br><br><ol><li>  Tidak ada tes sama sekali. </li><li>  Ada beberapa tes, mereka jarang ditulis dan tidak berjalan secara berkelanjutan. </li><li>  Tes hadir dan termasuk dalam CI (Continuous Integration), tetapi lebih banyak ruginya daripada kebaikan. </li></ol><br>  Sayangnya, ini adalah skenario terakhir yang sering mengarah pada upaya serius untuk mulai melaksanakan pengujian tanpa adanya keterampilan yang sesuai. <br><br>  Apa yang bisa dilakukan untuk mengubah situasi saat ini?  Gagasan menggunakan tes bukanlah hal baru.  Pada saat yang sama, sebagian besar tutorial menyerupai gambar terkenal tentang cara menggambar burung hantu: kita menghubungkan JUnit, menulis tes pertama, gunakan mock pertama dan pergi!  Artikel semacam itu tidak menjawab pertanyaan tentang tes apa yang perlu ditulis, apa yang perlu diperhatikan dan bagaimana menjalani semua ini.  Dari sinilah ide artikel ini lahir.  Saya mencoba merangkum pengalaman saya secara singkat dalam mengimplementasikan tes di berbagai proyek untuk memfasilitasi jalur ini untuk semua orang. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ra/7v/m-/ra7vm-kgn__gsmaeg6xg7aud4ey.jpeg"></div><br>  Ada lebih dari cukup artikel pengantar tentang topik ini, jadi kami tidak akan mengulangi dan mencoba untuk pergi dari sisi lain.  Pada bagian pertama, kami akan menyanggah mitos bahwa pengujian membawa biaya tambahan secara eksklusif.  Akan ditunjukkan bagaimana pembuatan tes kualitas dapat mempercepat proses pengembangan.  Kemudian, pada contoh proyek kecil, prinsip dan aturan dasar yang harus diikuti untuk mewujudkan manfaat ini akan dipertimbangkan.  Akhirnya, di bagian akhir, rekomendasi implementasi spesifik akan diberikan: bagaimana menghindari masalah yang khas ketika tes dimulai, sebaliknya, secara signifikan memperlambat pengembangan. <br><br>  Karena spesialisasi utama saya adalah Java backend, tumpukan teknologi berikut akan digunakan dalam contoh: Java, JUnit, H2, Mockito, Spring, Hibernate.  Pada saat yang sama, bagian penting dari artikel ini dikhususkan untuk masalah pengujian umum dan tips di dalamnya berlaku untuk berbagai tugas yang jauh lebih luas. <br><br>  Namun berhati-hatilah!  Tes sangat adiktif: sekali Anda belajar cara menggunakannya, Anda tidak bisa lagi hidup tanpanya. <br><br><div class="spoiler">  <b class="spoiler_title">Isi</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tes vs kecepatan pengembangan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menjalankan kode di sembarang tempat</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Meluncurkan kembali Tes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Debugging</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Keefektifan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dari teori ke praktik</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tantangan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Model domain</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Struktur proyek</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tes integrasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tes unit</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rekomendasi Implementasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kesimpulan</a> </div></div><br><a name="TestsVsSpeed"></a><h2>  Tes vs kecepatan pengembangan </h2><br>  Pertanyaan utama yang muncul ketika membahas implementasi pengujian: berapa lama waktu yang dibutuhkan untuk menulis tes dan apa manfaatnya?  Pengujian, seperti teknologi lainnya, akan membutuhkan upaya serius untuk pengembangan dan implementasi, jadi pada awalnya tidak ada manfaat signifikan yang diharapkan.  Adapun biaya waktu, mereka sangat tergantung pada tim tertentu.  Namun, kurang dari 20-30% dari biaya tambahan pengkodean tidak harus dihitung secara tepat.  Kurang sama sekali tidak cukup untuk mencapai setidaknya beberapa hasil.  Harapan pengembalian instan sering menjadi alasan utama untuk membatasi kegiatan ini bahkan sebelum tes menjadi berguna. <br><br>  Tetapi efisiensi seperti apa yang sedang kita bicarakan?  Mari kita letakkan lirik tentang kesulitan implementasi dan lihat peluang spesifik apa yang dapat digunakan untuk menghemat waktu pengujian. <br><br><a name="CodeRun"></a><h3>  Menjalankan kode di sembarang tempat </h3><br>  Jika tidak ada tes dalam proyek, satu-satunya cara untuk memulai adalah mengangkat seluruh aplikasi.  Ini bagus jika dibutuhkan sekitar 15-20 detik, tetapi kasus proyek besar di mana peluncuran penuh dapat berlangsung dari beberapa menit jauh dari langka.  Apa artinya ini bagi pengembang?  Bagian penting dari waktu kerja mereka adalah sesi tunggu singkat ini, di mana Anda tidak dapat terus mengerjakan tugas saat ini, tetapi pada saat yang sama ada terlalu sedikit waktu untuk beralih ke hal lain.  Banyak setidaknya sekali mengalami proyek-proyek seperti itu di mana kode yang ditulis dalam satu jam membutuhkan berjam-jam debug karena restart lama antara koreksi.  Dalam pengujian, Anda dapat membatasi diri untuk menjalankan bagian kecil dari aplikasi, yang secara signifikan akan mengurangi waktu tunggu dan meningkatkan produktivitas mengerjakan kode. <br><br>  Selain itu, kemampuan untuk menjalankan kode di sembarang tempat mengarah pada debugging yang lebih menyeluruh.  Sering memeriksa bahkan kasus penggunaan positif utama melalui antarmuka aplikasi membutuhkan upaya dan waktu yang serius.  Kehadiran tes memungkinkan untuk melakukan pemeriksaan terperinci dari fungsional tertentu yang jauh lebih mudah dan lebih cepat. <br><br>  Kelebihan lainnya adalah kemampuan untuk mengatur ukuran unit yang diuji.  Bergantung pada kompleksitas logika yang diuji, Anda dapat membatasi diri pada satu metode, kelas, sekelompok kelas yang menerapkan beberapa fungsi, layanan, dan sebagainya, hingga otomatisasi pengujian seluruh aplikasi.  Fleksibilitas ini memungkinkan Anda untuk memuat tes tingkat tinggi dari banyak bagian karena fakta bahwa tes tersebut akan diuji pada tingkat yang lebih rendah. <br><br><a name="RepeatedRun"></a><h3>  Meluncurkan kembali Tes </h3><br>  Nilai tambah ini sering disebut sebagai inti dari otomatisasi pengujian, tetapi mari kita lihat dari sudut yang kurang familiar.  Peluang baru apa yang terbuka untuk pengembang? <br><br>  Pertama, setiap pengembang baru yang datang ke proyek akan dapat dengan mudah menjalankan tes yang ada untuk memahami logika aplikasi menggunakan contoh.  Sayangnya, pentingnya ini sangat diremehkan.  Dalam kondisi modern, orang yang sama jarang mengerjakan proyek lebih dari 1-2 tahun.  Dan karena tim terdiri dari beberapa orang, penampilan peserta baru setiap 2-3 bulan adalah situasi khas untuk proyek yang relatif besar.  Terutama proyek-proyek yang sulit sedang mengalami perubahan dari seluruh generasi pengembang!  Kemampuan untuk dengan mudah meluncurkan bagian mana pun dari aplikasi dan melihat perilaku sistem pada waktu menyederhanakan perendaman programmer baru dalam proyek tersebut.  Selain itu, studi yang lebih rinci tentang logika kode mengurangi jumlah kesalahan yang dibuat pada output dan waktu untuk men-debug mereka di masa depan. <br><br>  Kedua, kemampuan untuk dengan mudah memverifikasi bahwa aplikasi bekerja dengan benar membuka jalan untuk Refactoring Berkelanjutan.  Istilah ini, sayangnya, jauh kurang populer daripada CI.  Ini berarti bahwa refactoring dapat dan harus dilakukan setiap kali kode disempurnakan.  Justru ketaatan reguler dari aturan kepanduan yang terkenal "meninggalkan tempat parkir lebih bersih daripada sebelum kedatangan Anda" yang memungkinkan Anda untuk menghindari degradasi basis kode dan menjamin proyek ini hidup yang panjang dan bahagia. <br><br><a name="Debugging"></a><h3>  Debugging </h3><br>  Debugging telah disebutkan dalam paragraf sebelumnya, tetapi poin ini sangat penting sehingga layak untuk dilihat lebih dekat.  Sayangnya, tidak ada cara yang dapat diandalkan untuk mengukur hubungan antara waktu yang dihabiskan untuk menulis kode dan men-debug-nya, karena proses ini praktis tidak dapat dipisahkan satu sama lain.  Namun demikian, keberadaan tes kualitas dalam proyek secara signifikan mengurangi waktu debugging, hingga hampir tidak ada kebutuhan untuk menjalankan debugger. <br><br><a name="Efficiency"></a><h3>  Keefektifan </h3><br>  Semua hal di atas dapat secara signifikan menghemat waktu pada debugging awal kode.  Dengan pendekatan yang tepat, hanya ini yang akan membayar semua biaya pengembangan tambahan.  Bonus pengujian yang tersisa - meningkatkan kualitas basis kode (kode yang dirancang dengan buruk sulit untuk diuji), mengurangi jumlah cacat, kemampuan untuk memverifikasi kebenaran kode kapan saja, dll. - akan mendapatkan hampir gratis. <br><br><a name="FromTheoryToPractice"></a><h2>  Dari teori ke praktik </h2><br>  Dengan kata-kata, semuanya terlihat bagus, tetapi mari kita beralih ke bisnis.  Seperti disebutkan sebelumnya, ada lebih dari cukup bahan tentang cara membuat pengaturan awal lingkungan pengujian.  Karena itu, kami segera melanjutkan ke proyek yang sudah selesai.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber di sini.</a> <br><br><a name="Task"></a><h3>  Tantangan </h3><br>  Sebagai tugas templat, pertimbangkan fragmen kecil di bagian belakang toko online.  Kami akan menulis API khas untuk bekerja dengan produk: membuat, menerima, mengedit.  Serta beberapa metode untuk bekerja dengan klien: mengubah "produk favorit" dan menghitung poin bonus untuk pesanan. <br><br><a name="DomainModel"></a><h3>  Model domain </h3><br>  Agar tidak membebani contoh, kami membatasi diri pada set minimal bidang dan kelas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wc/pn/pz/wcpnpz94fmrb-av0-wkkuu4l2wi.jpeg"></div><br><br>  Pelanggan memiliki nama pengguna, tautan ke produk favorit dan bendera yang menunjukkan apakah ia adalah pelanggan premium. <br><br>  Produk (Produk) - nama, harga, diskon, dan bendera yang menunjukkan apakah saat ini diiklankan. <br><br><a name="ProjectStructure"></a><h3>  Struktur proyek </h3><br>  Struktur kode proyek utama adalah sebagai berikut. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ks/qa/m3/ksqam31c3vwkzdfwkmi8r7o3ggk.jpeg"></div><br><br>  Kelas berlapis: <br><br><ul><li>  Model - model domain dari proyek; </li><li>  Jpa - repositori untuk bekerja dengan database berdasarkan Data Spring; </li><li>  Layanan - logika bisnis dari aplikasi; </li><li>  Controller - pengendali yang mengimplementasikan API. </li></ul><br>  Struktur tes unit. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i3/_1/mi/i3_1micxy4kvvlb6dlgihfmmng0.jpeg"></div><br><br>  Kelas uji berada dalam paket yang sama dengan kode asli.  Selain itu, paket dengan pembangun untuk persiapan data uji telah dibuat, tetapi lebih lanjut tentang itu di bawah ini. <br><br>  Lebih mudah untuk memisahkan tes unit dan tes integrasi.  Mereka sering memiliki ketergantungan yang berbeda, dan untuk perkembangan yang nyaman harus ada kemampuan untuk menjalankan salah satu dari yang lain.  Ini dapat dicapai dengan berbagai cara: konvensi penamaan, modul, paket, sourceSet.  Pilihan metode tertentu hanya masalah selera.  Dalam proyek ini, tes integrasi terletak pada sourceSet yang terpisah - IntegrationTest. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qq/1w/z7/qq1wz7n9tq77_zromu01ofx9cns.jpeg"></div><br><br>  Seperti halnya tes unit, kelas dengan tes integrasi berada dalam paket yang sama dengan kode asli.  Selain itu, ada kelas dasar yang membantu menghilangkan duplikasi konfigurasi dan, jika perlu, berisi metode universal yang bermanfaat. <br><br><a name="IntegrationTests"></a><h3>  Tes integrasi </h3><br>  Ada beberapa pendekatan berbeda untuk menguji apa yang layak dimulai.  Jika logika yang diuji tidak terlalu rumit, Anda dapat langsung melanjutkan ke yang integrasi (kadang-kadang disebut juga yang menerima).  Tidak seperti unit test, mereka memastikan bahwa aplikasi secara keseluruhan berfungsi dengan benar. <br><br>  <b>Arsitektur</b> <br><br>  Pertama, Anda perlu memutuskan pada pemeriksaan integrasi level spesifik apa yang akan dilakukan.  Spring Boot memberikan kebebasan penuh untuk memilih: Anda dapat meningkatkan bagian dari konteks, seluruh konteks, dan bahkan server penuh, dapat diakses dari tes.  Ketika ukuran aplikasi meningkat, masalah ini menjadi semakin kompleks.  Seringkali Anda harus menulis tes yang berbeda di level yang berbeda. <br><br>  Titik awal yang baik adalah tes pengontrol tanpa memulai server.  Dalam aplikasi yang relatif kecil, cukup diterima untuk meningkatkan seluruh konteks, karena secara default itu digunakan kembali antara tes dan diinisialisasi hanya sekali.  Pertimbangkan metode dasar kelas <code>ProductController</code> : <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@PostMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"new"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@RequestBody Product product)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> productService.createProduct(product); } <span class="hljs-meta"><span class="hljs-meta">@GetMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"{productId}"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@PathVariable(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"productId"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> productId) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> productService.getProduct(productId); } <span class="hljs-meta"><span class="hljs-meta">@PostMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"{productId}/edit"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@PathVariable(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"productId"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> productId, @RequestBody Product product) </span></span>{ productService.updateProduct(productId, product); }</code> </pre> <br>  Masalah penanganan kesalahan dikesampingkan.  Misalkan itu diterapkan secara eksternal berdasarkan analisis pengecualian yang dilemparkan.  Kode metode ini sangat sederhana, penerapannya di <code>ProductService</code> tidak jauh lebih rumit: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span>(readOnly = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long productId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> productRepository.findById(productId) .orElseThrow(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataNotFoundException(<span class="hljs-string"><span class="hljs-string">"Product"</span></span>, productId)); } <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Product product)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> productRepository.save(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Product(product)); } <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long productId, Product product)</span></span></span><span class="hljs-function"> </span></span>{ Product dbProduct = productRepository.findById(productId) .orElseThrow(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataNotFoundException(<span class="hljs-string"><span class="hljs-string">"Product"</span></span>, productId)); dbProduct.setPrice(product.getPrice()); dbProduct.setDiscount(product.getDiscount()); dbProduct.setName(product.getName()); dbProduct.setIsAdvertised(product.isAdvertised()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> productRepository.save(dbProduct); }</code> </pre> <br>  Repositori <code>ProductRepository</code> tidak mengandung metode sendiri sama sekali: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JpaRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Long</span></span></span><span class="hljs-class">&gt; </span></span>{ }</code> </pre> <br>  Semuanya mengisyaratkan bahwa kelas-kelas ini tidak memerlukan tes unit hanya karena seluruh rantai dapat dengan mudah dan efisien diperiksa oleh beberapa tes integrasi.  Duplikasi tes yang sama dalam tes yang berbeda mempersulit proses debug.  Dalam hal terjadi kesalahan dalam kode, sekarang tidak satu tes akan jatuh, tetapi 10-15 sekaligus.  Ini pada gilirannya akan membutuhkan analisis lebih lanjut.  Jika tidak ada duplikasi, maka satu-satunya tes jatuh cenderung segera menunjukkan kesalahan. <br><br>  <b>Konfigurasi</b> <br><br>  Untuk kenyamanan, kami menyoroti kelas dasar <code>BaseControllerIT</code> , yang berisi konfigurasi Spring dan beberapa bidang: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RunWith</span></span>(SpringRunner.class) <span class="hljs-meta"><span class="hljs-meta">@SpringBootTest</span></span>(webEnvironment = SpringBootTest.WebEnvironment.NONE) <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseControllerIT</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> ProductRepository productRepository; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> CustomerRepository customerRepository; }</code> </pre> <br>  Repositori dipindahkan ke kelas dasar agar tidak mengacaukan kelas tes.  Peran mereka adalah bantu tambahan: menyiapkan data dan memeriksa status database setelah pengontrol bekerja.  Ketika Anda meningkatkan ukuran aplikasi, ini mungkin tidak lagi nyaman, tetapi untuk awalnya sangat cocok. <br><br>  Konfigurasi utama Spring didefinisikan oleh baris berikut: <br><br>  <code>@SpringBootTest</code> - digunakan untuk mengatur konteks aplikasi.  <code>WebEnvironment.NONE</code> berarti tidak ada konteks web yang perlu ditingkatkan. <br><br>  <code>@Transactional</code> - membungkus semua tes kelas dalam suatu transaksi dengan rollback otomatis untuk menyimpan status basis data. <br><br>  <b>Struktur uji</b> <br><br>  Mari kita beralih ke serangkaian tes minimalis untuk kelas <code>ProductControllerIT</code> - <code>ProductControllerIT</code> . <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProduct_productSaved</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product = product(<span class="hljs-string"><span class="hljs-string">"productName"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"1.01"</span></span>).discount(<span class="hljs-string"><span class="hljs-string">"0.1"</span></span>).advertised(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>).build(); Product createdProduct = productController.createProduct(product); Product dbProduct = productRepository.getOne(createdProduct.getId()); assertEquals(<span class="hljs-string"><span class="hljs-string">"productName"</span></span>, dbProduct.getName()); assertEquals(number(<span class="hljs-string"><span class="hljs-string">"1.01"</span></span>), dbProduct.getPrice()); assertEquals(number(<span class="hljs-string"><span class="hljs-string">"0.1"</span></span>), dbProduct.getDiscount()); assertEquals(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, dbProduct.isAdvertised()); }</code> </pre> <br>  Sekilas kode tes harus sangat sederhana dan mudah dimengerti.  Jika tidak demikian, maka sebagian besar keuntungan dari tes yang dijelaskan pada bagian pertama artikel hilang.  Merupakan praktik yang baik untuk membagi badan uji menjadi tiga bagian yang dapat dipisahkan secara visual satu sama lain: menyiapkan data, memanggil metode pengujian, memvalidasi hasil.  Pada saat yang sama, sangat diinginkan agar kode uji sesuai pada layar secara keseluruhan. <br><br>  Secara pribadi, tampak lebih jelas bagi saya ketika nilai tes dari bagian persiapan data digunakan nanti dalam pemeriksaan.  Atau, Anda dapat membandingkan objek secara eksplisit, misalnya seperti ini: <br><br><pre> <code class="java hljs">assertEquals(product, dbProduct);</code> </pre> <br>  Dalam pengujian lain untuk memperbarui informasi produk ( <code>updateProduct</code> ), jelas bahwa pembuatan data telah menjadi sedikit lebih rumit dan untuk menjaga integritas visual dari tiga bagian pengujian, mereka dipisahkan oleh dua umpan baris berturut-turut: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateProduct_productUpdated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product = product(<span class="hljs-string"><span class="hljs-string">"productName"</span></span>).build(); productRepository.save(product); Product updatedProduct = product(<span class="hljs-string"><span class="hljs-string">"updatedName"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"1.1"</span></span>).discount(<span class="hljs-string"><span class="hljs-string">"0.5"</span></span>).advertised(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>).build(); updatedProduct.setId(product.getId()); productController.updateProduct(product.getId(), updatedProduct); Product dbProduct = productRepository.getOne(product.getId()); assertEquals(<span class="hljs-string"><span class="hljs-string">"updatedName"</span></span>, dbProduct.getName()); assertEquals(number(<span class="hljs-string"><span class="hljs-string">"1.1"</span></span>), dbProduct.getPrice()); assertEquals(number(<span class="hljs-string"><span class="hljs-string">"0.5"</span></span>), dbProduct.getDiscount()); assertEquals(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, dbProduct.isAdvertised()); }</code> </pre> <br>  Masing-masing dari tiga bagian adonan dapat disederhanakan.  Untuk persiapan data, pembangun uji sangat baik, yang berisi logika untuk membuat objek yang nyaman digunakan dari tes.  Pemanggilan metode yang terlalu rumit dapat dibuat menjadi metode tambahan di dalam kelas uji, menyembunyikan beberapa parameter yang tidak relevan untuk kelas ini.  Untuk menyederhanakan pemeriksaan kompleks, Anda juga dapat menulis fungsi bantu atau mengimplementasikan pencocokan Anda sendiri.  Hal utama dengan semua penyederhanaan ini adalah jangan sampai kehilangan visibilitas tes: semuanya harus jelas sekilas pada metode utama, tanpa perlu masuk lebih dalam. <br><br>  <b>Pembangun uji</b> <br><br>  Pembangun uji patut mendapat perhatian khusus.  Enkapsulasi logika membuat objek menyederhanakan perawatan uji.  Secara khusus, pengisian bidang model yang tidak relevan dengan pengujian ini dapat disembunyikan di dalam pembangun.  Untuk melakukan ini, Anda tidak harus membuatnya secara langsung, tetapi gunakan metode statis yang akan mengisi bidang yang hilang dengan nilai default.  Misalnya, jika bidang yang diperlukan baru muncul dalam model, mereka dapat dengan mudah ditambahkan ke metode ini.  Di <code>ProductBuilder</code> tampilannya seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ProductBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">product</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProductBuilder() .name(name) .advertised(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) .price(<span class="hljs-string"><span class="hljs-string">"0.00"</span></span>); }</code> </pre> <br>  <b>Nama uji</b> <br><br>  Sangat penting untuk memahami apa yang secara khusus diuji dalam tes ini.  Untuk kejelasan, yang terbaik adalah memberikan jawaban untuk pertanyaan ini dalam judulnya.  Menggunakan tes sampel untuk metode <code>getProduct</code> pertimbangkan konvensi penamaan yang digunakan: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getProduct_oneProductInDb_productReturned</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product = product(<span class="hljs-string"><span class="hljs-string">"productName"</span></span>).build(); productRepository.save(product); Product result = productController.getProduct(product.getId()); assertEquals(<span class="hljs-string"><span class="hljs-string">"productName"</span></span>, result.getName()); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getProduct_twoProductsInDb_correctProductReturned</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product1 = product(<span class="hljs-string"><span class="hljs-string">"product1"</span></span>).build(); Product product2 = product(<span class="hljs-string"><span class="hljs-string">"product2"</span></span>).build(); productRepository.save(product1); productRepository.save(product2); Product result = productController.getProduct(product1.getId()); assertEquals(<span class="hljs-string"><span class="hljs-string">"product1"</span></span>, result.getName()); }</code> </pre> <br>  Dalam kasus umum, judul metode pengujian terdiri dari tiga bagian, dipisahkan dengan menggarisbawahi: nama metode yang diuji, skrip, dan hasil yang diharapkan.  Namun, tidak ada yang membatalkan akal sehat, dan mungkin dibenarkan untuk menghilangkan beberapa bagian dari nama jika mereka tidak diperlukan dalam konteks ini (misalnya, skrip dalam satu tes untuk membuat produk).  Tujuan dari penamaan ini adalah untuk memastikan bahwa esensi dari setiap tes dapat dipahami tanpa mempelajari kode.  Ini membuat jendela hasil tes sejelas mungkin, dan dengan itu pekerjaan uji biasanya dimulai. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gu/0k/p9/gu0kp9p5hdbswo4i8d6ti2sy1qi.jpeg"></div><br><br>  <b>Kesimpulan</b> <br><br>  Itu saja.  Untuk pertama kalinya, serangkaian minimal empat tes sudah cukup untuk menguji metode kelas <code>ProductController</code> .  Dalam hal mendeteksi bug, Anda selalu dapat menambahkan tes yang hilang.  Pada saat yang sama, jumlah tes minimum secara signifikan mengurangi waktu dan upaya untuk mendukungnya.  Ini, pada gilirannya, sangat penting dalam proses implementasi pengujian, karena tes pertama biasanya diperoleh bukan dari kualitas terbaik dan menciptakan banyak masalah yang tidak terduga.  Pada saat yang sama, test suite semacam itu cukup untuk menerima bonus yang dijelaskan di bagian pertama artikel. <br><br>  Perlu dicatat bahwa tes tersebut tidak memeriksa lapisan web aplikasi, tetapi seringkali ini tidak diperlukan.  Jika perlu, Anda dapat menulis tes terpisah untuk lapisan web dengan rintisan alih-alih pangkalan ( <code>@WebMvcTest</code> , <code>MockMvc</code> , <code>@MockBean</code> ) atau menggunakan server yang lengkap.  Yang terakhir dapat menyulitkan debugging dan mempersulit pekerjaan dengan transaksi, karena tes tidak dapat mengontrol transaksi server.  Contoh dari tes integrasi seperti ini dapat ditemukan di kelas <code>CustomerControllerServerIT</code> . <br><br><a name="UnitTests"></a><h3>  Tes unit </h3><br>  Tes unit memiliki beberapa keunggulan dibandingkan tes integrasi: <br><br><ul><li>  Memulai membutuhkan milidetik; </li><li>  Ukuran kecil dari unit yang diuji; </li><li>  Sangat mudah untuk mengimplementasikan verifikasi sejumlah besar opsi, karena ketika metode ini dipanggil secara langsung, persiapan data sangat disederhanakan. </li></ul><br>  Meskipun demikian, tes unit pada dasarnya tidak dapat menjamin pengoperasian aplikasi secara keseluruhan dan tidak memungkinkan Anda untuk menghindari penulisan yang terintegrasi.  Jika logika unit yang diuji sederhana, duplikasi tes integrasi dengan tes unit tidak akan membawa manfaat apa pun, tetapi hanya menambah lebih banyak kode untuk mendukung. <br><br>  Satu-satunya kelas dalam contoh ini yang layak pengujian unit adalah <code>BonusPointCalculator</code> .  Fitur yang membedakan adalah sejumlah besar cabang logika bisnis.  Misalnya, diasumsikan bahwa pembeli menerima bonus 10% dari biaya produk, dikalikan dengan tidak lebih dari 2 pengganda dari daftar berikut: <br><br><ul><li>  Biaya produk lebih dari 10.000 (× 4); </li><li>  Produk berpartisipasi dalam kampanye iklan (× 3); </li><li>  Produk adalah produk "favorit" pelanggan (× 5); </li><li>  Klien memiliki status premium (× 2); </li><li>  Jika klien memiliki status premium dan membeli produk "favorit", alih-alih dua pengganda yang ditunjukkan, satu (× 8) digunakan. </li></ul><br>  Dalam kehidupan nyata, tentu saja, ada baiknya merancang mekanisme universal yang fleksibel untuk menghitung bonus ini, tetapi untuk menyederhanakan contoh, kita membatasi diri kita pada implementasi yang pasti.  Kode perhitungan pengali terlihat seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;BigDecimal&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateMultipliers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Customer customer, Product product)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;BigDecimal&gt; multipliers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (customer.getFavProduct() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; customer.getFavProduct().equals(product)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (customer.isPremium()) { multipliers.add(PREMIUM_FAVORITE_MULTIPLIER); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { multipliers.add(FAVORITE_MULTIPLIER); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (customer.isPremium()) { multipliers.add(PREMIUM_MULTIPLIER); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (product.isAdvertised()) { multipliers.add(ADVERTISED_MULTIPLIER); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (product.getPrice().compareTo(EXPENSIVE_THRESHOLD) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { multipliers.add(EXPENSIVE_MULTIPLIER); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> multipliers; }</code> </pre> <br>  Sejumlah besar opsi mengarah pada fakta bahwa dua atau tiga tes integrasi tidak dibatasi di sini.  Serangkaian tes unit minimalis sangat cocok untuk men-debug fungsionalitas tersebut. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bk/jw/ai/bkjwai9dy1mrxxarxncx6jgfehq.jpeg"></div><br><br>  Suite tes yang sesuai dapat ditemukan di kelas <code>BonusPointCalculatorTest</code> .  Inilah beberapa di antaranya: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate_oneProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product = product(<span class="hljs-string"><span class="hljs-string">"product"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"1.00"</span></span>).build(); Customer customer = customer(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>).build(); Map&lt;Product, Long&gt; quantities = mapOf(product, <span class="hljs-number"><span class="hljs-number">1L</span></span>); BigDecimal bonus = bonusPointCalculator.calculate(customer, list(product), quantities::get); BigDecimal expectedBonus = bonusPoints(<span class="hljs-string"><span class="hljs-string">"0.10"</span></span>).build(); assertEquals(expectedBonus, bonus); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate_favProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product = product(<span class="hljs-string"><span class="hljs-string">"product"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"1.00"</span></span>).build(); Customer customer = customer(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>).favProduct(product).build(); Map&lt;Product, Long&gt; quantities = mapOf(product, <span class="hljs-number"><span class="hljs-number">1L</span></span>); BigDecimal bonus = bonusPointCalculator.calculate(customer, list(product), quantities::get); BigDecimal expectedBonus = bonusPoints(<span class="hljs-string"><span class="hljs-string">"0.10"</span></span>).addMultiplier(FAVORITE_MULTIPLIER).build(); assertEquals(expectedBonus, bonus); }</code> </pre> <br>  Perlu dicatat bahwa dalam pengujian kami merujuk secara khusus ke API publik kelas - metode <code>calculate</code> .  Menguji kontrak kelas alih-alih implementasinya menghindari kerusakan pengujian karena perubahan dan refactoring yang tidak fungsional. <br><br>  Akhirnya, ketika kami memeriksa logika internal dengan unit test, kami tidak perlu lagi memasukkan semua detail ini ke dalam integrasi.  Dalam hal ini, satu atau lebih tes representatif sudah cukup, misalnya ini: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateBonusPoints_twoProductTypes_correctValueCalculated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product1 = product(<span class="hljs-string"><span class="hljs-string">"product1"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"1.01"</span></span>).build(); Product product2 = product(<span class="hljs-string"><span class="hljs-string">"product2"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"10.00"</span></span>).build(); productRepository.save(product1); productRepository.save(product2); Customer customer = customer(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>).build(); customerRepository.save(customer); Map&lt;Long, Long&gt; quantities = mapOf(product1.getId(), <span class="hljs-number"><span class="hljs-number">1L</span></span>, product2.getId(), <span class="hljs-number"><span class="hljs-number">2L</span></span>); BigDecimal bonus = customerController.calculateBonusPoints( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CalculateBonusPointsRequest(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>, quantities) ); BigDecimal bonusPointsProduct1 = bonusPoints(<span class="hljs-string"><span class="hljs-string">"0.10"</span></span>).build(); BigDecimal bonusPointsProduct2 = bonusPoints(<span class="hljs-string"><span class="hljs-string">"1.00"</span></span>).quantity(<span class="hljs-number"><span class="hljs-number">2</span></span>).build(); BigDecimal expectedBonus = bonusPointsProduct1.add(bonusPointsProduct2); assertEquals(expectedBonus, bonus); }</code> </pre> <br>  Seperti dalam kasus tes integrasi, set unit test yang digunakan sangat kecil dan tidak menjamin kebenaran lengkap dari aplikasi.  Namun demikian, kehadirannya secara signifikan meningkatkan kepercayaan terhadap kode, memfasilitasi debugging, dan memberikan bonus lain yang tercantum di bagian pertama artikel. <br><br><a name="ImplementationConsiderations"></a><h2>  Rekomendasi Implementasi </h2><br>  Saya harap bagian sebelumnya cukup untuk meyakinkan setidaknya satu pengembang untuk mulai menggunakan tes dalam proyek mereka.  Bab ini akan secara singkat mencantumkan rekomendasi utama yang akan membantu menghindari masalah serius dan mengarah pada biaya implementasi awal yang lebih rendah. <br><br>  <b>Cobalah untuk mulai menerapkan tes pada aplikasi baru.</b>  Menulis tes pertama dalam proyek lawas yang besar akan jauh lebih sulit dan membutuhkan lebih banyak keterampilan daripada yang baru dibuat.  Karena itu, jika memungkinkan lebih baik untuk memulai dengan aplikasi baru yang kecil.  Jika aplikasi baru yang lengkap tidak diharapkan, Anda dapat mencoba mengembangkan beberapa utilitas yang bermanfaat untuk penggunaan internal.  Hal utama adalah bahwa tugas harus lebih atau kurang realistis - contoh yang ditemukan tidak akan memberikan pengalaman yang lengkap. <br><br>  <b>Siapkan uji coba reguler.</b>  Jika tes tidak berjalan secara teratur, maka mereka tidak hanya berhenti melakukan fungsi utama mereka - memeriksa kebenaran kode - tetapi juga dengan cepat menjadi usang.  Oleh karena itu, sangat penting untuk mengkonfigurasi setidaknya pipa CI minimum dengan peluncuran uji otomatis setiap kali kode diperbarui dalam repositori. <br><br>  <b>Jangan mengejar penutup.</b>  Seperti halnya teknologi lainnya, pada awalnya tes tidak akan diperoleh dengan kualitas terbaik.  Literatur yang relevan (tautan di akhir artikel) atau mentor yang kompeten dapat membantu di sini, tetapi ini tidak membatalkan kebutuhan untuk kerucut yang diisi sendiri.  Pengujian dalam hal ini mirip dengan sisa kode: untuk memahami bagaimana mereka akan mempengaruhi proyek, Anda hanya dapat setelah tinggal bersama mereka untuk sementara waktu.  Oleh karena itu, untuk meminimalkan kerusakan, pertama kali lebih baik tidak mengejar jumlah dan jumlah yang indah seperti cakupan seratus persen.  Sebaliknya, Anda harus membatasi diri pada skenario positif utama untuk fungsionalitas aplikasi Anda sendiri. <br><br>  <b>Jangan terbawa oleh unit test.</b>  Melanjutkan tema "kuantitas vs kualitas", perlu dicatat bahwa pengujian unit jujur ​​tidak boleh dilakukan untuk pertama kalinya, karena ini dapat dengan mudah menyebabkan spesifikasi aplikasi yang berlebihan.  Pada gilirannya, ini akan menjadi faktor penghambat yang serius dalam perbaikan aplikasi dan refactoring berikutnya.  Tes unit hanya boleh digunakan jika ada logika kompleks di kelas atau kelompok kelas tertentu, yang tidak nyaman untuk diperiksa di tingkat integrasi. <br><br>  <b>Jangan terbawa oleh kelas rintisan dan metode aplikasi.</b>  Rintisan bertopik (stub, mock) adalah alat lain yang membutuhkan pendekatan yang seimbang dan menjaga keseimbangan.  Di satu sisi, isolasi lengkap unit memungkinkan Anda untuk fokus pada logika yang diuji dan tidak memikirkan sisa sistem.  Di sisi lain, ini akan membutuhkan waktu pengembangan tambahan dan, seperti halnya tes unit, dapat menyebabkan spesifikasi perilaku yang berlebihan. <br><br>  <b>Lepaskan tes integrasi dari sistem eksternal.</b>  Kesalahan yang sangat umum dalam tes integrasi adalah penggunaan database nyata, antrian pesan, dan sistem lain di luar aplikasi.  Tentu saja, kemampuan untuk menjalankan tes di lingkungan nyata berguna untuk debugging dan pengembangan.  Tes semacam itu dalam jumlah kecil mungkin masuk akal, terutama untuk berlari secara interaktif.  Namun, penggunaannya yang meluas menyebabkan sejumlah masalah: <br><br><ol><li>  Untuk menjalankan tes, Anda harus mengkonfigurasi lingkungan eksternal.  Misalnya, instal database pada setiap mesin tempat aplikasi akan dirakit.  Ini akan mempersulit pengembang baru untuk memasuki proyek dan mengkonfigurasi CI. </li><li>  Keadaan sistem eksternal dapat bervariasi pada mesin yang berbeda sebelum menjalankan pengujian.  Misalnya, database mungkin sudah berisi tabel yang dibutuhkan aplikasi dengan data yang tidak diharapkan dalam pengujian.  Ini akan menyebabkan kegagalan yang tidak terduga dalam tes, dan eliminasi mereka akan membutuhkan waktu yang cukup lama. </li><li>  Jika pekerjaan paralel sedang dilakukan pada beberapa proyek, pengaruh yang tidak jelas dari beberapa proyek pada yang lain adalah mungkin.  Misalnya, pengaturan basis data khusus yang dibuat untuk salah satu proyek dapat membantu fungsionalitas proyek lain bekerja dengan benar, yang, bagaimanapun, akan pecah ketika diluncurkan pada database yang bersih di mesin lain. </li><li>  Tes dilakukan untuk waktu yang lama: putaran penuh dapat mencapai puluhan menit.  Ini mengarah pada fakta bahwa pengembang berhenti menjalankan tes secara lokal dan melihat hasilnya hanya setelah mengirim perubahan ke repositori jarak jauh.  Perilaku ini meniadakan sebagian besar keuntungan dari tes, yang dibahas pada bagian pertama artikel. </li></ol><br>  <b>Kosongkan konteks antara tes integrasi.</b>  Seringkali, untuk mempercepat kerja tes integrasi, Anda harus menggunakan kembali konteks yang sama di antara mereka.  Bahkan dokumentasi resmi Spring membuat rekomendasi semacam itu.  Dalam hal ini, pengaruh tes satu sama lain harus dihindari.  Karena mereka diluncurkan dalam urutan yang sewenang-wenang, keberadaan koneksi tersebut dapat menyebabkan kesalahan acak yang tidak dapat diproduksi kembali.  Untuk mencegah hal ini terjadi, tes tidak boleh meninggalkan perubahan dalam konteks.  Misalnya, ketika menggunakan database, untuk isolasi biasanya cukup untuk memutar kembali semua transaksi yang dilakukan dalam pengujian.  Jika perubahan pada konteks tidak dapat dihindari, Anda dapat mengonfigurasi rekreasi menggunakan anotasi <code>@DirtiesContext</code> . <br><br> <b>  ,      .</b>         ,       - .    ,            .  ,   , —      ,           . <br><br> <b>      .</b>      ,    ,       . ,    ,       . <br><br> <b>   TDD (Test-Driven Development).</b> TDD    ,      ,     .  ,        ,     .   ,         ,        . <br><br><h2>   ,  ? </h2><br>              ,  : <br><br><ol><li>       (  )?             . </li><li>           ,      ( ,  CI)?    . </li><li>     ?                     . </li><li>     ?    .   ,      ,      . </li></ol><br>        ,      .     , , -   .   —           . <br><br><a name="Conclusion"></a><h2>  Kesimpulan </h2><br>       ,     .    -    ,    .  ,  -      .        —         ,      ,    -.      ,                 . <br><br> ,    ,        ,            ! <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   GitHub</a> <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Growing Object-Oriented Software, Guided by Tests</a> , Steve Freeman, Nat Pryce <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">The Art of Unit Testing</a> , Roy Osherove <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Test-driven Development: By Example</a> , Kent Beck <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Refactoring: Improving the Design of Existing Code</a> , Martin Fowler <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id427603/">https://habr.com/ru/post/id427603/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id427589/index.html">Kami menulis obrolan online di Websockets menggunakan Swoole</a></li>
<li><a href="../id427591/index.html">Arsitektur sebagai beban</a></li>
<li><a href="../id427593/index.html">Magic Perintah Cepat di Vivaldi 2.1</a></li>
<li><a href="../id427595/index.html">Coba Micronaut atau Sayang, saya mengurangi kerangka</a></li>
<li><a href="../id427601/index.html">Kasus 5 + 1 di mana spesifikasi REST API memainkan peran besar</a></li>
<li><a href="../id427605/index.html">Bagaimana platform crowdsourcing Yandex membantu melatih drone dan mengevaluasi kualitas layanan</a></li>
<li><a href="../id427607/index.html">Datacenter di Swiss: bekerja seperti jarum jam</a></li>
<li><a href="../id427609/index.html">Memecahkan persamaan dengan pembagian integer tanpa kekuatan kasar</a></li>
<li><a href="../id427611/index.html">Kisah bagaimana saya memperbarui Yandex MapKit di iOS atau peta, uang, 2 pemetaan</a></li>
<li><a href="../id427613/index.html">10 blog bermanfaat untuk programmer dalam bahasa Inggris</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>