<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☪️ 🤜🏾 🔹 Piglet Gunung Berapi, atau SQL do-it-yourself 🐙 🕺🏻 🙋🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pengumpulan, penyimpanan, konversi, dan penyajian data adalah tantangan utama yang dihadapi para insinyur data. Departemen Badoo Intelijen Bisnis mene...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Piglet Gunung Berapi, atau SQL do-it-yourself</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/461699/"><p><img src="https://habrastorage.org/webt/sl/pt/ay/slptaynsfh2p62e4epxcf6_xfaw.jpeg"></p><br><p>  Pengumpulan, penyimpanan, konversi, dan penyajian data adalah tantangan utama yang dihadapi para insinyur data.  Departemen Badoo Intelijen Bisnis menerima dan memproses lebih dari 20 miliar peristiwa yang dikirim dari perangkat pengguna per hari, atau 2 TB data yang masuk. </p><br><p>  Studi dan interpretasi dari semua data ini tidak selalu merupakan tugas sepele, kadang-kadang menjadi perlu untuk melampaui kemampuan database yang sudah jadi.  Dan jika Anda memiliki keberanian dan memutuskan untuk melakukan sesuatu yang baru, Anda harus terlebih dahulu membiasakan diri dengan prinsip kerja dari solusi yang ada. </p><br><p>  Singkatnya, penasaran dan pengembang yang berpikiran kuat, artikel ini ditujukan.  Di dalamnya Anda akan menemukan deskripsi model tradisional pelaksanaan query di database relasional menggunakan bahasa demo PigletQL sebagai contoh. </p><a name="habracut"></a><br><h1 id="soderzhanie">  Isi </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Latar belakang</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Struktur penerjemah SQL</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Eksekusi Model Volcano dan Query</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PigletQL</a> <br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Leksikal dan parser</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penganalisis semantik</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengkompilasi Pertanyaan ke Tampilan Menengah</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Eksekusi presentasi sementara</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Operator</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh kerja</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kesimpulan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sastra</a> </li></ul><br><h1 id="predystoriya">  Latar belakang </h1><br><p>  Kelompok insinyur kami terlibat dalam backend dan interface, memberikan peluang untuk analisis dan penelitian data di dalam perusahaan (omong-omong, kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memperluas</a> ).  Alat standar kami adalah database terdistribusi dari puluhan server (Exasol) dan cluster Hadoop untuk ratusan mesin (Hive dan Presto). </p><br><p>  Sebagian besar pertanyaan pada basis data ini bersifat analitis, yaitu, memengaruhi dari ratusan ribu hingga milyaran catatan.  Eksekusi mereka membutuhkan waktu beberapa menit, puluhan menit atau bahkan berjam-jam, tergantung pada solusi yang digunakan dan kompleksitas permintaan.  Dengan kerja manual dari pengguna-analis, waktu seperti itu dianggap dapat diterima, tetapi tidak cocok untuk penelitian interaktif melalui antarmuka pengguna. </p><br><p>  Seiring waktu, kami menyoroti kueri dan kueri analitik populer, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">yang sulit ditetapkan dalam hal</a> SQL, dan mengembangkan basis data khusus kecil untuknya.  Mereka menyimpan subset data dalam format yang sesuai untuk algoritma kompresi ringan (misalnya, streamvbyte), yang memungkinkan Anda untuk menyimpan data dalam satu mesin selama beberapa hari dan menjalankan query dalam hitungan detik. </p><br><p>  Bahasa permintaan pertama untuk data ini dan penerjemahnya diimplementasikan pada firasat, kami harus terus-menerus memperbaikinya, dan setiap kali butuh waktu yang sangat lama. </p><br><p>  Bahasa query tidak cukup fleksibel, meskipun tidak ada alasan yang jelas untuk membatasi kemampuan mereka.  Akibatnya, kami beralih ke pengalaman pengembang penerjemah SQL, berkat itu kami dapat memecahkan sebagian masalah yang muncul. </p><br><p>  Di bawah ini saya akan berbicara tentang model eksekusi permintaan paling umum di database relasional - Volcano.  Kode sumber interpreter dari dialek SQL primitif, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PigletQL</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dilampirkan pada artikel</a> , sehingga setiap orang yang tertarik dapat dengan mudah melihat detail dalam repositori. </p><br><h1 id="struktura-interpretatora-sql">  Struktur penerjemah SQL </h1><br><p> <a href=""><img src="https://habrastorage.org/webt/cw/gc/jr/cwgcjrjdybx4snxrzxqmyh4tu9c.jpeg" alt="Struktur juru bahasa"></a> </p><br><p>  Kebanyakan basis data populer menyediakan antarmuka ke data dalam bentuk bahasa query SQL deklaratif.  Kueri dalam bentuk string dikonversi oleh parser menjadi deskripsi kueri, mirip dengan pohon sintaksis abstrak.  Dimungkinkan untuk mengeksekusi query sederhana yang sudah pada tahap ini, namun, untuk mengoptimalkan transformasi dan eksekusi selanjutnya, representasi ini tidak nyaman.  Dalam database yang saya kenal, representasi perantara diperkenalkan untuk tujuan ini. </p><br><p>  Aljabar relasional menjadi model untuk representasi menengah.  Ini adalah bahasa di mana transformasi ( <em>operator</em> ) dilakukan pada data secara eksplisit dijelaskan: memilih subset data sesuai dengan predikat, menggabungkan data dari sumber yang berbeda, dll. Selain itu, aljabar relasional adalah aljabar dalam arti matematika, yaitu, sejumlah besar setara transformasi.  Oleh karena itu, mudah untuk melakukan transformasi optimal atas permintaan dalam bentuk pohon operator aljabar relasional. </p><br><p>  Ada perbedaan penting antara representasi internal dalam database dan aljabar relasional asli, sehingga lebih tepat untuk menyebutnya <em>aljabar logis</em> . </p><br><p>  Verifikasi validitas kueri biasanya dilakukan ketika menyusun representasi awal kueri ke dalam operator aljabar logis dan sesuai dengan tahap analisis semantik dalam kompiler konvensional.  Peran tabel simbol dalam basis data dimainkan oleh <em>direktori basis data</em> , yang menyimpan informasi tentang skema dan metadata basis data: tabel, kolom tabel, indeks, hak pengguna, dll. </p><br><p>  Dibandingkan dengan interpreter tujuan umum, interpreter database memiliki satu lagi kekhasan: perbedaan dalam volume data dan meta-informasi tentang data yang seharusnya dibuat pertanyaan.  Dalam tabel, atau hubungan dalam hal aljabar relasional, mungkin ada jumlah data yang berbeda, pada beberapa kolom ( <em>atribut</em> hubungan) indeks dapat dibangun, dll. Yaitu, tergantung pada skema database dan jumlah data dalam tabel, kueri harus dilakukan oleh algoritma yang berbeda , dan menggunakannya dalam urutan yang berbeda. </p><br><p>  Untuk mengatasi masalah ini, representasi perantara lain diperkenalkan - <em>aljabar fisik</em> .  Tergantung pada ketersediaan indeks pada kolom, jumlah data dalam tabel, dan struktur pohon aljabar logis, berbagai bentuk pohon aljabar fisik yang ditawarkan, dari mana pilihan terbaik dipilih.  Pohon inilah yang ditampilkan ke database sebagai rencana kueri.  Dalam kompiler konvensional, tahap ini secara kondisional sesuai dengan tahapan alokasi register, perencanaan, dan pemilihan instruksi. </p><br><p>  Langkah terakhir dalam pekerjaan penerjemah adalah langsung eksekusi pohon operator aljabar fisik. </p><br><h1 id="model-volcano-i-ispolnenie-zaprosov">  Eksekusi Model Volcano dan Query </h1><br><p>  Penerjemah pohon aljabar fisik selalu digunakan dalam database komersial tertutup, tetapi literatur akademik biasanya merujuk pada pengoptimal eksperimental Volcano, yang dikembangkan pada awal 90-an. </p><br><p>  Dalam model Volcano, setiap operator dari pohon aljabar fisik berubah menjadi struktur dengan tiga fungsi: buka, berikutnya, tutup.  Selain fungsi, operator berisi status pengoperasian.  Fungsi terbuka memulai keadaan pernyataan, fungsi berikutnya mengembalikan <em>tupel</em> berikutnya (English tuple), atau NULL, jika tidak ada tupel yang tersisa, fungsi tutup mengakhiri pernyataan: </p><br><p><img src="https://habrastorage.org/webt/oj/rs/td/ojrstdsuwcja-qrhljipd3cooeu.jpeg"></p><br><p>  Operator dapat bersarang untuk membentuk pohon operator aljabar fisik.  Setiap operator, dengan demikian, mengulangi tupel dari relasi yang ada pada media nyata atau relasi virtual yang dibentuk dengan menghitung tupel dari operator bersarang: </p><br><p><img src="https://habrastorage.org/webt/qv/pk/pj/qvpkpjoiusjmjxvxj6xlp_lci3y.jpeg"></p><br><p>  Dalam hal bahasa tingkat tinggi modern, pohon operator tersebut adalah kaskade iterator. </p><br><p>  Bahkan interpreter permintaan industri dalam DBMS relasional ditolak dari model Volcano, jadi saya menganggapnya sebagai dasar untuk juru bahasa PigletQL. </p><br><h1 id="pigletql">  PigletQL </h1><br><p><img src="https://habrastorage.org/webt/j9/sq/4w/j9sq4wdaertiyjii_h-vnxihrak.jpeg"></p><br><p>  Untuk mendemonstrasikan model, saya mengembangkan interpreter dari bahasa query terbatas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PigletQL</a> .  Ini ditulis dalam C, mendukung pembuatan tabel dalam gaya SQL, tetapi terbatas pada satu jenis - bilangan bulat positif 32-bit.  Semua tabel ada dalam memori.  Sistem beroperasi dalam satu utas dan tidak memiliki mekanisme transaksi. </p><br><p>  Tidak ada optimizer di PigletQL, dan kueri SELECT dikompilasi langsung ke pohon operator aljabar fisik.  Kueri yang tersisa (CREATE TABLE dan INSERT) berfungsi langsung dari tampilan internal primer. </p><br><p>  Contoh sesi pengguna dalam PigletQL: </p><br><pre><code class="plaintext hljs">&gt; ./pigletql &gt; CREATE TABLE tab1 (col1,col2,col3); &gt; INSERT INTO tab1 VALUES (1,2,3); &gt; INSERT INTO tab1 VALUES (4,5,6); &gt; SELECT col1,col2,col3 FROM tab1; col1 col2 col3 1 2 3 4 5 6 rows: 2 &gt; SELECT col1 FROM tab1 ORDER BY col1 DESC; col1 4 1 rows: 2</code> </pre> <br><h2 id="leksicheskiy-i-sintaksicheskiy-analizatory">  Leksikal dan parser </h2><br><p>  PigletQL adalah bahasa yang sangat sederhana, dan implementasinya tidak diperlukan pada tahap analisis leksikal dan parsing. </p><br><p>  Alat analisis leksikal ditulis dengan tangan.  Objek analyzer ( <a href="">scanner_t</a> ) dibuat dari string kueri, yang memberikan token satu per satu: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">scanner_t</span></span> *scanner_create(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scanner_destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">scanner_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *scanner)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">token_t</span></span> scanner_next(<span class="hljs-keyword"><span class="hljs-keyword">scanner_t</span></span> *scanner);</code> </pre> <br><p>  Parsing dilakukan menggunakan metode keturunan rekursif.  Pertama, objek <a href="">parser_t dibuat</a> , yang, setelah menerima analisa leksikal (scanner_t), mengisi objek query_t dengan informasi tentang permintaan: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">query_t</span></span> *query_create(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">query_destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">query_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *query)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">parser_t</span></span> *parser_create(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parser_destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">parser_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *parser)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parser_parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">parser_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *parser, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">scanner_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *scanner, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">query_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *query)</span></span></span></span>;</code> </pre> <br><p>  Hasil penguraian dalam query_t adalah salah satu dari tiga jenis permintaan yang didukung oleh PigletQL: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> query_tag { QUERY_SELECT, QUERY_CREATE_TABLE, QUERY_INSERT, } query_tag; <span class="hljs-comment"><span class="hljs-comment">/* * ... query_select_t, query_create_table_t, query_insert_t definitions ... **/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">query_t</span></span></span><span class="hljs-class"> {</span></span> query_tag tag; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">query_select_t</span></span> select; <span class="hljs-keyword"><span class="hljs-keyword">query_create_table_t</span></span> create_table; <span class="hljs-keyword"><span class="hljs-keyword">query_insert_t</span></span> insert; } as; } <span class="hljs-keyword"><span class="hljs-keyword">query_t</span></span>;</code> </pre> <br><p>  Jenis kueri paling rumit dalam PigletQL adalah SELECT.  Ini sesuai dengan <a href="">struktur</a> data <a href="">query_select_t</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">query_select_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Attributes to output */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">attr_name_t</span></span> attr_names[MAX_ATTR_NUM]; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> attr_num; <span class="hljs-comment"><span class="hljs-comment">/* Relations to get tuples from */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rel_name_t</span></span> rel_names[MAX_REL_NUM]; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> rel_num; <span class="hljs-comment"><span class="hljs-comment">/* Predicates to apply to tuples */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">query_predicate_t</span></span> predicates[MAX_PRED_NUM]; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pred_num; <span class="hljs-comment"><span class="hljs-comment">/* Pick an attribute to sort by */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> has_order; <span class="hljs-keyword"><span class="hljs-keyword">attr_name_t</span></span> order_by_attr; <span class="hljs-keyword"><span class="hljs-keyword">sort_order_t</span></span> order_type; } <span class="hljs-keyword"><span class="hljs-keyword">query_select_t</span></span>;</code> </pre> <br><p>  Struktur ini berisi deskripsi kueri (array atribut yang diminta oleh pengguna), daftar sumber data - hubungan, array predikat tupel pemfilteran, dan informasi tentang atribut yang digunakan untuk mengurutkan hasil. </p><br><h2 id="semanticheskiy-analizator">  Penganalisis semantik </h2><br><p>  Fase analisis semantik dalam SQL biasa melibatkan memeriksa keberadaan tabel yang terdaftar, kolom dalam tabel, dan ketik memeriksa ekspresi kueri.  Untuk pemeriksaan terkait dengan tabel dan kolom, direktori basis data digunakan, tempat semua informasi tentang struktur data disimpan. </p><br><p>  Tidak ada ekspresi kompleks di PigletQL, jadi pengecekan kueri dikurangi menjadi pengecekan metadata katalog tabel dan kolom.  Kueri SELECT, misalnya, <a href="">divalidasi</a> oleh fungsi <a href="">validate_select</a> .  Saya akan membawanya dalam bentuk singkat: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate_select</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">catalogue_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *cat, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">query_select_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *query)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* All the relations should exist */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> rel_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; rel_i &lt; query-&gt;rel_num; rel_i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (catalogue_get_relation(cat, query-&gt;rel_names[rel_i])) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"Error: relation '%s' does not exist\n"</span></span>, query-&gt;rel_names[rel_i]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* Relation names should be unique */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!rel_names_unique(query-&gt;rel_names, query-&gt;rel_num)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Attribute names should be unique */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!attr_names_unique(query-&gt;attr_names, query-&gt;attr_num)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Attributes should be present in relations listed */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ORDER BY attribute should be available in the list of attributes chosen */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Predicate attributes should be available in the list of attributes projected */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><p>  Jika permintaan tersebut valid, maka langkah selanjutnya adalah mengkompilasi parse tree menjadi tree operator. </p><br><h2 id="kompilyaciya-zaprosov-v-promezhutochnoe-predstavlenie">  Mengkompilasi Pertanyaan ke Tampilan Menengah </h2><br><p> <a href=""><img src="https://habrastorage.org/webt/b3/7i/6a/b37i6a7mfq9z6adzpkmdpcuunls.jpeg"></a> </p><br><p>  Dalam penerjemah SQL penuh, biasanya ada dua representasi menengah: aljabar logis dan fisik. </p><br><p>  Seorang juru bahasa PigletQL sederhana melakukan CREATE TABLE dan INSERT queries langsung dari pohon parsing, yaitu, <a href="">query_create_table_t</a> dan <a href="">struktur query_insert_t</a> .  Permintaan SELECT yang lebih kompleks dikompilasi menjadi representasi perantara tunggal, yang akan dieksekusi oleh penerjemah. </p><br><p>  Pohon operator dibuat dari daun ke akar dalam urutan berikut: </p><br><ol><li><p>  Dari bagian kanan kueri ("... FROM relation1, relation2, ..."), nama-nama relasi yang diinginkan diperoleh, untuk masing-masing pernyataan pemindaian dibuat. </p><br></li><li><p>  Mengekstrak tupel dari relasi, operator pemindaian digabungkan menjadi pohon biner sisi kiri melalui operator gabungan. </p><br></li><li><p>  Atribut yang diminta oleh pengguna ("SELECT attr1, attr2, ...") dipilih oleh pernyataan proyek. </p><br></li><li><p>  Jika ada predikat ditentukan ("... WHERE a = 1 AND b&gt; 10 ..."), maka pernyataan pilih ditambahkan ke pohon di atas. </p><br></li><li><p>  Jika metode untuk menyortir hasil ditentukan ("... ORDER BY attr1 DESC"), maka operator penyortiran ditambahkan ke bagian atas pohon. </p><br></li></ol><br><p>  Kompilasi dalam <a href="">kode</a> PigletQL: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *compile_select(<span class="hljs-keyword"><span class="hljs-keyword">catalogue_t</span></span> *cat, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">query_select_t</span></span> *query) { <span class="hljs-comment"><span class="hljs-comment">/* Current root operator */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *root_op = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 1. Scan ops */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 2. Join ops*/</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> rel_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">relation_t</span></span> *rel = catalogue_get_relation(cat, query-&gt;rel_names[rel_i]); root_op = scan_op_create(rel); rel_i += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; rel_i &lt; query-&gt;rel_num; rel_i++) { rel = catalogue_get_relation(cat, query-&gt;rel_names[rel_i]); <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *scan_op = scan_op_create(rel); root_op = join_op_create(root_op, scan_op); } } <span class="hljs-comment"><span class="hljs-comment">/* 3. Project */</span></span> root_op = proj_op_create(root_op, query-&gt;attr_names, query-&gt;attr_num); <span class="hljs-comment"><span class="hljs-comment">/* 4. Select */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (query-&gt;pred_num &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *select_op = select_op_create(root_op); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> pred_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; pred_i &lt; query-&gt;pred_num; pred_i++) { <span class="hljs-keyword"><span class="hljs-keyword">query_predicate_t</span></span> predicate = query-&gt;predicates[pred_i]; <span class="hljs-comment"><span class="hljs-comment">/* Add a predicate to the select operator */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } root_op = select_op; } <span class="hljs-comment"><span class="hljs-comment">/* 5. Sort */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (query-&gt;has_order) root_op = sort_op_create(root_op, query-&gt;order_by_attr, query-&gt;order_type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> root_op; }</code> </pre> <br><p>  Setelah pohon terbentuk, transformasi optimasi biasanya dilakukan, tetapi PigletQL segera melanjutkan ke tahap pelaksanaan representasi perantara. </p><br><h2 id="ispolnenie-promezhutochnogo-predstavleniya">  Eksekusi presentasi sementara </h2><br><p> <a href=""><img src="https://habrastorage.org/webt/q7/dj/xe/q7djxezm_g_dcjund49iztea5ec.jpeg"></a> </p><br><p>  Model Volcano menyiratkan antarmuka untuk bekerja dengan operator melalui tiga operasi terbuka / berikutnya / penutupan umum.  Intinya, setiap pernyataan Volcano adalah sebuah iterator yang darinya tupel "ditarik" satu per satu, sehingga pendekatan eksekusi ini juga disebut model tarik. </p><br><p>  Masing-masing iterator itu sendiri dapat memanggil fungsi iterator bersarang yang sama, membuat tabel sementara dengan hasil antara, dan mengonversi tupel yang masuk. </p><br><p>  Mengeksekusi <a href="">kueri SELECT</a> dalam PigletQL: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eval_select</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">catalogue_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *cat, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">query_select_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *query)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Compile the operator tree: */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *root_op = compile_select(cat, query); <span class="hljs-comment"><span class="hljs-comment">/* Eval the tree: */</span></span> { root_op-&gt;open(root_op-&gt;state); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> tuples_received = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *tuple = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((tuple = root_op-&gt;next(root_op-&gt;state))) { <span class="hljs-comment"><span class="hljs-comment">/* attribute list for the first row only */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tuples_received == <span class="hljs-number"><span class="hljs-number">0</span></span>) dump_tuple_header(tuple); <span class="hljs-comment"><span class="hljs-comment">/* A table of tuples */</span></span> dump_tuple(tuple); tuples_received++; } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"rows: %zu\n"</span></span>, tuples_received); root_op-&gt;close(root_op-&gt;state); } root_op-&gt;destroy(root_op); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><p>  Permintaan pertama dikompilasi oleh fungsi compile_select, yang mengembalikan root dari pohon operator, setelah itu fungsi buka / berikutnya / tutup yang sama dipanggil pada operator root.  Setiap panggilan ke berikutnya mengembalikan tuple berikutnya atau NULL.  Dalam kasus terakhir, ini berarti bahwa semua tupel telah diekstraksi, dan fungsi iterator yang dekat harus dipanggil. </p><br><p>  Tupel yang dihasilkan dihitung ulang dan output oleh tabel ke aliran output standar. </p><br><h2 id="operatory">  Operator </h2><br><p>  Hal yang paling menarik tentang PigletQL adalah pohon operator.  Saya akan menunjukkan perangkat beberapa dari mereka. </p><br><p>  Operator memiliki <a href="">antarmuka</a> umum dan terdiri dari pointer ke fungsi buka / berikutnya / tutup dan fungsi penghancuran tambahan, yang melepaskan sumber daya dari seluruh pohon operator sekaligus: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*op_open)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *(*op_next)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *state); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*op_close)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*op_destroy)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">operator_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *op)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* The operator itself is just 4 pointers to related ops and operator state */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator_t</span></span></span><span class="hljs-class"> {</span></span> op_open open; op_next next; op_close close; op_destroy destroy; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *state; } ;</code> </pre> <br><p>  Selain fungsi, operator dapat berisi keadaan internal yang sewenang-wenang (penunjuk keadaan). </p><br><p>  Di bawah ini saya akan menganalisis perangkat dari dua operator yang menarik: pemindaian paling sederhana dan membuat semacam hubungan perantara. </p><br><h3 id="operator-scan">  Pernyataan pemindaian </h3><br><p>  Pernyataan yang memulai kueri apa pun adalah pemindaian.  Dia hanya melewati semua tupel hubungan.  <a href="">Keadaan internal pemindaian</a> adalah penunjuk ke relasi tempat tupel akan diambil, indeks tupel berikutnya dalam relasi, dan struktur tautan ke tupel saat ini yang diteruskan ke pengguna: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scan_op_state_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* A reference to the relation being scanned */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">relation_t</span></span> *relation; <span class="hljs-comment"><span class="hljs-comment">/* Next tuple index to retrieve from the relation */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> next_tuple_i; <span class="hljs-comment"><span class="hljs-comment">/* A structure to be filled with references to tuple data */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> current_tuple; } <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span>;</code> </pre> <br><p>  Untuk membuat status pernyataan pemindaian, Anda memerlukan relasi sumber;  segala sesuatu yang lain (pointer ke fungsi yang sesuai) sudah diketahui: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *scan_op_create(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">relation_t</span></span> *relation) { <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *op = <span class="hljs-built_in"><span class="hljs-built_in">calloc</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*op)); assert(op); *op = (<span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span>) { .open = scan_op_open, .next = scan_op_next, .close = scan_op_close, .destroy = scan_op_destroy, }; <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span> *state = <span class="hljs-built_in"><span class="hljs-built_in">calloc</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*state)); assert(state); *state = (<span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span>) { .relation = relation, .next_tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>, .current_tuple.tag = TUPLE_SOURCE, .current_tuple.as.source.tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>, .current_tuple.as.source.relation = relation, }; op-&gt;state = state; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> op; }</code> </pre> <br><p>  Buka / tutup operasi dalam kasus tautan setel ulang pindai kembali ke elemen pertama hubungan: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scan_op_open</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span> *op_state = (typeof(op_state)) state; op_state-&gt;next_tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *current_tuple = &amp;op_state-&gt;current_tuple; current_tuple-&gt;as.source.tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scan_op_close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span> *op_state = (typeof(op_state)) state; op_state-&gt;next_tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *current_tuple = &amp;op_state-&gt;current_tuple; current_tuple-&gt;as.source.tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><p>  Panggilan berikutnya akan mengembalikan tupel berikutnya, atau NULL jika tidak ada lagi tupel dalam relasi: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *scan_op_next(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *state) { <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span> *op_state = (typeof(op_state)) state; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (op_state-&gt;next_tuple_i &gt;= op_state-&gt;relation-&gt;tuple_num) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">tuple_source_t</span></span> *source_tuple = &amp;op_state-&gt;current_tuple.as.source; source_tuple-&gt;tuple_i = op_state-&gt;next_tuple_i; op_state-&gt;next_tuple_i++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;op_state-&gt;current_tuple; }</code> </pre><br><h3 id="operator-sort">  Sortir pernyataan </h3><br><p>  Pernyataan sortir menghasilkan tupel dalam urutan yang ditentukan oleh pengguna.  Untuk melakukan ini, buat hubungan sementara dengan tupel yang diperoleh dari operator bersarang dan urutkan. </p><br><p>  <a href="">Keadaan internal</a> operator: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sort_op_state_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *source; <span class="hljs-comment"><span class="hljs-comment">/* Attribute to sort tuples by */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">attr_name_t</span></span> sort_attr_name; <span class="hljs-comment"><span class="hljs-comment">/* Sort order, descending or ascending */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sort_order_t</span></span> sort_order; <span class="hljs-comment"><span class="hljs-comment">/* Temporary relation to be used for sorting*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">relation_t</span></span> *tmp_relation; <span class="hljs-comment"><span class="hljs-comment">/* Relation scan op */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *tmp_relation_scan_op; } <span class="hljs-keyword"><span class="hljs-keyword">sort_op_state_t</span></span>;</code> </pre> <br><p>  Penyortiran dilakukan sesuai dengan atribut yang ditentukan dalam permintaan (sort_attr_name dan sort_order) atas rasio waktu (tmp_relation).  Semua ini terjadi ketika fungsi terbuka disebut: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sort_op_open</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">sort_op_state_t</span></span> *op_state = (typeof(op_state)) state; <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *source = op_state-&gt;source; <span class="hljs-comment"><span class="hljs-comment">/* Materialize a table to be sorted */</span></span> source-&gt;open(source-&gt;state); <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *tuple = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((tuple = source-&gt;next(source-&gt;state))) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!op_state-&gt;tmp_relation) { op_state-&gt;tmp_relation = relation_create_for_tuple(tuple); assert(op_state-&gt;tmp_relation); op_state-&gt;tmp_relation_scan_op = scan_op_create(op_state-&gt;tmp_relation); } relation_append_tuple(op_state-&gt;tmp_relation, tuple); } source-&gt;close(source-&gt;state); <span class="hljs-comment"><span class="hljs-comment">/* Sort it */</span></span> relation_order_by(op_state-&gt;tmp_relation, op_state-&gt;sort_attr_name, op_state-&gt;sort_order); <span class="hljs-comment"><span class="hljs-comment">/* Open a scan op on it */</span></span> op_state-&gt;tmp_relation_scan_op-&gt;open(op_state-&gt;tmp_relation_scan_op-&gt;state); }</code> </pre> <br><p>  Pencacahan elemen hubungan sementara dilakukan oleh operator sementara tmp_relation_scan_op: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *sort_op_next(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *state) { <span class="hljs-keyword"><span class="hljs-keyword">sort_op_state_t</span></span> *op_state = (typeof(op_state)) state; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> op_state-&gt;tmp_relation_scan_op-&gt;next(op_state-&gt;tmp_relation_scan_op-&gt;state);; }</code> </pre><br><p>  Hubungan sementara dinonaktifkan dalam fungsi dekat: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sort_op_close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">sort_op_state_t</span></span> *op_state = (typeof(op_state)) state; <span class="hljs-comment"><span class="hljs-comment">/* If there was a tmp relation - destroy it */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (op_state-&gt;tmp_relation) { op_state-&gt;tmp_relation_scan_op-&gt;close(op_state-&gt;tmp_relation_scan_op-&gt;state); scan_op_destroy(op_state-&gt;tmp_relation_scan_op); relation_destroy(op_state-&gt;tmp_relation); op_state-&gt;tmp_relation = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } }</code> </pre><br><p>  Di sini Anda dapat melihat dengan jelas mengapa menyortir operasi pada kolom tanpa indeks bisa memakan banyak waktu. </p><br><h2 id="primery-raboty">  Contoh kerja </h2><br><p>  Saya akan memberikan beberapa contoh pertanyaan PigletQL dan pohon terkait dari aljabar fisik. </p><br><p>  Contoh paling sederhana di mana semua tupel dari relasi dipilih: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletql &gt; create table rel1 (a1,a2,a3); &gt; insert into rel1 values (1,2,3); &gt; insert into rel1 values (4,5,6); &gt; select a1 from rel1; a1 1 4 rows: 2 &gt;</code> </pre> <br><p>  Untuk kueri yang paling sederhana, hanya mengambil tupel dari relasi pemindaian yang digunakan, dan memilih satu-satunya atribut proyek dari tupel: </p><br><p><img src="https://habrastorage.org/webt/3n/63/oa/3n63oa4mcglybfftogb195rdxko.jpeg"></p><br><p>  Memilih tupel dengan predikat: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletql &gt; create table rel1 (a1,a2,a3); &gt; insert into rel1 values (1,2,3); &gt; insert into rel1 values (4,5,6); &gt; select a1 from rel1 where a1 &gt; 3; a1 4 rows: 1 &gt;</code> </pre> <br><p>  Predikat diekspresikan oleh pernyataan pilih: </p><br><p><img src="https://habrastorage.org/webt/h8/82/r7/h882r7yfruh0orjlenqkb-o6lzk.jpeg"></p><br><p>  Pilihan tupel dengan penyortiran: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletql &gt; create table rel1 (a1,a2,a3); &gt; insert into rel1 values (1,2,3); &gt; insert into rel1 values (4,5,6); &gt; select a1 from rel1 order by a1 desc; a1 4 1 rows: 2</code> </pre> <br><p>  Operator sortir dalam panggilan terbuka menciptakan ( <em>mematerialisasi</em> ) hubungan sementara, menempatkan semua tupel yang masuk di sana, dan menyortir keseluruhannya.  Setelah itu, dalam panggilan berikutnya, ia menyimpulkan tupel dari hubungan sementara dalam urutan yang ditentukan oleh pengguna: </p><br><p><img src="https://habrastorage.org/webt/oq/ec/ap/oqecap_w6sdwv3-d7fckp2lfeyo.jpeg"></p><br><p>  Menggabungkan tupel dua hubungan dengan predikat: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletql &gt; create table rel1 (a1,a2,a3); &gt; insert into rel1 values (1,2,3); &gt; insert into rel1 values (4,5,6); &gt; create table rel2 (a4,a5,a6); &gt; insert into rel2 values (7,8,6); &gt; insert into rel2 values (9,10,6); &gt; select a1,a2,a3,a4,a5,a6 from rel1, rel2 where a3=a6; a1 a2 a3 a4 a5 a6 4 5 6 7 8 6 4 5 6 9 10 6 rows: 2</code> </pre> <br><p>  Operator gabungan di PigletQL tidak menggunakan algoritme kompleks apa pun, tetapi cukup membentuk produk Cartesian dari kumpulan tupel subpohon kiri dan kanan.  Ini sangat tidak efisien, tetapi untuk penerjemah demo, ini akan berhasil: </p><br><p><img src="https://habrastorage.org/webt/if/ct/zp/ifctzpcu29dnns3ijm3bwlckzyk.jpeg"></p><br><h1 id="vyvody">  Kesimpulan </h1><br><p>  Sebagai kesimpulan, saya perhatikan bahwa jika Anda membuat juru bahasa yang mirip dengan SQL, maka Anda mungkin harus mengambil salah satu dari banyak basis data relasional yang tersedia.  Ribuan orang-tahun telah diinvestasikan dalam pengoptimal dan pengalih permintaan modern dari basis data populer, dan butuh bertahun-tahun untuk mengembangkan bahkan basis data keperluan umum yang paling sederhana. </p><br><p>  Bahasa demo PigletQL meniru karya penerjemah SQL, tetapi dalam kenyataannya kami hanya menggunakan elemen individu dari arsitektur Volcano dan hanya untuk itu (jarang!) Jenis pertanyaan yang sulit untuk diungkapkan dalam kerangka model relasional. </p><br><p>  Namun demikian, saya ulangi: bahkan seorang kenalan dangkal dengan arsitektur penerjemah seperti itu berguna dalam kasus-kasus di mana perlu untuk bekerja secara fleksibel dengan aliran data. </p><br><h1 id="literatura">  Sastra </h1><br><p>  Jika Anda tertarik pada masalah dasar pengembangan basis data, maka buku lebih baik daripada “Implementasi sistem basis data” (Garcia-Molina H., Ullman JD, Widom J., 2000), Anda tidak akan menemukannya. </p><br><p>  Satu-satunya kelemahan adalah orientasi teoretis.  Secara pribadi, saya suka ketika contoh konkret kode atau bahkan proyek demo dilampirkan ke materi.  Untuk ini, Anda bisa merujuk ke buku "Perancangan dan implementasi basis data" (Sciore E., 2008), yang menyediakan kode lengkap untuk basis data relasional di Jawa. </p><br><p>  Database relasional paling populer masih menggunakan variasi pada tema Volcano.  Publikasi asli ditulis dalam bahasa yang sangat mudah diakses dan dapat dengan mudah ditemukan di Google Cendekia: "Gunung berapi - sistem evaluasi kueri paralel dan diperluas" (Graefe G., 1994). </p><br><p>  Meskipun SQL interpreter telah berubah sedikit lebih detail selama beberapa dekade terakhir, struktur yang sangat umum dari sistem ini tidak berubah untuk waktu yang sangat lama.  Anda bisa mendapatkan ide dari makalah ulasan oleh penulis yang sama, "Teknik evaluasi kueri untuk database besar" (Graefe G. 1993). </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461699/">https://habr.com/ru/post/id461699/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461689/index.html">Identifikasi IoT Pengembang</a></li>
<li><a href="../id461691/index.html">Bagaimana kami menutup kerentanan di OS Astra Linux Edisi Khusus</a></li>
<li><a href="../id461693/index.html">OpenCV 4 kompilasi silang untuk Raspberry Pi dan BeagleBone Black</a></li>
<li><a href="../id461695/index.html">Magang VFX</a></li>
<li><a href="../id461697/index.html">Kecerdasan Bir</a></li>
<li><a href="../id461703/index.html">Pelaporan microstepping dalam pekerjaan seorang programmer</a></li>
<li><a href="../id461707/index.html">The Adventures of the Elusive Malvari, Bagian V: Lebih Banyak DDE dan COM Scriptlets</a></li>
<li><a href="../id461709/index.html">Apa yang diharapkan jika Anda ingin menjadi pengembang iOS</a></li>
<li><a href="../id461713/index.html">4 cara untuk menghemat cadangan cloud</a></li>
<li><a href="../id461715/index.html">Ketakutan dan Kebencian sebagai Techdir</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>