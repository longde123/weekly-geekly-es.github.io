<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤ŸğŸ½ ğŸ”‡ ğŸ‘¨â€ğŸ‘§ Java: hal-hal yang mungkin tampak aneh bagi pengembang yang berpengalaman ğŸ¦ ğŸ‘¨â€ğŸ‘©â€ğŸ‘¦â€ğŸ‘¦ â“</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Waktu yang baik hari ini! 

 Artikel ini ditulis setelah publikasi â€œThings You [Mungkin] Tidak Tahu Tentang Javaâ€ oleh penulis lain, yang akan saya kl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Java: hal-hal yang mungkin tampak aneh bagi pengembang yang berpengalaman</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482950/"> Waktu yang baik hari ini! <br><br>  Artikel ini ditulis setelah publikasi <a href="https://habr.com/ru/post/482364">â€œThings You [Mungkin] Tidak Tahu Tentang Javaâ€ oleh</a> penulis lain, yang akan saya klasifikasikan sebagai â€œuntuk pemulaâ€.  Membaca dan berkomentar tentang itu, saya menyadari bahwa ada beberapa hal yang cukup menarik yang saya pelajari, sudah pemrograman di java selama lebih dari satu tahun.  Mungkin hal-hal ini akan terasa aneh bagi orang lain. <br><br><a name="habracut"></a>  Fakta-fakta yang, dari sudut pandang saya, mungkin berguna bagi pemula, saya hapus dalam "spoiler".  Beberapa hal mungkin masih menarik untuk yang lebih berpengalaman.  Sebagai contoh, saya sendiri tidak tahu sampai saat menulis artikel bahwa Boolean.hashCode (true) == 1231 dan Boolean.hashCode (false) == 1237. <br><br><div class="spoiler">  <b class="spoiler_title">untuk pemula</b> <div class="spoiler_text"><ul><li>  Boolean.hashCode (true) == 1231 </li><li>  Boolean.hashCode (false) == 1237 </li><li>  Float.hashCode (value) == Float.floatToIntBits (value) </li><li>  Double.hashCode (value) - xor dari halfwords 32-bit pertama dan kedua Double.doubleToLongBits (value) </li></ul></div></div><br><h2>  Object.hashCode () tidak lagi menjadi alamat suatu objek dalam memori </h2><br>  Penafian: Ini adalah detail jvm dari Oracle (HotSpot). <br><br><div class="spoiler">  <b class="spoiler_title">Sekali waktu ini begitu.</b> <div class="spoiler_text">  Dari jdk1.2.1 / docs / api / java / lang / Object.html # hashCode (): <blockquote>  Sebanyak yang cukup praktis, metode hashCode yang didefinisikan oleh class Object mengembalikan integer yang berbeda untuk objek yang berbeda.  (Ini biasanya diterapkan dengan mengubah alamat internal objek menjadi integer, tetapi teknik implementasi ini tidak diperlukan oleh bahasa pemrograman JavaTM.) </blockquote></div></div><br>  Kemudian mereka menolaknya.  Ini adalah apa yang dikatakan <a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/lang/Object.html" rel="nofollow">javadoc untuk jdk 12</a> . <br><br>  <a href="https://habr.com/ru/users/vladimir_dolzhenko/" class="user_link">vladimir_dolzhenko</a> menyarankan agar perilaku lama dapat dikembalikan menggunakan -XX: hashCode = 4.  Dan perubahan perilaku itu sendiri hampir dari versi java 1.2. <br><br><h2>  Integer.valueOf (15) == Integer.valueOf (15);  Integer.valueOf (128)! = Integer.valueOf (128) </h2><br>  Penafian: ini adalah bagian dari <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html" rel="nofollow">jls</a> . <br><br>  Jelas bahwa ketika membandingkan dua pembungkus dengan Operator == (! =), Tidak ada autoboxing terjadi.  Secara umum, ini adalah persamaan pertama yang membingungkan.  Faktanya adalah bahwa untuk nilai integer i: -129 &lt;i &lt;128 Objek pembungkus integer di-cache.  Oleh karena itu, untuk saya dari rentang ini, Integer.valueOf (i) tidak membuat objek baru setiap kali, tetapi mengembalikan yang sudah dibuat.  Untuk saya yang tidak termasuk dalam kisaran ini, Integer.valueOf (i) selalu membuat objek baru.  Oleh karena itu, jika Anda tidak memonitor secara cermat apa yang sebenarnya dan bagaimana tepatnya dibandingkan, Anda dapat menulis kode yang tampaknya berfungsi dan bahkan ditutupi dengan tes, tetapi pada saat yang sama mengandung "rake". <br><br>  Dalam jvm dari Oracle (HotSpot), batas atas caching dapat diubah melalui properti <a href="" rel="nofollow">"java.lang.Integer.IntegerCache.high"</a> . <br><br><h2>  dalam beberapa kasus, nilai-nilai bidang statis akhir primitif atau string dari kelas lain diselesaikan pada waktu kompilasi </h2><br>  Kedengarannya membingungkan, dan pernyataannya agak panjang.  Artinya adalah ini.  Jika kita memiliki kelas yang mendefinisikan konstanta tipe atau string primitif sebagai bidang statis akhir dengan inisialisasi langsung, <br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnotherClass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String CASE_1 = <span class="hljs-string"><span class="hljs-string">"case_1"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String CASE_2 = <span class="hljs-string"><span class="hljs-string">"case_2"</span></span>; }</code> </pre> <br>  ketika digunakan di kelas lain, <pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TheClass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... public static int getCaseNumber(String caseName) { switch (caseName) { case AnotherClass.CASE_1: return 1; case AnotherClass.CASE_2: return 2; default: throw new IllegalArgumentException("value of the argument caseName does not belong to the allowed value set"); } } }</span></span></code> </pre><br>  nilai konstanta ini ("case_1", "case_2") diselesaikan pada waktu kompilasi.  Dan mereka dimasukkan ke dalam kode sebagai nilai, dan bukan sebagai tautan.  Yaitu, jika kita menggunakan konstanta seperti itu dari perpustakaan, dan kemudian kita mendapatkan versi baru dari perpustakaan di mana nilai-nilai konstanta telah berubah, kita harus mengkompilasi ulang proyek.  Jika tidak, nilai konstanta lama dapat terus digunakan dalam kode. <br><br>  Perilaku ini diamati di semua tempat di mana ekspresi konstan (misalnya, switch / case) harus digunakan, atau kompiler diperbolehkan untuk mengubah ekspresi menjadi konstan dan ia dapat melakukannya. <br><br>  Bidang ini tidak dapat digunakan dalam ekspresi konstan segera setelah kami menghapus inisialisasi langsung dengan mentransfer inisialisasi ke blok statis. <br><br><div class="spoiler">  <b class="spoiler_title">untuk pemula</b> <div class="spoiler_text"><h2>  Dalam kondisi tertentu, pemulung tidak akan pernah lari. </h2><br>  Akibatnya, finalisasi () tidak akan diluncurkan.  Oleh karena itu, Anda tidak boleh menulis kode yang bergantung pada fakta bahwa finalize () akan selalu berfungsi.  Ya, dan jika objek masuk ke sampah sebelum akhir program, kemungkinan besar tidak akan dikumpulkan oleh kolektor. <br><br><h2>  Metode finalize () untuk objek tertentu dapat dipanggil sekali dan hanya sekali. </h2><br>  Pada finalize (), kita dapat membuat objek terlihat kembali, dan pemulung tidak akan "menghapus" kali ini.  Ketika objek ini jatuh ke sampah lagi, itu akan "dikompilasi" tanpa memanggil finalize ().  Jika pengecualian dilemparkan ke finalize () dan objek masih tidak terlihat oleh siapa pun, maka akan "dirakit".  Finalisasi () tidak akan dipanggil lagi. <br><br><h2>  aliran tempat finalisasi () akan dipanggil tidak diketahui sebelumnya </h2><br>  Hanya dijamin bahwa utas ini akan bebas dari kunci yang terlihat oleh program utama. <br><br><h2>  keberadaan metode finalisasi () yang ditimpa pada objek memperlambat proses pengumpulan sampah </h2><br>  Apa yang ada di permukaan adalah kebutuhan untuk mengecek ketersediaan objek - sekali sebelum memanggil finalize (), sekali di salah satu dari pengumpulan pengumpulan sampah berikut. <br><br><h2>  sangat sulit untuk mengatasi kebuntuan dalam menyelesaikan () </h2><br>  Dalam finalisasi non-sepele (), kunci mungkin diperlukan, yang, mengingat spesifik yang dijelaskan di atas, sangat sulit untuk di-debug. <br><br><h2>  Object.finalize () karena versi 9 java ditandai sebagai usang! </h2><br>  Yang tidak mengejutkan, mengingat spesifik yang dijelaskan di atas. </div></div><br><h2>  inisialisasi malas tunggal klasik: diperlukan penguncian ganda </h2><br>  Ada kesalahpahaman tentang topik ini bahwa pendekatan berikut (periksa idiom), yang terlihat sangat logis, selalu berhasil: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnsafeDCLFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Singleton instance; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Singleton </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (instance == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// read 1, check 1 synchronized (this) { if (instance == null) { // read 2, check 2 instance = new Singleton(); } } } return instance; // read 3 } }</span></span></code> </pre><br>  Kami melihat apakah objek dibuat (baca 1, centang 1).  Jika demikian, kembalikan.  Jika tidak, maka atur kunci, pastikan objek tidak dibuat, buat objek (kunci dilepas), dan kembalikan objek. <br><br>  Pendekatan tidak berfungsi karena alasan berikut.  <s>(baca 1, periksa 1) dan (baca 3) tidak sinkron.</s>  <s>Menurut konsep model memori java, perubahan yang dilakukan pada utas lain mungkin tidak dapat dilihat oleh utas kami hingga kami menyinkronkan.</s>  Terima kasih <a href="https://habr.com/ru/users/mk2/" class="user_link">mk2</a> untuk komentarnya, berikut adalah deskripsi masalahnya yang benar: <br><blockquote>  Ya, read1 dan read3 tidak disinkronkan, tetapi masalahnya bukan pada utas lainnya.  Dan fakta bahwa bacaan yang tidak disinkronkan dapat disusun ulang, mis.  read1! = null, tetapi read3 == null.  Dan pada saat yang sama, karena "instance = new Singleton ();" kita bisa mendapatkan referensi ke objek sebelum benar-benar dibangun, dan ini benar-benar masalah sinkronisasi dengan utas lain, tetapi bukan read1 dan read3, tetapi read3 dan akses untuk anggota contoh. </blockquote>  Itu diperlakukan baik dengan menambahkan sinkronisasi selama membaca, atau dengan menandai variabel di mana tautan ke singleton hidup, volatile.  (Solusi dengan volatile hanya berfungsi dengan java 5+. Sebelum itu, java memiliki model memori dengan ketidakpastian dalam situasi ini.) Ini adalah versi yang berfungsi (dengan optimasi tambahan - variabel lokal `res` ditambahkan untuk mengurangi jumlah bacaan dari bidang volatile). <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SafeLocalDCLFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Singleton instance; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Singleton </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Singleton res = instance; <span class="hljs-comment"><span class="hljs-comment">// read 1 if (res == null) { // check 1 synchronized (this) { res = instance; // read 2 if (res == null) { // check 2 res = new Singleton(); instance = res; } } } return res; } }</span></span></code> </pre><br>  Kode diambil <a href="https://shipilev.net/blog/2014/safe-public-construction/" rel="nofollow">dari sini</a> , dari situs Alexei Shipilev.  Rincian lebih lanjut tentang masalah ini dapat ditemukan di sana. <br><br><h2>  "Idiom inisialisasi sesuai permintaan" - inisialisasi "malas" yang sangat indah dari singleton </h2><br>  java menginisialisasi kelas (objek Kelas) hanya seperlunya dan, tentu saja, hanya sekali.  Dan Anda bisa memanfaatkan ini!  Mekanisme idiom pemegang inisialisasi atas permintaan tidak hanya itu.  (Kode ini <a href="https://en.wikipedia.org/wiki/Initialization-on-demand_holder_idiom" rel="nofollow">dari sini</a> .) <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Something</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Something</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LazyHolder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Something INSTANCE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Something(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Something </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LazyHolder.INSTANCE; } }</code> </pre><br>  Kelas LazyHolder hanya akan diinisialisasi saat Something.getInstance () pertama kali dipanggil.  Jvm akan memastikan bahwa ini hanya terjadi sekali dan, apalagi, sangat efisien - jika kelas sudah diinisialisasi, tidak akan ada overhead.  Dengan demikian, LazyHolder.INSTANCE juga akan diinisialisasi sekali, "malas" dan thread-safe. <div class="spoiler">  <b class="spoiler_title">sepotong spec tentang overhead</b> <div class="spoiler_text">  Jika prosedur inisialisasi ini selesai secara normal dan objek Class sepenuhnya diinisialisasi dan siap untuk digunakan, maka permohonan prosedur inisialisasi tidak lagi diperlukan dan dapat dihilangkan dari kode - misalnya, dengan menambalnya atau membuat ulang kode . <br>  <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html" rel="nofollow">Sumber</a> </div></div><br>  Secara umum, lajang tidak dianggap praktik terbaik. <br><br>  Materi belum berakhir.  Jadi, jika tangan "mencapai" dan apa yang sudah ditulis akan diminati, saya akan menulis lebih banyak tentang topik ini. <br><br>  Terima kasih atas komentar yang membangun.  Beberapa tempat dalam artikel diperluas berkat <a href="https://habr.com/ru/users/sergey-gornostaev/" class="user_link">sergey-gornostaev</a> , <a href="https://habr.com/ru/users/vladimir_dolzhenko/" class="user_link">vladimir_dolzhenko</a> , <a href="https://habr.com/ru/users/olehkurpiak/" class="user_link">OlehKurpiak</a> , <a href="https://habr.com/ru/users/mk2/" class="user_link">mk2</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id482950/">https://habr.com/ru/post/id482950/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id482940/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 396 (30 Desember 2019 - 5 Januari 2020)</a></li>
<li><a href="../id482942/index.html">Mitos dan legenda Fediverse kuno</a></li>
<li><a href="../id482944/index.html">Dispenser Konveyor Multi Komponen</a></li>
<li><a href="../id482946/index.html">1Ğ¡ DSS dan estimasi syarat dan biaya proyek dengan metode COCOMO II</a></li>
<li><a href="../id482948/index.html">"Satu, dua, tiga - bakar pohon Natal!" Atau pandangan pertamaku pada pengontrol mungil CANNY 3</a></li>
<li><a href="../id482956/index.html">Tinjauan WCS 5.2 - Server WebRTC untuk Pengembang Webcast dan Webcam</a></li>
<li><a href="../id482958/index.html">"Aturan pertumbuhan: dari junior ke CTO", abstrak dari webinar oleh Fedor Borshchev</a></li>
<li><a href="../id482960/index.html">Tinjauan Umum WCS 5.2 - Server WebRTC untuk Pengembang Web Siaran Daring dan Video Chat</a></li>
<li><a href="../id482968/index.html">Quarkus - Pandangan Baru Di Cloud Native Java</a></li>
<li><a href="../id482970/index.html">Hack The Box - Walkthrough Craft. Kami menggali Git, mengeksploitasi kerentanan dalam API, berurusan dengan Vault</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>