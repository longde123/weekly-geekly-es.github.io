<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚎 ⛷️ ⏭️ Menciptakan Tower Defense in Unity, Bagian 1 🚭 ⛵️ 💬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lapangan 


- Membuat bidang ubin. 
- Jalur pencarian menggunakan pencarian luas pertama. 
- Terapkan dukungan untuk ubin kosong dan ujung, serta ubin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menciptakan Tower Defense in Unity, Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449798/"><h1>  Lapangan </h1><br><ul><li>  Membuat bidang ubin. </li><li>  Jalur pencarian menggunakan pencarian luas pertama. </li><li>  Terapkan dukungan untuk ubin kosong dan ujung, serta ubin dinding. </li><li>  Mengedit konten dalam mode game. </li><li>  Tampilan opsional bidang dan jalur kisi. </li></ul><br>  Ini adalah bagian pertama dari serangkaian tutorial tentang cara membuat gim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertahanan menara</a> sederhana.  Pada bagian ini, kami akan mempertimbangkan untuk menciptakan lapangan bermain, menemukan jalan, dan menempatkan ubin dan dinding akhir. <br><br>  Tutorial dibuat di Unity 2018.3.0f2. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3d/ae4/591/c3dae459169a0a7f0ce240763b91d55c.jpg"></div><br>  <i>Bidang yang siap digunakan dalam permainan ubin genre menara pertahanan.</i> <br><br><h2>  Game Tower Defense </h2><br>  Menara pertahanan adalah genre di mana tujuan pemain adalah untuk menghancurkan kerumunan musuh sampai mereka mencapai titik akhir mereka.  Pemain memenuhi tujuannya dengan membangun menara yang menyerang musuh.  Genre ini memiliki banyak variasi.  Kami akan membuat game dengan bidang ubin.  Musuh akan bergerak melintasi lapangan menuju titik akhir mereka, dan pemain akan membuat rintangan untuk mereka. <br><a name="habracut"></a><br>  Saya akan berasumsi bahwa Anda telah mempelajari serangkaian tutorial tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengelola objek</a> . <br><br><h3>  Lapangan </h3><br>  Lapangan bermain adalah bagian terpenting dari permainan, jadi kami akan membuatnya terlebih dahulu.  Ini akan menjadi objek game dengan komponen <code>GameBoard</code> sendiri, yang dapat diinisialisasi dengan mengatur ukuran dalam dua dimensi, untuk itu kita dapat menggunakan nilai <code>Vector2Int</code> .  Field harus bekerja dengan ukuran apa pun, tetapi kami akan memilih ukuran di tempat lain, jadi kami akan membuat metode <code>Initialize</code> umum untuk ini. <br><br>  Selain itu, kami memvisualisasikan bidang dengan satu segi empat, yang akan menunjukkan bumi.  Kami tidak akan membuat objek bidang itu sendiri sebagai segi empat, tetapi menambahkan objek quad anak ke dalamnya.  Setelah inisialisasi, kita akan membuat skala XY bumi sama dengan ukuran lapangan.  Artinya, setiap ubin akan memiliki ukuran satu unit persegi ukuran untuk mesin. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameBoard</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { [SerializeField] Transform ground = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; Vector2Int size; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int size</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size = size; ground.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(size.x, size.y, <span class="hljs-number"><span class="hljs-number">1f</span></span>); } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Mengapa secara eksplisit menetapkan ground ke nilai default?</b> <div class="spoiler_text">  Idenya adalah bahwa segala sesuatu yang dapat disesuaikan melalui editor Unity dapat diakses melalui bidang tersembunyi berseri.  Perlu bahwa bidang-bidang ini hanya dapat diubah di inspektur.  Sayangnya, editor Unity akan terus menampilkan peringatan kompiler bahwa nilainya tidak pernah ditetapkan.  Kami dapat menekan peringatan ini dengan secara eksplisit menetapkan nilai default untuk bidang tersebut.  Anda juga dapat menetapkan <code>null</code> , tetapi saya membuatnya agar secara eksplisit menunjukkan bahwa kami hanya menggunakan nilai default, yang bukan merupakan referensi yang benar ke ground, jadi kami menggunakan <code>default</code> . </div></div><br>  Buat objek bidang dalam adegan baru dan tambahkan quad anak dengan bahan yang terlihat seperti bumi.  Karena kami membuat game prototipe sederhana, bahan hijau yang seragam akan cukup.  Putar quad 90 ° sepanjang sumbu X sehingga terletak pada bidang XZ. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db9/9b8/9af/db99b89afcc551541f1f6adbe4816e54.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa8/f7c/77d/fa8f7c77d6697bca5e3c8823f5adcd86.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2a/467/015/f2a467015b8eefc8ca956eaec61d50dc.png"></div><br>  <i>Lapangan bermain.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Mengapa tidak memposisikan game di pesawat XY?</b> <div class="spoiler_text">  Meskipun game akan berlangsung dalam ruang 2D, kami akan membuatnya dalam 3D, dengan musuh 3D dan kamera yang dapat dipindahkan relatif ke titik tertentu.  Pesawat XZ lebih nyaman untuk ini dan sesuai dengan orientasi skybox standar yang digunakan untuk pencahayaan sekitar. </div></div><br><h3>  Permainan </h3><br>  Selanjutnya, buat komponen <code>Game</code> yang akan bertanggung jawab untuk seluruh game.  Pada tahap ini, ini berarti akan menginisialisasi bidang.  Kami hanya membuat ukuran dapat disesuaikan melalui inspektur dan memaksa komponen untuk menginisialisasi bidang ketika bangun.  Mari kita gunakan ukuran standar 11 × 11. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Game</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { [SerializeField] Vector2Int boardSize = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>); [SerializeField] GameBoard board = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { board.Initialize(boardSize); } }</code> </pre> <br>  Ukuran bidang hanya bisa positif dan tidak masuk akal untuk membuat bidang dengan satu ubin.  Jadi mari kita batasi minimum hingga 2 × 2.  Ini dapat dilakukan dengan menambahkan metode <code>OnValidate</code> , secara paksa membatasi nilai minimum. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnValidate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boardSize.x &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { boardSize.x = <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boardSize.y &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { boardSize.y = <span class="hljs-number"><span class="hljs-number">2</span></span>; } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Kapan Onvalidate dipanggil?</b> <div class="spoiler_text">  Jika ada, editor Unity memanggilnya untuk komponen setelah mengubahnya.  Termasuk saat menambahkannya ke objek game, setelah memuat adegan, setelah mengkompilasi ulang, setelah mengubah editor, setelah membatalkan / mencoba ulang, dan setelah mengatur ulang komponen. <br><br>  <code>OnValidate</code> adalah satu-satunya tempat di kode tempat Anda dapat menetapkan nilai ke bidang konfigurasi komponen. </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ae/15d/efd/7ae15defd1e838186f922fc30d346b17.png"></div><br>  <i>Objek game.</i> <br><br>  Sekarang, ketika Anda memulai mode permainan, kami akan menerima bidang dengan ukuran yang benar.  Selama permainan, posisikan kamera sehingga seluruh papan terlihat, salin komponen transformasinya, keluar dari mode putar dan rekatkan nilai-nilai komponen.  Dalam kasus bidang 11 × 11 di titik asal, untuk mendapatkan tampilan yang nyaman dari atas, Anda dapat memposisikan kamera pada posisi (0.10.0) dan memutarnya 90 ° di sepanjang sumbu X. Kami akan membiarkan kamera dalam posisi tetap ini, tetapi dimungkinkan ubahlah di masa depan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb5/45c/421/eb545c421fdca09acf1258a2fac9e183.png"></div><br>  <i>Kamera di atas lapangan.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Bagaimana cara menyalin dan menempelkan nilai komponen?</b> <div class="spoiler_text">  Melalui menu drop-down yang muncul ketika Anda mengklik tombol dengan roda gigi di sudut kanan atas komponen. </div></div><br><h3>  Kotak cetakan </h3><br>  Lapangan terdiri dari ubin persegi.  Musuh akan dapat bergerak dari ubin ke ubin, melintasi tepi, tetapi tidak secara diagonal.  Gerakan akan selalu terjadi menuju titik akhir terdekat.  Mari kita secara grafis menunjukkan arah gerakan sepanjang ubin dengan panah.  Anda dapat mengunduh tekstur panah di <a href="">sini</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tf/l6/os/tfl6oszqhi93v6aqlllrp1yuhli.png"></div><br>  <i>Panah di latar belakang hitam.</i> <br><br>  Tempatkan tekstur panah di proyek Anda dan aktifkan opsi <em>Alpha As Transparency</em> .  Kemudian buat bahan untuk panah, yang bisa menjadi bahan default untuk mode potongan yang dipilih, dan pilih panah sebagai tekstur utama. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bfb/2d6/56c/bfb2d656c07931b8f59ef11715eee93b.png"></div><br>  <i>Bahan panah.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Mengapa menggunakan mode render potongan?</b> <div class="spoiler_text">  Ini memungkinkan Anda untuk mengaburkan panah menggunakan pipa render Unity standar. </div></div><br>  Untuk menunjukkan setiap ubin dalam game, kami akan menggunakan objek game.  Masing-masing dari mereka akan memiliki quad sendiri dengan bahan panah, seperti halnya lapangan memiliki quad bumi.  Kami juga akan menambahkan ubin ke komponen GameTile dengan tautan ke panah mereka. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTile</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { [SerializeField] Transform arrow = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }</code> </pre> <br>  Buat objek ubin dan mengubahnya menjadi cetakan.  Ubin akan rata dengan tanah, jadi naikkan panah sedikit untuk menghindari masalah dengan kedalaman saat rendering.  Perkecil juga sedikit, sehingga ada sedikit ruang di antara panah yang berdekatan.  Y offset 0,001 dan skala 0,8 yang sama untuk semua sumbu akan dilakukan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f12/02b/6d8/f1202b6d8f8f33593bf56ef0d8665537.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/964/1ac/a4b/9641aca4b874f48c3765af10e2c83157.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df7/7a3/c9f/df77a3c9f539083eab845be6b9c62919.png"></div><br>  <i>Kotak cetakan.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Di mana hierarki pabrikan cetakan?</b> <div class="spoiler_text">  Anda dapat membuka mode edit cetakan dengan mengklik dua kali pada aset cetakan, atau dengan memilih cetakan dan mengklik tombol <em>Buka Cetakan</em> di inspektur.  Anda dapat keluar dari mode edit cetakan dengan mengklik tombol dengan panah di sudut kiri atas hierarki header-nya. </div></div><br>  Perhatikan bahwa ubin itu sendiri tidak harus menjadi objek game.  Mereka hanya diperlukan untuk melacak keadaan lapangan.  Kita bisa menggunakan pendekatan yang sama dengan perilaku dalam rangkaian tutorial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Manajemen Objek</a> .  Namun pada tahap awal game sederhana atau prototipe objek game, kami cukup senang.  Ini bisa diubah di masa depan. <br><br><h3>  Kami punya ubin </h3><br>  Untuk membuat ubin, <code>GameBoard</code> harus memiliki tautan ke prefab ubin. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTile tilePrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/363/6c2/044/3636c204442368c58858152a7c3efee2.png"></div><br>  <i>Tautan ke ubin cetakan.</i> <br><br>  Dia kemudian dapat membuat instansnya menggunakan loop ganda di atas dua dimensi grid.  Meskipun ukurannya dinyatakan sebagai X dan Y, kami akan mengatur ubin pada bidang XZ, serta bidang itu sendiri.  Karena bidang dipusatkan relatif terhadap asal, kita perlu mengurangi ukuran yang sesuai dikurangi satu dibagi dua dari komponen posisi ubin.  Harap dicatat bahwa ini harus menjadi divisi floating point, jika tidak, ukurannya tidak akan berlaku. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int size</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size = size; ground.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(size.x, size.y, <span class="hljs-number"><span class="hljs-number">1f</span></span>); Vector2 offset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2( (size.x - <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, (size.y - <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++) { GameTile tile = Instantiate(tilePrefab); tile.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); tile.transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3( x - offset.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, y - offset.y ); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/391/265/640/391265640fe99dd10be005de76ce93f3.png"></div><br>  <i>Contoh ubin yang dibuat.</i> <br><br>  Nanti kita akan membutuhkan akses ke ubin ini, jadi kita akan melacaknya dalam sebuah array.  Kami tidak perlu daftar, karena setelah inisialisasi, ukuran bidang tidak akan berubah. <br><br><pre> <code class="cs hljs"> GameTile[] tiles; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int size</span></span></span><span class="hljs-function">)</span></span> { … tiles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameTile[size.x * size.y]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { GameTile tile = tiles[i] = Instantiate(tilePrefab); … } } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Bagaimana cara kerja tugas ini?</b> <div class="spoiler_text">  Ini adalah tugas yang ditautkan.  Dalam hal ini, ini berarti bahwa kami menetapkan tautan ke turunan ubin ke elemen array dan variabel lokal.  Operasi ini melakukan hal yang sama seperti kode yang ditunjukkan di bawah ini. <br><br><pre> <code class="cs hljs">GameTile t = Instantiate(tilePrefab); tiles[i] = t; GameTile tile = t;</code> </pre> </div></div><br><h2>  Cari cara </h2><br>  Pada tahap ini, setiap ubin memiliki panah, tetapi semuanya menunjuk ke arah positif sumbu Z, yang akan kita tafsirkan sebagai utara.  Langkah selanjutnya adalah menentukan arah yang benar untuk ubin.  Kami melakukan ini dengan menemukan jalan yang harus dilalui musuh ke titik akhir. <br><br><h3>  Tetangga Tetangga </h3><br>  Jalur pergi dari ubin ke ubin, di utara, timur, selatan atau barat.  Untuk mempermudah pencarian, buat <code>GameTile</code> track <code>GameTile</code> ke empat tetangganya. <br><br><pre> <code class="cs hljs"> GameTile north, east, south, west;</code> </pre> <br>  Hubungan antar tetangga simetris.  Jika ubin adalah tetangga timur ubin kedua, maka yang kedua adalah tetangga barat yang pertama.  Tambahkan metode statis umum ke <code>GameTile</code> untuk menentukan hubungan ini antara dua ubin. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeEastWestNeighbors</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile east, GameTile west</span></span></span><span class="hljs-function">)</span></span> { west.east = east; east.west = west; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Mengapa menggunakan metode statis?</b> <div class="spoiler_text">  Kita dapat menjadikannya metode instan dengan parameter tunggal, dan dalam hal ini kita akan menyebutnya sebagai <code>eastTile.MakeEastWestNeighbors(westTile)</code> atau sesuatu seperti itu.  Tetapi dalam kasus-kasus di mana tidak jelas ubin mana dari metode yang harus dipanggil, lebih baik menggunakan metode statis.  Contohnya adalah metode <code>Distance</code> dan <code>Dot</code> dari kelas <code>Vector3</code> . </div></div><br>  Setelah terhubung, seharusnya tidak pernah berubah.  Jika ini terjadi, maka kami membuat kesalahan dalam kode.  Anda dapat memverifikasi ini dengan membandingkan kedua tautan sebelum menetapkan nilai ke <code>null</code> , dan menampilkan kesalahan jika salah.  Anda dapat menggunakan metode <code>Debug.Assert</code> untuk <code>Debug.Assert</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeEastWestNeighbors</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile east, GameTile west</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert( west.east == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; east.west == <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Redefined neighbors!"</span></span> ); west.east = east; east.west = west; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Apa yang dilakukan dengan Debug.Assert?</b> <div class="spoiler_text">  Jika argumen pertama <code>false</code> , maka itu menampilkan kesalahan kondisi, menggunakan argumen kedua jika ditentukan.  Panggilan semacam itu hanya termasuk dalam uji coba bangunan, tetapi tidak dalam uji coba rilis.  Oleh karena itu, ini adalah cara yang baik untuk menambahkan pemeriksaan selama proses pengembangan yang tidak akan mempengaruhi rilis akhir. </div></div><br>  Tambahkan metode serupa untuk menciptakan hubungan antara tetangga utara dan selatan. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeNorthSouthNeighbors</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile north, GameTile south</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert( south.north == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; north.south == <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Redefined neighbors!"</span></span> ); south.north = north; north.south = south; }</code> </pre> <br>  Kami dapat menjalin hubungan ini saat membuat ubin di <code>GameBoard.Initialize</code> .  Jika koordinat X lebih besar dari nol, maka kita dapat membuat hubungan timur-barat antara ubin saat ini dan sebelumnya.  Jika koordinat Y lebih besar dari nol, maka kita dapat membuat hubungan utara-selatan antara ubin saat ini dan ubin dari baris sebelumnya. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { GameTile.MakeEastWestNeighbors(tile, tiles[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { GameTile.MakeNorthSouthNeighbors(tile, tiles[i - size.x]); } } }</code> </pre> <br>  Perhatikan bahwa ubin di tepi lapangan tidak memiliki empat tetangga.  Satu atau dua referensi tetangga akan tetap <code>null</code> . <br><br><h3>  Jarak dan arah </h3><br>  Kami tidak akan memaksa semua musuh untuk terus mencari jalan.  Ini perlu dilakukan hanya sekali per ubin.  Maka musuh akan dapat meminta dari ubin di mana mereka berada di mana harus pindah.  Kami akan menyimpan informasi ini di <code>GameTile</code> dengan menambahkan tautan ke ubin jalur berikutnya.  Selain itu, kami juga akan menghemat jarak ke titik akhir, dinyatakan sebagai jumlah ubin yang harus dikunjungi sebelum musuh mencapai titik akhir.  Untuk musuh, informasi ini tidak berguna, tetapi kami akan menggunakannya untuk menemukan jalur terpendek. <br><br><pre> <code class="cs hljs"> GameTile north, east, south, west, nextOnPath; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance;</code> </pre> <br>  Setiap kali kita memutuskan bahwa kita perlu mencari jalur, kita perlu menginisialisasi data jalur.  Sampai jalan ditemukan, tidak ada ubin berikutnya dan jarak dapat dianggap tak terbatas.  Kita bisa membayangkan ini sebagai nilai integer maksimum yang mungkin dari <code>int.MaxValue</code> .  Tambahkan metode <code>GameTile</code> generik untuk mengatur ulang <code>GameTile</code> ke kondisi ini. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; nextOnPath = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Jalur hanya dapat dicari jika kita memiliki titik akhir.  Ini berarti bahwa ubin harus menjadi titik akhir.  Ubin tersebut memiliki jarak nol, dan tidak memiliki ubin terakhir, karena jalur berakhir di atasnya.  Tambahkan metode generik yang mengubah ubin menjadi titik akhir. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BecomeDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; nextOnPath = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Pada akhirnya, semua ubin harus berubah menjadi jalur, sehingga jaraknya tidak lagi sama dengan nilai <code>int.MaxValue</code> . <code>int.MaxValue</code> .  Tambahkan properti pengambil yang nyaman untuk memeriksa apakah ubin saat ini memiliki jalur. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasPath =&gt; distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Bagaimana cara kerja properti ini?</b> <div class="spoiler_text">  Ini adalah entri singkat untuk properti pengambil yang hanya berisi satu ekspresi.  Itu tidak sama dengan kode yang ditunjukkan di bawah ini. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasPath { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } }</code> </pre> <br>  Operator panah <code>=&gt;</code> juga dapat digunakan secara individual untuk pengambil dan penyetel properti, untuk kumpulan metode, konstruktor, dan di beberapa tempat lain. </div></div><br><h3>  Kami tumbuh dengan cara </h3><br>  Jika kita memiliki ubin dengan jalan, maka kita dapat membiarkannya menumbuhkan jalan menuju salah satu tetangganya.  Awalnya, satu-satunya ubin dengan jalan adalah titik akhir, jadi kita mulai dari jarak nol dan meningkatkannya dari sini, bergerak ke arah yang berlawanan dengan pergerakan musuh.  Artinya, semua tetangga langsung dari titik akhir akan memiliki jarak 1, dan semua tetangga ubin ini akan memiliki jarak 2, dan seterusnya. <br><br>  Tambahkan metode tersembunyi <code>GameTile</code> untuk menumbuhkan jalur ke salah satu tetangganya, ditentukan melalui parameter.  Jarak ke tetangga adalah satu lebih dari ubin saat ini, dan jalur tetangga menunjukkan ubin saat ini.  Metode ini seharusnya hanya dipanggil untuk ubin yang sudah memiliki jalur, jadi mari kita periksa ini dengan tegas. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(HasPath, <span class="hljs-string"><span class="hljs-string">"No path!"</span></span>); neighbor.distance = distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbor.nextOnPath = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br>  Idenya adalah bahwa kita memanggil metode ini satu kali untuk masing-masing dari empat tetangga ubin.  Karena beberapa tautan ini akan menjadi <code>null</code> , kami akan memeriksa ini dan menghentikan eksekusi, jika demikian.  Selain itu, jika tetangga sudah memiliki jalan, maka kita tidak boleh melakukan apa-apa dan juga berhenti melakukannya. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(HasPath, <span class="hljs-string"><span class="hljs-string">"No path!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.HasPath) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } neighbor.distance = distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbor.nextOnPath = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br>  Cara <code>GameTile</code> melacak tetangganya tidak diketahui oleh kode lainnya.  Karenanya, <code>GrowPathTo</code> disembunyikan.  Kami akan menambahkan metode umum yang memberi tahu ubin untuk menumbuhkan jalurnya ke arah tertentu, secara tidak langsung memanggil <code>GrowPathTo</code> .  Tetapi kode yang mencari di seluruh bidang harus melacak ubin yang dikunjungi.  Karenanya, kami akan membuatnya mengembalikan tetangga atau <code>null</code> jika eksekusi dihentikan. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HasPath || neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.HasPath) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } neighbor.distance = distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbor.nextOnPath = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbor; }</code> </pre> <br>  Sekarang tambahkan metode untuk menumbuhkan jalur ke arah tertentu. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathNorth</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(north); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathEast</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(east); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathSouth</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(south); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathWest</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(west);</code> </pre> <br><h3>  Pencarian luas </h3><br>  <code>GameBoard</code> harus <code>GameBoard</code> bahwa semua ubin berisi data jalur yang benar.  Kami melakukan ini dengan melakukan pencarian luas pertama.  Mari kita mulai dengan ubin titik akhir, dan kemudian menumbuhkan jalur ke tetangganya, lalu ke tetangga dari ubin ini, dan seterusnya.  Dengan setiap langkah, jarak bertambah satu, dan jalan tidak pernah tumbuh ke arah ubin yang sudah memiliki jalan.  Ini memastikan bahwa semua petak sebagai hasilnya akan menunjuk di sepanjang jalur terpendek ke titik akhir. <br><br><div class="spoiler">  <b class="spoiler_title">Bagaimana dengan menemukan jalur menggunakan A *?</b> <div class="spoiler_text">  Algoritma A <sup>*</sup> adalah pengembangan evolusioner pencarian pertama.  Ini berguna ketika kita mencari satu-satunya jalan terpendek.  Tetapi kita membutuhkan semua jalur terpendek, sehingga A <sup>*</sup> tidak memberikan keuntungan apa pun.  Untuk contoh pencarian luas pertama dan A <sup>*</sup> pada kisi segi enam dengan animasi, lihat seri tutorial tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">peta segi enam</a> . </div></div><br>  Untuk melakukan pencarian, kita perlu melacak petak yang kita tambahkan ke jalur, tetapi dari sana kita belum mengembangkan jalur.  Kumpulan ubin ini sering disebut perbatasan pencarian.  Penting bahwa ubin diproses dalam urutan yang sama ketika ditambahkan ke perbatasan, jadi mari kita gunakan <code>Queue</code> .  Nanti kita harus melakukan pencarian beberapa kali, jadi mari kita atur sebagai bidang <code>GameBoard</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameBoard</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { … Queue&lt;GameTile&gt; searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Queue&lt;GameTile&gt;(); … }</code> </pre> <br>  Agar keadaan lapangan selalu benar, kita harus menemukan jalur di akhir <code>Initialize</code> , tetapi menempatkan kode dalam metode <code>FindPaths</code> terpisah.  Pertama-tama, Anda harus menghapus jalur semua ubin, lalu buat satu ubin titik akhir dan tambahkan ke perbatasan.  Mari kita pilih ubin pertama.  Karena <code>tiles</code> adalah array, kita dapat menggunakan <code>foreach</code> tanpa takut akan polusi memori.  Jika nanti kita beralih dari array ke daftar, kita juga perlu mengganti <code>foreach</code> loop dengan <code>for</code> loop. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int size</span></span></span><span class="hljs-function">)</span></span> { … FindPaths(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ClearPath(); } tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>].BecomeDestination(); searchFrontier.Enqueue(tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }</code> </pre> <br>  Selanjutnya, kita perlu mengambil satu ubin dari perbatasan dan menumbuhkan jalur ke semua tetangganya, menambahkan mereka semua ke perbatasan.  Pertama kita akan bergerak ke utara, lalu ke timur, selatan dan akhirnya ke barat. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ClearPath(); } tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>].BecomeDestination(); searchFrontier.Enqueue(tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>]); GameTile tile = searchFrontier.Dequeue(); searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathWest()); }</code> </pre> <br>  Kami ulangi tahap ini, sementara ada ubin di perbatasan. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { GameTile tile = searchFrontier.Dequeue(); searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathWest()); }</code> </pre> <br>  Menumbuhkan jalan tidak selalu membawa kita ke ubin baru.  Sebelum menambahkan ke antrian, kita perlu memeriksa nilai untuk <code>null</code> , tetapi kita dapat menunda cek untuk <code>null</code> sampai setelah output dari antrian. <br><br><pre> <code class="cs hljs"> GameTile tile = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathWest()); }</code> </pre> <br><h3>  Tampilkan jalurnya </h3><br>  Sekarang kami memiliki bidang yang berisi jalur yang benar, tetapi sejauh ini kami tidak melihat ini.  Anda perlu mengkonfigurasi panah sehingga mereka menunjuk di sepanjang jalan melalui ubin mereka.  Ini dapat dilakukan dengan memutarnya.  Karena belokan ini selalu sama, kami menambahkan ke <code>GameTile</code> satu bidang <code>Quaternion</code> statis untuk masing-masing arah. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Quaternion northRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), eastRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), southRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">180f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), westRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">270f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>);</code> </pre> <br>  Juga tambahkan metode <code>ShowPath</code> umum.  Jika jaraknya nol, maka petak adalah titik akhir dan tidak ada yang mengarah, jadi nonaktifkan panahnya.  Jika tidak, aktifkan panah dan atur putarannya.  Arah yang diinginkan dapat ditentukan dengan membandingkan <code>nextOnPath</code> dengan tetangganya. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance == <span class="hljs-number"><span class="hljs-number">0</span></span>) { arrow.gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } arrow.gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); arrow.localRotation = nextOnPath == north ? northRotation : nextOnPath == east ? eastRotation : nextOnPath == south ? southRotation : westRotation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panggil metode ini untuk semua ubin di akhir </font></font><code>GameBoard.FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ShowPath(); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2d/4fe/4d5/b2d4fe4d511b4e729910ea78b267f268.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menemukan cara.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa kita tidak mengubah panah secara langsung menjadi GrowPathTo?</font></font></b> <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memisahkan logika dan visualisasi pencarian. </font><font style="vertical-align: inherit;">Nanti kita akan membuat visualisasi dinonaktifkan. </font><font style="vertical-align: inherit;">Jika panah tidak muncul, kita tidak perlu memutarnya setiap kali kita memanggil </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ubah prioritas pencarian </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ternyata ketika titik akhir adalah sudut barat daya, semua jalan menuju ke barat sampai mereka mencapai tepi lapangan, setelah itu mereka berbelok ke selatan. </font><font style="vertical-align: inherit;">Semuanya benar di sini, karena sebenarnya tidak ada jalur yang lebih pendek ke titik akhir, karena gerakan diagonal tidak mungkin. </font><font style="vertical-align: inherit;">Namun, ada banyak jalur terpendek lainnya yang mungkin terlihat lebih cantik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk lebih memahami mengapa jalan seperti itu ditemukan, pindahkan titik akhir ke tengah peta. </font><font style="vertical-align: inherit;">Dengan ukuran bidang yang aneh, itu hanya ubin di tengah array.</font></font><br><br><pre> <code class="cs hljs"> tiles[tiles.Length / <span class="hljs-number"><span class="hljs-number">2</span></span>].BecomeDestination(); searchFrontier.Enqueue(tiles[tiles.Length / <span class="hljs-number"><span class="hljs-number">2</span></span>]);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d3/d09/d78/6d3d09d7844fbe6a4aaf4618449598de.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Titik akhir di tengah.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hasilnya tampak logis jika Anda mengingat cara kerja pencarian. Karena kami menambahkan tetangga dalam urutan timur laut-barat daya, utara memiliki prioritas tertinggi. Karena kami melakukan pencarian dalam urutan terbalik, ini berarti bahwa arah terakhir yang kami tempuh adalah selatan. Itulah sebabnya mengapa hanya beberapa panah yang menunjuk ke selatan dan banyak yang menunjuk ke timur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat mengubah hasilnya dengan menetapkan prioritas arah. Mari kita tukar timur dan selatan. Jadi kita harus mendapatkan simetri utara-selatan dan timur-barat.</font></font><br><br><pre> <code class="cs hljs"> searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathWest())</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/2c7/0b7/a9a2c70b7d7d178b041f30c11d256ad3.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Urutan pencarian adalah utara-tenggara-barat. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itu terlihat lebih cantik, tetapi lebih baik bagi jalan untuk mengubah arah, mendekati gerakan diagonal di mana ia akan terlihat alami. </font><font style="vertical-align: inherit;">Kita dapat melakukan ini dengan membalik prioritas pencarian ubin tetangga dalam pola kotak-kotak. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alih-alih mencari tahu jenis ubin apa yang kami proses selama pencarian, kami menambah </font></font><code>GameTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">properti umum yang menunjukkan apakah ubin saat ini merupakan alternatif.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsAlternative { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan mengatur properti ini di </font></font><code>GameBoard.Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pertama, tandai ubin sebagai alternatif jika koordinat X-nya genap.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { … tile.IsAlternative = (x &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa operasi (x &amp; 1) == 0 lakukan?</font></font></b> <div class="spoiler_text">   —     (AND).            .       1,       1.  10101010  00001111   00001010. <br><br>       .      0  1.     1, 2, 3, 4   1, 10, 11, 100.  ,       . <br><br>    AND  ,  ,    .    ,       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kedua, kami mengubah tanda hasil jika koordinat Y mereka genap. </font><font style="vertical-align: inherit;">Jadi kita akan membuat pola catur.</font></font><br><br><pre> <code class="cs hljs"> tile.IsAlternative = (x &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((y &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { tile.IsAlternative = !tile.IsAlternative; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kita menjaga urutan yang sama seperti pencarian genteng alternatif, tapi untuk membuat kembali ke semua ubin lainnya. </font><font style="vertical-align: inherit;">Ini akan memaksa jalan ke gerakan diagonal dan membuat zig-zag.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.IsAlternative) { searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathWest()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Enqueue(tile.GrowPathWest()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathNorth()); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b43/e3a/d63/b43e3ad6370a6b552073b4f0b4cf0e8b.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Urutan pencarian variabel.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mengubah Ubin </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada titik ini, semua ubin kosong. </font><font style="vertical-align: inherit;">Satu ubin digunakan sebagai titik akhir, tetapi selain tidak adanya panah yang terlihat, itu terlihat sama dengan orang lain. </font><font style="vertical-align: inherit;">Kami akan menambahkan kemampuan untuk mengubah ubin dengan menempatkan objek di atasnya.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konten Ubin </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objek ubin sendiri hanyalah cara untuk melacak informasi ubin. </font><font style="vertical-align: inherit;">Kami tidak memodifikasi objek ini secara langsung. </font><font style="vertical-align: inherit;">Sebaliknya, tambahkan konten terpisah dan letakkan di bidang. </font><font style="vertical-align: inherit;">Untuk saat ini, kita dapat membedakan antara ubin kosong dan ubin titik akhir. </font><font style="vertical-align: inherit;">Untuk menunjukkan kasus-kasus ini, buat enumerasi </font></font><code>GameTileContentType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> GameTileContentType { Empty, Destination }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selanjutnya, buat tipe komponen </font></font><code>GameTileContent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang memungkinkan Anda untuk mengatur jenis isinya melalui inspektur, dan aksesnya akan melalui properti pengambil yang umum.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTileContent</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { [SerializeField] GameTileContentType type = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameTileContentType Type =&gt; type; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemudian kami akan membuat cetakan untuk dua jenis konten, yang masing-masing memiliki komponen </font></font><code>GameTileContent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan jenis yang ditentukan. </font><font style="vertical-align: inherit;">Mari kita gunakan kubus pipih biru untuk menunjuk ubin titik akhir. </font><font style="vertical-align: inherit;">Karena hampir rata, ia tidak memerlukan collider. </font><font style="vertical-align: inherit;">Untuk menyiapkan konten kosong, gunakan objek game kosong.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f55/25d/8db/f5525d8db707ff187e17ce96a11d86ae.png" width="320" height="262" alt="tujuan"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c6f/463/e19/c6f463e198abca6134b7bc74d3207833.png" width="320" height="176" alt="kosong"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rak pabrikan dari titik akhir dan konten kosong. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan memberikan objek konten ke ubin kosong, karena semua ubin akan selalu memiliki konten, yang berarti kita tidak perlu memeriksa tautan ke konten untuk kesetaraan </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pabrik Konten </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk membuat konten dapat diedit, kami juga akan membuat pabrik untuk ini, menggunakan pendekatan yang sama seperti dalam tutorial </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manajemen Objek</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ini berarti bahwa Anda </font></font><code>GameTileContent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">harus melacak pabrik asli Anda, yang harus ditetapkan hanya sekali, dan mengirim diri Anda kembali ke pabrik dengan metode ini </font></font><code>Recycle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> GameTileContentFactory originFactory; … <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameTileContentFactory OriginFactory { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; originFactory; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { Debug.Assert(originFactory == <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Redefined origin factory!"</span></span>); originFactory = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Recycle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { originFactory.Reclaim(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini mengasumsikan keberadaan </font></font><code>GameTileContentFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, oleh karena itu kami akan membuat jenis objek skrip untuk ini dengan metode yang diperlukan </font></font><code>Recycle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pada tahap ini, kita tidak akan repot dengan penciptaan pabrik yang berfungsi penuh yang menggunakan konten, jadi kita akan membuatnya hanya menghancurkan isinya. </font><font style="vertical-align: inherit;">Nantinya akan dimungkinkan untuk menambahkan penggunaan kembali objek ke pabrik tanpa mengubah sisa kode.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.SceneManagement; [CreateAssetMenu] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTileContentFactory</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reclaim</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContent content</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(content.OriginFactory == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"Wrong factory reclaimed!"</span></span>); Destroy(content.gameObject); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan metode tersembunyi </font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke </font><font style="vertical-align: inherit;">pabrik </font><font style="vertical-align: inherit;">dengan prefab sebagai parameter. </font><font style="vertical-align: inherit;">Di sini kita kembali melewatkan penggunaan kembali objek. </font><font style="vertical-align: inherit;">Dia membuat instance objek, mengatur pabrik aslinya, memindahkannya ke adegan pabrik dan mengembalikannya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContent prefab</span></span></span><span class="hljs-function">)</span></span> { GameTileContent instance = Instantiate(prefab); instance.OriginFactory = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; MoveToFactoryScene(instance.gameObject); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mesin virtual telah dipindahkan ke adegan konten pabrik, yang dapat dibuat sesuai kebutuhan. </font><font style="vertical-align: inherit;">Jika kita berada di editor, maka sebelum membuat adegan, kita perlu memeriksa apakah itu ada, jika kita kehilangan pandangan saat restart panas.</font></font><br><br><pre> <code class="cs hljs"> Scene contentScene; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoveToFactoryScene</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameObject o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!contentScene.isLoaded) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Application.isEditor) { contentScene = SceneManager.GetSceneByName(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!contentScene.isLoaded) { contentScene = SceneManager.CreateScene(name); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { contentScene = SceneManager.CreateScene(name); } } SceneManager.MoveGameObjectToScene(o, contentScene); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami hanya memiliki dua jenis konten, jadi tambahkan saja dua bidang konfigurasi prefab untuknya. </font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContent destinationPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; [SerializeField] GameTileContent emptyPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hal terakhir yang perlu dilakukan agar pabrik dapat berfungsi adalah membuat metode umum </font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan parameter </font></font><code>GameTileContentType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang menerima instance dari cetakan yang sesuai.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContentType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Destination: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(destinationPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Empty: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(emptyPrefab); } Debug.Assert(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"Unsupported type: "</span></span> + type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah wajib menambahkan contoh kosong dari konten kosong ke setiap ubin?</font></font></b> <div class="spoiler_text">       ,               .         .  ,        - , , , ,    .     ,       .     ,        ,   . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mari kita buat aset pabrik dan konfigurasikan tautannya ke cetakan. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7eb/75f/1cd/7eb75f1cd4bed3c72ffd7f0c42b69cbe.png" width="320" height="106"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pabrik Konten </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan kemudian meneruskan </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tautannya ke pabrik.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContentFactory tileContentFactory = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b12/d6a/506/b12d6a5067fa91177dbed14a876f8b3d.png" width="320" height="110"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Game dengan pabrik.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mengetuk ubin </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mengubah bidang, kita harus dapat memilih ubin. Kami akan memungkinkannya dalam mode permainan. Kami akan memancarkan sinar ke adegan di tempat di mana pemain mengklik jendela permainan. Jika balok memotong dengan ubin, maka pemain menyentuhnya, itu harus diubah. </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan menangani input pemain, tetapi akan bertanggung jawab untuk menentukan ubin mana yang disentuh pemain </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak semua sinar berpotongan dengan ubin, jadi terkadang kita tidak akan menerima apa pun. Oleh karena itu, kami menambah </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode </font></font><code>GetTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang selalu selalu mengembalikan pada awalnya </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(ini berarti bahwa ubin tidak ditemukan).</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTile</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menentukan apakah suatu sinar telah melewati ubin, kita perlu memanggil </font></font><code>Physics.Raycast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan menentukan ray sebagai argumen. </font><font style="vertical-align: inherit;">Ini mengembalikan informasi tentang apakah ada persimpangan. </font><font style="vertical-align: inherit;">Jika demikian, maka kami dapat mengembalikan ubin, meskipun kami belum tahu yang mana, jadi untuk saat ini kami akan mengembalikannya </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryGetTile</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mengetahui apakah ada persimpangan dengan ubin, kami memerlukan informasi lebih lanjut tentang persimpangan. </font></font><code>Physics.Raycast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dapat memberikan informasi ini menggunakan parameter kedua </font></font><code>RaycastHit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini adalah parameter output, yang ditunjukkan oleh kata </font></font><code>out</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di depannya. </font><font style="vertical-align: inherit;">Ini berarti bahwa pemanggilan metode dapat memberikan nilai ke variabel yang kami berikan.</font></font><br><br><pre> <code class="cs hljs"> RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kita dapat menanamkan deklarasi variabel yang digunakan untuk parameter output, jadi mari kita lakukan. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> RaycastHit hit) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami tidak peduli dengan collider persimpangan mana yang terjadi, kami hanya menggunakan posisi persimpangan XZ untuk menentukan ubin. </font><font style="vertical-align: inherit;">Kami mendapatkan koordinat ubin dengan menambahkan setengah ukuran bidang ke koordinat titik persimpangan, dan lalu mengonversi hasilnya ke nilai integer. </font><font style="vertical-align: inherit;">Indeks petak akhir sebagai hasilnya adalah koordinat X ditambah koordinat Y dikalikan dengan lebar bidang.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> RaycastHit hit)) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(hit.point.x + size.x * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(hit.point.z + size.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tiles[x + y * size.x]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tapi ini hanya mungkin ketika koordinat ubin berada di dalam bidang, jadi kami akan memeriksanya. </font><font style="vertical-align: inherit;">Jika ini bukan masalahnya, maka ubin tidak akan dikembalikan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(hit.point.x + size.x * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(hit.point.z + size.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; x &lt; size.x &amp;&amp; y &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; y &lt; size.y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tiles[x + y * size.x]; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perubahan konten </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agar Anda dapat mengubah konten ubin, tambahkan ke </font></font><code>GameTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">properti umum </font></font><code>Content</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pembuatnya hanya mengembalikan konten, dan penyetel membuang konten sebelumnya, jika ada, dan menempatkan konten baru.</font></font><br><br><pre> <code class="cs hljs"> GameTileContent content; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameTileContent Content { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; content; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (content != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { content.Recycle(); } content = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; content.transform.localPosition = transform.localPosition; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah satu-satunya tempat Anda perlu memeriksa konten </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, karena pada awalnya kami tidak memiliki konten. </font><font style="vertical-align: inherit;">Untuk menjamin, kami menjalankan pernyataan agar setter tidak dipanggil dengan </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { Debug.Assert(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Null assigned to content!"</span></span>); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan akhirnya, kita membutuhkan input pemain. </font><font style="vertical-align: inherit;">Mengubah klik mouse menjadi sinar dapat dilakukan dengan memanggil </font></font><code>ScreenPointToRay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan </font></font><code>Input.mousePosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebagai argumen. </font><font style="vertical-align: inherit;">Panggilan harus dilakukan untuk kamera utama, yang dapat diakses melalui </font></font><code>Camera.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tambahkan properti c untuk ini </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> Ray TouchRay =&gt; Camera.main.ScreenPointToRay(Input.mousePosition);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemudian kami menambahkan metode </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang memeriksa apakah tombol mouse utama ditekan selama upgrade. </font><font style="vertical-align: inherit;">Untuk melakukan ini, panggil </font></font><code>Input.GetMouseButtonDown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan nol sebagai argumen. </font><font style="vertical-align: inherit;">Jika tombol telah ditekan, kami memproses sentuhan pemain, yaitu, kami mengambil ubin dari bidang dan mengatur titik akhir sebagai isinya, mengambilnya dari pabrik.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { HandleTouch(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { tile.Content = tileContentFactory.Get(GameTileContentType.Destination); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang kita dapat mengubah ubin apa pun menjadi titik akhir dengan menekan kursor. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99a/f15/da3/99af15da39bfc08cb8886b98e0ae15df.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beberapa titik akhir.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Membuat bidang menjadi benar </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun kami dapat mengubah ubin menjadi titik akhir, ini tidak mempengaruhi jalur sejauh ini. </font><font style="vertical-align: inherit;">Selain itu, kami belum menetapkan konten kosong untuk ubin. </font><font style="vertical-align: inherit;">Mempertahankan kebenaran dan integritas bidang adalah tugas </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, jadi mari kita beri dia tanggung jawab mengatur isi ubin. </font><font style="vertical-align: inherit;">Untuk menerapkan ini, kami akan memberikannya tautan ke pabrik konten melalui metodenya </font></font><code>Intialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan menggunakannya untuk memberikan semua ubin contoh konten kosong.</font></font><br><br><pre> <code class="cs hljs"> GameTileContentFactory contentFactory; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector2Int size, GameTileContentFactory contentFactory </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size = size; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.contentFactory = contentFactory; ground.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(size.x, size.y, <span class="hljs-number"><span class="hljs-number">1f</span></span>); tiles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameTile[size.x * size.y]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { … tile.Content = contentFactory.Get(GameTileContentType.Empty); } } FindPaths(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang saya </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">harus memindahkan pabrik saya ke ladang.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { board.Initialize(boardSize, tileContentFactory); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa tidak menambahkan bidang konfigurasi pabrik ke GameBoard?</font></font></b> <div class="spoiler_text">   ,    ,   .        ,       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena sekarang kami memiliki beberapa titik akhir, kami mengubahnya </font></font><code>GameBoard.FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehingga ia memanggil </font></font><code>BecomeDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">masing-masing dan menambahkan semuanya ke perbatasan. </font><font style="vertical-align: inherit;">Dan hanya itu yang diperlukan untuk mendukung banyak titik akhir. </font><font style="vertical-align: inherit;">Semua ubin lainnya dibersihkan seperti biasa. </font><font style="vertical-align: inherit;">Kemudian kami menghapus titik akhir hard-set di tengah.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Destination) { tile.BecomeDestination(); searchFrontier.Enqueue(tile); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tile.ClearPath(); } } <span class="hljs-comment"><span class="hljs-comment">//tiles[tiles.Length / 2].BecomeDestination(); //searchFrontier.Enqueue(tiles[tiles.Length / 2]); … }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi jika kita dapat mengubah ubin menjadi titik akhir, maka kita harus dapat melakukan operasi terbalik, mengubah titik akhir menjadi ubin kosong. </font><font style="vertical-align: inherit;">Tapi kemudian kita bisa mendapatkan bidang tanpa titik akhir sama sekali. </font><font style="vertical-align: inherit;">Dalam hal ini, </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak akan dapat melakukan tugasnya. </font><font style="vertical-align: inherit;">Ini terjadi ketika perbatasan kosong setelah inisialisasi jalur untuk semua sel. </font><font style="vertical-align: inherit;">Kami menyatakan ini sebagai keadaan lapangan yang tidak valid, mengembalikan </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan menyelesaikan eksekusi; </font><font style="vertical-align: inherit;">jika tidak kembali pada akhirnya </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } … <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara termudah untuk mengimplementasikan dukungan untuk menghapus titik akhir, menjadikannya operasi sakelar. Dengan mengeklik ubin kosong, kami akan mengubahnya menjadi titik akhir, dan dengan mengklik titik akhir, kami akan menghapusnya. Tapi sekarang ia terlibat dalam mengubah konten </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, jadi kami akan memberikannya metode umum </font></font><code>ToggleDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang parameternya adalah ubin. Jika ubin adalah titik akhir, maka kosongkan dan panggil </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Kalau tidak, kita menjadikannya sebagai titik akhir dan juga menyebutnya </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Destination) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tile.Content = contentFactory.Get(GameTileContentType.Destination); FindPaths(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menambahkan titik akhir tidak pernah dapat membuat keadaan bidang tidak valid, dan menghapus titik akhir bisa. </font><font style="vertical-align: inherit;">Karenanya, kami akan memeriksa apakah berhasil mengeksekusi </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setelah kami membuat ubin kosong. </font><font style="vertical-align: inherit;">Jika tidak, maka batalkan perubahan, balikkan ubin ke titik akhir, dan panggil lagi </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk kembali ke kondisi yang benar sebelumnya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Destination) { tile.Content = contentFactory.Get(GameTileContentType.Empty); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!FindPaths()) { tile.Content = contentFactory.Get(GameTileContentType.Destination); FindPaths(); } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisakah validasi dibuat lebih efisien?</font></font></b> <div class="spoiler_text">      ,      .           ,   .  ,          .        <code>FindPaths</code> ,      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang pada akhirnya </font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kita dapat memanggil </font></font><code>ToggleDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan ubin pusat sebagai argumen, alih-alih memanggil secara eksplisit </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini adalah satu-satunya saat kami mulai dengan keadaan bidang yang tidak valid, tetapi kami dijamin akan berakhir dengan keadaan yang benar.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector2Int size, GameTileContentFactory contentFactory </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-comment"><span class="hljs-comment">//FindPaths(); ToggleDestination(tiles[tiles.Length / 2]); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akhirnya, kami memaksa untuk </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menelepon </font></font><code>ToggleDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alih-alih mengatur konten ubin itu sendiri.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//tile.Content = //tileContentFactory.Get(GameTileContentType.Destination); board.ToggleDestination(tile); } }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/832/685/8a9/8326858a93b938353376ff97259df1a7.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Banyak titik akhir dengan jalur yang benar.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bukankah kita seharusnya melarang Game untuk mengatur konten ubin secara langsung?</font></font></b> <div class="spoiler_text">   .       .       ,   <code>Game</code>             .    ,      . </div></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dindingnya </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tujuan pertahanan menara adalah untuk mencegah musuh mencapai titik akhir. </font><font style="vertical-align: inherit;">Tujuan ini dicapai dengan dua cara. </font><font style="vertical-align: inherit;">Pertama, kita membunuh mereka, dan kedua, kita memperlambat mereka sehingga ada lebih banyak waktu untuk membunuh mereka. </font><font style="vertical-align: inherit;">Di bidang ubin, waktu dapat diperpanjang, meningkatkan jarak yang harus dilalui musuh. </font><font style="vertical-align: inherit;">Ini bisa dicapai dengan menempatkan rintangan di lapangan. </font><font style="vertical-align: inherit;">Biasanya ini adalah menara yang juga membunuh musuh, tetapi dalam tutorial ini kita akan membatasi diri kita hanya untuk tembok saja.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konten </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dinding adalah jenis konten lain, jadi mari kita tambahkan </font></font><code>GameTileContentType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elemen ke dalamnya.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> GameTileContentType { Empty, Destination, Wall }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemudian buat prefab dinding. </font><font style="vertical-align: inherit;">Kali ini, buat objek game untuk konten ubin dan tambahkan kubus anak ke dalamnya, yang akan berada di atas bidang dan isi seluruh ubin. </font><font style="vertical-align: inherit;">Buat setengah unit tinggi dan simpan collider, karena dinding secara visual dapat tumpang tindih bagian dari ubin di belakangnya. </font><font style="vertical-align: inherit;">Karena itu, ketika seorang pemain menyentuh dinding, ia akan mempengaruhi ubin yang sesuai.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d3/a33/779/1d3a33779b0c4d49f8ab4fed3d8abd20.png" width="320" height="176" alt="root"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/431/b5c/9f6/431b5c9f65000bab15dd9e1eed14696d.png" width="320" height="226" alt="kubus"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6b/875/3b2/e6b8753b2e9b954b55a4a3a6e0154560.png" width="225" height="60" alt="cetakan"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dinding Rak Pabrikan. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan prefab dinding ke pabrik, baik dalam kode dan inspektur.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContent wallPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContentType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Destination: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(destinationPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Empty: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(emptyPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Wall: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(wallPrefab); } Debug.Assert(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"Unsupported type: "</span></span> + type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/262/eaa/50f/262eaa50f1bf4f80b2d2861d6232368b.png" width="320" height="80"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pabrik dengan dinding cetakan.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nyalakan dan matikan dinding </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan ke </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode on / off dinding, seperti yang kita lakukan untuk titik akhir. </font><font style="vertical-align: inherit;">Awalnya, kami tidak akan memeriksa kondisi bidang yang salah.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Wall) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tile.Content = contentFactory.Get(GameTileContentType.Wall); FindPaths(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan memberikan dukungan untuk beralih hanya antara ubin kosong dan ubin dinding, tidak memungkinkan dinding untuk secara langsung mengganti titik akhir. </font><font style="vertical-align: inherit;">Karena itu, kami hanya akan membuat dinding ketika ubin kosong. </font><font style="vertical-align: inherit;">Selain itu, dinding harus memblokir pencarian jalan. </font><font style="vertical-align: inherit;">Tetapi setiap ubin harus memiliki jalur ke titik akhir, jika tidak musuh akan terjebak. </font><font style="vertical-align: inherit;">Untuk melakukan ini, kita lagi perlu menggunakan validasi </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan membuang perubahan jika mereka membuat keadaan bidang yang salah.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Wall); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!FindPaths()) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menghidupkan dan mematikan dinding akan digunakan lebih sering daripada menyalakan dan mematikan titik akhir, jadi kami akan membuat dinding-dinding penghubung dengan </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sentuhan utama. </font><font style="vertical-align: inherit;">Titik akhir dapat diaktifkan dengan sentuhan tambahan (biasanya tombol mouse kanan), yang dapat dikenali dengan memberikan </font></font><code>Input.GetMouseButtonDown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nilai 1.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { HandleTouch(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">1</span></span>)) { HandleAlternativeTouch(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleAlternativeTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { board.ToggleDestination(tile); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { board.ToggleWall(tile); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d62/e45/4e9/d62e454e94a659dd9da841a915a93dac.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita memiliki dinding.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa saya mendapatkan celah besar di antara bayang-bayang dinding yang berdekatan secara diagonal?</font></font></b> <div class="spoiler_text">  ,          ,    ,   .   ,   ,  far clipping plane      . ,   far plane  20      .  ,         MSAA,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mari kita juga memastikan bahwa titik akhir tidak dapat langsung menggantikan dinding. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Destination) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Destination); FindPaths(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Path Search Lock </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agar dinding memblokir pencarian jalur, cukup bagi kami untuk tidak menambahkan ubin dengan dinding ke batas pencarian. </font><font style="vertical-align: inherit;">Ini dapat dilakukan dengan memaksa </font></font><code>GameTile.GrowPathTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk tidak mengembalikan ubin dengan dinding. </font><font style="vertical-align: inherit;">Tetapi jalan harus tetap tumbuh ke arah dinding, sehingga semua ubin di lapangan memiliki jalan. </font><font style="vertical-align: inherit;">Hal ini diperlukan karena ada kemungkinan ubin dengan musuh tiba-tiba akan berubah menjadi dinding.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HasPath || neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.HasPath) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } neighbor.distance = distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbor.nextOnPath = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbor.Content.Type != GameTileContentType.Wall ? neighbor : <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memastikan bahwa semua ubin memiliki jalur, mereka </font></font><code>GameBoard.FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">harus memeriksa ini setelah pencarian selesai. </font><font style="vertical-align: inherit;">Jika tidak demikian, maka keadaan bidang tidak benar dan perlu dikembalikan </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tidak perlu memperbarui visualisasi jalur untuk keadaan tidak valid, karena bidang akan kembali ke keadaan sebelumnya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!tile.HasPath) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ShowPath(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc3/ff2/c3e/cc3ff2c3e52a087d9fa757d5760623d6.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dinding memengaruhi jalan. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memastikan bahwa dinding benar-benar memiliki jalur yang benar, Anda harus membuat kubusnya tembus cahaya.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d9b/2f6/70c/d9b2f670c9bcf0fc568c1484750c2e77.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dinding transparan. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhatikan bahwa persyaratan kebenaran semua jalur tidak memungkinkan dinding untuk menutup bagian dari bidang di mana tidak ada titik akhir. </font><font style="vertical-align: inherit;">Kami dapat membagi peta, tetapi hanya jika ada setidaknya satu titik akhir di setiap bagian. </font><font style="vertical-align: inherit;">Selain itu, setiap dinding harus bersebelahan dengan ubin kosong atau titik akhir, jika tidak maka tidak akan dapat memiliki jalur. </font><font style="vertical-align: inherit;">Sebagai contoh, adalah mustahil untuk membuat blok padat 3 × 3 dinding.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sembunyikan jalannya </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visualisasi jalur memungkinkan kita untuk melihat cara kerja pencarian jalur dan memastikan bahwa itu memang benar. </font><font style="vertical-align: inherit;">Tapi itu tidak perlu ditunjukkan kepada pemain, atau setidaknya belum tentu. </font><font style="vertical-align: inherit;">Karena itu, mari berikan kemampuan untuk mematikan panah. </font><font style="vertical-align: inherit;">Ini dapat dilakukan dengan menambahkan </font></font><code>GameTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode umum </font></font><code>HidePath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang hanya menonaktifkan panahnya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HidePath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { arrow.gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Status pemetaan jalur adalah bagian dari status bidang. </font><font style="vertical-align: inherit;">Tambahkan </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bidang boolean ke default sama </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan melacak statusnya, serta properti umum sebagai pengambil dan penyetel. </font><font style="vertical-align: inherit;">Setter harus menunjukkan atau menyembunyikan jalur di semua ubin.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> showPaths; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ShowPaths { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; showPaths; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { showPaths = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (showPaths) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ShowPath(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.HidePath(); } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang metode </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">harus menunjukkan jalur yang diperbarui hanya jika rendering diaktifkan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (showPaths) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ShowPath(); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara default, visualisasi jalur dinonaktifkan. </font><font style="vertical-align: inherit;">Matikan panah di pabrikan ubin.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a5a/c71/802/a5ac718028d1bb41c145dfabba9051e1.png" width="320" height="44"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panah pabrikan tidak aktif secara default. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami membuatnya sehingga </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengubah status visualisasi ketika tombol ditekan. </font><font style="vertical-align: inherit;">Adalah logis untuk menggunakan tombol P, tetapi juga merupakan tombol pintas untuk mengaktifkan / menonaktifkan mode permainan di editor Unity. </font><font style="vertical-align: inherit;">Akibatnya, visualisasi akan beralih ketika hotkey untuk keluar dari mode permainan digunakan, yang tidak terlihat sangat bagus. </font><font style="vertical-align: inherit;">Jadi mari kita gunakan tombol V (kependekan dari visualisasi).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9c/a96/15c/a9ca9615c10cdab502f1769443ad6b38.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak ada panah.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tampilan kotak </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika panah disembunyikan, menjadi sulit untuk membedakan lokasi setiap ubin. </font><font style="vertical-align: inherit;">Mari kita tambahkan garis kisi. </font><font style="vertical-align: inherit;">Unduh </font><font style="vertical-align: inherit;">tekstur garis batas persegi </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang dapat digunakan sebagai garis ubin terpisah.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c1/e98/483/4c1e984836babfc368136b83ac2b195b.png" width="128" height="128"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tekstur jala.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami tidak akan menambahkan tekstur ini secara individual ke setiap ubin, tetapi menerapkannya ke tanah. Tetapi kami akan membuat kisi-kisi ini opsional, serta visualisasi jalur. Oleh karena itu, kami akan menambah </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bidang konfigurasi </font></font><code>Texture2D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan memilih tekstur jala untuknya.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] Texture2D gridTexture = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed4/99a/28e/ed499a28e82a3328c010a71ba1085316.png" width="320" height="94"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bidang dengan tekstur jala. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan bidang Boolean lain dan properti untuk mengontrol keadaan visualisasi kisi. </font><font style="vertical-align: inherit;">Dalam hal ini, setter harus mengubah materi bumi, yang dapat diimplementasikan dengan memanggil </font></font><code>GetComponent&lt;MeshRenderer&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bumi dan mendapatkan akses ke properti </font></font><code>material</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hasil. </font><font style="vertical-align: inherit;">Jika kisi perlu ditampilkan, maka kami akan menetapkan </font></font><code>mainTexture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tekstur kisi </font><font style="vertical-align: inherit;">ke properti </font><font style="vertical-align: inherit;">material. </font><font style="vertical-align: inherit;">Kalau tidak, berikan itu padanya </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Perhatikan bahwa ketika Anda mengubah tekstur material, duplikat instance material akan dibuat, sehingga menjadi independen dari aset material.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> showGrid, showPaths; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ShowGrid { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; showGrid; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { showGrid = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Material m = ground.GetComponent&lt;MeshRenderer&gt;().material; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (showGrid) { m.mainTexture = gridTexture; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { m.mainTexture = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beralih visualisasi grid dengan tombol G.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.G)) { board.ShowGrid = !board.ShowGrid; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juga, tambahkan visualisasi mesh default ke </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { board.Initialize(boardSize, tileContentFactory); board.ShowGrid = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b04/145/190/b04145190e5d8f15972f25374d7f5813.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kisi yang tidak dihitung. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sejauh ini kami punya perbatasan di seluruh bidang. </font><font style="vertical-align: inherit;">Ini cocok dengan teksturnya, tapi bukan itu yang kita butuhkan. </font><font style="vertical-align: inherit;">Kita perlu skala tekstur utama bahan agar sesuai dengan ukuran kotak. </font><font style="vertical-align: inherit;">Anda dapat melakukan ini dengan memanggil metode </font></font><code>SetTextureScale</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">material dengan nama properti tekstur ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_MainTex</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dan ukuran dua dimensi. </font><font style="vertical-align: inherit;">Kita bisa menggunakan ukuran bidang secara langsung, yang secara tidak langsung dikonversi ke nilai </font></font><code>Vector2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (showGrid) { m.mainTexture = gridTexture; m.SetTextureScale(<span class="hljs-string"><span class="hljs-string">"_MainTex"</span></span>, size); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edb/d2a/b85/edbd2ab858e40a61d5f89452a8809b33.png" width="230" height="230" alt="tanpa"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8bd/91a/ae5/8bd91aae589309dbd64994bb10a935a9.png" width="230" height="230" alt="dengan"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grid berskala dengan visualisasi jalur dimatikan dan dihidupkan. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, pada tahap ini, kami memiliki bidang yang berfungsi untuk permainan ubin genre menara pertahanan. </font><font style="vertical-align: inherit;">Dalam tutorial selanjutnya kita akan menambahkan musuh. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repositori </font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PDF</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id449798/">https://habr.com/ru/post/id449798/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id449784/index.html">Dalam hal ini layak menggunakan Django (dan di mana itu tidak perlu)</a></li>
<li><a href="../id449788/index.html">Brave Browser memperkenalkan platform periklanan berbasis hadiah</a></li>
<li><a href="../id449790/index.html">Pengembangan Produk Alat Bantu Visual: Desain</a></li>
<li><a href="../id449794/index.html">Array Antena Adaptif: Bagaimana Cara Kerjanya? (Dasar-dasar)</a></li>
<li><a href="../id449796/index.html">Tentang seorang gadis</a></li>
<li><a href="../id449802/index.html">Programmer karir. Bagian 1. Program pertama</a></li>
<li><a href="../id449804/index.html">Tinjauan Terapi Anti-Penuaan untuk Biohackers</a></li>
<li><a href="../id449806/index.html">Programmer karir. Bagian 2. Sekolah atau pendidikan mandiri</a></li>
<li><a href="../id449808/index.html">Eksperimen Hack Days 9 Positif: Bagaimana Cara Berpikir Kritis Membantu Kehidupan dan Pekerjaan</a></li>
<li><a href="../id449814/index.html">Windows XP secara resmi mati, sekarang akhirnya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>