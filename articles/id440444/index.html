<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🎨 🕡 👨‍👨‍👧‍👦 Sistem Berbasis Antrian 👨🏾‍🤝‍👨🏼 ♻️ 👨🏽‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai, habrozhiteli! 

 Kami memutuskan untuk berbagi terjemahan bab "Sistem berdasarkan antrian tugas" Dari kebaruan mendatang "Sistem terdistribusi. P...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sistem Berbasis Antrian</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/440444/">  Hai, habrozhiteli! <br><br>  Kami memutuskan untuk berbagi terjemahan bab "Sistem berdasarkan antrian tugas" Dari kebaruan mendatang "Sistem terdistribusi.  Pola desain ”(sudah ada di percetakan). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/c0/c7/6k/c0c76kbloj9pjb2olgoma345bes.png" alt="gambar"></div><br>  Bentuk pemrosesan batch paling sederhana adalah antrian tugas.  Dalam sistem dengan antrian tugas, ada satu set tugas yang harus diselesaikan.  Setiap tugas sepenuhnya independen dari yang lain dan dapat diproses tanpa interaksi dengan mereka.  Dalam kasus umum, tujuan sistem dengan antrian tugas adalah untuk memastikan bahwa setiap tahap pekerjaan diselesaikan dalam periode waktu tertentu.  Jumlah alur kerja bertambah atau berkurang sesuai dengan perubahan beban.  Skema antrian tugas umum disajikan pada Gambar.  10.1. <br><a name="habracut"></a><br><h3>  Sistem berdasarkan antrian tugas umum </h3><br>  Baris tugas adalah contoh ideal yang menunjukkan kekuatan penuh pola desain sistem terdistribusi.  Sebagian besar logika antrian tugas tidak tergantung pada jenis pekerjaan yang dilakukan.  Dalam banyak kasus, hal yang sama berlaku untuk pengiriman tugas itu sendiri. <br><br>  Mari kita menggambarkan pernyataan ini menggunakan antrian tugas yang ditunjukkan pada Gambar.  10.1.  Setelah melihatnya lagi, tentukan fungsi apa yang bisa disediakan oleh satu set wadah bersama.  Menjadi jelas bahwa sebagian besar implementasi antrian tugas kemas dapat digunakan oleh berbagai pengguna. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8h/b2/qf/8hb2qfylszx_qmk8dicocvnvxtg.png" alt="gambar"></div><br>  Antrian tugas berbasis kontainer membutuhkan antarmuka yang cocok antara kontainer perpustakaan dan kontainer dengan logika pengguna.  Dalam antrian tugas kemas, dua antarmuka dibedakan: antarmuka wadah sumber, yang menyediakan aliran tugas yang membutuhkan pemrosesan, dan antarmuka wadah yang mengeksekusi, yang tahu bagaimana menanganinya. <br><br><h3>  Sumber Kontainer Antarmuka </h3><br>  Antrian tugas apa pun beroperasi berdasarkan serangkaian tugas yang membutuhkan pemrosesan.  Bergantung pada aplikasi spesifik yang diterapkan berdasarkan antrian tugas, ada banyak sumber tugas yang termasuk di dalamnya.  Tetapi setelah menerima serangkaian tugas, skema operasi antrian cukup sederhana.  Oleh karena itu, kita dapat memisahkan logika khusus aplikasi dari sumber tugas dari skema umum pemrosesan antrian tugas.  Mengingat pola kelompok wadah yang dibahas sebelumnya, di sini Anda dapat melihat penerapan pola Duta Besar.  Wadah tugas antrian umum adalah wadah aplikasi utama, dan wadah sumber khusus aplikasi adalah permintaan penyiaran duta besar dari wadah pengirim antrian ke pelaksana tugas tertentu.  Kelompok wadah ini ditunjukkan pada Gambar.  10.2. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bx/7u/pc/bx7upcqfw7gxqus2zqrhbrhqpes.png" alt="gambar"></div><br>  By the way, meskipun duta kontainer adalah khusus aplikasi (yang jelas), ada juga beberapa implementasi umum dari sumber API.  Misalnya, sumber dapat berupa daftar foto yang terletak di beberapa penyimpanan cloud, sekumpulan file pada drive jaringan, atau bahkan antrian dalam sistem yang beroperasi dengan prinsip "publikasikan / berlangganan", seperti Kafka atau Redis.  Terlepas dari kenyataan bahwa pengguna dapat memilih duta wadah yang paling cocok untuk tugas mereka, mereka harus menggunakan implementasi "perpustakaan" umum dari wadah itu sendiri.  Ini akan meminimalkan jumlah pekerjaan dan memaksimalkan penggunaan kembali kode. <br><br>  <b>API Antrian Tugas</b>  Mengingat mekanisme interaksi antara antrian tugas dan wadah yang bergantung pada aplikasi, kita harus merumuskan definisi formal antarmuka antara dua kontainer.  Ada banyak protokol berbeda, tetapi HTTP RESTful APIs mudah diimplementasikan dan merupakan standar de facto untuk antarmuka semacam itu.  Antrean tugas mengharapkan URL berikut untuk diimplementasikan dalam wadah setelah: <br><br><ul><li>  DAPATKAN <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">localhost / api / v1 / items;</a> </li><li>  DAPATKAN <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">localhost / api / v1 / items</a> &lt;item-name&gt;. </li></ul><blockquote>  Mengapa menambahkan v1 ke definisi API Anda, Anda bertanya?  Akankah ada versi antarmuka yang kedua?  Itu terlihat tidak masuk akal, tetapi biaya versi API ketika awalnya didefinisikan minimal.  Melakukan refactoring yang sesuai nantinya akan sangat mahal.  Buat aturan untuk menambahkan versi ke semua API, bahkan jika Anda tidak yakin apakah akan pernah berubah.  Tuhan menyelamatkan yang aman. <br></blockquote>  URL / item / mengembalikan daftar semua tugas: <br><br><pre><code class="plaintext hljs">{ kind: ItemList, apiVersion: v1, items: [ "item-1", "item-2", …. ] }</code> </pre> <br>  URL / item / &lt;item-name&gt; memberikan informasi terperinci tentang tugas tertentu: <br><br><pre> <code class="plaintext hljs">{ kind: Item, apiVersion: v1, data: { "some": "json", "object": "here", } }</code> </pre> <br>  Harap perhatikan bahwa API tidak menyediakan mekanisme apa pun untuk memperbaiki fakta tugas.  Seseorang dapat mengembangkan API yang lebih kompleks dan mengalihkan sebagian besar implementasinya ke duta kontainer.  Ingat, bagaimanapun, bahwa tujuan kami adalah untuk memusatkan sebanyak mungkin implementasi keseluruhan dalam manajer antrian tugas.  Dalam hal ini, manajer antrian tugas itu sendiri harus memantau tugas mana yang sudah diproses dan yang belum diproses. <br><br>  Dari API ini kami mendapatkan informasi tentang tugas tertentu, dan kemudian meneruskan nilai bidang item.data dari antarmuka kontainer pelaksana. <br><br><h3>  Menjalankan Antarmuka Kontainer </h3><br>  Segera setelah manajer antrian menerima tugas berikutnya, ia harus mempercayakannya kepada beberapa pelaksana.  Ini adalah antarmuka kedua dalam antrian tugas umum.  Wadah itu sendiri dan antarmuka-nya sedikit berbeda dari antarmuka wadah sumber karena beberapa alasan.  Pertama, ini adalah API satu kali.  Pekerjaan pelaksana dimulai dengan satu panggilan, dan selama siklus hidup wadah, tidak ada lagi panggilan yang dilakukan.  Kedua, wadah pelaksana dan pengelola antrian tugas berada dalam grup wadah yang berbeda.  Eksekutor kontainer diluncurkan melalui API orkestra wadah dalam grupnya sendiri.  Ini berarti bahwa manajer antrian tugas harus membuat panggilan jarak jauh untuk memulai wadah eksekusi.  Ini juga berarti bahwa Anda harus lebih berhati-hati tentang masalah keamanan, karena pengguna jahat cluster dapat memuatnya dengan pekerjaan yang tidak perlu. <br><br>  Dalam wadah sumber, kami menggunakan panggilan HTTP sederhana untuk mengirim daftar tugas ke pengelola tugas.  Ini dilakukan dengan asumsi bahwa panggilan API ini perlu dilakukan beberapa kali, dan masalah keamanan tidak diperhitungkan, karena semuanya bekerja dalam kerangka localhost.  API kontainer harus dipanggil hanya sekali dan penting untuk memastikan bahwa pengguna lain dari sistem tidak dapat menambahkan pekerjaan ke pelaksana, bahkan secara tidak sengaja atau dengan niat jahat.  Karenanya, untuk wadah pelaksana, kami akan menggunakan file API.  Setelah membuat, kami akan mengirimkan variabel lingkungan wadah yang disebut WORK_ITEM_FILE, yang nilainya merujuk ke file di sistem file internal wadah.  File ini berisi data tentang tugas yang harus diselesaikan.  Jenis API ini, seperti yang ditunjukkan di bawah ini, dapat diimplementasikan oleh objek ConfigMap Kubernetes.  Itu dapat dipasang dalam kelompok wadah sebagai file (Gbr. 10.3). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jn/p0/zb/jnp0zbiduvl1qsstlwa1mphwrxq.png" alt="gambar"></div><br>  Mekanisme API file seperti itu lebih mudah diimplementasikan menggunakan wadah.  Seorang pelaksana dalam antrian tugas sering kali adalah skrip shell sederhana yang mengakses beberapa alat.  Tidak praktis untuk meningkatkan seluruh server web untuk manajemen tugas - ini mengarah pada komplikasi arsitektur.  Seperti halnya dengan sumber tugas, sebagian besar wadah-pelaksana akan menjadi wadah khusus untuk tugas-tugas tertentu, tetapi ada juga pelaksana umum yang berlaku untuk menyelesaikan beberapa tugas yang berbeda. <br><br>  Pertimbangkan contoh wadah pelaksana yang mengunduh file dari penyimpanan cloud, menjalankan skrip shell di atasnya, dan kemudian menyalin hasilnya kembali ke penyimpanan cloud.  Kontainer seperti itu bisa untuk sebagian besar umum, tetapi skenario tertentu dapat diteruskan sebagai parameter.  Dengan demikian, sebagian besar kode penanganan file dapat digunakan kembali oleh banyak pengguna / antrian tugas.  Pengguna akhir hanya perlu menyediakan skrip yang berisi spesifikasi pemrosesan file. <br><br><h3>  Infrastruktur antrian tugas umum </h3><br>  Apa yang masih harus diimplementasikan dalam implementasi antrian yang dapat digunakan kembali jika Anda sudah memiliki implementasi dari dua antarmuka kontainer yang dijelaskan sebelumnya?  Algoritma dasar dari tugas antrian cukup sederhana. <br><br><ol><li>  Unduh tugas yang saat ini tersedia dari wadah sumber. </li><li>  Perjelas status antrian tugas untuk tugas-tugas apa yang telah selesai atau masih dilakukan. </li><li>  Untuk setiap tugas yang belum terselesaikan, buat wadah penampung dengan antarmuka yang sesuai. </li><li>  Setelah berhasil menyelesaikan wadah pelaksana, catat bahwa tugas telah selesai. </li></ol><br>  Algoritma ini sederhana dalam kata-kata, tetapi dalam kenyataannya tidak begitu mudah untuk diterapkan.  Untungnya, orkestra Kubernetes memiliki beberapa fitur yang sangat menyederhanakan implementasinya.  Yaitu: Kubernetes memiliki objek Pekerjaan yang memastikan operasi antrian tugas yang andal.  Anda dapat mengkonfigurasi objek Ayub sehingga mulai menjalankan wadah yang sesuai baik sekali atau sampai tugas berhasil diselesaikan.  Jika Anda mengonfigurasi wadah pelaksana sehingga dijalankan sebelum tugas selesai, maka bahkan ketika mesin di gugus gagal, tugas akhirnya akan berhasil diselesaikan. <br><br>  Dengan demikian, tugas antrian sangat disederhanakan, karena orkestra mengambil tanggung jawab untuk pelaksanaan tugas yang andal. <br><br>  Selain itu, Kubernetes memungkinkan Anda untuk membuat anotasi tugas, yang memungkinkan kami menandai setiap objek tugas dengan nama elemen antrian tugas yang diproses.  Menjadi lebih mudah untuk membedakan antara tugas yang diproses dan diselesaikan baik dengan sukses maupun dengan kesalahan. <br><br>  Ini berarti bahwa kita dapat mengimplementasikan antrian tugas di atas orkestra Kubernetes tanpa menggunakan repositori kita sendiri.  Semua ini sangat menyederhanakan tugas membangun infrastruktur antrian tugas. <br><br>  Oleh karena itu, algoritme terperinci untuk pengoperasian wadah, pengelola antrian tugas, adalah sebagai berikut. <br><br>  Ulangi tanpa henti. <br><br><ol><li>  Dapatkan daftar tugas melalui antarmuka wadah - sumber tugas. </li><li>  Dapatkan daftar tugas yang melayani antrian tugas ini. </li><li>  Atas dasar daftar ini, pilih daftar tugas yang belum diproses. </li><li>  Untuk setiap tugas yang tidak diproses, buat objek Ayub yang memunculkan wadah eksekusi yang sesuai. </li></ol><br>  Berikut ini adalah skrip Python yang mengimplementasikan antrian ini: <br><br><pre> <code class="plaintext hljs">import requests import json from kubernetes import client, config import time namespace = "default" def make_container(item, obj): container = client.V1Container() container.image = "my/worker-image" container.name = "worker" return container def make_job(item): response = requests.get("http://localhost:8000/items/{}".format(item)) obj = json.loads(response.text) job = client.V1Job() job.metadata = client.V1ObjectMeta() job.metadata.name = item job.spec = client.V1JobSpec() job.spec.template = client.V1PodTemplate() job.spec.template.spec = client.V1PodTemplateSpec() job.spec.template.spec.restart_policy = "Never" job.spec.template.spec.containers = [ make_container(item, obj) ] return job def update_queue(batch): response = requests.get("http://localhost:8000/items") obj = json.loads(response.text) items = obj['items'] ret = batch.list_namespaced_job(namespace, watch=False) for item in items: found = False for i in ret.items: if i.metadata.name == item: found = True if not found: #    Job,  #   job = make_job(item) batch.create_namespaced_job(namespace, job) config.load_kube_config() batch = client.BatchV1Api() while True: update_queue(batch) time.sleep(10)</code> </pre> <br><h3>  Bengkel  Implementasi generator thumbnail untuk file video </h3><br>  Sebagai contoh penggunaan antrian tugas, pertimbangkan tugas membuat thumbnail file video.  Berdasarkan thumbnail ini, pengguna memutuskan video mana yang ingin mereka tonton. <br><br>  Untuk mengimplementasikan thumbnail, Anda memerlukan dua wadah.  Yang pertama adalah untuk sumber tugas.  Akan lebih mudah untuk menempatkan tugas pada drive jaringan bersama yang terhubung, misalnya, melalui NFS (Sistem File Jaringan, sistem file jaringan).  Sumber tugas menerima daftar file dalam direktori ini dan meneruskannya ke pemanggil. <br><br>  Saya akan memberikan program sederhana tentang NodeJS: <br><br><pre> <code class="plaintext hljs">const http = require('http'); const fs = require('fs'); const port = 8080; const path = process.env.MEDIA_PATH; const requestHandler = (request, response) =&gt; { console.log(request.url); fs.readdir(path + '/*.mp4', (err, items) =&gt; { var msg = { 'kind': 'ItemList', 'apiVersion': 'v1', 'items': [] }; if (!items) { return msg; } for (var i = 0; i &lt; items.length; i++) { msg.items.push(items[i]); } response.end(JSON.stringify(msg)); }); } const server = http.createServer(requestHandler); server.listen(port, (err) =&gt; { if (err) { return console.log('  ', err); } console.log(`    ${port}`) });</code> </pre> <br>  Sumber ini mendefinisikan daftar film yang akan diproses.  Utilitas ffmpeg digunakan untuk mengekstrak thumbnail. <br><br>  Anda dapat membuat wadah yang menjalankan perintah berikut: <br><br><pre> <code class="plaintext hljs">ffmpeg -i ${INPUT_FILE} -frames:v 100 thumb.png</code> </pre> <br>  Perintah mengekstrak satu dari setiap 100 frame (-frame: parameter v 100) dan menyimpannya dalam format PNG (misalnya, thumb1.png, thumb2.png, dll.). <br><br>  Jenis pemrosesan ini dapat diimplementasikan berdasarkan pada gambar Docker ffmpeg yang ada.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gambar jrottenberg / ffmpeg</a> populer. <br><br>  Dengan mendefinisikan wadah sumber sederhana dan wadah pelaksanaan yang lebih sederhana, mudah untuk melihat manfaat dari sistem manajemen antrian yang berorientasi wadah.  Ini secara signifikan mengurangi waktu antara desain dan implementasi antrian tugas. <br><br><h3>  Penskalaan seniman yang dinamis </h3><br>  Antrian tugas yang dipertimbangkan sebelumnya sangat cocok untuk memproses tugas-tugas saat tersedia, tetapi dapat menyebabkan beban mendadak pada sumber daya orkestra kluster wadah.  Ini bagus ketika Anda memiliki banyak jenis tugas yang membuat puncak beban pada waktu yang berbeda dan dengan demikian mendistribusikan beban pada kluster dari waktu ke waktu. <br><br>  Tetapi jika Anda tidak memiliki jenis beban yang cukup, pendekatan "lalu tebal, lalu kosong" untuk penskalaan antrean tugas mungkin memerlukan cadangan sumber daya tambahan untuk mendukung semburan beban.  Sisa waktu, sumber daya akan menganggur, tidak perlu mengosongkan dompet Anda. <br><br>  Untuk mengatasi masalah ini, Anda bisa membatasi jumlah total objek Pekerjaan yang dihasilkan oleh antrian tugas.  Ini secara alami akan membatasi jumlah pekerjaan yang diproses secara paralel dan, akibatnya, mengurangi penggunaan sumber daya selama beban puncak.  Di sisi lain, durasi masing-masing tugas individu akan meningkat dengan beban tinggi pada cluster. <br><br>  Jika bebannya spasmodik, ini tidak menakutkan, karena interval waktu henti dapat digunakan untuk menyelesaikan tugas yang terakumulasi.  Namun, jika beban tetap terlalu tinggi, antrian tugas tidak akan punya waktu untuk memproses tugas yang masuk dan semakin banyak waktu akan dihabiskan untuk pelaksanaannya. <br><br>  Dalam situasi seperti itu, Anda harus secara dinamis menyesuaikan jumlah maksimum tugas paralel dan, dengan demikian, sumber daya komputasi yang tersedia untuk mempertahankan tingkat kinerja yang diperlukan.  Untungnya, ada rumus matematika yang memungkinkan Anda untuk menentukan kapan perlu untuk skala antrian tugas untuk memproses lebih banyak permintaan. <br><br>  Pertimbangkan antrean tugas di mana tugas baru muncul rata-rata satu menit sekali, dan penyelesaiannya membutuhkan rata-rata 30 detik.  Antrian seperti itu mampu mengatasi aliran tugas yang masuk ke dalamnya.  Bahkan jika paket besar tugas tiba sekaligus, menciptakan kemacetan lalu lintas, maka kemacetan lalu lintas akan dihilangkan seiring waktu, karena sebelum tugas berikutnya tiba, antrian berhasil memproses rata-rata dua tugas. <br><br>  Jika tugas baru tiba setiap menit dan dibutuhkan rata-rata 1 menit untuk memproses satu tugas, maka sistem seperti itu idealnya seimbang, tetapi tidak merespon dengan baik terhadap perubahan beban.  Dia mampu mengatasi semburan beban, tetapi itu akan menghabiskan banyak waktu.  Sistem tidak akan menganggur, tetapi tidak akan ada cadangan waktu komputer untuk mengimbangi peningkatan jangka panjang dalam kecepatan penerimaan tugas baru.  Untuk menjaga stabilitas sistem, perlu memiliki cadangan jika terjadi pertumbuhan beban jangka panjang atau keterlambatan tak terduga dalam tugas pemrosesan. <br><br>  Akhirnya, pertimbangkan sistem di mana satu tugas per menit tiba, dan pemrosesan tugas memakan waktu dua menit.  Sistem seperti itu akan terus-menerus kehilangan kinerja.  Panjang antrian tugas akan bertambah seiring dengan penundaan antara penerimaan dan pemrosesan tugas (dan tingkat gangguan pengguna). <br><br>  Nilai kedua indikator ini harus terus dipantau.  Dengan rata-rata waktu antara penerimaan tugas untuk jangka waktu yang lama, misalnya, berdasarkan jumlah tugas per hari, kami memperoleh perkiraan interval antar-tugas.  Anda juga perlu memantau waktu pemrosesan rata-rata tugas (tidak termasuk waktu yang dihabiskan dalam antrian).  Dalam antrian tugas yang stabil, waktu pemrosesan tugas rata-rata harus kurang dari interval antar-tugas.  Untuk memastikan bahwa kondisi ini terpenuhi, perlu untuk menyesuaikan secara dinamis jumlah antrian sumber daya komputasi yang tersedia.  Jika pekerjaan diproses secara paralel, maka waktu pemrosesan harus dibagi dengan jumlah pekerjaan yang diproses secara paralel.  Misalnya, jika satu tugas diproses satu menit, tetapi empat tugas diproses secara paralel, maka waktu pemrosesan efektif satu tugas adalah 15 detik, yang berarti bahwa interval antar-tugas minimal 16 detik. <br><br>  Pendekatan ini memungkinkan Anda untuk dengan mudah membuat modul untuk meningkatkan antrian tugas ke atas.  Penurunan skala agak lebih bermasalah.  Namun demikian, dimungkinkan untuk menggunakan perhitungan yang sama seperti sebelumnya, selain meletakkan cadangan sumber daya komputasi yang ditentukan oleh cara heuristik.  Misalnya, Anda dapat mengurangi jumlah tugas paralel hingga waktu pemrosesan untuk satu tugas adalah 90% dari interval antar-tugas. <br><br><h3>  Pola Multi-Pekerja </h3><br>  Salah satu topik utama buku ini adalah penggunaan wadah untuk merangkum dan menggunakan kembali kode.  Ini juga relevan untuk pola antrian tugas yang dijelaskan dalam bab ini.  Selain kontainer yang mengelola antrian itu sendiri, Anda dapat menggunakan kembali grup kontainer yang membentuk pelaksanaan pemain.  Misalkan Anda perlu memproses setiap tugas dalam antrian dengan tiga cara berbeda.  Misalnya, untuk mendeteksi wajah dalam sebuah foto, cocokkan dengan orang-orang tertentu, dan kemudian memburamkan bagian gambar yang sesuai.  Anda bisa meletakkan semua pemrosesan dalam satu wadah eksekusi, tetapi ini adalah solusi satu kali yang tidak dapat digunakan kembali.  Untuk menutupi hal lain, seperti mobil, di foto, Anda harus membuat wadah seniman dari awal. <br><br>  Kemungkinan penggunaan kembali semacam ini dapat dicapai dengan menerapkan pola Multi-Worker, yang sebenarnya merupakan kasus khusus dari pola Adaptor yang dijelaskan di awal buku.  Pola Multi-Pekerja mengubah seperangkat wadah menjadi satu wadah umum dengan antarmuka perangkat lunak wadah pelaksana.  Kontainer bersama ini memproses untuk beberapa wadah terpisah yang dapat digunakan kembali.  Proses ini secara skematis ditunjukkan pada Gambar.  10.4. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ei/wx/zv/eiwxzvdwvre9k_ftflo2xfz_bz4.png" alt="gambar"></div><br>  Dengan menggunakan kembali kode dengan menggabungkan wadah yang dapat dieksekusi, tenaga orang yang merancang sistem pemrosesan batch terdistribusi berkurang. <br><br>  »Informasi lebih lanjut tentang buku ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web penerbit</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Isi</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kutipan</a> <br><br>  Untuk habrozhitelami, diskon 20% pada kupon - <b>Sistem terdistribusi</b> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id440444/">https://habr.com/ru/post/id440444/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id440432/index.html">Friday SciFi tentang profesi masa depan: "Real Girls"</a></li>
<li><a href="../id440434/index.html">Industri otomotif Rusia: jalan menuju teknologi aditif</a></li>
<li><a href="../id440436/index.html">Java Practical Tasks - untuk kursus dan kegiatan lainnya</a></li>
<li><a href="../id440438/index.html">MQTT / UDP pre-roll: konfigurasi jarak jauh dan tanda tangan digital</a></li>
<li><a href="../id440440/index.html">Bagaimana saya mendapat pekerjaan dengan gaji $ 300.000 di Silicon Valley</a></li>
<li><a href="../id440446/index.html">Seri Webinar TDMS Fair Workflow</a></li>
<li><a href="../id440448/index.html">Apa yang mengakhiri cerita dengan programmer tunawisma</a></li>
<li><a href="../id440450/index.html">Ada rubel untuk masuk, tetapi tidak ada jalan keluar: bagaimana file pihak ketiga masuk ke blockchain dan apa yang harus dilakukan tentang hal itu</a></li>
<li><a href="../id440454/index.html">Paul Graham: Apa yang Saya Pelajari dari Hacker News</a></li>
<li><a href="../id440458/index.html">Prediksi status jaringan VoIP berdasarkan file log teks dari server aplikasi SIP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>