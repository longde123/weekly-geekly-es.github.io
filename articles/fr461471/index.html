<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äç‚öñÔ∏è üë©üèæ‚Äçüç≥ ü•Ñ .NET - Outils pour travailler avec le multithreading et l'asynchronie - Partie 2 üíª üë®üèø‚Äç‚öïÔ∏è ‚öõÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J'ai initialement publi√© cet article sur le blog CodingSight . 
 Il est √©galement disponible en russe ici . 

 Cet article contient la deuxi√®me partie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET - Outils pour travailler avec le multithreading et l'asynchronie - Partie 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461471/">  <i>J'ai initialement publi√© cet article sur le blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CodingSight</a> .</i> <i><br></i>  <i>Il est √©galement disponible en russe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .</i> <br><br>  Cet article contient la deuxi√®me partie de mon discours lors de la rencontre multithreading.  Vous pouvez consulter la premi√®re partie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Dans la premi√®re partie, je me suis concentr√© sur l'ensemble d'outils de base utilis√© pour d√©marrer un thread ou une t√¢che, les moyens de suivre leur √©tat et d'autres choses int√©ressantes telles que PLinq.  Dans cette partie, je vais r√©soudre les probl√®mes que vous pouvez rencontrer dans un environnement multithread et certaines des fa√ßons de les r√©soudre. <br><br><h2>  Table des mati√®res </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Concernant les ressources partag√©es</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Probl√®mes possibles dans les environnements multithreads</a> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Impasse</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Condition de course</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Attente occup√©e</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fil de famine</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">M√©thodes de synchronisation</a> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Interlocked</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Monitor.Enter, Monitor.Exit, lock</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SpinLock, SpinWait</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Monitor.Wait, Monitor.Pulse [Tout]</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ReaderWriterLockSlim</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La famille ResetEvent</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Conclusions</a> </li></ul><br><a name="habracut"></a><a name="SharedResources"></a><br><h2>  Concernant les ressources partag√©es </h2><br>  Vous ne pouvez pas √©crire un programme dont le travail est bas√© sur plusieurs threads sans avoir de ressources partag√©es.  M√™me si cela fonctionne sur votre niveau d'abstraction actuel, vous constaterez qu'il a en fait des ressources partag√©es d√®s que vous descendez d'un ou plusieurs niveaux d'abstraction.  Voici quelques exemples: <br><br>  <b>Exemple # 1:</b> <br><br>  Pour √©viter d'√©ventuels probl√®mes, vous faites fonctionner les threads avec diff√©rents fichiers, un fichier pour chaque thread.  Il vous semble que le programme ne dispose d'aucune ressource partag√©e. <br><br>  En descendant de quelques niveaux, vous apprenez qu'il n'y a qu'un seul disque dur, et c'est au pilote ou au syst√®me d'exploitation de trouver une solution aux probl√®mes d'acc√®s au disque dur. <br><br>  <b>Exemple # 2:</b> <br><br>  Apr√®s avoir lu l' <i>exemple # 1</i> , vous avez d√©cid√© de placer les fichiers sur deux machines distantes diff√©rentes avec un mat√©riel et des syst√®mes d'exploitation physiquement diff√©rents.  Vous g√©rez √©galement deux connexions FTP ou NFS diff√©rentes. <br><br>  En redescendant de quelques niveaux, vous comprenez que rien n'a vraiment chang√© et que le probl√®me d'acc√®s concurrentiel est d√©sormais d√©l√©gu√© au pilote de la carte r√©seau ou au syst√®me d'exploitation de la machine sur laquelle le programme s'ex√©cute. <br><br>  <b>Exemple # 3:</b> <br><br>  Apr√®s avoir arrach√© la plupart de vos cheveux au cours des tentatives de prouver que vous pouvez √©crire un programme multi-thread, vous d√©cidez d'abandonner compl√®tement les fichiers et de d√©placer les calculs vers deux objets diff√©rents, avec les liens vers chacun des objets disponibles uniquement pour leur sp√©cifique fils. <br><br>  Pour enfoncer la derni√®re douzaine de clous dans le cercueil de cette id√©e: un runtime et un garbage collector, un planificateur de threads, physiquement une RAM unifi√©e et un processeur sont toujours consid√©r√©s comme des ressources partag√©es. <br><br>  Nous avons donc appris qu'il est impossible d'√©crire un programme multithread sans ressources partag√©es √† tous les niveaux d'abstraction et sur toute l'√©tendue de la pile technologique.  Heureusement, chaque niveau d'abstraction (en r√®gle g√©n√©rale) s'occupe partiellement ou m√™me compl√®tement des probl√®mes d'acc√®s concurrentiel ou le refuse tout de suite (exemple: tout cadre d'interface utilisateur ne permet pas de travailler avec des √©l√©ments de diff√©rents threads).  Donc, g√©n√©ralement, les probl√®mes avec les ressources partag√©es apparaissent √† votre niveau d'abstraction actuel.  Pour en prendre soin, le concept de synchronisation est introduit. <br><a name="Problems"></a><br><h2>  Probl√®mes possibles dans les environnements multithreads </h2><br>  Nous pouvons classer les erreurs logicielles dans les cat√©gories suivantes: <br><ol><li>  Le programme ne produit aucun r√©sultat - il se bloque ou se fige. </li><li>  Le programme donne un r√©sultat incorrect. </li><li>  Le programme produit un r√©sultat correct mais ne satisfait pas √† certaines exigences non li√©es √† la fonction - il passe trop de temps ou de ressources. </li></ol><br>  Dans les environnements multithreads, les principaux probl√®mes qui entra√Ænent les erreurs # 1 et # 2 sont le <b>blocage</b> et la <b>condition de concurrence critique</b> . <br><br><a name="Deadlock"></a><br><h3>  Impasse </h3><br>  Deadlock est un blocage mutuel.  Il existe de nombreuses variantes d'un blocage.  La suivante peut √™tre consid√©r√©e comme la plus courante: <br><br><img src="https://habrastorage.org/webt/fl/ij/aj/flijajjtgsaczutpuk9t1filaig.png"><br><br>  Pendant que le <b>thread # 1</b> faisait quelque chose, le <b>thread # 2</b> bloquait la ressource <b>B.</b>  Quelque temps plus tard, le <b>thread n ¬∞ 1 a</b> bloqu√© la ressource <b>A</b> et tentait de bloquer la ressource B. <br><a name="RaceCondition"></a><br><h3>  Condition de course </h3><br>  Race-Condition est une situation o√π √† la fois, le comportement et les r√©sultats des calculs d√©pendent du planificateur de threads de l'environnement d'ex√©cution <br><br>  Le probl√®me est que votre programme peut fonctionner incorrectement une fois sur cent, voire sur un million. <br><br>  Les choses peuvent empirer lorsque les probl√®mes arrivent par trois.  Par exemple, le comportement sp√©cifique du planificateur de threads peut entra√Æner un blocage mutuel. <br><br>  En plus de ces deux probl√®mes qui conduisent √† des erreurs explicites, il y a aussi les probl√®mes qui, s'ils ne conduisent pas √† des r√©sultats de calcul incorrects, peuvent encore faire prendre au programme beaucoup plus de temps ou de ressources pour produire le r√©sultat souhait√©.  Deux de ces probl√®mes sont l' <b>attente occup√©e</b> et la <b>famine de fil</b> . <br><a name="BusyWait"></a><br><h3>  Attente occup√©e </h3><br>  L'attente occup√©e est un probl√®me qui survient lorsque le programme d√©pense les ressources du processeur en attente plut√¥t qu'en calcul. <br><br>  En r√®gle g√©n√©rale, ce probl√®me se pr√©sente comme suit: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!hasSomethingHappened) ;</code> </pre> <br>  Ceci est un exemple d'un code extr√™mement pauvre car il occupe pleinement un c≈ìur de votre processeur sans rien faire de productif du tout.  Un tel code ne peut √™tre justifi√© que s'il est extr√™mement important de traiter rapidement une modification d'une valeur dans un thread diff√©rent.  Et par ¬´rapidement¬ª, je veux dire que vous ne pouvez pas attendre m√™me quelques nanosecondes.  Dans tous les autres cas, c'est-√†-dire tous les cas o√π un esprit raisonnable peut arriver, il est beaucoup plus pratique d'utiliser les variantes de ResetEvent et leurs versions Slim.  Nous en parlerons un peu plus tard. <br><br>  Probablement, certains lecteurs sugg√©reraient de r√©soudre le probl√®me d'un c≈ìur compl√®tement occup√© √† attendre en ajoutant Thread.Sleep (1) (ou quelque chose de similaire) dans le cycle.  Bien qu'il r√©soudra ce probl√®me, un nouveau sera cr√©√© - le temps n√©cessaire pour r√©agir aux modifications sera d√©sormais de 0,5 ms en moyenne.  D'une part, ce n'est pas beaucoup, mais d'autre part, cette valeur est catastrophiquement plus √©lev√©e que ce que nous pouvons atteindre en utilisant des primitives de synchronisation de la famille ResetEvent. <br><a name="ThreadStarvation"></a><br><h3>  Fil de famine </h3><br>  Thread Starvation est un probl√®me avec le programme ayant trop de threads fonctionnant simultan√©ment.  Ici, nous parlons sp√©cifiquement des threads occup√©s par le calcul plut√¥t que par l'attente d'une r√©ponse de certains IO.  Avec ce probl√®me, nous perdons tous les avantages de performances possibles avec les threads car le processeur passe beaucoup de temps √† changer de contexte. <br><br>  Vous pouvez trouver de tels probl√®mes en utilisant divers profileurs.  Ce qui suit est une capture d'√©cran du profileur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dotTrace</a> fonctionnant en mode Timeline <br> <a href=""><img src="https://habrastorage.org/webt/qy/n9/nk/qyn9nkwglryzuu60cipo8zdi0ra.png"></a> <br>  <i>(cliquez pour agrandir).</i> <br><br>  Habituellement, les programmes qui ne souffrent pas de la famine de threads n'ont pas de sections roses sur les graphiques repr√©sentant les threads.  De plus, dans la cat√©gorie Sous-syst√®mes, nous pouvons voir que le programme attendait le CPU pendant 30,6% du temps. <br><br>  Lorsqu'un tel probl√®me est diagnostiqu√©, vous pouvez vous en occuper assez simplement: vous avez d√©marr√© trop de threads √† la fois, alors lancez simplement moins de threads. <br><a name="SyncPrimitives"></a><br><h2>  M√©thodes de synchronisation </h2><br><a name="Interlocked"></a><br><h3>  Interlocked </h3><br>  Il s'agit probablement de la m√©thode de synchronisation la plus l√©g√®re.  Interlocked est un ensemble d'op√©rations atomiques simples.  Lorsqu'une op√©ration atomique est en cours d'ex√©cution, rien ne peut se produire.  Dans .NET, Interlocked est repr√©sent√© par la classe statique du m√™me nom avec une s√©lection de m√©thodes, chacune impl√©mentant une op√©ration atomique. <br><br>  Pour r√©aliser l'horreur ultime des op√©rations non atomiques, essayez d'√©crire un programme qui lance 10 threads, chacun d'eux incr√©mentant la m√™me variable un million de fois.  Une fois leur travail termin√©, affichez la valeur de cette variable.  Malheureusement, il sera tr√®s diff√©rent de 10 millions.  De plus, il sera diff√©rent chaque fois que vous ex√©cuterez le programme.  Cela se produit parce que m√™me une op√©ration aussi simple que l'incr√©ment n'est pas atomique et comprend l'extraction de valeur de la m√©moire, le calcul de la nouvelle valeur et l'√©criture √† nouveau dans la m√©moire.  Ainsi, deux threads peuvent effectuer l'une de ces op√©rations et un incr√©ment sera perdu dans ce cas. <br><br>  La classe Interlocked fournit les m√©thodes Increment / Decrement, et il n'est pas difficile de deviner ce qu'elles sont cens√©es faire.  Ils sont vraiment pratiques si vous traitez des donn√©es dans plusieurs threads et calculez quelque chose.  Un tel code fonctionnera beaucoup plus rapidement que le verrou classique.  Si nous utilisions Interlocked dans la situation d√©crite dans le paragraphe pr√©c√©dent, le programme produirait de mani√®re fiable une valeur de 10 millions dans n'importe quel sc√©nario. <br><br>  La fonction de la m√©thode CompareExchange n'est pas si √©vidente.  Cependant, son existence permet la mise en ≈ìuvre de nombreux algorithmes int√©ressants.  Plus important encore, ceux de la famille sans verrou. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareExchange</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> location1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> comparand</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  Cette m√©thode prend trois valeurs.  La premi√®re passe par une r√©f√©rence et c'est la valeur qui sera chang√©e en seconde si location1 est √©gale √† comparand lorsque la comparaison est effectu√©e.  La valeur d'origine de location1 sera retourn√©e.  Cela semble compliqu√©, il est donc plus facile d'√©crire un morceau de code qui effectue les m√™mes op√©rations que CompareExchange: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> original = location1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location1 == comparand) location1 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> original;</code> </pre><br>  La seule diff√©rence est que la classe Interlocked l'impl√©mente de mani√®re atomique.  Donc, si nous √©crivions ce code nous-m√™mes, nous pourrions faire face √† un sc√©nario dans lequel la condition location1 == comparand a d√©j√† √©t√© remplie.  Mais lorsque l'instruction location1 = value est en cours d'ex√©cution, un thread diff√©rent a d√©j√† modifi√© la valeur location1, elle sera donc perdue. <br><br>  Nous pouvons trouver un bon exemple de la fa√ßon dont cette m√©thode peut √™tre utilis√©e dans le code que le compilateur g√©n√®re pour tout √©v√©nement C #. <br><br>  √âcrivons une classe simple avec un √©v√©nement appel√© MyEvent: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyClass</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent; }</code> </pre><br>  Maintenant, construisons le projet dans la configuration Release et ouvrons la construction via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dotPeek</a> avec l'option "Afficher le code g√©n√©r√© par le compilateur" activ√©e: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CompilerGenerated</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> EventHandler MyEvent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent { [CompilerGenerated] <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> { EventHandler eventHandler = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent; EventHandler comparand; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { comparand = eventHandler; eventHandler = Interlocked.CompareExchange&lt;EventHandler&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent, (EventHandler) Delegate.Combine((Delegate) comparand, (Delegate) <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>), comparand); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (eventHandler != comparand); } [CompilerGenerated] <span class="hljs-keyword"><span class="hljs-keyword">remove</span></span> { <span class="hljs-comment"><span class="hljs-comment">// The same algorithm but with Delegate.Remove } }</span></span></code> </pre><br>  Ici, nous pouvons voir que le compilateur a g√©n√©r√© un algorithme assez complexe dans les coulisses.  Cet algorithme nous emp√™che de perdre un abonnement √† l'√©v√©nement dans lequel quelques threads sont simultan√©ment abonn√©s √† cet √©v√©nement.  D√©veloppons la m√©thode add tout en gardant √† l'esprit ce que fait la m√©thode CompareExchange dans les coulisses: <br><br><pre> <code class="cs hljs">EventHandler eventHandler = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent; EventHandler comparand; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { comparand = eventHandler; <span class="hljs-comment"><span class="hljs-comment">// Begin Atomic Operation if (MyEvent == comparand) { eventHandler = MyEvent; MyEvent = Delegate.Combine(MyEvent, value); } // End Atomic Operation } while (eventHandler != comparand);</span></span></code> </pre><br>  C'est beaucoup plus g√©rable, mais n√©cessite probablement encore une explication.  Voici comment je d√©crirais l'algorithme: <br><br>  <i>Si MyEvent est toujours le m√™me qu'au moment o√π nous avons commenc√© √† ex√©cuter Delegate.Combine, d√©finissez-le sur ce que Delegate.Combine renvoie.</i>  <i>Si ce n'est pas le cas, r√©essayez jusqu'√† ce que cela fonctionne.</i> <br><br>  De cette fa√ßon, les abonnements ne seront jamais perdus.  Vous devrez r√©soudre un probl√®me similaire si vous souhaitez impl√©menter un tableau dynamique, thread-safe et sans verrouillage.  Si plusieurs threads commencent soudainement √† ajouter des √©l√©ments √† ce tableau, il est important que tous ces √©l√©ments soient ajout√©s avec succ√®s. <br><a name="Lock"></a><br><h3>  Monitor.Enter, Monitor.Exit, lock </h3><br>  Ces constructions sont utilis√©es pour la synchronisation des threads le plus fr√©quemment.  Ils impl√©mentent le concept d'une section critique: c'est-√†-dire que le code √©crit entre les appels de Monitor.Enter et Monitor.Exit ne peut √™tre ex√©cut√© que sur une ressource √† un moment donn√© par un seul thread.  L'op√©rateur de verrouillage sert de sucre de syntaxe autour des appels d'entr√©e / sortie envelopp√©s dans try-finally.  Une qualit√© agr√©able de la section critique dans .NET est qu'elle prend en charge la r√©entrance.  Cela signifie que le code suivant peut √™tre ex√©cut√© sans probl√®me r√©el: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(a) { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (a) { ... } }</code> </pre><br>  Il est peu probable que quelqu'un √©crive de cette mani√®re exacte, mais si vous r√©pandez ce code entre quelques m√©thodes √† travers la profondeur de la pile d'appels, cette fonctionnalit√© peut vous faire √©conomiser quelques IF.  Pour que cette astuce fonctionne, les d√©veloppeurs de .NET ont d√ª ajouter une limitation - vous ne pouvez utiliser que des instances de types de r√©f√©rence comme objet de synchronisation, et quelques octets sont ajout√©s √† chaque objet o√π l'identificateur de thread sera √©crit. <br><br>  Cette particularit√© du processus de travail de la section critique en C # impose une limitation int√©ressante √† l'op√©rateur de verrouillage: vous ne pouvez pas utiliser l'op√©rateur d'attente √† l'int√©rieur de l'op√©rateur de verrouillage.  Au d√©but, cela m'a surpris car une construction similaire de Monitor.Enter / Exit similaire peut √™tre compil√©e.  Quel est le probl√®me?  Il est important de relire le paragraphe pr√©c√©dent et d'appliquer certaines connaissances sur le fonctionnement de async / expect: le code apr√®s wait ne sera pas ex√©cut√© sur le m√™me thread que le code before wait.  Cela d√©pend du contexte de synchronisation et du fait que la m√©thode ConfigureAwait est appel√©e ou non.  Il s'ensuit que Monitor.Exit peut √™tre ex√©cut√© sur un thread diff√©rent de Monitor.Enter, ce qui entra√Ænera la lev√©e de SynchronizationLockException.  Si vous ne me croyez pas, essayez d'ex√©cuter le code suivant dans une application console - cela g√©n√©rera une <b>SynchronizationLockException</b> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> syncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Monitor.Enter(syncObject); Console.WriteLine(Thread.CurrentThread.ManagedThreadId); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Monitor.Exit(syncObject); Console.WriteLine(Thread.CurrentThread.ManagedThreadId);</code> </pre><br>  Il convient de noter que, dans une application WinForms ou WPF, ce code fonctionnera correctement si vous l'appelez √† partir du thread principal car il y aura un contexte de synchronisation qui impl√©mentera le retour √† UI-Thread apr√®s l'appel en attente.  Dans tous les cas, il vaut mieux ne pas jouer avec les sections critiques dans le contexte d'un code contenant l'op√©rateur wait.  Dans de tels exemples, il est pr√©f√©rable d'utiliser des primitives de synchronisation que nous verrons un peu plus tard. <br><br>  Bien que nous soyons sur le sujet des sections critiques dans .NET, il est important de mentionner une particularit√© suppl√©mentaire de la fa√ßon dont elles sont impl√©ment√©es.  Une section critique de .NET fonctionne en deux modes: spin-wait et core-wait.  Nous pouvons repr√©senter l'algorithme spin-wait comme le pseudocode suivant: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!TryEnter(syncObject)) ;</code> </pre><br>  Cette optimisation vise √† capturer une section critique le plus rapidement possible dans un court laps de temps sur la base que, m√™me si la ressource est actuellement occup√©e, elle sera lib√©r√©e tr√®s bient√¥t.  Si cela ne se produit pas dans un court laps de temps, le thread passera en attente dans le mode de base, ce qui prend du temps - tout comme revenir de l'attente.  Les d√©veloppeurs de .NET ont optimis√© autant que possible le sc√©nario des blocs courts.  Malheureusement, si de nombreux threads commencent √† tirer la section critique entre eux, cela peut entra√Æner une charge soudaine et √©lev√©e sur le processeur. <br><a name="SpinLock"></a><br><h3>  SpinLock, SpinWait </h3><br>  Ayant d√©j√† mentionn√© l'algorithme d'attente cyclique (spin-wait), il vaut la peine de parler des structures SpinLock et SpinWait de BCL.  Vous devez les utiliser s'il y a des raisons de supposer qu'il sera toujours possible d'obtenir un bloc tr√®s rapidement.  D'un autre c√¥t√©, vous ne devriez pas vraiment y penser jusqu'√† ce que les r√©sultats du profilage montrent que le goulot d'√©tranglement de votre programme est provoqu√© par l'utilisation d'autres primitives de synchronisation. <br><a name="Pulse"></a><br><h3>  Monitor.Wait, Monitor.Pulse [Tout] </h3><br>  Nous devrions regarder ces deux m√©thodes c√¥te √† c√¥te.  Avec leur aide, vous pouvez impl√©menter diff√©rents sc√©narios Producteur-Consommateur. <br><br>  Le producteur-consommateur est un mod√®le de conception multi-processus / multi-thread impliquant un ou plusieurs threads / processus qui produisent des donn√©es et un ou plusieurs processus / threads qui traitent ces donn√©es.  Habituellement, une collection partag√©e est utilis√©e. <br><br>  Ces deux m√©thodes ne peuvent √™tre appel√©es que par un thread qui a actuellement un bloc.  La m√©thode Wait lib√©rera le bloc et g√®lera jusqu'√† ce qu'un autre thread appelle Pulse. <br><br>  Pour illustrer cela, j'ai √©crit un petit exemple: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> syncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); Thread t1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T1); t1.Start(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); Thread t2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T2); t2.Start();</code> </pre><img src="https://habrastorage.org/webt/0-/7k/uy/0-7kuyx2b8evi2iwzmt-6-capv0.png"><br>  <i>(J'ai utilis√© une image plut√¥t que du texte ici pour montrer avec pr√©cision l'ordre d'ex√©cution des instructions)</i> <br>  <b>Explication:</b> J'ai d√©fini une latence de 100 ms lors du d√©marrage du deuxi√®me thread pour garantir sp√©cifiquement qu'il sera ex√©cut√© plus tard. <br>  - T1: ligne # 2 le thread est d√©marr√© <br>  - T1: ligne # 3, le thread entre dans une section critique <br>  - T1: ligne # 6, le fil se met en veille <br>  - T2: Ligne # 3 le thread est d√©marr√© <br>  - T2: Ligne # 4 il fige et attend la section critique <br>  - T1: Ligne # 7 il laisse aller la section critique et se fige en attendant la sortie de Pulse <br>  - T2: Ligne # 8 il entre dans la section critique <br>  - T2: Ligne # 11, il signale T1 √† l'aide de Pulse <br>  - T2: Ligne # 14 elle sort de la section critique.  T1 ne peut pas continuer son ex√©cution avant que cela ne se produise. <br>  - T1: Ligne # 15 elle sort de l'attente <br>  - T1: Ligne # 16 elle sort de la section critique <br><br>  <i>Il existe une remarque importante dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MSDN</a> concernant l'utilisation des m√©thodes Pulse / Wait: Monitor ne stocke pas les informations d'√©tat, ce qui signifie que l'appel de la m√©thode Pulse avant la m√©thode Wait peut entra√Æner un blocage.</i>  <i>Si un tel cas est possible, il est pr√©f√©rable d'utiliser l'une des classes de la famille ResetEvent.</i> <br><br>  L'exemple pr√©c√©dent montre clairement comment fonctionnent les m√©thodes Wait / Pulse de la classe Monitor, mais laisse encore quelques questions sur les cas dans lesquels nous devrions les utiliser.  Un bon exemple est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">impl√©mentation</a> de BlockingQueue &lt;T&gt;.  D'autre part, l'impl√©mentation de BlockingCollection &lt;T&gt; √† partir de System.Collections.Concurrent utilise SemaphoreSlim pour la synchronisation. <br><a name="ReaderWriterLockSlim"></a><br><h3>  ReaderWriterLockSlim </h3><br>  J'adore cette primitive de synchronisation, et elle est repr√©sent√©e par la classe du m√™me nom de l'espace de noms System.Threading.  Je pense que beaucoup de programmes fonctionneraient beaucoup mieux si leurs d√©veloppeurs utilisaient cette classe au lieu du verrou standard. <br><br>  Id√©e: beaucoup de threads peuvent lire et le seul peut √©crire.  Lorsqu'un thread veut √©crire, de nouvelles lectures ne peuvent pas √™tre d√©marr√©es - il attendra la fin de l'√©criture.  Il existe √©galement le concept de verrouillage de lecture √©volutif.  Vous pouvez l'utiliser lorsque, pendant le processus de lecture, vous comprenez qu'il est n√©cessaire d'√©crire quelque chose - un tel verrou sera transform√© en verrou d'√©criture en une seule op√©ration atomique. <br><br>  Dans l'espace de noms System.Threading, il existe √©galement la classe ReadWriteLock, mais il est fortement recommand√© de ne pas l'utiliser pour de nouveaux d√©veloppements.  La version Slim aidera √† √©viter les cas qui conduisent √† des blocages et permet de capturer rapidement un bloc car elle prend en charge la synchronisation en mode d'attente d'attente avant de passer au mode principal. <br><br>  Si vous ne connaissiez pas cette classe avant de lire cet article, je pense que vous vous souvenez maintenant de nombreux exemples du code r√©cemment √©crit o√π cette approche des blocs a permis au programme de fonctionner efficacement. <br><br>  L'interface de la classe ReaderWriterLockSlim est simple et facile √† comprendre, mais ce n'est pas si confortable √† utiliser: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReaderWriterLockSlim(); @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterReadLock(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... } finally { @lock.ExitReadLock(); }</span></span></code> </pre><br>  J'aime g√©n√©ralement l'envelopper dans une classe - cela le rend beaucoup plus pratique. <br><br>  <i><b>Id√©e:</b> cr√©ez des m√©thodes Read / WriteLock qui renvoient un objet avec la m√©thode Dispose.</i>  <i>Vous pouvez ensuite y acc√©der dans Utilisation, et cela ne diff√©rera probablement pas trop du verrou standard en ce qui concerne le nombre de lignes.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RWLock</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> WriteLockToken : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLockToken</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReaderWriterLockSlim @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">lock</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterWriteLock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.ExitWriteLock(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ReadLockToken : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadLockToken</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReaderWriterLockSlim @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">lock</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterReadLock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.ExitReadLock(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReaderWriterLockSlim(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ReadLockToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadLock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReadLockToken(@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> WriteLockToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WriteLockToken(@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.Dispose(); }</code> </pre><br>  Cela nous permet d'√©crire simplement ce qui suit plus loin dans le code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rwLock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RWLock(); <span class="hljs-comment"><span class="hljs-comment">// ... using(rwLock.ReadLock()) { // ... }</span></span></code> </pre><br><a name="ResetEvent"></a><br><h3>  La famille ResetEvent </h3><br>  J'inclus les classes suivantes dans cette famille: ManualResetEvent, ManualResetEventSlim et AutoResetEvent. <br><br>  La classe ManualResetEvent, sa version Slim et la classe AutoResetEvent peuvent exister dans deux √©tats: <br><br>  - Non signal√© - dans cet √©tat, tous les threads qui ont appel√© WaitOne se figent jusqu'√† ce que l'√©v√©nement passe √† un √©tat signal√©. <br>  - Signal√© - dans cet √©tat, tous les threads pr√©c√©demment gel√©s lors d'un appel WaitOne sont lib√©r√©s.  Tous les nouveaux appels WaitOne sur un √©v√©nement signal√© sont effectu√©s relativement instantan√©ment. <br><br>  AutoResetEvent diff√®re de ManualResetEvent en ce qu'il passe automatiquement √† l'√©tat non signal√© apr√®s avoir rel√¢ch√© <b>exactement un thread</b> .  Si quelques threads sont fig√©s en attendant AutoResetEvent, l'appel √† Set ne lib√©rera qu'un seul thread al√©atoire, contrairement √† ManualResetEvent qui lib√®re tous les threads. <br><br>  Regardons un exemple du fonctionnement d'AutoResetEvent: <br><br><pre> <code class="cs hljs">AutoResetEvent evt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AutoResetEvent(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); Thread t1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T1); t1.Start(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); Thread t2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T2); t2.Start();</code> </pre><img src="https://habrastorage.org/webt/ku/us/k2/kuusk2oupkj4_gftf8fixy_51pu.png"><br>  Dans ces exemples, nous pouvons voir que l'√©v√©nement ne passe automatiquement √† l'√©tat non signal√© qu'apr√®s avoir lib√©r√© le thread qui a √©t√© gel√© lors d'un appel WaitOne. <br><br>  Contrairement √† ReaderWriterLock, ManualResetEvent n'est pas consid√©r√© comme obsol√®te m√™me apr√®s l'apparition de sa version Slim.  Cette version Slim de la classe peut √™tre efficace pour les courtes attentes comme cela se produit dans le mode Spin-Wait;  la version standard convient aux longues attentes. <br><br>  Outre les classes ManualResetEvent et AutoResetEvent, il existe √©galement la classe CountdownEvent.  Cette classe est tr√®s utile pour impl√©menter des algorithmes qui fusionnent les r√©sultats ensemble apr√®s une section parall√®le.  Cette approche est connue sous le nom de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fork-join</a> .  Il y a un excellent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> d√©di√© √† cette classe, donc je ne le d√©crirai pas en d√©tail ici. <br><a name="Conclusions"></a><br><h2>  Conclusions </h2><br><ul><li>  Lorsque vous travaillez avec des threads, deux probl√®mes peuvent conduire √† des r√©sultats incorrects ou m√™me √† l'absence de r√©sultats: condition de concurrence critique et blocage. </li><li>  Les probl√®mes qui peuvent faire passer plus de temps ou de ressources au programme sont la famine de threads et l'attente occup√©e. </li><li>  .NET offre de nombreuses fa√ßons de synchroniser les threads. </li><li>  Il existe deux modes d'attente de bloc - Spin Wait et Core Wait.  Les primitives de synchronisation des threads Som.e dans .NET les utilisent toutes les deux. </li><li>  Interlocked est un ensemble d'op√©rations atomiques qui peuvent √™tre utilis√©es pour impl√©menter des algorithmes sans verrouillage.  C'est la primitive de synchronisation la plus rapide. </li><li>  Le verrou et le moniteur Les op√©rateurs Entr√©e / Sortie impl√©mentent le concept d'une section critique - un fragment de code qui ne peut √™tre ex√©cut√© que par un thread √† un moment donn√©. </li><li>  Les m√©thodes Monitor.Pulse / Wait sont utiles pour impl√©menter des sc√©narios Producteur-Consommateur. </li><li>  ReaderWriterLockSlim peut √™tre plus utile que les cas de verrouillage standard lorsqu'une lecture parall√®le est attendue. </li><li>  La famille de classes ResetEvent peut √™tre utile pour la synchronisation des threads. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr461471/">https://habr.com/ru/post/fr461471/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr461461/index.html">La sauvegarde prosp√®re √† l'√®re du cloud, mais les bobines de bande ne sont pas oubli√©es. Conversation avec Veeam</a></li>
<li><a href="../fr461463/index.html">Processus commerciaux dans les entreprises: sp√©culation et r√©alit√©. Faites la lumi√®re avec R</a></li>
<li><a href="../fr461465/index.html">Guide de mesure</a></li>
<li><a href="../fr461467/index.html">Un exemple de cr√©ation d'applications Makefile for Go</a></li>
<li><a href="../fr461469/index.html">√Ä quoi ressemble l'√©coute de code √† 1000 mots par minute</a></li>
<li><a href="../fr461473/index.html">D√©boguer des algorithmes sur les graphiques - maintenant avec des images</a></li>
<li><a href="../fr461475/index.html">AMA avec Habr.1011</a></li>
<li><a href="../fr461483/index.html">√âquilibrage de charge Openstack</a></li>
<li><a href="../fr461487/index.html">Mini t√¢ches CTF</a></li>
<li><a href="../fr461493/index.html">Django 3.0 sera asynchrone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>