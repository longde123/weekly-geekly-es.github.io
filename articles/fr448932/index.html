<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤹🏼 👴🏿 🧒🏼 Pourquoi Go est mauvais pour les programmeurs stupides 📝 ✔️ 💆🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'article est écrit en réponse à un article antipode publié précédemment. 





 Au cours des deux dernières années et plus, j'ai utilisé Go pour impl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pourquoi Go est mauvais pour les programmeurs stupides</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448932/"><p>  L'article est écrit en réponse à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article antipode</a> publié précédemment. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ac9/24e/5c8/ac924e5c8c90275379b035cfa5b1f23b.jpg" alt="image"></p><br><p>  Au cours des deux dernières années et plus, j'ai utilisé Go pour implémenter un serveur RADIUS spécialisé avec un système de facturation développé.  Ce faisant, j'apprends les subtilités de la langue elle-même.  Les programmes eux-mêmes sont très simples et n'ont pas pour but d'écrire un article, mais l'expérience d'utilisation de Go lui-même mérite de dire quelques mots pour sa défense.  Go devient un langage de plus en plus populaire pour le code sérieux et évolutif.  La langue est créée dans Google, dans laquelle elle est activement utilisée.  Pour résumer, je crois sincèrement que la conception du langage Go est mauvaise pour les programmeurs Dumb. </p><a name="habracut"></a><br><h1>  Conçu pour les programmeurs faibles? </h1><br><blockquote>  Faible discours sur les problèmes.  Parler fort d'idées et de rêves ... </blockquote><p>  Go est très simple à apprendre, si simple que vous pouvez lire le code avec peu ou pas de préparation du tout.  Cette fonctionnalité du langage est utilisée dans de nombreuses entreprises mondiales lorsque le code est lu avec des spécialistes non essentiels (gestionnaires, clients, etc.).  Ceci est très pratique pour les méthodologies telles que le développement piloté par la conception. </p><br><p>  Même les programmeurs débutants commencent à produire du code assez décent après une semaine ou deux.  Le livre que j'ai étudié Go s'appelle «Go Programming» (écrit par Mark Summerfield).  Le livre est très bon, il touche à beaucoup de nuances de la langue.  Après des langages inutilement compliqués comme Java, PHP, le manque de magie est rafraîchissant.  Mais tôt ou tard, de nombreux programmeurs limités souhaitent utiliser d'anciennes méthodes dans un nouveau domaine.  Est-ce vraiment nécessaire? </p><br><p>  Rob Pike (l'idéologue principal de la langue) a créé le Go comme un langage industriel facile à lire et efficace à utiliser.  Le langage est conçu pour une productivité maximale dans les grandes équipes et cela ne fait aucun doute.  De nombreux programmeurs débutants se plaignent du manque de nombreuses fonctionnalités.  Ce désir de simplicité était une décision consciente des développeurs de langage, et pour bien comprendre à quoi cela servait, nous devons comprendre la motivation des développeurs et ce qu'ils ont accompli dans Go. </p><br><p>  Alors pourquoi est-ce si simple?  Voici quelques citations de Rob Pike: </p><br><blockquote>  Le point clé ici est que nos programmeurs ne sont pas des chercheurs.  Ils sont généralement très jeunes, viennent chez nous après l'école, peut-être ont-ils étudié Java, ou C / C ++, ou Python.  Ils ne sont pas capables de comprendre une langue exceptionnelle, mais en même temps, nous voulons qu'ils créent de bons logiciels.  C'est pourquoi la langue devrait être facile à comprendre et à apprendre. <br><br>  Il devrait être familier, grosso modo comme C.  Les programmeurs Google commencent leur carrière tôt et sont généralement familiarisés avec les langages procéduraux, en particulier la famille C.  L'exigence d'une productivité rapide dans un nouveau langage de programmation signifie que le langage ne doit pas être trop radical. <br></blockquote><p>  Des mots sages, non? </p><br><h1>  Artefacts de simplicité </h1><br><blockquote>  La simplicité est une condition nécessaire au beau.  Leo Tolstoy. </blockquote><p>  Être simple est l'une des aspirations les plus importantes de toute conception.  Comme vous le savez, un projet parfait n'est pas un projet où il n'y a rien à ajouter, mais un - dont il n'y a rien à supprimer.  Beaucoup pensent que pour résoudre (ou même exprimer) des tâches complexes, un outil complexe est nécessaire.  Mais ce n'est pas le cas.  Prenons par exemple le langage PERL.  Les idéologues de la langue pensaient qu'un programmeur devait avoir au moins trois façons différentes de résoudre un problème.  Les idéologues de la langue Go ont pris un chemin différent, ils ont décidé que pour atteindre l'objectif, un chemin est suffisant, mais vraiment bon.  Cette approche a un fondement sérieux: le seul moyen est plus facile à apprendre et plus difficile à oublier. </p><br><p>  De nombreux migrants se plaignent que la langue ne contient pas d'élégantes abstractions.  Oui, c'est vrai, mais c'est l'un des principaux avantages de la langue.  La langue contient un minimum de magie - par conséquent, aucune connaissance approfondie n'est requise pour lire le programme.  Quant à la verbosité du code, ce n'est pas du tout un problème.  Un programme Golang bien écrit est lu verticalement avec peu ou pas de structuration.  De plus, la vitesse de lecture d'un programme est au moins d'un ordre de grandeur plus rapide que son écriture.  Si nous considérons que tout le code a un formatage uniforme (effectué à l'aide de la commande intégrée gofmt), la lecture de quelques lignes supplémentaires n'est pas du tout un problème. </p><br><h1>  Pas très expressif </h1><br><blockquote>  L'art ne tolère pas quand il restreint sa liberté.  La précision n'est pas de sa responsabilité. </blockquote><p>  En raison du désir de simplicité, Go manque de constructions qui, dans d'autres langues, sont perçues comme quelque chose de naturel pour les gens qui y sont habitués.  Au début, cela peut être quelque peu gênant, mais vous remarquerez ensuite que le programme est lu beaucoup plus facilement et plus clairement. </p><br><p>  Par exemple, un utilitaire de console qui lit stdin ou un fichier à partir d'arguments de ligne de commande ressemblera à ceci: </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"bufio"</span></span> <span class="hljs-string"><span class="hljs-string">"flag"</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"os"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { flag.Parse() scanner := newScanner(flag.Args()) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> text <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> scanner.Scan() { text += scanner.Text() } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := scanner.Err(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } fmt.Println(text) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newScanner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(flags []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bufio</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Scanner</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(flags) == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bufio.NewScanner(os.Stdin) } file, err := os.Open(flags[<span class="hljs-number"><span class="hljs-number">0</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bufio.NewScanner(file) }</code> </pre> <br><p>  Bien que la solution au même problème dans le langage D semble un peu plus courte, cependant, elle n'est pas plus facile à lire </p><br><pre> <code class="plaintext hljs">import std.stdio, std.array, std.conv; void main(string[] args) { try { auto source = args.length &gt; 1 ? File(args[1], "r") : stdin; auto text = source.byLine.join.to!(string); writeln(text); } catch (Exception ex) { writeln(ex.msg); } }</code> </pre> <br><h1>  Copiez l'enfer </h1><br><blockquote>  L'homme porte l'enfer en lui-même.  Martin Luther. </blockquote><p>  Les débutants se plaignent constamment de Go en termes de manque de génériques.  Pour résoudre ce problème, la plupart utilisent la copie directe de code.  Par exemple, ces malheureux professionnels pensent que la fonction de synthèse de la liste des entiers ne peut être implémentée autrement que par simple copier-coller pour chaque type de données. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int64Sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(list []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x := <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(list); x++ { result += list[x] } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span>(result) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int32Sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(list []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">int32</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x := <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(list); x++ { result += list[x] } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span>(result) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { list32 := []<span class="hljs-keyword"><span class="hljs-keyword">int32</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>} list64 := []<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>} fmt.Println(int32Sum(list32)) fmt.Println(int64Sum(list64)) }</code> </pre> <br><p>  Le langage dispose de moyens suffisants pour mettre en œuvre de telles constructions.  Par exemple, la programmation généralisée est très bien. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Eval32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(list []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32</span></span></span></span><span class="hljs-function"><span class="hljs-params">, fn </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int32</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int32</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">int32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, val := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> list { res = fn(res, val) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int32Add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int32</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int32Sub</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int32</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a - b } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Eval64</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(list []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">, fn </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int64</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, val := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> list { res = fn(res, val) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int64Add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int64Sub</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a - b } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { list32 := []<span class="hljs-keyword"><span class="hljs-keyword">int32</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>} list64 := []<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>} fmt.Println(Eval32(list32, int32Add)) fmt.Println(Eval64(list64, int64Add)) fmt.Println(Eval64(list64, int64Sub)) }</code> </pre> <br><p>  Et, bien que notre code se soit avéré être un peu plus long que le cas précédent, il s'est généralisé.  Par conséquent, il ne nous sera pas difficile de mettre en œuvre toutes les opérations arithmétiques. </p><br><p>  Beaucoup diront que le programme D semble beaucoup plus court et aura raison. </p><br><pre> <code class="plaintext hljs">import std.stdio; import std.algorithm; void main(string[] args) { [1, 2, 3, 4, 5].reduce!((a, b) =&gt; a + b).writeln; }</code> </pre> <br><p>  Cependant, il est seulement plus court, mais pas plus correct, car le problème de gestion des erreurs est complètement ignoré dans l'implémentation D. </p><br><p>  Dans la vraie vie, lorsque la complexité de la logique augmente, l'écart se rétrécit rapidement.  Encore plus rapidement, l'écart se réduit lorsqu'une action ne peut pas être effectuée à l'aide d'opérateurs de langage standard. </p><br><p>  En termes de prise en charge, d'extensibilité, de lisibilité, à mon avis, la langue Go gagne, même si elle perd en verbosité. </p><br><p>  La programmation généralisée dans certains cas nous donne des avantages indéniables.  Cela illustre clairement le package de tri.  Donc, pour trier n'importe quelle liste, il nous suffit d'implémenter l'interface sort.Interface. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"sort"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Names []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ns Names)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Len</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(ns) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ns Names)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Less</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, j </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ns[i] &lt; ns[j] } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ns Names)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, j </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { ns[i], ns[j] = ns[j], ns[i] } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { names := Names{<span class="hljs-string"><span class="hljs-string">"London"</span></span>, <span class="hljs-string"><span class="hljs-string">"Berlin"</span></span>, <span class="hljs-string"><span class="hljs-string">"Rim"</span></span>} sort.Sort(names) }</code> </pre> <br><p>  Si vous prenez un projet open source et exécutez la commande grep "interface {}" -R, vous verrez à quelle fréquence des interfaces confuses sont utilisées.  Les camarades bornés diront immédiatement que tout cela est dû au manque de génériques.  Cependant, c'est loin d'être toujours le cas.  Prenons par exemple la langue DELPHI.  Bien qu'il possède ces mêmes génériques, il contient un type spécial VARIANT pour les opérations avec des types de données arbitraires.  Go fait la même chose. </p><br><h1>  D'un pistolet sur des moineaux </h1><br><blockquote>  Et une camisole de force doit correspondre à la taille de la folie.  Stanislav laisse. </blockquote><p>  De nombreux fans de sports extrêmes peuvent dire que Go a un autre mécanisme pour créer des génériques - la réflexion.  Et ils auront raison ... mais seulement dans de rares cas. </p><br><p>  Rob Pike nous avertit: </p><br><blockquote>  Il s'agit d'un outil puissant qui doit être utilisé avec précaution.  Il doit être évité jusqu'à ce qu'il soit strictement nécessaire. <br></blockquote><p>  Wikipedia nous dit ce qui suit: </p><br><blockquote>  La réflexion désigne un processus au cours duquel un programme peut suivre et modifier sa propre structure et son propre comportement lors de l'exécution.  Le paradigme de programmation sous-jacent à la réflexion est appelé programmation réflexive.  Il s'agit d'un type de métaprogrammation. <br></blockquote><p>  Cependant, comme vous le savez, vous devez tout payer.  Dans ce cas, c'est: </p><br><ul><li>  difficulté à écrire des programmes </li><li>  vitesse d'exécution du programme </li></ul><br><p>  Par conséquent, la réflexion doit être utilisée avec prudence, comme une arme de gros calibre.  L'utilisation irréfléchie de la réflexion entraîne des programmes illisibles, des erreurs constantes et une faible vitesse.  Le fait est que le programmeur snob pourrait afficher son code devant d'autres collègues plus pragmatiques et modestes. </p><br><h1>  Bagage culturel de C?  Non, à partir de plusieurs langues! </h1><br><blockquote>  Avec l'État, les héritiers se retrouvent avec des dettes. </blockquote><p>  Malgré le fait que beaucoup croient que le langage est entièrement basé sur l'héritage de C, ce n'est pas le cas.  Le langage a incorporé de nombreux aspects des meilleurs langages de programmation. </p><br><h2>  Syntaxe </h2><br><p>  Tout d'abord, la syntaxe des constructions grammaticales est basée sur la syntaxe du langage C.  Cependant, le langage DELPHI a également eu un impact significatif.  Donc, nous voyons que les parenthèses en excès sont complètement supprimées, ce qui réduit considérablement la lisibilité du programme.  De plus, le langage contient l'opérateur :: =, qui est inhérent au langage DELPHI.  Le concept de packages est emprunté à des langues comme ADA.  La déclaration des entités non utilisées est empruntée au langage PROLOG. </p><br><h2>  Sémantique </h2><br><p>  La sémantique du langage DELPHI a été prise comme base des packages.  Chaque package encapsule des données et du code et contient des entités privées et publiques.  Cela vous permet de réduire au minimum l'interface du package. </p><br><p>  L'opération de mise en œuvre par délégation a été empruntée à DELPHI. </p><br><h2>  Compilation </h2><br><p>  Pas étonnant qu'il y ait une blague: Go a été développé pendant la compilation du programme C.  L'une des forces du langage est la compilation ultra-rapide.  L'idée a été empruntée à DELPHI.  De plus, chaque package Go correspond au module DELPHI.  Ces packages sont recompilés uniquement lorsque cela est nécessaire.  Par conséquent, après la prochaine édition, il n'est pas nécessaire de compiler le programme entier, mais il suffit de recompiler uniquement les packages modifiés et les packages en fonction de ces packages modifiés (et cela uniquement si les interfaces des packages ont changé). </p><br><h2>  Conceptions de haut niveau </h2><br><p>  Le langage contient de nombreuses constructions de haut niveau différentes qui ne sont en aucun cas associées à des langages de bas niveau tels que C. </p><br><ul><li>  Lignes </li><li>  Hachage de table </li><li>  Tranches </li><li>  Le typage de canard est emprunté à des langues comme RUBY (que beaucoup ne comprennent malheureusement pas et n'utilisent pas à leur plein potentiel). </li></ul><br><h2>  Gestion de la mémoire </h2><br><p>  La gestion de la mémoire mérite généralement un article séparé.  Si dans des langages comme C ++, le contrôle est entièrement laissé au développeur, puis dans des langages ultérieurs comme DELPHI, un modèle de comptage de référence a été utilisé.  Avec cette approche, les liens cycliques n'étaient pas autorisés, car des clusters perdus se sont formés, puis la détection de ces clusters (comme en C #) est intégrée à Go.  De plus, le garbage collector est plus efficace que la plupart des implémentations actuellement connues et peut déjà être utilisé pour de nombreuses tâches en temps réel.  Le langage lui-même reconnaît les situations où une valeur de stockage d'une variable peut être allouée sur la pile.  Cela réduit la charge sur le gestionnaire de mémoire et augmente la vitesse du programme. </p><br><h2>  Concurrence et concurrence </h2><br><p>  Le parallélisme et la compétitivité de la langue sont au-delà des louanges.  Aucune langue de bas niveau ne peut même rivaliser à distance avec la langue Go.  En toute honnêteté, il convient de noter que le modèle n'a pas été inventé par les auteurs de la langue, mais simplement emprunté à la bonne vieille langue de l'ADA.  Le langage est capable de traiter des millions de connexions parallèles en utilisant tous les CPU, tout en ayant de l'ordre de grandeur moins courant pour les problèmes complexes de code multithread avec des blocages et des conditions de concurrence. </p><br><h1>  Des avantages supplémentaires </h1><br><blockquote>  Si cela est bénéfique, tout le monde deviendra altruiste. </blockquote><p>  La langue nous offre également un certain nombre d'avantages incontestables: </p><br><ul><li>  Le seul fichier exécutable après la construction du projet simplifie considérablement le déploiement des applications. </li><li>  Le typage statique et l'inférence de type peuvent réduire considérablement le nombre d'erreurs dans le code même sans écrire de tests.  Je connais certains programmeurs qui se passent du tout d'écriture de tests et en même temps la qualité de leur code ne souffre pas de manière significative. </li><li>  Compilation croisée très simple et excellente portabilité de la bibliothèque standard, ce qui simplifie considérablement le développement d'applications multiplateformes. </li><li>  Les expressions régulières RE2 sont thread-safe et ont des temps d'exécution prévisibles. </li><li>  Une bibliothèque standard puissante, qui permet à la plupart des projets de se passer de frameworks tiers. </li><li>  Le langage est assez puissant pour se concentrer sur le problème, et non sur les méthodes pour le résoudre, et en même temps suffisamment faible pour que le problème puisse être résolu efficacement. </li><li>  Le système éco Go contient déjà des outils prêts à l'emploi pour toutes les occasions: tests, documentation, gestion des packages, linters puissants, génération de code, détecteur de conditions de course, etc. </li><li>  La version 1.11 de Go possède désormais une gestion des dépendances sémantiques intégrée au-dessus des hôtes VCS populaires.  Tous les outils qui composent l'écosystème Go utilisent ces services pour télécharger, compiler et installer leur code d'un seul coup.  Et c'est super.  Avec l'avènement de la version 1.11, le problème de versionnage des packages a également été complètement résolu. </li><li>  Étant donné que l'idée principale du langage est de réduire la magie, le langage encourage les développeurs à gérer explicitement la gestion des erreurs.  Et c'est correct, car sinon, il oubliera tout simplement la gestion des erreurs.  Une autre chose est que la plupart des développeurs ignorent délibérément la gestion des erreurs, préférant plutôt simplement transmettre l'erreur au lieu de les traiter. </li><li>  Le langage n'implémente pas la méthodologie OOP classique, car il n'y a pas de virtualité dans sa forme pure dans Go.  Cependant, ce n'est pas un problème lors de l'utilisation des interfaces.  L'absence de POO réduit considérablement la barrière d'entrée pour les débutants. </li></ul><br><h1>  Facilité pour les avantages communautaires </h1><br><blockquote>  Compliquer est simple, simplifier est difficile. </blockquote><p>  Go a été conçu pour être simple et exceller dans ce domaine.  Il a été écrit pour des programmeurs intelligents qui comprennent toutes les vertus du travail d'équipe et sont fatigués de la variabilité infinie des langages de niveau entreprise.  Ayant un ensemble relativement petit de constructions syntaxiques dans son arsenal, il n'est pratiquement pas soumis à des changements au fil du temps, par conséquent, les développeurs ont libéré beaucoup de temps spécifiquement pour le développement, et non pour une étude sans fin des innovations linguistiques. </p><br><p>  Les entreprises bénéficient également d'un certain nombre d'avantages: un seuil d'entrée bas vous permet de trouver rapidement un spécialiste, et l'immuabilité de la langue vous permet d'utiliser le même code après 10 ans. </p><br><h1>  Conclusion </h1><br><blockquote>  La grande taille du cerveau n'a pas encore fait un seul éléphant lauréat du prix Nobel. </blockquote><p>  Pour les programmeurs dont l'ego personnel prévaut sur l'esprit d'équipe, ainsi que pour les théoriciens qui aiment les tâches académiques et l '"auto-amélioration" sans fin, le langage est vraiment mauvais, car c'est un langage artisanal polyvalent qui ne permet pas de recevoir un plaisir esthétique du résultat de leur travail et de se montrer un professionnel devant des collègues (à condition de mesurer précisément l'esprit avec ces critères, et non avec le coefficient de QI).  Comme tout dans la vie, c'est une question de priorités personnelles.  Comme toutes les innovations valables, la langue a déjà parcouru un long chemin du déni universel à la reconnaissance de masse.  La langue est ingénieuse dans sa simplicité, mais, comme vous le savez, tout ingénieux est simple! </p><br><h1>  Résumé </h1><br><p>  Parmi toutes les critiques sévères adressées à Go, les déclarations suivantes ressortent particulièrement: </p><br><ul><li>  Pas de génériques.  Si nous regardons les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">statistiques des</a> langues <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les</a> plus populaires, nous remarquons que la moitié des dix premières langues n'ont pas de génériques.  Généralement, les génériques ne sont nécessaires que dans des conteneurs.  Par conséquent, leur gain n'est pas trop important. </li><li>  D'autres langues comme Rust sont bien meilleures (au moins dans les catégories de sites XXX).  Encore une fois, si nous regardons les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">statistiques des</a> langues <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les</a> plus populaires, nous ne trouverons pas du tout Rust dans la liste, ou ce sera quelque part en dessous de la note.  Personnellement, j'aime Rust, mais j'ai choisi Go. </li><li>  XXX a un tel chignon.  C'est le revers de la médaille de la simplicité.  Que ce soit un inconvénient ou non, c'est à chacun d'en décider.  Cependant, les développeurs du projet ont donné leur préférence en faveur de la simplicité. </li><li>  Ils sortiront Go 2.0, puis nous verrons.  Cette position est prise par des observateurs, pas des pratiquants. </li><li>  Pas assez expressif.  Je suis d'accord, dans certains domaines, l'expressivité est boiteuse, mais en général c'est un langage simple et cohérent.  De plus, en raison de la pauvreté du langage, nous sommes obligés de prêter plus d'attention à l'architecture de l'application développée, ce qui affecte positivement sa flexibilité. </li></ul><br><p>  En fait, l'article ne pensait pas aux avantages syntaxiques du langage Go, mais plutôt à un bref aperçu de ses avantages pour le travail d'équipe et de l'évolution effective du projet en cours de développement.  Il était entendu que l'article se serait poursuivi en relation avec des problèmes plus spécifiques.  Cependant, en raison du manque d'intérêt pour le sujet, il n'y a probablement pas de suite. </p><br><h1>  Une expérience </h1><br><blockquote>  Ne croyez pas les mots - ni les vôtres ni les étrangers, mais croyez les actes - les vôtres et les étrangers. </blockquote><p>  <em>La dernière partie est destinée exclusivement à cette catégorie de personnes qui se considèrent comme des optimistes à l'esprit constructif et qui peuvent le confirmer avec leurs propres affaires.</em>  <em>Le reste du public, veuillez sauter cette partie.</em> </p><br><p>  Cette expérience a été inspirée par des amis qui ont affirmé que tous les optimistes à l'esprit constructif avaient quitté depuis longtemps (au moins virtuellement) les étendues de notre pays et s'étaient installés, par exemple, sur Stack Overflow, et qu'ici, la plupart des snobs étaient restés.  Pendant longtemps, je ne les ai pas crus, j'ai donc décidé de mener cette expérience. <br>  Plusieurs articles ont été postés sur le hub, résultat de l'analyse des commentaires sur lesquels je cite. </p><br><ul><li>  En effet, l'hypothèse de mes amis a été confirmée, cependant, des personnes adéquates se trouvent encore parmi les colporteurs, bien que leur pourcentage diminue rapidement.  Yuri Bykov qualifie ces gens de " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fous</a> " sur lesquels repose tout le pays.  Selon lui, leur pourcentage est faible (environ 2%).  Je ne suis pas si pessimiste et je pense qu'il y en a beaucoup plus. </li><li>  La loi des médias.  Les informations destructives présentent un intérêt beaucoup plus grand que les informations constructives. </li><li>  La psychologie de la foule.  C'est une chose terrible, cela fait même un mouton violent d'une personne adéquate.  Un homme dans une foule n'est plus un homme.  On ne peut parler d’objectivité.  Aucun argument logique, aucune source faisant autorité ou précédent ne l'affecte plus. </li><li>  Responsabilité et impunité.  Les gens sont prêts à humilier un autre pour s’exalter (au moins à leurs propres yeux).  Surtout si vous n'avez pas à répondre (ce qui pourrait être plus facile - cliquez sur le signe moins et vous n'avez même pas besoin d'écrire un commentaire).  Il y a autant de points communs entre les paroles et les actes qu'entre un canal et un égout. </li><li>  Vanité.  La plupart des snobs sont prêts à se démarquer de quelque façon que ce soit.  Ils n'ont peur d'aucune barrière morale. </li><li>  Pessimisme  Contrairement aux pays occidentaux (et en particulier l'Amérique), les sentiments pessimistes prévalent dans le pays.  Comme vous le savez, un optimiste recherche des opportunités au milieu des difficultés, et un pessimiste cherche des difficultés au milieu des opportunités.  Dans notre pays, presque personne ne fait attention aux qualités positives de quoi que ce soit. </li><li>  Professionnalisme et vision du monde.  La plupart des gens choisissent les outils comme une fin en soi et non comme un moyen d'arriver à une fin.  Les gens ont oublié comment travailler avec des informations.  Les gens ne voient pas les forêts derrière les arbres.  À partir d'un éventail d'informations, ils ne sont pas en mesure d'extraire les principales pensées.  Personne ne veut regarder d'un point de vue différent et non standard pour eux-mêmes.  La dissidence est supprimée.  Ce n'est pas accepté ici. </li><li>  Convivialité et respect.  Les groupes amicaux loués n'existent que par des mots.  Les valeurs de développement agile sont uniquement sur papier. </li><li>  Hypocrisie.  Vous pouvez écrire un article séparé à ce sujet en général. </li><li>  Principe.  Il y a des gens qui posent la bonne question: « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Qu'est-ce que je fais?</a>  »Cependant, tout le monde ne comprend pas que, par manque de principe, pour nous, l'intérêt égoïste momentané est plus important que tous nos principes réunis.  Il est plus facile de tout blâmer sur les circonstances et de dire que rien ne dépend de nous. </li></ul><br><p>  <strong>Avec un profond respect et de la sympathie pour tous les optimistes à l'esprit constructif.</strong> </p><br><p>  Adverax </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr448932/">https://habr.com/ru/post/fr448932/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr448916/index.html">Grille ou Flexbox?</a></li>
<li><a href="../fr448918/index.html">Composants Web: 9 projets à découvrir en 2019</a></li>
<li><a href="../fr448920/index.html">Utilisation de la console JavaScript dans les navigateurs</a></li>
<li><a href="../fr448922/index.html">L'intelligence artificielle améliore la qualité graphique des anciens jeux vidéo et le fait très bien</a></li>
<li><a href="../fr448926/index.html">10 façons d'économiser sur l'infrastructure informatique pour tout le monde</a></li>
<li><a href="../fr448934/index.html">Liens gratuits ou choses à faire à votre guise avec le propriétaire du site</a></li>
<li><a href="../fr448936/index.html">Formalisation du discours. Quelques considérations</a></li>
<li><a href="../fr448938/index.html">Dans le sillage du hackathon de Nijni Novgorod</a></li>
<li><a href="../fr448940/index.html">Dell Latitude 5491: un ordinateur portable d'entreprise robuste avec un processeur puissant</a></li>
<li><a href="../fr448942/index.html">Crypto-monnaie: vit ou meurt?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>