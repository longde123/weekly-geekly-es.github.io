<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💺 🧓🏻 👧🏼 高采矿：保护PoW区块链免受“ 51％攻击”的最新选择 🌈 👩🏿‍🤝‍👨🏾 📠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Litecoin Cash叉子的开发人员展示了技术文档“ 蜂巢：Litecoin Cash中基于代理的采矿 ” 的预印本，他们在其中描述了他们的建议，即基于工作量证明算法来保护加密货币区块链免受“ 51％攻击”。 他们的解决方案结合了使用老化ASIC设备（SHA-256）的挖掘和使用“工作蜂”（Hi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>高采矿：保护PoW区块链免受“ 51％攻击”的最新选择</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415949/"><img src="https://habrastorage.org/webt/d1/oo/5w/d1oo5wr_cgcroc3091uoyu1trbw.png" alt="图片"><br><br>  Litecoin Cash叉子的开发人员展示了技术文档“ <i>蜂巢：Litecoin Cash中基于代理的采矿</i> ” <i>的</i>预印本，他们在其中描述了他们的建议，即基于工作量证明算法来保护加密货币区块链免受“ 51％攻击”。 他们的解决方案结合了使用老化ASIC设备（SHA-256）的挖掘和使用“工作蜂”（HiveMine）的民主虚拟挖掘。 在正确实施区块链的情况下，LCC将解决现代区块链项目（从比特币到以太坊）最大的问题之一：当总网络功率的一半以上集中在攻击者的手中时，就会构成攻击的威胁。 <br><a name="habracut"></a><br><h3>  51％攻击问题 </h3><br> 监视加密货币市场的人可能不会注意到最近爆发<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a>相对较小的PoW项目（工作量证明-“工作完成量证明”） <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">遭受了51％的攻击</a> ，当时攻击者重写了交易并通过交易所尽快转移了资金。 在这种情况下，“相对”表示支持大型区块链（例如，比特币或以太坊）的加密安全性的设备中的一小部分将足以打破使用相同哈希算法（分别为比特币现金或比特币黄金）的小型区块链的共识。 。 <br><br> 对于采用SHA-256算法（LCC或BCH）作为加密基础的加密货币，世界上最大，最安全的加密货币使用相同算法-比特币（BTC）的事实加剧了风险。 <br><br> 在本文中，我们将重点关注针对51％攻击的保护数学模型，并简要地突出显示区块链加密中使用的主要相关术语和概念。 <br><br><h3> 高采矿概论 </h3><br> 在经典的PoW区块链安全方案中，矿工通过计算大量潜在的区块哈希来竞争，以找到满足网络共识所指定的复杂性条件的区块哈希。 如果复杂度为零，并且任何哈希被网络接受为有效，则工作量证明将不起作用，并且任何网络节点都可以轻松挖掘区块。 <br><br> 乍看之下，这还不错：就能源而言，采矿将变得民主和低成本。 但是实际上，每个人都会挖掘便宜的区块并将其推入网络，这意味着将有很多候选者来延续区块链。 由于矿工将不再了解在哪个区块上构建区块链的延续性，因此将出现许多孤链。  PoW-coins会使用一种不足的算法来调整挖掘的复杂性，从而观察到混乱。 <br><br> 如果复杂度为零，并且该区块的生产不会产生任何成本，那么没人会确定哪个候选链的价值更高，这意味着将没有优先权。 矿工也将能够在各种链条上工作而不会损失任何东西。 <br><br> 这个思想实验只是表明，工作量证明算法，权益证明或任何事物的证明的主要目的是为网络提供确定性的方法，以确定采矿，铸造或锻造区块的权利，其他参与者将对此表示同意。 。 此外，对于所有寻求区块链者来说，另一个重要条件是不要同时不受惩罚地在多个链上工作。 在权益证明系统中，这种方法受到部分或全部剥夺股份的惩罚。 <br><br> 当生产一块的权利由代表用户的代理人保障时， <b>高采</b>是另一种形式的块状斗争。 这些代理商-“工蜂”-位于区块链本身。 它们是完全分散的，并在用户进行特殊交易以创建代理时创建。 <br><br> 创建后，工蜂开始充当采矿（钻机）的虚拟设备，它们的所有者成为“养蜂人”。 当工蜂成功获得保护区时，该保护区的报酬（包括保护区中的佣金）将支付给养蜂人。 工作的蜜蜂需要很少的能量，不需要专门的设备来生产块。 而且，它们的寿命是有限的，而养蜂是一种具有一定价格的投机行为。 这样可以防止尝试同时在多个链上工作。 单个蜜蜂的成功仅取决于生活在整个网络中的蜜蜂数量。 有些蜜蜂将永远找不到障碍，而另一些蜜蜂会格外幸运（类似于单独开采）。 <br><br><img src="https://habrastorage.org/webt/9r/aw/je/9rawje4irkcraqt-hpczoggsuqq.png" alt="图片"><br><br>  <i>图</i>  <i>1：在蜜蜂的生命周期中，通过蜜蜂创造交易（BCT）和矿区将工作蜜蜂添加到区块链中</i> <br><br><h3> 创建代理（工作中的蜜蜂） </h3><br> 要创建工作蜂，用户将交易发送到特殊的“死”地址，例如： <code>CReateLitecoinCashWorkerBeeXYs19YQ</code> 。 请注意，每个人都使用相同的地址来创建蜜蜂。 该地址被解析为现有地址和正确地址，但是没有人拥有私钥；  vanitygen实用程序确定使用24 * 2 GHz内核搜索私钥将花费大约1.7 * 10 ^ 31年（成功的机会为50％）。 <br><br> 创建蜜蜂的交易必须至少具有两个输出。 第一个定义了创建蜜蜂的固定费用，该费用被发送到无法访问的地址。 尽管创建蜜蜂的价格将动态确定，但可以假设，这将是块奖励的百分比。 此计算包括最低成本，因此，在开采所有代币时，使用大量采矿来收取交易费用是有意义的。 <br><br> 第二个结论的成本为零，但指定了基址，该基址将来会获得蜜蜂发现的障碍物的任何奖励。 您可以将其称为“养蜂人的未来地址”。 如果需要，用户可以自己进行澄清； 默认情况下，每次在他的钱包中都会生成一个新地址。 <br><br> 一个例子： <br><br><pre> <code class="hljs powershell"><span class="hljs-string"><span class="hljs-string">"vout"</span></span>: [ { // <span class="hljs-type"><span class="hljs-type">Bee</span></span> <span class="hljs-type"><span class="hljs-type">creation</span></span> <span class="hljs-type"><span class="hljs-type">fee</span></span> <span class="hljs-string"><span class="hljs-string">"addr"</span></span>: <span class="hljs-string"><span class="hljs-string">"CReateLitecoinCashWorkerBeeXYs19YQ"</span></span> <span class="hljs-string"><span class="hljs-string">"value"</span></span>: <span class="hljs-number"><span class="hljs-number">1.0000000</span></span> }, { // <span class="hljs-type"><span class="hljs-type">Address</span></span> <span class="hljs-type"><span class="hljs-type">to</span></span> <span class="hljs-type"><span class="hljs-type">receive</span></span> <span class="hljs-type"><span class="hljs-type">block</span></span> <span class="hljs-type"><span class="hljs-type">rewards</span></span> <span class="hljs-type"><span class="hljs-type">for</span></span> <span class="hljs-type"><span class="hljs-type">any</span></span> <span class="hljs-type"><span class="hljs-type">blocks</span></span> <span class="hljs-type"><span class="hljs-type">this</span></span> <span class="hljs-type"><span class="hljs-type">bee</span></span> <span class="hljs-type"><span class="hljs-type">mines</span></span> <span class="hljs-string"><span class="hljs-string">"addr"</span></span>: <span class="hljs-string"><span class="hljs-string">"CTrdm8YDfjmFJwFnKbvNZ9NYznhMqrNgFR"</span></span> <span class="hljs-string"><span class="hljs-string">"value"</span></span>: <span class="hljs-number"><span class="hljs-number">0.0000000</span></span> }, { // <span class="hljs-type"><span class="hljs-type">Change</span></span> <span class="hljs-type"><span class="hljs-type">address</span></span> <span class="hljs-type"><span class="hljs-type">for</span></span> <span class="hljs-type"><span class="hljs-type">change</span></span> <span class="hljs-type"><span class="hljs-type">from</span></span> <span class="hljs-type"><span class="hljs-type">creation</span></span> <span class="hljs-type"><span class="hljs-type">fee</span></span> <span class="hljs-string"><span class="hljs-string">"addr"</span></span>: <span class="hljs-string"><span class="hljs-string">"Cd6CRuWCu6p4NLR6XG7BKyC8hzvEoYuKbn"</span></span> <span class="hljs-string"><span class="hljs-string">"value"</span></span>: <span class="hljs-number"><span class="hljs-number">123.5274346</span></span> } ]</code> </pre> <br> 从创建蜜蜂的那一刻起，在区块链上出现576个区块之后，蜜蜂就会成熟并能够生产区块。 这是在24小时内添加到Litecoin Cash区块链中的新块的预期数量。 蜜蜂成熟后，有4032块（约1周）并寻找块，然后它们死亡。 <br><br> 蜜蜂在QT钱包中创建。 像这样的东西： <br><br><img src="https://habrastorage.org/webt/qx/pj/wt/qxpjwt6tv6k5il6empln0azugxe.png" alt="图片"><br><br>  <i>图</i>  <i>2：带有工作蜜蜂的LCC钱包的布局</i> <br><br><h3> 蜜蜂在工作：块搜索 </h3><br> 例如，假设区块链高度= 1000，并且网络应确定分配哪只蜜蜂来查找块1001。爱丽丝的养蜂人现在有4只蜜蜂（在576和4608之间创建）。 <br><br> 当出现块1000时，爱丽丝的钱包计算两个值。 <br><br> 第一个是确定性值，该值不可预测但易于验证。 通过在0到500000块之间的不同（硬编码）深度处添加块哈希可以轻松做到这一点，确保我们的随机值扎根于区块链： <br><br><pre> <code class="hljs powershell">string deterministicRandString = blocks[<span class="hljs-type"><span class="hljs-type">blockHeight</span></span>].hash + blocks[<span class="hljs-type"><span class="hljs-type">blockHeight</span></span>-<span class="hljs-number"><span class="hljs-number">13</span></span>].hash + blocks[<span class="hljs-type"><span class="hljs-type">blockHeight</span></span>-<span class="hljs-number"><span class="hljs-number">173</span></span>].hash + blocks[<span class="hljs-type"><span class="hljs-type">blockHeight</span></span>-<span class="hljs-number"><span class="hljs-number">1363</span></span>].hash + blocks[<span class="hljs-type"><span class="hljs-type">blockHeight</span></span>-<span class="hljs-number"><span class="hljs-number">27363</span></span>].hash + blocks[<span class="hljs-type"><span class="hljs-type">blockHeight</span></span>-<span class="hljs-number"><span class="hljs-number">496393</span></span>].hash;</code> </pre> <br> 接下来，她的钱包计算出蜜蜂的目标哈希<code>beeTargetHash</code> 。 该值由具有很高动态范围的指数移动平均值确定，该指数设置<code>beeTargetHash</code>以便对于任何给定的蜜蜂种群，确定在采矿过程中获得的块的频率。 从好的方面来说，自上一个高矿井区块以来，已开采了更多PoW区块，即beeTargetHash较高（更简单）。 该算法定义如下：  <code>maxTarget</code> ， <code>emaWindowsSize</code>和<code>emaDesiredSpacing</code>的值将在模拟过程中确定。 <br><br><pre> <code class="hljs pgsql">beeHashTarget = previousBeeHashTarget (<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> highest (easiest) target maxTarget) numPowBlocks = number <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> pow blocks since the previous hive mined block; emaInterval = emaWindowSize / emaDesiredSpacing; beeHashTarget *= (<span class="hljs-type"><span class="hljs-type">interval</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) * emaDesiredSpacing + numPowBlocks + numPowBlocks; beeHashTarget /= (<span class="hljs-type"><span class="hljs-type">interval</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) * emaDesiredSpacing;</code> </pre> <br>  <code>deterministicRandString</code>和<code>beeHashTarget</code>都可以由网络上的任何节点计算。 <br><br> 爱丽丝的钱包现在通过确定性随机链传递了她每只活着的蜜蜂，结合了蜜蜂的BCT交易并对其进行哈希处理以获得新的哈希值-单个蜜蜂的beeHash。 因此，每只蜜蜂每块产生一个哈希。 此哈希类似于PoW采矿设备在同一时间段内生成的最佳哈希。 <br><br><pre> <code class="hljs lisp">hash beeHash = sha256(<span class="hljs-name"><span class="hljs-name">deterministicRandString</span></span> + bee.creationTransaction.ID)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br> 由于爱丽丝的钱包跟踪蜜蜂（每个蜜蜂都计算<code>beeHash</code> ，因此它会记录发现的最佳（最低）哈希值。 结果，如果爱丽丝的钱包发现的最佳哈希满足条件<code>beeHash &lt; beeTargetHash</code> ，则爱丽丝有权添加一个块。 <br><br> 假设爱丽丝有一只活着的蜜蜂，其哈希值低于目标蜜蜂，并且成功的蜜蜂的BCT交易标识符如下： <br><br><pre> <code class="hljs go"><span class="hljs-number"><span class="hljs-number">0f</span></span>6953f0a0816483c71ae3df45650a997e678588a315d72e9ae06e6a3f1c1841.</code> </pre> <br> 网络知道爱丽丝的钱包有权在一个区块上签名，因此该网络产生了一个具有特殊交易的区块，并具有两个输出： <br><br><pre> <code class="hljs powershell"><span class="hljs-string"><span class="hljs-string">"vout"</span></span>: [ { // <span class="hljs-type"><span class="hljs-type">Zero</span></span>-<span class="hljs-type"><span class="hljs-type">value</span></span> <span class="hljs-type"><span class="hljs-type">output</span></span> <span class="hljs-type"><span class="hljs-type">identifies</span></span> <span class="hljs-type"><span class="hljs-type">the</span></span> <span class="hljs-type"><span class="hljs-type">bee</span></span> <span class="hljs-type"><span class="hljs-type">and</span></span> <span class="hljs-type"><span class="hljs-type">proves</span></span> <span class="hljs-type"><span class="hljs-type">it</span></span><span class="hljs-string"><span class="hljs-string">'s really minting for Alice "value": 0, "n": 0, "scriptPubKey": { "asm": "OP_RETURN OP_BEE 0f6953f0a0816483c71ae3df45650a997e678588a315d72e9ae06e6a3f1c1841 IH3Emz49KJeRbw0q4R48pD6GWPQtvHCxLeQOxxH+yv14Tn5KzUFIXBe9Td8EHudejzebMYt/XpusENzNkGM/a4I=" } }, { // Block reward (subsidy + fees) - must pay to bee'</span></span><span class="hljs-type"><span class="hljs-type">s</span></span> <span class="hljs-type"><span class="hljs-type">correct</span></span> <span class="hljs-type"><span class="hljs-type">coinbase</span></span> <span class="hljs-type"><span class="hljs-type">address</span></span> <span class="hljs-string"><span class="hljs-string">"value"</span></span>: <span class="hljs-number"><span class="hljs-number">250.0001125</span></span>, <span class="hljs-string"><span class="hljs-string">"n"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"scriptPubKey"</span></span>: { <span class="hljs-string"><span class="hljs-string">"addresses"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"CTrdm8YDfjmFJwFnKbvNZ9NYznhMqrNgFR"</span></span> ] } }</code> </pre> <br>  <code>vout[0]</code>是无法使用的零值输出。 它既可以用来识别遇到障碍的蜜蜂，也可以用来证明她是为爱丽丝得到的。 <br><br>  <code>vout[1]</code>是向Alice支付块奖励的输出。 <br><br><h3> 阻止确认 </h3><br> 鲍勃的钱包收到了爱丽丝的阻止，现在必须确保他满足共识。 首先，他确保事务包含两个输入，第一个输入为零，并且脚本以<code>OP_RETURN OP_BEE</code> 。 然后，他检索爱丽丝的蜜蜂交易ID： <br><br><pre> <code class="hljs go"><span class="hljs-number"><span class="hljs-number">0f</span></span>6953f0a0816483c71ae3df45650a997e678588a315d72e9ae06e6a3f1c1841.</code> </pre> <br><blockquote> 离题：由于创建蜜蜂的交易被转移到了无法访问的地址，因此未使用交易（UTXO）的输出仍保留在其中。 因此，鲍勃的钱包不需要启用<code>txindex</code>命令行选项（由于延迟验证和增加的磁盘使用量，该选项就完全索引了所有交易）来轻松检查Alice的BCT输出。 由于使用UTXO，因此QT钱包不需要任何数据库或修改即可支持高挖掘。 蜜蜂选项卡还动态集成。 </blockquote><br><br> 通过验证高矿区，Bob的钱包实现了RPC（远程过程调用）的等效功能： <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">gettxout</span></span> 0f6953f0a0816483c71ae3df45650a997e678588a315d72e9ae06e6a3f1c1841 <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br> 这为他提供了第一个BTC输出<code>vout [0]</code> ，并确保1）交易深度在蜜蜂的寿命范围内；  2）为养蜂支付了佣金；  3）它已发送到正确的死角地址。 <br><br> 如果通过验证，Bob的钱包将产生： <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">gettxout</span></span> 0f6953f0a0816483c71ae3df45650a997e678588a315d72e9ae06e6a3f1c1841 <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br> 因此，获得BCT的第二个输出<code>vout [1]</code> ，确认1）值为零；  2）该地址与该块中接收硬币转移的地址相同（在示例<code>CTrdm8YDfjmFJwFnKbvNZ9NYznhMqrNgFR</code> ）。 <br><br> 以下检查从<code>vout [0]</code>的最后部分验证消息签名。 该消息应包含当前的区块编号，并用接收硬币转账的地址签名，因此Bob的钱包会产生： <br><br><pre> <code class="hljs objectivec">verifymessage <span class="hljs-built_in"><span class="hljs-built_in">CTrdm8YDfjmFJwFnKbvNZ9NYznhMqrNgFR</span></span> <span class="hljs-string"><span class="hljs-string">"IH3Emz49KJeRbw0q4R48pD6GWPQtvHCxLeQOxxH+yv14Tn5KzUFIXBe9Td8EHudejzebMYt/XpusENzNkGM/a 4I="</span></span> <span class="hljs-string"><span class="hljs-string">"1001"</span></span></code> </pre> <br> 最后，Bob为当前块计算<code>deterministicRandString</code>和<code>beeHashTarget</code> ，然后计算Alice的<code>beeHash</code>并将其与<code>beeHashTarget</code> 。 如果所有检查均通过，则该块被视为有效并已验证。 块验证过程很快，并且不需要对历史块进行昂贵的验证。 <br><br><h3> 配对Hi-Min和PoW挖掘 </h3><br> 假定高挖掘不是确保网络安全的唯一方法。  Litecoin Cash开发人员不仅希望拯救采矿社区，而且也不想以任何方式进行干预。 高挖掘必须与一个区块链上的PoW挖掘配对。 <br><br> 当前，电路的操作计算如下： <br><br><img src="https://habrastorage.org/webt/vg/pz/np/vgpznpd0y6ijk9bv6ota03ybhn4.png" alt="图片"><br><br> 即，电路的操作根据电路的每个块中的复杂度而累积。 开发人员建议更改此定义，如下所示： <br><br><img src="https://habrastorage.org/webt/af/fo/e4/affoe4zxpceo_ow-jtscjvpb2lm.png" alt="图片"><br><br> 因此，将根据先前的PoW块中完成的工作量来奖励每个蜂巢矿块，并通过实验确定常数<code>k</code> 。 <br><br><h3> 结论：高采作为防御攻击的51％ </h3><br> 根据莱特币现金（Litecoin Cash）首席开发商Jane'Tanner'Craig的说法，HiveMine的想法不仅是为抵御51％的攻击提供可靠的保护，而且还使采矿民主化和分散化。 与PoS区块链不同的是，当“富人变得更富裕”时，HiveMine积累了自己的份额，但它仍然需要创建可能无法回报的蜜蜂的成本。 基于代理的挖掘可满足团队的三个主要任务：使用SHA-256算法使51％的攻击大大复杂化，使挖掘民主化并为矿工提供自由，这确保了同一比特币网络的高度安全性。 为了成功进行攻击，攻击者将需要夺取网络51％的权力以及网络中51％的蜜蜂种群，而且在创建蜜蜂的过程中，这将立即变得显而易见。 <br><br> 根据Craig的说法，在Litecoin Cash网络中测试并实现了HiveMine模型之后，该模型没有提供与相同的Bitcoin Cash相同的SHA-256哈希率，但它将比Bitcoin Cash或Bitcoin网络更快，更可靠。 。 <br><br> 参考文献： <br>  1.“ <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">蜂巢：Litecoin Cash中基于代理的挖掘</a></i> ”，Iain CRAIG，Sebastian CLARKE，MichałWYSZYŃSKI和Federico DEGONZÁLEZ-SOLER。  （2018） </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN415949/">https://habr.com/ru/post/zh-CN415949/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN415939/index.html">使用Spark GraphX进行分布式图形处理</a></li>
<li><a href="../zh-CN415941/index.html">我们如何尝试找出条形码却一无所知</a></li>
<li><a href="../zh-CN415943/index.html">“游戏开发和娱乐理论”：Raff Coster著作的重点</a></li>
<li><a href="../zh-CN415945/index.html">带有Aliexpress的新中文PLC：Wecon LX3VP / LX3VE</a></li>
<li><a href="../zh-CN415947/index.html">旋转过程中通过激光辐射进行处理的光纤安装误差补偿系统</a></li>
<li><a href="../zh-CN415951/index.html">Mitap Sberbank和IBM在HyperLedger Fabric上</a></li>
<li><a href="../zh-CN415953/index.html">血腥的企业如何赢得开源：BPMS之战</a></li>
<li><a href="../zh-CN415957/index.html">我们需要更多的背包：XD Design的Bobby XL</a></li>
<li><a href="../zh-CN415959/index.html">当我们编写移动PvP射击游戏的网络代码时：客户端上的播放器同步</a></li>
<li><a href="../zh-CN415961/index.html">俄罗斯分布式存储。 运作方式</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>