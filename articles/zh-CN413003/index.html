<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐊 🤷🏻 🚵🏻 Steam客户端消除了一个隐瞒了十年的危险漏洞 👩‍🎨 ⭕️ 👮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="信息安全公司首席研究员Tom Court of Context谈到了他如何设法检测Steam客户端代码中潜在的危险错误。 

 注重安全的PC播放器已经注意到Valve最近发布了新的Steam客户端更新。 

 在这篇文章中，我想借口在工作中玩游戏，以讲述Steam客户端中存在至少十年的相关错误的故...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Steam客户端消除了一个隐瞒了十年的危险漏洞</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413003/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5e/654/14d/b5e65414d10ab23ed9f334c7490b5b41.jpg" alt="图片"></div><br>  <i>信息安全公司首席研究员Tom Court of Context谈到了他如何设法检测Steam客户端代码中潜在的危险错误。</i> <br><br> 注重安全的PC播放器已经注意到Valve最近发布了新的Steam客户端更新。 <br><br> 在这篇文章中，我想<s>借口在工作中玩游戏，以</s>讲述Steam客户端中存在至少十年的相关错误的故事，直到去年7月，这可能导致远程代码执行（远程代码执行，RCE）所有1500万活跃客户中。 <br><br> 自7月起，当Valve（最终）在启用现代漏洞保护功能的情况下编译其代码时，它仅会导致客户端故障，并且RCE仅与单独的信息泄漏漏洞结合使用才可能。 <br><br> 我们于2018年2月20日宣布Valve为漏洞，并且值得赞扬的是，该公司在不到12小时后便将其修复到beta版分支中。 该修复程序已于2018年3月22日移至稳定分支。 <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e75/1aa/558/e751aa55836f621b240641f85adbde62.jpg" alt="图片"></div><br><h2> 简短评论 </h2><br> 该漏洞的根源是对Steam客户端库中堆的损坏，可以远程调用该代码，该代码部分涉及从几个接收到的UDP数据包中恢复分段的数据报。 <br><br>  Steam客户端通过自己的协议（Steam协议）交换数据，该协议在UDP之上实现。 由于存在漏洞，该协议中有两个特别有趣的地方： <br><br><ul><li> 包长 </li><li> 重建数据报的总长度 </li></ul><br> 该错误是由于缺少简单检查引起的。 该代码未验证第一个分段数据报的长度是否小于或等于数据报的总长度。 鉴于对于传输数据报片段的所有后续数据包都执行​​检查，这似乎是一个常见的疏忽。 <br><br> 如果没有其他数据泄漏错误，就很难控制现代操作系统上的堆破坏，因此很难执行远程代码执行。 但是，在这种情况下，由于Steamclient.dll二进制文件（到去年7月）中缺少Steam自己的内存分配器和ASLR，此错误可以用作非常可靠的利用的基础。 <br><br> 以下是该漏洞及其相关漏洞的技术描述，直到 <br> 代码执行实现。 <br><br><h2> 漏洞详情 </h2><br><h3> 理解所必需的信息 </h3><br><h4> 协议书 </h4><br> 第三方（例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://imfreedom.org/wiki/Steam_Friends</a> ）基于对Steam客户端生成的流量的分析，进行了逆向工程并创建了Steam协议的详细文档。 最初，该协议于2008年形成文档，此后没有太大变化。 <br><br> 该协议通过在UDP数据报流上建立连接来实现为传输协议。 根据上面链接中的文档，软件包具有以下结构： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/94b/d59/e25/94bd59e25c5dfac228e3a63b62192717.jpg" alt="图片"></div><br> 重要方面： <br><br><ul><li> 所有数据包<em>均以</em> “ <em>VS01</em> ”的4个字节<em>开头</em> </li><li>  <em>packet_len</em>描述有用信息的长度（对于无碎片的数据报，其值等于数据的长度） </li><li>  <em>type</em>描述程序包的类型，可以具有以下值： <br><ul><li>  0x2呼叫验证 </li><li>  0x4接受连接 </li><li>  0x5重置连接 </li><li>  0x6数据包是数据报的片段 </li><li>  0x7包是一个单独的数据报 </li></ul></li><li>  <em>源</em>和<em>目标</em>字段是为在Steam客户端内的多个连接上正确路由数据包而分配的标识符 </li><li> 如果数据包是数据报的片段： <br><ul><li>  <em>split_count</em>指示数据报被拆分为的片段数 </li><li>  <em>data_len</em>表示恢复的数据报的总长度 </li></ul></li><li> 这些UDP数据包的初始处理发生在<em>steamclient.dll</em>中的函数<em>CUDPConnection ::</em> UDPRecvPkt中 </li></ul><br><h4> 加密方式 </h4><br>  AES-256使用密钥对数据报包的有用信息进行加密，该密钥在每个会话的客户端和服务器之间协商。 密钥协商的执行过程如下： <br><br><ul><li> 客户端生成一个32字节的AES随机密钥，并且RSA在将其发送到服务器之前使用Valve公钥对其进行加密。 </li><li> 具有私钥的服务器可以解密该值并将其接受为AES-256密钥，该密钥将在会话中使用 </li><li> 同意密钥后，将使用此密钥对当前会话中的所有有用信息进行加密。 </li></ul><br><h3> 脆弱性 </h3><br>  <em>CUDPConnection</em>类的<em>RecvFragment</em>方法内部存在漏洞。  steamclient库的发行版中没有符号，但是，当在我们感兴趣的功能中搜索二进制<em>行时，</em>会找到指向“ <em>CUDPConnection :: RecvFragment</em> ”的链接。 当客户端收到包含类型为0x6的Steam数据报（“数据报的片段”）的UDP数据包时，执行此功能。 <br><br>  1.该功能通过检查连接状态以确保其处于“ <em>已连接</em> ”状态开始。 <br>  2.然后，检查Steam数据报中的<em>data_len</em>字段以确保它包含的字节数少于<em>0x20000060</em> （看来该值是任意选择的）。 <br>  3.如果通过了检查，该函数将检查连接是否收集某些数据报的片段，或者它是流的第一个数据包。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb3/19b/451/cb319b451e64f08c718a78f0f2c5995c.jpg" alt="图片"></div><br>  4.如果这是流中的第一个数据包，则<em>检查split_count</em>字段以查看此流将扩展多少个数据包 <br>  5.如果将流分成几个数据包，则将<em>检查seq_no_of_first_pkt</em>字段以确保它与当前数据包的序列号匹配。 这样可以确保数据包是流中的第一个。 <br>  6.再次对照<em>0x20000060</em>字节的限制<em>检查data_len</em>字段。 此外，已验证<em>split_count</em>小于<em>0x709b</em>数据包。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e6/19b/250/7e619b25083dc91558888ef6ca1b6ef4.jpg" alt="图片"></div><br>  7.如果满足这些条件，则将设置一个布尔值以指示我们现在正在收集片段。 它还会检查我们是否尚未分配用于存储片段的缓冲区。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69a/8b2/8c4/69a8b28c40e56f3de825d6a6c8c483c0.jpg" alt="图片"></div><br>  8.如果指向碎片收集缓冲区的指针不为零，则释放当前的碎片收集缓冲区并分配新的缓冲区（请参见下图中的黄色矩形）。 这是错误出现的地方。 片段收集缓冲区应以<em>data_len</em>字节的大小分配。 如果一切成功（并且代码未检查-一个小错误），则使用<em>memmove</em>将数据报的有用数据复制到此缓冲区，并相信在<em>packet_len中</em>指示了要复制的字节数。 <br><br>  <strong>开发人员最重要的疏忽是未执行检查“ <em>packet_len</em>小于或等于<em>data_len</em> ”。</strong>  <strong>这意味着可以传输小于<em>packet_len的</em> <em>data_len</em>并将最多64 KB的数据（由于<em>packet_len</em>字段为2字节宽）复制到一个很小的缓冲区中，从而可以利用堆损坏。</strong> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d4c/6ae/a31/d4c6aea31e05f0479552817bbc95a1e3.jpg" alt="图片"></div><br><h2> 漏洞利用 </h2><br> 本部分假定存在针对ASLR的解决方法。 这导致一个事实，即在开始运行之前，steamclient.dll的起始地址是已知的。 <br><br><h3> 数据包欺骗 </h3><br> 为了使客户端接收攻击性UDP数据包，它必须检查发送的（客户端-&gt;服务器）数据报，该数据报被发送以便找出客户端/服务器连接的标识符以及序列号。 然后，攻击者必须欺骗IP地址和源/目标端口以及客户端/服务器标识符，并将获悉的序列号加1。 <br><br><h3> 记忆体管理 </h3><br> 若要分配大于1024（0x400）字节的内存，请使用标准系统分配器。 为了分配小于或等于1024字节的内存，Steam使用其自己的分配器，该分配器在所有受支持的平台上均相同。 本文将不详细讨论此分发服务器，但以下关键方面除外： <br><br><ol><li> 向系统分配器请求较大的内存块，然后将其划分为固定大小的片段，以在Steam客户端内存分配请求下使用。 </li><li> 选择是按顺序执行的，在使用的片段之间没有将它们分开的元数据。 </li><li> 每个大块都存储自己的空闲内存列表，该列表实现为单链接列表。 </li><li> 空闲内存列表的顶部指示内存中的第一个空闲片段，此片段的前4个字节指示下一个空闲片段（如果存在）。 </li></ol><br><h4> 内存分配 </h4><br> 分配内存时，第一个空闲块与空闲内存列表的顶部断开连接，并且该块的与<em>next_free_block</em>相对应的前4个字节被复制到<em>分配器</em>类内的<em>freelist_head</em>成员<em>变量中</em> 。 <br><br><h4> 可用内存 </h4><br> 释放一个块后， <em>会将</em> <em>freelist_head</em>字段复制到已释放块的前4个字节（ <em>next_free_block</em> ），并将已释放块的地址复制到分发器类的成员变量<em>freelist_head</em> 。 <br><br><h3> 如何获得录音原语 </h3><br> 堆上会发生缓冲区溢出，根据导致损坏的数据包的大小，可以通过标准Windows分配器（当分配的内存大于0x400字节时）或Steam自己的分配器（当分配的内存小于0x400字节时）来控制内存分配。 由于我自己的Steam发行商缺乏安全措施，因此我决定将其用作漏洞利用程序更容易。 <br><br> 让我们回到有关内存管理的部分：已知的是，给定大小的块的空闲内存列表的顶部存储为分发器类的成员变量，并且指向列表中下一个空闲块的指针存储为列表中每个空闲块的前4个字节。 <br><br> 如果在发生溢出的块旁边有一个空闲块，则对堆的损坏使我们可以覆盖<em>next_free_block</em>指针。 如果您认为可以为此准备一堆，则可以将重写的<em>next_free_block</em>指针设置为要写入的地址，然后将随后的内存分配写入该位置。 <br><br><h3> 使用内容：数据报或片段 </h3><br> 负责处理数据报片段（类型6的数据包）的代码中发生内存损坏错误。 发生损坏后， <em>RecvFragment（）</em>函数处于期望接收更多片段的状态。 但是，如果到达，则执行检查： <br><br> <code>fragment_size + num_bytes_already_received &lt; sizeof(collection_buffer)</code> <br> <br> 但是显然不是这种情况，因为我们的第一个程序包已经违反了此规则（存在错误可能会跳过此检查），并且会发生错误。 为了避免这种情况，您需要在内存<em>损坏</em>后避免使用<em>CUDPConnection :: RevvFragment（）</em>方法。 <br><br> 幸运的是，在<em>RecvFragment（）</em>有效之前， <em>CUDPConnection :: :: RecvDatagram（）</em>仍可以接收和处理类型为7（数据报）的已发送数据包，并且该数据包可用于启动记录原语。 <br><br><h3> 加密问题 </h3><br>  <em>RecvDatagram（）</em>和<em>RecvFragment（）</em>接收到的数据包预计将被加密。 对于<em>RecvDatagram（），</em>接收后几乎立即执行解密。 对于<em>RecvFragment（），</em>它是在收到会话中的最后一个片段之后发生的。 <br><br> 由于我们不知道在每个会话中创建的加密密钥，因此出现了利用漏洞的问题。 这意味着我们发送的任何OP代码/ shell代码都将使用AES256“解密”，这会将我们的数据变成垃圾。 因此，有必要找到一种操作方法，在解密程序将能够处理包含在分组缓冲器中的有用信息之前，几乎可以在接收到分组之后立即进行操作。 <br><br><h3> 如何实现代码执行 </h3><br> 给定上述解密限制，应在解密输入数据之前执行操作。 这施加了附加的限制，但是任务仍然可行：您可以重写指针，使其指向存储在二进制文件的数据部分内可预测位置的<em>CWorkThreadPool</em>对象。 尽管此类的详细信息和内部功能尚不清楚，但可以通过其名称假定该类支持需要执行“工作”时可以使用的线程池。 在研究了二进制文件中的几行调试行后，您可以了解到，在这样的工作中有加密和解密（ <em>CWorkItemNetFilterEncrypt</em> ， <em>CWorkItemNetFilterDecrypt</em> ），因此当这些任务排队时，就<em>使用</em>了<em>CWorkThreadPool</em>类。 通过覆盖此指针并将其写入所需的位置，我们可以模拟vtable指针和与其关联的vtable，这使我们能够执行代码，例如，在<em>调用CWorkThreadPool :: AddWorkItem（）时</em> ，该代码必须在任何解密过程之前发生。 <br><br> 下图显示了成功利用此漏洞的过程，直到获得对EIP寄存器的控制权为止。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a8/383/537/4a83835371112599ca429941e449e734.jpg" alt="图片"></div><br> 从现在开始，您可以创建一个导致执行任意代码的ROP链。 以下视频显示了攻击者如何在完全修补的Windows 10版本中远程启动Windows计算器。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/0QaozC8S0Aw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2> 总结一下 </h2><br> 如果您到达本文的这一部分，则感谢您的坚持！ 我希望您理解这是一个非常简单的错误，由于缺乏现代的防范攻击手段，因此很容易利用。 易受攻击的代码可能很旧，但否则运行良好，因此开发人员无需检查或更新其构建脚本。 此处的教训是，即使代码本身的功能保持不变，对于开发人员而言，定期检查旧代码并构建系统以确保它们符合现代安全标准也很重要。 在2018年，在非常流行的软件平台上发现如此简单的bug并带来如此严重的后果，真是令人惊讶。 这应该激励所有研究人员寻找此类漏洞！ <br><br> 最后，值得讨论的是负责任的信息披露过程。 我们在格林尼治标准时间下午4点左右将这个错误报告给Valve的安全<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">团队</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">security@valvesoftware.com</a> ），仅8小时后，便创建了一个修复程序并将其发布到Beta客户端Steam中。 由于这个原因，Valve现在在我们的“谁将更快地修复漏洞”竞赛的（虚构）表中排名第一-与向其他公司披露错误相比，这是一个令人愉悦的例外，通常这会导致漫长的审批流程。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">描述所有客户端更新的详细信息的页面</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN413003/">https://habr.com/ru/post/zh-CN413003/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN412993/index.html">公钥基础结构：合格的证书请求生成实用程序</a></li>
<li><a href="../zh-CN412995/index.html">SAP快速</a></li>
<li><a href="../zh-CN412997/index.html">捉迷藏，或第一个不怕重启的僵尸网络</a></li>
<li><a href="../zh-CN412999/index.html">从长颈鹿的嗡嗡声到模仿鸟的声音-一起聆听大自然</a></li>
<li><a href="../zh-CN413001/index.html">SamsPcbGuide，第5部分：跟踪信号线。 线路失真和阻抗匹配</a></li>
<li><a href="../zh-CN413005/index.html">区块链-治疗现代教育的主要疾病</a></li>
<li><a href="../zh-CN413007/index.html">使用FPGA时的奇怪综合</a></li>
<li><a href="../zh-CN413009/index.html">使用Pipenv进行Python环境管理</a></li>
<li><a href="../zh-CN413011/index.html">死亡的地下室</a></li>
<li><a href="../zh-CN413013/index.html">对透明度的渴望</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>