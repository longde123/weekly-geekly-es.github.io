<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💼 🛌🏿 👨🏿‍🎓 Cara mengubah citra satelit menjadi peta. Visi komputer dalam Yandex 👨🏻‍🔧 🏅 😿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salah satu sumber data utama untuk layanan Yandex.Maps adalah citra satelit. Agar mudah digunakan dengan peta, objek ditandai dengan poligon dalam gam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara mengubah citra satelit menjadi peta. Visi komputer dalam Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/431108/">  Salah satu sumber data utama untuk layanan Yandex.Maps adalah citra satelit.  Agar mudah digunakan dengan peta, objek ditandai dengan poligon dalam gambar: hutan, kolam, jalan, rumah, dll. Biasanya, kartografer terlibat dalam penandaan.  Kami memutuskan untuk membantu mereka dan mengajarkan komputer untuk menambahkan poligon rumah tanpa partisipasi orang. <br><br>  Untuk operasi dengan gambar memenuhi bidang TI, yang disebut visi komputer.  Selama beberapa tahun terakhir, sebagian besar tugas di bidang ini telah sangat berhasil diselesaikan menggunakan jaringan saraf.  Hari ini kami akan memberi tahu pembaca Habr tentang pengalaman kami menggunakan jaringan saraf dalam pemetaan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rn/xz/e2/rnxze2-1b6bobojodppliybmehe.jpeg"></div><a name="habracut"></a><br>  Pertama-tama, kita akan melatih grid saraf yang akan terlibat dalam segmentasi semantik, yaitu, akan menentukan apakah setiap titik dalam citra satelit terkait dengan rumah.  Mengapa segmentasi semantik dan bukan hanya deteksi objek?  Ketika masalah pendeteksian diselesaikan, kita akan mendapatkan satu set persegi panjang keluaran, lebih spesifik: dua sisi vertikal, dua horisontal.  Dan rumah biasanya diputar relatif terhadap sumbu gambar, dan beberapa bangunan juga memiliki bentuk yang kompleks. <br><br>  Tugas segmentasi semantik sekarang sedang diselesaikan oleh berbagai jaringan ( <a href="">FCN</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SegNet</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">UNet</a> , dll.).  Anda hanya perlu memilih mana yang terbaik untuk kami. <br><br>  Setelah menerima topeng dari citra satelit, kami memilih kelompok titik yang cukup besar milik rumah-rumah, mengumpulkannya di area yang terhubung dan menyajikan batas-batas area dalam bentuk vektor dalam bentuk poligon. <br><br>  Jelas bahwa topeng itu tidak akan sepenuhnya akurat, yang berarti bahwa rumah-rumah di dekatnya dapat tetap bersatu dalam satu area yang terhubung.  Untuk mengatasi masalah ini, kami memutuskan untuk lebih lanjut melatih jaringan.  Dia akan menemukan dalam gambar tulang rusuk (batas-batas rumah) dan memisahkan bangunan yang direkatkan. <br><br>  Jadi, skema seperti itu tampak: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7z/dw/lt/7zdwlt1z0orhy2i9fhkgifjwkcw.jpeg"></div><br>  Kami tidak sepenuhnya membuang jaringan deteksi dan mencoba <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mask R-CNN</a> .  Kelebihannya dibandingkan dengan segmentasi biasa adalah bahwa Mask R-CNN mendeteksi objek dan menghasilkan topeng, sehingga tidak perlu mengotak-atik pembagian topeng umum ke dalam area yang terhubung.  Nah, minus (seperti tanpa itu) dalam resolusi tetap topeng setiap objek, yaitu, untuk rumah besar dengan perbatasan kompleks, perbatasan ini jelas akan berubah menjadi disederhanakan. <br><br><h2>  Alat-alatnya </h2><br>  Maka itu perlu untuk memutuskan alat.  Semuanya sangat jelas di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OpenCV</a> paling cocok untuk tugas-tugas visi komputer.  Pilihan jaringan saraf agak lebih luas.  Kami menetap di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tensorflow</a> .  Keuntungannya: <br><br><ul><li>  satu set “kubus” siap pakai yang dikembangkan dari mana Anda dapat mengumpulkan jaringan Anda; </li><li>  Python API, mudah untuk membuat struktur jaringan dan pelatihan dengan cepat; </li><li>  Jaringan terlatih dapat digunakan dalam program Anda melalui antarmuka C ++ (sangat buruk dibandingkan dengan bagian Python, tetapi cukup memadai untuk menjalankan jaringan yang sudah jadi). </li></ul><br>  Untuk pelatihan dan komputasi berat lainnya, kami berencana untuk menggunakan Nirvana - platform Yandex yang luar biasa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">yang telah kami bicarakan</a> . <br><br><h2>  Datacet </h2><br>  Keberhasilan delapan puluh persen dalam bekerja dengan jaringan saraf terdiri dari dataset yang baik.  Jadi, sebagai permulaan, kita harus mengumpulkan dataset seperti itu.  Yandex memiliki sejumlah besar gambar satelit dengan objek yang sudah ditandai.  Segalanya tampak sederhana: cukup unggah data ini dan kumpulkan dalam dataset.  Namun, ada satu peringatan. <br><br><h3>  Saring dataset </h3><br>  Ketika seseorang mencari rumah dalam citra satelit, hal pertama yang dilihatnya adalah atap.  Tetapi ketinggian rumah bervariasi, satelit dapat mengambil medan yang sama dari sudut yang berbeda - dan jika kita menempatkan poligon yang sesuai dengan atap pada peta vektor, tidak ada jaminan bahwa atap tidak akan pergi ketika gambar diperbarui.  Tetapi fondasi digali ke tanah dan, dari sudut mana pun Anda melepasnya, semua waktu tetap di satu tempat.  Itulah sebabnya rumah-rumah pada vektor Yandex.Map ditandai "pada fondasi."  Ini benar, tetapi untuk tugas segmentasi gambar, lebih baik mengajarkan jaringan untuk mencari atap: harapan bahwa jaringan dilatih untuk mengenali fondasi sangat kecil.  Oleh karena itu, dalam dataset semuanya harus ditandai di atap.  Jadi, untuk membuat dataset yang baik, kita perlu belajar bagaimana mengubah tata letak vektor rumah dari fondasi ke atap. <br><br>  <i>Kami mencoba untuk tidak bergeser, tetapi kualitasnya tidak terlalu bagus, dan ini dapat dimengerti: sudut pengambilan gambar satelit berbeda, ketinggian rumah berbeda, akibatnya, dalam foto-foto fondasi bergeser ke arah yang berbeda dan pada jarak yang berbeda dari atap.</i>  <i>Jaringan hilang dari variasi seperti itu dan, paling-paling, melatih sesuatu di antaranya, paling buruk - untuk sesuatu yang tidak dapat dipahami.</i>  <i>Selain itu, jaringan untuk segmentasi semantik menghasilkan hasil yang mirip dengan sesuatu yang dapat diterima, tetapi ketika mencari tepi, kualitasnya menurun secara dramatis.</i> <br><br><h4>  Pendekatan raster </h4><br>  Sejak kami masuk ke bidang visi komputer, hal pertama yang kami lakukan adalah mencoba pendekatan yang relevan dengan visi komputer ini.  Pertama, peta vektor dirasterisasi (poligon rumah digambar dengan garis putih pada latar belakang hitam), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">filter Sobel</a> memilih tepi pada gambar satelit.  Dan kemudian ada offset dari dua gambar relatif satu sama lain, yang memaksimalkan korelasi di antara mereka.  Tepi setelah filter Sobel cukup berisik, oleh karena itu, jika pendekatan ini diterapkan pada satu bangunan, hasil yang dapat diterima tidak selalu diperoleh.  Namun, metode ini bekerja dengan baik di wilayah dengan bangunan dengan ketinggian yang sama: jika Anda mencari offset segera di area gambar yang besar, hasilnya akan lebih stabil. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7q/re/nq/7qrenqshfovrbc1y84j0y_5q7do.jpeg"></div><br><h4>  Pendekatan "Geometrik" </h4><br>  Jika wilayah tersebut dibangun bukan dengan tipe yang sama, tetapi dengan berbagai rumah, metode sebelumnya tidak akan berfungsi.  Untungnya, kadang-kadang kita mengetahui ketinggian bangunan di peta vektor Yandex dan posisi satelit selama pemotretan.  Dengan demikian, kita dapat menggunakan pengetahuan sekolah tentang geometri dan menghitung di mana dan pada jarak berapa atap akan bergerak relatif terhadap fondasi.  Metode ini telah meningkatkan dataset di area dengan bangunan bertingkat tinggi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/in/v3/wp/inv3wppmsi5dhhk5jcbmiwymqas.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yq/kj/_h/yqkj_h0okr891jlbdoaljqfhfsu.jpeg"></div><br><h4>  Pendekatan "manual" </h4><br>  Cara yang paling memakan waktu: menyingsingkan lengan baju Anda, membuka mouse, menatap monitor dan secara manual menggeser tata letak vektor rumah-rumah dari fondasi ke atap.  Teknik ini membawa hasil yang luar biasa dalam kualitas, tetapi tidak disarankan untuk menggunakannya dalam jumlah besar: pengembang yang terlibat dalam tugas-tugas seperti itu dengan cepat jatuh ke dalam sikap apatis dan kehilangan minat dalam hidup. <br><br><h4>  Jaringan saraf </h4><br>  Pada akhirnya, kami mendapat citra satelit yang cukup, ditandai dengan baik di atap.  Jadi, ada kesempatan untuk melatih jaringan saraf (untuk saat ini, bukan untuk segmentasi, tetapi untuk meningkatkan tata letak gambar satelit lainnya).  Dan kami berhasil. <br><br>  Data input dari jaringan saraf convolutional adalah citra satelit dan tanda raster yang digeser.  Pada output, kami menerima vektor dua dimensi: perpindahan vertikal dan horisontal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ad/qy/i9/adqyi95ityf_cueqvd-f2krrknk.png"></div><br>  Dengan bantuan jaringan saraf, kami menemukan perpindahan yang diperlukan, yang memungkinkan kami mencapai hasil yang baik pada bangunan yang ketinggiannya tidak ditunjukkan.  Akibatnya, kami secara signifikan mengurangi koreksi markup manual. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/s6/tj/v1/s6tjv13fffnmhkxrs7etzhiv1g0.jpeg"></div><br><h3>  Wilayah berbeda - beda rumah </h3><br>  Ada banyak wilayah dan negara yang menarik di Yandex.Maps.  Tetapi bahkan di Rusia, rumah sangat beragam, yang memengaruhi penampilannya dalam citra satelit.  Jadi, Anda harus mencerminkan keragaman dalam dataset.  Dan awalnya kami tidak benar-benar mengerti bagaimana cara mengatasi semua kemegahan ini.  Kumpulkan dataset besar dan latih satu jaringan di atasnya?  Buat dataset Anda sendiri untuk setiap jenis pengembangan (kondisional) dan latih jaringan yang terpisah?  Melatih jaringan inti tertentu dan kemudian melatihnya untuk jenis pengembangan tertentu? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ny/pa/fd/nypafdcjqd3vny1_uqpujrfn0ci.jpeg"></div><br>  Secara empiris, kami menemukan bahwa: <br><br><ol><li>  Tidak diragukan lagi, perlu untuk memperluas dataset untuk berbagai jenis bangunan yang direncanakan untuk menggunakan alat ini.  Sebuah jaringan yang dilatih pada satu jenis mampu membedakan bangunan dari jenis lain, meskipun sangat buruk. </li><li>  Lebih baik melatih satu jaringan besar di seluruh kumpulan data.  Ini menggeneralisasi dengan cukup baik ke berbagai wilayah.  Jika Anda melatih jaringan yang terpisah untuk setiap jenis pengembangan, kualitasnya akan tetap sama atau hampir tidak membaik.  Jadi tidak ada gunanya menerapkan jaringan yang berbeda untuk wilayah yang berbeda.  Selain itu, ini membutuhkan lebih banyak data dan tambahan jenis pengembangan. </li><li>  Jika Anda menggunakan jaringan lama saat menambahkan wilayah baru ke data, jaringan akan belajar lebih cepat.  Pelatihan ulang jaringan lama pada data yang diperluas mengarah ke hasil yang kira-kira sama dengan melatih jaringan dari awal, tetapi membutuhkan waktu yang jauh lebih sedikit. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vk/_v/zq/vk_vzq0fxfhcjlusrbqjjqhnfre.jpeg"></div><br><h2>  Opsi solusi </h2><br><h3>  Segmentasi semantik </h3><br>  Segmentasi semantik adalah tugas yang diteliti dengan cukup baik.  Setelah munculnya artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jaringan Sepenuhnya Konvolusional</a> , sebagian besar diselesaikan dengan menggunakan jaringan saraf.  Yang tersisa hanyalah memilih jaringan (kami anggap <a href="">FCN</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SegNet</a> , dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">UNet</a> ), pikirkan apakah kami membutuhkan trik tambahan seperti CRF di output, dan putuskan bagaimana dan dengan fungsi kesalahan apa pelatihan akan dilatih. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/un/ay/gn/unaygnyzsdhk_2dbk4qq2-2m340.png"></div><br>  Sebagai hasilnya, kami memilih arsitektur seperti U-Net dengan fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Intersection Over Union yang digeneralisasi</a> sebagai fungsi kesalahan.  Untuk pelatihan, kami memotong gambar satelit dan tanda-tanda yang sesuai (tentu saja, di-raster) menjadi kotak dan dikumpulkan menjadi kumpulan data.  Ternyata cukup bagus, dan terkadang baik-baik saja. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z1/rv/ub/z1rvubhjv5xcruynmvarimca3zy.jpeg"></div><br>  Di wilayah dengan bangunan tunggal, segmentasi semantik sudah cukup untuk beralih ke tahap berikutnya - vektorisasi.  Di mana bangunannya padat, rumah-rumah kadang-kadang saling menempel di area yang kohesif.  Butuh untuk memisahkan mereka. <br><br><h3>  Deteksi tepi </h3><br>  Untuk mengatasi tugas ini, Anda dapat menemukan tepi pada gambar.  Untuk mendeteksi tepi, kami juga memutuskan untuk melatih jaringan (algoritme pencarian tepi yang tidak menggunakan jaringan saraf jelas merupakan sesuatu dari masa lalu).  Melatih jaringan tipe HED, yang dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Deteksi Tepi Bersarang Secara Holistik</a> .  Dalam artikel asli, jaringan dilatih pada set data BSDS-500, di mana semua tepi ditandai pada gambar.  Sebuah jaringan yang terlatih menemukan semua sisi yang menonjol: batas-batas rumah, jalan, danau, dll. Ini sudah cukup untuk memisahkan bangunan di dekatnya.  Tetapi kami memutuskan untuk melangkah lebih jauh dan menggunakan dataset yang sama untuk pelatihan seperti segmentasi semantik, tetapi ketika melakukan rasterisasi, jangan mengecat seluruh poligon bangunan, tetapi hanya menggambar batas-batasnya. <br><br>  Hasilnya sangat indah sehingga kami memutuskan untuk membuat vektor bangunan secara langsung dengan tepian yang diterima dari jaringan.  Dan itu terjadi begitu saja. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/am/uz/h-/amuzh-xo7mzssz9jtzkppm3_nag.jpeg"></div><br><h3>  Deteksi vertex </h3><br>  Karena jaringan seperti HED memberikan hasil yang sangat baik di tepi, kami memutuskan untuk melatihnya untuk mendeteksi simpul.  Faktanya, kami memiliki jaringan dengan bobot umum pada lapisan konvolusional.  Dia memiliki dua pintu keluar pada saat yang sama: untuk tepi dan untuk puncak.  Sebagai hasilnya, kami membuat versi lain dari vektorisasi bangunan, dan dalam beberapa kasus menunjukkan hasil yang cukup waras. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fj/50/wl/fj50wlerknjc02f8cnhgguizu2o.jpeg"></div><br><h3>  Topeng r-cnn </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mask R-CNN</a> adalah perluasan jaringan yang relatif baru seperti F-R-CNN yang lebih cepat.  Masker R-CNN mencari objek dan memilih topeng untuk masing-masing.  Akibatnya, untuk rumah-rumah kita tidak hanya mengikat persegi panjang, tetapi juga struktur halus.  Pendekatan ini lebih baik dibandingkan dengan deteksi sederhana (kami tidak tahu bagaimana bangunan itu berada di dalam persegi panjang) dan segmentasi normal (beberapa rumah dapat saling menempel menjadi satu, dan tidak jelas bagaimana memisahkannya).  Dengan Mask R-CNN, Anda tidak perlu lagi memikirkan trik tambahan: cukup untuk membuat vektor batas mask untuk setiap objek dan segera mendapatkan hasilnya.  Ada juga minus: ukuran topeng untuk objek selalu diperbaiki, mis. Untuk bangunan besar, akurasi tata letak piksel akan rendah.  Hasil dari Mask R-CNN terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/it/8v/4w/it8v4wy0axix-hpi2gfxkomo3nk.jpeg"></div><br>  Kami mencoba Mask R-CNN yang terakhir dan memastikan bahwa untuk beberapa jenis bangunan pendekatan ini mengungguli yang lain. <br><br><h2>  Vektorisasi </h2><br><h3>  Vektorisasi Persegi Panjang </h3><br>  Dengan semua keragaman arsitektur modern, rumah-rumah pada citra satelit masih paling sering terlihat seperti persegi panjang.  Selain itu, untuk massa wilayah, penandaan dengan poligon kompleks tidak diperlukan.  Tapi saya tetap ingin rumah di peta ditandai.  (Ya, misalnya, kemitraan hortikultura: biasanya ada banyak rumah di sana, penandaan secara manual tidak begitu penting, tetapi penandaan dengan persegi panjang pada peta sangat baik.) Oleh karena itu, pendekatan pertama untuk vektorisasi sangat sederhana. <br><br><ol><li>  Ambil wilayah raster yang sesuai dengan "rumah". </li><li>  Temukan persegi panjang area minimum yang berisi area ini (misalnya, seperti ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OpenCV :: minAreaRect</a> ).  Masalahnya terpecahkan. </li></ol><br>  Jelas bahwa kualitas pendekatan ini jauh dari ideal.  Namun, algoritma ini cukup sederhana dan dalam banyak kasus berfungsi. <br><br><h3>  Vektorisasi Poligon </h3><br>  Jika kualitas segmentasi cukup baik, Anda dapat membuat ulang kontur rumah dengan lebih akurat.  Pada sebagian besar bangunan dengan bentuk kompleks, sudut sebagian besar benar, jadi kami memutuskan untuk mengurangi masalah menjadi tugas membangun poligon dengan sisi ortogonal.  Memecahkannya, kami ingin mencapai dua tujuan sekaligus: untuk menemukan poligon paling sederhana dan mengulangi bentuk bangunan seakurat mungkin.  Sasaran-sasaran ini saling bertentangan, jadi Anda harus memperkenalkan kondisi tambahan: untuk membatasi panjang minimum dinding, deviasi maksimum dari wilayah raster, dll. <br><br>  Algoritma yang pertama kali terjadi pada kita didasarkan pada konstruksi proyeksi titik pada garis lurus: <br><br><ol><li>  Temukan garis besar wilayah raster yang sesuai dengan satu rumah. </li><li>  Kurangi jumlah titik dalam rangkaian dengan menyederhanakannya, misalnya, dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma Douglas-Pecker</a> . </li><li>  Temukan sisi terpanjang di garis besar.  Ini adalah sudut kemiringannya yang akan menentukan sudut seluruh poligon ortogonal di masa depan. </li><li>  Buatlah proyeksi dari titik kontur berikutnya ke sisi sebelumnya. </li><li>  Perpanjang sisi ke titik proyeksi.  Jika jarak dari titik ke proyeksi lebih besar dari dinding terpendek bangunan, tambahkan segmen yang dihasilkan ke kontur bangunan. </li><li>  Ulangi langkah 4 dan 5 hingga sirkuit ditutup. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ey/ok/y5/eyoky5b1d4ayzcflogdwsxfyi8g.png"></div><br>  Algoritma ini sangat sederhana dan cepat membawa hasil, tetapi kontur bangunan terkadang berubah menjadi sangat berisik.  Mencoba untuk mengatasi masalah ini, kami menemukan solusi yang agak menarik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk</a> masalah ini, yang menggunakan kotak persegi di ruang untuk memperkirakan poligon.  Dijelaskan secara singkat, algoritma terdiri dari tiga tindakan: <br><br><ol><li>  Bangun kisi persegi di ruang yang berpusat pada nol. </li><li>  Pada titik grid yang terletak tidak jauh dari jarak tertentu dari kontur asli, buat poligon yang berbeda. </li><li>  Pilih poligon dengan jumlah simpul minimum. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5f/em/ti/5femtieuuectay9wjhoncxi2rh4.png"></div><br>  Karena sudut rotasi yang diperlukan dari grid tidak diketahui sebelumnya, maka perlu untuk memilah beberapa nilai, yang mempengaruhi kinerja dengan buruk.  Namun, algoritma ini memungkinkan Anda untuk mencapai hasil yang lebih indah secara visual. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yz/rb/u1/yzrbu1in149ocfxxmdv_h6gctug.jpeg"></div><br><h2>  Peningkatan Vektorisasi </h2><br>  Padahal kami benar-benar bekerja dengan masing-masing rumah secara terpisah.  Ketika tahap pertama selesai, Anda sudah dapat bekerja dengan gambar secara keseluruhan dan meningkatkan hasilnya.  Untuk ini, sebuah algoritma untuk pasca-pemrosesan serangkaian poligon telah ditambahkan.  Kami menggunakan heuristik berikut: <br><br><ul><li>  Biasanya dinding rumah yang berdekatan sejajar.  Selain itu: paling sering, rumah dapat digabungkan menjadi set, di mana semua elemen disejajarkan. </li><li>  Jika jalan sudah ditandai pada gambar, maka sangat mungkin bahwa sisi poligon akan sejajar dengan jalan. </li><li>  Jika poligon berpotongan, maka kemungkinan besar masuk akal untuk memindahkan dinding sehingga persimpangan menghilang. </li></ul><br>  Akibatnya, algoritma berikut ini muncul: <br><br><ol><li>  Kami mengelompokkan rumah-rumah yang ditemukan oleh jarak antara mereka dan sudut rotasi.  Kami rata-rata pergantian bangunan di setiap kluster.  Kami ulangi sampai posisi bangunan berhenti berubah atau sampai rumah mulai menyimpang terlalu banyak dari posisi awal. </li><li>  Kami memilih rumah di dekat jalan, kami menemukan yang terpanjang dan terdekat dengan sisi jalan.  Kami mengubah rumah ke paralelisme sisi yang dipilih dan jalan. </li><li>  Kami menghapus persimpangan antara poligon, menggeser sisi dua bangunan yang berpotongan secara proporsional dengan ukuran sisi. </li></ol><br><h2>  Hasil </h2><br>  Hasilnya, kami mendapat alat yang bisa mengenali bangunan dari berbagai jenis bangunan.  Ini membantu para kartografer dalam kerja keras mereka: mempercepat pencarian rumah yang hilang dan mengisi daerah baru yang belum diolah.  Saat ini, lebih dari 800 ribu objek baru telah ditambahkan ke Peta Orang menggunakan alat ini. <br><br>  Di bawah ini Anda akan melihat beberapa contoh pengakuan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bn/pk/o0/bnpko0puk1vcvnd1oxanqo7pvty.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nr/qi/q5/nrqiq5mdh2wl8fjaqmr28sn0oys.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xz/3a/iw/xz3aiwhlc_g1lo_huyb8yml_6ms.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rn/xz/e2/rnxze2-1b6bobojodppliybmehe.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jm/_j/cv/jm_jcvdv8pxm60tlwmoj2hmcgjc.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9x/k_/u3/9xk_u3nlc82ymdbtht8ebtbx6ue.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mw/zk/8g/mwzk8g2ga_798vg986flckxculo.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ue/37/gu/ue37gu16xwfvt3zqh0akmtmxnyi.jpeg"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id431108/">https://habr.com/ru/post/id431108/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id431096/index.html">Cara membuat produk bot obrolan</a></li>
<li><a href="../id431098/index.html">Bahkan kebakaran bukanlah halangan, atau Zimbra Speed ​​Recovery setelah bencana</a></li>
<li><a href="../id431102/index.html">Bagaimana alamat fisik ditampilkan dalam string DRAM dan bank</a></li>
<li><a href="../id431104/index.html">Bagaimana Kami di Neoflex Mengembangkan Keahlian DevOps</a></li>
<li><a href="../id431106/index.html">Berapa banyak uang yang dihabiskan orang Amerika Black Friday ini, dan apa hubungannya smartphone dengan itu?</a></li>
<li><a href="../id431110/index.html">Berhenti memberi makan penerbit. UE sedang mengembangkan aturan untuk akses gratis wajib untuk penelitian</a></li>
<li><a href="../id431112/index.html">Cara menggunakan metode kuadrat terkecil untuk mengevaluasi sumber daya dan memonitor database Oracle</a></li>
<li><a href="../id431116/index.html">Ingin aneh: ulasan tentang konferensi DartUP mendatang di St. Petersburg</a></li>
<li><a href="../id431118/index.html">Seluruh kebenaran tentang RTOS. Artikel # 22. Kotak Surat: Layanan Tambahan dan Struktur Data</a></li>
<li><a href="../id431120/index.html">Penderitaan di tempat kerja tidak perlu</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>