<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍💼 ✋🏿 ⬆️ Pemrograman JavaScript Asinkron (Panggilan Balik, Janji, RxJ) 🧒🏻 🙋🏻 🦏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya. Sentuhan Omelnitsky Sergey. Belum lama ini saya memimpin aliran pemrograman reaktif di mana saya berbicara tentang asinkron dalam JavaS...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pemrograman JavaScript Asinkron (Panggilan Balik, Janji, RxJ)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462355/"><p>  Halo semuanya.  Sentuhan Omelnitsky Sergey.  Belum lama ini saya memimpin aliran pemrograman reaktif di mana saya berbicara tentang asinkron dalam JavaScript.  Hari ini saya ingin menguraikan materi ini. </p><br><p><img src="https://habrastorage.org/webt/oq/x0/s1/oqx0s1ukuyf6izyu-5cxkd9cd-m.png"></p><br><p>  Tetapi sebelum kita memulai materi utama, kita perlu melakukan yang pengantar.  Jadi, mari kita mulai dengan definisi: apa tumpukan dan antrian? </p><br><p>  <strong>Tumpukan</strong> adalah kumpulan yang elemen-elemennya diterima dengan prinsip LIFO "last in, first out" </p><br><p>  <strong>Antrian</strong> adalah kumpulan yang unsur-unsurnya diterima sesuai dengan prinsip (FIFO pertama masuk, pertama keluar) </p><br><p>  Ok, mari kita lanjutkan. </p><br><p><img src="https://habrastorage.org/webt/xk/dt/rr/xkdtrrm0vasdzlva2iqgrpjmwuk.png"></p><br><p>  JavaScript adalah bahasa pemrograman single-threaded.  Ini berarti bahwa ia hanya memiliki satu utas eksekusi dan satu tumpukan di mana fungsi-fungsi di-antri untuk dieksekusi.  Oleh karena itu, pada satu titik waktu, JavaScript hanya dapat melakukan satu operasi, sementara operasi lain akan menunggu giliran mereka di stack hingga dipanggil. </p><a name="habracut"></a><br><p>  <strong>Tumpukan panggilan</strong> adalah struktur data yang, secara sederhana, mencatat informasi tentang tempat dalam program di mana kita berada.  Jika kita masuk ke suatu fungsi, kita mencatatnya di bagian atas tumpukan.  Ketika kita kembali dari fungsi, kita menarik elemen paling atas dari tumpukan dan menemukan diri kita dari mana kita memanggil fungsi ini.  Ini semua yang bisa dilakukan tumpukan.  Dan sekarang pertanyaan yang sangat menarik.  Lalu bagaimana cara kerja asinkron dalam JavasScript? </p><br><p><img src="https://habrastorage.org/webt/h2/-x/aj/h2-xajggqa9vcloczh7owhqiffc.png"></p><br><p>  Bahkan, selain stack, browser memiliki antrian khusus untuk bekerja dengan WebAPI.  Fungsi dari antrian ini akan dieksekusi hanya setelah tumpukan benar-benar dihapus.  Hanya setelah itu mereka didorong dari antrian ke tumpukan untuk dieksekusi.  Jika setidaknya satu elemen saat ini di tumpukan, maka mereka tidak bisa masuk ke tumpukan.  Justru karena ini fungsi panggilan oleh timeout sering tidak akurat dalam waktu, karena fungsi tidak dapat pergi dari antrian ke tumpukan saat penuh. </p><br><p>  Pertimbangkan contoh berikut dan lakukan "eksekusi" langkah demi langkah.  Lihat juga apa yang terjadi di sistem. </p><br><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hi'</span></span>); setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cb1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'cb1'</span></span>); }, <span class="hljs-number"><span class="hljs-number">5000</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Bye'</span></span>);</code> </pre> <br><p><img src="https://habrastorage.org/webt/tg/i-/xf/tgi-xfd5vxrjxltraxp4o7uhiki.png"></p><br><p>  1) Sejauh ini, tidak ada yang terjadi.  Konsol browser bersih, tumpukan panggilan kosong. </p><br><p><img src="https://habrastorage.org/webt/v4/et/uh/v4etuhvfo-eltv08fhxv1bqx1a0.png"></p><br><p>  2) Kemudian perintah console.log ('Hai') ditambahkan ke tumpukan panggilan. </p><br><p><img src="https://habrastorage.org/webt/ns/-k/-k/ns-k-klle5egqpwjdzbgxkrwaes.png"></p><br><p>  3) Dan itu dieksekusi </p><br><p><img src="https://habrastorage.org/webt/dp/oo/tz/dpootztdu0jjapitb1v60dzwdcu.png"></p><br><p>  4) Kemudian console.log ('Hai') dihapus dari tumpukan panggilan. </p><br><p><img src="https://habrastorage.org/webt/fu/yb/wb/fuybwb7kq0kcxdj4gobj38-r_fc.png"></p><br><p>  5) Sekarang buka perintah setTimeout (function cb1 () {...}).  Itu ditambahkan ke tumpukan panggilan. </p><br><p><img src="https://habrastorage.org/webt/85/ps/v2/85psv2_s7ec0ibxh8h2991nbxi4.png"></p><br><p>  6) Perintah setTimeout (function cb1 () {...}) dijalankan.  Browser membuat timer yang merupakan bagian dari Web API.  Dia akan melakukan hitung mundur. </p><br><p><img src="https://habrastorage.org/webt/3a/4p/sh/3a4pshoazrkbxfgcajwjqm1cz-m.png"></p><br><p>  7) Perintah setTimeout (fungsi cb1 () {...}) telah selesai dan dihapus dari tumpukan panggilan. </p><br><p><img src="https://habrastorage.org/webt/oe/qt/ne/oeqtnemv7rawkjpanipkv41qpeq.png"></p><br><p>  8) Perintah console.log ('Bye') ditambahkan ke tumpukan panggilan. </p><br><p><img src="https://habrastorage.org/webt/bb/mp/fb/bbmpfba1p2tadcztfm-41py_mgi.png"></p><br><p>  9) Perintah console.log ('Bye') dijalankan. </p><br><p><img src="https://habrastorage.org/webt/d0/ra/3z/d0ra3zfarz4ujmyy46cmsofs8ue.png"></p><br><p>  10) Perintah console.log ('Bye') dihapus dari tumpukan panggilan. </p><br><p><img src="https://habrastorage.org/webt/5y/by/dr/5ybydrdk6yuexhgyhbxwsvnkefa.png"></p><br><p>  11) Setelah setidaknya 5000 ms berlalu, timer keluar dan menempatkan callback cb1 dalam antrian callback. </p><br><p><img src="https://habrastorage.org/webt/sx/of/no/sxofnovn3xkkz5oyngnotdggpcs.png"></p><br><p>  12) Loop acara mengambil fungsi cb1 dari antrian panggilan balik dan menempatkannya di tumpukan panggilan. </p><br><p><img src="https://habrastorage.org/webt/ge/qp/1t/geqp1t65hnddi0hx0ut4b80ooi0.png"></p><br><p>  13) Fungsi cb1 dijalankan dan menambahkan console.log ('cb1') ke tumpukan panggilan. </p><br><p><img src="https://habrastorage.org/webt/xi/vq/ac/xivqac36m7yv79qocvstugftlb4.png"></p><br><p>  14) Perintah console.log ('cb1') dijalankan. </p><br><p><img src="https://habrastorage.org/webt/hp/tu/gk/hptugkn_5iizvyhez25bpf8zvpy.png"></p><br><p>  15) Perintah console.log ('cb1') dihapus dari tumpukan panggilan. </p><br><p><img src="https://habrastorage.org/webt/bh/wr/st/bhwrstroipmqqhrhiit4cmdy-we.png"></p><br><p>  16) Fungsi cb1 dihapus dari tumpukan panggilan. </p><br><p>  Lihatlah contoh dalam dinamika: </p><br><p><img src="https://habrastorage.org/webt/xx/nj/a8/xxnja8sfjhdg5ks3ku5q6yzkxvc.gif"></p><br><p>  Nah, di sini kita telah memeriksa bagaimana asinkron diimplementasikan dalam JavaScript.  Sekarang mari kita bicara secara singkat tentang evolusi kode asinkron. </p><br><h2 id="evolyuciya-asinhronnogo-koda">  Evolusi kode asinkron. </h2><br><pre> <code class="javascript hljs">a(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resultsFromA</span></span></span><span class="hljs-function">) </span></span>{ b(resultsFromA, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resultsFromB</span></span></span><span class="hljs-function">) </span></span>{ c(resultsFromB, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resultsFromC</span></span></span><span class="hljs-function">) </span></span>{ d(resultsFromC, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resultsFromD</span></span></span><span class="hljs-function">) </span></span>{ e(resultsFromD, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resultsFromE</span></span></span><span class="hljs-function">) </span></span>{ f(resultsFromE, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resultsFromF</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(resultsFromF); }) }) }) }) }) });</code> </pre> <br><p>  Pemrograman asinkron, seperti yang kita kenal dalam JavaScript, hanya dapat diimplementasikan dengan fungsi.  Mereka dapat diteruskan seperti variabel lain ke fungsi lainnya.  Jadi callback lahir.  Dan itu keren, menyenangkan dan provokatif, sampai berubah menjadi kesedihan, kerinduan dan kesedihan.  Mengapa  Ya, semuanya sederhana: </p><br><ul><li>  Dengan meningkatnya kompleksitas kode, proyek dengan cepat berubah menjadi blok berulang kali tersembunyi - "neraka panggilan balik". </li><li>  Penanganan kesalahan dapat dengan mudah dilewatkan. </li><li>  Anda tidak dapat mengembalikan ekspresi dengan return. </li></ul><br><p>  Dengan Janji, segalanya menjadi sedikit lebih baik. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">2000</span></span>); }).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { alert(result); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result + <span class="hljs-number"><span class="hljs-number">2</span></span>; }).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'FAILED HERE'</span></span>); alert(result); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result + <span class="hljs-number"><span class="hljs-number">2</span></span>; }).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { alert(result); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result + <span class="hljs-number"><span class="hljs-number">2</span></span>; }).catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'error: '</span></span>, e); });</code> </pre> <br><ul><li>  Rantai janji muncul, yang meningkatkan keterbacaan kode </li><li>  Metode perangkap kesalahan terpisah telah muncul </li><li>  Sekarang Anda dapat berjalan secara paralel menggunakan Promise.all </li><li>  Kita dapat memecahkan asynchrony bersarang dengan async / menunggu </li></ul><br><p>  Tetapi promis memiliki keterbatasan.  Misalnya, sebuah janji, tanpa menari dengan rebana, tidak dapat dibatalkan, dan yang terpenting, itu bekerja dengan satu nilai. </p><br><p>  Yah, kami dengan lancar mendekati pemrograman reaktif.  Apakah kamu lelah?  Nah, hal baiknya adalah Anda dapat membuat beberapa camar, memikirkan kembali dan kembali untuk membaca lebih lanjut.  Dan saya akan melanjutkan. </p><br><p><img src="https://habrastorage.org/webt/pj/0g/7b/pj0g7bgonkiefme08noahs3y0wc.png" alt="Dasar-Dasar Pemrograman Reaktif"></p><br><p>  <strong>Pemrograman reaktif</strong> adalah paradigma pemrograman yang berfokus pada aliran data dan penyebaran perubahan.  Mari kita lihat lebih dekat apa itu aliran data. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     const input = ducument.querySelector('input'); const eventsArray = []; //      eventsArray input.addEventListener('keyup', event =&gt; eventsArray.push(event) );</span></span></code> </pre> <br><p>  Bayangkan bahwa kita memiliki bidang input.  Kami membuat array, dan untuk setiap keyup acara input, kami akan menyimpan acara di array kami.  Dalam hal ini, saya ingin mencatat bahwa array kami diurutkan berdasarkan waktu yaitu  indeks peristiwa kemudian lebih besar dari indeks yang sebelumnya.  Array seperti itu adalah model aliran data yang disederhanakan, tetapi ini belum merupakan aliran.  Agar array ini dapat disebut stream dengan aman, ia harus entah bagaimana dapat memberi tahu pelanggan bahwa ia telah menerima data baru.  Jadi kita sampai pada definisi aliran. </p><br><h3 id="potok-dannyh">  Aliran data </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { interval } = Rx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { take } = RxOperators; interval(<span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( take(<span class="hljs-number"><span class="hljs-number">4</span></span>) )</code> </pre> <br><p><img src="https://habrastorage.org/webt/iu/oe/9k/iuoe9k_c75atoryyrxykddnhuzi.gif"></p><br><p>  <strong>Aliran</strong> adalah array data yang diurutkan berdasarkan waktu yang dapat menunjukkan bahwa data telah berubah.  Sekarang bayangkan betapa nyamannya menulis kode di mana Anda perlu memicu beberapa peristiwa di berbagai bagian kode dalam satu tindakan.  Kami hanya berlangganan aliran dan dia akan memberi tahu kami ketika perubahan terjadi.  Dan perpustakaan RxJ dapat melakukan ini. </p><br><p><img src="https://habrastorage.org/webt/2e/eg/cv/2eegcvxzcaz0j6x_n27h7nko68s.png"></p><br><p>  <strong>RxJS</strong> adalah perpustakaan untuk bekerja dengan program asinkron dan berbasis acara menggunakan urutan yang dapat diamati.  Perpustakaan menyediakan jenis utama dari <em>Observable</em> , beberapa jenis tambahan ( <em>Pengamat, Penjadwal, Subjek</em> ) dan operator yang bekerja dengan acara seperti dengan koleksi ( <em>peta, filter, pengurangan, setiap</em> dan sejenisnya dari JavaScript Array). </p><br><p>  Mari kita lihat konsep dasar perpustakaan ini. </p><br><h3 id="observable-observer-producer">  Diamati, Pengamat, Produser </h3><br><p>  Dapat diamati adalah tipe dasar pertama yang akan kita lihat.  Kelas ini berisi sebagian besar implementasi RxJs.  Ini dikaitkan dengan aliran yang dapat diamati, yang Anda dapat berlangganan menggunakan metode berlangganan. </p><br><p>  Observable mengimplementasikan mekanisme bantu untuk membuat pembaruan, yang disebut <em>Pengamat</em> .  Sumber nilai untuk Pengamat disebut <em>Produser</em> .  Ini bisa berupa array, iterator, soket web, semacam acara, dll.  Jadi kita dapat mengatakan bahwa yang dapat diamati adalah konduktor antara Produser dan Pengamat. </p><br><p>  Dapat diamati menangani tiga jenis peristiwa Pengamat: </p><br><ul><li>  selanjutnya - data baru </li><li>  kesalahan - kesalahan jika urutan berakhir karena pengecualian.  Acara ini juga melibatkan penyelesaian urutan. </li><li>  selesai - sinyal tentang penyelesaian urutan.  Ini berarti tidak akan ada data baru. </li></ul><br><p>  Mari kita lihat demo: </p><br><p><img src="https://habrastorage.org/webt/mg/qn/pf/mgqnpfxctqlz3yqwseag1fqttrc.gif"></p><br><p>  Pada awalnya kita akan memproses nilai 1, 2, 3, dan setelah 1 detik.  kita akan mendapatkan 4 dan mengakhiri aliran kita. </p><br><div class="spoiler">  <b class="spoiler_title">Pikiran di telinga</b> <div class="spoiler_text"><p>  Dan kemudian saya menyadari bahwa bercerita lebih menarik daripada menulis tentang itu.  : D </p></div></div><br><h3 id="subscription">  Berlangganan </h3><br><p>  Saat kami berlangganan aliran, kami membuat kelas <strong>berlangganan</strong> baru yang memungkinkan kami untuk berhenti berlangganan menggunakan metode <em>berhenti berlangganan</em> .  Kami juga dapat mengelompokkan langganan menggunakan metode <em>add</em> .  Yah, masuk akal bahwa kita dapat <em>memisahkan</em> thread dengan <em>menghapus</em> .  Metode input tambah dan hapus menerima langganan lain.  Saya ingin mencatat bahwa ketika kami berhenti berlangganan, kami berhenti berlangganan dari semua langganan anak seolah-olah mereka memanggil metode berhenti berlangganan.  Silakan. </p><br><h3 id="vidy-potokov">  Jenis aliran </h3><br><div class="scrollable-table"><table><thead><tr><th>  Panas </th><th>  DINGIN </th></tr></thead><tbody><tr><td>  Produser yang dibuat di luar dapat diamati </td><td>  Produser yang dibuat di dalam diamati </td></tr><tr><td>  Data ditransfer pada saat diamati diamati dibuat. </td><td>  Data dilaporkan pada saat berlangganan </td></tr><tr><td>  Perlu lebih banyak logika untuk berhenti berlangganan </td><td>  Utas berakhir dengan sendirinya </td></tr><tr><td>  Menggunakan komunikasi satu-ke-banyak </td><td>  Menggunakan hubungan satu-ke-satu </td></tr><tr><td>  Semua langganan memiliki nilai yang sama. </td><td>  Langganan bersifat independen </td></tr><tr><td>  Data dapat hilang jika tidak ada langganan </td><td>  Menerbitkan ulang semua nilai streaming untuk langganan baru </td></tr></tbody></table></div><br><p>  Sebagai analogi, saya membayangkan aliran panas seperti film di bioskop.  Pada titik waktu Anda datang, sejak saat itu dan mulai melihat.  Saya akan membandingkan aliran dingin dengan panggilan di dalamnya.  dukungan.  Setiap penelepon mendengarkan mesin penjawab dari awal hingga selesai, tetapi Anda dapat menutup telepon dengan berhenti berlangganan. </p><br><p>  Saya ingin mencatat bahwa masih ada yang disebut aliran hangat (definisi yang sangat jarang saya temui dan hanya di komunitas asing) - ini adalah aliran yang mengubah dari aliran dingin menjadi panas.  Timbul pertanyaan - di mana untuk menggunakan)) Saya akan memberikan contoh dari latihan. </p><br><p>  Saya bekerja dengan sudut.  Dia aktif menggunakan rxjs.  Untuk mendapatkan data ke server, saya mengharapkan aliran dingin dan saya menggunakan aliran ini di templat menggunakan asyncPipe.  Jika saya menggunakan pipa ini beberapa kali, maka, kembali ke definisi aliran dingin, setiap pipa akan meminta data dari server, yang aneh untuk sedikitnya.  Dan jika saya mengubah aliran dingin menjadi hangat, maka permintaan akan terjadi sekali. </p><br><p>  Secara umum, memahami bentuk arus cukup rumit untuk pemula, tetapi penting. </p><br><h3 id="operators">  Operator </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.http.get(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${environment.apiUrl}</span></span></span><span class="hljs-string">/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.apiUrl}</span></span></span><span class="hljs-string">/trade_companies`</span></span>) .pipe( tap(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ data }: TradeCompanyList</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.companies$$.next(cloneDeep(data))), map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ data }: TradeCompanyList</span></span></span><span class="hljs-function">) =&gt;</span></span> data) );</code> </pre> <br><p>  Operator memberi kami kemampuan untuk bekerja dengan stream.  Mereka membantu mengendalikan peristiwa yang terjadi di Observable.  Kami akan mempertimbangkan beberapa yang paling populer, dan operator dapat ditemukan lebih detail menggunakan tautan dalam informasi yang bermanfaat. </p><br><p>  <strong>Operator - dari</strong> </p><br><p>  Kami mulai dengan operator tambahan.  Itu menciptakan diamati berdasarkan nilai sederhana. </p><br><p><img src="https://habrastorage.org/webt/ty/gv/ns/tygvns2-ufljiud304keflcihtw.png"></p><br><p>  <strong>Operator - filter</strong> </p><br><p><img src="https://habrastorage.org/webt/lu/ej/-q/luej-qu433z2ascmvk4avc9qg80.png"></p><br><p>  Filter operator filter, sesuai namanya, menyaring sinyal aliran.  Jika operator mengembalikan nilai true, maka lompati lebih jauh. </p><br><p>  <strong>Operator - ambil</strong> </p><br><p><img src="https://habrastorage.org/webt/n3/h-/p7/n3h-p7dnsmlrus2qxcid1k-j0sc.png"></p><br><p>  take - Mengambil nilai jumlah emisi, setelah itu aliran berakhir. </p><br><p>  <strong>Operator - debounceTime</strong> </p><br><p><img src="https://habrastorage.org/webt/fm/-h/ov/fm-hovzqqm8setakpkxrq35220i.png"></p><br><p>  debounceTime - membuang nilai yang dipancarkan yang termasuk dalam periode waktu yang ditentukan antara data output - setelah selang waktu interval itu memancarkan nilai terakhir. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Observable } = Rx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { debounceTime, take } = RxOperators; Observable.create(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; observer.next(i++); <span class="hljs-comment"><span class="hljs-comment">//     1000 setInterval(() =&gt; { observer.next(i++) }, 1000); //     1500 setInterval(() =&gt; { observer.next(i++) }, 1500); }).pipe( debounceTime(700), //  700     take(3) );</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/wq/c4/is/wqc4is_4memtbjbseivewpqsm3y.gif"></p><br><p>  <strong>Operator - takeWhile</strong> </p><br><p><img src="https://habrastorage.org/webt/be/_4/bw/be_4bwupgcjmlqubh0bnjfwaq3o.png"></p><br><p>  Ini memancarkan nilai sampai takeWhile mengembalikan false, setelah itu akan berhenti berlangganan dari aliran. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Observable } = Rx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { debounceTime, takeWhile } = RxOperators; Observable.create(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; observer.next(i++); <span class="hljs-comment"><span class="hljs-comment">//     1000 setInterval(() =&gt; { observer.next(i++) }, 1000); }).pipe( takeWhile( producer =&gt; producer &lt; 5 ) );</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/fj/yx/ht/fjyxhtlst2zizvmv6uoei5vi_bm.gif"></p><br><p>  <strong>Operator - gabungkanLatest</strong> </p><br><p>  Operator CombateLatest agak mirip dengan janji.semua.  Ini menggabungkan beberapa utas menjadi satu.  Setelah setiap utas membuat setidaknya satu emisi, kita mendapatkan nilai terakhir dari masing-masing dalam bentuk array.  Selanjutnya, setelah memancarkan apa pun dari arus gabungan, itu akan memberikan nilai baru. </p><br><p><img src="https://habrastorage.org/webt/cg/lq/pj/cglqpjraurcow4xpusyfy-o-g1i.png"></p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { combineLatest, Observable } = Rx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { take } = RxOperators; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observer_1 = Observable.create(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     1000 setInterval(() =&gt; { observer.next('a: ' + i++); }, 1000); }); const observer_2 = Observable.create((observer) =&gt; { let i = 1; //     750 setInterval(() =&gt; { observer.next('b: ' + i++); }, 750); }); combineLatest(observer_1, observer_2).pipe(take(5));</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/lx/f6/qc/lxf6qcp3uqlpezwwxzipibko8mw.gif"></p><br><p>  <strong>Operator - zip</strong> </p><br><p>  Zip - menunggu nilai dari setiap aliran dan membentuk array berdasarkan nilai-nilai ini.  Jika nilai tidak berasal dari aliran apa pun, maka grup tidak akan terbentuk. </p><br><p><img src="https://habrastorage.org/webt/_w/uw/u5/_wuwu5ncu3ikb96iszphaeho1cu.png"></p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { zip, Observable } = Rx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { take } = RxOperators; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observer_1 = Observable.create(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     1000 setInterval(() =&gt; { observer.next('a: ' + i++); }, 1000); }); const observer_2 = Observable.create((observer) =&gt; { let i = 1; //     750 setInterval(() =&gt; { observer.next('b: ' + i++); }, 750); }); const observer_3 = Observable.create((observer) =&gt; { let i = 1; //     500 setInterval(() =&gt; { observer.next('c: ' + i++); }, 500); }); zip(observer_1, observer_2, observer_3).pipe(take(5));</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/lr/iz/k2/lrizk28md9flrpm-5nkiioxlbw0.gif"></p><br><p>  <strong>Operator - forkJoin</strong> </p><br><p>  forkJoin juga merangkai utas, tetapi hanya nilai saat semua utas selesai. </p><br><p><img src="https://habrastorage.org/webt/kg/yn/i8/kgyni8bmucerz2-o015i4fnrlrg.png"></p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { forkJoin, Observable } = Rx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { take } = RxOperators; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observer_1 = Observable.create(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     1000 setInterval(() =&gt; { observer.next('a: ' + i++); }, 1000); }).pipe(take(3)); const observer_2 = Observable.create((observer) =&gt; { let i = 1; //     750 setInterval(() =&gt; { observer.next('b: ' + i++); }, 750); }).pipe(take(5)); const observer_3 = Observable.create((observer) =&gt; { let i = 1; //     500 setInterval(() =&gt; { observer.next('c: ' + i++); }, 500); }).pipe(take(4)); forkJoin(observer_1, observer_2, observer_3);</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/34/ny/qn/34nyqnbve4g6gsheeoeaii1qkw0.gif"></p><br><p>  <strong>Operator - peta</strong> </p><br><p>  Operator transformasi peta mengkonversi nilai emisi ke yang baru. </p><br><p><img src="https://habrastorage.org/webt/z5/cq/gn/z5cqgnureeelbyknte8aohlkjyo.png"></p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Observable } = Rx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { take, map } = RxOperators; Observable.create(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     1000 setInterval(() =&gt; { observer.next(i++); }, 1000); }).pipe( map(x =&gt; x * 10), take(3) );</span></span></code> </pre><br><p><img src="https://habrastorage.org/webt/zy/fz/az/zyfzazyep10bcow9f1nxzumq8nk.gif"></p><br><p>  <strong>Operator - bagikan, ketuk</strong> </p><br><p>  Operator keran - memungkinkan Anda melakukan efek samping, yaitu tindakan apa pun yang tidak memengaruhi urutannya. </p><br><p>  Operator berbagi utilitas dapat membuatnya panas dari aliran dingin. </p><br><p><img src="https://habrastorage.org/webt/2p/lc/fr/2plcfr9agwst3elkl_yglmmfftk.png"></p><br><p>  Dengan operator selesai.  Mari beralih ke Subjek. </p><br><div class="spoiler">  <b class="spoiler_title">Pikiran di telinga</b> <div class="spoiler_text"><p>  Dan kemudian saya pergi minum beberapa burung camar.  Contoh-contoh ini membuat saya bosan: D </p></div></div><br><h2 id="semeystvo-subject-ov">  Keluarga subjek </h2><br><p>  Keluarga subjek adalah contoh utama dari aliran panas.  Kelas-kelas ini adalah jenis hibrida yang bertindak secara simultan sebagai pengamat dan pengamat.  Karena subjek adalah aliran panas, Anda harus berhenti berlangganan darinya.  Jika kita berbicara tentang metode dasar, maka ini: </p><br><ul><li>  selanjutnya - transfer data baru ke stream </li><li>  kesalahan - kesalahan dan penghentian aliran </li><li>  lengkap - penghentian aliran </li><li>  berlangganan - berlangganan aliran </li><li>  berhenti berlangganan - berhenti berlangganan dari aliran </li><li>  asObservable - berubah menjadi pengamat </li><li>  toPromise - berubah menjadi janji </li></ul><br><p>  Alokasikan <del>  4 </del>  5 jenis subjek. </p><br><div class="spoiler">  <b class="spoiler_title">Pikiran di telinga</b> <div class="spoiler_text"><p>  Dia berbicara di sungai 4, tetapi ternyata mereka menambahkan satu lagi.  Seperti kata pepatah, hidup dan belajar. </p></div></div><br><p>  Subjek Sederhana Subjek <code>new Subject()</code> adalah jenis subjek yang paling sederhana.  Itu dibuat tanpa parameter.  Melewati nilai yang datang hanya setelah berlangganan. </p><br><p>  BehaviorSubject <code>new BehaviorSubject( defaultData&lt;T&gt; )</code> - menurut saya jenis subjek yang paling umum.  Input menerima nilai default.  Itu selalu menyimpan data dari emisi terakhir, yang ditransfer saat berlangganan.  Kelas ini juga memiliki metode nilai berguna yang mengembalikan nilai arus stream. </p><br><p>  ReplaySubject <code>new ReplaySubject(bufferSize?: number, windowTime?: number)</code> - Input opsional dapat menerima argumen pertama sebagai ukuran buffer nilai yang akan disimpan dalam dirinya sendiri, dan kedua kalinya selama yang kita perlu perubahan. </p><br><p>  AsyncSubject <code>new AsyncSubject()</code> - tidak ada yang terjadi ketika berlangganan, dan nilai akan dikembalikan hanya setelah selesai.  Hanya nilai streaming terakhir yang akan dikembalikan. </p><br><p>  WebSocketSubject WebSocketSubject <code>new WebSocketSubject(urlConfigOrSource: string | WebSocketSubjectConfig&lt;T&gt; | Observable&lt;T&gt;, destination?: Observer&lt;T&gt;)</code> - Dokumentasi diam tentang hal itu dan saya melihatnya untuk pertama kali.  Siapa yang tahu apa yang dia lakukan, tulis, tambah. </p><br><p>  Fuf.  Nah, di sini kita telah mempertimbangkan semua yang ingin saya sampaikan hari ini.  Saya harap informasi ini bermanfaat.  Anda dapat membiasakan diri dengan daftar referensi di tab informasi yang berguna. </p><br><h2 id="poleznaya-informaciya">  Informasi yang Berguna </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Stream Link</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara Kerja JS: Tinjauan umum mesin, mekanisme runtime, panggilan stack</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara Kerja JS: Event Loop, Async, dan Five Ways untuk Meningkatkan Kode Menggunakan async / tunggu</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana Event Loop Bekerja di JavaSript</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Evolusi JavaScript Asinkron</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa itu RxJS dan mengapa bermanfaat untuk mengetahuinya?</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><br></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aplikasi Praktis RxJS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RxJS Observables Tutorial - Membuat &amp; Berlangganan Observable</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RXJS: Observasi Panas dan Dingin</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kelas, fungsi untuk membuat Observable.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Operator</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Operator RxJS Dengan Contoh</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Daftar API</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Varietas Subjek dan Jadwal di RxJS</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462355/">https://habr.com/ru/post/id462355/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462337/index.html">Statistik situs dan repositori kecil Anda</a></li>
<li><a href="../id462339/index.html">Bagaimana pelatihan genggam terkait dengan standar internal Amazon dan bagaimana pengaruhnya terhadap pandangan dunia perusahaan?</a></li>
<li><a href="../id462347/index.html">Sepuluh hari pertama dalam perjalanan dari burung hantu ke burung awal: tidur, diet, diet dan olahraga</a></li>
<li><a href="../id462349/index.html">RESTinio adalah server HTTP asinkron. Contoh sederhana dari praktik: mengembalikan sejumlah besar data sebagai respons</a></li>
<li><a href="../id462353/index.html">FAQ Keamanan Protokol LoRaWAN</a></li>
<li><a href="../id462357/index.html">Prototipe pertama: Unikern sebagai tahap dalam evolusi Linux</a></li>
<li><a href="../id462359/index.html">Dat - protokol apa itu dan siapa yang menggunakannya</a></li>
<li><a href="../id462365/index.html">Keterbatasan Pembelajaran Mesin</a></li>
<li><a href="../id462367/index.html">13 fakta tentang kapitalisme ventura bagi para pendiri</a></li>
<li><a href="../id462371/index.html">Mulai Spring StateMachine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>