<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö£üèª üêÅ üèÆ CreateRemoteThread f√ºr Linux üïµüèª üåª üë©üèΩ‚Äçüîß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="WinAPI verf√ºgt √ºber eine CreateRemoteThread- Funktion, mit der Sie einen neuen Thread im Adressraum eines anderen Prozesses starten k√∂nnen. Es kann f√º...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>CreateRemoteThread f√ºr Linux</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473740/"><p><img src="https://habrastorage.org/webt/qu/fi/43/qufi43ym9g9-ptbmm43ajv-e_-4.jpeg" width="300" align="right" alt="Mitsuha bringt neue Streams">  WinAPI verf√ºgt √ºber eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">CreateRemoteThread-</a> Funktion, mit der Sie einen neuen Thread im Adressraum eines anderen Prozesses starten k√∂nnen.  Es kann f√ºr eine Vielzahl von DLL-Injektionen verwendet werden, sowohl f√ºr schlechte Zwecke (Cheats in Spielen, Passwortdiebstahl usw.) als auch, um einen Fehler in einem laufenden Programm im laufenden Betrieb zu beheben oder Plugins an Stellen hinzuzuf√ºgen, an denen dies nicht der Fall war zur Verf√ºgung gestellt. </p><br><p>  Im Allgemeinen hat diese Funktion ein zweifelhaftes Anwendungsdienstprogramm, daher ist es nicht verwunderlich, dass Linux kein fertiges Analogon zu CreateRemoteThread hat.  Ich habe mich jedoch gefragt, wie es implementiert werden kann.  Das Studium des Themas wurde zu einem guten Abenteuer. </p><br><p>  Ich werde im Detail dar√ºber sprechen, wie mit Hilfe der ELF-Spezifikation, einigen Kenntnissen der x86_64-Architektur und Linux-Systemaufrufen Ihr eigener kleiner Debugger geschrieben wird, der beliebigen Code in einem bereits laufenden und funktionierenden Prozess laden und ausf√ºhren kann. </p><br><p>  Zum Verst√§ndnis des Textes sind Grundkenntnisse √ºber die Systemprogrammierung f√ºr Linux erforderlich: die C-Sprache, das Schreiben und Debuggen von Programmen, das Verst√§ndnis der Rolle von Maschinencode und Speicher im Computer, das Konzept von Systemaufrufen, die Kenntnis der Hauptbibliotheken und das Lesen der Dokumentation. </p><a name="habracut"></a><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hauptideen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">L√∂sungsskizze</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schritt 1. Verbindung zum Prozess</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schritt 2. Suchen Sie nach Bibliotheken im Speicher</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schritt 3. Analysieren von ELF-Bibliotheksbildern</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schritt 4. Implementieren des Shellcodes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schritt 5. Starten Sie einen neuen Thread</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fazit</a> </li></ul><br><p>  Infolgedessen konnte ich die M√∂glichkeit zur Vorschau von Kennw√∂rtern im Gnome Control Center hinzuf√ºgen: </p><br><p><img src="https://habrastorage.org/webt/0v/gu/we/0vguwedoumnnjh89zw5jtpaaltw.gif" alt="Injektionsdemonstration im Gnome Control Center"></p><br><h2 id="osnovnye-idei">  Hauptideen </h2><br><p>  Wenn die Anforderungen zum Laden des Codes in einen bereits laufenden Prozess keine Klausel enthalten w√ºrden, w√§re die L√∂sung √§u√üerst einfach: LD_PRELOAD.  Diese Umgebungsvariable erm√∂glicht das Laden einer beliebigen Bibliothek mit der Anwendung.  In gemeinsam genutzten Bibliotheken k√∂nnen Sie <em>Konstruktorfunktionen</em> definieren, die beim Laden der Bibliothek ausgef√ºhrt werden. </p><br><p>  Zusammen erm√∂glichen LD_PRELOAD und die Konstruktoren die Ausf√ºhrung von beliebigem Code in jedem Prozess unter Verwendung eines dynamischen Loaders.  Dies ist eine relativ bekannte Funktion, die h√§ufig zum Debuggen verwendet wird.  Sie k√∂nnen beispielsweise Ihre eigene Bibliothek mit der Anwendung herunterladen, die die Funktionen malloc () und free () definiert, um Speicherlecks zu erkennen. </p><br><p>  Leider funktioniert LD_PRELOAD nur, wenn der Prozess startet.  Es kann nicht zum Laden einer Bibliothek in einen bereits laufenden Prozess verwendet werden.  Es gibt eine dlopen () -Funktion zum Laden von Bibliotheken, w√§hrend der Prozess ausgef√ºhrt wird, aber nat√ºrlich muss der Prozess sie selbst aufrufen, um die Plugins zu laden. </p><br><blockquote> <strong>√úber statische ausf√ºhrbare Dateien</strong> <br><br>  LD_PRELOAD funktioniert nur mit Programmen, die den dynamischen Loader verwenden.  Wenn das Programm mit dem Schalter <code>-static</code> , enth√§lt es alle erforderlichen Bibliotheken.  In diesem Fall wird die Aufl√∂sung von Abh√§ngigkeiten in Bibliotheken zur Erstellungszeit durchgef√ºhrt, und das Programm ist normalerweise nicht bereit und kann Bibliotheken nach der Assemblierung zur Laufzeit nicht dynamisch laden. <br><br>  In statisch zusammengestellten Programmen k√∂nnen Sie Code zur Laufzeit einbetten, dies sollte jedoch auf etwas andere Weise erfolgen.  Und dies ist nicht ganz sicher, da das Programm m√∂glicherweise nicht f√ºr eine solche Wende bereit ist. </blockquote><p>  Im Allgemeinen gibt es keine vorgefertigte bequeme L√∂sung, Sie m√ºssen Ihr Fahrrad schreiben.  Andernfalls w√ºrden Sie diesen Text nicht lesen :) </p><br><p>  Um den Prozess eines anderen zur Ausf√ºhrung eines Codes zu zwingen, m√ºssen Sie konzeptionell die folgenden Aktionen ausf√ºhren: </p><br><ol><li>  Holen Sie sich die Kontrolle √ºber den Zielprozess. </li><li>  Laden Sie den Code in den Speicher des Zielprozesses. </li><li>  Bereiten Sie den heruntergeladenen Code f√ºr die Ausf√ºhrung im Zielprozess vor. </li><li>  Organisieren Sie die Ausf√ºhrung des heruntergeladenen Codes durch den Zielprozess. </li></ol><br><p>  Lass uns gehen ... </p><br><h3 id="poluchenie-upravleniya-v-processe">  Kontrolle bekommen </h3><br><p>  Zun√§chst m√ºssen wir den Zielprozess unserem Willen unterordnen.  Schlie√ülich f√ºhren Prozesse normalerweise nur ihren eigenen Code oder den Code geladener Bibliotheken oder die Ergebnisse der JIT-Kompilierung aus.  Aber sicher nicht unser Code. </p><br><p>  Eine M√∂glichkeit besteht darin, eine Art Sicherheitsl√ºcke in dem Prozess zu verwenden, mit der Sie die Kontrolle √ºbernehmen k√∂nnen.  Ein klassisches Beispiel aus Tutorials: Puffer√ºberlauf, mit dem die R√ºcksprungadresse auf dem Stapel neu geschrieben werden kann.  Es macht Spa√ü, funktioniert manchmal sogar, ist aber nicht f√ºr den allgemeinen Fall geeignet. </p><br><p>  Wir werden einen anderen, ehrlichen Weg einschlagen, um die Kontrolle zu erlangen: das <em>Debuggen von Systemaufrufen</em> .  Interaktive Debugger k√∂nnen Prozesse von Drittanbietern perfekt stoppen, Ausdr√ºcke auswerten und viele andere Dinge.  Sie k√∂nnen - wir k√∂nnen. </p><br><p>  Unter Linux ist der Hauptaufruf des Debugging-Systems <strong>ptrace ()</strong> .  Sie k√∂nnen eine Verbindung zu Prozessen herstellen, deren Status √ºberpr√ºfen und den Fortschritt ihrer Ausf√ºhrung steuern.  ptrace () ist f√ºr sich genommen ziemlich gut dokumentiert, aber die Details seiner Verwendung sind nur in der Praxis klar. </p><br><h3 id="zagruzka-koda-v-pamyat-processa">  Laden von Code in den Prozessspeicher </h3><br><p>  Bei Puffer√ºberl√§ufen ist die Nutzlast ( <em>Shell-Code</em> ) normalerweise in den Inhalten enthalten, die denselben Puffer √ºberlaufen.  Bei Verwendung des Debuggers kann der erforderliche Code direkt in den Prozessspeicher geschrieben werden.  In WinAPI gibt es hierf√ºr eine spezielle Funktion WriteProcessMemory.  Linux entspricht zu diesem Zweck der UNIX-Methode: F√ºr jeden Prozess im System gibt es eine Datei <strong>/ proc / $ pid / mem</strong> , die den Speicher dieses Prozesses anzeigt.  Es ist m√∂glich, mit der √ºblichen Eingabe / Ausgabe etwas in den Prozessspeicher zu schreiben. </p><br><h3 id="podgotovka-koda-k-ispolneniyu">  Code f√ºr die Ausf√ºhrung vorbereiten </h3><br><p>  Nur Code in den Speicher zu schreiben, reicht nicht aus.  Es muss noch <em>in den ausf√ºhrbaren Speicher geschrieben werden</em> .  Bei der Aufzeichnung √ºber eine Sicherheitsanf√§lligkeit gibt es nicht triviale Schwierigkeiten, aber da wir den Zielprozess vollst√§ndig steuern k√∂nnen, ist es f√ºr uns kein Problem, den ‚Äûrichtigen‚Äú Speicher f√ºr uns selbst zu finden oder zuzuweisen. </p><br><p>  Ein weiterer wichtiger Punkt bei der Vorbereitung ist der Shell-Code selbst.  Darin werden wir wahrscheinlich einige Funktionen aus Bibliotheken verwenden wollen, wie Eingabe-Ausgabe, grafische Grundelemente und so weiter.  Wir m√ºssen jedoch nackten Maschinencode aufschreiben, der an sich keine Ahnung von den Adressen all dieser coolen Funktionen in Bibliotheken hat.  Woher bekommen Sie sie? </p><br><p>  Um die Lebensdauer des Betriebssystems zu vereinfachen und die Lebensdauer von Schadcode zu verkomplizieren, verwenden Bibliotheken normalerweise keine festen Adressen (und enthalten sogenannten <em>positionsunabh√§ngigen Code</em> ).  Die Adressen k√∂nnen also nicht erraten werden. </p><br><p>  Wenn der Prozess normal startet, ist der <em>Loader</em> , der die <em>Verschiebungen durchf√ºhrt</em> , f√ºr die Ermittlung der genauen Adressen der Bibliotheken verantwortlich.  Allerdings erf√ºllt er zu Beginn nur einmal.  Wenn der Prozess das dynamische Laden von Bibliotheken erm√∂glicht, befindet sich ein <em>dynamischer Loader</em> darin, der dasselbe tun kann, w√§hrend der Prozess ausgef√ºhrt wird.  Die Adresse des dynamischen Laders ist jedoch ebenfalls nicht festgelegt. </p><br><p>  Bei Bibliotheken gibt es im Allgemeinen vier Optionen: </p><br><ul><li>  Verwenden Sie √ºberhaupt keine Bibliotheken, machen Sie alles bei sauberen Systemaufrufen </li><li>  F√ºgen Sie Kopien aller erforderlichen Bibliotheken in den Shell-Code ein </li><li>  erledigen Sie die Arbeit des dynamischen Laders selbst </li><li>  Finden Sie einen dynamischen Bootloader und lassen Sie ihn unsere Bibliotheken laden </li></ul><br><p>  Wir werden uns f√ºr Letzteres entscheiden, weil wir die Bibliotheken wollen und unseren vollst√§ndigen Bootloader f√ºr eine lange Zeit schreiben.  Dies ist nicht die geheimste Methode und nicht die interessanteste, sondern die einfachste, leistungsf√§higste und zuverl√§ssigste. </p><br><h3 id="peredacha-upravleniya-kodu">  √úbertragung der Kontrolle auf den Code </h3><br><p>  Mit ptrace () k√∂nnen Sie die Prozessorregister √§ndern, sodass es keine Probleme bei der √úbertragung der Steuerung auf den geladenen und vorbereiteten Code geben sollte: Schreiben Sie einfach die Adresse unseres Codes in das% rip-Register - und voila!  In Wirklichkeit ist jedoch nicht alles so einfach.  Die Schwierigkeiten h√§ngen mit der Tatsache zusammen, dass der debuggte Prozess tats√§chlich nicht verschwunden ist und dass auch eine Art Code ausgef√ºhrt wurde und weiterhin ausgef√ºhrt wird. </p><br><h2 id="eskiz-resheniya">  L√∂sungsskizze </h2><br><p>  Insgesamt werden wir unseren Ablauf in einem Drittanbieterprozess wie folgt implementieren: </p><br><ol><li>  Wir sind mit dem Zielprozess f√ºr das Debuggen verbunden. </li><li>  Wir finden die notwendigen Bibliotheken im Speicher: <br><ul><li>  libdl - um eine neue Bibliothek zu laden </li><li>  libpthread - um einen neuen Thread zu starten </li></ul></li><li>  Die notwendigen Funktionen finden wir in den Bibliotheken: <br><ul><li>  libdl: dlopen (), dlsym () </li><li>  libpthread: pthread_create (), pthread_detach () </li></ul></li><li><p>  Wir f√ºhren den Shell-Code in den Speicher des Zielprozesses ein: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *payload = dlopen(<span class="hljs-string"><span class="hljs-string">"/path/to/payload.so"</span></span>, RTLD_LAZY); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *entry = dlsym(payload, <span class="hljs-string"><span class="hljs-string">"entry_point"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">pthread_t</span></span> thread; pthread_create(&amp;thread, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, entry, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); pthread_detach(thread); }</code> </pre> <br></li><li>  Wir geben den zu erf√ºllenden Shell-Code an. </li></ol><br><p>  Infolgedessen werden Bibliotheken das Richtige f√ºr uns tun: Sie laden unsere Bibliothek mit dem Code, den wir im Speicher ben√∂tigen, und starten einen neuen Thread, der diesen Code ausf√ºhrt. </p><br><h3 id="ogranicheniya">  Einschr√§nkungen </h3><br><p>  Der oben beschriebene Ansatz bringt bestimmte Einschr√§nkungen mit sich: </p><br><ul><li>  Der Bootloader muss √ºber ausreichende Berechtigungen verf√ºgen, um den Zielprozess zu debuggen. </li><li>  Der Prozess sollte libdl verwenden (bereit zum dynamischen Laden von Modulen). </li><li>  Der Prozess sollte libpthread verwenden (bereit f√ºr Multithreading). </li><li>  Statische Anwendungen werden nicht unterst√ºtzt. </li></ul><br><p>  Au√üerdem bin ich pers√∂nlich zu faul, um mich mit der Unterst√ºtzung von All-All-Architekturen zu besch√§ftigen, sodass wir uns auf x86_64 beschr√§nken werden.  (Sogar ein 32-Bit x86 w√§re komplizierter.) </p><br><p>  Wie Sie sehen, macht all dies der verdeckten Verwendung mit b√∂swilligen Zielen ein Ende.  Die Aufgabe beh√§lt jedoch weiterhin das Forschungsinteresse und l√§sst sogar eine schwache Chance f√ºr die industrielle Nutzung. </p><br><h3 id="otstuplenie-ob-ispolzovanii-libdl-i-libpthread">  Exkurs: √ºber die Verwendung von libdl und libpthread </h3><br><p>  Ein erfahrener professioneller Leser mag sich fragen: Warum sollte libdl ben√∂tigt werden, wenn die internen Funktionen __libc_dlopen_mode () und __libc_dlsym () bereits in glibc integriert sind und libdl nur ein Wrapper dar√ºber ist?  Warum sollte libpthread ebenfalls ben√∂tigt werden, wenn mit dem Systemaufruf clone () einfach ein neuer Thread erstellt werden kann? </p><br><p>  In der Tat gibt es im Internet bei weitem kein Beispiel daf√ºr, wie sie verwendet werden: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">https://github.com/gaffe23/linux-inject</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">https://github.com/TsarFox/hypodermic</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">http://hick.org/code/skape/papers/needle.txt</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">https://github.com/ice799/injectso64</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">http://www.ouah.org/subversiveld.pdf</a> </li></ul><br><p>  Sie werden sogar in der popul√§ren Hackerliteratur erw√§hnt: </p><br><ul><li>  Lernen der bin√§ren Linux-Analyse </li><li>  Die Kunst der Ged√§chtnisforensik </li></ul><br><p>  Warum also nicht?  Zumindest, weil wir keinen Schadcode schreiben, bei dem eine L√∂sung geeignet ist, die 90% der √úberpr√ºfungen ausl√§sst, 20-mal weniger Speicherplatz beansprucht, aber auch in 80% der F√§lle funktioniert.  Au√üerdem wollte ich alles mit meinen eigenen H√§nden ausprobieren. </p><br><p>  In der Tat ist libdl nicht <em>erforderlich</em> , um die Bibliothek im Fall von glibc zu laden.  Die Verwendung durch den Prozess zeigt an, dass es eindeutig zum dynamischen Laden von Code bereit ist.  Trotzdem k√∂nnen Sie die Verwendung von libdl grunds√§tzlich ablehnen (da wir sp√§ter auch noch nach glibc suchen m√ºssen). </p><br><blockquote>  <strong>Warum √ºberhaupt dlopen () in glibc?</strong> <br><br>  Dies ist auf ihre Weise eine interessante Frage.  Kurze Antwort: Implementierungsdetails. <br><br>  Dies ist eine Frage des <em>Name Service Switch</em> (NSS) - einer der Teile von glibc, der die √úbersetzung verschiedener Namen erm√∂glicht: Namen von Maschinen, Protokollen, Benutzern, Mailservern usw. Sie ist f√ºr Funktionen wie getaddrinfo () verantwortlich, √ºber die IP-Adressen abgerufen werden Dom√§nenname und getpwuid (), um Informationen √ºber den Benutzer anhand seiner numerischen Kennung abzurufen. <br><br>  NSS hat eine modulare Architektur und Module werden dynamisch geladen.  Tats√§chlich ben√∂tigte glibc daf√ºr auch Mechanismen zum dynamischen Laden von Bibliotheken.  Wenn Sie versuchen, getaddrinfo () in einer statisch zusammengestellten Anwendung zu verwenden, gibt der Linker daher eine "unverst√§ndliche" Warnung aus: <br><pre>
 /tmp/build/socket.o: In der Funktion `Socket :: bind ':
 socket.o :(. text + 0x374): Warnung: Verwenden von 'getaddrinfo' in statisch verkn√ºpften
 Anwendungen ben√∂tigen zur Laufzeit die gemeinsam genutzten Bibliotheken aus der glibc-Version
 zum Verkn√ºpfen verwendet
</pre><br></blockquote><p>  Bei Threads ist ein Thread normalerweise nicht nur ein Stapel und ausf√ºhrbarer Code, sondern auch globale Daten, die im <em>Thread-Local Storage</em> (TLS) gespeichert sind.  Die korrekte Initialisierung eines neuen Threads erfordert den koordinierten Betrieb des Betriebssystemkerns, eines Bin√§rcode-Laders und einer Programmiersprachen-Laufzeit.  Daher reicht ein einfacher Aufruf von clone () aus, um einen Stream zu erstellen, der in die Datei ‚ÄûHello world!‚Äú Schreiben kann. Dies funktioniert jedoch m√∂glicherweise nicht f√ºr komplexeren Code, der Zugriff auf TLS und andere interessante Dinge ben√∂tigt, die vor den Augen des Anwendungsprogrammierers verborgen sind. </p><br><p>  Ein weiterer Punkt im Zusammenhang mit Multithreading sind Single-Thread-Prozesse.  Was passiert, wenn wir in einem Prozess, der nicht als Multithreading konzipiert wurde, einen neuen Thread erstellen?  Richtig, vages Verhalten.  In der Tat gibt es dabei keine Synchronisation der Arbeit zwischen Threads, was fr√ºher oder sp√§ter zu einer Besch√§digung der Daten f√ºhren wird.  Wenn wir verlangen, dass die Anwendung libpthread verwendet, k√∂nnen wir sicher sein, dass sie in einer Multithread-Umgebung einsatzbereit ist (zumindest sollte sie bereit sein). </p><br><h2 id="shag-1-podklyuchenie-k-processu">  Schritt 1. Verbindung zum Prozess </h2><br><p>  Zuerst m√ºssen wir zum Debuggen eine Verbindung zum Zielprozess herstellen und sp√§ter die Verbindung wieder trennen.  Hier kommt der <em>Systemaufruf ptrace</em> () ins <em>Spiel</em> . </p><br><h3 id="pervyy-kontakt-s-ptrace">  Erster Kontakt mit ptrace () </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">In der Dokumentation zu ptrace ()</a> finden Sie fast alle notwendigen Informationen: </p><br><pre>   Anbringen und Abnehmen
        Mit dem Aufruf kann ein Thread an den Tracer angeh√§ngt werden<font></font>
<font></font>
            ptrace (PTRACE_ATTACH, pid, 0, 0);<font></font>
<font></font>
        oder<font></font>
<font></font>
            ptrace (PTRACE_SEIZE, pid, 0, PTRACE_O_flags);<font></font>
<font></font>
        PTRACE_ATTACH sendet SIGSTOP an diesen Thread.  Wenn der Tracer das will
        SIGSTOP hat keine Wirkung, es muss unterdr√ºckt werden.  Beachten Sie, dass wenn
        W√§hrend des Anh√§ngens werden gleichzeitig andere Signale an diesen Thread gesendet
        Der Tracer kann sehen, dass der Tracee mit einem anderen Signal in den Signal-Delivery-Stop eintritt
        nal (s) zuerst!  Die √ºbliche Praxis besteht darin, diese Signale bis erneut zu injizieren
        SIGSTOP wird angezeigt, dann wird die SIGSTOP-Injektion unterdr√ºckt.  Der Designfehler
        Hier ist, dass ein Ptrace Attach und ein gleichzeitig gelieferter SIGSTOP k√∂nnen
        Rennen und der gleichzeitige SIGSTOP k√∂nnen verloren gehen.
</pre><br><p>  Der erste Schritt ist also die Verwendung von PTRACE_ATTACH: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ptrace_attach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_ATTACH, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wait_for_process_stop(pid, SIGSTOP) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  Nach ptrace () ist der Zielprozess noch nicht zum Debuggen bereit.  Wir haben uns damit verbunden, aber f√ºr eine interaktive Untersuchung des Zustands des Prozesses muss es gestoppt werden.  ptrace () sendet ein SIGSTOP-Signal an den Prozess, aber wir m√ºssen noch warten, bis der Prozess tats√§chlich stoppt. </p><br><p>  Verwenden <em>Sie</em> zum Warten den <em>Systemaufruf waitpid</em> ().  Gleichzeitig sind einige interessante Grenzf√§lle erw√§hnenswert.  Erstens kann der Prozess einfach enden oder sterben, ohne SIGSTOP erhalten zu haben.  In diesem Fall k√∂nnen wir nichts tun.  Zweitens kann zuvor ein anderes Signal an den Prozess gesendet werden.  In diesem Fall sollten wir den Prozess es verarbeiten lassen (mit PTRACE_CONT) und uns selbst weiter auf unser SIGSTOP warten: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_for_process_stop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> expected_signal)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> status = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* ,    -  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (waitpid(pid, &amp;status, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*      ‚Äî   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WIFSIGNALED(status) || WIFEXITED(status)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   ,     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WIFSTOPPED(status)) { <span class="hljs-comment"><span class="hljs-comment">/* *  WSTOPSIG()   , *   ptrace()   *     . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stop_signal = status &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    ,    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stop_signal == expected_signal) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*        */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_CONT, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, stop_signal) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*   ‚Äî   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h3 id="otklyuchenie-ot-processa">  Prozessabschaltung </h3><br><p>  Das Stoppen des Debugging-Prozesses ist viel einfacher: Verwenden Sie einfach PTRACE_DETACH: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ptrace_detach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_DETACH, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  Genau genommen ist es nicht immer erforderlich, den Debugger explizit zu deaktivieren.  Wenn der Debugger-Prozess endet, wird die Verbindung zu allen debuggten Prozessen automatisch getrennt, und die Prozesse werden fortgesetzt, wenn sie von ptrace () gestoppt wurden.  Wenn der Debugging-Prozess jedoch vom Debugger mithilfe des SIGSTOP-Signals ohne Verwendung von ptrace () explizit gestoppt wurde, wird er ohne das entsprechende SIGCONT- oder PTRACE_DETACH-Signal nicht aktiviert.  Daher ist es besser, sich kulturell von Prozessen zu trennen. </p><br><h3 id="nastroyka-ptrace_scope">  Ptrace_scope-Einstellung </h3><br><p>  Der Debugger hat die volle Kontrolle √ºber den zu debuggenden Prozess.  Wenn jemand irgendetwas debuggen k√∂nnte, was w√§re die Weite f√ºr b√∂sartigen Code!  Es ist offensichtlich, dass interaktives Debuggen eine ziemlich spezifische Aktivit√§t ist, die normalerweise nur f√ºr Entwickler erforderlich ist.  W√§hrend des normalen Betriebs des Systems besteht meistens keine Notwendigkeit, Prozesse zu debuggen. </p><br><p>  Aus diesen Gr√ºnden deaktivieren Systeme aus Sicherheitsgr√ºnden normalerweise die M√∂glichkeit, alle Prozesse standardm√§√üig zu debuggen.  Verantwortlich daf√ºr ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><strong>Yama-</strong> Sicherheitsmodul</a> , das √ºber die Datei / proc / sys / kernel / yama / ptrace_scope verwaltet wird.  Es bietet vier Verhaltensweisen: </p><br><ul><li>  0 - Der Benutzer kann alle von ihm gestarteten Prozesse debuggen </li><li>  1 - Standardmodus, nur vom Debugger gestartete Prozesse k√∂nnen debuggt werden </li><li>  2 - Nur ein Root-Systemadministrator kann Prozesse debuggen </li><li>  3 - Das Debuggen ist f√ºr alle Personen verboten. Der Modus wird erst nach einem Neustart des Systems ausgeschaltet </li></ul><br><p>  F√ºr unsere Zwecke m√ºssen Sie nat√ºrlich in der Lage sein, Prozesse zu debuggen, die vor unserem Debugger gestartet wurden. F√ºr Experimente m√ºssen Sie entweder das System in den Entwicklungsmodus schalten, indem Sie 0 in eine spezielle ptrace_scope-Datei schreiben (f√ºr die Administratorrechte erforderlich sind): </p><br><pre> <code class="plaintext hljs">$ sudo sh -c 'echo 0 &gt; /proc/sys/kernel/yama/ptrace_scope'</code> </pre> <br><p>  oder f√ºhren Sie den Debugger als Administrator aus: </p><br><pre> <code class="plaintext hljs">$ sudo ./inject-thread ...</code> </pre> <br><h3 id="rezultaty-pervogo-shaga">  Ergebnisse des ersten Schritts </h3><br><p>  Auf diese Weise k√∂nnen wir im ersten Schritt als Debugger eine Verbindung zum Zielprozess herstellen und sp√§ter die Verbindung zu diesem trennen. </p><br><p>  Der Zielprozess wird gestoppt und wir k√∂nnen sicherstellen, dass das Betriebssystem uns wirklich als Debugger sieht: </p><br><pre> <code class="plaintext hljs">$ sudo ./inject-thread --target $(pgrep docker) $ cat /proc/$(pgrep docker)/status | head Name: docker State: t (tracing stop) &lt;---    Tgid: 31330 Ngid: 0 Pid: 31330 PPid: 1 TracerPid: 2789 &lt;--- PID   Uid: 0 0 0 0 Gid: 0 0 0 0 FDSize: 64 $ ps a | grep [2]789 2789 pts/5 S+ 0:00 ./inject-thread --target 31330</code> </pre> <br><h2 id="shag-2-poisk-bibliotek-v-pamyati">  Schritt 2. Suchen Sie nach Bibliotheken im Speicher </h2><br><p>  Der n√§chste Schritt ist einfacher: Sie m√ºssen im Speicher des Zielprozesses die Bibliothek mit den Funktionen finden, die wir ben√∂tigen.  Aber es gibt viel Ged√§chtnis, wo man anfangen soll und was genau? </p><br><h3 id="fayl-procpidmaps">  Datei / proc / $ pid / maps </h3><br><p>  Eine spezielle Datei hilft uns dabei, durch die der Kernel angibt, was und wo sich der Prozess im Speicher befindet.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Wie Sie wissen</a> , befindet sich im Verzeichnis / proc f√ºr jeden Prozess ein Unterverzeichnis.  Darin befindet sich eine Datei, die <em>die</em> Prozessspeicherkarte beschreibt: </p><br><pre> $ cat / proc / self / maps
 00400000-0040c000 r-xp 00000000 zB: 01 1044592 / bin / cat
 0060b000-0060c000 r - p 0000b000 fe: 01 1044592 / bin / cat
 0060c000-0060d000 rw-p 0000c000 fe: 01 1044592 / bin / cat
 013d5000-013f6000 rw-p 00000000 00:00 0 [Heap]
 7f9920bd1000-7f9920d72000 r-xp 00000000 fe: 01 920019 /lib/x86_64-linux-gnu/libc-2.19.so
 7f9920d72000-7f9920f72000 --- p 001a1000 fe: 01 920019 /lib/x86_64-linux-gnu/libc-2.19.so
 7f9920f72000-7f9920f76000 r - p 001a1000 fe: 01 920019 /lib/x86_64-linux-gnu/libc-2.19.so
 7f9920f76000-7f9920f78000 rw-p 001a5000 fe: 01 920019 /lib/x86_64-linux-gnu/libc-2.19.so
 7fc3f8381000-7fc3f8385000 rw-p 00000000 00:00 0
 7fc3f8385000-7fc3f83a6000 r-xp 00000000 fe: 01 920012 /lib/x86_64-linux-gnu/ld-2.19.so
 7fc3f83ec000-7fc3f840e000 rw-p 00000000 00:00 0
 7fc3f840e000-7fc3f8597000 r - p 00000000 fe: 01 657286 / usr / lib / locale / locale-archive
 7fc3f8597000-7fc3f859a000 rw-p 00000000 00:00 0
 7fc3f85a3000-7fc3f85a5000 rw-p 00000000 00:00 0
 7fc3f85a5000-7fc3f85a6000 r - p 00020000 fe: 01 920012 /lib/x86_64-linux-gnu/ld-2.19.so
 7fc3f85a6000-7fc3f85a7000 rw-p 00021000 fe: 01 920012 /lib/x86_64-linux-gnu/ld-2.19.so
 7fc3f85a7000-7fc3f85a8000 rw-p 00000000 00:00 0
 7ffdb6f0e000-7ffdb6f2f000 rw-p 00000000 00:00 0 [Stapel]
 7ffdb6f7f000-7ffdb6f81000 r-xp 00000000 00:00 0 [vdso]
 7ffdb6f81000-7ffdb6f83000 r - p 00000000 00:00 0 [vvar]
 ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0 [vsyscall]
</pre><br><p>  Der Inhalt dieser Datei wird vom Betriebssystemkern im laufenden Betrieb aus internen Strukturen generiert, die die Speicherbereiche des f√ºr uns interessanten Prozesses beschreiben, und enth√§lt die folgenden Informationen: </p><br><ul><li>  Adressbereich, der der Region zugeordnet ist </li><li>  Zugangsrechte zur Region <br><ul><li>  <code>r/-</code> : lesen </li><li>  <code>w/-</code> : schreiben </li><li>  <code>x/-</code> : Ausf√ºhrung </li><li>  <code>p/s</code> : Speicher mit anderen Prozessen teilen </li></ul></li><li>  Dateiversatz (falls vorhanden) </li><li>  Code des Ger√§ts, auf dem sich die angezeigte Datei befindet </li><li>  Datei-Inode-Nummer (falls vorhanden) </li><li>  Pfad zur angezeigten Datei (falls vorhanden) </li></ul><br><p>  Einige Speicherbereiche werden auf Dateien abgebildet: Wenn ein Prozess einen solchen Speicher liest, liest er tats√§chlich Daten aus den entsprechenden Dateien mit einem bestimmten Versatz.  Wenn Sie in eine Region schreiben k√∂nnen, k√∂nnen √Ñnderungen im Speicher entweder nur f√ºr den Prozess selbst sichtbar sein ( <em>Copy-on-Write-</em> Mechanismus, <code>p</code> Modus ist privat) oder mit der Festplatte synchronisiert ( <code>s</code> Modus wird gemeinsam genutzt). </p><br><p>  Andere Regionen sind <em>anonym</em> - dieser Speicher entspricht keiner Datei.  Das Betriebssystem gibt dem Prozess einfach einen physischen Speicher, den es verwendet.  Solche Bereiche werden beispielsweise f√ºr "normalen" Prozessspeicher verwendet: Stapel und Heap.  Anonyme Regionen k√∂nnen entweder f√ºr einen Prozess pers√∂nlich sein oder von mehreren Prozessen <em>gemeinsam genutzt</em> werden ( <em>Shared Memory-</em> Mechanismus). </p><br><p>  Dar√ºber hinaus gibt es im Speicher mehrere spezielle Bereiche, die mit den Pseudonamen [vdso] und [vsyscall] gekennzeichnet sind.  Sie werden verwendet, um einige Systemaufrufe zu optimieren. </p><br><p>  Wir interessieren uns f√ºr Regionen, in denen der Inhalt von Bibliotheksdateien angezeigt wird.  Wenn wir die Speicherkarte lesen und die darin enthaltenen Eintr√§ge nach dem Namen der angezeigten Datei herausfiltern, finden wir alle Adressen, die von den ben√∂tigten Bibliotheken belegt werden.  Das Format der Speicherkarte ist speziell f√ºr die Programmverarbeitung geeignet und mit den Funktionen der scanf () -Familie leicht verst√§ndlich: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_proc_line</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *line, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *library, struct memory_region *region)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> vaddr_low = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> vaddr_high = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> read = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> write = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> execute = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> path_offset = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    /proc/$pid/maps */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sscanf</span></span>(line, <span class="hljs-string"><span class="hljs-string">"%lx-%lx %c%c%c%*c %*lx %*x:%*x %*d %n"</span></span>, &amp;vaddr_low, &amp;vaddr_high, &amp;read, &amp;write, &amp;execute, &amp;path_offset); <span class="hljs-comment"><span class="hljs-comment">/* ,       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>(line + path_offset, library)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*           */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region) { region-&gt;vaddr_low = vaddr_low; region-&gt;vaddr_high = vaddr_high; region-&gt;readable = (read == <span class="hljs-string"><span class="hljs-string">'r'</span></span>); region-&gt;writeable = (write == <span class="hljs-string"><span class="hljs-string">'w'</span></span>); region-&gt;executable = (execute == <span class="hljs-string"><span class="hljs-string">'x'</span></span>); region-&gt;content = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3 id="tayna-tretey-planety">    </h3><br><p>      ,  libc-2.19.so,     : </p><br><p><img src="https://habrastorage.org/webt/vf/lw/4m/vflw4m5jy3pwtbcxu0foudxnh3o.png" alt="Loch in libc-2.19.so"></p><br><p>        2   -    ?  51?   ?  ? </p><br><p> ,    ,          . </p><br><p>  ,     <em></em>   ,         .  <em> </em>         ,    ,   ,           (, ,        ). </p><br><p>      ,  <em></em> (  4  ).    ,            . </p><br><p>  ,           .       ‚Äî    ‚Äî      .           2    ‚Äî   ,        ( x86_64    4 , 2 , 1 ).                  . </p><br><h3 id="rezultaty-vtorogo-shaga">    </h3><br><p>     ,          : </p><br><ul><li>  libdl: dlopen()  dlsym() </li><li>  libpthread: pthread_create()  pthread_detach() </li></ul><br><p>    ,       ,   .      Linux       ( <em>address space layout randomization</em> , ASLR).        (- ,     ),             ‚Äî    - . </p><br><p>       ,           ,      ,     /proc/$pid/maps.     ,          . </p><br><h2 id="shag-3-razbor-elf-obrazov-bibliotek">  3.  ELF-  </h2><br><p> ,      ,        ,   . </p><br><p>   : </p><br><pre> <code class="plaintext hljs">$ nm -D /lib/x86_64-linux-gnu/libdl-2.19.so | grep dlopen 0000000000001090 T dlopen</code> </pre> <br><p>  <em>nm</em>             .                . </p><br><p>   -  ,      nm     ,        .  ,      dlsym(). </p><br><h3 id="chtenie-pamyati-celevogo-processa">     </h3><br><p>   ‚Äî    ELF-,    .        procfs.    UNIX way,         <strong>/proc/$pid/mem</strong> ,    ‚Äî      (     /proc/$pid/maps). </p><br><p>   Linux           mmap(),         (    ,   ).            : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map_region</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, struct memory_region *region)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> length = region-&gt;vaddr_high - region-&gt;vaddr_low; <span class="hljs-keyword"><span class="hljs-keyword">off_t</span></span> offset = region-&gt;vaddr_low; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> path[<span class="hljs-number"><span class="hljs-number">32</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">snprintf</span></span>(path, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(path), <span class="hljs-string"><span class="hljs-string">"/proc/%d/mem"</span></span>, pid); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd = open(path, O_RDONLY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fd &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *buffer = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!buffer) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error_close_file; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (read_region(fd, offset, buffer, length) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error_free_buffer; region-&gt;content = buffer; close(fd); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; error_free_buffer: <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(buffer); error_close_file: close(fd); error: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_region</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">off_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *buffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lseek(fd, offset, SEEK_SET) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> remaining = length; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ptr = buffer; <span class="hljs-comment"><span class="hljs-comment">/* *     .   , *      ,  . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (remaining &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> count = read(fd, ptr, remaining); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; remaining -= count; ptr += count; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>      ELF- .    , -,       ,  -,       . </p><br><h3 id="dvulikiy-elf">  ELF </h3><br><p>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">   ELF</a> ‚Äî         Linux.      ,    ,      . </p><br><p>      ELF   .    ELF    <em></em>    .    ‚Äî   <em></em> ,        .      ,  ‚Äî    .        ELF-. </p><br><p> ,   libdl-2.19.so  : </p><br><p><img src="https://habrastorage.org/webt/at/zw/up/atzwupwipysw3kip1yx95aa-eps.png" alt="Abschnitte und Segmente libdl-2.19.so"></p><br><p> (          <code>readelf --headers</code> .) </p><br><p>   ,    ,   (29  9).    ‚Äî    ,           ,     .  ELF ‚Äî    ,      .  Linux, ,    LOAD,      (     ). </p><br><p>   ELF-     ,         . ,       . </p><br><p>       ,   . ¬´¬ª    .     .bss,   ,      (    ). </p><br><p>  ,   ELF     ‚Äî  ,     .       ... </p><br><h3 id="gde-lezhit-tablica-simvolov">    ? </h3><br><p>          ()   .        ,     dlsym(),       .  -   . </p><br><p>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"> ELF</a> (. 2-10).   ,        <strong>.dynamic</strong> ,     <strong>DYNAMIC</strong> .   .dynamic     ,  : </p><br><ul><li> <strong>.dynsym</strong> ‚Äî     ; </li><li> <strong>.dynstr</strong> ‚Äî     ; </li><li> <strong>.hash</strong> ‚Äî -,   . </li></ul><br><p>    ,     ,       ELF: </p><br><p><img src="https://habrastorage.org/webt/yw/y9/7d/ywy97dqzszhxz1jmoe45851oebe.png" alt="DYNAMISCHE Segmentsuche"></p><br><p>     ELF,      (1),      (2),      (3),      (4) <del>  ,    </del>  . </p><br><h4 id="zagolovok-elf--tablica-segmentov">  ELF ‚Üí   </h4><br><p> ()   ELF      &lt;elf.h&gt;, ,   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"> </a> .   ,  ELF ‚Äî      .    32-  64- ,      ,      ,   .          x86_64,    ELF  . </p><br><p>  ELF-    ( <strong>Elf64_Ehdr</strong> ).          ( <em>program headers</em> ),    <strong>e_phoff</strong>  <strong>e_phnum</strong> : </p><br><p><img src="https://habrastorage.org/webt/1z/al/rn/1zalrn30vwfxce_smmy4vylj55g.png" alt=" ELF"></p><br><p>   ‚Äî    ,   ,  ELF-   ‚Äî     ,    ,     ,  ,    . </p><br><p>        e_phoff,       ,      .    e_phnum   e_phentsize  . </p><br><p>    (   ),        ELF ‚Äî    64 . </p><br><h4 id="tablica-segmentov--segment-dynamic">   ‚Üí  DYNAMIC </h4><br><p>      .   ‚Äî      <strong>Elf64_Phdr</strong> ( 64- ELF-),   .      <strong>PT_DYNAMIC</strong>   <strong>p_type</strong> : </p><br><p><img src="https://habrastorage.org/webt/i0/rg/cp/i0rgcpji9bl9wbsvegzrree9zfm.png" alt="  ELF"></p><br><p>          : </p><br><ul><li> <strong>p_vaddr</strong> ‚Äî   ,    ; </li><li> <strong>p_memsz</strong> ‚Äî      . </li></ul><br><p>     .dynamic      0x2D88 (     ).        DYNAMIC     ‚Äî   0x202D88.    0x210 (8448) .                . </p><br><h4 id="segment-dynamic--sekcii-dynsym-dynstr-hash">  DYNAMIC ‚Üí  .dynsym, .dynstr, .hash </h4><br><p>  .dynamic,    DYNAMIC,      .       <strong>Elf64_Dyn</strong> ,   : </p><br><p><img src="https://habrastorage.org/webt/dd/jp/th/ddjpthosvl8irw8ekelw0bdkaug.png" alt="  DYNAMIC"></p><br><p>    8     <strong>d_val</strong>  <strong>d_ptr</strong> ,   8-  <strong>d_tag</strong> ,  ,    .      : </p><br><ul><li> <strong>DT_HASH</strong> (4) ‚Äî    .hash ( d_ptr) </li><li> <strong>DT_STRTAB</strong> (5) ‚Äî    .dynstr ( d_ptr) </li><li> <strong>DT_SYMTAB</strong> (6) ‚Äî    .dynsym ( d_ptr) </li><li> <strong>DT_STRSZ</strong> (10) ‚Äî     .dynstr ( d_val) </li><li> <strong>DT_NULL</strong> (0) ‚Äî     </li></ul><br><p>       .     .dynamic     :  ,   ,    ,    . </p><br><p>    ,   DYNAMIC   <em></em>          ,    .      ,            ,  - ,   . </p><br><p>    .dynamic         ,          . -,   .dynstr   ,      ?     . </p><br><h3 id="poisk-funkciy-v-biblioteke">     </h3><br><p>            .     ,    <strong>.dynsym</strong>   ,        . (  ¬´¬ª   .symtab,      , ,  .    .) </p><br><h4 id="tablica-simvolov">   </h4><br><p>      <strong>Elf64_Sym</strong> ,        ELF ‚Äî , , , .       <code>dlopen</code> : </p><br><p><img src="https://habrastorage.org/webt/pd/5_/qh/pd5_qhcculmqmjk7p6krar1czjy.png" alt="  ELF"></p><br><p>      : </p><br><ul><li> <strong>st_name</strong> ‚Äî  ,       </li><li> <strong>st_info</strong> ‚Äî     (   ) </li><li> <strong>st_value</strong> ‚Äî     </li></ul><br><p> (  ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  nm</a>   ,  dlopen()     .text,   0x1090   .) </p><br><p>     ,       . </p><br><h4 id="tablica-strok">   </h4><br><p>   ‚Äî     - ,    .            (   ).        <strong>.dynstr</strong> ,      libdl-2.19.so  : </p><br><p><img src="https://habrastorage.org/webt/mg/b9/1v/mgb91vjtwrr_kqrncnrojgg6jum.png" alt="  ELF"></p><br><p> ,           ( ¬´dlopen¬ª,   0xA5)      ,    .        . </p><br><h4 id="hesh-tablica"> - </h4><br><p>  <strong>.hash</strong>  <em>-</em> ,       .   - ‚Äî    ‚Äî      ELF-,       . ,         .dynsym,       ,      .   ( )     - . </p><br><p>  -      &lt;elf.h&gt;,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"> </a> (. 2-19).   -   ,   : </p><br><p><img src="https://habrastorage.org/webt/ez/a3/ku/eza3ku71zydhqm_e3je0xbtjec8.png" alt="- ELF"></p><br><p>  wo </p><br><ul><li> nbuckets ‚Äî    buckets </li><li> nchains ‚Äî    chains (  ) </li><li> buckets ‚Äî      </li><li> chains ‚Äî      </li></ul><br><p>  -  : </p><br><ol><li>   <strong>h</strong>    . </li><li>   <strong>i</strong>  <code>buckets[h % nbuckets]</code> ,     . </li><li>      (     )  ,   . </li><li>    ‚Äî  <code>chains[i % nchains]</code> . </li><li>   3‚Äî4           ,       . </li></ol><br><p>  -,  ELF: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">elf_hash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> h = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> g; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (*name) { h = (h &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) + *name++; g = h &amp; <span class="hljs-number"><span class="hljs-number">0xF0000000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (g) h ^= g &gt;&gt; <span class="hljs-number"><span class="hljs-number">24</span></span>; h &amp;= ~g; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> h; }</code> </pre> <br><p> ,   <code>"dlopen"</code> -   112420542     : </p><br><p><img src="https://habrastorage.org/webt/zu/ch/4i/zuch4ibwuspxmog6_erhbq1evyg.png" alt="   "></p><br><p> libdl ‚Äî    ,    39   ,      .  -           . </p><br><h3 id="rezultaty-tretego-shaga">    </h3><br><p>              ,          : </p><br><ul><li> dlopen()  dlsym()   libdl </li><li> pthread_create()  pthread_detach()   libpthread </li></ul><br><p>   ,    . </p><br><p>         .            .      ,       . </p><br><p>     ELF-    .       ,      (  ).        ,    . ,    ,     .               . </p><br><h2 id="shag-4-vnedrenie-shell-koda">  4.  - </h2><br><p>   ,    ,    <em>-</em> ,     :         ,   .   -  . </p><br><h3 id="soderzhimoe-shell-koda">  - </h3><br><p> ,   -: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *payload = dlopen(<span class="hljs-string"><span class="hljs-string">"/path/to/payload.so"</span></span>, RTLD_LAZY); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*entry)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) = dlsym(payload, <span class="hljs-string"><span class="hljs-string">"entry_point"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">pthread_t</span></span> thread; pthread_create(&amp;thread, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, entry, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); pthread_detach(thread); }</code> </pre> <br><p>       ? </p><br><p> ,        ‚Äî   .    ,     ,      ,       -  ‚Äî  -     !    . </p><br><p>    ‚Äî   -  .         ,    ,           :        . </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* *      .rodata:   * .         , *        . */</span></span> .section .rodata <span class="hljs-comment"><span class="hljs-comment">/* *   .       . *      -:    ,  *  ,       . */</span></span> .global shellcode_start .global shellcode_address_dlopen .global shellcode_address_dlsym .global shellcode_address_pthread_create .global shellcode_address_pthread_detach .global shellcode_address_payload .global shellcode_address_entry .global shellcode_end <span class="hljs-comment"><span class="hljs-comment">/* *   dlopen().     #include &lt;dlfcn.h&gt;, *       . */</span></span> .set RTLD_LAZY, <span class="hljs-number"><span class="hljs-number">1</span></span> .align <span class="hljs-number"><span class="hljs-number">8</span></span> shellcode_start: <span class="hljs-comment"><span class="hljs-comment">/* * void *payload = dlopen(shellcode_address_payload, RTLD_LAZY); * *        x86_64: * * -     %rdi, %rsi, %rdx, %rcx * -     %rax * -      * *         . * *       %rax,    *     . */</span></span> lea shellcode_address_payload(%rip),%rdi mov $RTLD_LAZY,%rsi mov shellcode_address_dlopen(%rip),%rax callq *%rax <span class="hljs-comment"><span class="hljs-comment">/* * void (*entry)(void) = dlsym(payload, shellcode_address_entry); */</span></span> mov %rax,%rdi lea shellcode_address_entry(%rip),%rsi mov shellcode_address_dlsym(%rip),%rax callq *%rax <span class="hljs-comment"><span class="hljs-comment">/* * pthread_t thread; * pthread_create(&amp;thread, NULL, entry, NULL); * *            * ,     pthread_create(). */</span></span> sub $<span class="hljs-number"><span class="hljs-number">8</span></span>,%rsp mov %rsp,%rdi xor %rsi,%rsi mov %rax,%rdx xor %rcx,%rcx mov shellcode_address_pthread_create(%rip),%rax callq *%rax <span class="hljs-comment"><span class="hljs-comment">/* * pthread_detach(thread); * *    ,   ,  *     . */</span></span> mov (%rsp),%rdi add $<span class="hljs-number"><span class="hljs-number">8</span></span>,%rsp mov shellcode_address_pthread_detach(%rip),%rax callq *%rax <span class="hljs-comment"><span class="hljs-comment">/* *   - ‚Äî    ,     *      ret.    *     ,  *      . */</span></span> int $<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-comment"><span class="hljs-comment">/* *       ,   *   ,    - *     .   ‚Äú  *  ‚Äù (global offset table, GOT),   *           . */</span></span> .align <span class="hljs-number"><span class="hljs-number">8</span></span> shellcode_address_dlopen: .space <span class="hljs-number"><span class="hljs-number">8</span></span> shellcode_address_dlsym: .space <span class="hljs-number"><span class="hljs-number">8</span></span> shellcode_address_pthread_create: .space <span class="hljs-number"><span class="hljs-number">8</span></span> shellcode_address_pthread_detach: .space <span class="hljs-number"><span class="hljs-number">8</span></span> shellcode_address_payload: .space <span class="hljs-number"><span class="hljs-number">256</span></span> shellcode_address_entry: .space <span class="hljs-number"><span class="hljs-number">256</span></span> <span class="hljs-comment"><span class="hljs-comment">/* *  - . */</span></span> shellcode_end: .end</code> </pre> <br><p> ,   .      : </p><br><pre> <code class="plaintext hljs">$ as -o shellcode.o shellcode.S</code> </pre> <br><p>  ,      ,  ,   .            :   <em>  </em> (procedure linkage table, PLT),        . </p><br><p>     -    ,         (, )       .  <em>-</em>  <em></em> . </p><br><h3 id="razmeschenie-shell-koda-v-pamyati">  -   </h3><br><p>     <em>-</em>    . ,       ,   ,          .      ? </p><br><h4 id="trebovaniya-k-pamyati-pod-shell-kod">     - </h4><br><p>      ,       .      <em></em> ,       .    ,         .         ,       . </p><br><p>              (-  ),         :   ,    ,    . , ,   JIT-   ,       .    ? </p><br><h4 id="podhody-k-razmescheniyu-v-pamyati">      </h4><br><p>         : </p><br><ul><li>  -  ,     </li><li>   - ,    </li></ul><br><p>      ,  . -,    - ,     . -,       . -,      ,  -    -,     . </p><br><p>   ,      .     .  x86_64  <code>int $3</code>     ‚Äî 0xCC ‚Äî          .  ptrace()         PTRACE_POKETEXT ‚Äî ,     8   , . ,          ,     . </p><br><p> ,  ,   ,       :        .     -       ,  . </p><br><h4 id="kak-vydelit-novuyu-pamyat">    ? </h4><br><p>  ,  !    malloc()! </p><br><p> .      ,      -,    .       .          ,     mmap(): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject_shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *shellcode_src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shellcode_size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *shellcode_dst = mmap(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, shellcode_size, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANONYMOUS | MAP_PRIVATE, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); copy_shellcode(shellcode_dst, shellcode_src, shellcode_size); }</code> </pre> <br><p>  ,   ptrace()         ,     . </p><br><h3 id="vypolnenie-sistemnyh-vyzovov">    </h3><br><p>      ,     ?    ,            . Linux  x86_64   : </p><br><ul><li>       %rax </li><li>    ‚Äî    ‚Äî      %rsi, %rdi, %rdx, %r10, %r8, %r9 </li><li>   SYSCALL,     </li><li>       %rax </li></ul><br><p>  ptrace()           PTRACE_GETREGS  PTRACE_SETREGS.  ,        .   -   SYSCALL. </p><br><p>     :      ,       %rip.   ,   ,   SYSCALL. </p><br><h4 id="poisk-instrukcii-syscall">   SYSCALL </h4><br><p>    SYSCALL? ,    .   -   ,   <em>-</em>      .    ‚Äî   libc.  ,  ,      ,   : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_syscall_instruction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct library *library)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; library-&gt;region_count; i++) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">memory_region</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">region</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">library</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">regions</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class">];</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(region-&gt;readable &amp;&amp; region-&gt;executable)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *region_data = region-&gt;content; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> region_size = region-&gt;vaddr_high - region-&gt;vaddr_low; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region_size &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* * 0F 05 syscall */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> offset = <span class="hljs-number"><span class="hljs-number">0</span></span>; offset &lt; region_size - <span class="hljs-number"><span class="hljs-number">1</span></span>; offset++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region_data[offset + <span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-number"><span class="hljs-number">0x0F</span></span> &amp;&amp; region_data[offset + <span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-number"><span class="hljs-number">0x05</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> region-&gt;vaddr_low + offset; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>        , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  /proc/$pid/maps</a> .  x86_64     ,    -   .     <em></em>   ,    0x0F 0x05.     , ,  ARM,       0xDF 0x00 ( SVC #0),  <em>  </em> . </p><br><h4 id="ispolzovanie-ptrace_getsetregs">  PTRACE_{GET,SET}REGS </h4><br><p>      : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_registers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, struct user_regs_struct *registers)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_GETREGS, pid, registers, registers) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) err = -errno; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; }</code> </pre> <br><p>     <code>struct user_regs_struct</code> ,    &lt;sys/user.h&gt;.     .          .     ,        <em>varargs</em> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_regs_for_syscall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct user_regs_struct *registers, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> syscall_insn_vaddr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> syscall_number, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> args_count, va_list args)</span></span></span><span class="hljs-function"> </span></span>{ registers-&gt;rip = syscall_insn_vaddr; registers-&gt;rax = syscall_number; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; args_count; i++) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (i) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: registers-&gt;rdi = va_arg(args, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: registers-&gt;rsi = va_arg(args, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: registers-&gt;rdx = va_arg(args, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: registers-&gt;r10 = va_arg(args, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: registers-&gt;r8 = va_arg(args, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>: registers-&gt;r9 = va_arg(args, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -E2BIG; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perform_syscall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> syscall_insn_vaddr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> syscall_number, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> args_count, ...)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user_regs_struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">old_registers</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user_regs_struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new_registers</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* *    ,   *      . */</span></span> get_registers(pid, &amp;old_registers); <span class="hljs-comment"><span class="hljs-comment">/* *      ,   * ,     . */</span></span> new_registers = old_registers; va_list args; va_start(args, args_count); set_regs_for_syscall(&amp;new_registers, syscall_insn_vaddr, syscall_number, args_count, args); va_end(args); set_registers(pid, &amp;new_registers); <span class="hljs-comment"><span class="hljs-comment">/* *    ,    *   ,    * (  ),    . *     . */</span></span> wait_for_syscall_completion(pid); <span class="hljs-comment"><span class="hljs-comment">/* *       *    . *        . */</span></span> get_registers(pid, &amp;new_registers); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> result = new_registers.rax; set_registers(pid, &amp;old_registers); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><h4 id="ispolzovanie-ptrace_syscall">  PTRACE_SYSCALL </h4><br><p>       :        ,    ? </p><br><p>      PTRACE_SYSCALL.   PTRACE_CONT,     .   ,    - :    ,    . </p><br><p> PTRACE_SYSCALL    SIGTRAP    :      (     )       (      ).  , ptrace()   ,          ,         . </p><br><p>  ,           SIGTRAP: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_for_syscall_enter_exit_stop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_SYSCALL, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wait_for_process_stop(pid, SIGTRAP) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_for_syscall_completion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ wait_for_syscall_enter_exit_stop(pid); wait_for_syscall_enter_exit_stop(pid); }</code> </pre> <br><p>   ‚Äî   ,    ‚Äî       (wait_for_process_stop() <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ).           .       ,     . </p><br><h4 id="opciya-ptrace_o_tracesysgood">  PTRACE_O_TRACESYSGOOD </h4><br><p>   , PTRACE_SYSCALL      :       ,   ,  -  .  ,      SIGTRAP       (    ). </p><br><p>     SIGTRAP       <em></em> .        PTRACE_O_TRACESYSGOOD,            : </p><br><ul><li> SIGTRAP ‚Äî -     </li><li> SIGTRAP | 0x80 ‚Äî     </li></ul><br><pre> <code class="diff hljs"> int ptrace_attach(pid_t pid) { if (ptrace(PTRACE_ATTACH, pid, 0, 0) &lt; 0) return -1; if (wait_for_process_stop(pid, SIGSTOP) &lt; 0) return -1; + /*     */ + unsigned long options = PTRACE_O_TRACESYSGOOD; + if (ptrace(PTRACE_SETOPTIONS, pid, 0, options) &lt; 0) + return -1; return 0; } static int wait_for_syscall_enter_exit_stop(pid_t pid) { if (ptrace(PTRACE_SYSCALL, pid, 0, 0) &lt; 0) return -1; - if (wait_for_process_stop(pid, SIGTRAP) &lt; 0) + if (wait_for_process_stop(pid, SIGTRAP | 0x80) &lt; 0) return -1; return 0; }</code> </pre> <br><h3 id="zagruzka-shell-koda-v-pamyat">  -   </h3><br><p> -       : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_text[SHELLCODE_TEXT_SIZE]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> shellcode_size = shellcode_end - shellcode_start; <span class="hljs-comment"><span class="hljs-comment">/*   ,  ,  . . */</span></span> prepare_shellcode(shellcode_text, shellcode_size); <span class="hljs-comment"><span class="hljs-comment">/*   -   */</span></span> write_remote_memory(target, shellcode_text_vaddr, shellcode_text, shellcode_size); }</code> </pre> <br><p>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   -</a>    :      dlopen(),               . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy_shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *shellcode_text, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *shellcode_addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">ptrdiff_t</span></span> offset = shellcode_addr - shellcode_start; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(shellcode_text + offset, data, length); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare_shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *shellcode_text, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shellcode_size)</span></span></span><span class="hljs-function"> </span></span>{ copy_shellcode(shellcode_text, shellcode_start, shellcode_start, shellcode_size); copy_shellcode(shellcode_text, shellcode_address_dlopen, &amp;dlopen_vaddr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(dlopen_vaddr)); copy_shellcode(shellcode_text, shellcode_address_dlsym, &amp;dlsym_vaddr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(dlsym_vaddr)); copy_shellcode(shellcode_text, shellcode_address_pthread_create, &amp;pthread_create_vaddr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(pthread_create_vaddr)); copy_shellcode(shellcode_text, shellcode_address_pthread_detach, &amp;pthread_detach_vaddr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(pthread_detach_vaddr)); copy_shellcode(shellcode_text, shellcode_address_payload, payload, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(payload)); copy_shellcode(shellcode_text, shellcode_address_entry, entry, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(entry)); }</code> </pre> <br><p>     ,    ,      -: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_start[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_address_dlopen[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_address_dlsym[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_address_pthread_create[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_address_pthread_detach[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_address_payload[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_address_entry[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_end[];</code> </pre> <br><p>      ,              . </p><br><p>    -        .         /proc/$pid/mem, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    </a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_remote_memory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vaddr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> path[<span class="hljs-number"><span class="hljs-number">32</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">snprintf</span></span>(path, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(path), <span class="hljs-string"><span class="hljs-string">"/proc/%d/mem"</span></span>, pid); <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd = open(path, O_WRONLY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fd &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lseek(fd, vaddr, SEEK_SET) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { close(fd); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err = do_write_remote_memory(fd, data, size); close(fd); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_write_remote_memory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> left = size; <span class="hljs-comment"><span class="hljs-comment">/* *    ,  ,     *   ,       *      . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (left &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> wrote = write(fd, data, left); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrote &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; data += wrote; left -= wrote; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h3 id="rezultaty-chetvyortogo-shaga">    </h3><br><p> ,             - ‚Äî ¬´ ¬ª .           .    - ,                . </p><br><h2 id="shag-5-zapusk-novogo-potoka">  5.    </h2><br><p>     -        .  ,    :    %rip  -,  PTRACE_SETREGS,  PTRACE_CONT    .     . </p><br><p> ,   ,    .      -?        ? </p><br><h3 id="pochemu-nuzhen-novyy-potok">     </h3><br><p>  ,    .    ,          ¬´ ¬ª  .  ,      .      : </p><br><ul><li>       </li><li>   (async-signal-safe)  </li></ul><br><p>      ‚Äî     . dlopen()  pthread_create()     .        -  dlopen(),      dlopen()  ? </p><br><p>        -, ,   ,       . ,     pthread_create()    .     ,       (     ).     clone(). </p><br><blockquote> <strong>  pthread_create()?</strong> <br><br>     ,  -     ,         ? <br><br> :          clone(). <br><br>          ,    (libc)    (pthread).   clone()       <em> </em> (thread control block, TCB)  <em> </em> (thread-local storage, TLS),        ,  . .     pthread_create()    ,    . <br><br>    ¬´¬ª,      clone()        libc  pthread.        ,    . </blockquote><br><h3 id="podgotovka-k-zapusku-potoka">     </h3><br><p>      clone()      : </p><br><ul><li>      ? </li><li>    ? </li><li>    -? </li></ul><br><h4 id="obrabotka-zaversheniya-potoka">    </h4><br><p>      :     -? </p><br><p>     ,  -       :   ,   ,       ,       . </p><br><p>        .  ,     ,        .  Wie?  :     exit().          ,     . </p><br><p>         .     exit()   -: </p><br><pre> <code class="diff hljs"><span class="hljs-addition"><span class="hljs-addition">+.set __NR_exit, 60 .set RTLD_LAZY, 1 @@ - /* - *  . - */ - int $3 + /* + * exit(0); + */ + xor %rdi,%rdi + mov $__NR_exit,%rax + syscall</span></span></code> </pre> <br><p>  :   exit() ‚Äî    exit()   .   exit()    <em></em> ,    exit()    ‚Äî <em> </em>   .    Linux     exit_group(). </p><br><h4 id="vydelenie-pamyati-pod-stek">     </h4><br><p>     .         .     ,      ,   PROT_EXEC: </p><br><pre> <code class="cpp hljs">shellcode_stack_vaddr = remote_mmap(target, syscall_vaddr, <span class="hljs-number"><span class="hljs-number">0</span></span>, SHELLCODE_STACK_SIZE, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE | MAP_STACK | MAP_GROWSDOWN, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>   ,   Linux  x86_64  <em> </em> ‚Äî  ¬´¬ª  ,     .  mmap()      ,   clone()     .  ,    mmap()  MAP_GROWSDOWN,       ,    . </p><br><h4 id="opciya-ptrace_o_traceclone">  PTRACE_O_TRACECLONE </h4><br><p>        .       ,   -   .         waitpid(),     :      ,          . </p><br><p>        ‚Äî   PTRACE_O_TRACECLONE.          .  ,       . ,      ,     ,    .      ,       PTRACE_ATTACH  ,    . </p><br><p> -,       : </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- unsigned long options = PTRACE_O_TRACESYSGOOD; + unsigned long options = PTRACE_O_TRACESYSGOOD | PTRACE_O_TRACECLONE; if (ptrace(PTRACE_SETOPTIONS, pid, 0, options) &lt; 0) return -1;</span></span></code> </pre> <br><p> -,         clone(),    PTRACE_EVENT_CLONE,     ,  PTRACE_SYSCALL.        : </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">-void wait_for_syscall_completion(pid_t pid) +void wait_for_syscall_completion(pid_t pid, long syscall) { wait_for_syscall_enter_exit_stop(pid); + + /*  clone()   PTRACE_EVENT_CLONE */ + if (syscall == __NR_clone) + wait_for_clone_event(pid); wait_for_syscall_enter_exit_stop(pid); }</span></span></code> </pre> <br><p>     : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_for_clone_event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_CONT, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> event = SIGTRAP | (PTRACE_EVENT_CLONE &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wait_for_process_stop(pid, event) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>     clone()  PID  ,    .         : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear_ptrace_options</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ ptrace(PTRACE_SETOPTIONS, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><p>   ,   clone()    ptrace(),  PTRACE_O_TRACECLONE.     ,     ,  -     . </p><br><h3 id="zapusk-novogo-potoka">    </h3><br><p>      ,   - .       clone()   : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spawn_shell_thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ shell_tid = remote_clone(target, syscall_ret_vaddr, CLONE_FILES | CLONE_FS | CLONE_IO | CLONE_SIGHAND | CLONE_SYSVSEM | CLONE_THREAD | CLONE_VM, <span class="hljs-comment"><span class="hljs-comment">/*   **  */</span></span> shellcode_stack_vaddr + SHELLCODE_STACK_SIZE); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!shell_tid) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">clone()    </a> :    ,   ,     ,  .      ,  . </p><br><p> CLONE_FILES, CLONE_FS, CLONE_IO, CLONE_SIGHAND, CLONE_SYSVSEM, CLONE_VM ‚Äî         . ,   CLONE_FILES    <em></em>   ,    (  fork()).      ‚Äî    <em></em> ‚Äî      ,        .       . , CLONE_VM   ,       ,    . </p><br><p>  CLONE_THREAD       <em></em> :    Linux ‚Äî  ¬´   ¬ª,     .  , ,  getpid()         , kill() ‚Äî   -   , execve() ‚Äî       ,   . </p><br><p>  ,  clone()   fork():        ,    .      clone()      :    ,  ‚Äî   .        . ( , ,        .) </p><br><p>    ,  pthread_create()    ,      ,    .     ? </p><br><h3 id="peredacha-upravleniya">   </h3><br><p>    fork()  : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pid_t</span></span> child = fork(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (child &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* fork() ,    */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (child == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*     execve() */</span></span> } <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span></code> </pre> <br><p>  ,     .  clone()                 .            . </p><br><p>      <a href="" rel="nofollow"> </a> . ,   clone()      ,    .      syscall   ret,       ,     .           . </p><br><h4 id="poisk-pary-instrukciy-syscall--ret">    SYSCALL + RET </h4><br><p>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   </a> ,       .      ,     syscall   ret: </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">-if (region_size &lt; 2) +if (region_size &lt; 3) continue; /* * 0F 05 syscall + * C3 retq */ -for (size_t offset = 0; offset &lt; region_size - 1; offset++) { +for (size_t offset = 0; offset &lt; region_size - 2; offset++) { if (region_data[offset + 0] == 0x0F &amp;&amp; - region_data[offset + 1] == 0x05) + region_data[offset + 1] == 0x05 &amp;&amp; + region_data[offset + 2] == 0xC3) { return region-&gt;vaddr_low + offset; } }</span></span></code> </pre> <br><p>  ,       . </p><br><h4 id="podgotovka-steka">   </h4><br><p>     .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> prepare_shellcode()</a> ,    ,          : </p><br><pre> <code class="diff hljs"> void write_shellcode(void) { char shellcode_text[SHELLCODE_TEXT_SIZE]; size_t shellcode_size = shellcode_end - shellcode_start; /*   ,  ,  . . */ prepare_shellcode(shellcode_text, shellcode_size); /*   -   */ write_remote_memory(target, shellcode_text_vaddr, shellcode_text, shellcode_size); + /*    ¬´¬ª   */ + unsigned long retaddr_vaddr = + shellcode_stack_vaddr + SHELLCODE_STACK_SIZE - 8; + write_remote_memory(target, retaddr_vaddr, + &amp;shellcode_text_vaddr, sizeof(shellcode_text_vaddr)); }</code> </pre> <br><p>  ,      ,     . </p><br><p>  ,     ,   <em></em> . System V ABI ,   ( %rsp)     16    .  <code>shellcode_stack_vaddr + SHELLCODE_STACK_SIZE</code>  :       (  4096 ),     1 .  8 ,     ,      retq,      -    .   -   : </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- sub $8,%rsp + sub $16,%rsp /*   */ mov %rsp,%rdi xor %rsi,%rsi mov %rax,%rdx xor %rcx,%rcx mov shellcode_address_pthread_create(%rip),%rax callq *%rax</span></span></code> </pre> <br><p>     ,   %rsp    16       pthread_create().          SIGSEGV,     ‚Äî     pthread_create()   ,       . </p><br><h4 id="zapusk-potoka">   </h4><br><p>        ,       - ,      clone(): </p><br><pre> <code class="diff hljs"> static int spawn_shell_thread() { shell_tid = remote_clone(target, syscall_ret_vaddr, CLONE_FILES | CLONE_FS | CLONE_IO | CLONE_SIGHAND | CLONE_SYSVSEM | CLONE_THREAD | CLONE_VM, /*   **  */ - shellcode_stack_vaddr + SHELLCODE_STACK_SIZE); + shellcode_stack_vaddr + SHELLCODE_STACK_SIZE - 8); if (!shell_tid) return -1; return 0; }</code> </pre> <br><p>      ptrace()    SIGSTOP,     : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ignore_thread_stop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wait_for_process_stop(pid, SIGSTOP); }</code> </pre> <br><p>  Das ist alles.               ptrace(): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resume_thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ ptrace(PTRACE_CONT, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><h3 id="zavershenie-potoka">   </h3><br><p>  ,    ,  ,    exit().        waitpid().     ‚Äî  CLONE_THREAD   wait()  ,‚Äî    PTRACE_O_TRACECLONE,      : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_for_process_exit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> status = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (waitpid(pid, &amp;status, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!WIFEXITED(status)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WEXITSTATUS(status); }</code> </pre> <br><p>    pthread ,   ,  pthread_join()      pthread       ,        . ,  ‚Äî  .       ,   ,  . </p><br><h4 id="osvobozhdenie-pamyati">  Freier Speicher </h4><br><p>     ,  -   .     ,   -   ,      munmap(): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remote_munmap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> syscall_insn_vaddr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ perform_syscall(pid, syscall_insn_vaddr, __NR_munmap, <span class="hljs-number"><span class="hljs-number">2</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) addr, (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) len); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unmap_shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ remote_munmap(target, syscall_ret_vaddr, shellcode_text_vaddr, SHELLCODE_TEXT_SIZE); remote_munmap(target, syscall_ret_vaddr, shellcode_stack_vaddr, SHELLCODE_STACK_SIZE); }</code> </pre> <br><p> ,  ,     ,      ‚Äî  ptrace()   .        (, SIGSTOP),    ,   <em> </em>    (    ): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop_thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (kill(pid, SIGSTOP) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wait_for_process_stop(pid, SIGSTOP) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h4 id="otklyuchenie-otladchika">   </h4><br><p> ,      ,    .     PTRACE_DETACH: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ptrace_detach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_DETACH, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h3 id="rezultaty-pyatogo-shaga">    </h3><br><p>                   ,      .     ,         .   ,      . </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Was kann man damit machen?   . ,       ,      . </p><br><p><img src="https://habrastorage.org/webt/0v/gu/we/0vguwedoumnnjh89zw5jtpaaltw.gif" alt="   Gnome Control Center"></p><br><p>    Linux    .     GTK+     .      ,       make: </p><br><pre> <code class="bash hljs">libpayload.so: payload.c $(CC) $(CFLAGS) $(shell pkg-config --cflags --libs gtk+-3.0) -shared -o <span class="hljs-variable"><span class="hljs-variable">$@</span></span> $&lt;</code> </pre> <br><p>     entry()            GTK- ‚Äî    GTK  UI      ,    : </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;glib.h&gt; #include &lt;gtk/gtk.h&gt; static gboolean actual_entry(gpointer _arg) { /*       : */ hook_gtk_entry_constructor(); /*   FALSE,       */ return FALSE; } void entry(void) { /*    -,   */ g_idle_add_full(G_PRIORITY_DEFAULT_IDLE, actual_entry, NULL, NULL); }</span></span></span></span></code> </pre> <br><p> ,   GTK   ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">GtkEntry</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"> "input-purpose"</a>     .       ¬´¬ª,    ,      . </p><br><p> GTK   glib ‚Äî     ‚Äî      GtkEntry       .    constructed(),     .    : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*old_gtk_entry_constructed)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GObject *object)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_gtk_entry_constructed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GObject *object)</span></span></span><span class="hljs-function"> </span></span>{ GtkEntry *entry = GTK_ENTRY(object); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> old_gtk_entry_constructed(object); <span class="hljs-comment"><span class="hljs-comment">/*    ,  ,   entry */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hook_gtk_entry_constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*     GtkEntry */</span></span> GTypeClass *entry_type_class = g_type_class_peek(GTK_TYPE_ENTRY); GObjectClass *entry_object_class = G_OBJECT_CLASS(entry_type_class); <span class="hljs-comment"><span class="hljs-comment">/* *     "constructed"     . */</span></span> old_gtk_entry_constructed = entry_object_class-&gt;constructed; entry_object_class-&gt;constructed = new_gtk_entry_constructed; }</code> </pre> <br><p>   GtkEntry   : </p><br><ul><li>   ,  ,   </li><li>        </li></ul><br><p>  ,    GtkEntry  <em></em> ,   ,    .     ,    : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_gtk_entry_constructed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GObject *object)</span></span></span><span class="hljs-function"> </span></span>{ GtkEntry *entry = GTK_ENTRY(object); old_gtk_entry_constructed(object); <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> g_signal_connect(entry, <span class="hljs-string"><span class="hljs-string">"notify::input-purpose"</span></span>, G_CALLBACK(input_purpose_changed), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> g_signal_connect(entry, <span class="hljs-string"><span class="hljs-string">"icon-press"</span></span>, G_CALLBACK(icon_pressed), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> g_signal_connect(entry, <span class="hljs-string"><span class="hljs-string">"icon-release"</span></span>, G_CALLBACK(icon_released), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); }</code> </pre> <br><p>   .                ,         .         . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">input_purpose_changed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkEntry *entry)</span></span></span><span class="hljs-function"> </span></span>{ GtkInputPurpose purpose = gtk_entry_get_input_purpose(entry); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (purpose == GTK_INPUT_PURPOSE_PASSWORD) { gtk_entry_set_icon_activatable(entry, GTK_ENTRY_ICON_PRIMARY, TRUE); gtk_entry_set_icon_from_icon_name(entry, GTK_ENTRY_ICON_PRIMARY, <span class="hljs-string"><span class="hljs-string">"list-remove"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { gtk_entry_set_icon_activatable(entry, GTK_ENTRY_ICON_PRIMARY, FALSE); gtk_entry_set_icon_from_icon_name(entry, GTK_ENTRY_ICON_PRIMARY, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); } }</code> </pre> <br><p>   : ,      ,   ,  -       ,      : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">icon_pressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkEntry *entry, GtkEntryIconPosition position)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (position != GTK_ENTRY_ICON_PRIMARY) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; gtk_entry_set_visibility(entry, TRUE); gtk_entry_set_icon_from_icon_name(entry, GTK_ENTRY_ICON_PRIMARY, <span class="hljs-string"><span class="hljs-string">"list-add"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">icon_released</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkEntry *entry, GtkEntryIconPosition position)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (position != GTK_ENTRY_ICON_PRIMARY) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; gtk_entry_set_visibility(entry, FALSE); gtk_entry_set_icon_from_icon_name(entry, GTK_ENTRY_ICON_PRIMARY, <span class="hljs-string"><span class="hljs-string">"list-remove"</span></span>); }</code> </pre> <br><p>  Das ist alles. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"> GitHub</a>         (GPLv2). </p><br><p> ,       .   gdb         : </p><br><pre> <code class="plaintext hljs">$ gdb --pid $(pgrep target) \ --batch \ -ex 'compile file -raw shell-code.c'</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de473740/">https://habr.com/ru/post/de473740/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de473720/index.html">Zwei M√∂glichkeiten, um zuverl√§ssige Komponententests durchzuf√ºhren</a></li>
<li><a href="../de473722/index.html">Fernisolation, Angst und Depression</a></li>
<li><a href="../de473726/index.html">Es reicht nicht aus zu wissen, was Mutex, Semaphore und Async / Warten sind. Sie m√ºssen alles von Quanten wissen</a></li>
<li><a href="../de473728/index.html">Typische Implementierung der √úberwachung. Nikolay Sivko</a></li>
<li><a href="../de473732/index.html">Die Geschichte des Betrugs beim Bau eines Kabelnetzes unter der Arktis f√ºr 1 Milliarde US-Dollar</a></li>
<li><a href="../de473742/index.html">Epson Engineering-Drucker f√ºr CAD und GIS und ein paar Worte zum Thema "Robustes Design"</a></li>
<li><a href="../de473748/index.html">Bezierkurve im Dienste der Arbeits√∂konomen</a></li>
<li><a href="../de473750/index.html">Stereopi + WebRTC = Telepr√§senz zu Hause</a></li>
<li><a href="../de473752/index.html">Was ist falsch an Copy-on-Write f√ºr Linux beim Kopieren?</a></li>
<li><a href="../de473756/index.html">HTTPS DNS - halbe und falsche L√∂sung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>