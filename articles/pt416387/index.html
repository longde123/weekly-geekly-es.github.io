<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÇüèæ üë®üèø‚Äçüíª üëØ Camar√£o: Dimensione e compartilhe imagens HTTP no C ++ moderno com ImageMagic ++, SObjectizer e RESTinio ü§≤üèº üïë ‚ò†Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pref√°cio 
 Nossa pequena equipe est√° desenvolvendo duas ferramentas OpenSource para desenvolvedores de C ++ - a estrutura do ator SObjectizer e o serv...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Camar√£o: Dimensione e compartilhe imagens HTTP no C ++ moderno com ImageMagic ++, SObjectizer e RESTinio</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416387/"><img src="https://habrastorage.org/webt/c8/es/x7/c8esx7a-blzv0brvoyng2drgdeq.jpeg"><br><br><h1>  Pref√°cio </h1><br>  Nossa pequena equipe est√° desenvolvendo duas ferramentas OpenSource para desenvolvedores de C ++ - a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">estrutura do</a> ator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SObjectizer</a> e o servidor HTTP incorporado RESTinio.  No entanto, encontramos regularmente algumas perguntas n√£o triviais: <br><br><ul><li>  quais recursos adicionar √† biblioteca e quais deixar "ao mar"? </li><li>  como demonstrar claramente as maneiras "ideologicamente corretas" de usar a biblioteca? </li></ul><br>  √â bom quando as respostas a essas perguntas aparecem durante o uso de nossos desenvolvimentos em projetos reais, quando os desenvolvedores v√™m at√© n√≥s com suas reclama√ß√µes ou lista de desejos.  Devido √† satisfa√ß√£o dos desejos dos usu√°rios, preenchemos nossas ferramentas com funcionalidades ditadas pela pr√≥pria vida, e n√£o "sugadas pelo dedo". <br><br>  Mas as informa√ß√µes nos chegam longe de todos os problemas e dificuldades que os usu√°rios enfrentam.  E nem sempre podemos usar as informa√ß√µes recebidas, e especialmente os exemplos de c√≥digo, em nossos materiais p√∫blicos. <br><br>  Portanto, √†s vezes pensamos em pequenos problemas para n√≥s mesmos, resolvendo os quais somos for√ßados a transformar de desenvolvedores de ferramentas em usu√°rios.  Isso nos permite olhar para nossas pr√≥prias ferramentas com olhos diferentes e entender por n√≥s mesmos o que √© bom, o que n√£o √© bom, o que est√° faltando e o que √© demais. <br><br>  Hoje, queremos contar apenas uma dessas tarefas "pequenas", na qual SObjectizer e RESTinio se uniram naturalmente. <br><br><h1>  Dimensionamento e distribui√ß√£o de imagens.  Por que exatamente isso? </h1><br>  Como uma pequena tarefa de demonstra√ß√£o para n√≥s mesmos, escolhemos um servidor HTTP que distribui imagens em escala mediante solicita√ß√£o.  Coloque as imagens em algum diret√≥rio, inicie o servidor HTTP, fa√ßa uma solicita√ß√£o no formato: <br><a name="habracut"></a><br><pre><code class="bash hljs">curl <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/my_picture.jpg?op=resize&amp;max=1920"</span></span></code> </pre> <br>  e, em troca, voc√™ obt√©m uma imagem dimensionada para 1920 pixels no lado comprido. <br><br>  A escolha recaiu nessa tarefa, pois demonstra perfeitamente os cen√°rios para os quais come√ßamos a desenvolver o RESTinio: existe um c√≥digo de longa execu√ß√£o e depurado em C ou C ++, ao qual voc√™ precisa anexar uma entrada HTTP e come√ßar a responder √†s solicita√ß√µes recebidas.  Ao mesmo tempo, o que √© importante, o processamento do aplicativo de uma solicita√ß√£o pode levar um tempo consider√°vel e, portanto, n√£o √© rent√°vel extrair o c√≥digo do aplicativo diretamente no contexto de E / S.  O servidor HTTP deve ser ass√≠ncrono: aceite e analise a solicita√ß√£o HTTP, forne√ßa a solicita√ß√£o analisada em algum lugar para processamento adicional do aplicativo, continue atendendo √† pr√≥xima solicita√ß√£o HTTP, retorne a retornar a resposta √† solicita√ß√£o HTTP quando essa resposta for preparada por algu√©m. <br><br>  √â exatamente o que acontece ao processar solicita√ß√µes de dimensionamento de imagens.  Um servidor HTTP pode fazer seu trabalho direto (ou seja, ler dados, analisar uma solicita√ß√£o HTTP) em uma fra√ß√£o de milissegundo.  Mas dimensionar uma imagem pode levar dezenas, centenas ou at√© milhares de milissegundos. <br><br>  E como pode levar muito tempo para dimensionar uma imagem, voc√™ precisa garantir que o servidor HTTP possa continuar funcionando enquanto a imagem √© dimensionada.  Para fazer isso, precisamos espalhar o trabalho do servidor HTTP e dimensionar imagens para diferentes contextos de trabalho.  No caso simples, ser√£o diferentes segmentos de trabalho.  Bem, como vivemos em processadores com v√°rios n√∫cleos, teremos v√°rios threads de trabalho.  Alguns deles servir√£o solicita√ß√µes HTTP, outros funcionar√£o com imagens. <br><br>  Acontece que, para distribuir imagens escalon√°veis ‚Äã‚Äãvia HTTP, precisamos reutilizar o c√≥digo C / C ++ de grava√ß√£o longa e funcional (neste caso ImageMagic ++), atender solicita√ß√µes HTTP de forma ass√≠ncrona e executar o processamento de solicita√ß√µes de aplicativos em v√°rios fluxos de trabalho.  Uma excelente tarefa para o RESTinio e o SObjectizer, como nos pareceu. <br><br>  E decidimos nomear nosso camar√£o do projeto de demonstra√ß√£o. <br><br><h1>  Camar√£o como √© </h1><br><h2>  O que o camar√£o faz? </h2><br>  O Shrimp √© executado como um aplicativo de console, abre e escuta na porta especificada, recebe e processa solicita√ß√µes HTTP GET do formul√°rio: <br><br><pre> <code class="hljs xml">/<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">image</span></span></span><span class="hljs-tag">&gt;</span></span>.<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ext</span></span></span><span class="hljs-tag">&gt;</span></span> /<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">image</span></span></span><span class="hljs-tag">&gt;</span></span>.<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ext</span></span></span><span class="hljs-tag">&gt;</span></span>?op=resize&amp;<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">side</span></span></span><span class="hljs-tag">&gt;</span></span>=<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Onde: <br><br><ul><li>  image √© o nome do arquivo de imagem a ser dimensionado.  Por exemplo, my_picture ou DSCF0069; </li><li>  ext √© uma das extens√µes suportadas por camar√£o (jpg, jpeg, png ou gif); </li><li>  side √© uma indica√ß√£o do lado para o qual o tamanho est√° definido.  Pode ter um valor de largura; nesse caso, a imagem √© redimensionada para que a largura resultante seja igual ao valor especificado, a altura da imagem √© selecionada automaticamente, mantendo a propor√ß√£o da imagem.  Ou o valor da altura, nesse caso, a escala ocorre na altura.  No m√°ximo, neste caso, o lado comprido √© limitado e o pr√≥prio camar√£o determina se o lado comprido √© altura ou largura; </li><li>  value √© o tamanho em que a escala ocorre. </li></ul><br>  Se apenas o nome do arquivo for especificado na URL, sem a opera√ß√£o de redimensionamento, o camar√£o simplesmente retornar√° a imagem original na resposta.  Se a opera√ß√£o de redimensionamento for especificada, o camar√£o altera o tamanho da imagem solicitada e fornece a vers√£o em escala. <br><br>  Ao mesmo tempo, o camar√£o mant√©m na mem√≥ria um cache de imagens em escala.  Se uma imagem for solicitada repetidamente com os mesmos par√¢metros de redimensionamento, que j√° est√£o no cache, o valor do cache ser√° retornado.  Se n√£o houver imagem no cache, a imagem ser√° lida no disco, dimensionada, armazenada no cache e retornada em resposta. <br><br>  O cache √© limpo periodicamente.  As imagens que permanecem no cache h√° mais de uma hora desde o √∫ltimo acesso a elas s√£o removidas.  Al√©m disso, as imagens mais antigas s√£o jogadas para fora do cache se o cache exceder seu tamanho m√°ximo (em um projeto de demonstra√ß√£o √© de 100 Mb). <br><br>  Preparamos uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">p√°gina</a> na qual qualquer pessoa pode experimentar camar√£o: <br><br><img src="https://habrastorage.org/webt/uv/vr/-q/uvvr-qtt1xovbi_k-ieoyrpvq-y.jpeg"><br><br>  Nesta p√°gina, voc√™ pode definir o tamanho da imagem e clicar em "Redimensionar".  Dois pedidos ser√£o feitos ao servidor camar√£o com os mesmos par√¢metros.  Provavelmente, a primeira solicita√ß√£o ser√° exclusiva (ou seja, ainda n√£o haver√° um cache com esses par√¢metros de redimensionamento), portanto, a primeira solicita√ß√£o levar√° algum tempo para realmente dimensionar a imagem.  E a segunda solicita√ß√£o, provavelmente, encontrar√° a imagem j√° escalada no cache e a fornecer√° imediatamente. <br><br>  √â poss√≠vel julgar se uma imagem √© fornecida a partir do cache ou se realmente foi dimensionada pelo texto sob a imagem.  Por exemplo, o texto "Transformado (114.0ms)" indica que a imagem foi dimensionada e a opera√ß√£o de zoom levou 114 milissegundos. <br><br><h2>  Como o camar√£o faz isso? </h2><br>  O Shrimp √© um aplicativo multithread que executa tr√™s grupos de threads de trabalho: <br><br><ol><li>  O conjunto de threads de trabalho executando o servidor HTTP.  Nesse pool, novas conex√µes s√£o atendidas, solicita√ß√µes de entrada s√£o recebidas e analisadas, respostas s√£o geradas e enviadas.  O servidor HTTP √© implementado atrav√©s da biblioteca RESTinio. </li><li>  Um encadeamento de trabalho separado no qual o agente SO transforma√ß√£o de transform_manager √© executado.  Este agente processa solicita√ß√µes recebidas do servidor HTTP e mant√©m um cache de imagens em escala. </li><li>  O conjunto de encadeamentos no qual os agentes do SObjectizer est√£o trabalhando nos transformadores.  Eles realizam o dimensionamento real das imagens usando o ImageMagic ++. </li></ol><br>  Acontece o seguinte esquema de trabalho: <br><br><img src="https://habrastorage.org/webt/ns/ov/sj/nsovsjushv0zxasu_cq3ur0dy6m.png"><br><br>  O servidor HTTP aceita a solicita√ß√£o recebida, analisa-a e verifica a corre√ß√£o.  Se essa solicita√ß√£o n√£o exigir uma opera√ß√£o de redimensionamento, o pr√≥prio servidor HTTP processar√° a solicita√ß√£o por meio da opera√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sendfile</a> .  Se a solicita√ß√£o exigir uma opera√ß√£o de redimensionamento, a solicita√ß√£o ser√° enviada de forma ass√≠ncrona para o agente transform_manager. <br><br>  O agente transform_manager recebe solicita√ß√µes do servidor HTTP, verifica a presen√ßa de imagens j√° dimensionadas no cache.  Se houver uma imagem no cache, o transform_manager gera imediatamente uma resposta para o servidor HTTP.  Se n√£o houver imagem, o transform_manager envia uma solicita√ß√£o para dimensionar a imagem para um dos agentes do transformador.  Quando o resultado da escala vem do transformador, o resultado √© armazenado no cache e uma resposta √© gerada para o servidor HTTP. <br><br>  O agente transformador recebe solicita√ß√µes de transform_manager, as processa e retorna o resultado da transforma√ß√£o de volta ao agente transform_manager. <br><br><h2>  O que o camar√£o tem sob o cap√¥? </h2><br>  O c√≥digo fonte da vers√£o mais m√≠nima do camar√£o descrita neste artigo pode ser encontrado neste reposit√≥rio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">shrimp-demo no BitBucket</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no GitHub</a> . <br><br>  H√° muito c√≥digo, embora, na maioria das vezes, nesta vers√£o do camar√£o, o c√≥digo seja bastante trivial.  No entanto, faz sentido se concentrar em alguns aspectos da implementa√ß√£o. <br><br><h3>  Usando C ++ 17 e as vers√µes mais recentes do compilador </h3><br>  Na implementa√ß√£o do camar√£o, decidimos usar o C ++ 17 e as vers√µes mais recentes dos compiladores, em particular o GCC 7.3 e 8.1.  O projeto √© fortemente pesquisado.  Portanto, uma introdu√ß√£o pr√°tica ao C ++ 17 no √¢mbito de um projeto desse tipo √© natural e admiss√≠vel.  Enquanto em desenvolvimentos mais mundanos focados em aplica√ß√µes industriais pr√°ticas aqui e agora, somos for√ßados a olhar para compiladores bastante antigos e usar talvez o C ++ 14, ou mesmo apenas um subconjunto do C ++ 11. <br><br>  Devo dizer que o C ++ 17 causa uma boa impress√£o.  Parece que n√£o usamos tantas inova√ß√µes do d√©cimo s√©timo padr√£o no c√≥digo do camar√£o, mas elas tiveram um efeito positivo: o atributo [[nodiscard]], std :: opcional / std :: variant / std :: filesystem diretamente " pronto para uso ‚Äù, e n√£o a partir de depend√™ncias externas, liga√ß√£o estruturada, se for o caso, a capacidade de reunir visitantes para lambdas para std :: visit ... Individualmente, todos esses s√£o insignificantes, mas juntos eles produzem um poderoso efeito cumulativo. <br><br>  Portanto, o primeiro resultado √∫til que obtivemos ao desenvolver o camar√£o: C ++ 17 vale a pena mudar para ele. <br><br><h3>  Servidor HTTP usando ferramentas RESTinio </h3><br>  Talvez a parte mais f√°cil do camar√£o tenha sido o servidor HTTP e o manipulador de solicita√ß√µes HTTP GET ( <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/v0.2/dev/shrimp/">http_server.hpp</a> e <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/v0.2/dev/shrimp/">http_server.cpp</a> ). <br><br><h4>  Receber e enviar solicita√ß√µes de entrada </h4><br>  Essencialmente, toda a l√≥gica b√°sica do servidor HTTP de camar√£o est√° concentrada nesta fun√ß√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_transform_op_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">app_params_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; app_params, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">http_req_router_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; router, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req_handler_mbox )</span></span></span><span class="hljs-function"> </span></span>{ router.http_get( <span class="hljs-string"><span class="hljs-string">R"(/:path(.*)\.:ext(.{3,4}))"</span></span>, restinio::path2regex::<span class="hljs-keyword"><span class="hljs-keyword">options_t</span></span>{}.strict( <span class="hljs-literal"><span class="hljs-literal">true</span></span> ), [req_handler_mbox, &amp;app_params]( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> params ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( has_illegal_path_components( req-&gt;header().path() ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( req ) ); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> opt_image_format = image_format_from_extension( params[ <span class="hljs-string"><span class="hljs-string">"ext"</span></span> ] ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !opt_image_format ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( req ) ); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( req-&gt;header().query().empty() ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> serve_as_regular_file( app_params.m_storage.m_root_dir, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( req ), *opt_image_format ); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> qp = restinio::parse_query( req-&gt;header().query() ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-string"><span class="hljs-string">"resize"</span></span> != restinio::value_or( qp, <span class="hljs-string"><span class="hljs-string">"op"</span></span>sv, <span class="hljs-string"><span class="hljs-string">""</span></span>sv ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( req ) ); } handle_resize_op_request( req_handler_mbox, *opt_image_format, qp, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( req ) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_accepted(); } ); }</code> </pre> <br>  Essa fun√ß√£o prepara o manipulador de solicita√ß√µes HTTP GET usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">roteador</a> RESTinio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ExpressJS</a> .  Quando o servidor HTTP recebe uma solicita√ß√£o GET, cuja URL se enquadra na express√£o regular especificada, a fun√ß√£o lambda especificada √© chamada. <br><br>  Essa fun√ß√£o lambda faz algumas verifica√ß√µes simples sobre a exatid√£o da solicita√ß√£o, mas, principalmente, seu trabalho se resume a uma escolha simples: se o redimensionamento n√£o estiver definido, a imagem solicitada ser√° retornada em sua forma original usando um arquivo de envio eficaz do sistema.  Se o modo de redimensionamento estiver configurado, uma mensagem ser√° gerada e enviada ao agente transform_manager: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_resize_op_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; req_handler_mbox, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">image_format_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> image_format, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> restinio::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">query_string_params_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; qp, restinio::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">request_handle_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req )</span></span></span><span class="hljs-function"> </span></span>{ try_to_handle_request( [&amp;]{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> op_params = transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span>::make( restinio::opt_value&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> &gt;( qp, <span class="hljs-string"><span class="hljs-string">"width"</span></span> ), restinio::opt_value&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> &gt;( qp, <span class="hljs-string"><span class="hljs-string">"height"</span></span> ), restinio::opt_value&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> &gt;( qp, <span class="hljs-string"><span class="hljs-string">"max"</span></span> ) ); transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_params_constraints_t</span></span>{}.check( op_params ); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> image_path{ req-&gt;header().path() }; so_5::send&lt; so_5::mutable_msg&lt;<span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt;&gt;( req_handler_mbox, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(image_path), image_format, op_params ); }, req ); }</code> </pre> <br>  Acontece que o servidor HTTP, tendo aceitado a solicita√ß√£o de redimensionamento, a entrega ao agente transform_manager por meio de uma mensagem ass√≠ncrona e continua a atender a outras solicita√ß√µes. <br><br><h4>  Compartilhamento de arquivos com sendfile </h4><br>  Se o servidor HTTP detectar uma solicita√ß√£o para a imagem original, sem a opera√ß√£o de redimensionamento, o servidor envia imediatamente essa imagem atrav√©s da opera√ß√£o sendfile.  O c√≥digo principal associado a isso √© o seguinte (o c√≥digo completo para esta fun√ß√£o pode ser encontrado <a href="">no reposit√≥rio</a> ): <br><br><pre> <code class="cpp hljs">[[nodiscard]] restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handling_status_t</span></span> serve_as_regular_file( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp; root_dir, restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handle_t</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> image_format ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> full_path = make_full_path( root_dir, req-&gt;header().path() ); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> sf = restinio::sendfile( full_path ); ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> set_common_header_fields_for_image_resp( file_stat.st_mtim.tv_sec, resp ) .append_header( restinio::http_field::content_type, image_content_type_from_img_format( image_format ) ) .append_header( http_header::shrimp_image_src, image_src_to_str( http_header::<span class="hljs-keyword"><span class="hljs-keyword">image_src_t</span></span>::sendfile ) ) .set_body( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( sf ) ) .done(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(...) {} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_404_response( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( req ) ); }</code> </pre> <br>  O ponto principal aqui √© chamar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">restinio :: sendfile ()</a> e, em seguida, passar o valor retornado por esta fun√ß√£o para set_body (). <br><br>  A fun√ß√£o restinio :: sendfile () cria uma opera√ß√£o de upload de arquivo usando a API do sistema.  Quando essa opera√ß√£o √© passada para set_body (), o RESTinio entende que o conte√∫do do arquivo especificado em restinio :: sendfile () ser√° usado para o corpo da resposta HTTP.  Em seguida, ele usa a API do sistema para gravar o conte√∫do desse arquivo no soquete TCP. <br><br><h3>  Implementando o cache de imagem </h3><br>  O agente transform_manager armazena o cache de imagens convertidas, onde as imagens s√£o colocadas ap√≥s o dimensionamento.  Esse cache √© um cont√™iner personalizado simples que fornece acesso ao seu conte√∫do de duas maneiras: <br><br><ol><li>  Procurando um elemento por chave (semelhante √† maneira como isso acontece nos cont√™ineres padr√£o std :: map e std :: unordered_map). </li><li>  Acessando o item de cache mais antigo. </li></ol><br>  O primeiro m√©todo de acesso √© usado quando precisamos verificar a disponibilidade da imagem no cache.  A segunda √© quando exclu√≠mos as imagens mais antigas do cache. <br><br>  N√£o come√ßamos a procurar algo pronto para esses fins na Internet.  Provavelmente o Boost.MultiIndex seria bastante adequado aqui.  Mas como eu n√£o queria arrastar o Boost apenas pelo MultiIndex, fizemos <a href="">nossa implementa√ß√£o trivial</a> literalmente de joelhos.  Parece funcionar;) <br><br><h3>  Fila de solicita√ß√µes pendentes no transform_manager </h3><br>  O agente transform_manager, apesar de seu tamanho bastante decente (um <a href="">arquivo hpp de</a> cerca de 250 linhas e um <a href="">arquivo cpp de</a> cerca de 270 linhas), em nossa implementa√ß√£o mais simples de camar√£o, acabou sendo bastante trivial, em nossa opini√£o. <br><br>  Uma das coisas que contribui significativamente para a complexidade e quantidade de c√≥digo do agente √© a presen√ßa n√£o apenas de um cache de imagens transformadas no transform_manager, mas tamb√©m de filas de solicita√ß√µes pendentes. <br><br>  Temos um n√∫mero limitado de agentes de transforma√ß√£o (em princ√≠pio, seu n√∫mero deve corresponder aproximadamente ao n√∫mero de n√∫cleos de processamento dispon√≠veis).  Se mais solicita√ß√µes forem simult√¢neas do que transformadores livres, poderemos responder imediatamente negativamente √† solicita√ß√£o ou enfileir√°-la.  E ent√£o retire-o da fila quando um transformador livre aparecer. <br><br>  No camar√£o, usamos uma fila de pedidos em espera, definida da seguinte forma: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pending_request_t</span></span></span><span class="hljs-class"> {</span></span> transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span> m_key; <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt; m_cmd; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::steady_clock::time_point m_stored_at; <span class="hljs-keyword"><span class="hljs-keyword">pending_request_t</span></span>( transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span> key, <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt; cmd, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::steady_clock::time_point stored_at ) : m_key{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(key) } , m_cmd{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd) } , m_stored_at{ stored_at } {} }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pending_request_queue_t</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">pending_request_t</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">pending_request_queue_t</span></span> m_pending_requests; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> max_pending_requests{ <span class="hljs-number"><span class="hljs-number">64u</span></span> };</code> </pre> <br>  Ap√≥s o recebimento da solicita√ß√£o, n√≥s a colocamos na fila, fixando o hor√°rio de recebimento da solicita√ß√£o.  Periodicamente, verificamos se o tempo limite dessa solicita√ß√£o expirou.  De fato, em princ√≠pio, pode acontecer que um pacote de solicita√ß√µes "pesadas" tenha chegado mais cedo, cujo processamento demorou muito.  √â errado esperar incessantemente que um transformador gratuito apare√ßa; √© melhor enviar uma resposta negativa ao cliente ap√≥s algum tempo, o que significa que o servi√ßo agora est√° sobrecarregado. <br><br>  H√° tamb√©m um limite de tamanho para a fila de solicita√ß√µes pendentes.  Se a fila j√° atingiu seu tamanho m√°ximo, imediatamente nos recusamos a processar a solicita√ß√£o e informamos ao cliente que estamos sobrecarregados. <br><br>  H√° um ponto importante relacionado √† fila de solicita√ß√µes pendentes, nas quais focaremos na conclus√£o do artigo. <br><br><h4>  Digite sobj_shptr_t e reutilize inst√¢ncias de mensagem </h4><br>  Ao determinar o tipo de fila de pedidos em espera, bem como nas assinaturas de alguns m√©todos do transform_manager, √© poss√≠vel ver o uso do tipo sobj_shptr_t.  Faz sentido se debru√ßar com mais detalhes sobre que tipo √© e por que √© usado. <br><br>  A linha inferior √© que transform_manager recebe uma solicita√ß√£o do servidor HTTP como uma mensagem resize_request_t: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resize_request_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> { restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handle_t</span></span> m_http_req; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_image; <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> m_image_format; transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> m_params; <span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>( restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handle_t</span></span> http_req, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> image, <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> image_format, transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> params ) : m_http_req{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(http_req) } , m_image{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(image) } , m_image_format{ image_format } , m_params{ params } {} };</code> </pre> <br>  e precisamos fazer algo para armazenar essas informa√ß√µes na fila de solicita√ß√µes em espera.  Por exemplo, voc√™ pode criar uma nova inst√¢ncia de resize_request_t e mover os valores da mensagem recebida para ela. <br><br>  E voc√™ pode se lembrar que a pr√≥pria mensagem no SObjectizer √© um objeto criado dinamicamente.  E n√£o √© um objeto simples, mas com um contador de links dentro.  E que no SObjectizer existe um tipo especial de ponteiro inteligente para esses objetos - intrusive_ptr_t. <br><br>  I.e.  n√£o podemos fazer uma c√≥pia de resize_request_t para a fila de solicita√ß√µes em espera, mas podemos simplesmente colocar nessa fila um ponteiro inteligente para uma inst√¢ncia existente de resize_request_t.  O que fazemos  E para n√£o escrever em todos os lugares o nome bastante ex√≥tico so_5 :: intrusive_ptr_t, inserimos nosso alias: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span> = so_5::<span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt;T&gt;;</code> </pre><br><h3>  Respostas ass√≠ncronas aos clientes </h3><br>  Dissemos que as solicita√ß√µes HTTP s√£o processadas de forma ass√≠ncrona.  E mostramos acima como o servidor HTTP envia uma consulta ao agente transform_manager com uma mensagem ass√≠ncrona.  Mas o que acontece com as respostas √†s solicita√ß√µes HTTP? <br><br>  As respostas tamb√©m s√£o exibidas de forma ass√≠ncrona.  Por exemplo, no c√≥digo transform_manager, voc√™ pode ver o seguinte: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_failed_resize( <span class="hljs-keyword"><span class="hljs-keyword">failed_resize_t</span></span> &amp; <span class="hljs-comment"><span class="hljs-comment">/*result*/</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt; cmd ) { do_404_response( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd-&gt;m_http_req) ); }</code> </pre> <br>  Esse c√≥digo gera uma resposta negativa √† solicita√ß√£o HTTP no caso em que a imagem n√£o p√¥de ser dimensionada por algum motivo.  A resposta √© gerada na fun√ß√£o auxiliar do_404_response, cujo c√≥digo pode ser representado da seguinte maneira: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_404_response</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( restinio::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">request_handle_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> resp = req-&gt;create_response( <span class="hljs-number"><span class="hljs-number">404</span></span>, <span class="hljs-string"><span class="hljs-string">"Not Found"</span></span> ); resp.append_header( restinio::<span class="hljs-keyword"><span class="hljs-keyword">http_field_t</span></span>::server, <span class="hljs-string"><span class="hljs-string">"Shrimp draft server"</span></span> ); resp.append_header_date_field(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( req-&gt;header().should_keep_alive() ) resp.connection_keep_alive(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> resp.connection_close(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resp.done(); }</code> </pre> <br>  O primeiro ponto-chave com do_404_response () √© que essa fun√ß√£o √© chamada no contexto de trabalho do agente transform_manager e n√£o no contexto de trabalho do servidor HTTP. <br><br>  O segundo ponto principal √© a chamada para o m√©todo done () no objeto resp totalmente formado.  Toda m√°gica ass√≠ncrona com uma resposta HTTP acontece aqui.  O m√©todo done () pega todas as informa√ß√µes preparadas e as envia de forma ass√≠ncrona para o servidor HTTP.  I.e.  um retorno de do_404_response () ocorrer√° imediatamente ap√≥s o conte√∫do do objeto resp ser enfileirado pelo servidor HTTP. <br><br>  O servidor HTTP em seu contexto de trabalho detectar√° a presen√ßa de uma nova resposta HTTP e come√ßar√° a executar as a√ß√µes necess√°rias para enviar a resposta ao cliente apropriado. <br><br><h3>  Digite datasizable_blob_t </h3><br>  Outro pequeno ponto que faz sentido para esclarecer, porque provavelmente √© incompreens√≠vel sem entender os meandros do RESTinio.  Estamos falando da presen√ßa de, √† primeira vista, um tipo estranho de datasizeable_blob_t, definido da seguinte maneira: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">datasizable_blob_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::enable_shared_from_this&lt; <span class="hljs-keyword"><span class="hljs-keyword">datasizable_blob_t</span></span> &gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_blob.data(); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_blob.length(); } Magick::Blob m_blob; <span class="hljs-comment"><span class="hljs-comment">//! Value for `Last-Modified` http header field. const std::time_t m_last_modified_at{ std::time( nullptr ) }; };</span></span></code> </pre> <br>  Para explicar por que esse tipo √© necess√°rio, voc√™ precisa mostrar como uma resposta HTTP √© formada com uma imagem transformada: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serve_transformed_image</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( restinio::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">request_handle_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">datasizable_blob_shared_ptr_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> blob, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">image_format_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> img_format, http_header::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">image_src_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> image_src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">header_fields_list_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header_fields )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> resp = req-&gt;create_response(); set_common_header_fields_for_image_resp( blob-&gt;m_last_modified_at, resp ) .append_header( restinio::http_field::content_type, image_content_type_from_img_format( img_format ) ) .append_header( http_header::shrimp_image_src, image_src_to_str( image_src ) ) .set_body( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( blob ) ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; hf : header_fields ) { resp.append_header( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( hf.m_name ), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( hf.m_value ) ); } resp.done(); }</code> </pre> <br>  Prestamos aten√ß√£o na chamada para set_body (): um ponteiro inteligente para a inst√¢ncia datasizable_blob_t √© enviado diretamente para l√°.  Porque <br><br>  O fato √© que o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RESTinio suporta v√°rias op√ß√µes para formar o corpo de uma resposta HTTP</a> .  O mais simples √© passar uma inst√¢ncia do tipo std :: string para set_body () e o RESTinio salvar√° o valor dessa string no objeto resp. <br><br>  Mas h√° momentos em que o valor de set_body () deve ser reutilizado em v√°rias respostas ao mesmo tempo.  Por exemplo, no camar√£o, isso acontece quando o camar√£o recebe v√°rios pedidos id√™nticos de transforma√ß√£o da mesma imagem.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesse caso, n√£o √© rent√°vel copiar o mesmo valor em cada resposta. </font><font style="vertical-align: inherit;">Portanto, no RESTinio, h√° uma variante set_body () do formul√°rio:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_body</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt; body)</span></span></span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por√©m, neste caso, uma limita√ß√£o importante √© imposta ao tipo T: ele deve conter os m√©todos public data () e size (), necess√°rios para que o RESTinio possa acessar o conte√∫do da resposta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A imagem em escala no camar√£o √© armazenada como um objeto Magick :: Blob. </font><font style="vertical-align: inherit;">Existe um m√©todo de dados no tipo Magic :: Blob, mas n√£o existe o m√©todo size (), mas existe o m√©todo length (). </font><font style="vertical-align: inherit;">Portanto, precisamos da classe wrapper datasizable_blob_t, que fornece ao RESTinio a interface necess√°ria para acessar o valor do Magick :: Blob.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mensagens peri√≥dicas no transform_manager </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O agente transform_manager precisa fazer v√°rias coisas de tempos em tempos: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puxe as fotos que est√£o no cache por muito tempo. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> controlar o tempo gasto por solicita√ß√µes na fila de espera de transformadores livres. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O agente transform_manager executa essas a√ß√µes por meio de mensagens peri√≥dicas. </font><font style="vertical-align: inherit;">Parece o seguinte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro, os tipos de sinais que ser√£o usados ‚Äã‚Äãcomo mensagens peri√≥dicas s√£o determinados:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clear_cache_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">check_pending_requests_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {};</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Em seguida, o agente √© inscrito, incluindo estes sinais: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::so_define_agent() { so_subscribe_self() .event( &amp;<span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_resize_request ) .event( &amp;<span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_resize_result ) .event( &amp;<span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_clear_cache ) .event( &amp;<span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_check_pending_requests ); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_clear_cache( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">clear_cache_t</span></span>&gt; ) {...} <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_check_pending_requests( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">check_pending_requests_t</span></span>&gt; ) {...}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gra√ßas √† assinatura, o SObjectizer chamar√° o manipulador desejado quando o agente receber o sinal correspondente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E resta apenas executar mensagens peri√≥dicas quando o agente √© iniciado:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::so_evt_start() { m_clear_cache_timer = so_5::send_periodic&lt;<span class="hljs-keyword"><span class="hljs-keyword">clear_cache_t</span></span>&gt;( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, clear_cache_period, clear_cache_period ); m_check_pending_timer = so_5::send_periodic&lt;<span class="hljs-keyword"><span class="hljs-keyword">check_pending_requests_t</span></span>&gt;( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, check_pending_period, check_pending_period ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ponto principal aqui √© salvar timer_id, retornado pelas fun√ß√µes send_periodic (). </font><font style="vertical-align: inherit;">Afinal, um sinal peri√≥dico vir√° apenas enquanto seu timer_id estiver ativo. </font><font style="vertical-align: inherit;">Portanto, se o valor de retorno send_periodic () n√£o for salvo, o envio de uma mensagem peri√≥dica ser√° imediatamente cancelado. </font><font style="vertical-align: inherit;">Portanto, a classe a_transform_manager_t possui os seguintes atributos:</font></font><br><br><pre> <code class="cpp hljs">so_5::<span class="hljs-keyword"><span class="hljs-keyword">timer_id_t</span></span> m_clear_cache_timer; so_5::<span class="hljs-keyword"><span class="hljs-keyword">timer_id_t</span></span> m_check_pending_timer;</code> </pre> <br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fim da primeira parte </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hoje, apresentamos ao leitor a implementa√ß√£o mais simples e minimalista do camar√£o. Essa implementa√ß√£o √© suficiente para mostrar como o RESTinio e o SObjectizer podem ser usados ‚Äã‚Äãjuntos para algo mais ou menos como uma tarefa real, em vez de um simples HelloWorld. Mas tem uma s√©rie de falhas s√©rias. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por exemplo, no agente transform_manager, h√° uma certa verifica√ß√£o da exclusividade da solicita√ß√£o. Mas isso s√≥ funciona se a imagem transformada j√° estiver no cache. Se ainda n√£o houver uma imagem no cache e, ao mesmo tempo, duas solicita√ß√µes id√™nticas vierem para a mesma imagem, ambas as solicita√ß√µes ser√£o enviadas para processamento. O que n√£o √© bom. Seria correto processar apenas um deles e adiar o segundo at√© que o processamento do primeiro seja conclu√≠do.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esse controle mais avan√ßado sobre a exclusividade de solicita√ß√µes levaria a um c√≥digo transform_manager muito mais complexo e volumoso. Portanto, n√£o come√ßamos a implement√°-lo imediatamente, mas decidimos seguir o caminho evolutivo - do simples ao complexo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, a vers√£o mais simples do camar√£o √© uma ‚Äúcaixa preta‚Äù que n√£o mostra sinais de seu trabalho. O que n√£o √© muito conveniente durante o teste e durante a opera√ß√£o. Portanto, de uma maneira boa, o camar√£o tamb√©m deve adicionar registros. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos tentar eliminar essas e algumas outras defici√™ncias da primeira vers√£o do camar√£o em vers√µes futuras e descrev√™-las em artigos futuros. Portanto, fique atento.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se algu√©m tiver d√∫vidas sobre a l√≥gica do camar√£o, RESTinio ou SObjectizer, teremos o maior prazer em responder nos coment√°rios. </font><font style="vertical-align: inherit;">Al√©m disso, o pr√≥prio camar√£o √© um projeto de demonstra√ß√£o, mas se algu√©m estiver interessado em sua funcionalidade e desejar ver algo mais al√©m da opera√ß√£o de redimensionamento, informe-nos, teremos o maior prazer em ouvir quaisquer id√©ias construtivas .</font></font><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Para continuar ...</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt416387/">https://habr.com/ru/post/pt416387/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt416375/index.html">No√ß√µes b√°sicas de JavaScript para iniciantes</a></li>
<li><a href="../pt416377/index.html">N√≥s nos tornamos assistentes em programa√ß√£o. Parte 1</a></li>
<li><a href="../pt416379/index.html">Neurobugurt. Como ensinamos a rede neural a inventar memes um ano antes que Stanford</a></li>
<li><a href="../pt416381/index.html">Relat√≥rio do Club of Rome de 2018, cap√≠tulo 3.13: Filantropia, Investimento, Crowdsourcing e Blockchain</a></li>
<li><a href="../pt416385/index.html">Se a correla√ß√£o sair 100%, algum erro ocorreu em algum lugar: a experi√™ncia de est√°gio no Rambler Group</a></li>
<li><a href="../pt416391/index.html">Otimiza√ß√£o do posicionamento de m√°quinas virtuais em servidores</a></li>
<li><a href="../pt416393/index.html">Confer√™ncia da IIDF: empresas n√£o s√£o vs startups</a></li>
<li><a href="../pt416397/index.html">Automatizamos testes de interface do usu√°rio de aplicativos Android usando o padr√£o Objeto de P√°gina</a></li>
<li><a href="../pt416399/index.html">Como analisamos as an√°lises de aplicativos para dispositivos m√≥veis usando o aprendizado de m√°quina</a></li>
<li><a href="../pt416401/index.html">Blender: modelo 3D de um chip para conectar-se √† biblioteca KiCad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>