<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧝🏼 🥀 🚄 PHP asinkron. Mengapa 👉🏼 🐈 😱</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pemrograman asinkron sangat diminati saat ini, terutama dalam pengembangan web, di mana respons aplikasi sangat penting. Tidak ada yang mau menunggu a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PHP asinkron. Mengapa</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skyeng/blog/448968/"><img src="https://habrastorage.org/webt/vr/yd/zc/vrydzcqx0ogo5vfy-a2uzf0wmgs.jpeg" alt="gambar"><br><br>  Pemrograman asinkron sangat diminati saat ini, terutama dalam pengembangan web, di mana respons aplikasi sangat penting.  Tidak ada yang mau menunggu aplikasi untuk "melorot", bahkan jika pada saat itu menjalankan query ke database, mengirim email atau bekerja pada tugas-tugas lain yang dapat memakan banyak waktu.  Klien menginginkan jawaban atas tindakannya, yang terbaik dari semuanya - segera.  Jika aplikasi Anda lambat, Anda kehilangan pelanggan.  Dihadapkan dengan aplikasi melayang, paling sering pengguna hanya menutupnya dan tidak pernah kembali.  Dari sudut pandang pengguna, aplikasi hanya hang, dia tidak bisa mengerti mengapa ini terjadi: apakah itu melakukan operasi yang kompleks atau telah berhenti bekerja pada prinsipnya. <br><br>  <i>Memperkenalkan terjemahan artikel oleh Skyend backend developer Sergey Zhuk.</i> <br><a name="habracut"></a><br><h3>  App Responsiveness </h3><br>  Aplikasi modern sering responsif, tetapi beberapa tugas atau operasi, seperti bertukar data melalui jaringan, file I / O, atau query database, dapat memakan waktu dan secara signifikan memperlambat aplikasi.  Untuk mencegah operasi seperti memblokir aplikasi, Anda dapat menjalankannya di latar belakang, sehingga menyembunyikan penundaan yang disebabkannya.  Pada saat yang sama, aplikasi tetap responsif karena dapat terus melakukan tugas-tugas lain, misalnya, mengembalikan aliran kontrol ke antarmuka pengguna atau merespons peristiwa lain. <br><br><h3>  Konkurensi dan Asinkron </h3><br>  Ketika orang melihat kode asinkron, paling sering mereka langsung berpikir: "Hebat, saya bisa memparalelkan proses!".  Saya mungkin mengecewakan Anda, tetapi sebenarnya tidak.  Sinkronisasi dan konkurensi bukanlah hal yang sama.  Mungkin sulit untuk menangkap perbedaan ini, jadi mari kita coba mencari tahu. <br><br>  Jika tugas dilakukan secara tidak sinkron, mereka tidak memblokir satu sama lain dan pelaksanaan satu tugas tidak tergantung pada penyelesaian tugas lainnya.  Concurrency, pada gilirannya, menyiratkan peluncuran beberapa tugas terpisah secara bersamaan sebagai unit kerja independen. <br><br>  Sinkronisasi: <br><blockquote>  Pergi dan selesaikan <b>sendiri</b> tugas itu.  Beri tahu saya setelah selesai dan tunjukkan hasilnya.  Pada saat ini, saya dapat terus melakukan pekerjaan saya. </blockquote><br>  Kode asinkron membutuhkan proses dependensi yang muncul selama pelaksanaan tugas, dan ini diimplementasikan menggunakan panggilan balik.  Ketika tugas selesai, kode memberitahukan tugas lain.  Kode asinkron pada dasarnya adalah tentang waktu tugas yang harus diselesaikan (urutan kejadian). <br><img src="https://habrastorage.org/webt/zu/np/3h/zunp3hgp9rim8pbath4tidi_icu.png" alt="gambar"><br>  Concurrency: <br><blockquote>  <b>Pekerjakan pekerja sebanyak yang Anda inginkan,</b> dan bagikan tugas di antara mereka untuk menyelesaikannya lebih cepat, dan beri tahu saya ketika Anda selesai.  Saya dapat terus melakukan hal-hal lain atau, jika tugas ini mendesak, saya akan tinggal dan menunggu sampai Anda kembali dengan hasilnya.  Kemudian saya dapat menyusun hasil akhir dari semua karyawan.  Eksekusi paralel seringkali membutuhkan lebih banyak sumber daya, jadi di sini pada dasarnya tergantung pada perangkat keras. </blockquote><br><img src="https://habrastorage.org/webt/o9/ty/fp/o9tyfphmymspkaemitwjnhrikx0.png" alt="gambar"><br>  Untuk memahami perbedaan antara eksekusi asinkron dan paralel menggunakan contoh nyata, kami membandingkan dua server web populer: Apache dan Nginx.  Mereka dengan sempurna menggambarkan perbedaan ini.  Nginx menggunakan model asinkron berbasis peristiwa sementara Apache menggunakan utas paralel.  Apache membuat utas baru untuk setiap koneksi tambahan, jadi di sini jumlah maksimum koneksi yang diizinkan tergantung pada jumlah memori yang tersedia dalam sistem.  Ketika batas koneksi tercapai, Apache berhenti membuat koneksi tambahan.  Faktor pembatas ketika mengkonfigurasi Apache adalah memori (ingat bahwa eksekusi paralel sering tergantung pada perangkat keras).  Jika utas berhenti, klien menunggu respons hingga utas gratis dan dapat mengirim respons. <br><br>  Nginx tidak berfungsi seperti Apache - tidak membuat utas baru untuk setiap permintaan yang masuk.  Nginx memiliki alur kerja utama (atau beberapa pekerja, seringkali untuk satu prosesor ada satu alur kerja), yang merupakan single-threaded.  Pekerja ini dapat memproses ribuan koneksi "secara bersamaan" dan melakukannya secara serempak, dalam satu utas, dan tidak secara paralel dalam beberapa utas. <br><br>  Jadi, "asinkron" adalah bagaimana kita membangun sistem, itu adalah komposisi proses yang tidak tergantung satu sama lain.  Yang dimaksud dengan "eksekusi paralel" adalah eksekusi beberapa proses pada saat yang bersamaan, sementara mereka mungkin terkait atau tidak.  Dalam eksekusi asinkron, kami memproses beberapa tugas sekaligus, dan dalam eksekusi paralel, kami memulai beberapa proses sekaligus.  Ini mungkin tampaknya hal yang sama, tetapi tidak.  Asynchrony menggambarkan suatu struktur, paralelisme menggambarkan cara melakukannya. <br><br>  Eksekusi asinkron dapat dibandingkan dengan perangkat I / O di komputer Anda (mouse, keyboard, display).  Mereka semua dikelola oleh sistem operasi, tetapi masing-masing merupakan bagian independen dari kernel.  Proses-proses ini tidak sinkron, bisa paralel, tetapi ini tidak perlu.  Jadi, untuk memastikan konsistensi, Anda harus membuat tautan antara bagian-bagian independen ini untuk mengoordinasikannya. <br><br><h3>  Bagaimana dengan backend ini? </h3><br>  Anda dapat mengatakan bahwa respons tidak terlalu penting di backend.  Semua hal asinkron keren dengan JavaScript ini terjadi di freeend, dan server Anda hanya merespons permintaan, jadi freeend harus bertanggung jawab atas respons aplikasi, tetapi bukan Anda.  Ya, itu benar, tetapi tugas server tidak terbatas pada respons API.  Terkadang Anda harus mengelola tugas yang rumit, misalnya mengunduh video.  Dalam hal ini, responsif mungkin bukan faktor kunci, tetapi kurangnya sumber daya terbuang karena aplikasi harus diam.  Itu bisa menunggu penyelesaian operasi sistem file, interaksi jaringan, permintaan basis data, dan sejenisnya.  Seringkali operasi I / O ini sangat lambat dibandingkan dengan perhitungan prosesor, misalnya ketika kita mengonversi file video.  Dan sementara kami perlahan menyimpan atau membaca file, prosesor dipaksa untuk siaga alih-alih melakukan pekerjaan yang bermanfaat.  Seperti yang sudah kita ketahui, alih-alih menunggu, kita dapat menjalankan tugas ini di latar belakang.  Bagaimana?  Silakan. <br><br><h3>  PHP asinkron </h3><br>  Dalam JavaScript, di luar kotak, dukungan bawaan dan solusi untuk menulis kode asinkron tersedia.  Ada juga Node.js, yang memungkinkan Anda untuk menulis aplikasi server asinkron.  Dalam JavaScript, kita dapat menggunakan fungsi setTimeout () untuk menunjukkan contoh kode asinkron: <br><img src="https://habrastorage.org/webt/j-/tx/mt/j-txmtg4lym_eu5fwk2qakt_s08.png" alt="gambar"><br><br>  Ketika kita menjalankan kode ini, kita akan melihat yang berikut: <br><img src="https://habrastorage.org/webt/bk/fk/2r/bkfk2r_onqq6_yhyqzqbzsuqod8.png" alt="gambar"><br><br>  Fungsi setTimeout () mengirimkan kode ke antrian dan menjalankannya di akhir tumpukan panggilan saat ini.  Ini berarti bahwa kami mengganggu aliran kode yang sinkron dan menunda eksekusi.  Panggilan kedua ke console.log () dilakukan sebelum panggilan ke antrian di dalam panggilan setTimeout (). <br><br>  Bagaimana dengan PHP?  Dalam PHP, kami tidak memiliki alat adaptasi yang cocok untuk menulis kode yang benar-benar tidak sinkron.  Tidak ada yang setara dengan setTimeout (), dan kami tidak bisa hanya menunda atau mengantri kode apa pun.  Itu sebabnya kerangka kerja dan pustaka seperti Amp dan ReactPHP mulai muncul.  Gagasan mereka adalah menyembunyikan detail tingkat rendah bahasa dan memberikan alat tingkat tinggi kepada pengguna yang memungkinkan Anda untuk menulis kode asinkron dan mengelola eksekusi proses kompetitif seperti JavaScript dan Node.js. <br><br><h3>  Mengapa saya harus menggunakan PHP jika ada Node.js dan Go? </h3><br>  Pertanyaan ini sering muncul ketika datang ke PHP asinkron.  Untuk beberapa alasan, banyak yang menentang menggunakan PHP untuk menulis kode asinkron.  Seseorang selalu menyarankan menggunakan Go atau Node.js. sebagai ganti PHP. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tweet</a> assertchris dengan sempurna menjelaskan situasi ini: <br><br><img src="https://habrastorage.org/webt/hz/gd/gs/hzgdgsarcixle4sahqsvummqkvs.png" alt="gambar"><br><br>  Tentu saja, ketika PHP baru saja dibuat, tidak ada tujuan untuk menjadikannya bahasa pemrograman yang dapat digunakan untuk membuat aplikasi rumit yang besar.  Saat itu, tidak ada yang memikirkan JavaScript atau asynchrony.  Tetapi sekarang kami memiliki PHP yang sama sekali berbeda yang sudah memiliki fungsinya sendiri untuk menulis kode asinkron (misalnya, fungsi stream_select ()). <br><br>  Ya, Anda bisa menggunakan Go atau Node.js untuk membuat aplikasi server asinkron, tetapi ini tidak selalu menyelesaikan masalah.  Jika Anda sudah memiliki pengalaman luas dengan PHP, akan jauh lebih mudah bagi Anda untuk hanya mempelajari perpustakaan dan alat-alat yang sesuai untuk situasi Anda daripada belajar bahasa baru dan ekosistem baru.  Alat-alat seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ReactPHP</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Amp</a> memungkinkan Anda untuk menulis kode asinkron seperti Anda melakukannya di Node.js.  Alat-alat ini cukup dikembangkan dan memiliki versi stabil, sehingga Anda dapat menggunakannya dengan aman dalam produksi. <br><br><h3>  Bukan hanya CLI </h3><br><blockquote>  Saya tidak akan menulis obrolan, server atau sesuatu seperti itu.  Saya hanya ingin mempercepat situs. </blockquote><br>  Secara umum diterima bahwa kode asinkron hanya dapat digunakan dalam skrip CLI.  Sangat normal untuk mengintegrasikan beberapa komponen asinkron ke dalam lingkungan sinkron tradisional, bahkan ke dalam aplikasi web tradisional.  Misalnya, Anda dapat menerima permintaan dan kemudian memanggil beberapa sumber yang berbeda secara tidak sinkron, dan ketika panggilan ini selesai, Anda dapat melanjutkan siklus hidup permintaan-respons, dan sebagai hasilnya, halaman tersebut akan ditampilkan lebih cepat. <br><br>  Atau Anda perlu melakukan beberapa panggilan API eksternal - misalnya, ketika pengguna menyelesaikan pembayaran, Anda ingin mengirim email atau pemberitahuan push.  Anda dapat membuat panggilan API ini secara tidak sinkron, dan kemudian melanjutkan aliran kode sinkron tradisional Anda.  Tidak perlu sepenuhnya menulis ulang aplikasi dan menghapus semua yang memperlambat.  Identifikasi saja kemacetan yang mengganggu kinerja, dan mungkin saja mereka dapat diperbaiki menggunakan kode asinkron. <br><br>  Ya, kode asinkron dalam banyak kasus masih digunakan dalam skrip CLI, tetapi tidak terbatas pada obrolan dan server waktu nyata.  Jika Anda hanya ingin mempercepat situs Anda, Anda tidak perlu menyerahkan kerangka kerja Symfony atau Laravel Anda dan membuat server aplikasi yang sepenuhnya tidak sinkron. <br><br><h3>  Kesimpulan </h3><br>  Jangan takut untuk belajar paradigma baru.  PHP lebih dari sekadar "menjalankan skrip, menjalankan kode, dan mati."  Anda akan terkejut ketika Anda menyadari bahwa Anda dapat menggunakan PHP yang akrab dengan cara yang sama sekali baru, seperti Anda tidak pernah menggunakannya!  Kode asinkron dan pemrograman berorientasi peristiwa akan memperluas pemahaman Anda tentang PHP dan kemungkinan menggunakan bahasa ini.  Anda tidak perlu belajar bahasa baru untuk menulis aplikasi asinkron hanya karena "PHP adalah alat yang tidak pantas" atau "Saya selalu melakukan ini, itu tidak dapat diperbaiki."  Cobalah! <br><br>  Yah, kami juga mengingatkan Anda bahwa kami selalu memiliki banyak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lowongan menarik</a> untuk pengembang! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id448968/">https://habr.com/ru/post/id448968/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id448958/index.html">Bagaimana Amazon mengambil penawaran yang tampaknya acak hari ini. Dan mengapa penjual begitu mengejar mereka</a></li>
<li><a href="../id448960/index.html">Teknologi XR tanpa batas di era komputasi terdistribusi</a></li>
<li><a href="../id448962/index.html">Efektivitas saluran pemasaran AARRR</a></li>
<li><a href="../id448964/index.html">Pemanggang memberi pengguna lebih banyak hak</a></li>
<li><a href="../id448966/index.html">Aplikasi Android dalam memori. Laporan Pengoptimalan untuk Yandex.Luncher</a></li>
<li><a href="../id448970/index.html">Otentikasi dua faktor untuk SSH</a></li>
<li><a href="../id448974/index.html">Pendekatan tanpa server untuk pengembangan cepat layanan video yang berfungsi</a></li>
<li><a href="../id448976/index.html">Peristiwa musim semi Gamedev di HSE</a></li>
<li><a href="../id448980/index.html">Makan siang pertama kami bersama: mengapa dan bagaimana kami menghabiskan hari ujian kami</a></li>
<li><a href="../id448982/index.html">CMS tanpa kepala. Kenapa aku menulis milikku</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>