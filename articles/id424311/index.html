<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚛 🥄 👩🏻‍⚖️ Logika bisnis asinkron hari ini 🤟 🚱 👐🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Singkatnya: 


- Buktinya sudah diimplementasikan dalam C ++ , JS dan PHP , cocok untuk Java . 
- Lebih cepat dari coroutine dan Promise, lebih banyak...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Logika bisnis asinkron hari ini</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424311/"><p>  Singkatnya: </p><br><blockquote><ul><li>  Buktinya sudah diimplementasikan dalam <strong>C ++</strong> , <strong>JS</strong> dan <strong>PHP</strong> , cocok untuk <strong>Java</strong> . </li><li> <strong>Lebih cepat</strong> dari coroutine dan Promise, lebih banyak fitur. </li><li>  Itu tidak memerlukan tumpukan perangkat lunak terpisah. </li><li>  Berteman dengan semua alat keamanan dan debugging. </li><li>  Ia bekerja pada arsitektur apa pun dan tidak memerlukan flag kompiler khusus. </li></ul><br></blockquote><a name="habracut"></a><br><hr><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lihatlah ke belakang</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FutoIn AsyncSteps - sebuah alternatif untuk coroutine</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ke nomor</a> </li></ul><br><h2 id="vzglyad-nazad">  Lihatlah ke belakang </h2><br><p>  Pada awal komputer, ada aliran kontrol tunggal dengan memblokir input-output.  Kemudian interupsi besi ditambahkan ke dalamnya.  Sekarang Anda dapat secara efektif menggunakan perangkat yang lambat dan tidak dapat diprediksi. </p><br><p>  Dengan pertumbuhan kemampuan besi dan ketersediaannya yang rendah, menjadi perlu untuk melakukan beberapa tugas secara bersamaan, yang memberikan dukungan perangkat keras.  Jadi ada proses terisolasi dengan interupsi yang disarikan dari besi dalam bentuk sinyal. </p><br><p>  Tahap evolusi berikutnya adalah multithreading, yang diimplementasikan atas dasar proses yang sama, tetapi dengan akses bersama ke memori dan sumber daya lainnya.  Pendekatan ini memiliki keterbatasan dan overhead yang signifikan untuk beralih ke OS yang aman. </p><br><p>  Untuk komunikasi antara proses dan bahkan mesin yang berbeda, abstraksi Janji / Masa Depan diusulkan 40+ tahun yang lalu. </p><br><p>  Antarmuka pengguna dan masalah klien 10K yang saat ini menggelikan telah menyebabkan masa kejayaan pendekatan Event Loop, Reactor, dan Proactor, yang lebih berorientasi pada peristiwa daripada logika bisnis yang jelas dan konsisten. </p><br><p>  Akhirnya, kami sampai pada coroutine modern (coroutine), yang pada dasarnya adalah emulasi aliran di atas abstraksi yang dijelaskan di atas dengan keterbatasan teknis yang sesuai dan transfer kontrol deterministik. </p><br><p>  Untuk menyampaikan peristiwa, hasil, dan pengecualian, semuanya kembali ke konsep Janji / Masa Depan yang sama.  Beberapa kantor memutuskan untuk memberi nama sedikit berbeda - "Tugas". </p><br><p> Pada akhirnya, mereka menyembunyikan semuanya dalam paket <code>async/await</code> indah, yang membutuhkan dukungan kompiler atau penerjemah tergantung pada teknologinya. </p><br><h3 id="problemy-s-tekuschiy-situaciy-asinhronnoy-biznes-logiki">  Masalah dengan situasi logika bisnis asinkron saat ini </h3><br><p>  Anggap saja coroutine dan Promise, yang dihiasi <code>async/await</code> , sebagai  keberadaan masalah dalam pendekatan yang lebih lama menegaskan proses evolusi itu sendiri. </p><br><p>  Kedua istilah ini tidak identik.  Sebagai contoh, dalam ECMAScript tidak ada coroutine, tetapi ada bantuan sintaksis untuk menggunakan <code>Promise</code> , yang pada gilirannya hanya mengatur pekerjaan dengan neraka panggilan balik.  Bahkan, mesin scripting seperti V8 melangkah lebih jauh dan melakukan optimasi khusus untuk fungsi dan panggilan <code>async/await</code> murni. </p><br><p>  Para ahli <code>co_async/co_await</code> yang tidak termasuk dalam C ++ 17 di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini tentang sumber daya</a> , tetapi tekanan dari coroutine raksasa perangkat lunak dapat muncul dalam standar persis dalam bentuknya.  Sementara itu, solusi yang diakui secara tradisional adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Boost.Context</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Boost.Fiber</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Boost.Coroutine2</a> . </p><br><p>  Di Jawa, masih belum ada <code>async/await</code> di tingkat bahasa, tetapi ada solusi seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">EA Async</a> , yang, seperti Boost.Context, perlu disesuaikan untuk setiap versi JVM dan byte kode. </p><br><p>  Go memiliki coroutine sendiri, tetapi jika Anda hati-hati melihat artikel dan laporan bug proyek terbuka, ternyata di sini semuanya tidak begitu lancar.  Mungkin kehilangan antarmuka coroutine sebagai entitas yang dikelola bukanlah ide yang baik. </p><br><h4 id="mnenie-avtora-soprogrammy-na-golom-zheleze-opasny">  Opini Penulis: coroutine bare-metal berbahaya </h4><br><p>  Secara pribadi, penulis memiliki sedikit terhadap coroutine dalam bahasa yang dinamis, tetapi ia sangat waspada terhadap godaan dengan tumpukan di tingkat kode mesin. </p><br><p>  Beberapa poin: </p><br><ol><li>  Diperlukan tumpukan: <br><ul><li>  tumpukan di heap memiliki sejumlah kelemahan: masalah penentuan tepat waktu meluap, kerusakan oleh tetangga dan masalah keandalan / keamanan lainnya, </li><li>  tumpukan aman memerlukan setidaknya satu halaman memori fisik, satu halaman bersyarat dan overhead tambahan untuk setiap panggilan ke fungsi <code>async</code> : 4 + KB (minimum) + peningkatan batas sistem, </li><li>  pada akhirnya, mungkin sebagian besar memori yang dialokasikan untuk tumpukan tidak digunakan selama downtime coroutine. </li></ul></li><li>  Kita perlu menerapkan logika kompleks untuk menyelamatkan, memulihkan, dan menghapus status coroutine: <br><ul><li>  untuk setiap kasus arsitektur prosesor (bahkan model) dan antarmuka biner (ABI): <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh</a> , </li><li>  fitur arsitektur baru atau opsional menimbulkan masalah yang berpotensi laten (misalnya, Intel TSX, co-prosesor ARM atau MIPS), </li><li>  potensi masalah lain karena sistem tertutup dokumentasi tertutup (Dokumentasi Boost merujuk pada ini). </li></ul></li><li>  Masalah potensial dengan alat analisis dinamis dan keamanan secara umum: <br><ul><li>  misalnya, integrasi dengan Valgrind diperlukan semua karena tumpukan lompatan yang sama, </li><li>  sulit untuk berbicara tentang antivirus, tetapi mungkin mereka tidak begitu suka pada contoh masalah dengan JVM di masa lalu, </li><li>  Saya yakin jenis serangan baru akan muncul dan kerentanan yang terkait dengan penerapan coroutine akan terungkap. </li></ul></li></ol><br><h4 id="mnenie-avtora-generatory-i-yield-principialnoe-zlo">  Pendapat penulis: generator dan <code>yield</code> kejahatan mendasar </h4><br><p>  Tema pihak ketiga yang tampaknya terkait langsung dengan konsep coroutine dan properti "terus". </p><br><p>  Singkatnya, iterator lengkap harus ada untuk koleksi apa pun.  Mengapa membuat masalah iterator-generator yang dipangkas tidak jelas.  Misalnya, case dengan <code>range()</code> dalam Python lebih merupakan pamer eksklusif daripada alasan untuk komplikasi teknis. </p><br><p>  Jika case adalah generator tanpa batas, maka logika implementasinya adalah elementer.  Mengapa membuat kesulitan teknis tambahan untuk mendorong siklus berkelanjutan tanpa akhir. </p><br><p>  Satu-satunya pembenaran yang masuk akal yang kemudian muncul yang diberikan oleh pendukung coroutine adalah segala macam pengurai aliran dengan kontrol terbalik.  Bahkan, ini adalah kasus khusus yang sempit untuk memecahkan masalah tunggal di tingkat perpustakaan, bukan logika bisnis aplikasi.  Pada saat yang sama ada solusi yang elegan, sederhana dan lebih deskriptif melalui mesin negara yang terbatas.  Area masalah teknis ini jauh lebih kecil daripada area logika bisnis biasa. </p><br><p>  Bahkan, masalah yang harus dipecahkan diperoleh dari jari dan membutuhkan upaya yang relatif serius untuk implementasi awal dan dukungan jangka panjang.  Sedemikian rupa sehingga beberapa proyek dapat memperkenalkan larangan penggunaan coroutine tingkat kode mesin mengikuti contoh larangan <code>goto</code> atau penggunaan alokasi memori dinamis dalam industri individu. </p><br><h4 id="mnenie-avtora-model-asyncawait-na-promise-iz-ecmascript-bolee-nadyozhna-no-trebuet-adaptacii">  Pendapat penulis: Model Promyn <code>async/await</code> ECMAScript lebih dapat diandalkan, tetapi membutuhkan adaptasi </h4><br><p>  Tidak seperti melanjutkan coroutine, dalam model ini potongan-potongan kode diam-diam dibagi menjadi blok non-interruptible yang dirancang sebagai fungsi anonim.  Dalam C ++, ini tidak sepenuhnya cocok karena kekhasan manajemen memori, contoh: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeObject</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Value = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;; <span class="hljs-function"><span class="hljs-function">Promise </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">funcPromise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Promise.resolved(value_); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">funcCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::function&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">()&gt; &amp;&amp;cb, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value&amp; val)</span></span></span><span class="hljs-function"> </span></span>{ somehow_call_later(cb); } Value value_; }; <span class="hljs-function"><span class="hljs-function">Promise </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ SomeObject some_obj; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> some_obj.funcPromise() .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>([](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception &amp;e){ <span class="hljs-comment"><span class="hljs-comment">// ... }) .then([&amp;](SomeObject::value &amp;&amp;val){ return Promise([&amp;](Resolve&amp;&amp; resolve, Reject&amp;&amp;){ some_obj.funcCallback(resolve, val); }); }); }</span></span></code> </pre> <br><p>  Pertama, <code>some_obj</code> akan dihancurkan ketika keluar dari <code>example()</code> dan sebelum memanggil fungsi lambda. </p><br><p>  Kedua, fungsi lambda dengan menangkap variabel atau referensi adalah objek dan diam-diam menambahkan copy / move, yang dapat secara negatif mempengaruhi kinerja dengan sejumlah besar tangkapan dan kebutuhan untuk mengalokasikan memori pada heap selama penghapusan tipe pada <code>std::function</code> biasa. </p><br><p>  Ketiga, antarmuka <code>Promise</code> itu sendiri dikandung pada konsep "janji" dari hasil, daripada pelaksanaan logika bisnis yang konsisten. </p><br><p>  Solusi skema TIDAK optimal mungkin terlihat seperti ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Promise </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalContext</span></span></span><span class="hljs-class"> {</span></span> SomeObject some_obj; }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ctx = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;LocalContext&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> some_obj.funcPromise() .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>([](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception &amp;e){ <span class="hljs-comment"><span class="hljs-comment">// ... }) .then([ctx](SomeObject::Value &amp;&amp;val){ struct LocalContext2 { LocalContext2(std::shared_ptr&lt;LocalContext&gt; &amp;&amp;ctx, SomeObject::Value &amp;&amp;val) : ctx(ctx), val(val) {} std::shared_ptr&lt;LocalContext&gt; ctx; SomeObject::Value val; }; auto ctx2 = std::make_shared&lt;LocalContext2&gt;( std::move(ctx), std::forward&lt;SomeObject::Value&gt;(val) ); return Promise([ctx2](Resolve&amp;&amp; resolve, Reject&amp;&amp;){ ctx2-&gt;ctx-&gt;some_obj.funcCallback([ctx2, resolve](){ resolve(); }, val); }); }); }</span></span></code> </pre> <br><p>  <em>Catatan: <code>std::move</code> bukannya <code>std::shared_ptr</code> tidak cocok karena ketidakmampuan untuk mentransfer ke beberapa lambda sekaligus dan pertumbuhan ukurannya.</em> </p><br><p>  Dengan tambahan <code>async/await</code> kengerian asinkron datang dalam kondisi yang dapat dicerna: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">async </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ SomeObject some_obj; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { SomeObject::Value val = await some_obj.func(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception&amp; e) ( <span class="hljs-comment"><span class="hljs-comment">// ... } // Capture "async context" return Promise([async](Resolve&amp;&amp; resolve, Reject&amp;&amp;){ some_obj.funcCallback([async](){ resolve(); }, val); }); }</span></span></code> </pre> <br><h4 id="mnenie-avtora-planirovschik-soprogramm---eto-perebor">  Pendapat penulis: perencana coroutine adalah sebuah kegagalan </h4><br><p>  Beberapa kritik menyebut kurangnya penjadwal dan penggunaan sumber daya prosesor yang “tidak adil” merupakan masalah.  Mungkin masalah yang lebih serius adalah lokalitas data dan penggunaan cache prosesor yang efisien. </p><br><p>  Pada masalah pertama: penentuan prioritas pada tingkat masing-masing coroutine terlihat seperti biaya overhead yang besar.  Sebaliknya, mereka dapat dioperasikan pada kesamaan untuk tugas terpadu tertentu.  Inilah yang dilakukan arus lalu lintas. </p><br><p>  Ini dimungkinkan dengan membuat instance Event Loop terpisah dengan utas "besi" sendiri dan perencanaan di tingkat OS.  Opsi kedua adalah menyinkronkan coroutine dengan primitif (Mutex, Throttle) yang relatif primitif dalam hal kompetisi dan / atau kinerja. </p><br><p>  Pemrograman asinkron tidak membuat sumber daya prosesor kenyal dan membutuhkan batasan yang benar-benar normal pada jumlah tugas yang diproses secara bersamaan dan batas waktu eksekusi total. </p><br><p>  Perlindungan terhadap pemblokiran yang lama pada satu coroutine memerlukan langkah-langkah yang sama dengan panggilan balik - untuk menghindari pemblokiran panggilan sistem dan siklus pemrosesan data yang panjang. </p><br><p>  Masalah kedua membutuhkan penelitian, tetapi setidaknya coroutine menumpuk sendiri dan rincian implementasi Future / Promise sudah melanggar lokalitas data.  Ada peluang untuk mencoba melanjutkan eksekusi coroutine yang sama jika Future sudah penting.  Diperlukan mekanisme tertentu untuk menghitung waktu eksekusi atau jumlah kelanjutan tersebut untuk mencegah satu coroutine menangkap seluruh waktu prosesor.  Ini mungkin tidak memberikan hasil, atau memberikan hasil yang sangat berlipat ganda tergantung pada ukuran cache prosesor dan jumlah utas. </p><br><p>  Ada juga poin ketiga - banyak implementasi penjadwalan coroutine memungkinkan mereka untuk dijalankan pada core prosesor yang berbeda, yang sebaliknya menambah masalah karena sinkronisasi wajib ketika mengakses sumber daya bersama.  Dalam kasus aliran Peristiwa tunggal, sinkronisasi seperti itu hanya diperlukan pada tingkat logis, sejak itu  Setiap blok panggilan balik yang sinkron dijamin bekerja tanpa balapan dengan yang lain. </p><br><h4 id="mnenie-avtora-vsyo-horosho-v-meru">  Pendapat penulis: semuanya baik-baik saja </h4><br><p>  Kehadiran utas dalam sistem operasi modern tidak meniadakan penggunaan proses individu.  Juga, memproses sejumlah besar klien di Event Loop tidak meniadakan penggunaan benang "besi" yang terisolasi untuk kebutuhan lain. </p><br><p>  Bagaimanapun, coroutine dan berbagai varian Event Loops menyulitkan proses debugging tanpa dukungan yang diperlukan dalam alat, dan dengan variabel lokal pada tumpukan coroutine, semuanya menjadi lebih sulit - praktis tidak ada cara untuk mendapatkannya. </p><br><hr><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2p/pp/lb/2ppplbzrvm8c0yvbasdwrojknss.png" width="326" height="326"></div><br><h2 id="futoin-asyncsteps---alternativa-soprogrammam">  FutoIn AsyncSteps - sebuah alternatif untuk coroutine </h2><br><p>  Kami mengambil sebagai dasar pola Perulangan Kejadian dan organisasi skema panggilan balik yang sudah mapan sesuai dengan tipe Janji ECMAScript (JavaScript). </p><br><p>  Dalam hal perencanaan eksekusi, kami tertarik pada kegiatan berikut dari Perulangan Kejadian: </p><br><ol><li>  <code>Handle immediate(callack)</code> membutuhkan tumpukan panggilan yang bersih. </li><li>  Callback <code>Handle deferred(delay, callback)</code> . </li><li>  Batalkan callback <code>handle.cancel()</code> . </li></ol><br><p>  Jadi kita mendapatkan antarmuka yang disebut <code>AsyncTool</code> , yang dapat diimplementasikan dalam banyak cara, termasuk di atas perkembangan yang sudah terbukti.  Dia tidak memiliki hubungan langsung dengan penulisan logika bisnis, jadi kami tidak akan membahas lebih jauh. </p><br><h3 id="derevo-shagov">  Pohon langkah: </h3><br><p>  Dalam konsep AsyncSteps, pohon abstrak langkah sinkron berbaris dan dieksekusi dengan masuk jauh ke dalam urutan pembuatan.  Langkah-langkah dari setiap level yang lebih dalam ditetapkan secara dinamis saat bagian tersebut selesai. </p><br><p>  Semua interaksi terjadi melalui antarmuka <code>AsyncSteps</code> tunggal, yang, menurut <code>AsyncSteps</code> , dilewatkan sebagai parameter pertama untuk setiap langkah.  Sesuai konvensi, nama parameternya <code>asi</code> atau tidak digunakan lagi.  Pendekatan ini memungkinkan Anda untuk memutus koneksi antara implementasi tertentu dan menulis logika bisnis di plugin dan pustaka. </p><br><p>  Dalam implementasi kanonik, setiap langkah menerima instance sendiri dari objek yang mengimplementasikan <code>AsyncSteps</code> , yang memungkinkan pelacakan tepat waktu kesalahan logis dalam menggunakan antarmuka. </p><br><p>  Contoh abstrak: </p><br><pre> <code class="hljs lua"> asi.add( // Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> func( asi ){ <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 func"</span></span> ) asi.add( // Level <span class="hljs-number"><span class="hljs-number">1</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> func( asi ){ <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 1 func"</span></span> ) asi.<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>( <span class="hljs-string"><span class="hljs-string">"MyError"</span></span> ) }, onerror( asi, <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> ){ // Level <span class="hljs-number"><span class="hljs-number">1</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> catch <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 1 onerror: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> ) asi.<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>( <span class="hljs-string"><span class="hljs-string">"NewError"</span></span> ) } ) }, onerror( asi, <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> ){ // Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> catch <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 onerror: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> strequal <span class="hljs-string"><span class="hljs-string">"NewError"</span></span> ) { asi.success( <span class="hljs-string"><span class="hljs-string">"Prm"</span></span>, <span class="hljs-number"><span class="hljs-number">123</span></span>, [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-literal"><span class="hljs-literal">true</span></span>) } } ) asi.add( // Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">2</span></span> func( asi, str_param, int_param, array_param ){ <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 func2: "</span></span> + param ) } )</code> </pre> <br><p>  Hasil Eksekusi: </p><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> func <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> func <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> onerror <span class="hljs-number"><span class="hljs-number">1</span></span>: MyError <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> onerror <span class="hljs-number"><span class="hljs-number">1</span></span>: NewError <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> func <span class="hljs-number"><span class="hljs-number">2</span></span>: Prm</code> </pre> <br><p>  Dalam sinkronisasi, akan terlihat seperti ini: </p><br><pre> <code class="hljs coffeescript"> str_res, int_res, array_res, bool_res <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 func 1"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Level <span class="hljs-number"><span class="hljs-number">1</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 1 func 1"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-string"><span class="hljs-string">"MyError"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( error ){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Level <span class="hljs-number"><span class="hljs-number">1</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 1 onerror 1: "</span></span> + error ) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-string"><span class="hljs-string">"NewError"</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( error ){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 onerror 1: "</span></span> + error ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( error strequal <span class="hljs-string"><span class="hljs-string">"NewError"</span></span> ) { str_res = <span class="hljs-string"><span class="hljs-string">"Prm"</span></span> int_res = <span class="hljs-number"><span class="hljs-number">123</span></span> array_res = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] bool_res = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { re-<span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> } } { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 func 2: "</span></span> + str_res ) }</code> </pre> <br><p>  Mimikri maksimum dari kode sinkron tradisional segera terlihat, yang seharusnya membantu keterbacaan. </p><br><p>  Dari sudut pandang logika bisnis, sejumlah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">besar persyaratan</a> tumbuh seiring waktu, tetapi kita dapat membaginya menjadi bagian-bagian yang mudah dipahami.  Dijelaskan di bawah ini, hasil lari dalam praktik selama empat tahun. </p><br><h3 id="bazovye-api-vremeni-vypolneniya">  API Core Runtime: </h3><br><ol><li>  <code>add(func[, onerror])</code> - imitasi <code>try-catch</code> . </li><li>  <code>success([args...])</code> - indikasi eksplisit penyelesaian yang berhasil: <br><ul><li>  tersirat secara default </li><li>  dapat meneruskan hasilnya ke langkah berikutnya. </li></ul></li><li>  <code>error(code[, reason)</code> - gangguan eksekusi dengan kesalahan: <br><ul><li>  <code>code</code> - memiliki tipe string yang lebih baik diintegrasikan dengan protokol jaringan dalam arsitektur layanan mikro, </li><li>  <code>reason</code> - penjelasan sewenang-wenang bagi seseorang. </li></ul></li><li>  <code>state()</code> - analog dari Penyimpanan Lokal Utas.  Kunci asosiatif yang telah ditentukan: <br><ul><li>  <code>error_info</code> - penjelasan tentang kesalahan terakhir untuk seseorang, </li><li>  <code>last_exception</code> - penunjuk ke objek pengecualian terakhir, </li><li>  <code>async_stack</code> - setumpuk panggilan asinkron <code>async_stack</code> teknologi memungkinkan, </li><li>  sisanya diatur oleh pengguna. </li></ul></li></ol><br><p>  Contoh sebelumnya sudah dengan kode C ++ nyata dan beberapa fitur tambahan: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;futoin/iasyncsteps.hpp&gt; using namespace futoin; void some_api(IAsyncSteps&amp; asi) { asi.add( [](IAsyncSteps&amp; asi) { std::cout &lt;&lt; "Level 0 func 1" &lt;&lt; std::endl; asi.add( [](IAsyncSteps&amp; asi) { std::cout &lt;&lt; "Level 1 func 1" &lt;&lt; std::endl; asi.error("MyError"); }, [](IAsyncSteps&amp; asi, ErrorCode code) { std::cout &lt;&lt; "Level 1 onerror 1: " &lt;&lt; code &lt;&lt; std::endl; asi.error("NewError", "Human-readable description"); } ); }, [](IAsyncSteps&amp; asi, ErrorCode code) { std::cout &lt;&lt; "Level 0 onerror 1: " &lt;&lt; code &lt;&lt; std::endl; if (code == "NewError") { // Human-readable error info assert(asi.state().error_info == "Human-readable description"); // Last exception thrown is also available in state std::exception_ptr e = asi.state().last_exception; // NOTE: smart conversion of "const char*" asi.success("Prm", 123, std::vector&lt;int&gt;({1, 2, 3}, true)); } } ); asi.add( [](IAsyncSteps&amp; asi, const futoin::string&amp; str_res, int int_res, std::vector&lt;int&gt;&amp;&amp; arr_res) { std::cout &lt;&lt; "Level 0 func 2: " &lt;&lt; str_res &lt;&lt; std::endl; } ); }</span></span></span></span></code> </pre> <br><h3 id="api-dlya-sozdaniya-ciklov">  API untuk membuat loop: </h3><br><ol><li>  <code>loop( func, [, label] )</code> - langkah dengan tubuh yang berulang berulang. </li><li>  <code>forEach( map|list, func [, label] )</code> - langkah-iterasi dari objek koleksi. </li><li>  <code>repeat( count, func [, label] )</code> - langkah-iterasi yang ditentukan berapa kali. </li><li>  <code>break( [label] )</code> adalah analog dari interupsi loop tradisional. </li><li>  <code>continue( [label] )</code> adalah analog dari kelanjutan loop tradisional dengan iterasi baru. </li></ol><br><p>  <em>Spesifikasi ini menawarkan nama-nama alternatif <code>breakLoop</code> , <code>continueLoop</code> dan lainnya jika ada konflik dengan kata-kata yang dipesan.</em> </p><br><p>  Contoh C ++: </p><br><pre> <code class="cpp hljs"> asi.loop([](IAsyncSteps&amp; asi) { <span class="hljs-comment"><span class="hljs-comment">// infinite loop asi.breakLoop(); }); asi.repeat(10, [](IAsyncSteps&amp; asi, size_t i) { // range loop from i=0 till i=9 (inclusive) asi.continueLoop(); }); asi.forEach( std::vector&lt;int&gt;{1, 2, 3}, [](IAsyncSteps&amp; asi, size_t i, int v) { // Iteration of vector-like and list-like objects }); asi.forEach( std::list&lt;futoin::string&gt;{"1", "2", "3"}, [](IAsyncSteps&amp; asi, size_t i, const futoin::string&amp; v) { // Iteration of vector-like and list-like objects }); asi.forEach( std::map&lt;futoin::string, futoin::string&gt;(), [](IAsyncSteps&amp; asi, const futoin::string&amp; key, const futoin::string&amp; v) { // Iteration of map-like objects }); std::map&lt;std::string, futoin::string&gt; non_const_map; asi.forEach( non_const_map, [](IAsyncSteps&amp; asi, const std::string&amp; key, futoin::string&amp; v) { // Iteration of map-like objects, note the value reference type });</span></span></code> </pre> <br><h3 id="api-integracii-s-vneshnimi-sobytiyami">  API untuk integrasi dengan acara eksternal: </h3><br><ol><li>  <code>setTimeout( timeout_ms )</code> - melempar kesalahan <code>Timeout</code> setelah timeout jika langkah dan subtree-nya belum menyelesaikan eksekusi. </li><li>  <code>setCancel( handler )</code> - mengatur cancel handler, yang dipanggil ketika utas dibatalkan sama sekali dan ketika tumpukan langkah asinkron diperluas selama pemrosesan kesalahan. </li><li>  <code>waitExternal()</code> - tunggu sederhana untuk acara eksternal. <br><ul><li>  <em>Catatan: Aman untuk digunakan hanya dalam teknologi dengan pengumpul sampah.</em> </li></ul></li></ol><br><p>  Panggilan ke salah satu dari fungsi-fungsi ini membuat panggilan eksplisit untuk <code>success()</code> diperlukan. </p><br><p>  Contoh C ++: </p><br><pre> <code class="cpp hljs"> asi.add([](IAsyncSteps&amp; asi) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> handle = schedule_external_callback([&amp;](<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> err) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { asi.error(<span class="hljs-string"><span class="hljs-string">"ExternalError"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (...) { <span class="hljs-comment"><span class="hljs-comment">// pass } } else { asi.success(); } }); asi.setCancel([=](IAsyncSteps&amp; asi) { external_cancel(handle); }); }); asi.add( [](IAsyncSteps&amp; asi) { // Raises Timeout error after specified period asi.setTimeout(std::chrono::seconds{10}); asi.loop([](IAsyncSteps&amp; asi) { // infinite loop }); }, [](IAsyncSteps&amp; asi, ErrorCode code) { if (code == futoin::errors::Timeout) { asi(); } });</span></span></code> </pre> <br><p>  Contoh ECMAScript: </p><br><pre> <code class="javascript hljs">asi.add( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">asi</span></span></span><span class="hljs-function">) =&gt;</span></span> { asi.waitExternal(); <span class="hljs-comment"><span class="hljs-comment">// disable implicit success() some_obj.read( (err, data) =&gt; { if (!asi.state) { // ignore as AsyncSteps execution got canceled } else if (err) { try { asi.error( 'IOError', err ); } catch (_) { // ignore error thrown as there are no // AsyncSteps frames on stack. } } else { asi.success( data ); } } ); } );</span></span></code> </pre> <br><h3 id="api-integracii-s-futurepromise">  API Integrasi Masa Depan / Janji: </h3><br><ol><li>  <code>await(promise_future[, on_error])</code> - menunggu Masa Depan / Janji sebagai langkah. </li><li>  <code>promise()</code> - mengubah seluruh aliran eksekusi ke Masa Depan / Janji, digunakan alih-alih <code>execute()</code> . </li></ol><br><p>  Contoh C ++: </p><br><pre> <code class="hljs pgsql"> [](IAsyncSteps&amp; asi) { // Proper way <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> AsyncSteps instances // <span class="hljs-keyword"><span class="hljs-keyword">without</span></span> hard dependency <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> implementation. auto new_steps = asi.newInstance(); new_steps-&gt;<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>([](IAsyncSteps&amp; asi) {}); // Can be <span class="hljs-keyword"><span class="hljs-keyword">called</span></span> outside <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> AsyncSteps event <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> // new_steps.promise().wait(); // <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> // new_steps.promise&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;().<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(); // Proper way <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> wait <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> standard std::future asi.await(new_steps-&gt;promise()); // Ensure instance lifetime asi.state()["some_obj"] = std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(new_steps); };</code> </pre> <br><h3 id="api-kontrolya-potoka-vypolneniya-biznes-logiki">  API Kontrol Alur Logika Bisnis: </h3><br><ol><li>  <code>AsyncSteps(AsyncTool&amp;)</code> adalah konstruktor yang mengikat utas eksekusi ke Loop Acara tertentu. </li><li>  <code>execute()</code> - memulai utas eksekusi. </li><li>  <code>cancel()</code> - membatalkan utas eksekusi. </li></ol><br><p>  Implementasi antarmuka spesifik sudah diperlukan di sini. </p><br><p>  Contoh C ++: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;futoin/ri/asyncsteps.hpp&gt; #include &lt;futoin/ri/asynctool.hpp&gt; void example() { futoin::ri::AsyncTool at; futoin::ri::AsyncSteps asi{at}; asi.loop([&amp;](futoin::IAsyncSteps &amp;asi){ // Some infinite loop logic }); asi.execute(); std::this_thread::sleep_for(std::chrono::seconds{10}); asi.cancel(); // called in d-tor by fact }</span></span></span></span></code> </pre> <br><h3 id="prochie-api">  API lain: </h3><br><ol><li>  <code>newInstance()</code> - memungkinkan Anda membuat utas eksekusi baru tanpa ketergantungan langsung pada implementasinya. </li><li>  <code>sync(object, func, onerror)</code> - sama, tetapi dengan sinkronisasi relatif terhadap objek yang mengimplementasikan antarmuka yang sesuai. </li><li>  <code>parallel([on_error])</code> - <code>add()</code> khusus <code>add()</code> , subteps di antaranya adalah aliran AsyncSteps yang terpisah: <br><ul><li>  semua utas memiliki <code>state()</code> umum <code>state()</code> , </li><li>  utas induk melanjutkan eksekusi setelah semua anak selesai </li><li>  kesalahan tanpa tertangkap pada anak mana pun segera membatalkan semua utas anak lainnya. </li></ul></li></ol><br><p>  Contoh C ++: </p><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;futoin/ri/mutex.hpp&gt; using namespace futoin; ri::Mutex mtx_a; void sync_example(IAsyncSteps&amp; asi) { asi.sync(mtx_a, [](IAsyncSteps&amp; asi) { // synchronized section asi.add([](IAsyncSteps&amp; asi) { // inner step in the section // This synchronization is NOOP for already // acquired Mutex. asi.sync(mtx_a, [](IAsyncSteps&amp; asi) { }); }); }); } void parallel_example(IAsyncSteps&amp; asi) { using OrderVector = std::vector&lt;int&gt;; asi.state("order", OrderVector{}); auto&amp; p = asi.parallel([](IAsyncSteps&amp; asi, ErrorCode) { // Overall error handler asi.success(); }); p.add([](IAsyncSteps&amp; asi) { // regular flow asi.state&lt;OrderVector&gt;("order").push_back(1); asi.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order").push_back(4); }); }); p.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order").push_back(2); asi.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order").push_back(5); asi.error("SomeError"); }); }); p.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order").push_back(3); asi.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order").push_back(6); }); }); asi.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order"); // 1, 2, 3, 4, 5 }); };</span></span></span></span></code> </pre> <br><h3 id="standartnye-primitivy-dlya-sinhronizacii">  Primitif standar untuk sinkronisasi </h3><br><ol><li>  <code>Mutex</code> - membatasi eksekusi simultan <code>N</code> thread dengan antrian di <code>Q</code> , secara default <code>N=1, Q=unlimited</code> . </li><li>  <code>Throttle</code> - membatasi jumlah input <code>N</code> dalam periode <code>P</code> dengan antrian di <code>Q</code> , secara default <code>N=1, P=1s, Q=0</code> . </li><li>  <code>Limiter</code> adalah kombinasi dari <code>Mutex</code> dan <code>Throttle</code> , yang biasanya digunakan pada input pemrosesan permintaan eksternal dan ketika memanggil sistem eksternal untuk tujuan operasi yang stabil di bawah beban. </li></ol><br><p>  Dalam hal <code>DefenseRejected</code> batas antrian, kesalahan <code>DefenseRejected</code> , artinya jelas dari deskripsi <code>Limiter</code> . </p><br><h3 id="klyuchevye-preimuschestva">  Manfaat Utama </h3><br><p>  Konsep AsyncSteps bukanlah tujuan itu sendiri, tetapi lahir dari kebutuhan untuk eksekusi program asinkron yang lebih terkontrol dalam hal batas waktu, pembatalan dan konektivitas keseluruhan dari callback individu.  Tidak ada solusi universal pada waktu itu dan sekarang menyediakan fungsionalitas yang sama.  Oleh karena itu: </p><br><p> <strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> FTN12</a>   </strong> —           . </p><br><p> <strong>  <code>setCancel()</code></strong> —                    .       ,     .   RAII  <code>atexit()</code>   . </p><br><p> <strong>   <code>cancel()</code></strong> —     ,         .   <code>SIGTERM</code>  <code>pthread_cancel()</code> ,       . </p><br><p> <strong>   <code>setTimeout()</code></strong> —                 .    ,    "Timeout". </p><br><p> <strong>     </strong> —  FutoIn AsyncSteps             . </p><br><p> <strong>      </strong> —          ABI     ,    .    Embedded     MMU. </p><br><hr><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yj/8x/wv/yj8xwvibm7tjsj30qhojwbleige.jpeg"></div><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em> </em></a> </p><br><h2 id="k-cifram">   </h2><br><p>    Intel Xeon E3-1245v2/DDR1333  Debian Stretch    . </p><br><p>   : </p><br><ol><li> Boost.Fiber  <code>protected_fixedsize_stack</code> . </li><li> Boost.Fiber  <code>pooled_fixedsize_stack</code>     . </li><li> FutoIn AsyncSteps   . </li><li> FutoIn AsyncSteps      ( <code>FUTOIN_USE_MEMPOOL=false</code> ). <br><ul><li>      <code>futoin::IMemPool</code> . </li></ul></li><li> FutoIn NitroSteps&lt;&gt; —           . <br><ul><li>         . </li></ul></li></ol><br><p>    Boost.Fiber    : </p><br><ol><li>     1 . . </li><li>       30 .   1 . . <br><ul><li>   30 .     <code>mmap()/mprotect()</code>  <code>boost::fiber::protected_fixedsize_stack</code> . </li><li>          . </li></ul></li><li>   30 .   10 .     . <br><ul><li>    ""          . </li></ul></li></ol><br><p>      "" , ..     ,       .        .   . </p><br><p>    GCC 6.3.0.   lang  tcmalloc  ,     . </p><br><p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitLab</a> . </p><br><h3 id="1-posledovatelnoe-sozdanie"> 1.   </h3><br><table><thead><tr><th>  </th><th>  </th><th>  </th></tr></thead><tbody><tr><td> Boost.Fiber protected </td><td> 4.8s </td><td> 208333.333Hz </td></tr><tr><td> Boost.Fiber pooled </td><td> 0.23s </td><td> 4347826.086Hz </td></tr><tr><td> FutoIn AsyncSteps </td><td> <strong>0.21s</strong> </td><td> <strong>4761904.761Hz</strong> </td></tr><tr><td> FutoIn AsyncSteps no mempool </td><td> 0.31s </td><td> 3225806.451Hz </td></tr><tr><td> FutoIn NitroSteps </td><td> 0.255s </td><td> 3921568.627Hz </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qm/ur/y6/qmury65-mbkth_om8smkfi7vamq.png"></div><br><p> <em> — .</em> </p><br><p>     Boost.Fiber -      ,     <code>pooled_fixedsize_stack</code>   ,    AsyncSteps. </p><br><h3 id="2-parallelnoe-sozdanie-i-ispolnenie"> 2.     </h3><br><table><thead><tr><th>  </th><th>  </th><th>  </th></tr></thead><tbody><tr><td> Boost.Fiber protected </td><td> 6.31s </td><td> 158478.605Hz </td></tr><tr><td> Boost.Fiber pooled </td><td> 1.558s </td><td> 641848.523Hz </td></tr><tr><td> FutoIn AsyncSteps </td><td> <strong>1.13s</strong> </td><td> <strong>884955.752Hz</strong> </td></tr><tr><td> FutoIn AsyncSteps no mempool </td><td> 1.353s </td><td> 739098.300Hz </td></tr><tr><td> FutoIn NitroSteps </td><td> 1.43s </td><td> 699300.699Hz </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0s/gz/lu/0sgzlur2xsrlf-wo4mrcynvzhxi.png"></div><br><p> <em> — .</em> </p><br><p>    ,          .    ,        —            . </p><br><h3 id="3-parallelnye-cikly"> 3.   </h3><br><table><thead><tr><th>  </th><th>  </th><th>  </th></tr></thead><tbody><tr><td> Boost.Fiber protected </td><td> 5.096s </td><td> 1962323.390Hz </td></tr><tr><td> Boost.Fiber pooled </td><td> 5.077s </td><td> 1969667.126Hz </td></tr><tr><td> FutoIn AsyncSteps </td><td> 5.361s </td><td> 1865323.633Hz </td></tr><tr><td> FutoIn AsyncSteps no mempool </td><td> 8.288s </td><td> 1206563.706Hz </td></tr><tr><td> FutoIn NitroSteps </td><td> <strong>3.68s</strong> </td><td> <strong>2717391.304Hz</strong> </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/c1/17/pbc117djqds0d4twh5fzcklsmfc.png"></div><br><p> <em> — .</em> </p><br><p>   ,        Boost.Fiber      AsyncSteps,    NitroSteps. </p><br><h3 id="ispolzovanie-pamyati-po-rss">   ( RSS) </h3><br><table><thead><tr><th>  </th><th>  </th></tr></thead><tbody><tr><td> Boost.Fiber protected </td><td> 124M </td></tr><tr><td> Boost.Fiber pooled </td><td> 505M </td></tr><tr><td> FutoIn AsyncSteps </td><td> 124M </td></tr><tr><td> FutoIn AsyncSteps no mempool </td><td> <strong>84M</strong> </td></tr><tr><td> FutoIn NitroSteps </td><td> 115M </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ol/w0/6n/olw06nef5wj3ah1lo9u-pby9sfg.png"></div><br><p> <em> — .</em> </p><br><p>  , Boost.Fiber  . </p><br><h3 id="bonus-testy-na-nodejs"> :   Node.js </h3><br><p>      -  <code>Promise</code> : +    10 . .   10 .          JIT  <code>NODE_ENV=production</code> ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>@futoin/optihelp</code></a> . </p><br><p>      <a href="">GitHub</a>  <a href="">GitLab</a> .   Node.js v8.12.0  v10.11.0,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FutoIn CID</a> . </p><br><table><thead><tr><th> Tech </th><th> Simple </th><th> Loop </th></tr></thead><tbody><tr><td> <strong>Node.js v10</strong> </td><td></td><td></td></tr><tr><td> FutoIn AsyncSteps </td><td> <strong>1342899.520Hz</strong> </td><td> 587.777Hz </td></tr><tr><td> async/await </td><td> 524983.234Hz </td><td> <strong>630.863Hz</strong> </td></tr><tr><td> <strong>Node.js v8</strong> </td><td></td><td></td></tr><tr><td> FutoIn AsyncSteps </td><td> <strong>682420.735Hz</strong> </td><td> <strong>588.336Hz</strong> </td></tr><tr><td> async/await </td><td> 365050.395Hz </td><td> 400.575Hz </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/x7/-n/b5/x7-nb5v9dfkwn1lttyg67w2b_tk.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gh/yj/9p/ghyj9pczw0smbfksq-aad_tltay.png"></div><br><p> <em> — .</em> </p><br><p>   <code>async/await</code> ? ,   V8  Node.js v10       . </p><br><p>  ,   Promise  <code>async/await</code> <strong></strong> Node.js Event Loop.          ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> ),   FutoIn AsyncSteps   . </p><br><p> <em>   AsyncSteps  Node.js Event Loop      <code>async/await</code>  -  Node.js v10.</em> </p><br><p> <em>,      ++   —    .  ,    Node.js    10 .</em> </p><br><h3 id="vyvody">  Kesimpulan </h3><br><p>   C++, FutoIn AsyncSteps  Boost.Fiber       ,     Boost.Fiber         <code>mmap()/mprotect</code> . </p><br><p>       ,      -      ,   .     . </p><br><p> FutoIn AsyncSteps  JavaScript  <code>async/await</code>       Node.js v10. </p><br><p>   ,       -,       .        . </p><br><p>   -                        ""  .     —   API. </p><br><hr><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p> ,  FutoIn AsyncSteps ,          "" <code>async/await</code> . ,         .      <code>Promise</code>  ECMAScript, AsyncSteps    ""           . </p><br><p>               .        AsyncSteps  NitroSteps   . </p><br><p>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> ,    - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . </p><br><p>       Java/JVM         —    .    . </p><br><p>      ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitLab</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424311/">https://habr.com/ru/post/id424311/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424297/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 9: Keamanan Aplikasi Web, Bagian 3</a></li>
<li><a href="../id424301/index.html">Algoritma Filter Gambar Jaringan Syaraf Adaptif</a></li>
<li><a href="../id424305/index.html">RIB Arsitektur Arsitektur Lintas Platform Uber</a></li>
<li><a href="../id424307/index.html">GitLab 11.3 dirilis dengan repositori Maven dan Lingkungan aman</a></li>
<li><a href="../id424309/index.html">DevCore: bagian perangkat lunak dari proyek DevBoy</a></li>
<li><a href="../id424313/index.html">EveryLang adalah program yang dapat melakukan hampir semua hal</a></li>
<li><a href="../id424315/index.html">Babak baru substitusi impor. Di mana harus lari dan apa yang harus dilakukan?</a></li>
<li><a href="../id424319/index.html">Struktur toko online. Bagian 2</a></li>
<li><a href="../id424321/index.html">Puting NetFlow Murah dan Marah</a></li>
<li><a href="../id424323/index.html">Contoh bekerja dengan metode ICE dari manajer produk Google dan Microsoft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>