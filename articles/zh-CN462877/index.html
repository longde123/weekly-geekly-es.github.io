<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚟 👩🏾‍🤝‍👨🏼 🍑 PostgreSQL中的锁：1.关系锁 🏬 ⭐️ 🚴🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="之前的两篇文章集中讨论了隔离，多版本主义和日记 。 

 在本系列中，我们将讨论锁。 我会坚持这个词，但是在文学中可能还会有另一个词： 城堡 。 

 该周期将包括四个部分： 



1. 关系锁（本文）； 
2. 行锁 ; 
3. 其他对象的锁和谓词锁； 
4. 锁定RAM 。 
 所有文章的内容...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PostgreSQL中的锁：1.关系锁</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/462877/"> 之前的两篇文章集中讨论了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">隔离，多版本主义和日记</a> 。 <br><br> 在本系列中，我们将讨论锁。 我会坚持这个词，但是在文学中可能还会有另一个词： <em>城堡</em> 。 <br><br> 该周期将包括四个部分： <br><br><ol><li> 关系锁（本文）； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">行锁</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">其他对象的</a>锁和谓词锁； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">锁定RAM</a> 。 </li></ol><br> 所有文章的内容均基于我和Pavel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">pluzanov所做的</a>行政<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">培训课程</a> ，但不再逐字重复，旨在用于深思熟虑的阅读和独立的实验。 <br><br><img src="https://habrastorage.org/webt/rx/jt/bz/rxjtbz_s6otkhbwcm6agmmtldxe.png"><br><br><h1> 有关锁的一般信息 </h1><br>  PostgreSQL使用了许多不同的机制来阻止某些东西（或者至少被称为那）。 因此，我将从最笼统的词开始，以说明为什么根本需要锁，锁是什么以及它们之间有何不同。 然后，我们将看到在PostgreSQL中可以找到这种不同的东西，然后，我们才开始详细处理不同类型的锁。 <br><a name="habracut"></a><br> 锁用于简化对共享资源的并发访问。 <br><br> 竞争访问是指同时访问多个流程。 这些过程本身可以在分时模式下并行执行（如果设备允许），也可以顺序执行-这并不重要。 <br><br> 如果没有竞争，那么就不需要锁（例如，共享缓冲区高速缓存需要锁，而本地缓冲区不需要）。 <br><br> 在访问资源之前，进程必须获取与该资源关联的锁。 也就是说，我们谈论的是某种纪律：只要所有过程都符合访问共享资源的既定规则，一切都会起作用。 如果DBMS管理锁，则它本身会监视顺序； 如果应用程序设置了阻止，则此义务落在他身上。 <br><br> 在较低的级别上，锁由共享内存的一部分表示，在其中以某种方式指出了锁是空闲的还是已捕获的（并且可能还会记录其他信息：进程号，捕获时间等）。 <br><br><blockquote> 您可能会注意到，这样的共享内存本身就是可以竞争访问的资源。 如果我们往下面看，我们将看到操作系统提供的特殊附件原语（例如信号量或互斥量）用于组织访问。 它们的含义是访问共享资源的代码一次只能在一个进程中执行。 在最底层，这些原语是基于原子处理器指令（例如，测试和设置或比较和交换）实现的。 <br></blockquote><br> 在进程不再需要资源之后，它将<em>释放</em>锁，以便其他人可以使用该资源。 <br><br> 当然，锁定锁并非总是可能的：该资源可能已被其他人占用。 然后，该过程要么进入等待队列（如果锁定机制提供了此机会），要么在一定时间后重试以获取锁定。 一种或另一种方式导致以下事实：在预期资源释放的过程中，进程被迫处于空闲状态。 <br><br><blockquote> 有时可以应用其他非阻塞策略。 例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">多重</a>版本控制<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">机制</a>在某些情况下允许多个进程同时处理不同版本的数据，而不会相互阻塞。 <br></blockquote><br> 原则上，如果只能明确地标识该资源并与阻塞地址进行匹配，则受保护的资源可以是任何东西。 <br><br> 例如，资源可以是DBMS正在使用的对象，例如数据页（由文件名和文件内的位置标识），表（系统目录中的oid），表行（页和页内的偏移量）。 资源可以是内存中的结构，例如哈希表，缓冲区等（由预分配的编号标识）。 有时，使用没有任何物理意义的抽象资源甚至很方便（它们仅由唯一数字标识）。 <br><br> 锁的有效性受许多因素影响，我们将其中两个因素区分开。 <br><br><ul><li> 如果资源形成层次结构，则<strong>粒度</strong> （granularity）很重要。 <br><br> 例如，一个表由包含表行的页面组成。 所有这些对象都可以充当资源。 如果进程通常只对几行感兴趣，并且锁定是在表级别设置的，则其他进程将无法同时处理不同的行。 因此，粒度越高，并行化的可能性越好。 <br><br> 但是，这导致锁的数量增加（必须将其存储在内存中的信息）。 在这种情况下，可以<em>增加</em>锁<em>的级别</em> （升级）：当低级别的粒度锁的数量超过某个限制时，它们将被更高级别的一个锁代替。 <br></li><li> 可以用不同的<strong>模式</strong>捕获锁。 <br><br> 模式的名称可以是绝对任意的，只有它们相互兼容的矩阵很重要。 与任何模式（包括自身）不兼容的模式通常称为<em>互斥</em>或互斥。 如果这些模式兼容，那么可以同时通过多个过程来捕获锁； 这种模式称为共享。 通常，可以区分出更多彼此兼容的不同模式，从而为并行性创造了更多机会。 <br></li></ul><br> 根据使用时间，锁可以分为长型和短型。 <br><br><ul><li>  <strong>长期</strong>锁定可能会捕获很长时间（通常直到事务结束），并且通常与诸如表（关系）和行之类的资源有关。  PostgreSQL通常自动管理这些锁，但是用户仍然可以对此过程进行一些控制。 <br><br> 长锁具有大量模式，因此可以对数据执行尽可能多的同时动作。 通常，对于此类锁，存在发达的基础结构（例如，支持等待队列和死锁检测）和监视工具，因为维护所有这些便利设施的成本仍比保护数据的操作成本低得多。 <br></li><li>  <strong>短期</strong>锁定会在很短的时间内捕获（从几条处理器指令到几分之一秒的时间），通常是指共享内存中的数据结构。  PostgreSQL完全自动地管理这些锁-您只需要知道它们的存在即可。 <br><br> 短锁的特征在于最少的模式（独占和共享）和简单的基础结构。 在某些情况下，甚至可能没有监视工具。 <br></li></ul><br>  PostgreSQL使用不同类型的锁。 <br><br>  <strong>对象级别的锁</strong>是长期的“重量级” <strong>锁</strong> 。 这里的资源是关系和其他对象。 如果阻止一词出现在文本中而没有澄清，则表示仅是这种“正常”阻止。 <br><br> 在长期锁中， <strong>行级</strong>锁分别突出。 它们的实现与其他长期锁定有所不同，因为它们的数量可能很大（可以想象在一个事务中更新一百万行）。 这种锁将在下一篇文章中讨论。 <br><br> 本系列的第三篇文章将专门介绍对象级别上的其余锁以及<strong>谓词锁</strong> （因为有关所有这些锁的信息都以相同的方式存储在RAM中）。 <br><br> 短锁包括<strong>RAM结构的</strong>各种<strong>锁</strong> 。 我们将在周期的最后一篇文章中对它们进行讨论。 <br><br><h1> 对象锁 </h1><br> 因此，我们从对象级别锁开始。 在这里，对象首先被理解为<em>关系</em> ，即表，索引，序列，物化表示，还有一些其他实体。 这些锁通常可以防止对象同时更改或在对象更改时被使用，也可以用于其他需求。 <br><br> 措辞模糊？ 这是因为该组中的锁有多种用途。 使它们团结起来的是如何安排它们。 <br><br><h2> 装置 </h2><br> 对象锁位于服务器的共享内存中。 它们的数量受两个参数的值的乘积限制： <em>max_locks_per_transaction</em> × <em>max_connections</em> 。 <br><br> 锁池对于所有事务都是通用的，也就是说，一个事务可以捕获比<em>max_locks_per_transaction</em>更多的锁：仅重要的一点是，系统中的锁总数不超过设置的限制。 该池是在启动时创建的，因此更改指示的两个选项中的任何一个都需要重新引导服务器。 <br><br> 可以在pg_locks视图中查看所有锁。 <br><br> 如果资源已经被锁定在不兼容模式下，则尝试捕获该资源的事务将排队，并等待释放该锁定。 待处理的事务不会消耗处理器资源：释放资源时，相应的服务进程将“入睡”并由操作系统唤醒。 <br><br> 可能出现<em>死锁</em>或<em>死锁</em>情况，其中一个事务需要第二个事务占用的资源才能继续，而第二个事务则需要第一个事务占用的资源（通常情况下，可能发生死锁和两个以上的事务）。 在这种情况下，等待将无限期地继续，因此PostgreSQL自动检测到这种情况并中止其中一个事务，以便其他事务可以继续工作。  （我们将在下一篇文章中进一步讨论死锁。） <br><br><h2> 对象类型 </h2><br> 这是我们将在本文和下一篇文章中处理的锁的类型（或者，如果您喜欢，对象的类型）的列表。 名称是根据pg_locks视图的locktype列给出的。 <br><br><ul><li>  <strong>关系</strong> <br><br> 关系锁。 <br></li><li>  <strong>transactionid</strong>和<strong>virtualxid</strong> <br><br> 阻止交易编号（真实或虚拟）。 每个事务本身都拥有其自己的编号的排它锁，因此在您需要等到另一笔事务结束时，使用这些锁很方便。 <br></li><li>  <strong>元组</strong> <br><br> 字符串版本锁。 在某些情况下，它用于在希望锁定同一行的多个事务之间设置优先级。 <br></li></ul><br> 我们将把其余类型的锁的讨论推迟到本周期的第三篇文章中。 仅在特殊模式下或在独占和共享下捕获所有这些对象。 <br><br><ul><li>  <strong>延伸</strong> <br><br> 在将页面添加到任何关系的文件时使用。 <br></li><li>  <strong>对象</strong> <br><br> 锁定非关系对象（数据库，架构，订阅等）。 <br></li><li>  <strong>页面</strong> <br><br> 页面锁定很少使用，并且仅由某些类型的索引使用。 <br></li><li>  <strong>咨询</strong> <br><br> 建议的阻止功能，由用户手动设置。 <br></li></ul><br><h1> 关系锁 </h1><br> 为了不丢失上下文，我将在此类图片上标记那些类型的锁，稍后将对其进行讨论。 <br><br><img src="https://habrastorage.org/webt/od/wc/ne/odwcnenfvjv_ikwmqw8x-vaexqi.png"><br><br><h2> 模式 </h2><br> 如果不是最重要的，那么肯定是最“粗俗”的封锁-封锁关系。 对于她来说，定义了多达8种不同的模式。 此数量是必需的，以便可以同时执行属于一个表的最大数量的指令。 <br><br> 认真学习这些模式或试图理解其名称的含义是没有意义的。 最主要的是在正确的时间在您眼前有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">矩阵</a> ，它可以显示哪些锁彼此冲突。 为了方便起见，此处与需要适当锁定级别的命令示例一起复制： <br><br><div class="scrollable-table"><table><tbody><tr><th> 锁定模式 </th><th> 作为 </th><th>  RS </th><th> 稀土 </th><th> 苏 </th><th> 小号 </th><th>  SRE </th><th>  Ë </th><th>  e </th><th> 示例<nobr>SQL命令</nobr> </th></tr><tr><td> 访问共享 </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>  X </td><td> 选择 </td></tr><tr><td> 行共享 </td><td></td><td></td><td></td><td></td><td></td><td></td><td>  X </td><td>  X </td><td> 选择更新/分享 </td></tr><tr><td> 行排他 </td><td></td><td></td><td></td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td> 插入，更新，删除 </td></tr><tr><td> 分享更新独家 </td><td></td><td></td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td> 真空，更改表<sup>*</sup> ，同时创建索引 </td></tr><tr><td> 分享到 </td><td></td><td></td><td>  X </td><td>  X </td><td></td><td>  X </td><td>  X </td><td>  X </td><td> 创建索引 </td></tr><tr><td> 分享行独家 </td><td></td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td> 创建触发器，更改表<sup>*</sup> </td></tr><tr><td> 独家的 </td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td> 刷新垫。 同时查看 </td></tr><tr><td> 独家访问 </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td> 拖放，截断，真空已满，锁定表，更改表<sup>*</sup> ，刷新垫。 查看 </td></tr></tbody></table></div><br> 一些评论： <br><br><ul><li> 前四种模式允许同时更改表中的数据，而后四种不允许。 </li><li> 第一种模式（访问共享）最弱，它与最后一种模式（访问专用）兼容。 最后一种模式是排他的，它与任何模式都不兼容。 </li><li>  ALTER TABLE命令具有许多选项，不同的选项需要不同的锁定级别。 因此，在矩阵中，此命令出现在不同的行上，并标有星号。 </li></ul><br><h2> 例如，例如 </h2><br> 举个例子。 如果我运行CREATE INDEX命令会怎样？ <br><br> 我们在文档中发现此命令将共享模式设置为锁定。 根据矩阵，我们确定该命令与其自身（即，您可以同时创建多个索引）和读取命令兼容。 因此，SELECT命令将继续起作用，但是UPDATE，DELETE，INSERT命令将被阻止。 <br><br> 反之亦然-修改表中数据的不完整事务将阻止CREATE INDEX命令的操作。 因此，该命令有一个变体-CREATE INDEX CONCURRENTLY。 它的工作时间更长（甚至可能因错误而掉落），但允许同时更改数据。 <br><br> 在实践中可以看到这一点。 为了进行实验，我们将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一个周期</a>熟悉的“银行”帐户表，其中将存储帐号和金额。 <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts( acc_no <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span>, amount <span class="hljs-type"><span class="hljs-type">numeric</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1000.00</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2000.00</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3000.00</span></span>);</code> </pre> <br> 在第二个会话中，启动事务。 我们需要一个服务流程号。 <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| pg_backend_pid | ---------------- | 4746 | (1 row)</code> </pre><br> 新启动的事务持有什么锁？ 我们看一下pg_locks： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">REGCLASS</span></span>, virtualxid <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> virtxid, transactionid <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">4746</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | virtxid | xid | mode | granted ------------+----------+---------+-----+---------------+--------- virtualxid | | 5/15 | | ExclusiveLock | t (1 row)</code> </pre><br> 正如我已经说过的，事务始终持有其自身编号的排他锁（ExclusiveLock），在这种情况下为虚拟锁。 此过程没有其他锁定。 <br><br> 现在更新表格行。 情况将如何改变？ <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \g</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | virtxid | xid | mode | granted ---------------+---------------+---------+--------+------------------+--------- relation | accounts_pkey | | | RowExclusiveLock | t relation | accounts | | | RowExclusiveLock | t virtualxid | | 5/15 | | ExclusiveLock | t transactionid | | | 529404 | ExclusiveLock | t (4 rows)</code> </pre><br> 现在，可变表和索引（为主键创建）上有锁，由UPDATE命令使用。 两种锁定均在RowExclusiveLock模式下进行。 另外，添加了对真实交易编号的排他性阻止（交易开始更改数据后立即出现）。 <br><br> 现在，在另一个会话中，我们将尝试在表上创建索引。 <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">|| pg_backend_pid || ---------------- || 4782 || (1 row)</code> </pre><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> accounts(acc_no);</code> </pre><br> 该命令因预期资源释放而冻结。 她正在尝试捕获哪种锁？ 检查： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">REGCLASS</span></span>, virtualxid <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> virtxid, transactionid <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">4782</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | virtxid | xid | mode | granted ------------+----------+---------+-----+---------------+--------- virtualxid | | 6/15 | | ExclusiveLock | t relation | accounts | | | ShareLock | f (2 rows)</code> </pre><br> 我们看到事务正在尝试以ShareLock模式获得表锁，但不能（已授予= f）。 <br><br> 使用9.6版中出现的函数可以很方便地找到阻塞进程的编号，通常可以找到几个编号（在此之前，我必须仔细查看pg_locks的所有内容来得出结论）： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_blocking_pids(<span class="hljs-number"><span class="hljs-number">4782</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_blocking_pids ------------------ {4746} (1 row)</code> </pre><br> 然后，要了解情况，您可以获取有关会话的信息，其中包括找到的数字： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-keyword"><span class="hljs-keyword">ANY</span></span>(pg_blocking_pids(<span class="hljs-number"><span class="hljs-number">4782</span></span>)) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----+------------------------------------------------------------ datid | 16386 datname | test pid | 4746 usesysid | 16384 usename | student application_name | psql client_addr | client_hostname | client_port | -1 backend_start | 2019-08-07 15:02:53.811842+03 xact_start | 2019-08-07 15:02:54.090672+03 query_start | 2019-08-07 15:02:54.10621+03 state_change | 2019-08-07 15:02:54.106965+03 wait_event_type | Client wait_event | ClientRead state | idle in transaction backend_xid | 529404 backend_xmin | query | UPDATE accounts SET amount = amount + 100 WHERE acc_no = 1; backend_type | client backend</code> </pre><br> 事务完成后，将释放锁并创建索引。 <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">| COMMIT</code> </pre><br><pre> <code class="plaintext hljs">|| CREATE INDEX</code> </pre><br><h2> 在排队！ </h2><br> 为了更好地想象不兼容锁的外观会导致什么，我们将看到如果在系统运行期间执行VACUUM FULL命令会发生什么。 <br><br> 让SELECT命令首先在我们的表上执行。 她锁定了最弱的访问共享级别。 为了控制锁释放时间，我们在事务内部执行此命令-直到事务结束，才会释放锁。 实际上，几个命令可以读取（和修改）表，而某些查询可能要花相当长的时间。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs"> acc_no | amount --------+--------- 2 | 2000.00 3 | 3000.00 1 | 1100.00 (3 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, mode, granted, pid, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> wait_for <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | mode | granted | pid | wait_for ----------+-----------------+---------+------+---------- relation | AccessShareLock | t | 4710 | {} (1 row)</code> </pre><br> 然后，管理员执行VACUUM FULL命令，该命令需要Access Exclusive级别锁定，该锁定与任何内容（甚至与Access Share）都不兼容。  （LOCK TABLE命令也需要相同的锁定。）事务队列。 <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">LOCK</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts; <span class="hljs-comment"><span class="hljs-comment">--  VACUUM FULL</span></span></code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, mode, granted, pid, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> wait_for <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | mode | granted | pid | wait_for ----------+---------------------+---------+------+---------- relation | AccessShareLock | t | 4710 | {} relation | AccessExclusiveLock | f | 4746 | {4710} (2 rows)</code> </pre><br> 但是应用程序继续发出请求，现在SELECT命令出现在系统中。 纯粹从理论上讲，在VACUUM FULL等待期间，她可能会“滑倒”，但是没有-她老实地在VACUUM FULL队列中占据一席之地。 <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, mode, granted, pid, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> wait_for <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | mode | granted | pid | wait_for ----------+---------------------+---------+------+---------- relation | AccessShareLock | t | 4710 | {} relation | AccessExclusiveLock | f | 4746 | {4710} relation | AccessShareLock | f | 4782 | {4746} (3 rows)</code> </pre><br> 在使用SELECT命令执行的第一个事务完成并释放锁之后，VACUUM FULL命令开始（我们使用LOCK TABLE命令进行了模拟）。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">COMMIT</code> </pre><br><pre> <code class="plaintext hljs">| LOCK TABLE</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, mode, granted, pid, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> wait_for <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | mode | granted | pid | wait_for ----------+---------------------+---------+------+---------- relation | AccessExclusiveLock | t | 4746 | {} relation | AccessShareLock | f | 4782 | {4746} (2 rows)</code> </pre><br> 而且只有在VACUUM FULL完成其工作并删除锁之后，队列中累积的所有命令（在本示例中为SELECT）才能够捕获相应的锁（访问共享）并执行。 <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">| COMMIT</code> </pre><br><pre> <code class="plaintext hljs">|| acc_no | amount || --------+--------- || 2 | 2000.00 || 3 | 3000.00 || 1 | 1100.00 || (3 rows)</code> </pre><br> 因此，不准确的命令会使系统瘫痪的时间大大超过执行命令本身所花费的时间。 <br><br><h1> 监控工具 </h1><br> 当然，锁是正确操作所必需的，但是会导致不良期望。 可以监视此类期望以了解其原因，并在可能的情况下消除它们（例如，通过更改应用程序算法）。 <br><br> 我们已经熟悉一种方法：在长锁定时，我们可以执行对pg_locks视图的请求，查看可锁定和阻塞的事务（pg_blocking_pids函数），然后使用pg_stat_activity对其进行解密。 <br><br> 另一种方法是启用<em>log_lock_waits</em>参数。 在这种情况下，如果事务等待的时间超过了<em>deadlock_timeout</em> （尽管使用了死锁参数，我们正在谈论正常期望），则信息将显示在服务器的消息日志中。 <br><br> 让我们尝试一下。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> log_lock_waits = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br> 默认的<em>deadlock_timeout</em>参数值为一秒： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> deadlock_timeout;</code> </pre><pre> <code class="plaintext hljs"> deadlock_timeout ------------------ 1s (1 row)</code> </pre><br> 玩锁。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs">UPDATE 1</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br> 第二个UPDATE命令要求锁定。 请稍等，然后完成第一笔交易。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">COMMIT</code> </pre><br> 现在，第二笔交易即可完成。 <br><br><pre> <code class="plaintext hljs">| UPDATE 1</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">| COMMIT</code> </pre><br> 所有重要信息都进入了期刊： <br><br><pre> <code class="plaintext hljs">postgres$ tail -n 7 /var/log/postgresql/postgresql-11-main.log</code> </pre><pre> <code class="plaintext hljs">2019-08-07 15:26:30.827 MSK [5898] student@test LOG: process 5898 still waiting for ShareLock on transaction 529427 after 1000.186 ms 2019-08-07 15:26:30.827 MSK [5898] student@test DETAIL: Process holding the lock: 5862. Wait queue: 5898. 2019-08-07 15:26:30.827 MSK [5898] student@test CONTEXT: while updating tuple (0,4) in relation "accounts" 2019-08-07 15:26:30.827 MSK [5898] student@test STATEMENT: UPDATE accounts SET amount = amount + 100.00 WHERE acc_no = 1;</code> </pre><pre> <code class="plaintext hljs">2019-08-07 15:26:30.836 MSK [5898] student@test LOG: process 5898 acquired ShareLock on transaction 529427 after 1009.536 ms 2019-08-07 15:26:30.836 MSK [5898] student@test CONTEXT: while updating tuple (0,4) in relation "accounts" 2019-08-07 15:26:30.836 MSK [5898] student@test STATEMENT: UPDATE accounts SET amount = amount + 100.00 WHERE acc_no = 1;</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">待续</a> 。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN462877/">https://habr.com/ru/post/zh-CN462877/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN462859/index.html">欧洲巴士公司在俄罗斯的运作方式：巴士和乘客有何不同</a></li>
<li><a href="../zh-CN462863/index.html">8月21日播放Zabbix莫斯科聚会＃5</a></li>
<li><a href="../zh-CN462867/index.html">为您的应用选择配色方案：如何使其变得简单？</a></li>
<li><a href="../zh-CN462869/index.html">Agilean项目管理系统</a></li>
<li><a href="../zh-CN462875/index.html">如何降低成本并为业务模型提供最佳的IT支持。 我们正在寻找“救赎的中间方式”</a></li>
<li><a href="../zh-CN462879/index.html">Slurm DevOps：从Git到SRE，一站式</a></li>
<li><a href="../zh-CN462881/index.html">为什么很难选择要观看的电影（以及可以做什么）</a></li>
<li><a href="../zh-CN462883/index.html">设计SEO在线商店：（理论+清单）</a></li>
<li><a href="../zh-CN462885/index.html">容错IPoE网络在手</a></li>
<li><a href="../zh-CN462887/index.html">使用动态推荐示例个性化在线商店的体验</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>