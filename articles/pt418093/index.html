<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚵 👉🏾 👋 Curso MIT "Segurança de sistemas de computadores". Aula 3: Estouros de Buffer: Explorações e Proteção, Parte 2 👩🏿‍🎓 😀 👰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instituto de Tecnologia de Massachusetts. Curso de Aula nº 6.858. "Segurança de sistemas de computador". Nikolai Zeldovich, James Mickens. 2014 ano 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Curso MIT "Segurança de sistemas de computadores". Aula 3: Estouros de Buffer: Explorações e Proteção, Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/418093/"><h3>  Instituto de Tecnologia de Massachusetts.  Curso de Aula nº 6.858.  "Segurança de sistemas de computador".  Nikolai Zeldovich, James Mickens.  2014 ano </h3><br>  Computer Systems Security é um curso sobre o desenvolvimento e implementação de sistemas de computador seguros.  As palestras abrangem modelos de ameaças, ataques que comprometem a segurança e técnicas de segurança baseadas em trabalhos científicos recentes.  Os tópicos incluem segurança do sistema operacional (SO), recursos, gerenciamento de fluxo de informações, segurança de idiomas, protocolos de rede, segurança de hardware e segurança de aplicativos da web. <br><br>  Palestra 1: “Introdução: modelos de ameaças” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 2: “Controle de ataques de hackers” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Aula 3: “Estouros de Buffer: Explorações e Proteção” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <a name="habracut"></a><br><br>  Curiosamente, um invasor não pode pular para um endereço específico, apesar de usarmos principalmente endereços codificados.  O que ele faz é chamado de "ataque de pilha", e se você é uma pessoa má, será muito divertido para você.  Com esse ataque, um hacker começa a alocar dinamicamente toneladas de código de shell e simplesmente inseri-lo aleatoriamente na memória.  Isso é especialmente eficaz se você usar linguagens de alto nível dinamicamente, como JavaScript.  Assim, o leitor de tags está em um loop estreito e simplesmente gera um grande número de linhas de código de shell e preenche várias delas. <br><br>  O invasor não pode determinar a localização exata das linhas, ele simplesmente seleciona 10 MB de linhas de código de shell e faz um salto arbitrário.  E se ele puder, de alguma forma, controlar um dos ponteiros <b>ret</b> , existe a chance de ele "aterrar" no código do shell. <br><br><img src="https://habrastorage.org/webt/jl/7-/8x/jl7-8xckq3eq6z_wf2_m2alslzg.jpeg"><br><br>  Você pode usar um truque chamado <b>NOP slide</b> , <b>NOP sled</b> ou <b>NOP ramp</b> , em que <b>NOP</b> é <b>instruções de não operação</b> ou comandos vazios, ociosos.  Isso significa que o fluxo de execução do comando do processador "desliza" para o destino final desejado sempre que o programa vai para o endereço de memória em qualquer lugar do slide. <br><br>  Imagine que se você tiver uma linha de código do shell e for para um local aleatório nessa linha, isso pode não funcionar, porque não permite que você implante o ataque da maneira correta. <br><br>  Mas talvez o material que você coloca no heap seja basicamente apenas uma tonelada de <b>NOP</b> e, no final, você tenha um código shell.  Isso é realmente muito inteligente, porque significa que agora você pode realmente chegar ao lugar certo onde está pulando.  Porque se você pular para um desses <b>NOPs</b> , isso acontecerá "boom, boom, boom, boom, boom, boom, boom, boom" e, então, você entrará no código do shell. <br><br>  Parece que as pessoas sugerem isso, o que você provavelmente vê em nossa equipe.  Eles inventam algo assim, e esse é o problema.  Portanto, essa é outra maneira de contornar algumas coisas aleatórias, simplesmente tornando robusta a randomização de seus códigos, se isso fizer sentido. <br><br>  Então, discutimos alguns tipos de aleatoriedade que você pode usar.  Existem algumas idéias estúpidas que também surgiram nas pessoas.  Portanto, agora você sabe que, quando deseja fazer uma chamada do sistema, por exemplo, usando a função <b>syscall libc</b> , passa basicamente qualquer número único que represente a chamada do sistema que deseja fazer.  Talvez a função de <b>garfo</b> seja 7, o <b>sono</b> seja 8 ou algo assim. <br><br>  Isso significa que, se um invasor puder descobrir o endereço dessa instrução <b>syscall</b> e <b>acessá</b> -lo de alguma forma, ele poderá substituir o número de chamada do sistema que deseja usar diretamente.  Você pode imaginar que toda vez que o programa é executado, você cria uma atribuição dinâmica de números de <b>syscall a</b> <b>syscalls</b> válidos, a fim de complicar a captura do invasor. <br><br><img src="https://habrastorage.org/webt/nq/l6/ob/nql6obzl82-6vvdgdkt6iuhzs8g.jpeg"><br><br>  Existem até algumas sugestões de vanguarda para alterar o hardware, para que o equipamento contenha a chave de criptografia <b>xor</b> , que é usada para funções dinâmicas <b>xor</b> .  Imagine que toda vez que você compila um programa, todos os códigos de instruções recebem uma certa chave <b>xor</b> .  Essa chave é armazenada no registro do equipamento quando você baixa o programa inicialmente; depois disso, sempre que você executa a instrução, o equipamento executa automaticamente a operação <b>xor</b> com ele antes de continuar com esta instrução.  O lado bom dessa abordagem é que agora, mesmo que um invasor possa gerar código shell, ele não reconhecerá essa chave.  Portanto, será muito difícil descobrir o que exatamente precisa ser guardado na memória. <br><br>  <b>Público:</b> mas se ele conseguir o código, também poderá usar o <b>xor</b> para transformar o código novamente em uma instrução. <br><br>  <b>Professor:</b> sim, esse é o problema canônico, certo.  Isso é um pouco semelhante ao que acontece durante os ataques do <b>BROP</b> , quando parecemos aleatoriamente a localização do código, mas o invasor pode "senti-lo" e descobrir o que está acontecendo.  Pode-se imaginar que, por exemplo, se um invasor souber alguma sub-sequência de código que ele espera encontrar em um arquivo binário, ele tentará usar a operação <b>xor</b> para esse arquivo para extrair a chave. <br><br>  Essencialmente, discutimos todos os tipos de ataques de randomização sobre os quais eu queria falar hoje.  Antes de prosseguirmos com a programação, vale a pena discutir quais desses métodos de proteção são utilizados na prática.  Acontece que o <b>GCC</b> e o Visual Studio incluem a abordagem de <b>canários de pilha</b> por <b>padrão</b> .  Esta é uma comunidade muito popular e muito famosa.  Se você observar o Linux e o Windows, eles também tiram proveito de coisas como memória não executável e randomização do espaço de endereço.  É verdade que o sistema de <b>limites largos</b> não é tão popular entre eles, provavelmente devido ao custo de memória, processador, alarmes falsos etc., sobre os quais já falamos.  Então, basicamente, examinamos como as coisas vão impedir o problema de estouro de buffer. <br><br>  Agora vamos falar sobre <b>ROP</b> , programação orientada a reverso.  Hoje eu já contei o que ele representa em termos de randomizar o espaço de endereço e impedir que os dados sejam executados - é leitura, gravação e execução.  Na verdade, essas são coisas muito poderosas.  Porque a randomização impede a possibilidade de um invasor entender onde estão nossos endereços codificados.  E a capacidade de impedir a execução de dados garante que, mesmo se você colocar o código do shell na pilha, um invasor não pode simplesmente pular para executá-lo. <br><br>  Tudo isso parece bastante progressivo, mas os hackers estão constantemente desenvolvendo métodos de ataque contra essas soluções de defesa progressiva. <br><br>  Então, qual é a essência da programação reversa? <br><br>  E se, em vez de apenas criar um novo código durante um ataque, um invasor pudesse combinar os trechos de código existentes e depois combiná-los de maneira anormal?  Afinal, sabemos que o programa contém toneladas desse código. <br><br><img src="https://habrastorage.org/webt/fd/76/08/fd7608uferkfub0zyknpa6w1vfk.jpeg"><br><br>  Felizmente ou infelizmente, tudo depende de que lado você está.  Se você puder encontrar alguns trechos interessantes de código e combiná-los, poderá obter algo como a linguagem <b>Turing</b> , onde o atacante pode essencialmente fazer o que quiser. <br><br>  Vejamos um exemplo muito simples que lhe parecerá familiar a princípio, mas que rapidamente se tornará algo louco. <br><br>  Digamos que temos o seguinte programa.  Então, vamos ter algum tipo de função e, o que é conveniente para o atacante, aqui está essa agradável função <b>shell de execução</b> .  Portanto, isso é apenas uma chamada para o sistema, ele executará o comando <b>bin / bash</b> e isso terminará.  Em seguida, temos um processo de estouro de buffer canônico ou, desculpe, uma função que anunciará a criação de um buffer e, em seguida, usará uma dessas funções não seguras para preencher o buffer com bytes. <br><br><img src="https://habrastorage.org/webt/7r/os/et/7rosetpoais8blpdvc_-7mfkg7u.jpeg"><br><br>  Portanto, sabemos que aqui o estouro de buffer ocorre sem problemas.  Mas o interessante é que temos essa função <b>shell de execução</b> , mas é difícil obtê-la de maneiras baseadas em estouros de buffer.  Como um invasor pode chamar esse comando <b>shell de execução</b> ? <br><br>  Primeiro, o atacante pode desmontar o programa, iniciar o <b>GDB</b> e descobrir o endereço dessa coisa no arquivo executável.  Você provavelmente está familiarizado com esses métodos no trabalho de laboratório.  Em seguida, durante um estouro de buffer, um invasor pode pegar esse endereço, colocá-lo no estouro de buffer gerado e verificar se a função retorna ao <b>shell de execução</b> . <br><br>  Para deixar claro, eu vou desenhar.  Portanto, você tem uma pilha assim: na parte inferior, há um buffer excedido, acima dele é um indicador de intervalo salvo, acima dele é o endereço de retorno para <b>prosess_msg</b> .  Em baixo, à esquerda, temos um novo ponteiro de pilha que inicia a função, acima dela, um novo ponteiro de quebra, depois o ponteiro de pilha que será usado, e ainda mais alto é o ponteiro de quebra do quadro anterior.  Tudo parece bem familiar. <br><br><img src="https://habrastorage.org/webt/qf/ee/vg/qfeevg9_wr3ctwybpgx8acjcpeq.jpeg"><br><br>  Como eu disse, durante o ataque, o <b>GDB foi</b> usado para descobrir qual é o endereço do <b>shell de execução</b> .  Assim, quando o buffer transborda, podemos simplesmente colocar o endereço do <b>shell de execução</b> aqui e à direita.  Esta é realmente uma extensão bastante simples do que já sabemos fazer.  Essencialmente, isso significa que, se tivermos um comando que inicie o shell e se pudermos desmontar o arquivo binário para descobrir onde está esse endereço, podemos simplesmente colocá-lo nessa matriz de estouro localizada na parte inferior da pilha.  É bem simples. <br><br>  Portanto, esse foi um exemplo extremamente frívolo, porque o programador, por algum motivo maluco, colocou essa função aqui, apresentando ao atacante um verdadeiro presente. <br>  Agora, suponha que, em vez de chamar isso de <b>run_shell</b> , chamemos de <b>run_boring</b> e simplesmente execute o <b>comando / bin / ls</b> .  No entanto, não perdemos nada, porque teremos a string <b>char * bash_path no topo</b> , o que nos dirá o caminho para este <b>bin / bash</b> . <br><br><img src="https://habrastorage.org/webt/1d/u1/a2/1du1a2wtfwbzgtyul4bknzikpti.jpeg"><br><br>  Portanto, o mais interessante é que um invasor que deseja executar o <b>sl</b> pode "analisar" o programa e encontrar a localização do <b>run_boring</b> , e isso não é nada divertido.  Mas, na verdade, temos uma linha na memória que aponta para o caminho do shell, além disso, sabemos algo mais interessante.  Isto é, mesmo que o programa não chame o sistema com o argumento <b>/ bin / ls</b> , ele ainda fará algum tipo de chamada. <br><br>  Portanto, sabemos que o sistema deve estar de alguma forma conectado com este programa - <b>sistema (“/ bin / ls”)</b> .  Portanto, podemos usar essas duas operações <b>nulas</b> para realmente associar o sistema a esse <b>argumento char * bash_path</b> .  A primeira coisa que fazemos é entrar no <b>GDB</b> e descobrir onde esse <b>sistema (“/ bin / ls”)</b> está localizado na imagem do processo binário.  Então, basta acessar o <b>GDB</b> , digitar <b>print_system</b> e obter informações sobre o deslocamento.  Isso é bem simples e você pode fazer o mesmo com o <b>bash_path</b> .  Ou seja, você simplesmente usa o <b>GDB</b> para descobrir onde essa coisa mora. <br><br>  Depois de ter feito, você precisa fazer outra coisa.  Porque agora realmente precisamos descobrir como invocar o sistema usando o argumento que escolhemos.  E a maneira como fazemos isso consiste essencialmente em falsificar o quadro de chamada do sistema.  Se você se lembra, um quadro é o que o compilador e o hardware usam para implementar a chamada de pilha. <br><br>  Queremos organizar na pilha algo como o que descrevi nesta figura.  Na verdade, vamos falsificar um sistema que deveria estar na pilha, mas pouco antes de ele realmente executar seu código. <br><br>  Então, aqui temos o argumento do sistema, esta é a linha que queremos executar.  Na parte inferior, temos uma linha na qual o sistema deve retornar quando a linha com o argumento for concluída.  O sistema espera que a pilha tenha a mesma aparência antes do início da execução. <br><br><img src="https://habrastorage.org/webt/7r/ik/vp/7rikvpe59gsq0xdlubuhbew1juu.jpeg"><br><br>  Costumávamos assumir que não há argumentos quando você passa a função, mas agora parece um pouco diferente.  Só precisamos garantir que o <b>argumento</b> esteja no código de estouro que estamos criando.  Só precisamos garantir que esse <b>quadro de chamada</b> falsa esteja nesse array.  Assim, nosso trabalho será o seguinte.  Lembre-se de que o estouro da pilha vai de baixo para cima. <br><br><img src="https://habrastorage.org/webt/kh/by/g7/khbyg7us4ir4ydv6ossc2-bbnd0.jpeg"><br><br>  Primeiro, vamos colocar o endereço do sistema aqui.  Além disso, colocaremos um <b>endereço de retorno indesejado</b> .  Este é o local onde o sistema retornará após a conclusão.  Este endereço será um conjunto aleatório de bytes.  Acima dele, colocaremos o endereço <b>bash_path</b> .  O que acontece quando o buffer estourar agora? <br><br>  Depois que o <b>prosess_msg</b> chegar à linha de chegada, ele dirá: "OK, este é o lugar para onde eu deveria voltar"!  O código do sistema continua a funcionar, ele se move mais alto e vê o quadro de chamadas falsas que criamos.  Para o sistema, nada de impressionante acontecerá, ele dirá: "sim, aqui está, o argumento que quero executar é <b>bin / bash</b> ", ele executa e está pronto - o invasor capturou o shell! <br><br>  O que fizemos agora?  Aproveitamos o conhecimento da <b>convenção de chamada</b> , <b>convenção de chamada</b> , como uma plataforma para criar quadros de pilha falsos ou nomes de quadros falsos, eu diria.  Usando esses <b>quadros de chamada</b> falsos, podemos executar qualquer função mencionada e que já esteja definida pelo aplicativo. <br><br>  A próxima pergunta que devemos fazer é: e se o programa não tiver essa linha <b>char * bash_path</b> ?  Noto que essa linha está quase sempre presente no programa.  No entanto, suponha que vivamos em um mundo invertido, e ele ainda não está lá.  Então, o que podemos fazer para colocar essa linha em um programa? <br><br>  A primeira coisa que você pode fazer para isso é especificar o endereço correto para <b>bash_path</b> , colocando-o mais alto, aqui neste compartimento de nossa pilha, inserindo três elementos, cada um com 4 bytes de tamanho: <br><br>  <b>/ 0</b> <b><br></b>  <b>/ pat</b> <b><br></b>  <b>/ bin</b> <br><br><img src="https://habrastorage.org/webt/7y/ko/bo/7ykobou1yi5jzfppu2w0ok6b0zs.jpeg"><br><br>  Mas, de qualquer forma, nosso ponteiro vem aqui e - bum!  - A coisa está feita.  Dessa forma, agora você pode chamar argumentos simplesmente colocando-os no seu código shell.  Aterrorizante, não é?  E tudo isso é construído antes de um ataque completo do <b>BROP</b> .  Porém, antes de apontar um ataque completo do <b>BROP</b> , você precisa entender como simplesmente encadear as coisas que já estão dentro do código.  Quando eu tenho esse endereço de retorno despejado aqui, queremos apenas acessar o shell.  Mas se você for um invasor, poderá direcionar esse endereço ou endereço de retorno para algo que realmente possa ser usado.  E se você fizesse isso, poderia colocar várias funções seguidas em uma linha, vários sinais de uma função em uma linha.  Esta é realmente uma opção muito poderosa. <br><br>  Porque se simplesmente definirmos o endereço de retorno para o salto, depois disso o programa geralmente falha, o que talvez não desejemos.  Portanto, vale a pena vincular algumas dessas coisas para fazer coisas mais interessantes com o programa. <br><br>  Suponha que nosso objetivo seja chamar o sistema um número arbitrário de vezes.  Não queremos fazer isso apenas uma vez, faremos isso várias vezes arbitrariamente.  Então, como isso pode ser feito? <br><br>  Para fazer isso, usamos duas informações que já sabemos como obter.  Sabemos como obter o endereço do sistema - você só precisa procurar no <b>GDB</b> e encontrá-lo lá.  Também sabemos como encontrar o endereço dessa linha, <b>bin / bash</b> .  Agora, para iniciar esse ataque usando várias chamadas para o sistema, precisamos usar gadgets.  Isso nos aproxima do que está acontecendo no <b>BROP</b> . <br><br>  Então, o que precisamos agora é encontrar o endereço dessas duas operações de código: <b>pop% eax</b> e <b>ret</b> .  O primeiro remove o topo da pilha e o coloca no registro <b>eax</b> , e o segundo o coloca no <b>ponteiro da</b> instrução <b>eip</b> .  Isso é o que chamamos de gadget.  Parece um pequeno conjunto de instruções de montagem que um invasor pode usar para criar ataques mais ambiciosos. <br><br><img src="https://habrastorage.org/webt/r4/nw/c6/r4nwc61pbprp8gv2gof8kxdj0uw.jpeg"><br><br>  Esses gadgets são ferramentas padrão usadas pelos hackers para encontrar coisas como arquivos binários.  Também é fácil encontrar um desses gadgets, supondo que você tenha uma cópia do binário e não nos incomodamos com a randomização.  Essas coisas são muito fáceis de encontrar, bem como o endereço do sistema e assim por diante. <br><br>  Então, se temos um desses gadgets, por que podemos usá-lo?  Claro, fazer o mal!  Para fazer isso, você pode fazer o seguinte. <br><br>  Suponha que alteremos nossa pilha para que fique assim, a exploração, como antes, é direcionada de baixo para cima.  A primeira coisa que fazemos é colocar o endereço do sistema aqui e, acima dele, colocamos o endereço do gadget <b>pop / ret</b> .  Ainda mais alto, colocamos o endereço do <b>bash_path</b> e repetimos tudo: de cima, colocamos novamente o endereço do sistema, o endereço do gadget <b>pop / ret</b> e o endereço do <b>bash_path</b> . <br><br><img src="https://habrastorage.org/webt/f6/ti/zh/f6tizhirkpxkzrwjeavzjc6uulc.jpeg"><br><br>  O que acontecerá aqui agora?  Será um pouco complicado, então as notas desta palestra estão disponíveis na Internet e, por enquanto, você pode apenas ouvir o que está acontecendo aqui, mas quando eu entendi isso pela primeira vez, foi como entender que o Papai Noel não existia! <br><br>  Começaremos do local em que a entrada de <b>entrada</b> está localizada, de volta ao sistema em que a instrução <b>ret</b> removerá o item da pilha usando o comando <b>pop</b> ; agora, a parte superior do ponteiro da pilha está aqui.  Portanto, removemos o elemento usando <b>pop</b> , retornamos o procedimento <b>ret</b> , que transfere o controle para o endereço de retorno selecionado na pilha, e esse endereço de retorno é colocado lá com o comando <b>call</b> .  Então, fazemos novamente uma chamada para o sistema, e esse processo pode ser repetido várias vezes. <br><br><img src="https://habrastorage.org/webt/js/mz/oz/jsmzoz4p8_mrqlskie75rmdgcnu.jpeg"><br><br>  É claro que podemos relacionar essa sequência para executar um número arbitrário de coisas.  Essencialmente, o kernel recebe o que é chamado de programação orientada a reverso.  Observe que não realizamos nada nesta pilha.  Fizemos o que nos permitiu impedir a execução de dados sem destruir nada.  Demos um salto inesperado para fazer o que queremos.  Na verdade, é muito, muito, muito, inteligente. <br><br>  E o interessante é que, em um nível alto, identificamos esse novo modelo de computação.  ,   ,     ,       .     ,  ,    .  , -       .     ,       ,   .          ,       .         .  ,        .  ,    ,     <b>stack canaries.</b> <br><br>   ,  «»  ,      .  ,  ,  «»    <b>ret address</b>   <b>saved %ebp</b> ,    -   ,   «».  ,        <b>ret</b> ,   ,       «»,  ,    - .    <b>stack canaries</b> . <br><br>  ,    «».         ,   . ,     «»? <br><br> ,    ,  ,      . <br> ,   ,  ,   «»  ,    «»  «». <br><br>  ,    ,  ,    «»     ,   ,    . <br>   ,    -  ,     «»         ,         .    ,   ?           ? <br>   ,       <b>fork</b>    .   , <b>fork</b>     .    ,   ,    ,      <b>fork</b> ,      ,  ,       ,       «»   .     ,       <b>stack canaries</b> . <br><br>       «»?      .  ,    ,     ,   «».  «»    .                . <br><br><img src="https://habrastorage.org/webt/ql/h1/ol/qlh1olpcbsug9nbtozpjevlll7u.jpeg"><br><br> ,    ,     –    ,      «».         , ,      0.    ,  «»,      .    ,  : <br><br> «,      «»!     ,      0.  «»!  1 –  «»,  2 –   . ,    2- .  ,     ,  «». <br><br><img src="https://habrastorage.org/webt/tx/xp/rc/txxprcve2i3lgkwslbdrluiv-sk.jpeg"><br><br>    ,   ,      ,     . <br><br>      «»,   ,    ,     .     ,          ,      «». <br><br> 57:10  <br><br> : <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Curso MIT "Segurança de sistemas de computadores".</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aula 3: Estouros de Buffer: Explorações e Proteção, Parte 3</font></font></a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xSQxaie_h1o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A versão completa do curso está disponível </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br>  Obrigado por ficar conosco.  Você gosta dos nossos artigos?  Deseja ver materiais mais interessantes?  Ajude-nos fazendo um pedido ou recomendando a seus amigos, um <b>desconto de 30% para os usuários da Habr em um análogo exclusivo de servidores básicos que inventamos para você:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Toda a verdade sobre o VPS (KVM) E5-2650 v4 (6 núcleos) 10GB DDR4 240GB SSD 1Gbps de US $ 20 ou como dividir o servidor?</a>  (as opções estão disponíveis com RAID1 e RAID10, até 24 núcleos e até 40GB DDR4). <br><br>  <b>Dell R730xd 2 vezes mais barato?</b>  Somente nós temos <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2 TVs Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 a partir de US $ 249</a> na Holanda e nos EUA!</b>  Leia sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como criar um prédio de infraestrutura.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">classe usando servidores Dell R730xd E5-2650 v4 custando 9.000 euros por um centavo?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt418093/">https://habr.com/ru/post/pt418093/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt418083/index.html">Servidor simples com GraphQL em vez de REST, implementação em java</a></li>
<li><a href="../pt418085/index.html">Usando promessas em JavaScript</a></li>
<li><a href="../pt418087/index.html">80% dos check-outs de autoatendimento estão em risco</a></li>
<li><a href="../pt418089/index.html">Visão geral da fresadora CNC SolidCraft</a></li>
<li><a href="../pt418091/index.html">Lista de artigos e literatura sobre NAS</a></li>
<li><a href="../pt418095/index.html">Sobre o dispositivo da funcionalidade de teste integrada no Rust (tradução)</a></li>
<li><a href="../pt418099/index.html">Curso MIT "Segurança de sistemas de computadores". Aula 3: Estouros de Buffer: Explorações e Proteção, Parte 3</a></li>
<li><a href="../pt418101/index.html">Etimologia dos Termos de TI</a></li>
<li><a href="../pt418103/index.html">O chefe da Roscosmos lembrou seu primeiro foguete e compartilhou planos para o futuro</a></li>
<li><a href="../pt418105/index.html">Por que abrir o YouTube no Firefox ou Edge pode demorar 5 vezes mais do que no Google Chrome</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>