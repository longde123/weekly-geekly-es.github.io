<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸšµ ğŸ‘‰ğŸ¾ ğŸ‘‹ Curso MIT "SeguranÃ§a de sistemas de computadores". Aula 3: Estouros de Buffer: ExploraÃ§Ãµes e ProteÃ§Ã£o, Parte 2 ğŸ‘©ğŸ¿â€ğŸ“ ğŸ˜€ ğŸ‘°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instituto de Tecnologia de Massachusetts. Curso de Aula nÂº 6.858. "SeguranÃ§a de sistemas de computador". Nikolai Zeldovich, James Mickens. 2014 ano 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Curso MIT "SeguranÃ§a de sistemas de computadores". Aula 3: Estouros de Buffer: ExploraÃ§Ãµes e ProteÃ§Ã£o, Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/418093/"><h3>  Instituto de Tecnologia de Massachusetts.  Curso de Aula nÂº 6.858.  "SeguranÃ§a de sistemas de computador".  Nikolai Zeldovich, James Mickens.  2014 ano </h3><br>  Computer Systems Security Ã© um curso sobre o desenvolvimento e implementaÃ§Ã£o de sistemas de computador seguros.  As palestras abrangem modelos de ameaÃ§as, ataques que comprometem a seguranÃ§a e tÃ©cnicas de seguranÃ§a baseadas em trabalhos cientÃ­ficos recentes.  Os tÃ³picos incluem seguranÃ§a do sistema operacional (SO), recursos, gerenciamento de fluxo de informaÃ§Ãµes, seguranÃ§a de idiomas, protocolos de rede, seguranÃ§a de hardware e seguranÃ§a de aplicativos da web. <br><br>  Palestra 1: â€œIntroduÃ§Ã£o: modelos de ameaÃ§asâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 2: â€œControle de ataques de hackersâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Aula 3: â€œEstouros de Buffer: ExploraÃ§Ãµes e ProteÃ§Ã£oâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <a name="habracut"></a><br><br>  Curiosamente, um invasor nÃ£o pode pular para um endereÃ§o especÃ­fico, apesar de usarmos principalmente endereÃ§os codificados.  O que ele faz Ã© chamado de "ataque de pilha", e se vocÃª Ã© uma pessoa mÃ¡, serÃ¡ muito divertido para vocÃª.  Com esse ataque, um hacker comeÃ§a a alocar dinamicamente toneladas de cÃ³digo de shell e simplesmente inseri-lo aleatoriamente na memÃ³ria.  Isso Ã© especialmente eficaz se vocÃª usar linguagens de alto nÃ­vel dinamicamente, como JavaScript.  Assim, o leitor de tags estÃ¡ em um loop estreito e simplesmente gera um grande nÃºmero de linhas de cÃ³digo de shell e preenche vÃ¡rias delas. <br><br>  O invasor nÃ£o pode determinar a localizaÃ§Ã£o exata das linhas, ele simplesmente seleciona 10 MB de linhas de cÃ³digo de shell e faz um salto arbitrÃ¡rio.  E se ele puder, de alguma forma, controlar um dos ponteiros <b>ret</b> , existe a chance de ele "aterrar" no cÃ³digo do shell. <br><br><img src="https://habrastorage.org/webt/jl/7-/8x/jl7-8xckq3eq6z_wf2_m2alslzg.jpeg"><br><br>  VocÃª pode usar um truque chamado <b>NOP slide</b> , <b>NOP sled</b> ou <b>NOP ramp</b> , em que <b>NOP</b> Ã© <b>instruÃ§Ãµes de nÃ£o operaÃ§Ã£o</b> ou comandos vazios, ociosos.  Isso significa que o fluxo de execuÃ§Ã£o do comando do processador "desliza" para o destino final desejado sempre que o programa vai para o endereÃ§o de memÃ³ria em qualquer lugar do slide. <br><br>  Imagine que se vocÃª tiver uma linha de cÃ³digo do shell e for para um local aleatÃ³rio nessa linha, isso pode nÃ£o funcionar, porque nÃ£o permite que vocÃª implante o ataque da maneira correta. <br><br>  Mas talvez o material que vocÃª coloca no heap seja basicamente apenas uma tonelada de <b>NOP</b> e, no final, vocÃª tenha um cÃ³digo shell.  Isso Ã© realmente muito inteligente, porque significa que agora vocÃª pode realmente chegar ao lugar certo onde estÃ¡ pulando.  Porque se vocÃª pular para um desses <b>NOPs</b> , isso acontecerÃ¡ "boom, boom, boom, boom, boom, boom, boom, boom" e, entÃ£o, vocÃª entrarÃ¡ no cÃ³digo do shell. <br><br>  Parece que as pessoas sugerem isso, o que vocÃª provavelmente vÃª em nossa equipe.  Eles inventam algo assim, e esse Ã© o problema.  Portanto, essa Ã© outra maneira de contornar algumas coisas aleatÃ³rias, simplesmente tornando robusta a randomizaÃ§Ã£o de seus cÃ³digos, se isso fizer sentido. <br><br>  EntÃ£o, discutimos alguns tipos de aleatoriedade que vocÃª pode usar.  Existem algumas idÃ©ias estÃºpidas que tambÃ©m surgiram nas pessoas.  Portanto, agora vocÃª sabe que, quando deseja fazer uma chamada do sistema, por exemplo, usando a funÃ§Ã£o <b>syscall libc</b> , passa basicamente qualquer nÃºmero Ãºnico que represente a chamada do sistema que deseja fazer.  Talvez a funÃ§Ã£o de <b>garfo</b> seja 7, o <b>sono</b> seja 8 ou algo assim. <br><br>  Isso significa que, se um invasor puder descobrir o endereÃ§o dessa instruÃ§Ã£o <b>syscall</b> e <b>acessÃ¡</b> -lo de alguma forma, ele poderÃ¡ substituir o nÃºmero de chamada do sistema que deseja usar diretamente.  VocÃª pode imaginar que toda vez que o programa Ã© executado, vocÃª cria uma atribuiÃ§Ã£o dinÃ¢mica de nÃºmeros de <b>syscall a</b> <b>syscalls</b> vÃ¡lidos, a fim de complicar a captura do invasor. <br><br><img src="https://habrastorage.org/webt/nq/l6/ob/nql6obzl82-6vvdgdkt6iuhzs8g.jpeg"><br><br>  Existem atÃ© algumas sugestÃµes de vanguarda para alterar o hardware, para que o equipamento contenha a chave de criptografia <b>xor</b> , que Ã© usada para funÃ§Ãµes dinÃ¢micas <b>xor</b> .  Imagine que toda vez que vocÃª compila um programa, todos os cÃ³digos de instruÃ§Ãµes recebem uma certa chave <b>xor</b> .  Essa chave Ã© armazenada no registro do equipamento quando vocÃª baixa o programa inicialmente; depois disso, sempre que vocÃª executa a instruÃ§Ã£o, o equipamento executa automaticamente a operaÃ§Ã£o <b>xor</b> com ele antes de continuar com esta instruÃ§Ã£o.  O lado bom dessa abordagem Ã© que agora, mesmo que um invasor possa gerar cÃ³digo shell, ele nÃ£o reconhecerÃ¡ essa chave.  Portanto, serÃ¡ muito difÃ­cil descobrir o que exatamente precisa ser guardado na memÃ³ria. <br><br>  <b>PÃºblico:</b> mas se ele conseguir o cÃ³digo, tambÃ©m poderÃ¡ usar o <b>xor</b> para transformar o cÃ³digo novamente em uma instruÃ§Ã£o. <br><br>  <b>Professor:</b> sim, esse Ã© o problema canÃ´nico, certo.  Isso Ã© um pouco semelhante ao que acontece durante os ataques do <b>BROP</b> , quando parecemos aleatoriamente a localizaÃ§Ã£o do cÃ³digo, mas o invasor pode "senti-lo" e descobrir o que estÃ¡ acontecendo.  Pode-se imaginar que, por exemplo, se um invasor souber alguma sub-sequÃªncia de cÃ³digo que ele espera encontrar em um arquivo binÃ¡rio, ele tentarÃ¡ usar a operaÃ§Ã£o <b>xor</b> para esse arquivo para extrair a chave. <br><br>  Essencialmente, discutimos todos os tipos de ataques de randomizaÃ§Ã£o sobre os quais eu queria falar hoje.  Antes de prosseguirmos com a programaÃ§Ã£o, vale a pena discutir quais desses mÃ©todos de proteÃ§Ã£o sÃ£o utilizados na prÃ¡tica.  Acontece que o <b>GCC</b> e o Visual Studio incluem a abordagem de <b>canÃ¡rios de pilha</b> por <b>padrÃ£o</b> .  Esta Ã© uma comunidade muito popular e muito famosa.  Se vocÃª observar o Linux e o Windows, eles tambÃ©m tiram proveito de coisas como memÃ³ria nÃ£o executÃ¡vel e randomizaÃ§Ã£o do espaÃ§o de endereÃ§o.  Ã‰ verdade que o sistema de <b>limites largos</b> nÃ£o Ã© tÃ£o popular entre eles, provavelmente devido ao custo de memÃ³ria, processador, alarmes falsos etc., sobre os quais jÃ¡ falamos.  EntÃ£o, basicamente, examinamos como as coisas vÃ£o impedir o problema de estouro de buffer. <br><br>  Agora vamos falar sobre <b>ROP</b> , programaÃ§Ã£o orientada a reverso.  Hoje eu jÃ¡ contei o que ele representa em termos de randomizar o espaÃ§o de endereÃ§o e impedir que os dados sejam executados - Ã© leitura, gravaÃ§Ã£o e execuÃ§Ã£o.  Na verdade, essas sÃ£o coisas muito poderosas.  Porque a randomizaÃ§Ã£o impede a possibilidade de um invasor entender onde estÃ£o nossos endereÃ§os codificados.  E a capacidade de impedir a execuÃ§Ã£o de dados garante que, mesmo se vocÃª colocar o cÃ³digo do shell na pilha, um invasor nÃ£o pode simplesmente pular para executÃ¡-lo. <br><br>  Tudo isso parece bastante progressivo, mas os hackers estÃ£o constantemente desenvolvendo mÃ©todos de ataque contra essas soluÃ§Ãµes de defesa progressiva. <br><br>  EntÃ£o, qual Ã© a essÃªncia da programaÃ§Ã£o reversa? <br><br>  E se, em vez de apenas criar um novo cÃ³digo durante um ataque, um invasor pudesse combinar os trechos de cÃ³digo existentes e depois combinÃ¡-los de maneira anormal?  Afinal, sabemos que o programa contÃ©m toneladas desse cÃ³digo. <br><br><img src="https://habrastorage.org/webt/fd/76/08/fd7608uferkfub0zyknpa6w1vfk.jpeg"><br><br>  Felizmente ou infelizmente, tudo depende de que lado vocÃª estÃ¡.  Se vocÃª puder encontrar alguns trechos interessantes de cÃ³digo e combinÃ¡-los, poderÃ¡ obter algo como a linguagem <b>Turing</b> , onde o atacante pode essencialmente fazer o que quiser. <br><br>  Vejamos um exemplo muito simples que lhe parecerÃ¡ familiar a princÃ­pio, mas que rapidamente se tornarÃ¡ algo louco. <br><br>  Digamos que temos o seguinte programa.  EntÃ£o, vamos ter algum tipo de funÃ§Ã£o e, o que Ã© conveniente para o atacante, aqui estÃ¡ essa agradÃ¡vel funÃ§Ã£o <b>shell de execuÃ§Ã£o</b> .  Portanto, isso Ã© apenas uma chamada para o sistema, ele executarÃ¡ o comando <b>bin / bash</b> e isso terminarÃ¡.  Em seguida, temos um processo de estouro de buffer canÃ´nico ou, desculpe, uma funÃ§Ã£o que anunciarÃ¡ a criaÃ§Ã£o de um buffer e, em seguida, usarÃ¡ uma dessas funÃ§Ãµes nÃ£o seguras para preencher o buffer com bytes. <br><br><img src="https://habrastorage.org/webt/7r/os/et/7rosetpoais8blpdvc_-7mfkg7u.jpeg"><br><br>  Portanto, sabemos que aqui o estouro de buffer ocorre sem problemas.  Mas o interessante Ã© que temos essa funÃ§Ã£o <b>shell de execuÃ§Ã£o</b> , mas Ã© difÃ­cil obtÃª-la de maneiras baseadas em estouros de buffer.  Como um invasor pode chamar esse comando <b>shell de execuÃ§Ã£o</b> ? <br><br>  Primeiro, o atacante pode desmontar o programa, iniciar o <b>GDB</b> e descobrir o endereÃ§o dessa coisa no arquivo executÃ¡vel.  VocÃª provavelmente estÃ¡ familiarizado com esses mÃ©todos no trabalho de laboratÃ³rio.  Em seguida, durante um estouro de buffer, um invasor pode pegar esse endereÃ§o, colocÃ¡-lo no estouro de buffer gerado e verificar se a funÃ§Ã£o retorna ao <b>shell de execuÃ§Ã£o</b> . <br><br>  Para deixar claro, eu vou desenhar.  Portanto, vocÃª tem uma pilha assim: na parte inferior, hÃ¡ um buffer excedido, acima dele Ã© um indicador de intervalo salvo, acima dele Ã© o endereÃ§o de retorno para <b>prosess_msg</b> .  Em baixo, Ã  esquerda, temos um novo ponteiro de pilha que inicia a funÃ§Ã£o, acima dela, um novo ponteiro de quebra, depois o ponteiro de pilha que serÃ¡ usado, e ainda mais alto Ã© o ponteiro de quebra do quadro anterior.  Tudo parece bem familiar. <br><br><img src="https://habrastorage.org/webt/qf/ee/vg/qfeevg9_wr3ctwybpgx8acjcpeq.jpeg"><br><br>  Como eu disse, durante o ataque, o <b>GDB foi</b> usado para descobrir qual Ã© o endereÃ§o do <b>shell de execuÃ§Ã£o</b> .  Assim, quando o buffer transborda, podemos simplesmente colocar o endereÃ§o do <b>shell de execuÃ§Ã£o</b> aqui e Ã  direita.  Esta Ã© realmente uma extensÃ£o bastante simples do que jÃ¡ sabemos fazer.  Essencialmente, isso significa que, se tivermos um comando que inicie o shell e se pudermos desmontar o arquivo binÃ¡rio para descobrir onde estÃ¡ esse endereÃ§o, podemos simplesmente colocÃ¡-lo nessa matriz de estouro localizada na parte inferior da pilha.  Ã‰ bem simples. <br><br>  Portanto, esse foi um exemplo extremamente frÃ­volo, porque o programador, por algum motivo maluco, colocou essa funÃ§Ã£o aqui, apresentando ao atacante um verdadeiro presente. <br>  Agora, suponha que, em vez de chamar isso de <b>run_shell</b> , chamemos de <b>run_boring</b> e simplesmente execute o <b>comando / bin / ls</b> .  No entanto, nÃ£o perdemos nada, porque teremos a string <b>char * bash_path no topo</b> , o que nos dirÃ¡ o caminho para este <b>bin / bash</b> . <br><br><img src="https://habrastorage.org/webt/1d/u1/a2/1du1a2wtfwbzgtyul4bknzikpti.jpeg"><br><br>  Portanto, o mais interessante Ã© que um invasor que deseja executar o <b>sl</b> pode "analisar" o programa e encontrar a localizaÃ§Ã£o do <b>run_boring</b> , e isso nÃ£o Ã© nada divertido.  Mas, na verdade, temos uma linha na memÃ³ria que aponta para o caminho do shell, alÃ©m disso, sabemos algo mais interessante.  Isto Ã©, mesmo que o programa nÃ£o chame o sistema com o argumento <b>/ bin / ls</b> , ele ainda farÃ¡ algum tipo de chamada. <br><br>  Portanto, sabemos que o sistema deve estar de alguma forma conectado com este programa - <b>sistema (â€œ/ bin / lsâ€)</b> .  Portanto, podemos usar essas duas operaÃ§Ãµes <b>nulas</b> para realmente associar o sistema a esse <b>argumento char * bash_path</b> .  A primeira coisa que fazemos Ã© entrar no <b>GDB</b> e descobrir onde esse <b>sistema (â€œ/ bin / lsâ€)</b> estÃ¡ localizado na imagem do processo binÃ¡rio.  EntÃ£o, basta acessar o <b>GDB</b> , digitar <b>print_system</b> e obter informaÃ§Ãµes sobre o deslocamento.  Isso Ã© bem simples e vocÃª pode fazer o mesmo com o <b>bash_path</b> .  Ou seja, vocÃª simplesmente usa o <b>GDB</b> para descobrir onde essa coisa mora. <br><br>  Depois de ter feito, vocÃª precisa fazer outra coisa.  Porque agora realmente precisamos descobrir como invocar o sistema usando o argumento que escolhemos.  E a maneira como fazemos isso consiste essencialmente em falsificar o quadro de chamada do sistema.  Se vocÃª se lembra, um quadro Ã© o que o compilador e o hardware usam para implementar a chamada de pilha. <br><br>  Queremos organizar na pilha algo como o que descrevi nesta figura.  Na verdade, vamos falsificar um sistema que deveria estar na pilha, mas pouco antes de ele realmente executar seu cÃ³digo. <br><br>  EntÃ£o, aqui temos o argumento do sistema, esta Ã© a linha que queremos executar.  Na parte inferior, temos uma linha na qual o sistema deve retornar quando a linha com o argumento for concluÃ­da.  O sistema espera que a pilha tenha a mesma aparÃªncia antes do inÃ­cio da execuÃ§Ã£o. <br><br><img src="https://habrastorage.org/webt/7r/ik/vp/7rikvpe59gsq0xdlubuhbew1juu.jpeg"><br><br>  CostumÃ¡vamos assumir que nÃ£o hÃ¡ argumentos quando vocÃª passa a funÃ§Ã£o, mas agora parece um pouco diferente.  SÃ³ precisamos garantir que o <b>argumento</b> esteja no cÃ³digo de estouro que estamos criando.  SÃ³ precisamos garantir que esse <b>quadro de chamada</b> falsa esteja nesse array.  Assim, nosso trabalho serÃ¡ o seguinte.  Lembre-se de que o estouro da pilha vai de baixo para cima. <br><br><img src="https://habrastorage.org/webt/kh/by/g7/khbyg7us4ir4ydv6ossc2-bbnd0.jpeg"><br><br>  Primeiro, vamos colocar o endereÃ§o do sistema aqui.  AlÃ©m disso, colocaremos um <b>endereÃ§o de retorno indesejado</b> .  Este Ã© o local onde o sistema retornarÃ¡ apÃ³s a conclusÃ£o.  Este endereÃ§o serÃ¡ um conjunto aleatÃ³rio de bytes.  Acima dele, colocaremos o endereÃ§o <b>bash_path</b> .  O que acontece quando o buffer estourar agora? <br><br>  Depois que o <b>prosess_msg</b> chegar Ã  linha de chegada, ele dirÃ¡: "OK, este Ã© o lugar para onde eu deveria voltar"!  O cÃ³digo do sistema continua a funcionar, ele se move mais alto e vÃª o quadro de chamadas falsas que criamos.  Para o sistema, nada de impressionante acontecerÃ¡, ele dirÃ¡: "sim, aqui estÃ¡, o argumento que quero executar Ã© <b>bin / bash</b> ", ele executa e estÃ¡ pronto - o invasor capturou o shell! <br><br>  O que fizemos agora?  Aproveitamos o conhecimento da <b>convenÃ§Ã£o de chamada</b> , <b>convenÃ§Ã£o de chamada</b> , como uma plataforma para criar quadros de pilha falsos ou nomes de quadros falsos, eu diria.  Usando esses <b>quadros de chamada</b> falsos, podemos executar qualquer funÃ§Ã£o mencionada e que jÃ¡ esteja definida pelo aplicativo. <br><br>  A prÃ³xima pergunta que devemos fazer Ã©: e se o programa nÃ£o tiver essa linha <b>char * bash_path</b> ?  Noto que essa linha estÃ¡ quase sempre presente no programa.  No entanto, suponha que vivamos em um mundo invertido, e ele ainda nÃ£o estÃ¡ lÃ¡.  EntÃ£o, o que podemos fazer para colocar essa linha em um programa? <br><br>  A primeira coisa que vocÃª pode fazer para isso Ã© especificar o endereÃ§o correto para <b>bash_path</b> , colocando-o mais alto, aqui neste compartimento de nossa pilha, inserindo trÃªs elementos, cada um com 4 bytes de tamanho: <br><br>  <b>/ 0</b> <b><br></b>  <b>/ pat</b> <b><br></b>  <b>/ bin</b> <br><br><img src="https://habrastorage.org/webt/7y/ko/bo/7ykobou1yi5jzfppu2w0ok6b0zs.jpeg"><br><br>  Mas, de qualquer forma, nosso ponteiro vem aqui e - bum!  - A coisa estÃ¡ feita.  Dessa forma, agora vocÃª pode chamar argumentos simplesmente colocando-os no seu cÃ³digo shell.  Aterrorizante, nÃ£o Ã©?  E tudo isso Ã© construÃ­do antes de um ataque completo do <b>BROP</b> .  PorÃ©m, antes de apontar um ataque completo do <b>BROP</b> , vocÃª precisa entender como simplesmente encadear as coisas que jÃ¡ estÃ£o dentro do cÃ³digo.  Quando eu tenho esse endereÃ§o de retorno despejado aqui, queremos apenas acessar o shell.  Mas se vocÃª for um invasor, poderÃ¡ direcionar esse endereÃ§o ou endereÃ§o de retorno para algo que realmente possa ser usado.  E se vocÃª fizesse isso, poderia colocar vÃ¡rias funÃ§Ãµes seguidas em uma linha, vÃ¡rios sinais de uma funÃ§Ã£o em uma linha.  Esta Ã© realmente uma opÃ§Ã£o muito poderosa. <br><br>  Porque se simplesmente definirmos o endereÃ§o de retorno para o salto, depois disso o programa geralmente falha, o que talvez nÃ£o desejemos.  Portanto, vale a pena vincular algumas dessas coisas para fazer coisas mais interessantes com o programa. <br><br>  Suponha que nosso objetivo seja chamar o sistema um nÃºmero arbitrÃ¡rio de vezes.  NÃ£o queremos fazer isso apenas uma vez, faremos isso vÃ¡rias vezes arbitrariamente.  EntÃ£o, como isso pode ser feito? <br><br>  Para fazer isso, usamos duas informaÃ§Ãµes que jÃ¡ sabemos como obter.  Sabemos como obter o endereÃ§o do sistema - vocÃª sÃ³ precisa procurar no <b>GDB</b> e encontrÃ¡-lo lÃ¡.  TambÃ©m sabemos como encontrar o endereÃ§o dessa linha, <b>bin / bash</b> .  Agora, para iniciar esse ataque usando vÃ¡rias chamadas para o sistema, precisamos usar gadgets.  Isso nos aproxima do que estÃ¡ acontecendo no <b>BROP</b> . <br><br>  EntÃ£o, o que precisamos agora Ã© encontrar o endereÃ§o dessas duas operaÃ§Ãµes de cÃ³digo: <b>pop% eax</b> e <b>ret</b> .  O primeiro remove o topo da pilha e o coloca no registro <b>eax</b> , e o segundo o coloca no <b>ponteiro da</b> instruÃ§Ã£o <b>eip</b> .  Isso Ã© o que chamamos de gadget.  Parece um pequeno conjunto de instruÃ§Ãµes de montagem que um invasor pode usar para criar ataques mais ambiciosos. <br><br><img src="https://habrastorage.org/webt/r4/nw/c6/r4nwc61pbprp8gv2gof8kxdj0uw.jpeg"><br><br>  Esses gadgets sÃ£o ferramentas padrÃ£o usadas pelos hackers para encontrar coisas como arquivos binÃ¡rios.  TambÃ©m Ã© fÃ¡cil encontrar um desses gadgets, supondo que vocÃª tenha uma cÃ³pia do binÃ¡rio e nÃ£o nos incomodamos com a randomizaÃ§Ã£o.  Essas coisas sÃ£o muito fÃ¡ceis de encontrar, bem como o endereÃ§o do sistema e assim por diante. <br><br>  EntÃ£o, se temos um desses gadgets, por que podemos usÃ¡-lo?  Claro, fazer o mal!  Para fazer isso, vocÃª pode fazer o seguinte. <br><br>  Suponha que alteremos nossa pilha para que fique assim, a exploraÃ§Ã£o, como antes, Ã© direcionada de baixo para cima.  A primeira coisa que fazemos Ã© colocar o endereÃ§o do sistema aqui e, acima dele, colocamos o endereÃ§o do gadget <b>pop / ret</b> .  Ainda mais alto, colocamos o endereÃ§o do <b>bash_path</b> e repetimos tudo: de cima, colocamos novamente o endereÃ§o do sistema, o endereÃ§o do gadget <b>pop / ret</b> e o endereÃ§o do <b>bash_path</b> . <br><br><img src="https://habrastorage.org/webt/f6/ti/zh/f6tizhirkpxkzrwjeavzjc6uulc.jpeg"><br><br>  O que acontecerÃ¡ aqui agora?  SerÃ¡ um pouco complicado, entÃ£o as notas desta palestra estÃ£o disponÃ­veis na Internet e, por enquanto, vocÃª pode apenas ouvir o que estÃ¡ acontecendo aqui, mas quando eu entendi isso pela primeira vez, foi como entender que o Papai Noel nÃ£o existia! <br><br>  ComeÃ§aremos do local em que a entrada de <b>entrada</b> estÃ¡ localizada, de volta ao sistema em que a instruÃ§Ã£o <b>ret</b> removerÃ¡ o item da pilha usando o comando <b>pop</b> ; agora, a parte superior do ponteiro da pilha estÃ¡ aqui.  Portanto, removemos o elemento usando <b>pop</b> , retornamos o procedimento <b>ret</b> , que transfere o controle para o endereÃ§o de retorno selecionado na pilha, e esse endereÃ§o de retorno Ã© colocado lÃ¡ com o comando <b>call</b> .  EntÃ£o, fazemos novamente uma chamada para o sistema, e esse processo pode ser repetido vÃ¡rias vezes. <br><br><img src="https://habrastorage.org/webt/js/mz/oz/jsmzoz4p8_mrqlskie75rmdgcnu.jpeg"><br><br>  Ã‰ claro que podemos relacionar essa sequÃªncia para executar um nÃºmero arbitrÃ¡rio de coisas.  Essencialmente, o kernel recebe o que Ã© chamado de programaÃ§Ã£o orientada a reverso.  Observe que nÃ£o realizamos nada nesta pilha.  Fizemos o que nos permitiu impedir a execuÃ§Ã£o de dados sem destruir nada.  Demos um salto inesperado para fazer o que queremos.  Na verdade, Ã© muito, muito, muito, inteligente. <br><br>  E o interessante Ã© que, em um nÃ­vel alto, identificamos esse novo modelo de computaÃ§Ã£o.  ,   ,     ,       .     ,  ,    .  , -       .     ,       ,   .          ,       .         .  ,        .  ,    ,     <b>stack canaries.</b> <br><br>   ,  Â«Â»  ,      .  ,  ,  Â«Â»    <b>ret address</b>   <b>saved %ebp</b> ,    -   ,   Â«Â».  ,        <b>ret</b> ,   ,       Â«Â»,  ,    - .    <b>stack canaries</b> . <br><br>  ,    Â«Â».         ,   . ,     Â«Â»? <br><br> ,    ,  ,      . <br> ,   ,  ,   Â«Â»  ,    Â«Â»  Â«Â». <br><br>  ,    ,  ,    Â«Â»     ,   ,    . <br>   ,    -  ,     Â«Â»         ,         .    ,   ?           ? <br>   ,       <b>fork</b>    .   , <b>fork</b>     .    ,   ,    ,      <b>fork</b> ,      ,  ,       ,       Â«Â»   .     ,       <b>stack canaries</b> . <br><br>       Â«Â»?      .  ,    ,     ,   Â«Â».  Â«Â»    .                . <br><br><img src="https://habrastorage.org/webt/ql/h1/ol/qlh1olpcbsug9nbtozpjevlll7u.jpeg"><br><br> ,    ,     â€“    ,      Â«Â».         , ,      0.    ,  Â«Â»,      .    ,  : <br><br> Â«,      Â«Â»!     ,      0.  Â«Â»!  1 â€“  Â«Â»,  2 â€“   . ,    2- .  ,     ,  Â«Â». <br><br><img src="https://habrastorage.org/webt/tx/xp/rc/txxprcve2i3lgkwslbdrluiv-sk.jpeg"><br><br>    ,   ,      ,     . <br><br>      Â«Â»,   ,    ,     .     ,          ,      Â«Â». <br><br> 57:10  <br><br> : <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Curso MIT "SeguranÃ§a de sistemas de computadores".</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aula 3: Estouros de Buffer: ExploraÃ§Ãµes e ProteÃ§Ã£o, Parte 3</font></font></a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xSQxaie_h1o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A versÃ£o completa do curso estÃ¡ disponÃ­vel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br>  Obrigado por ficar conosco.  VocÃª gosta dos nossos artigos?  Deseja ver materiais mais interessantes?  Ajude-nos fazendo um pedido ou recomendando a seus amigos, um <b>desconto de 30% para os usuÃ¡rios da Habr em um anÃ¡logo exclusivo de servidores bÃ¡sicos que inventamos para vocÃª:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Toda a verdade sobre o VPS (KVM) E5-2650 v4 (6 nÃºcleos) 10GB DDR4 240GB SSD 1Gbps de US $ 20 ou como dividir o servidor?</a>  (as opÃ§Ãµes estÃ£o disponÃ­veis com RAID1 e RAID10, atÃ© 24 nÃºcleos e atÃ© 40GB DDR4). <br><br>  <b>Dell R730xd 2 vezes mais barato?</b>  Somente nÃ³s temos <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2 TVs Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 a partir de US $ 249</a> na Holanda e nos EUA!</b>  Leia sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como criar um prÃ©dio de infraestrutura.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">classe usando servidores Dell R730xd E5-2650 v4 custando 9.000 euros por um centavo?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt418093/">https://habr.com/ru/post/pt418093/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt418083/index.html">Servidor simples com GraphQL em vez de REST, implementaÃ§Ã£o em java</a></li>
<li><a href="../pt418085/index.html">Usando promessas em JavaScript</a></li>
<li><a href="../pt418087/index.html">80% dos check-outs de autoatendimento estÃ£o em risco</a></li>
<li><a href="../pt418089/index.html">VisÃ£o geral da fresadora CNC SolidCraft</a></li>
<li><a href="../pt418091/index.html">Lista de artigos e literatura sobre NAS</a></li>
<li><a href="../pt418095/index.html">Sobre o dispositivo da funcionalidade de teste integrada no Rust (traduÃ§Ã£o)</a></li>
<li><a href="../pt418099/index.html">Curso MIT "SeguranÃ§a de sistemas de computadores". Aula 3: Estouros de Buffer: ExploraÃ§Ãµes e ProteÃ§Ã£o, Parte 3</a></li>
<li><a href="../pt418101/index.html">Etimologia dos Termos de TI</a></li>
<li><a href="../pt418103/index.html">O chefe da Roscosmos lembrou seu primeiro foguete e compartilhou planos para o futuro</a></li>
<li><a href="../pt418105/index.html">Por que abrir o YouTube no Firefox ou Edge pode demorar 5 vezes mais do que no Google Chrome</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>