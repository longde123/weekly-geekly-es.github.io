<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úíÔ∏è ü§æ ü§üüèª Interessante Neuigkeiten Vue 3 üë¥üèΩ üîû üßîüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anstelle des Vorworts 
 Vue wird in allen FunCorp-Projekten verwendet. Wir beobachten die Entwicklung des Frameworks genau, verbessern den Entwicklung...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interessante Neuigkeiten Vue 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/475968/"><h2>  Anstelle des Vorworts </h2><br>  Vue wird in allen FunCorp-Projekten verwendet.  Wir beobachten die Entwicklung des Frameworks genau, verbessern den Entwicklungsprozess st√§ndig und setzen die Best Practices um.  Und nat√ºrlich konnten wir den Artikel von Philip Rakovsky, Mitbegr√ºnder von VueStorefront, √ºber neue Vue 3-Funktionen, die das Schreiben von Code ernsthaft beeintr√§chtigen, nicht √ºbersetzten. <br><br><img src="https://habrastorage.org/webt/ta/6z/aq/ta6zaqz4kxyqh_wh0zoo4zayqeo.png" alt="Bild"><br>  Das letzte Mal haben wir uns Funktionen angesehen, die sich auf die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Leistung von Vue 3</a> auswirken.  Wir wissen bereits, dass auf der neuen Version des Frameworks geschriebene Anwendungen sehr schnell funktionieren, aber die Leistung ist nicht die wichtigste √Ñnderung.  F√ºr die meisten Entwickler ist es viel wichtiger, wie sich Vue 3 auf die Art und Weise auswirkt, wie Sie Code schreiben. <a name="habracut"></a><br><br>  Wie Sie vielleicht erraten haben, wird Vue 3 viele coole Funktionen haben.  Gl√ºcklicherweise hat das Vue-Team mehr Verbesserungen und Erg√§nzungen vorgenommen als √Ñnderungen.  Aus diesem Grund sollten sich die meisten Entwickler, die Vue 2 kennen, schnell mit der neuen Syntax vertraut machen. <br><br>  Beginnen wir mit einer API, von der viele von Ihnen vielleicht schon geh√∂rt haben. <br><br><h2>  Kompositions-API </h2><br>  Die Composition-API ist das am h√§ufigsten diskutierte und am h√§ufigsten erw√§hnte Feature der n√§chsten Hauptversion von Vue.  Die Composition-API-Syntax bietet einen v√∂llig neuen Ansatz zum Organisieren und Wiederverwenden von Code. <br><br>  Wir erstellen jetzt Komponenten mit einer Syntax namens Options API.  Um Logik hinzuzuf√ºgen, erstellen wir im Komponentenobjekt Eigenschaften (Optionen), z. B. Daten, Methoden, berechnete usw.  Der Hauptnachteil dieses Ansatzes besteht darin, dass es sich nicht um JavaScript-Code als solchen handelt.  Sie m√ºssen genau wissen, welche Optionen in der Vorlage verf√ºgbar sind und wie diese aussehen werden.  Der Vue-Compiler konvertiert Eigenschaften f√ºr Sie in funktionierenden JavaScript-Code.  Aufgrund dieser Funktion k√∂nnen wir die automatische Vervollst√§ndigung oder die Typpr√ºfung nicht vollst√§ndig verwenden. <br><br>  Die Composition-API l√∂st dieses Problem und erm√∂glicht die Verwendung der in den Optionen verf√ºgbaren Mechanismen mit normalen JavaScript-Funktionen. <br>  Das Vue-Team beschreibt die Kompositions-API als "optionale, funktionsbasierte API, die eine flexible Verwendung der Komposition in der Komponentenlogik erm√∂glicht".  Code, der mit der neuen API geschrieben wurde, ist einfacher zu lesen und somit verst√§ndlicher. <br><br>  Um zu verstehen, wie die neue Syntax funktioniert, betrachten Sie ein Beispiel f√ºr eine einfache Komponente. <br><br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> @</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"increment"</span></span></span><span class="hljs-tag">&gt;</span></span> Count is: {{ count }}, double is {{ double }}, click to increment. <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">import</span></span></span><span class="javascript"> { ref, computed, onMounted } </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">from</span></span></span><span class="javascript"> </span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'vue'</span></span></span><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">export</span></span></span><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">default</span></span></span><span class="javascript"> { setup() { </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">const</span></span></span><span class="javascript"> count = ref(</span><span class="hljs-number"><span class="javascript"><span class="hljs-number">0</span></span></span><span class="javascript">) </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">const</span></span></span><span class="javascript"> double = computed(</span><span class="hljs-function"><span class="hljs-params"><span class="javascript"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span><span class="javascript"><span class="hljs-function"> =&gt;</span></span></span><span class="javascript"> count.value * </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">2</span></span></span><span class="javascript">) </span><span class="hljs-function"><span class="hljs-keyword"><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="javascript"><span class="hljs-function"> </span></span><span class="hljs-title"><span class="javascript"><span class="hljs-function"><span class="hljs-title">increment</span></span></span></span><span class="javascript"><span class="hljs-function">(</span></span><span class="hljs-params"></span><span class="javascript"><span class="hljs-function"><span class="hljs-params"></span>) </span></span></span><span class="javascript">{ count.value++ } onMounted(</span><span class="hljs-function"><span class="hljs-params"><span class="javascript"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span><span class="javascript"><span class="hljs-function"> =&gt;</span></span></span><span class="javascript"> </span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">console</span></span></span><span class="javascript">.log(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'component mounted!'</span></span></span><span class="javascript">)) </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">return</span></span></span><span class="javascript"> { count, double, increment } } } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Wir werden den Code in Teile zerlegen und analysieren, was hier passiert. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ref, computed, onMounted } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vue'</span></span></code> </pre> <br>  Wie oben erw√§hnt, stellt die Composition-API die Komponentenoptionen als Funktionen dar. Daher m√ºssen zun√§chst die erforderlichen Funktionen importiert werden.  In diesem Beispiel m√ºssen wir eine reaktive Eigenschaft mit ref erstellen, die mit computed berechnet wurde, und mit der Funktion onMounted auf den eingeh√§ngten Lifecycle-Hook zugreifen. <br><br>  M√∂glicherweise haben Sie eine Frage: Was ist diese mysteri√∂se Einrichtungsmethode? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { setup() {} }</code> </pre> <br>  Kurz gesagt, Setup ist nur eine Funktion, die Eigenschaften und Funktionen an eine Vorlage √ºbergibt.  Wir beschreiben alle reaktiven und berechneten Eigenschaften, Lifecycle-Hooks und alle Beobachter in der Setup-Funktion und geben sie zur Verwendung in der Vorlage zur√ºck. <br><br>  Damit wir nicht vom Setup zur√ºckkehren, gibt es keinen Zugriff in der Vorlage. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = ref(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Die z√§hlreaktive Eigenschaft wird mit der Funktion ref initialisiert.  Es nimmt ein Primitiv oder Objekt und gibt eine reaktive Verkn√ºpfung zur√ºck.  Der √ºbergebene Wert wird in der value-Eigenschaft des erstellten Links gespeichert.  Wenn wir beispielsweise auf den Wert von count zugreifen m√∂chten, m√ºssen wir explizit auf count.value zugreifen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> double = computed(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> count.value * <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ count.value++ }</code> </pre><br>  Wir deklarieren also eine berechnete Double-Eigenschaft und eine Inkrement-Funktion. <br><br><pre> <code class="javascript hljs">onMounted(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'component mounted!'</span></span>))</code> </pre> <br>  Mit dem onMounted-Hook drucken wir nach dem Mounten der Komponente eine Nachricht an die Konsole, um diese M√∂glichkeit zu demonstrieren. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { count, double, increment }</code> </pre> <br>  Damit die count- und double-Eigenschaften und die increment-Methode in der Vorlage verf√ºgbar sind, geben wir sie von der setup-Methode zur√ºck. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> @</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"increment"</span></span></span><span class="hljs-tag">&gt;</span></span> Count is: {{ count }}, double is {{ double }}. Click to increment. <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Und voila!  Wir haben vom Setup aus Zugriff auf die Eigenschaften und Methoden, als ob sie √ºber die alte Options-API deklariert worden w√§ren. <br><br>  Dies ist ein einfaches Beispiel. √Ñhnliches k√∂nnte leicht mit der Options-API geschrieben werden. <br>  Der Vorteil der neuen Composition-API liegt jedoch nicht in der M√∂glichkeit, Code in einem anderen Stil zu schreiben, sondern in den M√∂glichkeiten, die sich f√ºr die Wiederverwendung von Logik er√∂ffnen. <br><br><h2>  Wiederverwenden von Code mit der Composition-API </h2><br>  Schauen wir uns die Vorteile der neuen Composition-API genauer an, zum Beispiel f√ºr die Wiederverwendung von Code.  Wenn wir nun einen Teil des Codes in mehreren Komponenten verwenden m√∂chten, haben wir zwei M√∂glichkeiten: Mixins und Scoped Slots.  Beide Optionen haben ihre Nachteile. <br><br>  Wir m√∂chten die Funktionalit√§t des Z√§hlers extrahieren und in anderen Komponenten wiederverwenden.  Hier ist ein Beispiel, wie dies unter Verwendung der vorhandenen und der neuen API durchgef√ºhrt werden kann. <br><br>  Betrachten Sie zun√§chst die Implementierung mit Mixins. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CounterMixin <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./mixins/counter'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { <span class="hljs-attr"><span class="hljs-attr">mixins</span></span>: [CounterMixin] }</code> </pre> <br>  Das gr√∂√üte Problem bei diesem Ansatz ist, dass wir nichts dar√ºber wissen, was zu unserer Komponente hinzugef√ºgt wird.  Dies erschwert das Verst√§ndnis und kann zu Konflikten mit vorhandenen Eigenschaften und Methoden f√ºhren. <br><br>  Betrachten Sie nun Slots mit einem begrenzten Umfang. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Counter</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-slot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{ count, increment }"</span></span></span><span class="hljs-tag">&gt;</span></span> {{ count }} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> @</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"increment"</span></span></span><span class="hljs-tag">&gt;</span></span>Increment<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Counter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Bei der Verwendung von Slots wissen wir genau, auf welche Eigenschaften wir √ºber die v-slot-Direktive zugreifen k√∂nnen, was recht einfach zu verstehen ist.  Der Nachteil dieses Ansatzes ist, dass wir nur auf die Daten der Counter-Komponente zugreifen k√∂nnen. <br><br>  Betrachten Sie nun eine Implementierung mit der Composition-API. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useCounter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = ref(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ count.value++ } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { count, incrememt } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { setup () { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { count, increment } = useCounter() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { count, increment } } }</code> </pre> <br>  Es sieht viel eleganter aus, oder?  Wir sind weder an eine Vorlage noch an einen Bereich gebunden und wissen genau, welche Z√§hlereigenschaften verf√ºgbar sind.  Und da useCounter nur eine Funktion ist, die Daten zur√ºckgibt, erhalten wir als angenehmen Bonus die Code-Vervollst√§ndigung im Editor.  Hier gibt es keine Magie, daher kann uns der Editor bei der Typpr√ºfung helfen und Hinweise geben. <br><br>  Die Verwendung von Bibliotheken von Drittanbietern sieht ebenfalls besser aus.  Wenn wir beispielsweise Vuex verwenden m√∂chten, k√∂nnen wir die useStore-Funktion explizit importieren und den Vue-Prototyp damit nicht verstopfen. $ Store-Eigenschaft.  Dieser Ansatz erm√∂glicht es Ihnen, zus√§tzliche Manipulationen in Plugins zu beseitigen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { commit, dispatch } = useStore()</code> </pre> <br>  Wenn Sie mehr √ºber die Composition-API und ihre Anwendungen erfahren m√∂chten, empfehle ich, ein Dokument zu lesen, in dem das Vue-Team die Gr√ºnde f√ºr die Erstellung einer neuen API erl√§utert und F√§lle aufzeigt, in denen dies hilfreich sein wird.  Es gibt auch ein wunderbares Repository mit Beispielen f√ºr die Verwendung der Kompositions-API von Thorsten L√ºnborg, einem Mitglied des Vue-Kernteams. <br><br><h2>  Konfigurations- und Montage√§nderungen </h2><br>  In der neuen Version gibt es weitere wichtige √Ñnderungen in der Art und Weise, wie wir unsere Anwendung erstellen und konfigurieren.  Schauen wir uns ein Beispiel an. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Vue <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vue'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> App <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./App.vue'</span></span> Vue.config.ignoredElements = [<span class="hljs-regexp"><span class="hljs-regexp">/^app-/</span></span>] Vue.use(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>) Vue.mixin(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>) Vue.component(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>) Vue.directive(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vue({ <span class="hljs-attr"><span class="hljs-attr">render</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">h</span></span></span><span class="hljs-function"> =&gt;</span></span> h(App) }).$mount(<span class="hljs-string"><span class="hljs-string">'#app'</span></span>)</code> </pre> <br>  Wir verwenden jetzt das globale Vue-Objekt, um neue Vue-Instanzen zu konfigurieren und zu erstellen.  Jede √Ñnderung, die wir am Vue-Objekt vornehmen, wirkt sich auf die endg√ºltigen Instanzen und Komponenten aus. <br><br>  Mal sehen, wie das in Vue 3 funktioniert. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { createApp } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vue'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> App <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./App.vue'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = createApp(App) app.config.ignoredElements = [<span class="hljs-regexp"><span class="hljs-regexp">/^app-/</span></span>] app.use(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>) app.mixin(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>) app.component(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>) app.directive(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>) app.mount(<span class="hljs-string"><span class="hljs-string">'#app'</span></span>)</code> </pre> <br>  Wie Sie bereits bemerkt haben, bezieht sich die Konfiguration auf eine bestimmte Vue-Instanz, die mit createApp erstellt wurde. <br><br>  Dies macht unseren Code lesbarer und verringert die M√∂glichkeit unerwarteter Probleme mit Plugins von Drittanbietern.  Jetzt kann sich jede Bibliothek eines Drittanbieters, die das globale Vue-Objekt √§ndert, auf Ihre Anwendung an einem unerwarteten Ort auswirken (insbesondere, wenn es sich um ein globales Mixin handelt), was in Vue 3 nicht m√∂glich ist. <br><br>  Diese √Ñnderungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> im RFC <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">besprochen</a> , und m√∂glicherweise wird die Implementierung in Zukunft anders sein. <br><br><h2>  Fragmente </h2><br>  Ein weiteres cooles Feature, auf das wir in Vue 3 z√§hlen k√∂nnen. <br>  Was sind Fragmente? <br>  Derzeit kann eine Komponente nur ein Stammelement haben, was bedeutet, dass der folgende Code nicht funktioniert. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>Hello<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>World<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Der Grund daf√ºr ist, dass die Vue-Instanz, die sich hinter jeder Komponente versteckt, nur einem DOM-Element zugeordnet werden kann.  Jetzt gibt es eine M√∂glichkeit, eine Komponente mit mehreren Stammelementen zu erstellen: Dazu m√ºssen Sie eine Komponente in einem funktionalen Stil schreiben, der keine eigene Vue-Instanz ben√∂tigt. <br><br>  Es stellt sich heraus, dass das gleiche Problem in der React-Community besteht, das mit dem virtuellen Fragment-Element behoben wurde. <br><br>  Es sieht so aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Columns</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">React.Fragment</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">td</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Hello</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">td</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">td</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">World</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">td</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">React.Fragment</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); } }</span></span></code> </pre> <br>  Obwohl Fragment wie ein regul√§res DOM-Element aussieht, ist es virtuell und wird nicht in der DOM-Struktur erstellt.  Mit diesem Ansatz k√∂nnen wir die Funktionalit√§t eines einzelnen Stammelements nutzen, ohne ein zus√§tzliches Element im DOM zu erstellen. <br><br>  Jetzt k√∂nnen Sie Fragmente in Vue 2 verwenden, aber mit der Vue-Fragmentbibliothek, und in Vue 3 funktionieren sie sofort! <br><br><h2>  Spannung </h2><br>  Eine weitere gro√üartige Idee aus dem React-√ñkosystem, die in Vue 3 implementiert wird, ist Suspense. <br><br>  Mit Suspense wird das Rendern von Komponenten angehalten und ein Stub angezeigt, bis bestimmte Bedingungen erf√ºllt sind.  Bei Vue London ber√ºhrte Ewan Yu beil√§ufig Suspense und enth√ºllte die API, die wir in Zukunft erwarten k√∂nnen.  Die Suspense-Komponente verf√ºgt √ºber zwei Steckpl√§tze: f√ºr Inhalte und f√ºr Stubs. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Suspense</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag"> &gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Suspended-component</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag"> #</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fallback</span></span></span><span class="hljs-tag">&gt;</span></span> Loading... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Suspense</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Der Stub wird angezeigt, bis die Komponente &lt;Suspended-component /&gt; bereit ist.  Die Suspense-Komponente erwartet m√∂glicherweise auch, dass sie die asynchrone Komponente l√§dt oder einige asynchrone Aktionen in der Setup-Funktion ausf√ºhrt. <br><br><h2>  Mehrere V-Modelle </h2><br>  v-model ist eine Direktive, mit der Sie die bidirektionale Bindung verwenden k√∂nnen.  Wir k√∂nnen die reaktive Eigenschaft √ºbergeben und sie innerhalb des Bauteils √§ndern. <br><br>  Wir sind bekannt f√ºr die Arbeit mit Formularelementen. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-model</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"property"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br>  Aber wussten Sie, dass V-Modell mit jeder Komponente verwendet werden kann?  Unter der Haube leitet das V-Modell lediglich den Werteparameter weiter und wartet auf das Eingabeereignis. <br><br>  Sie k√∂nnen das vorherige Beispiel mit dieser Syntax wie folgt umschreiben: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-bind:value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"property"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-on:input</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"property = $event.target.value"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br>  Sie k√∂nnen sogar die Standardeigenschaftsnamen und -ereignisse mithilfe der Modelloption √§ndern: <br><br><pre> <code class="javascript hljs">model: { <span class="hljs-attr"><span class="hljs-attr">prop</span></span>: <span class="hljs-string"><span class="hljs-string">'checked'</span></span>, <span class="hljs-attr"><span class="hljs-attr">event</span></span>: <span class="hljs-string"><span class="hljs-string">'change'</span></span> }</code> </pre> <br>  Wie Sie sehen, kann die v-model-Direktive ein sehr n√ºtzlicher ‚Äûsyntaktischer Zucker‚Äú sein, wenn wir in unseren Komponenten die bidirektionale Bindung verwenden m√∂chten.  Leider kann es nur ein V-Modell pro Komponente geben. <br><br>  Zum Gl√ºck wird dieses Problem in Vue 3 behoben.  Wir k√∂nnen den Namen an v-model √ºbergeben und so viel v-model wie n√∂tig verwenden. <br><br>  Anwendungsbeispiel: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">InviteeForm</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-model:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"inviteeName"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-model:email</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"inviteeEmail"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br>  Diese √Ñnderungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> im RFC <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">besprochen</a> , und m√∂glicherweise wird die Implementierung in Zukunft anders sein. <br><br><h2>  Portale </h2><br>  Portale sind Komponenten, die zum Rendern von Inhalten au√üerhalb der Hierarchie der aktuellen Komponente erstellt wurden.  Dies ist auch eine der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in React implementierten</a> Funktionen.  In der React-Dokumentation werden Portale wie folgt beschrieben: "Mithilfe von Portalen k√∂nnen Sie untergeordnete Elemente in einem DOM-Knoten rendern, der sich au√üerhalb der DOM-Hierarchie der √ºbergeordneten Komponente befindet." <br><br>  Portale eignen sich hervorragend zum Implementieren von Komponenten wie modalen Fenstern, Popups und allen anderen, die oben auf der Seite angezeigt werden m√ºssen. <br><br>  Wenn Sie Portale verwenden, k√∂nnen Sie sicher sein, dass sich die Stile der √ºbergeordneten Komponente nicht auf die untergeordnete Komponente auswirken.  Es erspart Ihnen auch schmutzige Z-Index-Hacks. <br><br>  F√ºr jedes Portal m√ºssen wir das Ziel angeben, in dem der Portalinhalt angezeigt werden soll. <br><br>  Das Folgende ist eine Implementierungsoption f√ºr die Portal-Vue-Bibliothek, mit der Portale zu Vue 2 hinzugef√ºgt werden. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">portal</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">to</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"destination"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>This slot content will be rendered wherever the portal-target with name 'destination' is located.<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">portal</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">portal-target</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"destination"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- This component can be located anywhere in your App. The slot content of the above portal component wilbe rendered here. --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">portal-target</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  In Vue 3 ist diese Funktion sofort einsatzbereit. <br><br><h2>  Neue API f√ºr benutzerdefinierte Richtlinien </h2><br>  Die benutzerdefinierte Direktiven-API wird in Vue 3 etwas ge√§ndert, um dem Lebenszyklus der Komponente besser zu entsprechen.  Das Erstellen von Anweisungen wird intuitiver und daher f√ºr Anf√§nger einfacher zu verstehen und zu lernen. <br><br>  Nun sieht die Deklaration der user-Direktive so aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyDirective = { bind(el, binding, vnode, prevVnode) {}, inserted() {}, update() {}, componentUpdated() {}, unbind() {} }</code> </pre> <br>  Und in Vue 3 wird es so aussehen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyDirective = { beforeMount(el, binding, vnode, prevVnode) {}, mounted() {}, beforeUpdate() {}, updated() {}, beforeUnmount() {}, <span class="hljs-comment"><span class="hljs-comment">// new unmounted() {} }</span></span></code> </pre> <br>  Obwohl dies wichtige √Ñnderungen sind, k√∂nnen sie mit einem kompatiblen Vue-Build verwendet werden. <br><br>  Diese API wird ebenfalls <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diskutiert</a> und kann sich in Zukunft √§ndern. <br><br><h2>  Zusammenfassung </h2><br>  Neben der bedeutenden Innovation - der Composition API - finden wir einige kleinere Verbesserungen.  Offensichtlich ist Vue bestrebt, die Entwicklererfahrung zu verbessern und intuitive APIs zu vereinfachen.  Es ist auch sch√∂n zu sehen, dass das Vue-Team beschlossen hat, dem Kern des Frameworks viele Ideen hinzuzuf√ºgen, die bereits in Bibliotheken von Drittanbietern implementiert sind. <br><br>  Die obige Liste enth√§lt nur die wichtigsten Verbesserungen und √Ñnderungen an der API.  Wenn Sie mehr √ºber andere erfahren m√∂chten, lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das RFC-Repository</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de475968/">https://habr.com/ru/post/de475968/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de475948/index.html">JH Rainwater "Wie man Katzen weidet" (Teil 2): ‚Äã‚ÄãAlles, was technisch zu meistern bleibt</a></li>
<li><a href="../de475950/index.html">Warum sollte sich ein Roboter darauf beschr√§nken, Golfb√§lle zu sammeln? Es gibt auch Tennis</a></li>
<li><a href="../de475956/index.html">Wie wir die Technologie der optischen Texterkennung geschaffen haben. OCR auf Yandex</a></li>
<li><a href="../de475958/index.html">Die Geschichte, wie sich das M√§dchen in der IT versammelt hat</a></li>
<li><a href="../de475960/index.html">AHURATUS Smart Home Sprachassistent</a></li>
<li><a href="../de475974/index.html">Wie wir im Zug einen Hackathon machten und was daraus wurde</a></li>
<li><a href="../de475978/index.html">Wof√ºr ist das Hauptquartier des Zuges?</a></li>
<li><a href="../de475980/index.html">Geringe Konnektivit√§t, Architektur und Teamorganisation</a></li>
<li><a href="../de475982/index.html">Wie lerne ich eine Fremdsprache?</a></li>
<li><a href="../de475986/index.html">PocketBook 740 Pro Reader √úbersicht: 7,8 Zoll, Audio- und IPX8-Schutz</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>