<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äç‚öñÔ∏è ‚õàÔ∏è üñ®Ô∏è CSS Grid Naming ü•• ‚èπÔ∏è üéç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie zum ersten Mal lernen, wie Sie das Rasterlayout verwenden, k√∂nnen Sie zun√§chst Elemente nach Zeilennummern auf dem Raster platzieren. In dies...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>CSS Grid Naming</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/478850/">  Wenn Sie zum ersten Mal lernen, wie Sie das Rasterlayout verwenden, k√∂nnen Sie zun√§chst Elemente nach Zeilennummern auf dem Raster platzieren.  In diesem Fall muss √ºberwacht werden, wo bestimmte Zeilen im Raster angezeigt werden. Beachten Sie, dass die Reihenfolge ihrer Nummern umgekehrt ist, wenn die Site f√ºr Sprachen angezeigt wird, die von rechts nach links geschrieben sind. <br><br>  Basierend auf diesem Liniensystem arbeiten Techniken, die es erm√∂glichen, Linien und sogar Gitterbereiche zu benennen.  Mithilfe dieser Techniken k√∂nnen Sie Objekte nach Namen und nicht nach Nummern sortieren.  In diesem Artikel werde ich die <b>verschiedenen Arten der Benennung von Linien und Bereichen in CSS-Grid-Layouts</b> sowie einige interessante Funktionen, die sie erstellen, genauer betrachten. <br><a name="habracut"></a><br><hr><br><blockquote> <b>Vom √úbersetzer:</b> <br>  Ein Artikel vor zwei Jahren (2017), der jedoch die wichtige Funktionsweise des CSS-Gitters anspricht und daher heute n√ºtzlich und relevant erscheint. <br></blockquote><br><h2>  Linienbenennung </h2><br>  Beginnen wir mit der Benennung der Gitterlinien.  Im folgenden Beispiel gibt es ein Raster mit sechs expliziten Spaltenspuren und einer expliziten Linienspur.  Elemente werden mit Zeilennummern auf dem Raster platziert. <br><br><pre><code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.grid</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: grid; <span class="hljs-attribute"><span class="hljs-attribute">grid-gap</span></span>: <span class="hljs-number"><span class="hljs-number">20px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-template-rows</span></span>: <span class="hljs-number"><span class="hljs-number">20vh</span></span> ; <span class="hljs-attribute"><span class="hljs-attribute">grid-template-columns</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr; } <span class="hljs-selector-class"><span class="hljs-selector-class">.header</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-row</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> / -<span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.sidebar</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-row</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.content</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-row</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> / -<span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Bei Bedarf k√∂nnen in der Titelliste Zeilennamen in eckigen Klammern angegeben werden.  Es ist wichtig, sich daran zu erinnern, dass Sie die Linie benennen, nicht die Spur, die ihr folgt.  Nachdem Sie die Linien benannt haben, k√∂nnen Sie beim Positionieren von Elementen im Raster deren Namen anstelle von Zahlen verwenden. <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.grid</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: grid; <span class="hljs-attribute"><span class="hljs-attribute">grid-gap</span></span>: <span class="hljs-number"><span class="hljs-number">20px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-template-rows</span></span>: [header-start] <span class="hljs-number"><span class="hljs-number">20vh</span></span> [header-end] ; <span class="hljs-attribute"><span class="hljs-attribute">grid-template-columns</span></span>: [sidebar-start] <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr [sidebar-end] <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr; } <span class="hljs-selector-class"><span class="hljs-selector-class">.header</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-row</span></span>: header-start; <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> / -<span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.sidebar</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-row</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: sidebar-start / sidebar-end; }</code> </pre><br>  Der Name kann etwas anderes als das <code>span</code> Schl√ºsselwort sein.  Aus Gr√ºnden, die Sie sp√§ter in diesem Artikel erfahren werden, ist die Benennung mit dem Suffix <code>-start</code> f√ºr f√ºhrende Zeilen (es spielt keine Rolle, ob es sich um eine Zeilen- oder Spaltenzeile handelt) und <code>-end</code> f√ºr <code>-end</code> eine gute Vorgehensweise.  Das Ergebnis sollte <code>main-start</code> und <code>main-end</code> oder <code>sidebar-start</code> und <code>sidebar-end</code> . <br><br>  Ziemlich oft stimmen die Endlinie eines Teils des Rasters und die Startlinie des anderen Teils √ºberein, aber dies ist kein Problem, da Linien mehrere Namen haben k√∂nnen.  Sie k√∂nnen Zeilen mit mehreren Namen angeben, indem Sie sie durch ein Leerzeichen in eckigen Klammern einf√ºgen. <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.grid</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: grid; <span class="hljs-attribute"><span class="hljs-attribute">grid-gap</span></span>: <span class="hljs-number"><span class="hljs-number">20px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-template-rows</span></span>: [header-start] <span class="hljs-number"><span class="hljs-number">20vh</span></span> [header-end] ; <span class="hljs-attribute"><span class="hljs-attribute">grid-template-columns</span></span>: [full-start sidebar-start] <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr [sidebar-end main-start] <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr [main-end full-end]; } <span class="hljs-selector-class"><span class="hljs-selector-class">.header</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-row</span></span>: header-start; <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: full-start / full-end; } <span class="hljs-selector-class"><span class="hljs-selector-class">.sidebar</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-row</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: sidebar-start / sidebar-end; } <span class="hljs-selector-class"><span class="hljs-selector-class">.content</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-row</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: main-start / main-end; }</code> </pre><br>  Dieses Beispiel zeigt, dass Sie nicht jede einzelne Gitterlinie benennen m√ºssen und dass Zeilennummern, die zus√§tzlich zu Namen verwendet werden k√∂nnen, immer verf√ºgbar sind. <br><br>  Codepen 1. <a href="https://codepen.io/rachelandrew/pen/KXqMdm/" rel="nofollow">Line Naming</a> <br><br><h2>  Linien mit dem gleichen Namen. </h2><br>  Wir haben gesehen, wie Zeilen mehrere Namen haben k√∂nnen, aber es gibt auch Situationen, in denen mehrere Zeilen denselben Namen haben.  Dies geschieht, wenn Sie die Funktion <code>repeat()</code> verwenden und benannte Zeilen in die Titelliste aufnehmen.  Im folgenden Beispiel werden sechs benannte Zeilen erstellt, die abwechselnd die Namen <code>col-a-start</code> und <code>col-b-start</code> . <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.grid</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: grid; <span class="hljs-attribute"><span class="hljs-attribute">grid-gap</span></span>: <span class="hljs-number"><span class="hljs-number">20px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-template-columns</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">repeat</span></span>(3, [col-a-start] 1fr [col-b-start] 2fr); }</code> </pre><br>  Wenn Sie beim Positionieren eines Elements <code>col-a-start</code> angeben, wird es in der ersten Zeile platziert, die mit dem Namen <code>col-a-start</code> (im betrachteten Beispiel die erste Gitterlinie).  Wenn Sie beim Positionieren eines Elements <code>col-b-start</code> angeben, wird es nach demselben Prinzip auf der zweiten Rasterlinie platziert. <br><br>  Wenn Sie in nachfolgenden Zeilen positionieren m√ºssen, f√ºgen Sie nach dem Namen eine Zahl ein, um anzugeben, in welcher Zeile der Zeile mit demselben Namen das Objekt platziert werden soll <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.box3</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-row</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: col-a-start <span class="hljs-number"><span class="hljs-number">2</span></span> / col-b-start <span class="hljs-number"><span class="hljs-number">3</span></span>; }</code> </pre><br>  Codepen 2. <a href="https://codepen.io/rachelandrew/pen/jGLVRb/" rel="nofollow">Linien mit dem gleichen Namen.</a> <br><br>  <a href="https://www.w3.org/TR/css-grid-1/" rel="nofollow">In der Spezifikation</a> wird dieses Verhalten als "Erstellen eines benannten Satzes von Rasterlinien" beschrieben. <br><br><h2>  Speichern von Liniennamen beim Wiederherstellen eines adaptiven Rasters </h2><br>  Verwenden Sie die Zeilennummern oder deren Namen, Sie entscheiden.  In der Regel k√∂nnen Linien in Situationen n√ºtzlich sein, in denen Sie die Gitterstruktur im Rahmen einer Medienabfrage √§ndern m√∂chten.  Anstatt zu verfolgen, auf welcher Linie Sie Elemente an verschiedenen Kontrollpunkten platzieren, k√∂nnen Sie auch mit nacheinander benannten Linien arbeiten. <br><br>  Im folgenden einfachen Beispiel definiere ich Rasterspalten f√ºr einen schmalen Bildschirm und definiere sie dann mit einer Breite von 550px neu. <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.grid</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: grid; <span class="hljs-attribute"><span class="hljs-attribute">grid-gap</span></span>: <span class="hljs-number"><span class="hljs-number">20px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-template-rows</span></span>: [header-start] <span class="hljs-number"><span class="hljs-number">20vh</span></span> [header-end]; <span class="hljs-attribute"><span class="hljs-attribute">grid-template-columns</span></span>: [full-start ] <span class="hljs-number"><span class="hljs-number">10px</span></span> [sidebar-start main-start] <span class="hljs-number"><span class="hljs-number">1</span></span>fr [main-end sidebar-end] <span class="hljs-number"><span class="hljs-number">10px</span></span> [full-end]; } @<span class="hljs-keyword"><span class="hljs-keyword">media</span></span> (min-width: <span class="hljs-number"><span class="hljs-number">550px</span></span>) { <span class="hljs-selector-class"><span class="hljs-selector-class">.grid</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-template-columns</span></span>: [full-start sidebar-start] <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr [sidebar-end main-start] <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr [main-end full-end]; } }</code> </pre><br>  Codepen 3. <a href="https://codepen.io/rachelandrew/pen/jGLyGB/" rel="nofollow">Benennen von Dingen:</a> Definieren Sie <a href="https://codepen.io/rachelandrew/pen/jGLyGB/" rel="nofollow">die Position der benannten Zeilen neu</a> <br><br><h2>  Benannte Regionen </h2><br>  Vorher haben wir nur benannte Zeilen betrachtet, aber es gibt einen anderen Weg.  Wir k√∂nnen Gitterbereiche benennen. <br><br>  Ein Gitterbereich ist ein rechteckiger Bereich, der aus einer oder mehreren Gitterzellen besteht.  Der Bereich wird durch vier Gitterlinien definiert, die die Start- und Endzeilen f√ºr Spalten und Zeilen angeben. <br><br><img src="https://habrastorage.org/webt/l2/c6/xt/l2c6xtlnkmuhzsdh1nrtx3docgg.png"><br>  Wir benennen die Gitterbereiche mit der Eigenschaft <code>grid-template-areas</code> .  Diese Eigenschaft beschreibt das Layout in Form einer ASCII-Tabelle und ist ein Satz von Linien, von denen jede eine separate Linienspur des Rasters beschreibt. <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.grid</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: grid; <span class="hljs-attribute"><span class="hljs-attribute">grid-template-columns</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">repeat</span></span>(3, 1fr 2fr) ; <span class="hljs-attribute"><span class="hljs-attribute">grid-template-areas</span></span>: <span class="hljs-string"><span class="hljs-string">"head head head head head head"</span></span> <span class="hljs-string"><span class="hljs-string">"side side main main main main"</span></span> <span class="hljs-string"><span class="hljs-string">"foot foot foot foot foot foot"</span></span>; }</code> </pre><br>  Die Namen, die wir in den Zeilen der Eigenschaft <code>grid-template-areas</code> werden den direkten untergeordneten Elementen des Rasters mithilfe der Eigenschaft <code>grid-area</code> zugewiesen.  Der Wert dieser Eigenschaft ist, wenn sie zur Benennung verwendet wird, die sogenannte <i>Benutzerkennung</i> , sodass sie nicht in Anf√ºhrungszeichen eingeschlossen werden muss <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.header</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-area</span></span>: head; } <span class="hljs-selector-class"><span class="hljs-selector-class">.sidebar</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-area</span></span>: side; } <span class="hljs-selector-class"><span class="hljs-selector-class">.content</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-area</span></span>: main; } <span class="hljs-selector-class"><span class="hljs-selector-class">.footer</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-area</span></span>: foot; }</code> </pre><br>  Damit der Bereich bei der Beschreibung der Gitterstruktur mit der Eigenschaft <code>grid-template-areas</code> mehr als eine Zelle abdeckt, m√ºssen Sie den Bezeichner mehrmals entlang einer Zeile oder Spalte neu aufzeichnen.  Der erstellte Bereich muss ein Rechteck sein. L- und T-f√∂rmige Bereiche sind nicht zul√§ssig.  Sie k√∂nnen auch nur einen rechteckigen Bereich f√ºr jeden Namen erstellen - nicht verbundene Bereiche sind nicht zul√§ssig.  Die Spezifikation stellt fest, dass: <br><blockquote>  <i>‚ÄûIn zuk√ºnftigen Versionen dieses Moduls sind m√∂glicherweise nicht rechteckige oder nicht verbundene Bereiche zul√§ssig.‚Äú</i> <i><br></i>  <i>- <a href="https://www.w3.org/TR/css-grid-1/" rel="nofollow">Eigenschaftenraster-Vorlagenbereiche</a></i> <br></blockquote><br>  Bei der Beschreibung eines Rasters muss auf die vollst√§ndige Darstellung geachtet werden, da sonst die gesamte Anzeige als ung√ºltig verworfen wird.  Dies bedeutet, dass jede Gitterzelle gef√ºllt sein muss. <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">grid-template-areas</span></span>: "<span class="hljs-selector-tag"><span class="hljs-selector-tag">head</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">head</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">head</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">head</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">head</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">head</span></span>" "<span class="hljs-selector-tag"><span class="hljs-selector-tag">side</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">side</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span>" "<span class="hljs-selector-tag"><span class="hljs-selector-tag">foot</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">foot</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">foot</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">foot</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">foot</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">foot</span></span>"; }</code> </pre><br>  Da Sie m√∂glicherweise einige Zellen im Markup leer lassen m√∂chten, definiert die Spezifikation ein Punktsymbol <b><code>.</code></b>  oder eine Folge von Punkten ohne Leerzeichen zwischen ihnen <b><code>....</code></b> als Markierung einer leeren Zelle <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">grid-template-areas</span></span>: "<span class="hljs-selector-tag"><span class="hljs-selector-tag">head</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">head</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">head</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">head</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">head</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">head</span></span>" "<span class="hljs-selector-tag"><span class="hljs-selector-tag">side</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">side</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span>" "....... ....... <span class="hljs-selector-tag"><span class="hljs-selector-tag">foot</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">foot</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">foot</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">foot</span></span>"; }</code> </pre><br>  Codepen 4. <a href="https://codepen.io/rachelandrew/pen/gGxKXd/" rel="nofollow">Benannte Regionen</a> <br><br>  Wenn Sie Firefox noch nicht heruntergeladen haben, um die neuesten Funktionen von Firefox DevTools Grid Inspector zu nutzen, empfehle ich dies, wenn Sie mit benannten Bereichen arbeiten <br><br><img src="https://habrastorage.org/webt/1g/ak/4f/1gak4fvdwrsqwj7nchm3t_y8eug.png"><br>  <i>Demonstration benannter Bereiche im "Grid Inspector" des Firefox-Browsers ( <a href="" rel="nofollow">Original √∂ffnen</a> )</i> <br><br><h2>  Benannte Linien bilden Bereiche </h2><br>  Nun kommen wir zu dem interessanten Teil dieses ganzen Namensfestes.  Sie erinnern sich vielleicht, dass ich bei der Betrachtung der benannten Zeilen vorgeschlagen habe, eine Zeilenende-Vereinbarung zu verwenden, die den Beginn des Bereichs mit <code>-start</code> und das Ende des Bereichs mit <code>-start</code> .  Der Grund daf√ºr ist, dass Sie, wenn Sie die Linien auf diese Weise benennen, einen Gitterbereich mit diesem Namen erhalten und ein Element darin einf√ºgen k√∂nnen, indem Sie diesen Namen √ºber die <code>grid-area</code> festlegen. <br><br>  Im folgenden Beispiel bezeichne ich f√ºr Zeilen und Spalten die Zeilen <code>panel-start</code> und <code>panel-end</code> .  Dies gibt mir einen benannten Bereich namens Panel.  Wenn ich es als Wert der Eigenschaft <code>grid-area</code> f√ºr ein Element auf der Seite festlege, wird das Element in den durch diese Linien definierten Bereich eingef√ºgt <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.grid</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: grid; <span class="hljs-attribute"><span class="hljs-attribute">grid-gap</span></span>: <span class="hljs-number"><span class="hljs-number">20px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-template-columns</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>fr [panel-start] <span class="hljs-number"><span class="hljs-number">2</span></span>fr <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr <span class="hljs-number"><span class="hljs-number">1</span></span>fr [panel-end] <span class="hljs-number"><span class="hljs-number">2</span></span>fr; <span class="hljs-attribute"><span class="hljs-attribute">grid-template-rows</span></span>: <span class="hljs-number"><span class="hljs-number">10vh</span></span> [panel-start] <span class="hljs-built_in"><span class="hljs-built_in">minmax</span></span>(200px, auto) <span class="hljs-number"><span class="hljs-number">10vh</span></span> [panel-end]; <span class="hljs-attribute"><span class="hljs-attribute">grid-template-areas</span></span>: <span class="hljs-string"><span class="hljs-string">"head head head head head head"</span></span> <span class="hljs-string"><span class="hljs-string">"side side main main main main"</span></span> <span class="hljs-string"><span class="hljs-string">".... .... foot foot foot foot"</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.panel</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-area</span></span>: panel; }</code> </pre><br>  Codepen 5. Bereiche, die <a href="https://codepen.io/rachelandrew/pen/QqMVKa/" rel="nofollow">aus benannten Linien</a> gebildet <a href="https://codepen.io/rachelandrew/pen/QqMVKa/" rel="nofollow">werden</a> <br><br><h2>  Linien werden aus benannten Bereichen gebildet </h2><br>  Wir k√∂nnen auch das Gegenteil von dem tun, was oben gezeigt ist, indem wir Linien verwenden, die aus benannten Bereichen erstellt wurden.  Jeder Bereich erstellt vier benannte Zeilen mit derselben Suffixkonvention wie <code>-start</code> und <code>-start</code> .  Wenn es einen benannten Bereich mit dem Namen <code>main</code> , werden seine Start- und Endzeilen und Spaltenzeilen als <code>main-start</code> und <code>main-end</code> .  Diese benannten Linien k√∂nnen zum Positionieren eines Elements verwendet werden. <br><br>  Im folgenden Beispiel positioniere ich das Panel anhand der Namen dieser automatisch generierten Zeilen: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.grid</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: grid; <span class="hljs-attribute"><span class="hljs-attribute">grid-template-areas</span></span>: <span class="hljs-string"><span class="hljs-string">"head head head head head head"</span></span> <span class="hljs-string"><span class="hljs-string">"side side main main main main"</span></span> <span class="hljs-string"><span class="hljs-string">".... .... foot foot foot foot"</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.panel</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: main-start / main-end; <span class="hljs-attribute"><span class="hljs-attribute">grid-row</span></span>: head-start / foot-end; }</code> </pre><br>  Codepen 6. <a href="https://codepen.io/rachelandrew/pen/xXLarv/" rel="nofollow">Linien bilden sich aus benannten Bereichen</a> <br><br><h2>  Zeilennamen, die dem Regionsnamen entsprechen </h2><br>  Zus√§tzlich zu Linien mit den <code>-end</code> <code>-start</code> und <code>-start</code> <code>-end</code> Linien f√ºr die Fl√§chen aller Rasterregionen mit dem Namen dieser Region erstellt.  Wenn es also einen <code>main</code> gibt, k√∂nnen Sie den <code>main</code> als Wert f√ºr die Eigenschaften <code>grid-row-start</code> oder <code>grid-column-start</code> verwenden. Der Inhalt befindet sich am Anfang dieses Bereichs.  Wenn Sie diesen Wert f√ºr die Eigenschaft <code>grid-row-end</code> oder <code>grid-column-end</code> , wird die Endzeile dieses Bereichs ausgew√§hlt.  Im folgenden Beispiel <code>.panel</code> ich das Element <code>.panel</code> f√ºr Spalten vom Anfang des <code>main</code> zum Ende des <code>main</code> und f√ºr Zeilen vom Anfang des <code>main</code> zum <code>foot</code> <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.panel</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: main; <span class="hljs-attribute"><span class="hljs-attribute">grid-row</span></span>: main / foot ; }</code> </pre><br>  Codepen 7. Zeilennamen, die dem <a href="https://codepen.io/rachelandrew/pen/JryazG/" rel="nofollow">Namen der Region entsprechen</a> <br><br><h2>  Erkl√§rung der Netzfl√§cheneigenschaften </h2><br>  Es ist n√ºtzlich, etwas √ºber die <code>grid-area</code> zu wissen.  Im Wesentlichen beschreiben wir bei der Verwendung von <code>grid-area</code> mit einem Bezeichner wie <code>main</code> alle vier Linien des Areals.  G√ºltige Werte f√ºr die <code>grid-area</code> sind auch Zeilennummern. <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.main</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-area</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> / <span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span>; }</code> </pre><br>  Dies hat den gleichen Effekt wie der Eintrag: <br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.main</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-row-start</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-column-start</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-row-end</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-column-end</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>; }</code> </pre><br>  Wenn du fragst <br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.main</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-area</span></span>: main; }</code> </pre><br>  Das hei√üt eigentlich: <br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.main</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-area</span></span>: main / main / main / main ; }</code> </pre><br>  Die Eigenschaft <code>grid-area</code> verh√§lt sich etwas anders, wenn anstelle einer Zeilennummer eine Benutzer-ID verwendet wird.  Wenn Sie Zeilennummern f√ºr Anfangswerte in der Eigenschaft <code>grid-area</code> , wird jede nicht angegebene Endzeilennummer automatisch auf <code>auto</code> . Daher wird durch die automatische Positionierung bestimmt, wo das Element platziert werden soll. <br><br>  Wenn Sie jedoch eine Benutzer-ID verwenden und einige Zeilen √ºberspringen, werden diese wie folgt festgelegt <br><br><h3>  Drei Zeilennamen angegeben </h3><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.main</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-area</span></span>: main / main / main ; }</code> </pre><br>  Wenn Sie drei Zeilennamen angeben, fehlt im Wesentlichen das <code>grid-column-end</code> .  Wenn <code>grid-column-start</code> eine Benutzer-ID ist, wird dieselbe ID auch f√ºr <code>grid-column-end</code> .  Wie wir bereits gesehen haben, verwendet die <code>-end</code> Eigenschaft die Endfl√§che des <code>main</code> Wenn also <code>grid-column-start</code> und <code>grid-column-end</code> auf denselben Namen festgelegt sind, wird der Inhalt auf alle Spalten dieses Bereichs ausgedehnt. <br><br><h3>  Zwei Zeilennamen angegeben </h3><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.main</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-area</span></span>: main / main ; }</code> </pre><br>  Wenn nur zwei Namen angegeben werden, werden die Anfangszeilen der Zeilen und Spalten festgelegt.  Wenn <code>grid-column-start</code> und / oder <code>grid-row-start</code> eine Benutzerkennung ist, werden <code>grid-column-end</code> und <code>grid-row-end</code> auf denselben Wert gesetzt. <br><br><h3>  Ein Zeilenname angegeben </h3><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.main</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-area</span></span>: main ; }</code> </pre><br>  Das Festlegen eines einzelnen Liniennamens ist genau das, was Sie tun, wenn Sie den Gitterbereich auf den Hauptnamen des Bereichs festlegen.  In diesem Fall werden alle vier Zeilen auf diesen Wert gesetzt. <br><br>  <b>Hinweis</b> : <i>Dies funktioniert sowohl f√ºr <code>grid-column</code> als auch f√ºr <code>grid-row</code> .</i> <br><br>  Diese Methode bedeutet, dass Sie eine Reihe von Spalten oder Zeilen in einem Raster festlegen k√∂nnen, um ein Element zu platzieren.  So wie die <code>-end</code> Werte f√ºr die Eigenschaft <code>grid-area</code> auf dieselben Werte gesetzt sind wie die urspr√ºnglichen (wenn weggelassen), verhalten sich auch die Endwerte f√ºr die Eigenschaften <code>grid-column</code> und <code>grid-row</code> .  Dies bedeutet, dass Sie das Element zwischen der Start- und Endspaltenzeile des <code>main</code> k√∂nnen, indem Sie Folgendes verwenden: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.main</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: main ; }</code> </pre><br>  In dem <a href="https://rachelandrew.co.uk/archives/2017/06/01/breaking-out-with-css-grid-explained/" rel="nofollow">erl√§uterten Breakout mit CSS-Raster habe</a> ich gezeigt, wie mit dieser Funktion n√ºtzliche Entwurfsmuster f√ºr Bereiche in voller Gr√∂√üe erstellt werden, die √ºber einen begrenzten Inhaltsbereich hinausgehen. <br><br><h2>  Ein Gitter kann viele benannte Linien haben. </h2><br>  All dies bedeutet, dass das Raster eine gro√üe Anzahl benannter Zeilen enthalten kann.  In den meisten F√§llen sollten Sie sich dar√ºber keine Sorgen machen.  Arbeiten Sie mit den Zeilen, die Sie ben√∂tigen, und ignorieren Sie die Existenz anderer. <br><br><h2>  Benennung und abgek√ºrzte Eigenschaften von Rastern und Rastervorlagen </h2><br>  CSS-Gitter hat zwei Abk√ºrzungen, mit denen Sie viele Gittereigenschaften in einer kompakten Syntax festlegen k√∂nnen.  Pers√∂nlich scheint es mir schwierig genug zu sein, dies zu erkennen.  Wenn ich dies mit anderen Entwicklern diskutiere, sind die Meinungen geteilt: Einige m√∂gen sie, andere bevorzugen die Verwendung separater Eigenschaften.  Wie bei anderen Abk√ºrzungen sollte beachtet werden, dass die Werte von Eigenschaften, die Sie nicht verwenden, auf das Original zur√ºckgesetzt werden <br><br><h3>  Gittervorlagen-Abk√ºrzung: Erstellen eines expliziten Gitters </h3><br>  Sie k√∂nnen die Verkn√ºpfung mit der Rastervorlage verwenden, um alle Eigenschaften eines expliziten Rasters gleichzeitig an einer Stelle festzulegen <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">grid-template-columns</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">grid-template-rows</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">grid-template-areas</span></span></code> </pre><br>  Dies bedeutet, dass Sie benannte Linien und benannte Bereiche gleichzeitig definieren k√∂nnen.  Bei Verwendung einer Eigenschaft, die benannte Bereiche und Linien kombiniert, w√ºrde ich zun√§chst den Wert der Eigenschaft <code>grid-template-areas</code> , wie im obigen Abschnitt beschrieben. <br><br>  Dann m√∂chten Sie m√∂glicherweise Zeilennamen hinzuf√ºgen.  Sie werden am Anfang und am Ende jeder Wertelinie platziert - denken Sie daran, dass jede Wertelinie eine Linienspur darstellt.  Der Name oder die Namen der Linien m√ºssen sich innerhalb der eckigen Klammern befinden, genau wie beim Benennen der Linien in der Eigenschaft <code>grid-template-rows</code> , und sollten sich au√üerhalb der Anf√ºhrungszeichen befinden, die die Wertelinie umgeben, die die Linienspur definiert. <br><br>  Im folgenden Beispiel habe ich zwei Zeilen genannt: Der <code>panel-start</code> folgt der Kopfzeile (zweite Zeile des Rasters) und das <code>panel-end</code> des <code>panel-end</code> der letzten Fu√üzeile (vierte Zeile des Rasters mit drei Linienspuren).  Ich habe auch die Gr√∂√üe der Linienspur f√ºr die benannten und unbenannten Linien bestimmt, indem ich am Ende der Wertlinie, die diese Linienspur beschreibt, einen Parameter hinzuf√ºgte <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.grid</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: grid; <span class="hljs-attribute"><span class="hljs-attribute">grid-gap</span></span>: <span class="hljs-number"><span class="hljs-number">20px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-template</span></span>: <span class="hljs-string"><span class="hljs-string">" head head head head head head"</span></span> <span class="hljs-number"><span class="hljs-number">10vh</span></span> [panel-start] <span class="hljs-string"><span class="hljs-string">"side side main main main main"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">minmax</span></span>(200px, auto) <span class="hljs-string"><span class="hljs-string">".... .... foot foot foot foot"</span></span> <span class="hljs-number"><span class="hljs-number">10vh</span></span> [panel-end]; }</code> </pre><br>  Wenn es auch notwendig ist, die Spalten zu benennen, k√∂nnen wir dies nicht innerhalb der Zeile tun, also m√ºssen wir das Trennzeichen <b><code>/</code></b> hinzuf√ºgen und dann eine Liste von Spaltenspuren definieren.  Zeilen werden so benannt, als w√§re diese Liste der Wert der Eigenschaft <code>grid-template-columns</code> . <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.grid</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: grid; <span class="hljs-attribute"><span class="hljs-attribute">grid-gap</span></span>: <span class="hljs-number"><span class="hljs-number">20px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-template</span></span>: <span class="hljs-string"><span class="hljs-string">" head head head head head head"</span></span> <span class="hljs-number"><span class="hljs-number">10vh</span></span> [panel-start] <span class="hljs-string"><span class="hljs-string">"side side main main main main"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">minmax</span></span>(200px, auto) <span class="hljs-string"><span class="hljs-string">".... .... foot foot foot foot"</span></span> <span class="hljs-number"><span class="hljs-number">10vh</span></span> [panel-end] / [full-start ] <span class="hljs-number"><span class="hljs-number">1</span></span>fr [panel-start] <span class="hljs-number"><span class="hljs-number">2</span></span>fr <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr <span class="hljs-number"><span class="hljs-number">1</span></span>fr [panel-end] <span class="hljs-number"><span class="hljs-number">2</span></span>fr [full-end]; }</code> </pre><br>  In diesem Beispiel, das Sie im folgenden Codepen sehen k√∂nnen, erstelle ich einen zus√§tzlichen Satz von Zeilen und Spalten. Diese Zeilen definieren einen Bereich namens <code>panel</code> , da ich die Syntax <code>panel-start</code> und <code>panel-end</code> .  Auf diese Weise kann ich das Element platzieren, indem ich den <code>panel</code> der Eigenschaft <code>grid-area</code> festlege. <br><br>  Auf den ersten Blick erscheint dies eher unverst√§ndlich.  Hier erstellen wir also eine Liste von Spalten, die gem√§√ü unserer oben definierten ASCII-Tabelle ausgerichtet sind.  F√ºgen Sie optional Leerzeichen zwischen den Werten ein, um die Definition von <code>template-areas</code> und <code>template-columns</code> auszurichten. <br><br>  Codepen 8. Gitter- <a href="https://codepen.io/rachelandrew/pen/wrqxrK/" rel="nofollow">Vorlage-Abk√ºrzung</a> <br><br><h3>  Gitterabk√ºrzung: implizites und explizites Gitter </h3><br>  In der Spezifikation wird davon ausgegangen, dass Sie, wenn Sie ein implizites Raster separat definieren m√ºssen, die Eigenschaft "Kurzschriftraster" anstelle der <code>grid-template</code> .  Das Abk√ºrzungsraster setzt alle impliziten Werte zur√ºck, die Sie nicht festgelegt haben.  Auf diese Weise k√∂nnen Sie die folgenden Eigenschaften festlegen und zur√ºcksetzen <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">grid-template-columns</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">grid-template-rows</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">grid-template-areas</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">grid-auto-columns</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">grid-auto-rows</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">grid-auto-flow</span></span></code> </pre><br>  F√ºr unsere Zwecke ist die Verwendung der <code>grid</code> identisch mit der Verwendung der <code>grid-template</code> , da wir eine implizite Gitterdefinition definieren.  Der einzige Unterschied besteht darin, die Eigenschaften von <code>grid-auto‚Äì*</code> .  Die <code>grid</code> kann entweder zum Festlegen des expliziten Gitters und zum Zur√ºcksetzen der impliziten Eigenschaften oder zum Festlegen des impliziten Gitters und zum Zur√ºcksetzen der expliziten Eigenschaften verwendet werden.  Beides gleichzeitig zu machen, macht nicht viel Sinn <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.grid</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: grid; <span class="hljs-attribute"><span class="hljs-attribute">grid-gap</span></span>: <span class="hljs-number"><span class="hljs-number">20px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid</span></span>: <span class="hljs-string"><span class="hljs-string">" head head head head head head"</span></span> <span class="hljs-number"><span class="hljs-number">10vh</span></span> [panel-start] <span class="hljs-string"><span class="hljs-string">"side side main main main main"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">minmax</span></span>(200px, auto) <span class="hljs-string"><span class="hljs-string">".... .... foot foot foot foot"</span></span> <span class="hljs-number"><span class="hljs-number">10vh</span></span> [panel-end] / [full-start ] <span class="hljs-number"><span class="hljs-number">1</span></span>fr [panel-start] <span class="hljs-number"><span class="hljs-number">2</span></span>fr <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr <span class="hljs-number"><span class="hljs-number">1</span></span>fr [panel-end] <span class="hljs-number"><span class="hljs-number">2</span></span>fr [full-end]; }</code> </pre><br>  <b>Hinweis</b> : <i>In der urspr√ºnglich empfohlenen Version der CSS-Raster-Spezifikation werden durch diese Reduzierung auch die L√ºckeneigenschaften zwischen <code>grid-column-gap</code> und <code>grid-row-gap</code> Zellen zur√ºckgesetzt.</i>  <i>Dieses Verhalten wurde jedoch schlie√ülich ge√§ndert.</i>  <i>Browser aktualisieren dieses Verhalten, aber zum Zeitpunkt des Schreibens (Oktober 2017) kann es immer noch vorkommen, dass der Wert der L√ºckeneigenschaften bei Verwendung der Reduzierung auf Null zur√ºckgesetzt wird, sodass Sie sie m√∂glicherweise sp√§ter neu definieren m√ºssen</i> <br><br><h2>  Welchen Ansatz verwenden? </h2><br>  Sie fragen sich vielleicht, welche dieser Methoden f√ºr eine bestimmte Aufgabe am besten geeignet ist?  Es gibt keine strengen Regeln.  Pers√∂nlich verwende ich gerne <code>grid-template-areas</code> f√ºr Komponenten, wenn ich in meiner Vorlagenbibliothek arbeite.  Es ist praktisch, die Struktur der Komponente direkt vor Ihren Augen in CSS- und <code>grid-template-areas</code> zu haben, damit Sie beim Testen verschiedene Layoutoptionen ausprobieren k√∂nnen.  Ich fand, dass es wegen einer so einfachen Bewegung der Maschenzellen wichtig ist, dass die visuelle und logische Reihenfolge der Komponentenzellen nicht gest√∂rt wird.  Besucher, die √ºber die Tastatur mit Ihrer Site interagieren und mit der Tabulatortaste zwischen den Elementen wechseln, w√§hlen die Elemente in der Reihenfolge aus, in der sie im Markup definiert sind.  Denken Sie daran, das Layout neu zu ordnen, sobald Sie sich f√ºr die am besten geeignete Art der Anzeige Ihres Inhalts entschieden haben.  Um mehr √ºber dieses Problem zu erfahren, schlage ich vor, den Artikel √ºber <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/CSS_Grid_Layout_and_Accessibility" rel="nofollow">CSS-Rasterlayout und Eingabehilfen zu</a> lesen. <br><br><h2>  Grundlegende Namenskonventionen </h2><br>  Um den Artikel zusammenzufassen, fasse ich ein paar Grundregeln zusammen, die Sie beim Benennen von Linien oder Bereichen in CSS Grid ber√ºcksichtigen sollten: <br><br>  <b>Linienbezeichnung:</b> <br><br><ol><li>  Sie k√∂nnen fast jeden Namen verwenden (mit Ausnahme des span-Schl√ºsselworts), aber Sie k√∂nnen auch den aus diesen Zeilen erstellten Bereich verwenden, wenn deren Namen mit <code>-start</code> und <code>-start</code> enden </li><li>  Zeilen k√∂nnen mehrere Namen haben, die in eckigen Klammern definiert und durch ein Leerzeichen getrennt sind </li><li>  Mehrere Zeilen k√∂nnen denselben Namen haben.  Wenn Sie ein bestimmtes ben√∂tigen, f√ºgen Sie einfach die Nummer der erforderlichen Zeile nach dem Namen in der Reihenfolge hinzu </li></ol><br>  <b>Namensbereiche:</b> <br><br><ol><li>  Bei der Definition eines Bereichs mit <code>grid-template-areas</code> sollte die Form des Bereichs rechteckig sein </li><li>  Bei Verwendung der Eigenschaft <code>grid-template-areas</code> wird jede Linienspur des Rasters als Zeichenfolge von Werten dargestellt und in Anf√ºhrungszeichen angezeigt </li><li>  Jede Zelle muss gef√ºllt sein.  Wenn Sie beabsichtigt sind, einige Zellen leer zu lassen, verwenden Sie hierf√ºr einen Punkt <b><code>.</code></b>  oder Auslassungspunkte <b><code>...</code></b> keine Leerzeichen </li><li>  Benannte Regionen erstellen Linien mit demselben Namen wie die Region, jedoch mit den <code>-end</code> <code>-start</code> und <code>-start</code> .  Sie k√∂nnen zum Positionieren von Elementen verwendet werden. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de478850/">https://habr.com/ru/post/de478850/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de478838/index.html">Der erste Tod auf einem Jetpack</a></li>
<li><a href="../de478840/index.html">Wo beginnt die Schaffung eines Marktplatzes? Teil zwei</a></li>
<li><a href="../de478844/index.html">Angst und Abscheu vor IT</a></li>
<li><a href="../de478846/index.html">Systemd, interaktive Skripte und Timer</a></li>
<li><a href="../de478848/index.html">Die Evolution der digitalen Fotografie</a></li>
<li><a href="../de478852/index.html">Einf√ºhrung in GitOps f√ºr OpenShift</a></li>
<li><a href="../de478854/index.html">Der Kampf der Webserver. Teil 1 - HTTP von der Realit√§t getrennt:</a></li>
<li><a href="../de478856/index.html">SD-WAN - aktuelle Trends und Prognosen f√ºr 2020</a></li>
<li><a href="../de478858/index.html">Vergleichen von Profilierungssitzungen in XHProf Admin</a></li>
<li><a href="../de478862/index.html">Wie ist der Frontend-Test in Yandex.Market aufgebaut und warum lehnen wir w√∂chentliche Releases ab?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>