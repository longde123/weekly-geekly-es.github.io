<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍⚖️ ⛈️ 🖨️ CSS Grid Naming 🥥 ⏹️ 🎍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie zum ersten Mal lernen, wie Sie das Rasterlayout verwenden, können Sie zunächst Elemente nach Zeilennummern auf dem Raster platzieren. In dies...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>CSS Grid Naming</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/478850/">  Wenn Sie zum ersten Mal lernen, wie Sie das Rasterlayout verwenden, können Sie zunächst Elemente nach Zeilennummern auf dem Raster platzieren.  In diesem Fall muss überwacht werden, wo bestimmte Zeilen im Raster angezeigt werden. Beachten Sie, dass die Reihenfolge ihrer Nummern umgekehrt ist, wenn die Site für Sprachen angezeigt wird, die von rechts nach links geschrieben sind. <br><br>  Basierend auf diesem Liniensystem arbeiten Techniken, die es ermöglichen, Linien und sogar Gitterbereiche zu benennen.  Mithilfe dieser Techniken können Sie Objekte nach Namen und nicht nach Nummern sortieren.  In diesem Artikel werde ich die <b>verschiedenen Arten der Benennung von Linien und Bereichen in CSS-Grid-Layouts</b> sowie einige interessante Funktionen, die sie erstellen, genauer betrachten. <br><a name="habracut"></a><br><hr><br><blockquote> <b>Vom Übersetzer:</b> <br>  Ein Artikel vor zwei Jahren (2017), der jedoch die wichtige Funktionsweise des CSS-Gitters anspricht und daher heute nützlich und relevant erscheint. <br></blockquote><br><h2>  Linienbenennung </h2><br>  Beginnen wir mit der Benennung der Gitterlinien.  Im folgenden Beispiel gibt es ein Raster mit sechs expliziten Spaltenspuren und einer expliziten Linienspur.  Elemente werden mit Zeilennummern auf dem Raster platziert. <br><br><pre><code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.grid</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: grid; <span class="hljs-attribute"><span class="hljs-attribute">grid-gap</span></span>: <span class="hljs-number"><span class="hljs-number">20px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-template-rows</span></span>: <span class="hljs-number"><span class="hljs-number">20vh</span></span> ; <span class="hljs-attribute"><span class="hljs-attribute">grid-template-columns</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr; } <span class="hljs-selector-class"><span class="hljs-selector-class">.header</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-row</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> / -<span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.sidebar</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-row</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.content</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-row</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> / -<span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Bei Bedarf können in der Titelliste Zeilennamen in eckigen Klammern angegeben werden.  Es ist wichtig, sich daran zu erinnern, dass Sie die Linie benennen, nicht die Spur, die ihr folgt.  Nachdem Sie die Linien benannt haben, können Sie beim Positionieren von Elementen im Raster deren Namen anstelle von Zahlen verwenden. <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.grid</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: grid; <span class="hljs-attribute"><span class="hljs-attribute">grid-gap</span></span>: <span class="hljs-number"><span class="hljs-number">20px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-template-rows</span></span>: [header-start] <span class="hljs-number"><span class="hljs-number">20vh</span></span> [header-end] ; <span class="hljs-attribute"><span class="hljs-attribute">grid-template-columns</span></span>: [sidebar-start] <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr [sidebar-end] <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr; } <span class="hljs-selector-class"><span class="hljs-selector-class">.header</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-row</span></span>: header-start; <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> / -<span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.sidebar</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-row</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: sidebar-start / sidebar-end; }</code> </pre><br>  Der Name kann etwas anderes als das <code>span</code> Schlüsselwort sein.  Aus Gründen, die Sie später in diesem Artikel erfahren werden, ist die Benennung mit dem Suffix <code>-start</code> für führende Zeilen (es spielt keine Rolle, ob es sich um eine Zeilen- oder Spaltenzeile handelt) und <code>-end</code> für <code>-end</code> eine gute Vorgehensweise.  Das Ergebnis sollte <code>main-start</code> und <code>main-end</code> oder <code>sidebar-start</code> und <code>sidebar-end</code> . <br><br>  Ziemlich oft stimmen die Endlinie eines Teils des Rasters und die Startlinie des anderen Teils überein, aber dies ist kein Problem, da Linien mehrere Namen haben können.  Sie können Zeilen mit mehreren Namen angeben, indem Sie sie durch ein Leerzeichen in eckigen Klammern einfügen. <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.grid</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: grid; <span class="hljs-attribute"><span class="hljs-attribute">grid-gap</span></span>: <span class="hljs-number"><span class="hljs-number">20px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-template-rows</span></span>: [header-start] <span class="hljs-number"><span class="hljs-number">20vh</span></span> [header-end] ; <span class="hljs-attribute"><span class="hljs-attribute">grid-template-columns</span></span>: [full-start sidebar-start] <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr [sidebar-end main-start] <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr [main-end full-end]; } <span class="hljs-selector-class"><span class="hljs-selector-class">.header</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-row</span></span>: header-start; <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: full-start / full-end; } <span class="hljs-selector-class"><span class="hljs-selector-class">.sidebar</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-row</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: sidebar-start / sidebar-end; } <span class="hljs-selector-class"><span class="hljs-selector-class">.content</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-row</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: main-start / main-end; }</code> </pre><br>  Dieses Beispiel zeigt, dass Sie nicht jede einzelne Gitterlinie benennen müssen und dass Zeilennummern, die zusätzlich zu Namen verwendet werden können, immer verfügbar sind. <br><br>  Codepen 1. <a href="https://codepen.io/rachelandrew/pen/KXqMdm/" rel="nofollow">Line Naming</a> <br><br><h2>  Linien mit dem gleichen Namen. </h2><br>  Wir haben gesehen, wie Zeilen mehrere Namen haben können, aber es gibt auch Situationen, in denen mehrere Zeilen denselben Namen haben.  Dies geschieht, wenn Sie die Funktion <code>repeat()</code> verwenden und benannte Zeilen in die Titelliste aufnehmen.  Im folgenden Beispiel werden sechs benannte Zeilen erstellt, die abwechselnd die Namen <code>col-a-start</code> und <code>col-b-start</code> . <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.grid</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: grid; <span class="hljs-attribute"><span class="hljs-attribute">grid-gap</span></span>: <span class="hljs-number"><span class="hljs-number">20px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-template-columns</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">repeat</span></span>(3, [col-a-start] 1fr [col-b-start] 2fr); }</code> </pre><br>  Wenn Sie beim Positionieren eines Elements <code>col-a-start</code> angeben, wird es in der ersten Zeile platziert, die mit dem Namen <code>col-a-start</code> (im betrachteten Beispiel die erste Gitterlinie).  Wenn Sie beim Positionieren eines Elements <code>col-b-start</code> angeben, wird es nach demselben Prinzip auf der zweiten Rasterlinie platziert. <br><br>  Wenn Sie in nachfolgenden Zeilen positionieren müssen, fügen Sie nach dem Namen eine Zahl ein, um anzugeben, in welcher Zeile der Zeile mit demselben Namen das Objekt platziert werden soll <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.box3</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-row</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: col-a-start <span class="hljs-number"><span class="hljs-number">2</span></span> / col-b-start <span class="hljs-number"><span class="hljs-number">3</span></span>; }</code> </pre><br>  Codepen 2. <a href="https://codepen.io/rachelandrew/pen/jGLVRb/" rel="nofollow">Linien mit dem gleichen Namen.</a> <br><br>  <a href="https://www.w3.org/TR/css-grid-1/" rel="nofollow">In der Spezifikation</a> wird dieses Verhalten als "Erstellen eines benannten Satzes von Rasterlinien" beschrieben. <br><br><h2>  Speichern von Liniennamen beim Wiederherstellen eines adaptiven Rasters </h2><br>  Verwenden Sie die Zeilennummern oder deren Namen, Sie entscheiden.  In der Regel können Linien in Situationen nützlich sein, in denen Sie die Gitterstruktur im Rahmen einer Medienabfrage ändern möchten.  Anstatt zu verfolgen, auf welcher Linie Sie Elemente an verschiedenen Kontrollpunkten platzieren, können Sie auch mit nacheinander benannten Linien arbeiten. <br><br>  Im folgenden einfachen Beispiel definiere ich Rasterspalten für einen schmalen Bildschirm und definiere sie dann mit einer Breite von 550px neu. <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.grid</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: grid; <span class="hljs-attribute"><span class="hljs-attribute">grid-gap</span></span>: <span class="hljs-number"><span class="hljs-number">20px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-template-rows</span></span>: [header-start] <span class="hljs-number"><span class="hljs-number">20vh</span></span> [header-end]; <span class="hljs-attribute"><span class="hljs-attribute">grid-template-columns</span></span>: [full-start ] <span class="hljs-number"><span class="hljs-number">10px</span></span> [sidebar-start main-start] <span class="hljs-number"><span class="hljs-number">1</span></span>fr [main-end sidebar-end] <span class="hljs-number"><span class="hljs-number">10px</span></span> [full-end]; } @<span class="hljs-keyword"><span class="hljs-keyword">media</span></span> (min-width: <span class="hljs-number"><span class="hljs-number">550px</span></span>) { <span class="hljs-selector-class"><span class="hljs-selector-class">.grid</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-template-columns</span></span>: [full-start sidebar-start] <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr [sidebar-end main-start] <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr [main-end full-end]; } }</code> </pre><br>  Codepen 3. <a href="https://codepen.io/rachelandrew/pen/jGLyGB/" rel="nofollow">Benennen von Dingen:</a> Definieren Sie <a href="https://codepen.io/rachelandrew/pen/jGLyGB/" rel="nofollow">die Position der benannten Zeilen neu</a> <br><br><h2>  Benannte Regionen </h2><br>  Vorher haben wir nur benannte Zeilen betrachtet, aber es gibt einen anderen Weg.  Wir können Gitterbereiche benennen. <br><br>  Ein Gitterbereich ist ein rechteckiger Bereich, der aus einer oder mehreren Gitterzellen besteht.  Der Bereich wird durch vier Gitterlinien definiert, die die Start- und Endzeilen für Spalten und Zeilen angeben. <br><br><img src="https://habrastorage.org/webt/l2/c6/xt/l2c6xtlnkmuhzsdh1nrtx3docgg.png"><br>  Wir benennen die Gitterbereiche mit der Eigenschaft <code>grid-template-areas</code> .  Diese Eigenschaft beschreibt das Layout in Form einer ASCII-Tabelle und ist ein Satz von Linien, von denen jede eine separate Linienspur des Rasters beschreibt. <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.grid</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: grid; <span class="hljs-attribute"><span class="hljs-attribute">grid-template-columns</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">repeat</span></span>(3, 1fr 2fr) ; <span class="hljs-attribute"><span class="hljs-attribute">grid-template-areas</span></span>: <span class="hljs-string"><span class="hljs-string">"head head head head head head"</span></span> <span class="hljs-string"><span class="hljs-string">"side side main main main main"</span></span> <span class="hljs-string"><span class="hljs-string">"foot foot foot foot foot foot"</span></span>; }</code> </pre><br>  Die Namen, die wir in den Zeilen der Eigenschaft <code>grid-template-areas</code> werden den direkten untergeordneten Elementen des Rasters mithilfe der Eigenschaft <code>grid-area</code> zugewiesen.  Der Wert dieser Eigenschaft ist, wenn sie zur Benennung verwendet wird, die sogenannte <i>Benutzerkennung</i> , sodass sie nicht in Anführungszeichen eingeschlossen werden muss <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.header</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-area</span></span>: head; } <span class="hljs-selector-class"><span class="hljs-selector-class">.sidebar</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-area</span></span>: side; } <span class="hljs-selector-class"><span class="hljs-selector-class">.content</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-area</span></span>: main; } <span class="hljs-selector-class"><span class="hljs-selector-class">.footer</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-area</span></span>: foot; }</code> </pre><br>  Damit der Bereich bei der Beschreibung der Gitterstruktur mit der Eigenschaft <code>grid-template-areas</code> mehr als eine Zelle abdeckt, müssen Sie den Bezeichner mehrmals entlang einer Zeile oder Spalte neu aufzeichnen.  Der erstellte Bereich muss ein Rechteck sein. L- und T-förmige Bereiche sind nicht zulässig.  Sie können auch nur einen rechteckigen Bereich für jeden Namen erstellen - nicht verbundene Bereiche sind nicht zulässig.  Die Spezifikation stellt fest, dass: <br><blockquote>  <i>„In zukünftigen Versionen dieses Moduls sind möglicherweise nicht rechteckige oder nicht verbundene Bereiche zulässig.“</i> <i><br></i>  <i>- <a href="https://www.w3.org/TR/css-grid-1/" rel="nofollow">Eigenschaftenraster-Vorlagenbereiche</a></i> <br></blockquote><br>  Bei der Beschreibung eines Rasters muss auf die vollständige Darstellung geachtet werden, da sonst die gesamte Anzeige als ungültig verworfen wird.  Dies bedeutet, dass jede Gitterzelle gefüllt sein muss. <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">grid-template-areas</span></span>: "<span class="hljs-selector-tag"><span class="hljs-selector-tag">head</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">head</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">head</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">head</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">head</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">head</span></span>" "<span class="hljs-selector-tag"><span class="hljs-selector-tag">side</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">side</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span>" "<span class="hljs-selector-tag"><span class="hljs-selector-tag">foot</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">foot</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">foot</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">foot</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">foot</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">foot</span></span>"; }</code> </pre><br>  Da Sie möglicherweise einige Zellen im Markup leer lassen möchten, definiert die Spezifikation ein Punktsymbol <b><code>.</code></b>  oder eine Folge von Punkten ohne Leerzeichen zwischen ihnen <b><code>....</code></b> als Markierung einer leeren Zelle <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">grid-template-areas</span></span>: "<span class="hljs-selector-tag"><span class="hljs-selector-tag">head</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">head</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">head</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">head</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">head</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">head</span></span>" "<span class="hljs-selector-tag"><span class="hljs-selector-tag">side</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">side</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span>" "....... ....... <span class="hljs-selector-tag"><span class="hljs-selector-tag">foot</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">foot</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">foot</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">foot</span></span>"; }</code> </pre><br>  Codepen 4. <a href="https://codepen.io/rachelandrew/pen/gGxKXd/" rel="nofollow">Benannte Regionen</a> <br><br>  Wenn Sie Firefox noch nicht heruntergeladen haben, um die neuesten Funktionen von Firefox DevTools Grid Inspector zu nutzen, empfehle ich dies, wenn Sie mit benannten Bereichen arbeiten <br><br><img src="https://habrastorage.org/webt/1g/ak/4f/1gak4fvdwrsqwj7nchm3t_y8eug.png"><br>  <i>Demonstration benannter Bereiche im "Grid Inspector" des Firefox-Browsers ( <a href="" rel="nofollow">Original öffnen</a> )</i> <br><br><h2>  Benannte Linien bilden Bereiche </h2><br>  Nun kommen wir zu dem interessanten Teil dieses ganzen Namensfestes.  Sie erinnern sich vielleicht, dass ich bei der Betrachtung der benannten Zeilen vorgeschlagen habe, eine Zeilenende-Vereinbarung zu verwenden, die den Beginn des Bereichs mit <code>-start</code> und das Ende des Bereichs mit <code>-start</code> .  Der Grund dafür ist, dass Sie, wenn Sie die Linien auf diese Weise benennen, einen Gitterbereich mit diesem Namen erhalten und ein Element darin einfügen können, indem Sie diesen Namen über die <code>grid-area</code> festlegen. <br><br>  Im folgenden Beispiel bezeichne ich für Zeilen und Spalten die Zeilen <code>panel-start</code> und <code>panel-end</code> .  Dies gibt mir einen benannten Bereich namens Panel.  Wenn ich es als Wert der Eigenschaft <code>grid-area</code> für ein Element auf der Seite festlege, wird das Element in den durch diese Linien definierten Bereich eingefügt <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.grid</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: grid; <span class="hljs-attribute"><span class="hljs-attribute">grid-gap</span></span>: <span class="hljs-number"><span class="hljs-number">20px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-template-columns</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>fr [panel-start] <span class="hljs-number"><span class="hljs-number">2</span></span>fr <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr <span class="hljs-number"><span class="hljs-number">1</span></span>fr [panel-end] <span class="hljs-number"><span class="hljs-number">2</span></span>fr; <span class="hljs-attribute"><span class="hljs-attribute">grid-template-rows</span></span>: <span class="hljs-number"><span class="hljs-number">10vh</span></span> [panel-start] <span class="hljs-built_in"><span class="hljs-built_in">minmax</span></span>(200px, auto) <span class="hljs-number"><span class="hljs-number">10vh</span></span> [panel-end]; <span class="hljs-attribute"><span class="hljs-attribute">grid-template-areas</span></span>: <span class="hljs-string"><span class="hljs-string">"head head head head head head"</span></span> <span class="hljs-string"><span class="hljs-string">"side side main main main main"</span></span> <span class="hljs-string"><span class="hljs-string">".... .... foot foot foot foot"</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.panel</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-area</span></span>: panel; }</code> </pre><br>  Codepen 5. Bereiche, die <a href="https://codepen.io/rachelandrew/pen/QqMVKa/" rel="nofollow">aus benannten Linien</a> gebildet <a href="https://codepen.io/rachelandrew/pen/QqMVKa/" rel="nofollow">werden</a> <br><br><h2>  Linien werden aus benannten Bereichen gebildet </h2><br>  Wir können auch das Gegenteil von dem tun, was oben gezeigt ist, indem wir Linien verwenden, die aus benannten Bereichen erstellt wurden.  Jeder Bereich erstellt vier benannte Zeilen mit derselben Suffixkonvention wie <code>-start</code> und <code>-start</code> .  Wenn es einen benannten Bereich mit dem Namen <code>main</code> , werden seine Start- und Endzeilen und Spaltenzeilen als <code>main-start</code> und <code>main-end</code> .  Diese benannten Linien können zum Positionieren eines Elements verwendet werden. <br><br>  Im folgenden Beispiel positioniere ich das Panel anhand der Namen dieser automatisch generierten Zeilen: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.grid</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: grid; <span class="hljs-attribute"><span class="hljs-attribute">grid-template-areas</span></span>: <span class="hljs-string"><span class="hljs-string">"head head head head head head"</span></span> <span class="hljs-string"><span class="hljs-string">"side side main main main main"</span></span> <span class="hljs-string"><span class="hljs-string">".... .... foot foot foot foot"</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.panel</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: main-start / main-end; <span class="hljs-attribute"><span class="hljs-attribute">grid-row</span></span>: head-start / foot-end; }</code> </pre><br>  Codepen 6. <a href="https://codepen.io/rachelandrew/pen/xXLarv/" rel="nofollow">Linien bilden sich aus benannten Bereichen</a> <br><br><h2>  Zeilennamen, die dem Regionsnamen entsprechen </h2><br>  Zusätzlich zu Linien mit den <code>-end</code> <code>-start</code> und <code>-start</code> <code>-end</code> Linien für die Flächen aller Rasterregionen mit dem Namen dieser Region erstellt.  Wenn es also einen <code>main</code> gibt, können Sie den <code>main</code> als Wert für die Eigenschaften <code>grid-row-start</code> oder <code>grid-column-start</code> verwenden. Der Inhalt befindet sich am Anfang dieses Bereichs.  Wenn Sie diesen Wert für die Eigenschaft <code>grid-row-end</code> oder <code>grid-column-end</code> , wird die Endzeile dieses Bereichs ausgewählt.  Im folgenden Beispiel <code>.panel</code> ich das Element <code>.panel</code> für Spalten vom Anfang des <code>main</code> zum Ende des <code>main</code> und für Zeilen vom Anfang des <code>main</code> zum <code>foot</code> <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.panel</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: main; <span class="hljs-attribute"><span class="hljs-attribute">grid-row</span></span>: main / foot ; }</code> </pre><br>  Codepen 7. Zeilennamen, die dem <a href="https://codepen.io/rachelandrew/pen/JryazG/" rel="nofollow">Namen der Region entsprechen</a> <br><br><h2>  Erklärung der Netzflächeneigenschaften </h2><br>  Es ist nützlich, etwas über die <code>grid-area</code> zu wissen.  Im Wesentlichen beschreiben wir bei der Verwendung von <code>grid-area</code> mit einem Bezeichner wie <code>main</code> alle vier Linien des Areals.  Gültige Werte für die <code>grid-area</code> sind auch Zeilennummern. <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.main</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-area</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> / <span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span>; }</code> </pre><br>  Dies hat den gleichen Effekt wie der Eintrag: <br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.main</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-row-start</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-column-start</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-row-end</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-column-end</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>; }</code> </pre><br>  Wenn du fragst <br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.main</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-area</span></span>: main; }</code> </pre><br>  Das heißt eigentlich: <br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.main</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-area</span></span>: main / main / main / main ; }</code> </pre><br>  Die Eigenschaft <code>grid-area</code> verhält sich etwas anders, wenn anstelle einer Zeilennummer eine Benutzer-ID verwendet wird.  Wenn Sie Zeilennummern für Anfangswerte in der Eigenschaft <code>grid-area</code> , wird jede nicht angegebene Endzeilennummer automatisch auf <code>auto</code> . Daher wird durch die automatische Positionierung bestimmt, wo das Element platziert werden soll. <br><br>  Wenn Sie jedoch eine Benutzer-ID verwenden und einige Zeilen überspringen, werden diese wie folgt festgelegt <br><br><h3>  Drei Zeilennamen angegeben </h3><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.main</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-area</span></span>: main / main / main ; }</code> </pre><br>  Wenn Sie drei Zeilennamen angeben, fehlt im Wesentlichen das <code>grid-column-end</code> .  Wenn <code>grid-column-start</code> eine Benutzer-ID ist, wird dieselbe ID auch für <code>grid-column-end</code> .  Wie wir bereits gesehen haben, verwendet die <code>-end</code> Eigenschaft die Endfläche des <code>main</code> Wenn also <code>grid-column-start</code> und <code>grid-column-end</code> auf denselben Namen festgelegt sind, wird der Inhalt auf alle Spalten dieses Bereichs ausgedehnt. <br><br><h3>  Zwei Zeilennamen angegeben </h3><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.main</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-area</span></span>: main / main ; }</code> </pre><br>  Wenn nur zwei Namen angegeben werden, werden die Anfangszeilen der Zeilen und Spalten festgelegt.  Wenn <code>grid-column-start</code> und / oder <code>grid-row-start</code> eine Benutzerkennung ist, werden <code>grid-column-end</code> und <code>grid-row-end</code> auf denselben Wert gesetzt. <br><br><h3>  Ein Zeilenname angegeben </h3><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.main</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-area</span></span>: main ; }</code> </pre><br>  Das Festlegen eines einzelnen Liniennamens ist genau das, was Sie tun, wenn Sie den Gitterbereich auf den Hauptnamen des Bereichs festlegen.  In diesem Fall werden alle vier Zeilen auf diesen Wert gesetzt. <br><br>  <b>Hinweis</b> : <i>Dies funktioniert sowohl für <code>grid-column</code> als auch für <code>grid-row</code> .</i> <br><br>  Diese Methode bedeutet, dass Sie eine Reihe von Spalten oder Zeilen in einem Raster festlegen können, um ein Element zu platzieren.  So wie die <code>-end</code> Werte für die Eigenschaft <code>grid-area</code> auf dieselben Werte gesetzt sind wie die ursprünglichen (wenn weggelassen), verhalten sich auch die Endwerte für die Eigenschaften <code>grid-column</code> und <code>grid-row</code> .  Dies bedeutet, dass Sie das Element zwischen der Start- und Endspaltenzeile des <code>main</code> können, indem Sie Folgendes verwenden: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.main</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: main ; }</code> </pre><br>  In dem <a href="https://rachelandrew.co.uk/archives/2017/06/01/breaking-out-with-css-grid-explained/" rel="nofollow">erläuterten Breakout mit CSS-Raster habe</a> ich gezeigt, wie mit dieser Funktion nützliche Entwurfsmuster für Bereiche in voller Größe erstellt werden, die über einen begrenzten Inhaltsbereich hinausgehen. <br><br><h2>  Ein Gitter kann viele benannte Linien haben. </h2><br>  All dies bedeutet, dass das Raster eine große Anzahl benannter Zeilen enthalten kann.  In den meisten Fällen sollten Sie sich darüber keine Sorgen machen.  Arbeiten Sie mit den Zeilen, die Sie benötigen, und ignorieren Sie die Existenz anderer. <br><br><h2>  Benennung und abgekürzte Eigenschaften von Rastern und Rastervorlagen </h2><br>  CSS-Gitter hat zwei Abkürzungen, mit denen Sie viele Gittereigenschaften in einer kompakten Syntax festlegen können.  Persönlich scheint es mir schwierig genug zu sein, dies zu erkennen.  Wenn ich dies mit anderen Entwicklern diskutiere, sind die Meinungen geteilt: Einige mögen sie, andere bevorzugen die Verwendung separater Eigenschaften.  Wie bei anderen Abkürzungen sollte beachtet werden, dass die Werte von Eigenschaften, die Sie nicht verwenden, auf das Original zurückgesetzt werden <br><br><h3>  Gittervorlagen-Abkürzung: Erstellen eines expliziten Gitters </h3><br>  Sie können die Verknüpfung mit der Rastervorlage verwenden, um alle Eigenschaften eines expliziten Rasters gleichzeitig an einer Stelle festzulegen <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">grid-template-columns</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">grid-template-rows</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">grid-template-areas</span></span></code> </pre><br>  Dies bedeutet, dass Sie benannte Linien und benannte Bereiche gleichzeitig definieren können.  Bei Verwendung einer Eigenschaft, die benannte Bereiche und Linien kombiniert, würde ich zunächst den Wert der Eigenschaft <code>grid-template-areas</code> , wie im obigen Abschnitt beschrieben. <br><br>  Dann möchten Sie möglicherweise Zeilennamen hinzufügen.  Sie werden am Anfang und am Ende jeder Wertelinie platziert - denken Sie daran, dass jede Wertelinie eine Linienspur darstellt.  Der Name oder die Namen der Linien müssen sich innerhalb der eckigen Klammern befinden, genau wie beim Benennen der Linien in der Eigenschaft <code>grid-template-rows</code> , und sollten sich außerhalb der Anführungszeichen befinden, die die Wertelinie umgeben, die die Linienspur definiert. <br><br>  Im folgenden Beispiel habe ich zwei Zeilen genannt: Der <code>panel-start</code> folgt der Kopfzeile (zweite Zeile des Rasters) und das <code>panel-end</code> des <code>panel-end</code> der letzten Fußzeile (vierte Zeile des Rasters mit drei Linienspuren).  Ich habe auch die Größe der Linienspur für die benannten und unbenannten Linien bestimmt, indem ich am Ende der Wertlinie, die diese Linienspur beschreibt, einen Parameter hinzufügte <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.grid</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: grid; <span class="hljs-attribute"><span class="hljs-attribute">grid-gap</span></span>: <span class="hljs-number"><span class="hljs-number">20px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-template</span></span>: <span class="hljs-string"><span class="hljs-string">" head head head head head head"</span></span> <span class="hljs-number"><span class="hljs-number">10vh</span></span> [panel-start] <span class="hljs-string"><span class="hljs-string">"side side main main main main"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">minmax</span></span>(200px, auto) <span class="hljs-string"><span class="hljs-string">".... .... foot foot foot foot"</span></span> <span class="hljs-number"><span class="hljs-number">10vh</span></span> [panel-end]; }</code> </pre><br>  Wenn es auch notwendig ist, die Spalten zu benennen, können wir dies nicht innerhalb der Zeile tun, also müssen wir das Trennzeichen <b><code>/</code></b> hinzufügen und dann eine Liste von Spaltenspuren definieren.  Zeilen werden so benannt, als wäre diese Liste der Wert der Eigenschaft <code>grid-template-columns</code> . <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.grid</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: grid; <span class="hljs-attribute"><span class="hljs-attribute">grid-gap</span></span>: <span class="hljs-number"><span class="hljs-number">20px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-template</span></span>: <span class="hljs-string"><span class="hljs-string">" head head head head head head"</span></span> <span class="hljs-number"><span class="hljs-number">10vh</span></span> [panel-start] <span class="hljs-string"><span class="hljs-string">"side side main main main main"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">minmax</span></span>(200px, auto) <span class="hljs-string"><span class="hljs-string">".... .... foot foot foot foot"</span></span> <span class="hljs-number"><span class="hljs-number">10vh</span></span> [panel-end] / [full-start ] <span class="hljs-number"><span class="hljs-number">1</span></span>fr [panel-start] <span class="hljs-number"><span class="hljs-number">2</span></span>fr <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr <span class="hljs-number"><span class="hljs-number">1</span></span>fr [panel-end] <span class="hljs-number"><span class="hljs-number">2</span></span>fr [full-end]; }</code> </pre><br>  In diesem Beispiel, das Sie im folgenden Codepen sehen können, erstelle ich einen zusätzlichen Satz von Zeilen und Spalten. Diese Zeilen definieren einen Bereich namens <code>panel</code> , da ich die Syntax <code>panel-start</code> und <code>panel-end</code> .  Auf diese Weise kann ich das Element platzieren, indem ich den <code>panel</code> der Eigenschaft <code>grid-area</code> festlege. <br><br>  Auf den ersten Blick erscheint dies eher unverständlich.  Hier erstellen wir also eine Liste von Spalten, die gemäß unserer oben definierten ASCII-Tabelle ausgerichtet sind.  Fügen Sie optional Leerzeichen zwischen den Werten ein, um die Definition von <code>template-areas</code> und <code>template-columns</code> auszurichten. <br><br>  Codepen 8. Gitter- <a href="https://codepen.io/rachelandrew/pen/wrqxrK/" rel="nofollow">Vorlage-Abkürzung</a> <br><br><h3>  Gitterabkürzung: implizites und explizites Gitter </h3><br>  In der Spezifikation wird davon ausgegangen, dass Sie, wenn Sie ein implizites Raster separat definieren müssen, die Eigenschaft "Kurzschriftraster" anstelle der <code>grid-template</code> .  Das Abkürzungsraster setzt alle impliziten Werte zurück, die Sie nicht festgelegt haben.  Auf diese Weise können Sie die folgenden Eigenschaften festlegen und zurücksetzen <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">grid-template-columns</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">grid-template-rows</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">grid-template-areas</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">grid-auto-columns</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">grid-auto-rows</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">grid-auto-flow</span></span></code> </pre><br>  Für unsere Zwecke ist die Verwendung der <code>grid</code> identisch mit der Verwendung der <code>grid-template</code> , da wir eine implizite Gitterdefinition definieren.  Der einzige Unterschied besteht darin, die Eigenschaften von <code>grid-auto–*</code> .  Die <code>grid</code> kann entweder zum Festlegen des expliziten Gitters und zum Zurücksetzen der impliziten Eigenschaften oder zum Festlegen des impliziten Gitters und zum Zurücksetzen der expliziten Eigenschaften verwendet werden.  Beides gleichzeitig zu machen, macht nicht viel Sinn <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.grid</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: grid; <span class="hljs-attribute"><span class="hljs-attribute">grid-gap</span></span>: <span class="hljs-number"><span class="hljs-number">20px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid</span></span>: <span class="hljs-string"><span class="hljs-string">" head head head head head head"</span></span> <span class="hljs-number"><span class="hljs-number">10vh</span></span> [panel-start] <span class="hljs-string"><span class="hljs-string">"side side main main main main"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">minmax</span></span>(200px, auto) <span class="hljs-string"><span class="hljs-string">".... .... foot foot foot foot"</span></span> <span class="hljs-number"><span class="hljs-number">10vh</span></span> [panel-end] / [full-start ] <span class="hljs-number"><span class="hljs-number">1</span></span>fr [panel-start] <span class="hljs-number"><span class="hljs-number">2</span></span>fr <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr <span class="hljs-number"><span class="hljs-number">1</span></span>fr [panel-end] <span class="hljs-number"><span class="hljs-number">2</span></span>fr [full-end]; }</code> </pre><br>  <b>Hinweis</b> : <i>In der ursprünglich empfohlenen Version der CSS-Raster-Spezifikation werden durch diese Reduzierung auch die Lückeneigenschaften zwischen <code>grid-column-gap</code> und <code>grid-row-gap</code> Zellen zurückgesetzt.</i>  <i>Dieses Verhalten wurde jedoch schließlich geändert.</i>  <i>Browser aktualisieren dieses Verhalten, aber zum Zeitpunkt des Schreibens (Oktober 2017) kann es immer noch vorkommen, dass der Wert der Lückeneigenschaften bei Verwendung der Reduzierung auf Null zurückgesetzt wird, sodass Sie sie möglicherweise später neu definieren müssen</i> <br><br><h2>  Welchen Ansatz verwenden? </h2><br>  Sie fragen sich vielleicht, welche dieser Methoden für eine bestimmte Aufgabe am besten geeignet ist?  Es gibt keine strengen Regeln.  Persönlich verwende ich gerne <code>grid-template-areas</code> für Komponenten, wenn ich in meiner Vorlagenbibliothek arbeite.  Es ist praktisch, die Struktur der Komponente direkt vor Ihren Augen in CSS- und <code>grid-template-areas</code> zu haben, damit Sie beim Testen verschiedene Layoutoptionen ausprobieren können.  Ich fand, dass es wegen einer so einfachen Bewegung der Maschenzellen wichtig ist, dass die visuelle und logische Reihenfolge der Komponentenzellen nicht gestört wird.  Besucher, die über die Tastatur mit Ihrer Site interagieren und mit der Tabulatortaste zwischen den Elementen wechseln, wählen die Elemente in der Reihenfolge aus, in der sie im Markup definiert sind.  Denken Sie daran, das Layout neu zu ordnen, sobald Sie sich für die am besten geeignete Art der Anzeige Ihres Inhalts entschieden haben.  Um mehr über dieses Problem zu erfahren, schlage ich vor, den Artikel über <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/CSS_Grid_Layout_and_Accessibility" rel="nofollow">CSS-Rasterlayout und Eingabehilfen zu</a> lesen. <br><br><h2>  Grundlegende Namenskonventionen </h2><br>  Um den Artikel zusammenzufassen, fasse ich ein paar Grundregeln zusammen, die Sie beim Benennen von Linien oder Bereichen in CSS Grid berücksichtigen sollten: <br><br>  <b>Linienbezeichnung:</b> <br><br><ol><li>  Sie können fast jeden Namen verwenden (mit Ausnahme des span-Schlüsselworts), aber Sie können auch den aus diesen Zeilen erstellten Bereich verwenden, wenn deren Namen mit <code>-start</code> und <code>-start</code> enden </li><li>  Zeilen können mehrere Namen haben, die in eckigen Klammern definiert und durch ein Leerzeichen getrennt sind </li><li>  Mehrere Zeilen können denselben Namen haben.  Wenn Sie ein bestimmtes benötigen, fügen Sie einfach die Nummer der erforderlichen Zeile nach dem Namen in der Reihenfolge hinzu </li></ol><br>  <b>Namensbereiche:</b> <br><br><ol><li>  Bei der Definition eines Bereichs mit <code>grid-template-areas</code> sollte die Form des Bereichs rechteckig sein </li><li>  Bei Verwendung der Eigenschaft <code>grid-template-areas</code> wird jede Linienspur des Rasters als Zeichenfolge von Werten dargestellt und in Anführungszeichen angezeigt </li><li>  Jede Zelle muss gefüllt sein.  Wenn Sie beabsichtigt sind, einige Zellen leer zu lassen, verwenden Sie hierfür einen Punkt <b><code>.</code></b>  oder Auslassungspunkte <b><code>...</code></b> keine Leerzeichen </li><li>  Benannte Regionen erstellen Linien mit demselben Namen wie die Region, jedoch mit den <code>-end</code> <code>-start</code> und <code>-start</code> .  Sie können zum Positionieren von Elementen verwendet werden. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de478850/">https://habr.com/ru/post/de478850/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de478838/index.html">Der erste Tod auf einem Jetpack</a></li>
<li><a href="../de478840/index.html">Wo beginnt die Schaffung eines Marktplatzes? Teil zwei</a></li>
<li><a href="../de478844/index.html">Angst und Abscheu vor IT</a></li>
<li><a href="../de478846/index.html">Systemd, interaktive Skripte und Timer</a></li>
<li><a href="../de478848/index.html">Die Evolution der digitalen Fotografie</a></li>
<li><a href="../de478852/index.html">Einführung in GitOps für OpenShift</a></li>
<li><a href="../de478854/index.html">Der Kampf der Webserver. Teil 1 - HTTP von der Realität getrennt:</a></li>
<li><a href="../de478856/index.html">SD-WAN - aktuelle Trends und Prognosen für 2020</a></li>
<li><a href="../de478858/index.html">Vergleichen von Profilierungssitzungen in XHProf Admin</a></li>
<li><a href="../de478862/index.html">Wie ist der Frontend-Test in Yandex.Market aufgebaut und warum lehnen wir wöchentliche Releases ab?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>