<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí≤ üõÅ ‚óÄÔ∏è Ich muss schnell gehen: Auf Geschwindigkeit in iOS bauen. Teil 1 üï¶ ü§ûüèæ üë∂üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es gibt viele Tipps und Tricks, mit denen iOS-Entwickler wissen, wie Leistungsoptimierungen vorgenommen werden k√∂nnen, damit Animationen in Anwendunge...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ich muss schnell gehen: Auf Geschwindigkeit in iOS bauen. Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/e-Legion/blog/436360/"><img src="https://habrastorage.org/webt/cl/ww/k-/clwwk-yxw7f1pbfvtly5lytqnac.png"><br><br>  Es gibt viele Tipps und Tricks, mit denen iOS-Entwickler wissen, wie Leistungsoptimierungen vorgenommen werden k√∂nnen, damit Animationen in Anwendungen reibungslos ausgef√ºhrt werden.  Nachdem Sie den Artikel gelesen haben, werden Sie feststellen, was 16,67 Millisekunden f√ºr iOS-Entwickler bedeuten und welche Tools besser zum Aufsp√ºren des Codes geeignet sind. <br><br>  Der Artikel basiert auf dem Keynote-Vortrag von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Luke Parham</a> , derzeit iOS-Ingenieur bei Apple und Autor von Tutorials f√ºr die iOS-Entwicklung auf RayWenderlich.com, auf der International Mobile Developers Conference <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MBLT DEV 2017</a> . <a name="habracut"></a><br><br><blockquote>  ‚ÄûHey Leute.  Wenn Sie beispielsweise die Startzeit um 10 Sekunden verk√ºrzen k√∂nnen, multiplizieren Sie diese mit 5 Millionen Benutzern und das sind 50 Millionen Sekunden pro Tag.  √úber ein Jahr sind das wahrscheinlich Dutzende von Leben.  Wenn Sie es also zehn Sekunden schneller booten lassen, haben Sie ein Dutzend Leben gerettet.  Das ist es wirklich wert, findest du nicht? " </blockquote><br>  <i>Steve Jobs √ºber die Leistung (Startzeit von Apple II).</i> <br><br><h2>  Leistung in iOS oder wie man aus der Hauptleitung kommt </h2><br>  Der Haupt-Thread ist daf√ºr verantwortlich, Benutzereingaben zu akzeptieren und Ergebnisse auf dem Bildschirm anzuzeigen.  Tippen, Schwenken, alle Gesten akzeptieren und dann rendern.  Die meisten modernen Mobiltelefone rendern mit 60 Bildern pro Sekunde.  Dies bedeutet, dass jeder die gesamte Arbeit innerhalb von 16,67 Millisekunden erledigen m√∂chte.  Das Verlassen des Hauptfadens ist also eine wirklich gro√üe Sache. <br><br>  Wenn etwas l√§nger als 16,67 Millisekunden dauert, werden automatisch Frames gel√∂scht, und Ihre Benutzer sehen es, wenn Animationen ausgef√ºhrt werden.  Einige Ger√§te haben noch weniger Zeit zum Rendern, zum Beispiel hat das neue iPad 120 Hertz, sodass nur 8 Millisekunden pro Frame f√ºr die Arbeit zur Verf√ºgung stehen. <br><br><h2>  Frames fallen gelassen </h2><br><h3>  Regel 1: Verwenden Sie einen CADisplayLink, um abgelegte Frames zu verfolgen </h3><br>  CADisplayLink ist ein spezieller Timer, der auf dem Vsync ausgel√∂st wird.  Vsync wird ausgef√ºhrt, wenn die App auf dem Bildschirm gerendert wird. Dies geschieht alle 16 Millisekunden.  Zu Testzwecken k√∂nnen Sie in Ihrem AppDelegate CADisplayLink einrichten, das der Hauptlaufschleife hinzugef√ºgt wurde, und dann einfach eine andere Funktion haben, in der Sie ein wenig rechnen.  Dann verfolgen Sie, wie lange die App ausgef√ºhrt wurde und wie lange es her ist, seit diese Funktion das letzte Mal ausgel√∂st wurde.  Und sehen Sie, ob es l√§nger als 16 Millisekunden gedauert hat. <br><br><img src="https://habrastorage.org/webt/pm/jv/r_/pmjvr_ketfth1a_vhcp36_lu-mu.png"><br><br>  Dies wird nur ausgel√∂st, wenn es tats√§chlich gerendert werden kann.  Wenn Sie eine Menge Arbeit erledigt und den Hauptthread verlangsamt haben, wird dieser 100 Millisekunden sp√§ter ausgef√ºhrt, was bedeutet, dass Sie zu viel Arbeit geleistet und in dieser Zeit Frames gel√∂scht haben. <br><br>  Dies ist beispielsweise die App Catstagram.  Es hat Ruckler, wenn das Bild geladen wird.  Und dann k√∂nnen Sie sehen, dass der Frame zu einem bestimmten Zeitpunkt gel√∂scht wurde und eine verstrichene Zeit von etwa 200 Millisekunden hatte.  Das bedeutet, dass diese App etwas tut, das zu lange dauert. <br><br><img src="https://habrastorage.org/webt/tz/8b/_u/tz8b_u-2r_f5-p7k9pjll9hvhfk.gif"><br><br>  Benutzer m√∂gen eine solche Erfahrung nicht, insbesondere wenn die App √§ltere Ger√§te wie iPhone 5, alte iPods usw. unterst√ºtzt. <br><br><h3>  Zeitprofiler </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Time Profiler</a> ist wahrscheinlich das n√ºtzlichste Tool, um das Zeug aufzusp√ºren.  Die anderen Tools sind n√ºtzlich, aber letztendlich verwenden wir in Fyusion den Time Profiler in 90% der F√§lle.  Die √ºblichen Verd√§chtigen der Anwendung sind Bildlaufansicht, Text und Bilder. <br><br>  Bilder sind die wirklich gro√üen.  Wir haben JPEG-Decodierung - "UIImageView" entspricht etwas UIImage.  UIimages dekodieren alle JPEGs f√ºr die App.  Sie tun es langsam, so dass Sie die Leistung nicht direkt verfolgen k√∂nnen.  Es passiert nicht richtig, wenn Sie das Bild festlegen, aber Sie k√∂nnen es in Zeitprofiler-Traces sehen. <br>  Textmessung ist eine weitere gro√üe Sache.  Es zeigt sich, zB wenn Sie viele wirklich komplexe wie Japanisch oder Chinesisch haben.  Die Messung von Linien kann lange dauern. <br><br>  Das Hierarchie-Layout verlangsamt auch das App-Rendering.  Dies gilt insbesondere f√ºr das automatische Layout.  Es ist praktisch, aber im Vergleich zum manuellen Layout auch aggressiv langsam.  Es ist also einer dieser Kompromisse.  Wenn die App dadurch verlangsamt wird, ist es m√∂glicherweise an der Zeit, von der App abzuweichen und eine andere Layouttechnik auszuprobieren. <br><br><h3>  Beispielverfolgung </h3><br><br><img src="https://habrastorage.org/webt/sx/od/dw/sxoddwfs536ehipsoclxey4yysw.png"><br><br>  Im Beispielaufrufbaum k√∂nnen Sie sehen, wie viel Arbeit Ihre CPUs leisten.  Sie k√∂nnen die Ansichten wechseln, sie nach Threads und nach CPUs betrachten.  Normalerweise ist es am interessantesten, nach Threads zu trennen und dann zu schauen, was auf main ist. <br><br>  Wenn Sie sich das zum ersten Mal ansehen, scheint es oft sehr √ºberw√§ltigend zu sein.  Sie haben manchmal das Gef√ºhl: ‚ÄûWas ist das f√ºr ein M√ºll?  Ich wei√ü nicht, was dies "FRunLoopDoSource0" bedeutet. <br><br>  Aber es ist eines der Dinge, in die man sich vertiefen und verstehen kann, wie Dinge funktionieren, und es beginnt Sinn zu machen.  Sie k√∂nnen also der Stapelverfolgung folgen und alle Systemelemente anzeigen, die Sie nicht geschrieben haben.  Aber unten sehen Sie Ihren tats√§chlichen Code. <br><br><h3>  Der Anrufbaum </h3><br>  Zum Beispiel haben wir eine wirklich einfache App, die die Hauptfunktion hat und dann einige Methoden innerhalb der Hauptfunktion aufruft.  Der Zeitprofiler erstellt standardm√§√üig jede Millisekunde eine Momentaufnahme der aktuellen Stapelverfolgung.  Dann wartet es eine Millisekunde und macht einen Schnappschuss, in dem Sie "main" genannt haben, was "foo" hei√üt, was "bar" hei√üt.  √úber dem Screenshot befindet sich die erste Stapelverfolgung.  Das wird also gesammelt.  Wir haben diese Z√§hlungen: 1, 1, 1. <br><br><img src="https://habrastorage.org/webt/uc/rc/uq/ucrcuqen-b5unzzu3hinwhxny6e.png"><br><br>  Jede dieser Funktionen wurde einmal aufgerufen.  Dann, eine Millisekunde sp√§ter, erfassen wir einen weiteren Stapel.  Und diesmal ist es genau das Gleiche, wir erh√∂hen alle Z√§hlungen um 2. <br><br><img src="https://habrastorage.org/webt/r2/ak/ez/r2akezneiolgd_p4robekqxddtg.jpeg"><br><br>  In der dritten Millisekunde haben wir dann einen etwas anderen Aufrufstapel.  Main ruft direkt "bar" an.  Main und Bar sind um eins.  Aber dann haben wir eine Trennung.  Manchmal rufen Hauptanrufe "foo", manchmal Hauptanrufe "bar" direkt.  Das passiert einmal.  Eine Methode wurde in einer anderen aufgerufen. <br><br>  Weiterhin wurde eine Methode in einer anderen aufgerufen, die die dritte Methode aufruft.  Wir sehen, dass "buz" zweimal aufgerufen wurde.  Aber es ist eine so kleine Methode, dass sie zwischen einer Millisekunde stattfindet. <br><br>  Bei Verwendung des Zeitprofilers ist zu beachten, dass die genauen Zeiten nicht angegeben werden.  Es sagt nicht genau, wie lange eine Methode dauert.  Es gibt an, wie oft es in Snapshots angezeigt wird. Dies kann nur ann√§hern, wie lange die Ausf√ºhrung der einzelnen Methoden gedauert hat.  Denn wenn etwas kurz genug ist, wird es nie auftauchen. <br><br><img src="https://habrastorage.org/webt/2x/9_/3a/2x9_3a7jrotn2hmb7qwcrstnqq8.jpeg"><br><br>  Wenn Sie in der Anrufstruktur in den Konsolenmodus wechseln, k√∂nnen Sie alle Frame-Drop-Ereignisse sehen und abgleichen.  Wir haben eine Menge Frames, die fallen gelassen werden, und wir haben eine Menge Arbeit im Gange.  Sie k√∂nnen den Zeitprofiler vergr√∂√üern und sehen, was gerade in diesem Abschnitt ausgef√ºhrt wurde. <br><br><img src="https://habrastorage.org/webt/py/rr/mg/pyrrmgpd2zi_g7sfmd0bxkrb0jw.jpeg"><br><br>  Tats√§chlich k√∂nnen Sie auf einem Mac im Allgemeinen mit der Option auf Offenlegungsdreiecke klicken, und es wird auf magische Weise ge√∂ffnet und zeigt Ihnen, was dort am wichtigsten ist.  Es wird auf das herunterfallen, was die meiste Arbeit erledigt.  Und in 90% der F√§lle handelt es sich um CFRunLoopRun und dann um die R√ºckrufe. <br><br><img src="https://habrastorage.org/webt/a9/v-/u0/a9v-u04m0cv1rlw6iodwjhale3y.jpeg"><br><br>  Die gesamte App basiert auf einer Run Loop.  Sie haben diese Schleife, die f√ºr immer l√§uft, und dann werden bei jeder Iteration der Schleife die R√ºckrufe aufgerufen.  Wenn Sie an diesem Punkt angelangt sind, k√∂nnen Sie einen Drilldown zu jedem dieser Punkte durchf√ºhren und sich im Grunde ansehen, was Ihre drei oder vier gr√∂√üten Engp√§sse sind. <br><br>  Wenn wir uns mit einem dieser Dinge befassen, k√∂nnen wir solche Dinge sehen, bei denen es wirklich einfach ist, sie zu betrachten, und sagen: ‚ÄûWow, ich wei√ü nicht, was das tut.‚Äú  Wie Renderings, Bildanbieter, IO. <br><br><img src="https://habrastorage.org/webt/jd/ay/wp/jdaywpohjztghohyu9qnxpgqkky.jpeg"><br><br>  Es gibt eine Option, mit der Sie Systembibliotheken ausblenden k√∂nnen.  Es ist wirklich verlockend, sich zu verstecken, aber in Wirklichkeit ist dies der gr√∂√üte Engpass in der App. <br><br>  Es gibt die Gewichte, die zeigen, wie viel Prozent der Arbeit diese bestimmte Funktion oder Methode leistet.  Und wenn wir das Beispiel genauer untersuchen, haben wir 34% und das liegt an Apple jpeg_decode_image_all.  Nach ein wenig Recherche wird klar, dass dies bedeutet, dass die JPEG-Decodierung im Haupt-Thread stattfindet und den gr√∂√üten Teil des Frames verliert. <br><br><img src="https://habrastorage.org/webt/ke/zk/zl/kezkzlggrh1akcegmmvuqefzl7u.png"><br><br><h3>  Regel Nr. 2 </h3><br>  Im Allgemeinen ist es besser, JPEGs im Hintergrund zu dekodieren.  Die meisten Bibliotheken von Drittanbietern (AsyncDisplayKit, SDWebImage, ...) tun dies sofort.  Wenn Sie keine Frameworks verwenden m√∂chten, k√∂nnen Sie dies selbst tun.  Sie √ºbergeben ein Bild. In diesem Fall handelt es sich um eine Erweiterung von UIImage. Anschlie√üend richten Sie einen Kontext ein und zeichnen das Bild manuell in einen Kontext in eine CGBitmap. <br><br><img src="https://habrastorage.org/webt/yu/7j/k3/yu7jk3lnsy0csn-k2kddmjha-_w.jpeg"><br><br>  Wenn Sie dies tun, k√∂nnen Sie die decodierte Image () -Methode aus einem Hintergrundthread aufrufen.  Dadurch wird immer das dekodierte Bild zur√ºckgegeben.  Es gibt keine M√∂glichkeit zu √ºberpr√ºfen, ob insbesondere UIImage bereits dekodiert ist, und Sie m√ºssen sie hier immer weiterleiten.  Wenn Sie die Dinge jedoch richtig zwischenspeichern, wird keine zus√§tzliche Arbeit geleistet. <br><br>  Dies ist technisch weniger effizient.  Die Verwendung von UIimageView ist sehr optimiert und sehr effizient.  Es wird Hardware-Dekodierung durchf√ºhren, so dass es ein Kompromiss ist.  Ihre Bilder werden auf diese Weise langsamer dekodiert.  Aber das Gute ist, dass Sie in eine Hintergrundwarteschlange senden, Ihr Bild mit der gerade gesehenen Methode dekodieren und dann zur√ºck zum Haupt-Thread springen und Ihren Inhalt festlegen k√∂nnen. <br><br><img src="https://habrastorage.org/webt/xu/lv/dg/xulvdgmhnxm6zk4hrfaslok81fg.png"><br><br>  Obwohl diese Arbeit l√§nger dauerte, geschah sie m√∂glicherweise nicht im Hauptthread, sodass die Benutzerinteraktion nicht blockiert wurde, da das Scrollen nicht blockiert wurde.  Das ist also ein Gewinn. <br><br><h3>  Speicherwarnungen </h3><br>  Jedes Zeichen, dass Sie eine Speicherwarnung erhalten, dass Sie alles l√∂schen m√∂chten, l√∂schen Sie den gesamten nicht verwendeten Speicher, den Sie k√∂nnen.  Wenn Sie jedoch Probleme mit Hintergrund-Threads haben, beansprucht das Zuweisen dieser gro√üen dekodierten JPEGs viel neuen Speicher f√ºr Hintergrund-Threads. <br><br>  Dies geschah in der Fyuse-App.  Wenn ich zu einem Hintergrund-Thread springen und alle meine JPEGs dekodieren w√ºrde, in einigen F√§llen wie bei √§lteren Telefonen, w√ºrde das System diese sofort beenden.  Und das liegt daran, dass eine Erinnerungswarnung gesendet wird, die sagt: ‚ÄûHey!  Werde dein Ged√§chtnis los ‚Äú, aber die Hintergrundwarteschlangen h√∂ren nicht zu.  Was passiert, wenn Sie alle diese Bilder zuweisen und es dann jedes Mal abst√ºrzt?  Um dies zu umgehen, m√ºssen Sie den Haupt-Thread vom Hintergrund-Thread aus anpingen. <br><br><img src="https://habrastorage.org/webt/i2/pj/fb/i2pjfbbvytxdsiut5jqirpaibvi.png"><br><br>  Im Allgemeinen ist der Hauptthread eine Warteschlange.  Dinge werden in die Warteschlange gestellt und passieren im Haupt-Thread.  Wenn Sie in Objective-C zum Hintergrund wechseln, k√∂nnen Sie performSelectorOnMainThread: withObject: waitUntilDone: verwenden.  Dadurch wird es an das Ende der Hauptwarteschlangenzeile gesetzt. Wenn die Hauptwarteschlange also mit der Verarbeitung von Speicherwarnungen besch√§ftigt ist, wird dieser Funktionsaufruf an das Ende der Zeile gesendet und wartet, bis alle Speicherwarnungen verarbeitet sind, bevor die gesamte Zuweisung von ausgef√ºhrt wird Speicher <br><br>  In Swift ist es einfacher.  Sie k√∂nnen einen leeren Hauptblock f√ºr den Versand synchron auf main ausf√ºhren. <br><br>  Hier ist ein Beispiel, in dem wir aufger√§umt haben und Bilddecodierungen in Hintergrundwarteschlangen durchf√ºhren.  Und das visuelle Scrollen ist viel sch√∂ner.  Wir haben immer noch Frame Drops, aber dies ist auf einem iPod 5g, also ist es eines der schlimmsten Dinge, die Sie testen k√∂nnen, die immer noch iOS 10 und 11 unterst√ºtzen. <br><br><img src="https://habrastorage.org/webt/bw/fa/og/bwfaog8aavwenf4h1lkqipapnds.gif"><br><br>  Wenn Sie diese Rahmentropfen haben, k√∂nnen Sie weiter suchen.  Es ist noch Arbeit im Gange und verursacht diese Frame-Drops.  Sie k√∂nnen noch mehr tun, um es schneller zu machen. <br><br>  Zusammenfassend ist es nicht immer so einfach, aber wenn Sie kleine Dinge haben, die viel Zeit in Anspruch nehmen, k√∂nnen Sie sie im Hintergrund erledigen. <br><br>  Stellen Sie sicher, dass es nicht mit UIKit zusammenh√§ngt.  Viele UIKit-Klassen sind nicht threadsicher und Sie k√∂nnen diese UIView nicht im Hintergrund zuordnen. <br><br>  Verwenden Sie Core Graphics, wenn Sie Bildsachen im Hintergrund ausf√ºhren m√ºssen.  Verstecken Sie keine Systembibliotheken.  Und vergessen Sie nicht die Speicherwarnungen. <br><br>  Dies ist der erste Teil eines Artikels, der auf Luke Parhams Pr√§sentation basiert.  Wenn Sie mehr √ºber die Funktionsweise der Benutzeroberfl√§che in iOS erfahren m√∂chten, warum Sie einen Bezierpfad verwenden und wann Sie auf die manuelle Speicherverwaltung zur√ºckgreifen m√ºssen, lesen Sie den zweiten Teil eines Artikels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h2>  Video </h2><br>  Sehen Sie sich hier den vollst√§ndigen Vortrag an: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/tZIQjrPdFcI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436360/">https://habr.com/ru/post/de436360/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436350/index.html">Lernen Sie kontroverse Taktiken, Techniken und allgemeines Wissen (ATT @ CK). Unternehmenstaktik. Teil 7</a></li>
<li><a href="../de436352/index.html">PostgreSQL News Digest. Ausgabe Nr. 14</a></li>
<li><a href="../de436354/index.html">Das US-Milit√§r vernachl√§ssigt Fragen der Cybersicherheit</a></li>
<li><a href="../de436356/index.html">[Interessant hinter dem H√ºgel] Wie stoppen wir die technologische Abh√§ngigkeit?</a></li>
<li><a href="../de436358/index.html">Warum unterrichten √§ltere Entwickler Sch√ºler?</a></li>
<li><a href="../de436364/index.html">Liveprof zeigt an, wann und warum sich die Leistung Ihrer PHP-Anwendung ge√§ndert hat</a></li>
<li><a href="../de436370/index.html">Infrastruktur f√ºr √∂ffentliche Schl√ºssel X509 v.3 Stammzertifikatskette</a></li>
<li><a href="../de436372/index.html">Isometrisches Plugin f√ºr Unity3D</a></li>
<li><a href="../de436374/index.html">Designtrends f√ºr UI und UX 2019</a></li>
<li><a href="../de436376/index.html">√úbersicht √ºber den Gel√§nderoboter EZ-Robot Roli Rover</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>