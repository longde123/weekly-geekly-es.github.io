<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üß¢ üî™ üå∂Ô∏è Eine Geschichte √ºber V8, React und einen Leistungsabfall. Teil 1 üëéüèª „äóÔ∏è üöç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In dem Material, dessen erster Teil der √úbersetzung wir heute ver√∂ffentlichen, wird erl√§utert, wie die V8-JavaScript-Engine die besten M√∂glichkeiten z...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eine Geschichte √ºber V8, React und einen Leistungsabfall. Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/467247/">  In dem Material, dessen erster Teil der √úbersetzung wir heute ver√∂ffentlichen, wird erl√§utert, wie die V8-JavaScript-Engine die besten M√∂glichkeiten zur Darstellung verschiedener JS-Werte im Speicher ausw√§hlt und wie sich dies auf die internen Mechanismen von V8 beim Arbeiten mit sogenannten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Formularen</a> auswirkt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Objekte</a> (Form).  All dies wird uns helfen, das Wesentliche des j√ºngsten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Problems</a> der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">React-Leistung zu</a> kl√§ren. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/pu/wk/8i/puwk8ihuo_in6vqmeg86j2-5sxa.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">JavaScript-Datentypen</font> </h2><br>  Jeder JavaScript-Wert kann nur einen der acht vorhandenen Datentypen haben: <code>Number</code> , <code>String</code> , <code>Symbol</code> , <code>BigInt</code> , <code>Boolean</code> , <code>Undefined</code> , <code>Null</code> und <code>Object</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36e/5e0/3fb/36e5e03fb481b601d2bb1cc61a1fa2f4.png"></div><br>  <i><font color="#999999">JavaScript-Datentypen</font></i> <br><br>  Die Art des Wertes kann mit dem Operator <code>typeof</code> werden, es gibt jedoch eine wichtige Ausnahme: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 'number' typeof 'foo'; // 'string' typeof Symbol('bar'); // 'symbol' typeof 42n; // 'bigint' typeof true; // 'boolean' typeof undefined; // 'undefined' typeof null; // 'object' -   ,     typeof { x: 42 }; // 'object'</span></span></code> </pre> <br>  Wie Sie sehen k√∂nnen, gibt der Befehl <code>typeof null</code> <code>'object'</code> und nicht <code>'null'</code> , obwohl <code>null</code> einen eigenen Typ hat - <code>Null</code> .  Um den Grund f√ºr diese Art von Verhalten zu verstehen, ber√ºcksichtigen wir die Tatsache, dass die Menge aller JavaScript-Typen in zwei Gruppen unterteilt werden kann: <br><br><ul><li>  Objekte (d. H. Typ <code>Object</code> ). </li><li>  Primitive Werte (dh alle nicht objektiven Werte). </li></ul><br>  In Anbetracht dieses Wissens stellt sich heraus, dass <code>null</code> ‚Äûkein Objektwert‚Äú bedeutet, w√§hrend <code>undefined</code> ‚Äûkein Wert‚Äú bedeutet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e9/8e6/c97/0e98e6c97b3e87411146a60f1c67cf8e.png"></div><br>  <i><font color="#999999">Primitive Werte, Objekte, null und undefiniert</font></i> <br><br>  In Anlehnung an diese √úberlegungen im Geiste von Java hat Brendan Eich JavaScript so entworfen, dass der Operator <code>typeof</code> <code>'object'</code> f√ºr die Werte der Typen zur√ºckgibt, die sich in der vorherigen Abbildung rechts befinden.  Alle Objektwerte und <code>null</code> kommen hierher.  Aus diesem Grund ist der Ausdruck <code>typeof null === 'object'</code> wahr, obwohl die Sprachspezifikation einen separaten Typ <code>Null</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/23e/df7/0e2/23edf70e2101cc687a759653f150305d.png"></div><br>  <i><font color="#999999">Der Ausdruckstyp von v === 'Objekt' ist wahr</font></i> <br><br><h2>  <font color="#3AC1EF">Darstellung von Werten</font> </h2><br>  JavaScript-Engines sollten in der Lage sein, alle JavaScript-Werte im Speicher darzustellen.  Es ist jedoch wichtig zu beachten, dass Werttypen in JavaScript von der Darstellung durch JS-Engines im Speicher getrennt sind. <br><br>  Beispielsweise ist ein Wert von 42 in JavaScript vom Typ <code>number</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 'number'</span></span></code> </pre> <br>  Es gibt verschiedene M√∂glichkeiten, Ganzzahlen wie 42 im Speicher darzustellen: <br><div class="scrollable-table"><table><tbody><tr><td>  Einreichung <br></td><td>  Bits <br></td></tr><tr><td>  8 Bits zus√§tzlich zu zwei <br></td><td>  0010 1010 <br></td></tr><tr><td>  32 Bit, mit bis zu zwei <br></td><td>  0000 0000 0000 0000 0000 0000 0010 1010 <br></td></tr><tr><td>  Gepackte bin√§rcodierte Dezimalzahl (BCD) <br></td><td>  0100 0010 <br></td></tr><tr><td>  32 Bit, Gleitkommazahl IEEE-754 <br></td><td>  0 100 0010 0010 1000 0000 0000 0000 0000 <br></td></tr><tr><td>  64 Bit, IEEE-754-Gleitkommazahl <br></td><td>  0100 0000 0100 0101 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 <br></td></tr></tbody></table></div><br>  Nach dem ECMAScript-Standard sind Zahlen 64-Bit-Gleitkommawerte, sogenannte Gleitkommazahlen mit doppelter Genauigkeit (Float64).  Dies bedeutet jedoch nicht, dass JavaScript-Engines Zahlen immer in einer Float64-Ansicht speichern.  Das w√§re sehr, sehr ineffizient!  Engines k√∂nnen andere interne Darstellungen von Zahlen verwenden - sofern das Verhalten der Werte genau mit dem Verhalten der Float64-Zahlen √ºbereinstimmt. <br><br>  Wie sich herausstellte, sind die meisten Zahlen in echten JS-Anwendungen g√ºltige ECMAScript-Array- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Indizes</a> .  Das hei√üt - ganze Zahlen im Bereich von 0 bis 2 <sup>32</sup> -2. <br><br><pre> <code class="javascript hljs">array[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//      . array[42]; array[2**32-2]; //      .</span></span></code> </pre> <br>  JavaScript-Engines k√∂nnen das optimale Format f√ºr die Darstellung solcher Werte im Speicher ausw√§hlen.  Dies geschieht, um den Code f√ºr Array-Elemente mithilfe von Indizes zu optimieren.  Ein Prozessor, der Speicherzugriffsoperationen ausf√ºhrt, ben√∂tigt die Array-Indizes als Zahlen, die in einer Ansicht mit einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Addition von zwei</a> gespeichert sind.  Wenn wir stattdessen die Indizes von Arrays in Form von Float64-Werten darstellen, w√ºrde dies eine Verschwendung von Systemressourcen bedeuten, da die Engine dann Float64-Zahlen in ein Format mit zwei Additionen konvertieren m√ºsste und umgekehrt, wenn jemand auf ein Array-Element zugreift. <br><br>  Die Darstellung von 32-Bit-Zahlen mit der Hinzuf√ºgung von bis zu zwei ist nicht nur zur Optimierung der Arbeit mit Arrays n√ºtzlich.  Im Allgemeinen kann festgestellt werden, dass der Prozessor Ganzzahloperationen viel schneller ausf√ºhrt als Operationen, die Gleitkommawerte verwenden.  Deshalb ist im folgenden Beispiel der erste Zyklus ohne Probleme doppelt so schnell wie der zweite Zyklus. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; ++i) {  <span class="hljs-comment"><span class="hljs-comment">//  } for (let i = 0.1; i &lt; 1000.1; ++i) {  //  }</span></span></code> </pre> <br>  Gleiches gilt f√ºr Berechnungen mit mathematischen Operatoren. <br><br>  Beispielsweise h√§ngt die Leistung des Operators, den Rest der Division vom n√§chsten Codefragment zu √ºbernehmen, davon ab, welche Zahlen in die Berechnungen einbezogen werden. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> remainder = value % divisor; <span class="hljs-comment"><span class="hljs-comment">//  -  `value`  `divisor`   , //    .</span></span></code> </pre> <br>  Wenn beide Operanden durch ganze Zahlen dargestellt werden, kann der Prozessor das Ergebnis sehr effizient berechnen.  In V8 gibt es eine zus√§tzliche Optimierung f√ºr F√§lle, in denen der <code>divisor</code> Operand durch eine Zahl mit einer Zweierpotenz dargestellt wird.  F√ºr Werte, die als Gleitkommazahlen dargestellt werden, sind die Berechnungen viel komplizierter und dauern viel l√§nger. <br><br>  Da Ganzzahloperationen normalerweise viel schneller ausgef√ºhrt werden als Operationen mit Gleitkommawerten, scheint es, dass Engines einfach immer alle Ganzzahlen und alle Ergebnisse von Ganzzahloperationen in einem Format mit einer Addition von zwei speichern k√∂nnen.  Leider w√ºrde ein solcher Ansatz die ECMAScript-Spezifikation verletzen.  Wie bereits erw√§hnt, sieht der Standard die Darstellung von Zahlen im Float64-Format vor, und einige Operationen mit ganzen Zahlen k√∂nnen dazu f√ºhren, dass Ergebnisse in Form von Gleitkommazahlen angezeigt werden.  Es ist wichtig, dass JS-Engines in solchen Situationen korrekte Ergebnisse liefern. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Float64   53-  . //         . 2**53 === 2**53+1; // true // Float64   ,   -1 * 0   -0,  //           . -1*0 === -0; // true // Float64   Infinity,   , //     . 1/0 === Infinity; // true -1/0 === -Infinity; // true // Float64    NaN. 0/0 === NaN;</span></span></code> </pre> <br>  Obwohl im vorherigen Beispiel alle Zahlen auf der linken Seite der Ausdr√ºcke Ganzzahlen sind, sind alle Zahlen auf der rechten Seite der Ausdr√ºcke Gleitkommawerte.  Aus diesem Grund kann keine der vorherigen Operationen in einem 32-Bit-Format mit einer Addition von bis zu zwei korrekt ausgef√ºhrt werden.  JavaScript-Engines m√ºssen besonders darauf achten, dass Sie bei der Ausf√ºhrung von Ganzzahloperationen die richtigen Float64-Ergebnisse erhalten (obwohl sie ungew√∂hnlich aussehen k√∂nnen - wie im vorherigen Beispiel). <br><br>  Bei kleinen Ganzzahlen, die in den Bereich der 31-Bit-Darstellung vorzeichenbehafteter Ganzzahlen fallen, verwendet V8 eine spezielle Darstellung namens <code>Smi</code> .  Alles, was kein <code>Smi</code> Wert ist, wird als <code>HeapObject</code> Wert dargestellt. <code>HeapObject</code> ist die Adresse einer Entit√§t im Speicher.  F√ºr Zahlen, die nicht in den <code>Smi</code> Bereich fallen, haben wir eine spezielle Art von <code>HeapObject</code> - die sogenannte <code>HeapNumber</code> . <br><br><pre> <code class="javascript hljs">-<span class="hljs-literal"><span class="hljs-literal">Infinity</span></span> <span class="hljs-comment"><span class="hljs-comment">// HeapNumber -(2**30)-1 // HeapNumber  -(2**30) // Smi       -42 // Smi        -0 // HeapNumber         0 // Smi       4.2 // HeapNumber        42 // Smi   2**30-1 // Smi     2**30 // HeapNumber  Infinity // HeapNumber       NaN // HeapNumber</span></span></code> </pre> <br>  Wie Sie im vorherigen Beispiel sehen k√∂nnen, werden einige JS-Nummern als <code>Smi</code> und andere als <code>HeapNumber</code> .  Die V8-Engine ist hinsichtlich der Verarbeitung von <code>Smi</code> Nummern optimiert.  Tatsache ist, dass kleine Ganzzahlen in echten JS-Programmen sehr h√§ufig sind.  Bei der Arbeit mit <code>Smi</code> Werten ist es nicht erforderlich, Speicher f√ºr einzelne Entit√§ten zuzuweisen.  Ihre Verwendung erm√∂glicht es Ihnen au√üerdem, schnelle Operationen mit ganzen Zahlen durchzuf√ºhren. <br><br><h2>  <font color="#3AC1EF">Vergleich von Smi, HeapNumber und MutableHeapNumber</font> </h2><br>  Lassen Sie uns dar√ºber sprechen, wie die interne Struktur dieser Mechanismen aussieht.  Angenommen, wir haben das folgende Objekt: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> o = {  <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-comment"><span class="hljs-comment">// Smi  y: 4.2, // HeapNumber };</span></span></code> </pre> <br>  Der Wert 42 der Eigenschaft des Objekts <code>x</code> wird als <code>Smi</code> codiert.  Dies bedeutet, dass es im Objekt selbst gespeichert werden kann.  Um den Wert 4.2 zu speichern, m√ºssen Sie dagegen eine separate Entit√§t erstellen.  Im Objekt befindet sich eine Verkn√ºpfung zu dieser Entit√§t. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/116/718/f34/116718f3426bccd613dd35dc95be9739.png"></div><br>  <i><font color="#999999">Speicherung verschiedener Werte</font></i> <br><br>  Angenommen, wir f√ºhren den folgenden JavaScript-Code aus: <br><br><pre> <code class="javascript hljs">ox += <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ox   52 oy += 1; // oy   5.2</span></span></code> </pre> <br>  In diesem Fall kann der Wert der Eigenschaft <code>x</code> an ihrem Speicherort aktualisiert werden.  Tatsache ist, dass der neue Wert von <code>x</code> 52 ist und diese Zahl in den Bereich von <code>Smi</code> f√§llt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d8/400/d42/4d8400d42a2046c9727d4ff76ad2b483.png"></div><br>  <i><font color="#999999">Der neue Wert der Eigenschaft x wird dort gespeichert, wo der vorherige Wert gespeichert wurde.</font></i> <br><br>  Der neue Wert von <code>y</code> , 5.2, passt jedoch nicht in den Bereich von <code>Smi</code> und unterscheidet sich au√üerdem vom vorherigen Wert von y - 4.2.  Infolgedessen muss V8 Speicher f√ºr die neue <code>HeapNumber</code> Entit√§t <code>HeapNumber</code> und bereits vom Objekt aus darauf verweisen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ba/ecf/095/9baecf0951766c6e2781b552593b6b94.png"></div><br>  <i><font color="#999999">Neue Entit√§t HeapNumber zum Speichern des neuen y-Werts</font></i> <br><br>  <code>HeapNumber</code> Entit√§ten sind unver√§nderlich.  Auf diese Weise k√∂nnen Sie einige Optimierungen implementieren.  Angenommen, wir m√∂chten die Eigenschaft des Objekts <code>x</code> Wert der Eigenschaft <code>y</code> : <br><br><pre> <code class="javascript hljs">ox = oy; <span class="hljs-comment"><span class="hljs-comment">// ox   5.2</span></span></code> </pre> <br>  Wenn Sie diesen Vorgang ausf√ºhren, k√∂nnen wir einfach auf dieselbe <code>HeapNumber</code> Entit√§t verweisen und keinen zus√§tzlichen Speicher zuweisen, um denselben Wert zu speichern. <br><br>  Einer der Nachteile der Immunit√§t von HeapNuber-Entit√§ten besteht darin, dass die h√§ufige Aktualisierung von Feldern mit Werten au√üerhalb des <code>Smi</code> Bereichs langsam ist.  Dies wird im folgenden Beispiel demonstriert: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   `HeapNumber`. const o = { x: 0.1 }; for (let i = 0; i &lt; 5; ++i) {  //    `HeapNumber`.  ox += 1; }</span></span></code> </pre> <br>  Bei der Verarbeitung der ersten Zeile wird eine Instanz von <code>HeapNumber</code> erstellt, deren Anfangswert 0,1 betr√§gt.  Im Hauptteil des Zyklus √§ndert sich dieser Wert zu 1.1, 2.1, 3.1, 4.1 und schlie√ülich zu 5.1.  Infolgedessen werden beim Ausf√ºhren dieses Codes 6 Instanzen von <code>HeapNumber</code> , von denen f√ºnf nach Abschluss der Schleife <code>HeapNumber</code> unterzogen werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d10/7e2/8f1/d107e28f181bf1eaf1fd57765bdfe49f.png"></div><br>  <i><font color="#999999">HeapNumber-Entit√§ten</font></i> <br><br>  Um dieses Problem zu vermeiden, verf√ºgt V8 √ºber eine Optimierung, bei der numerische Felder aktualisiert werden, deren Werte nicht an denselben Stellen in den <code>Smi</code> Bereich passen, an denen sie bereits gespeichert sind.  Wenn in einem numerischen Feld Werte <code>Smi</code> werden, f√ºr die die <code>Smi</code> Entit√§t nicht zum Speichern geeignet ist, markiert V8 dieses Feld in Form eines Objekts als <code>Double</code> und <code>MutableHeapNumber</code> der <code>MutableHeapNumber</code> Entit√§t Speicher zu, in der der im Float64-Format dargestellte reale Wert gespeichert wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a17/c42/466/a17c42466cde98778836809e09df4da6.png"></div><br>  <i><font color="#999999">Verwenden von MutableHeapNumber-Entit√§ten</font></i> <br><br>  Infolgedessen muss V8 nach √Ñnderung des <code>HeapNumber</code> keinen Speicher mehr f√ºr die neue <code>HeapNumber</code> Entit√§t <code>HeapNumber</code> .  Schreiben Sie stattdessen einfach den neuen Wert in eine vorhandene <code>MutableHeapNumber</code> Entit√§t. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c86/3bd/d1c/c863bdd1c81213b080d86bed079e9e5f.png"></div><br>  <i><font color="#999999">Schreiben eines neuen Werts in MutableHeapNumber</font></i> <br><br>  Dieser Ansatz hat jedoch seine Nachteile.  Da sich die Werte von <code>MutableHeapNumber</code> √§ndern k√∂nnen, ist es wichtig sicherzustellen, dass das System so funktioniert, dass sich diese Werte wie in der Sprachspezifikation angegeben verhalten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/176/be3/8ca/176be38cad03b4e4ab2881d7a9b67bfd.png"></div><br>  <i><font color="#999999">Nachteile von MutableHeapNumber</font></i> <br><br>  Wenn Sie beispielsweise den Wert von <code>ox</code> anderen Variablen <code>y</code> zuweisen, m√ºssen Sie sicherstellen, dass sich der Wert von <code>y</code> bei einer nachfolgenden √Ñnderung von <code>ox</code> nicht √§ndert.  Das w√§re ein Versto√ü gegen die JavaScript-Spezifikation!  Daher muss beim Zugriff auf <code>ox</code> die Nummer auf den √ºblichen <code>HeapNumber</code> Wert neu <code>HeapNumber</code> werden, bevor sie <code>y</code> zugewiesen wird. <br><br>  Im Fall von Gleitkommazahlen f√ºhrt V8 die obigen Packoperationen unter Verwendung seiner internen Mechanismen aus.  Bei kleinen Ganzzahlen w√§re die Verwendung von <code>MutableHeapNumber</code> jedoch Zeitverschwendung, da <code>Smi</code> eine effizientere Methode zur Darstellung solcher Zahlen darstellt. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// ""  `x`    object.x += 1; //   `x`  </span></span></code> </pre> <br>  Um eine ineffiziente Nutzung der Systemressourcen zu vermeiden, m√ºssen wir f√ºr die Arbeit mit kleinen Ganzzahlen lediglich die entsprechenden Felder in Form von Objekten als <code>Smi</code> markieren.  Infolgedessen k√∂nnen die Werte dieser Felder direkt innerhalb der Objekte aktualisiert werden, sofern sie dem <code>Smi</code> Bereich entsprechen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b6a/d23/b96/b6ad23b9635e31d8f695d7170b8d3d7c.png"></div><br>  <i><font color="#999999">Arbeiten Sie mit ganzen Zahlen, deren Werte im Bereich von Smi liegen</font></i> <br><br>  Fortsetzung folgt‚Ä¶ <br><br>  <b>Liebe Leser!</b>  Haben Sie Probleme mit der JavaScript-Leistung festgestellt, die durch Funktionen der JS-Engine verursacht wurden? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467247/">https://habr.com/ru/post/de467247/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467231/index.html">Einf√ºhrung Melden Sie sich mit Apple in Ihrer iOS-App an</a></li>
<li><a href="../de467237/index.html">Erh√∂hen Sie Ihren DNS-over-HTTPS-Server</a></li>
<li><a href="../de467239/index.html">Der Unterschied zwischen Data Scientist und einem Teenager in einem Sportwagen</a></li>
<li><a href="../de467241/index.html">ROS LKW Wagen. Teil 4. Erstellen einer Robotersimulation mit den Editoren rviz und pavillon</a></li>
<li><a href="../de467245/index.html">Dmitry Matskevich, Dbrain: √ºber Unternehmertum als geistige Behinderung, KI und emotionale Sicherheit</a></li>
<li><a href="../de467249/index.html">Eine Geschichte √ºber V8, React und einen Leistungsabfall. Teil 2</a></li>
<li><a href="../de467251/index.html">Geiseln COBOL und Math. Teil 1</a></li>
<li><a href="../de467253/index.html">Geiseln COBOL und Math. Teil 2</a></li>
<li><a href="../de467255/index.html">Drei h√§ufige Sicherheitsfehler, √ºber die jeder Reaktionsentwickler Bescheid wissen sollte</a></li>
<li><a href="../de467257/index.html">Lagern Sie nicht alle Eier gleichzeitig in einem Korb</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>