<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¾â€ğŸ¤â€ğŸ‘¨ğŸ» ğŸ‘¨â€ğŸ‘¨â€ğŸ‘¦â€ğŸ‘¦ ğŸš¨ Est-il possible en 1C de ne pas observer la technologie des composants externes? Ou Comment fÃ©liciter des collÃ¨gues utilisant 1C? ğŸ‘¨â€ğŸ”¬ ğŸ§˜ğŸ¾ ğŸ‘©ğŸ¼â€ğŸš€</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y avait une idÃ©e ici pour fÃ©liciter notre chef comptable d'une maniÃ¨re plus ou moins originale, par exemple, avec l'aide de son programme 1C prÃ©fÃ©r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Est-il possible en 1C de ne pas observer la technologie des composants externes? Ou Comment fÃ©liciter des collÃ¨gues utilisant 1C?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466713/">  Il y avait une idÃ©e ici pour fÃ©liciter notre chef comptable d'une maniÃ¨re plus ou moins originale, par exemple, avec l'aide de son programme 1C prÃ©fÃ©rÃ©?  Mais comment? <br><br>  AprÃ¨s rÃ©flexion, l'idÃ©e est venue d'utiliser pour les fÃ©licitations d'arriÃ¨re-plan l'image d'arriÃ¨re-plan dans la zone client des formulaires conventionnels pour les configurations sur 1C77-1C82 ou dans une fenÃªtre externe pour les formulaires gÃ©rÃ©s 1C82 et dans tous les cas pour 1C83.  Sur celui-ci, affichez le message souhaitÃ© et donnez des liens vers la vidÃ©o de fÃ©licitations, comme indiquÃ© sur la figure. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a77/0bd/055/a770bd055ca43fdb5ad8d6f1f124253b.jpg" alt="FÃ©licitation en 1C"><br><a name="habracut"></a><br><h2>  PremiÃ¨re partie - RÃ©sultat </h2><br>  De toute Ã©vidence, cette idÃ©e n'est pas nouvelle.  Ainsi, en 2011, une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">solution similaire a</a> Ã©tÃ© proposÃ©e basÃ©e sur <b>FormEx.dll, par <i>Aleksey Fedorov alias ALF</i></b> .  Et des questions sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">maniÃ¨re d'y parvenir</a> ont Ã©tÃ© posÃ©es en 2008. <br><br>  Ã€ un moment donnÃ©, nous avons Ã©galement utilisÃ© ce composant pour charger l'image d'arriÃ¨re-plan dans 1C77.  Mais le chargement de gros fichiers bmp (et d'autres ne pouvaient pas Ãªtre utilisÃ©s) Ã©tait lent (Ã  cause de cela, de petites images posÃ©es avec des tuiles ont Ã©tÃ© utilisÃ©es), donc il y avait un dÃ©sir d'Ã©crire votre propre composant externe (VK), qui ne tÃ©lÃ©chargera que les images nÃ©cessaires et rien de plus, sauf si quoi d'autre pour Ãªtre un terrain d'essai pour des expÃ©riences. <br><br>  Un tel composant a Ã©tÃ© Ã©crit (Ã©galement, uniquement pour les fichiers bmp, en utilisant, si nÃ©cessaire, le pavage).  La fonction <b>WinAPI LoadImage () y a</b> Ã©tÃ© utilisÃ©e.  Cette DLL n'a pas Ã©tÃ© en conflit avec FormEx.dll, elle Ã©tait simple, assez rapide et servie pendant longtemps. <br><br>  Tout cela Ã©tait merveilleux, mais il Ã©tait temps d'Ã©tendre ses capacitÃ©s, et ici une approche diffÃ©rente Ã©tait nÃ©cessaire. <br><br>  Dans cet article, nous n'abordons pas les problÃ¨mes de crÃ©ation de fichiers multimÃ©dias.  Ce n'est pas notre spÃ©cialitÃ©.  Nous nous limitons uniquement Ã  certaines nuances de programmation de composants externes pour 1C. <br><br><h3>  1C77 </h3><br>  Ã‰tant donnÃ© que les versions de la plate-forme 1C peuvent Ãªtre diffÃ©rentes, il peut y avoir plusieurs solutions.  Dans notre cas, il s'agissait de configurations sur 1C77 (Fig.1). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b4/611/4ad/8b46114ad1ae83e57667cc4bb84aae7e.jpg" alt="Fig. 1. Image de fÃ©licitations dans la configuration de test sur 1C77"><br>  Fig.  1. Image de fÃ©licitations dans la configuration de test sur 1C77. <br><br>  La vidÃ©o ici, bien que la sienne, mais l'idÃ©e de sa crÃ©ation est glanÃ©e auprÃ¨s d' <b><i>Anna Shiyanova, sous le surnom de "Cas spÃ©cial"</i></b> .  Cette fille a du talent, elle peut Ãªtre imitÃ©e, mais il n'est guÃ¨re possible de rÃ©pÃ©ter complÃ¨tement le style.  Dans ce cas, je voulais juste au moins un Ã©lÃ©ment de crÃ©ativitÃ©. <br><br>  Si l'un des collÃ¨gues est dÃ©jÃ  fatiguÃ© de regarder les fÃ©licitations des autres, il peut surcharger l'image avec Â« <b>Alt + I</b> Â» (Fig. 2-3). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/01a/8c1/200/01a8c120008b72dd648b7c8697298d65.jpg" alt="Fig. 2. SÃ©lection d'une autre image d'arriÃ¨re-plan dans le menu &quot;Fichier / SÃ©lectionner l'arriÃ¨re-plan&quot; ou par &quot;Alt + I&quot;"><br>  Fig.  2. SÃ©lection d'une image d'arriÃ¨re-plan diffÃ©rente dans le menu "Fichier / SÃ©lectionner l'arriÃ¨re-plan" ou par "Alt + I". <br><br>  Et en mÃªme temps voir les informations sur le module utilisÃ© par " <b>Alt + L</b> " (Fig. 3). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/499/499/f23/499499f23ec33734bd6a5068f5d493b8.jpg" alt="Fig. 3. Une image d'arriÃ¨re-plan surchargÃ©e avec des informations sur le programme (&quot;Aide / Ã€ propos du module LionExt32.dll&quot; ou &quot;Alt + L&quot;)"><br>  Fig.  3. Image d'arriÃ¨re-plan surchargÃ©e avec des informations sur le programme (Â«Aide / Ã€ propos du module LionExt32.dllÂ» ou Â«Alt + LÂ»). <br><br><h3>  Formes conventionnelles 1C82 </h3><br>  Naturellement, la majoritÃ© est dÃ©sormais orientÃ©e vers le G8 (1C8x).  Cependant, travailler avec l'image d'arriÃ¨re-plan dans 1C n'est possible que sur les formulaires ordinaires dans la version 8.2 et moins, et si vous n'utilisez aucun traitement qui dÃ©marre en mode Â«bureauÂ», qui chevauchera simplement complÃ¨tement notre arriÃ¨re-plan (Fig. 4). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/390/123/bfd/390123bfd2ef88bfbc108dbe44c70835.jpg" alt="Fig. 4. Image de fÃ©licitations dans la configuration de test sur les formulaires ordinaires 1C82"><br>  Fig.  4. Image de fÃ©licitations dans la configuration de test sur les formulaires habituels 1C82. <br><br>  Notez que les liens vers la Fig.  4 n'indiquez pas notre vidÃ©o.  Ils sont montrÃ©s juste pour le test. <br><br>  Dans les formes ordinaires, 1C82 ne fonctionne plus de maniÃ¨re standard pour accÃ©der au menu, car il n'y est pas systÃ©mique, comme dans le "sept", mais "propre" (bien que le systÃ¨me puisse Ãªtre crÃ©Ã©, mais pourquoi avons-nous besoin de deux menus principaux?).  Cependant, des raccourcis clavier peuvent Ãªtre utilisÃ©s.  De la mÃªme maniÃ¨re, Â«Alt + IÂ», dans notre composant, nous invoquons une boÃ®te de dialogue, comme dans la Fig. 2 et chargeons un autre arriÃ¨re-plan (Fig. 5). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c3f/535/deb/c3f535deb522e2ae7ad8937ce31b1188.jpg" alt="Fig. 5. Image d'arriÃ¨re-plan surchargÃ©e sous des formes 1C82 Â«Ã©paissesÂ»"><br>  Fig.  5. Image d'arriÃ¨re-plan surchargÃ©e sous des formes 1C82 Â«Ã©paissesÂ». <br><br>  De mÃªme, vous pouvez obtenir des informations sur le module en appuyant sur la touche "Alt + L", comme dans la fig.  3. <br><br><h3>  Formulaires gÃ©rÃ©s 1C82 </h3><br>  Pour les formulaires gÃ©rÃ©s dans 1C82, vous pouvez toujours trouver la fenÃªtre dont nous avons besoin au septiÃ¨me niveau d'imbrication, comme " <b>V8FormElement</b> " et dessiner dessus, mais en quelque sorte ce n'est pas intÃ©ressant. <br><br>  Pour nous, il rÃ©sulte de ces considÃ©rations qu'il est plus facile de crÃ©er une fenÃªtre externe avec un message de fÃ©licitations (Fig. 6) que de traiter chaque cas individuel.  La fenÃªtre elle-mÃªme peut Ãªtre fermÃ©e, ou plutÃ´t minimisÃ©e par " <b>Esc</b> ", " <b>Ctrl + F4</b> ", " <b>Alt + F4</b> " ou en cliquant sur la " <b>croix</b> ". <br><br><img src="https://habrastorage.org/getpro/habr/post_images/790/cd9/79d/790cd979df8a4d97ff5488c50fa4bd6c.jpg" alt="Fig. 6. Image de fÃ©licitations dans une configuration de test sur les formulaires gÃ©rÃ©s 1C82"><br>  Fig.  6. Image de fÃ©licitations dans une configuration de test sur les formulaires gÃ©rÃ©s 1C82. <br><br>  De plus, la fenÃªtre minimisÃ©e (Fig. 7) peut Ã  nouveau Ãªtre agrandie. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/66c/1a7/c7f/66c1a7c7f725404604318cdcde3a9915.jpg" alt="Fig. 7. L'image minimisÃ©e de la fenÃªtre externe sur les formulaires gÃ©rÃ©s 1C82"><br>  Fig.  7. Une image rÃ©duite de la fenÃªtre externe sur les formulaires gÃ©rÃ©s 1C82. <br><br>  Les dimensions et la position relative de la fenÃªtre extÃ©rieure peuvent Ãªtre modifiÃ©es, tout est comme d'habitude ici (voir des images agrandies de fenÃªtres extÃ©rieures sur la Fig. 6 et la Fig. 10).  Notez que les raccourcis clavier ne fonctionnent que si la fenÃªtre externe est active. <br><br><h3>  Formes conventionnelles 1C83 </h3><br>  Dans 1C83, il n'y a plus de fenÃªtres enfants du tout, ce qui peut servir de critÃ¨re pour la version 1C dans notre DLL.  De plus, les formulaires Â«Ã©paisÂ» sont une fenÃªtre de cadre (Fig. 8), et les formulaires gÃ©rÃ©s sont sans cadre (Fig. 9).  Autrement dit, tout ce qui n'est pas un cadre peut Ãªtre redessinÃ©.  Un cadre peut Ã©galement Ãªtre redessinÃ©, mais uniquement en tant qu'Ã©lÃ©ment systÃ¨me. <br><div class="scrollable-table"><table><tbody><tr><th><img src="https://habrastorage.org/getpro/habr/post_images/f9c/35e/0da/f9c35e0da01025306525d14f700d22a4.jpg" alt="Fig. 8. FenÃªtre de cadre sous formes Â«Ã©paissesÂ» 1C83"></th><th><img src="https://habrastorage.org/getpro/habr/post_images/962/5f9/e7c/9625f9e7c28fed4c9226ee73d8126ed8.jpg" alt="Fig. 9. FenÃªtre sans cadre dans les formulaires gÃ©rÃ©s 1C83"></th></tr><tr><th>  Fig.  8. FenÃªtre de cadre en formes Â«Ã©paissesÂ» 1C83. </th><th>  Fig.  9. FenÃªtre sans cadre sous formes contrÃ´lÃ©es 1C83. </th></tr></tbody></table></div>  Ici, nous avons crÃ©Ã© une fenÃªtre de test Ã  l'aide d'une bibliothÃ¨que dynamique et l'avons subordonnÃ©e Ã  la fenÃªtre principale 1C.  La diffÃ©rence de comportement est visible dans les figures. <br><br><h3>  Formulaires gÃ©rÃ©s 1C83 </h3><br>  Dans le cas de 1C83, comme dans les formulaires gÃ©rÃ©s 1C82, nous tirerons nos fÃ©licitations non pas sur le fond, mais dans une fenÃªtre distincte, dont le prototype est illustrÃ© sur la Fig.  8-9.  Par consÃ©quent, le composant souhaitÃ© ( <b>LionExt32.dll</b> ou <b>LionExt64.dll</b> ) donnera le rÃ©sultat suivant (Fig. 10-12). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/104/cf1/f10/104cf1f10c6ae652d24edea7082c7e6c.jpg" alt="Fig. 10. L'image d'arriÃ¨re-plan dans la fenÃªtre externe pour les formulaires conventionnels 1C83"><br>  Fig.  10. L'image d'arriÃ¨re-plan dans la fenÃªtre externe pour les formulaires conventionnels 1C83. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/56a/03f/fc7/56a03ffc7fe1f2bfee6358ecb81af9fa.jpg" alt="Fig. 11. Image d'arriÃ¨re-plan dans la fenÃªtre externe des formulaires gÃ©rÃ©s 1C83, version 14, version 64 bits"><br>  Fig.  11. L'image d'arriÃ¨re-plan dans la fenÃªtre externe des formulaires gÃ©rÃ©s 1C83, version 14, version 64 bits. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/05e/12f/71c/05e12f71ccfb9212b96bc3db92630869.jpg" alt="Fig. 12. Image d'arriÃ¨re-plan dans la fenÃªtre externe des formulaires gÃ©rÃ©s 1C83, version 15, version 64 bits"><br>  Fig.  12. L'image d'arriÃ¨re-plan dans la fenÃªtre externe des formulaires gÃ©rÃ©s 1C83, version 15, version 64 bits. <br><br><h3>  Constatations prÃ©liminaires </h3><br>  Cette composante Ã©tait effectivement utilisÃ©e en pratique (Fig.1), le chef comptable Ã©tait satisfait, tout s'est merveilleusement bien passÃ©.  En cours de route, il s'est avÃ©rÃ© que les utilisateurs aiment choisir leurs propres images d'arriÃ¨re-plan, dans ce cas, pour travailler sur les "sept".  Pour le G8, notre composant est adaptÃ© avec une rÃ©serve pour l'avenir, alors qu'il devrait Ãªtre considÃ©rÃ© comme une version de dÃ©monstration. <br><br>  L'intÃ©rÃªt ici Ã©tait que <b><i>ce composant ne nÃ©cessitait pas la conformitÃ© avec la technologie de crÃ©ation de composants externes Ã  partir de 1C</i></b> .  Peut-Ãªtre que d'autres idÃ©es surgiront pour Ã©tendre ses capacitÃ©s.  Par exemple, pour les configurations entiÃ¨rement prises en charge, vous ne souhaitez pas apporter de modifications au code 1C sans besoin particulier.  Dans ce cas, on pourrait offrir l'option de chargement externe d'une DLL arbitraire dans l'espace d'adressage 1C.  Mais c'est le sujet d'un autre article. <br><br>  Parmi les innovations techniques, un verrou a Ã©tÃ© utilisÃ© pour dÃ©charger notre composant avec la plateforme 1C (car il n'est pas conforme au format VK).  De plus, une autre astuce a permis d'affecter un <b>menu local</b> Ã  la fenÃªtre enfant, puisque le systÃ¨me d'exploitation Windows bloque la crÃ©ation d'un tel menu pour les fenÃªtres subordonnÃ©es.  Par consÃ©quent, vous ne verrez nulle part les menus locaux dans la mÃªme interface <b>MDI</b> (Multi Document Interface).  Il est remplacÃ© par des panneaux de commandes, des barres d'outils et un menu contextuel.  Il y a encore un moment pour mettre Ã  jour les fenÃªtres.  Il arrive parfois que ni <b>UpdateWindow ()</b> ni <b>InvalidateRect () ne</b> fonctionnent correctement.  Mais quelques fonctions rÃ©ussissent dans ce cas: <br><br><pre><code class="cpp hljs">ShowWindow(hWnd, SW_HIDE); ShowWindow(hWnd, SW_SHOW);</code> </pre> <br>  Il convient Ã©galement de noter que notre composant peut entrer en conflit avec d'autres, par exemple, avec FormEx.dll pour 1C77.  Dans ce cas, il doit Ãªtre chargÃ© en dernier. <br><br>  Par ailleurs, il est Ã  noter que si vous crÃ©ez une configuration dans la version 1C-8.3.14 et supÃ©rieure, le composant n'est pas chargÃ© de maniÃ¨re rÃ©guliÃ¨re.  Mais si la base de donnÃ©es a Ã©tÃ© crÃ©Ã©e dans une version antÃ©rieure de 1C et s'ouvre dans les derniÃ¨res versions, il n'y a aucun problÃ¨me de chargement de notre VK.  Cela suggÃ¨re une fois de plus la nÃ©cessitÃ© de crÃ©er un chargeur de dÃ©marrage externe. <br><br>  Ce projet utilise le sous-systÃ¨me <b>WinAPI GDI +</b> .  En l'utilisant, vous pouvez afficher des images de diffÃ©rents formats: <b>bmp, jpg, gif, png, tif</b> et autres.  Dans le mÃªme ordre, le composant tente de charger le premier fichier <b>Main. *</b> Disponible Ã  partir du rÃ©pertoire <b>Pics</b> local dans la configuration actuelle.  Si aucun de ces fichiers n'est trouvÃ©, une simple image d'arriÃ¨re-plan provenant des ressources des composants est utilisÃ©e.  Dans la fig.  La figure 13 montre cette image d'arriÃ¨re-plan pour les formes habituelles de 64 bits 1C83, version 15. Pour une modification, la fenÃªtre externe de l'argot a Ã©tÃ© agrandie et une autre image du fichier <b>Main1.png</b> , qui a Ã©tÃ© Â«mosaÃ¯queÂ», a Ã©tÃ© ajoutÃ©e Ã  son arriÃ¨re-plan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/71c/80a/48a/71c80a48a18236e495a1d62b0f316e11.jpg" alt="Fig. 13. Le fond d'Ã©cran par dÃ©faut pour les formulaires rÃ©guliers 64 bits 1C83, version 15"><br>  Fig.  13. L'image d'arriÃ¨re-plan par dÃ©faut pour les formes habituelles de 64 bits 1C83, version 15. De plus, une autre image du fichier Main1.png, posÃ©e en "mosaÃ¯que", a Ã©tÃ© ajoutÃ©e. <br><br>  Il n'y a aucune diffÃ©rence dans le fonctionnement du composant dans diffÃ©rents modes de bits. <br><br>  On peut Ã©galement noter que notre composant sous-classe la fenÃªtre principale 1C et son client MDI, le cas Ã©chÃ©ant.  Cela, apparemment, sert de source de conflit avec FormEx.dll lors de son dernier chargement (en 1C77). <br><br><h2>  DeuxiÃ¨me partie - Technique </h2><br>  Le projet lui-mÃªme peut Ãªtre trouvÃ© sur les liens suivants: <br><br><ul><li>  <a href="">Tester la configuration sur 1C77</a> </li><li>  <a href="">Configuration de test sur 1C82</a> </li><li>  <a href="">Configuration de test sur 1C83</a> </li><li>  <a href="">Projet sur MS VS C ++, v.</a>  <a href="">13</a> </li></ul><br>  Un projet <b>C ++</b> peut Ãªtre facilement adaptÃ© pour la version <b>10</b> si la chaÃ®ne " <b>v120</b> " est remplacÃ©e par " <b>v100</b> " et " <b>ToolsVersion =" 12.0 "</b> " par " <b>ToolsVersion =" 4.0 "</b> dans les fichiers de configuration. <br><br>  Le code des versions <b>32</b> bits et <b>64</b> bits de <b>1C est</b> le mÃªme et peut Ãªtre compilÃ© en mÃªme temps. <br><br>  La version 1C77 est dÃ©terminÃ©e dans le composant externe par le descripteur de fonction GetMenu <b>()</b> non nul et la version 1C83, par l'absence de fenÃªtres enfants dans la fenÃªtre principale, dont le <b>descripteur</b> est dÃ©terminÃ© par la fonction <b>GetForegroundWindow ()</b> . <br><br><h3>  Ã€ propos de la technologie de crÃ©ation de composants externes pour 1C </h3><br>  Sur les disques ITS de la sociÃ©tÃ© 1C, et sur Internet, on peut facilement trouver des informations sur la crÃ©ation de VC et les modÃ¨les correspondants dans diffÃ©rents langages de programmation.  Cependant, au temps du 1C77, ces schÃ©mas satisfaisaient Â«pas seulement tout le mondeÂ». <br><br>  Si vous regardez certains composants largement utilisÃ©s, en particulier pour 1C77, vous verrez que leurs auteurs ont souvent utilisÃ© des mÃ©thodes de programmation spÃ©ciales pour Ã©tendre les capacitÃ©s de leurs conceptions. <br><br>  Peut-Ãªtre que l'un des premiers composants externes de ce type Ã©tait <b><i>"RAINBOW ADDIN 2000 for 1C: Enterprise 7.7"</i></b> .  Le plus important ici Ã©tait peut-Ãªtre une pÃ©nÃ©tration plus profonde dans les entrailles du Â«septÂ» que la technologie officielle VK ne le permettait, mÃªme si elle suivait le format VK.  Cet objectif a Ã©tÃ© atteint grÃ¢ce aux en-tÃªtes (fichiers * .h) reÃ§us, probablement non standard, des fichiers de bibliothÃ¨que 1C77 utilisÃ©s dans d'autres projets largement connus. <br><br>  En effet, si des fonctions 1C telles que <b>LoadExternalComponent ()</b> et <b>ConnectExternalComponent ()</b> vous permettent d'incorporer <b>des DLL externes</b> dans votre propre espace d'adressage (tout d'abord, qui satisfont le format de la technologie VK), alors pourquoi les programmes utilisateur ne succombent-ils pas Ã  la tentation et tentent d'accÃ©der Ã  d'autres cachÃ©s de eux, les procÃ©dures et autres objets de la plate-forme cible?  Cette approche a Ã©tÃ© dÃ©montrÃ©e avec succÃ¨s par le composant <b>Rainbow.dll</b> . <br><br>  Plus tard, un mÃ©canisme similaire a Ã©tÃ© adoptÃ© par d'autres auteurs du composant 1C version 7.7.  Le composant pour la "sept" <b>1C ++. Dll</b> et son, pour ainsi dire, un cas spÃ©cial de <b>FormEx.dll</b> sont particuliÃ¨rement <b>remarquables</b> . <br><br>  Mais l'approche non triviale de la conception de composants externes pour 1C77 ne s'arrÃªte pas lÃ .  Apparemment, quelqu'un aurait dÃ» dire: Â«Pourquoi avons-nous besoin d'un forgeron?  Nous n'avons pas besoin d'un forgeron! "  Ici, par Â«forgeronÂ», nous entendons la technologie COM de MicroSoft, qui, dans un sens, a Ã©tÃ© suivie par la technologie VK pour les Â«septÂ».  Non, vraiment, pourquoi avons-nous besoin d'un registre si nous tÃ©lÃ©chargeons notre VK directement?  Cela peut Ãªtre logique pour les navigateurs Web qui fonctionnent avec Internet, mais pour un fonctionnement local, l'utilisation du registre est clairement redondante.  Ã€ tout le moins, cela ne devrait pas Ãªtre une condition prÃ©alable.  De plus, pour Ã©diter le registre, vous avez besoin de droits administratifs. <br><br>  Notez que 1C aimait beaucoup cette technologie (au moins jusqu'au portage de 1C vers Linux).  Nous la traitons plutÃ´t cool.  COM est pratique pour utiliser le composant ActiveX et cela est naturel, car ces derniers ont Ã©tÃ© initialement dÃ©veloppÃ©s pour Internet. <br><br>  Cependant, dans les derniÃ¨res versions, 1C a ajoutÃ© la possibilitÃ© d'utiliser la technologie <b>API native</b> , ce qui Ã©limine le besoin d'un registre.  En principe, c'est ce dont nous avons besoin, sauf que cette technologie n'est pas applicable dans les Â«septÂ» et qu'elle est, pour certains, toujours d'actualitÃ©. <br><br>  Mais parfois, des tÃ¢ches relativement simples surviennent lorsque vous ne souhaitez pas utiliser un tas de code passe-partout pour VK et qu'il est conseillÃ© de travailler avec 1C uniquement du cÃ´tÃ© du composant externe.  Comme, disons, dans notre cas, la dÃ©monstration d'une image de fÃ©licitations dans l'espace client ou, si nÃ©cessaire, dans une fenÃªtre sÃ©parÃ©e, la configuration 1C. <br><br>  En d'autres termes, si nous n'allons pas Ã©changer directement des donnÃ©es entre 1C et VK, nous serons trÃ¨s satisfaits d'une version plus simple et plus universelle du composant externe pour 1C.  Ici, la simplicitÃ© sera obtenue en raison de l'absence de code passe-partout. <br><br><h3>  Technologie alternative pour crÃ©er VK pour 1C </h3><br>  Ã‰tant donnÃ© que VK pour 1C est un cas particulier de <b>serveur COM</b> (avant la technologie <b>Native API</b> ), certains dÃ©veloppeurs VK ont dit: Â«COM - non!Â».  L'activitÃ© dans ce sens d' <b><i>Alexandre Orefkov</i></b> est particuliÃ¨rement notable.  Ses composants Â« <b>1sqlite.dll</b> Â», Â« <b>TurboMD.dll</b> Â» et Ã©ventuellement d'autres n'utilisent pas COM Ã  partir du mot Â«complÃ¨tementÂ».  Le composant <b>Yoksel</b> (" <b>SpreadSheet.dll</b> ") se dÃ©veloppe Ã©galement le long de ce chemin. <br><br>  Mais comment alors le chargeur VK de 1C77 charge-t-il ces composants?  AprÃ¨s tout, ils n'essaient mÃªme pas d'imiter une sorte de COM lÃ -bas.  En effet, si nous essayons de glisser franchement une DLL standard gÃ©nÃ©rÃ©e par, disons, l'assistant <b>MS VC ++</b> dans la fonction <b>LoadExternalComponent ()</b> , alors nous aurons une erreur. <br><br>  Dans le "sept", nous obtenons un message comme: <blockquote>  Une erreur s'est produite lors de la crÃ©ation d'un objet Ã  partir du composant &lt;Chemin d'accÃ¨s complet \ Nom du composant&gt; .dll (CLSID est manquant) </blockquote><br>  Dans le client "Ã©pais" 32 bits du message "huit" sera similaire.  La mÃªme dll provoquera une prestation de serment similaire (Fig.15): <blockquote>  Erreur lors de l'appel de la mÃ©thode de contexte (Load External Component): erreur lors du chargement du composant externe </blockquote><br>  Alors, comment les bibliothÃ¨ques mentionnÃ©es rÃ©solvent-elles ce problÃ¨me?  En Ã©tudiant les textes des programmes Orefkov et Yoksel, nous concluons finalement que les Â« <b>lignes magiques</b> Â» suivantes dans le fichier de ressources (* .rc ou * .rc2) sont Â«Ã  blÃ¢merÂ»: <br><br><pre> <code class="plaintext hljs">STRINGTABLE DISCARDABLE BEGIN 100 "\0sd" // 1sqlite.dll 100 "\0tmd" // TurboMD.dll 100 "\0f" // SpreadSheet.dll END</code> </pre> <br>  C'est-Ã -dire  sans faute, dans les ressources du programme, il y a une ligne avec l'identifiant <b>100</b> et une certaine valeur de chaÃ®ne, dont le premier caractÃ¨re est zÃ©ro.  Vous pouvez expÃ©rimenter avec des variations de telles chaÃ®nes, mais la chaÃ®ne " <b>\ 0L</b> " me convient.  Ainsi, nous crÃ©ons un fichier de ressources et Ã©crivons des lignes comme ceci: <br><br><pre> <code class="plaintext hljs">STRINGTABLE DISCARDABLE BEGIN 100 "\0L" //    1     ! END</code> </pre> <br>  Nous connectons ce fichier Ã  notre projet de DLL le plus simple gÃ©nÃ©rÃ© par l'assistant MS C ++, ajoutez le code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">BOOL APIENTRY </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DllMain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HANDLE hModule, DWORD dwReason, LPVOID lpReserved)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(dwReason) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DLL_PROCESS_ATTACH: MessageBox(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">",  DllMain()!"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, MB_OK); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DLL_THREAD_ATTACH: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DLL_THREAD_DETACH: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DLL_PROCESS_DETACH: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// switch(dwReason) return TRUE; } // DllMain()</span></span></code> </pre> <br>  et observez (Fig. 14). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/715/a71/7f7/715a717f7ee778dd219e79e5fbd43e97.jpg" alt="Fig. 14. Utilisation du Â«VKÂ» le plus simple du 1C82"><br>  Fig.  14. Utilisation du Â«VKÂ» le plus simple en 1C82. <br><br>  Sans "lignes magiques" dans le fichier de ressources, notre dll, aprÃ¨s avoir montrÃ© MessageBox, se dÃ©charge immÃ©diatement avec une malÃ©diction de 1C (Fig. 15). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a98/cec/432/a98cec4326033180917940aa248dbc96.jpg" alt="Fig. 15. Erreur lors du chargement de la DLL rÃ©guliÃ¨re dans 1C82"><br>  Fig.  15. Erreur lors du chargement de la DLL rÃ©guliÃ¨re dans 1C82. <br><br>  Autrement dit, ces lignes ont vraiment un effet magique sur le chargeur de composants externes 1C. <br><br>  La premiÃ¨re, semble-t-il, des Â«lignes magiquesÂ» a Ã©tÃ© dÃ©crite dans son ancien article d' <b><i>Alexei Fedorov (ALF)</i></b> , mais le lien vers celle-ci n'est plus disponible, et l'auteur ne voit pas l'intÃ©rÃªt de sa nouvelle publication.  De plus, <b><i>Alexander Orefkov les a</i></b> utilisÃ©s de la maniÃ¨re la plus intensive, et apparemment, d'aprÃ¨s sa soumission, l'auteur Ã©tait <b><i>Yoksel</i></b> .  Par consÃ©quent, nous parlerons <b><i>des lignes Â«magiquesÂ» de Fedorov-Orefkov</i></b> .  Leur signification est de bloquer le dÃ©chargement des fichiers dll non standard (du point de vue de 1C) par la fonction <b>LoadExternalComponent ()</b> .  De plus, comme nous le voyons, cette technique fonctionne non seulement en 1C77, mais aussi sous des formes 1C82 Â«Ã©paissesÂ». <br><br>  Cependant, dans les formulaires gÃ©rÃ©s 1C82 et dans toutes les versions de 1C83, cette fonctionnalitÃ© a dÃ©jÃ  Ã©tÃ© complÃ¨tement interrompue (un autre chargeur est Ã©galement apparu - <b>ConnectExternalComponent ()</b> ). <br><br>  Ainsi, dans les versions modernes de 1C, vous devez rechercher d'autres alternatives simples aux lignes Â«magiquesÂ» de Fedorov-Orefkov. <br><br>  Et une telle alternative est facile Ã  offrir.  Le point est simple.  Le chargeur 1C dÃ©charge le Â«mauvaisÂ» composant s'il lÃ¨ve une exception lorsqu'il essaie d'y accÃ©der en utilisant le protocole spÃ©cifiÃ©, par exemple, lors de la demande de la version du composant.  Naturellement, nous nâ€™avons rien de ce type, qui sert de base au dÃ©chargement dâ€™une DLL non standard.  Mais l'exigence de 1C pour que le systÃ¨me d'exploitation dÃ©charge cette bibliothÃ¨que dynamique peut Ãªtre ignorÃ©e par le systÃ¨me si ce VK est toujours utilisÃ© quelque part.  Au lieu de la suppression elle-mÃªme, le systÃ¨me rÃ©duit simplement le compteur d'utilisation du module souhaitÃ©.  Et supprimez physiquement au plus tÃ´t ce compteur est rÃ©initialisÃ©.  Par consÃ©quent, notre tÃ¢che consiste Ã  augmenter artificiellement ce compteur. <br><br>  Pour ce faire, vous pouvez appeler Ã  nouveau notre fonction dll WinAPI <b>LoadLibrary ()</b> dans la section <b>DLL_THREAD_ATTACH</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">BOOL APIENTRY </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DllMain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HANDLE hModule, DWORD dwReason, LPVOID lpReserved)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(dwReason) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DLL_PROCESS_ATTACH: { WCHAR szDllName[_MAX_PATH] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//     dll GetModuleFileName(hModule, szDllName, _MAX_PATH); //MessageBox(NULL, szDllName, L"Info", MB_OK); //    dll (     183), //      DLL_PROCESS_ATTACH HMODULE hDll = LoadLibrary(szDllName); break; } // case DLL_PROCESS_ATTACH case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; } // switch(dwReason) return TRUE; } // DllMain()</span></span></code> </pre> <br>  VoilÃ !  Le problÃ¨me est rÃ©solu.  Le rappel de la mÃªme bibliothÃ¨que dynamique augmentera son compteur d'utilisation de un et le dÃ©chargement (avec un accÃ¨s prÃ©liminaire Ã  la section <b>DLL_THREAD_DETACH</b> ) diminuera de un.  Au total, nous avons <b>2 - 1 = 1&gt; 0</b> , par consÃ©quent, le systÃ¨me d'exploitation ne dÃ©chargera pas notre DLL.  De plus, ce qui est important, la rÃ©initialisation de la section <b>DLL_PROCESS_ATTACH</b> ne se produira pas. <br><br>  De cela, d'ailleurs, on peut voir comment 1C peut gÃ©rer une astuce similaire dans ses derniÃ¨res versions (et, apparemment, il le fait dÃ©jÃ  dans les configurations crÃ©Ã©es dans 1C-8.3.14 et plus).  Il peut utiliser la fonction <b>LoadLibraryEx ()</b> avec un paramÃ¨tre qui bloque l'exÃ©cution de la section d'initialisation <b>DLL_PROCESS_ATTACH</b> , aprÃ¨s quoi il appellera immÃ©diatement les fonctions exportÃ©es nÃ©cessaires.  Et, en effet, si vous regardez le code de l'exemple VK pour l'API native, vous pouvez voir qu'il n'est pas nÃ©cessaire d'appeler le code d'initialisation, car il doit Ãªtre vide au format VK. <br><br>  Concernant les exemples d'utilisation de la technologie COM, il est Ã©vident que l'exÃ©cution de la section d'initialisation <b>DLL_PROCESS_ATTACH y</b> est nÃ©cessaire, donc, dans les versions pas trop rÃ©centes de 1C, plus prÃ©cisÃ©ment, dans les configurations faites en 1C-8.3.13 et ci-dessous, le chargeur 1C nous convient: <br><br><pre> <code class="plaintext hljs">(, , .COM);</code> </pre> <br>  Ici, le dernier paramÃ¨tre peut Ãªtre supprimÃ©, car il est implicite par dÃ©faut.  En mÃªme temps, ils peuvent s'ouvrir normalement dans n'importe quelle version supÃ©rieure.  Dans les versions 1C83, l'ancien chargeur de dÃ©marrage <b>LoadExternalComponent (Component Address)</b> ne nous convient plus (respectivement, les "lignes magiques" de Fedorov-Orefkov n'y fonctionnent pas). <br><br>  Dans le cas gÃ©nÃ©ral, comme dÃ©jÃ  mentionnÃ©, le problÃ¨me peut Ãªtre rÃ©solu en utilisant un chargeur de dÃ©marrage externe.  Ou, ce qui est tout Ã  fait naturel, d'observer, dans une mesure ou une autre, la technologie des composants externes du 1C. <br><br>  Il convient Ã©galement de noter que les expÃ©riences que nous avons menÃ©es dans des versions de fichiers de 1C avec diffÃ©rentes profondeurs de bits.  Pour tÃ©lÃ©charger notre composant, vous devrez peut-Ãªtre dÃ©finir la propriÃ©tÃ© Â« <b>Synchronous Call Usage Mode</b> Â» sur Â« <b>Use</b> Â» dans la configuration. <br><br>  Il faut Ã©galement comprendre que vous rÃ©alisez l'utilisation d'une telle technique Ã  vos risques et pÃ©rils, expÃ©rimentez Ã  l'avance des configurations de test ou des copies de travailleurs pour Ã©viter les problÃ¨mes potentiels dans les programmes principaux. <br><br><h3>  Mise Ã  jour du 09/11/2019 </h3><br>  Il s'est avÃ©rÃ© que je m'inquiÃ©tais en vain que: "dans les versions 1C-8.3.14 et supÃ©rieures, la section d'initialisation dans le composant externe n'est plus effectuÃ©e Ã  partir du mot" complÃ¨tement "". <br><br>  Il s'avÃ¨re que seul le message de retour dans la fonction <b>ConnectExternalComponent ()</b> n'a pas besoin d'Ãªtre traitÃ©.  De plus, quel que soit le type de composant que nous spÃ©cifions: <b>COM</b> ou <b>API native</b> . <br><br>  Ainsi, vous pouvez crÃ©er une configuration dans toutes les versions actuellement disponibles de 1C, notre composant devrait fonctionner correctement partout, et la crÃ©ation d'un chargeur de dÃ©marrage externe sera pertinente, sauf dans le cas oÃ¹ vous ne souhaitez pas modifier la configuration, qui est entiÃ¨rement prise en charge. <br><br>  Ã€ cet Ã©gard, le code dans les configurations de test pour 1C82 et 1C83 est lÃ©gÃ¨rement modifiÃ©, bien que les diffÃ©rences entre elles ne soient plus fondamentales. <br><br>  Dans le mÃªme temps, notre remarque selon laquelle la sociÃ©tÃ© 1C peut facilement bloquer l'exÃ©cution du code d'initialisation dans n'importe quel VK, au moins pour les composants externes tels que l' <b>API native</b> , reste Ã©videmment valide, car Ã  en juger par leur modÃ¨le, cela n'est pas nÃ©cessaire.  Pour un <b>COM de</b> type VK <b>, il existe</b> un tel besoin jusqu'Ã  prÃ©sent, mais qu'est-ce qui l'empÃªche de s'en dÃ©barrasser?  Dans le mÃªme temps, voyons sâ€™ils tiendront compte de ces informations? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466713/">https://habr.com/ru/post/fr466713/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466699/index.html">Approbation des protocoles de confiance - Authentification OAuth avec InterSystems IRIS</a></li>
<li><a href="../fr466701/index.html">Let's Encrypt dessert prÃ¨s de 30% des domaines</a></li>
<li><a href="../fr466705/index.html">Vivaldi Beta pour Android - Navigateur rÃ©el</a></li>
<li><a href="../fr466709/index.html">DÃ©veloppement d'un systÃ¨me d'exploitation monolithique de type Unix - BibliothÃ¨que C (2)</a></li>
<li><a href="../fr466711/index.html">VulnÃ©rabilitÃ© DaOffice autorisÃ© Ã  supprimer tout utilisateur du rÃ©seau social</a></li>
<li><a href="../fr466719/index.html">Profil de vitesse ultra-lÃ©ger: thÃ©orie et pratique. partie 1</a></li>
<li><a href="../fr466721/index.html">[Ekaterinbourg, annonce] java.ural.Meetup @ 3 - annonce des troisiÃ¨mes reportages vidÃ©o Java mitap + de java.ural.Meetup @ 2</a></li>
<li><a href="../fr466723/index.html">Apple Text Broadcast - 10 septembre 2019</a></li>
<li><a href="../fr466725/index.html">La dague 2 est Ã©lÃ©mentaire (partie 1)</a></li>
<li><a href="../fr466727/index.html">Mise Ã  niveau paresseuse: comment PostgreSQL 12 amÃ©liore les performances</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>