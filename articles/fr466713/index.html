<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🤝‍👨🏻 👨‍👨‍👦‍👦 🚨 Est-il possible en 1C de ne pas observer la technologie des composants externes? Ou Comment féliciter des collègues utilisant 1C? 👨‍🔬 🧘🏾 👩🏼‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y avait une idée ici pour féliciter notre chef comptable d'une manière plus ou moins originale, par exemple, avec l'aide de son programme 1C préfér...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Est-il possible en 1C de ne pas observer la technologie des composants externes? Ou Comment féliciter des collègues utilisant 1C?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466713/">  Il y avait une idée ici pour féliciter notre chef comptable d'une manière plus ou moins originale, par exemple, avec l'aide de son programme 1C préféré?  Mais comment? <br><br>  Après réflexion, l'idée est venue d'utiliser pour les félicitations d'arrière-plan l'image d'arrière-plan dans la zone client des formulaires conventionnels pour les configurations sur 1C77-1C82 ou dans une fenêtre externe pour les formulaires gérés 1C82 et dans tous les cas pour 1C83.  Sur celui-ci, affichez le message souhaité et donnez des liens vers la vidéo de félicitations, comme indiqué sur la figure. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a77/0bd/055/a770bd055ca43fdb5ad8d6f1f124253b.jpg" alt="Félicitation en 1C"><br><a name="habracut"></a><br><h2>  Première partie - Résultat </h2><br>  De toute évidence, cette idée n'est pas nouvelle.  Ainsi, en 2011, une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">solution similaire a</a> été proposée basée sur <b>FormEx.dll, par <i>Aleksey Fedorov alias ALF</i></b> .  Et des questions sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">manière d'y parvenir</a> ont été posées en 2008. <br><br>  À un moment donné, nous avons également utilisé ce composant pour charger l'image d'arrière-plan dans 1C77.  Mais le chargement de gros fichiers bmp (et d'autres ne pouvaient pas être utilisés) était lent (à cause de cela, de petites images posées avec des tuiles ont été utilisées), donc il y avait un désir d'écrire votre propre composant externe (VK), qui ne téléchargera que les images nécessaires et rien de plus, sauf si quoi d'autre pour être un terrain d'essai pour des expériences. <br><br>  Un tel composant a été écrit (également, uniquement pour les fichiers bmp, en utilisant, si nécessaire, le pavage).  La fonction <b>WinAPI LoadImage () y a</b> été utilisée.  Cette DLL n'a pas été en conflit avec FormEx.dll, elle était simple, assez rapide et servie pendant longtemps. <br><br>  Tout cela était merveilleux, mais il était temps d'étendre ses capacités, et ici une approche différente était nécessaire. <br><br>  Dans cet article, nous n'abordons pas les problèmes de création de fichiers multimédias.  Ce n'est pas notre spécialité.  Nous nous limitons uniquement à certaines nuances de programmation de composants externes pour 1C. <br><br><h3>  1C77 </h3><br>  Étant donné que les versions de la plate-forme 1C peuvent être différentes, il peut y avoir plusieurs solutions.  Dans notre cas, il s'agissait de configurations sur 1C77 (Fig.1). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b4/611/4ad/8b46114ad1ae83e57667cc4bb84aae7e.jpg" alt="Fig. 1. Image de félicitations dans la configuration de test sur 1C77"><br>  Fig.  1. Image de félicitations dans la configuration de test sur 1C77. <br><br>  La vidéo ici, bien que la sienne, mais l'idée de sa création est glanée auprès d' <b><i>Anna Shiyanova, sous le surnom de "Cas spécial"</i></b> .  Cette fille a du talent, elle peut être imitée, mais il n'est guère possible de répéter complètement le style.  Dans ce cas, je voulais juste au moins un élément de créativité. <br><br>  Si l'un des collègues est déjà fatigué de regarder les félicitations des autres, il peut surcharger l'image avec « <b>Alt + I</b> » (Fig. 2-3). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/01a/8c1/200/01a8c120008b72dd648b7c8697298d65.jpg" alt="Fig. 2. Sélection d'une autre image d'arrière-plan dans le menu &quot;Fichier / Sélectionner l'arrière-plan&quot; ou par &quot;Alt + I&quot;"><br>  Fig.  2. Sélection d'une image d'arrière-plan différente dans le menu "Fichier / Sélectionner l'arrière-plan" ou par "Alt + I". <br><br>  Et en même temps voir les informations sur le module utilisé par " <b>Alt + L</b> " (Fig. 3). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/499/499/f23/499499f23ec33734bd6a5068f5d493b8.jpg" alt="Fig. 3. Une image d'arrière-plan surchargée avec des informations sur le programme (&quot;Aide / À propos du module LionExt32.dll&quot; ou &quot;Alt + L&quot;)"><br>  Fig.  3. Image d'arrière-plan surchargée avec des informations sur le programme («Aide / À propos du module LionExt32.dll» ou «Alt + L»). <br><br><h3>  Formes conventionnelles 1C82 </h3><br>  Naturellement, la majorité est désormais orientée vers le G8 (1C8x).  Cependant, travailler avec l'image d'arrière-plan dans 1C n'est possible que sur les formulaires ordinaires dans la version 8.2 et moins, et si vous n'utilisez aucun traitement qui démarre en mode «bureau», qui chevauchera simplement complètement notre arrière-plan (Fig. 4). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/390/123/bfd/390123bfd2ef88bfbc108dbe44c70835.jpg" alt="Fig. 4. Image de félicitations dans la configuration de test sur les formulaires ordinaires 1C82"><br>  Fig.  4. Image de félicitations dans la configuration de test sur les formulaires habituels 1C82. <br><br>  Notez que les liens vers la Fig.  4 n'indiquez pas notre vidéo.  Ils sont montrés juste pour le test. <br><br>  Dans les formes ordinaires, 1C82 ne fonctionne plus de manière standard pour accéder au menu, car il n'y est pas systémique, comme dans le "sept", mais "propre" (bien que le système puisse être créé, mais pourquoi avons-nous besoin de deux menus principaux?).  Cependant, des raccourcis clavier peuvent être utilisés.  De la même manière, «Alt + I», dans notre composant, nous invoquons une boîte de dialogue, comme dans la Fig. 2 et chargeons un autre arrière-plan (Fig. 5). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c3f/535/deb/c3f535deb522e2ae7ad8937ce31b1188.jpg" alt="Fig. 5. Image d'arrière-plan surchargée sous des formes 1C82 «épaisses»"><br>  Fig.  5. Image d'arrière-plan surchargée sous des formes 1C82 «épaisses». <br><br>  De même, vous pouvez obtenir des informations sur le module en appuyant sur la touche "Alt + L", comme dans la fig.  3. <br><br><h3>  Formulaires gérés 1C82 </h3><br>  Pour les formulaires gérés dans 1C82, vous pouvez toujours trouver la fenêtre dont nous avons besoin au septième niveau d'imbrication, comme " <b>V8FormElement</b> " et dessiner dessus, mais en quelque sorte ce n'est pas intéressant. <br><br>  Pour nous, il résulte de ces considérations qu'il est plus facile de créer une fenêtre externe avec un message de félicitations (Fig. 6) que de traiter chaque cas individuel.  La fenêtre elle-même peut être fermée, ou plutôt minimisée par " <b>Esc</b> ", " <b>Ctrl + F4</b> ", " <b>Alt + F4</b> " ou en cliquant sur la " <b>croix</b> ". <br><br><img src="https://habrastorage.org/getpro/habr/post_images/790/cd9/79d/790cd979df8a4d97ff5488c50fa4bd6c.jpg" alt="Fig. 6. Image de félicitations dans une configuration de test sur les formulaires gérés 1C82"><br>  Fig.  6. Image de félicitations dans une configuration de test sur les formulaires gérés 1C82. <br><br>  De plus, la fenêtre minimisée (Fig. 7) peut à nouveau être agrandie. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/66c/1a7/c7f/66c1a7c7f725404604318cdcde3a9915.jpg" alt="Fig. 7. L'image minimisée de la fenêtre externe sur les formulaires gérés 1C82"><br>  Fig.  7. Une image réduite de la fenêtre externe sur les formulaires gérés 1C82. <br><br>  Les dimensions et la position relative de la fenêtre extérieure peuvent être modifiées, tout est comme d'habitude ici (voir des images agrandies de fenêtres extérieures sur la Fig. 6 et la Fig. 10).  Notez que les raccourcis clavier ne fonctionnent que si la fenêtre externe est active. <br><br><h3>  Formes conventionnelles 1C83 </h3><br>  Dans 1C83, il n'y a plus de fenêtres enfants du tout, ce qui peut servir de critère pour la version 1C dans notre DLL.  De plus, les formulaires «épais» sont une fenêtre de cadre (Fig. 8), et les formulaires gérés sont sans cadre (Fig. 9).  Autrement dit, tout ce qui n'est pas un cadre peut être redessiné.  Un cadre peut également être redessiné, mais uniquement en tant qu'élément système. <br><div class="scrollable-table"><table><tbody><tr><th><img src="https://habrastorage.org/getpro/habr/post_images/f9c/35e/0da/f9c35e0da01025306525d14f700d22a4.jpg" alt="Fig. 8. Fenêtre de cadre sous formes «épaisses» 1C83"></th><th><img src="https://habrastorage.org/getpro/habr/post_images/962/5f9/e7c/9625f9e7c28fed4c9226ee73d8126ed8.jpg" alt="Fig. 9. Fenêtre sans cadre dans les formulaires gérés 1C83"></th></tr><tr><th>  Fig.  8. Fenêtre de cadre en formes «épaisses» 1C83. </th><th>  Fig.  9. Fenêtre sans cadre sous formes contrôlées 1C83. </th></tr></tbody></table></div>  Ici, nous avons créé une fenêtre de test à l'aide d'une bibliothèque dynamique et l'avons subordonnée à la fenêtre principale 1C.  La différence de comportement est visible dans les figures. <br><br><h3>  Formulaires gérés 1C83 </h3><br>  Dans le cas de 1C83, comme dans les formulaires gérés 1C82, nous tirerons nos félicitations non pas sur le fond, mais dans une fenêtre distincte, dont le prototype est illustré sur la Fig.  8-9.  Par conséquent, le composant souhaité ( <b>LionExt32.dll</b> ou <b>LionExt64.dll</b> ) donnera le résultat suivant (Fig. 10-12). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/104/cf1/f10/104cf1f10c6ae652d24edea7082c7e6c.jpg" alt="Fig. 10. L'image d'arrière-plan dans la fenêtre externe pour les formulaires conventionnels 1C83"><br>  Fig.  10. L'image d'arrière-plan dans la fenêtre externe pour les formulaires conventionnels 1C83. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/56a/03f/fc7/56a03ffc7fe1f2bfee6358ecb81af9fa.jpg" alt="Fig. 11. Image d'arrière-plan dans la fenêtre externe des formulaires gérés 1C83, version 14, version 64 bits"><br>  Fig.  11. L'image d'arrière-plan dans la fenêtre externe des formulaires gérés 1C83, version 14, version 64 bits. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/05e/12f/71c/05e12f71ccfb9212b96bc3db92630869.jpg" alt="Fig. 12. Image d'arrière-plan dans la fenêtre externe des formulaires gérés 1C83, version 15, version 64 bits"><br>  Fig.  12. L'image d'arrière-plan dans la fenêtre externe des formulaires gérés 1C83, version 15, version 64 bits. <br><br><h3>  Constatations préliminaires </h3><br>  Cette composante était effectivement utilisée en pratique (Fig.1), le chef comptable était satisfait, tout s'est merveilleusement bien passé.  En cours de route, il s'est avéré que les utilisateurs aiment choisir leurs propres images d'arrière-plan, dans ce cas, pour travailler sur les "sept".  Pour le G8, notre composant est adapté avec une réserve pour l'avenir, alors qu'il devrait être considéré comme une version de démonstration. <br><br>  L'intérêt ici était que <b><i>ce composant ne nécessitait pas la conformité avec la technologie de création de composants externes à partir de 1C</i></b> .  Peut-être que d'autres idées surgiront pour étendre ses capacités.  Par exemple, pour les configurations entièrement prises en charge, vous ne souhaitez pas apporter de modifications au code 1C sans besoin particulier.  Dans ce cas, on pourrait offrir l'option de chargement externe d'une DLL arbitraire dans l'espace d'adressage 1C.  Mais c'est le sujet d'un autre article. <br><br>  Parmi les innovations techniques, un verrou a été utilisé pour décharger notre composant avec la plateforme 1C (car il n'est pas conforme au format VK).  De plus, une autre astuce a permis d'affecter un <b>menu local</b> à la fenêtre enfant, puisque le système d'exploitation Windows bloque la création d'un tel menu pour les fenêtres subordonnées.  Par conséquent, vous ne verrez nulle part les menus locaux dans la même interface <b>MDI</b> (Multi Document Interface).  Il est remplacé par des panneaux de commandes, des barres d'outils et un menu contextuel.  Il y a encore un moment pour mettre à jour les fenêtres.  Il arrive parfois que ni <b>UpdateWindow ()</b> ni <b>InvalidateRect () ne</b> fonctionnent correctement.  Mais quelques fonctions réussissent dans ce cas: <br><br><pre><code class="cpp hljs">ShowWindow(hWnd, SW_HIDE); ShowWindow(hWnd, SW_SHOW);</code> </pre> <br>  Il convient également de noter que notre composant peut entrer en conflit avec d'autres, par exemple, avec FormEx.dll pour 1C77.  Dans ce cas, il doit être chargé en dernier. <br><br>  Par ailleurs, il est à noter que si vous créez une configuration dans la version 1C-8.3.14 et supérieure, le composant n'est pas chargé de manière régulière.  Mais si la base de données a été créée dans une version antérieure de 1C et s'ouvre dans les dernières versions, il n'y a aucun problème de chargement de notre VK.  Cela suggère une fois de plus la nécessité de créer un chargeur de démarrage externe. <br><br>  Ce projet utilise le sous-système <b>WinAPI GDI +</b> .  En l'utilisant, vous pouvez afficher des images de différents formats: <b>bmp, jpg, gif, png, tif</b> et autres.  Dans le même ordre, le composant tente de charger le premier fichier <b>Main. *</b> Disponible à partir du répertoire <b>Pics</b> local dans la configuration actuelle.  Si aucun de ces fichiers n'est trouvé, une simple image d'arrière-plan provenant des ressources des composants est utilisée.  Dans la fig.  La figure 13 montre cette image d'arrière-plan pour les formes habituelles de 64 bits 1C83, version 15. Pour une modification, la fenêtre externe de l'argot a été agrandie et une autre image du fichier <b>Main1.png</b> , qui a été «mosaïque», a été ajoutée à son arrière-plan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/71c/80a/48a/71c80a48a18236e495a1d62b0f316e11.jpg" alt="Fig. 13. Le fond d'écran par défaut pour les formulaires réguliers 64 bits 1C83, version 15"><br>  Fig.  13. L'image d'arrière-plan par défaut pour les formes habituelles de 64 bits 1C83, version 15. De plus, une autre image du fichier Main1.png, posée en "mosaïque", a été ajoutée. <br><br>  Il n'y a aucune différence dans le fonctionnement du composant dans différents modes de bits. <br><br>  On peut également noter que notre composant sous-classe la fenêtre principale 1C et son client MDI, le cas échéant.  Cela, apparemment, sert de source de conflit avec FormEx.dll lors de son dernier chargement (en 1C77). <br><br><h2>  Deuxième partie - Technique </h2><br>  Le projet lui-même peut être trouvé sur les liens suivants: <br><br><ul><li>  <a href="">Tester la configuration sur 1C77</a> </li><li>  <a href="">Configuration de test sur 1C82</a> </li><li>  <a href="">Configuration de test sur 1C83</a> </li><li>  <a href="">Projet sur MS VS C ++, v.</a>  <a href="">13</a> </li></ul><br>  Un projet <b>C ++</b> peut être facilement adapté pour la version <b>10</b> si la chaîne " <b>v120</b> " est remplacée par " <b>v100</b> " et " <b>ToolsVersion =" 12.0 "</b> " par " <b>ToolsVersion =" 4.0 "</b> dans les fichiers de configuration. <br><br>  Le code des versions <b>32</b> bits et <b>64</b> bits de <b>1C est</b> le même et peut être compilé en même temps. <br><br>  La version 1C77 est déterminée dans le composant externe par le descripteur de fonction GetMenu <b>()</b> non nul et la version 1C83, par l'absence de fenêtres enfants dans la fenêtre principale, dont le <b>descripteur</b> est déterminé par la fonction <b>GetForegroundWindow ()</b> . <br><br><h3>  À propos de la technologie de création de composants externes pour 1C </h3><br>  Sur les disques ITS de la société 1C, et sur Internet, on peut facilement trouver des informations sur la création de VC et les modèles correspondants dans différents langages de programmation.  Cependant, au temps du 1C77, ces schémas satisfaisaient «pas seulement tout le monde». <br><br>  Si vous regardez certains composants largement utilisés, en particulier pour 1C77, vous verrez que leurs auteurs ont souvent utilisé des méthodes de programmation spéciales pour étendre les capacités de leurs conceptions. <br><br>  Peut-être que l'un des premiers composants externes de ce type était <b><i>"RAINBOW ADDIN 2000 for 1C: Enterprise 7.7"</i></b> .  Le plus important ici était peut-être une pénétration plus profonde dans les entrailles du «sept» que la technologie officielle VK ne le permettait, même si elle suivait le format VK.  Cet objectif a été atteint grâce aux en-têtes (fichiers * .h) reçus, probablement non standard, des fichiers de bibliothèque 1C77 utilisés dans d'autres projets largement connus. <br><br>  En effet, si des fonctions 1C telles que <b>LoadExternalComponent ()</b> et <b>ConnectExternalComponent ()</b> vous permettent d'incorporer <b>des DLL externes</b> dans votre propre espace d'adressage (tout d'abord, qui satisfont le format de la technologie VK), alors pourquoi les programmes utilisateur ne succombent-ils pas à la tentation et tentent d'accéder à d'autres cachés de eux, les procédures et autres objets de la plate-forme cible?  Cette approche a été démontrée avec succès par le composant <b>Rainbow.dll</b> . <br><br>  Plus tard, un mécanisme similaire a été adopté par d'autres auteurs du composant 1C version 7.7.  Le composant pour la "sept" <b>1C ++. Dll</b> et son, pour ainsi dire, un cas spécial de <b>FormEx.dll</b> sont particulièrement <b>remarquables</b> . <br><br>  Mais l'approche non triviale de la conception de composants externes pour 1C77 ne s'arrête pas là.  Apparemment, quelqu'un aurait dû dire: «Pourquoi avons-nous besoin d'un forgeron?  Nous n'avons pas besoin d'un forgeron! "  Ici, par «forgeron», nous entendons la technologie COM de MicroSoft, qui, dans un sens, a été suivie par la technologie VK pour les «sept».  Non, vraiment, pourquoi avons-nous besoin d'un registre si nous téléchargeons notre VK directement?  Cela peut être logique pour les navigateurs Web qui fonctionnent avec Internet, mais pour un fonctionnement local, l'utilisation du registre est clairement redondante.  À tout le moins, cela ne devrait pas être une condition préalable.  De plus, pour éditer le registre, vous avez besoin de droits administratifs. <br><br>  Notez que 1C aimait beaucoup cette technologie (au moins jusqu'au portage de 1C vers Linux).  Nous la traitons plutôt cool.  COM est pratique pour utiliser le composant ActiveX et cela est naturel, car ces derniers ont été initialement développés pour Internet. <br><br>  Cependant, dans les dernières versions, 1C a ajouté la possibilité d'utiliser la technologie <b>API native</b> , ce qui élimine le besoin d'un registre.  En principe, c'est ce dont nous avons besoin, sauf que cette technologie n'est pas applicable dans les «sept» et qu'elle est, pour certains, toujours d'actualité. <br><br>  Mais parfois, des tâches relativement simples surviennent lorsque vous ne souhaitez pas utiliser un tas de code passe-partout pour VK et qu'il est conseillé de travailler avec 1C uniquement du côté du composant externe.  Comme, disons, dans notre cas, la démonstration d'une image de félicitations dans l'espace client ou, si nécessaire, dans une fenêtre séparée, la configuration 1C. <br><br>  En d'autres termes, si nous n'allons pas échanger directement des données entre 1C et VK, nous serons très satisfaits d'une version plus simple et plus universelle du composant externe pour 1C.  Ici, la simplicité sera obtenue en raison de l'absence de code passe-partout. <br><br><h3>  Technologie alternative pour créer VK pour 1C </h3><br>  Étant donné que VK pour 1C est un cas particulier de <b>serveur COM</b> (avant la technologie <b>Native API</b> ), certains développeurs VK ont dit: «COM - non!».  L'activité dans ce sens d' <b><i>Alexandre Orefkov</i></b> est particulièrement notable.  Ses composants « <b>1sqlite.dll</b> », « <b>TurboMD.dll</b> » et éventuellement d'autres n'utilisent pas COM à partir du mot «complètement».  Le composant <b>Yoksel</b> (" <b>SpreadSheet.dll</b> ") se développe également le long de ce chemin. <br><br>  Mais comment alors le chargeur VK de 1C77 charge-t-il ces composants?  Après tout, ils n'essaient même pas d'imiter une sorte de COM là-bas.  En effet, si nous essayons de glisser franchement une DLL standard générée par, disons, l'assistant <b>MS VC ++</b> dans la fonction <b>LoadExternalComponent ()</b> , alors nous aurons une erreur. <br><br>  Dans le "sept", nous obtenons un message comme: <blockquote>  Une erreur s'est produite lors de la création d'un objet à partir du composant &lt;Chemin d'accès complet \ Nom du composant&gt; .dll (CLSID est manquant) </blockquote><br>  Dans le client "épais" 32 bits du message "huit" sera similaire.  La même dll provoquera une prestation de serment similaire (Fig.15): <blockquote>  Erreur lors de l'appel de la méthode de contexte (Load External Component): erreur lors du chargement du composant externe </blockquote><br>  Alors, comment les bibliothèques mentionnées résolvent-elles ce problème?  En étudiant les textes des programmes Orefkov et Yoksel, nous concluons finalement que les « <b>lignes magiques</b> » suivantes dans le fichier de ressources (* .rc ou * .rc2) sont «à blâmer»: <br><br><pre> <code class="plaintext hljs">STRINGTABLE DISCARDABLE BEGIN 100 "\0sd" // 1sqlite.dll 100 "\0tmd" // TurboMD.dll 100 "\0f" // SpreadSheet.dll END</code> </pre> <br>  C'est-à-dire  sans faute, dans les ressources du programme, il y a une ligne avec l'identifiant <b>100</b> et une certaine valeur de chaîne, dont le premier caractère est zéro.  Vous pouvez expérimenter avec des variations de telles chaînes, mais la chaîne " <b>\ 0L</b> " me convient.  Ainsi, nous créons un fichier de ressources et écrivons des lignes comme ceci: <br><br><pre> <code class="plaintext hljs">STRINGTABLE DISCARDABLE BEGIN 100 "\0L" //    1     ! END</code> </pre> <br>  Nous connectons ce fichier à notre projet de DLL le plus simple généré par l'assistant MS C ++, ajoutez le code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">BOOL APIENTRY </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DllMain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HANDLE hModule, DWORD dwReason, LPVOID lpReserved)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(dwReason) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DLL_PROCESS_ATTACH: MessageBox(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">",  DllMain()!"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, MB_OK); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DLL_THREAD_ATTACH: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DLL_THREAD_DETACH: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DLL_PROCESS_DETACH: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// switch(dwReason) return TRUE; } // DllMain()</span></span></code> </pre> <br>  et observez (Fig. 14). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/715/a71/7f7/715a717f7ee778dd219e79e5fbd43e97.jpg" alt="Fig. 14. Utilisation du «VK» le plus simple du 1C82"><br>  Fig.  14. Utilisation du «VK» le plus simple en 1C82. <br><br>  Sans "lignes magiques" dans le fichier de ressources, notre dll, après avoir montré MessageBox, se décharge immédiatement avec une malédiction de 1C (Fig. 15). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a98/cec/432/a98cec4326033180917940aa248dbc96.jpg" alt="Fig. 15. Erreur lors du chargement de la DLL régulière dans 1C82"><br>  Fig.  15. Erreur lors du chargement de la DLL régulière dans 1C82. <br><br>  Autrement dit, ces lignes ont vraiment un effet magique sur le chargeur de composants externes 1C. <br><br>  La première, semble-t-il, des «lignes magiques» a été décrite dans son ancien article d' <b><i>Alexei Fedorov (ALF)</i></b> , mais le lien vers celle-ci n'est plus disponible, et l'auteur ne voit pas l'intérêt de sa nouvelle publication.  De plus, <b><i>Alexander Orefkov les a</i></b> utilisés de la manière la plus intensive, et apparemment, d'après sa soumission, l'auteur était <b><i>Yoksel</i></b> .  Par conséquent, nous parlerons <b><i>des lignes «magiques» de Fedorov-Orefkov</i></b> .  Leur signification est de bloquer le déchargement des fichiers dll non standard (du point de vue de 1C) par la fonction <b>LoadExternalComponent ()</b> .  De plus, comme nous le voyons, cette technique fonctionne non seulement en 1C77, mais aussi sous des formes 1C82 «épaisses». <br><br>  Cependant, dans les formulaires gérés 1C82 et dans toutes les versions de 1C83, cette fonctionnalité a déjà été complètement interrompue (un autre chargeur est également apparu - <b>ConnectExternalComponent ()</b> ). <br><br>  Ainsi, dans les versions modernes de 1C, vous devez rechercher d'autres alternatives simples aux lignes «magiques» de Fedorov-Orefkov. <br><br>  Et une telle alternative est facile à offrir.  Le point est simple.  Le chargeur 1C décharge le «mauvais» composant s'il lève une exception lorsqu'il essaie d'y accéder en utilisant le protocole spécifié, par exemple, lors de la demande de la version du composant.  Naturellement, nous n’avons rien de ce type, qui sert de base au déchargement d’une DLL non standard.  Mais l'exigence de 1C pour que le système d'exploitation décharge cette bibliothèque dynamique peut être ignorée par le système si ce VK est toujours utilisé quelque part.  Au lieu de la suppression elle-même, le système réduit simplement le compteur d'utilisation du module souhaité.  Et supprimez physiquement au plus tôt ce compteur est réinitialisé.  Par conséquent, notre tâche consiste à augmenter artificiellement ce compteur. <br><br>  Pour ce faire, vous pouvez appeler à nouveau notre fonction dll WinAPI <b>LoadLibrary ()</b> dans la section <b>DLL_THREAD_ATTACH</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">BOOL APIENTRY </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DllMain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HANDLE hModule, DWORD dwReason, LPVOID lpReserved)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(dwReason) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DLL_PROCESS_ATTACH: { WCHAR szDllName[_MAX_PATH] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//     dll GetModuleFileName(hModule, szDllName, _MAX_PATH); //MessageBox(NULL, szDllName, L"Info", MB_OK); //    dll (     183), //      DLL_PROCESS_ATTACH HMODULE hDll = LoadLibrary(szDllName); break; } // case DLL_PROCESS_ATTACH case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; } // switch(dwReason) return TRUE; } // DllMain()</span></span></code> </pre> <br>  Voilà!  Le problème est résolu.  Le rappel de la même bibliothèque dynamique augmentera son compteur d'utilisation de un et le déchargement (avec un accès préliminaire à la section <b>DLL_THREAD_DETACH</b> ) diminuera de un.  Au total, nous avons <b>2 - 1 = 1&gt; 0</b> , par conséquent, le système d'exploitation ne déchargera pas notre DLL.  De plus, ce qui est important, la réinitialisation de la section <b>DLL_PROCESS_ATTACH</b> ne se produira pas. <br><br>  De cela, d'ailleurs, on peut voir comment 1C peut gérer une astuce similaire dans ses dernières versions (et, apparemment, il le fait déjà dans les configurations créées dans 1C-8.3.14 et plus).  Il peut utiliser la fonction <b>LoadLibraryEx ()</b> avec un paramètre qui bloque l'exécution de la section d'initialisation <b>DLL_PROCESS_ATTACH</b> , après quoi il appellera immédiatement les fonctions exportées nécessaires.  Et, en effet, si vous regardez le code de l'exemple VK pour l'API native, vous pouvez voir qu'il n'est pas nécessaire d'appeler le code d'initialisation, car il doit être vide au format VK. <br><br>  Concernant les exemples d'utilisation de la technologie COM, il est évident que l'exécution de la section d'initialisation <b>DLL_PROCESS_ATTACH y</b> est nécessaire, donc, dans les versions pas trop récentes de 1C, plus précisément, dans les configurations faites en 1C-8.3.13 et ci-dessous, le chargeur 1C nous convient: <br><br><pre> <code class="plaintext hljs">(, , .COM);</code> </pre> <br>  Ici, le dernier paramètre peut être supprimé, car il est implicite par défaut.  En même temps, ils peuvent s'ouvrir normalement dans n'importe quelle version supérieure.  Dans les versions 1C83, l'ancien chargeur de démarrage <b>LoadExternalComponent (Component Address)</b> ne nous convient plus (respectivement, les "lignes magiques" de Fedorov-Orefkov n'y fonctionnent pas). <br><br>  Dans le cas général, comme déjà mentionné, le problème peut être résolu en utilisant un chargeur de démarrage externe.  Ou, ce qui est tout à fait naturel, d'observer, dans une mesure ou une autre, la technologie des composants externes du 1C. <br><br>  Il convient également de noter que les expériences que nous avons menées dans des versions de fichiers de 1C avec différentes profondeurs de bits.  Pour télécharger notre composant, vous devrez peut-être définir la propriété « <b>Synchronous Call Usage Mode</b> » sur « <b>Use</b> » dans la configuration. <br><br>  Il faut également comprendre que vous réalisez l'utilisation d'une telle technique à vos risques et périls, expérimentez à l'avance des configurations de test ou des copies de travailleurs pour éviter les problèmes potentiels dans les programmes principaux. <br><br><h3>  Mise à jour du 09/11/2019 </h3><br>  Il s'est avéré que je m'inquiétais en vain que: "dans les versions 1C-8.3.14 et supérieures, la section d'initialisation dans le composant externe n'est plus effectuée à partir du mot" complètement "". <br><br>  Il s'avère que seul le message de retour dans la fonction <b>ConnectExternalComponent ()</b> n'a pas besoin d'être traité.  De plus, quel que soit le type de composant que nous spécifions: <b>COM</b> ou <b>API native</b> . <br><br>  Ainsi, vous pouvez créer une configuration dans toutes les versions actuellement disponibles de 1C, notre composant devrait fonctionner correctement partout, et la création d'un chargeur de démarrage externe sera pertinente, sauf dans le cas où vous ne souhaitez pas modifier la configuration, qui est entièrement prise en charge. <br><br>  À cet égard, le code dans les configurations de test pour 1C82 et 1C83 est légèrement modifié, bien que les différences entre elles ne soient plus fondamentales. <br><br>  Dans le même temps, notre remarque selon laquelle la société 1C peut facilement bloquer l'exécution du code d'initialisation dans n'importe quel VK, au moins pour les composants externes tels que l' <b>API native</b> , reste évidemment valide, car à en juger par leur modèle, cela n'est pas nécessaire.  Pour un <b>COM de</b> type VK <b>, il existe</b> un tel besoin jusqu'à présent, mais qu'est-ce qui l'empêche de s'en débarrasser?  Dans le même temps, voyons s’ils tiendront compte de ces informations? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466713/">https://habr.com/ru/post/fr466713/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466699/index.html">Approbation des protocoles de confiance - Authentification OAuth avec InterSystems IRIS</a></li>
<li><a href="../fr466701/index.html">Let's Encrypt dessert près de 30% des domaines</a></li>
<li><a href="../fr466705/index.html">Vivaldi Beta pour Android - Navigateur réel</a></li>
<li><a href="../fr466709/index.html">Développement d'un système d'exploitation monolithique de type Unix - Bibliothèque C (2)</a></li>
<li><a href="../fr466711/index.html">Vulnérabilité DaOffice autorisé à supprimer tout utilisateur du réseau social</a></li>
<li><a href="../fr466719/index.html">Profil de vitesse ultra-léger: théorie et pratique. partie 1</a></li>
<li><a href="../fr466721/index.html">[Ekaterinbourg, annonce] java.ural.Meetup @ 3 - annonce des troisièmes reportages vidéo Java mitap + de java.ural.Meetup @ 2</a></li>
<li><a href="../fr466723/index.html">Apple Text Broadcast - 10 septembre 2019</a></li>
<li><a href="../fr466725/index.html">La dague 2 est élémentaire (partie 1)</a></li>
<li><a href="../fr466727/index.html">Mise à niveau paresseuse: comment PostgreSQL 12 améliore les performances</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>