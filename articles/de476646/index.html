<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚öíÔ∏è üóÇÔ∏è ü§òüèº 3-Wege-Fusion in Werf: Einsatz in Kubernetes mit Helm "auf Steroiden" üî• üë≤ üë®üèº‚Äçüéì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es ist etwas passiert, worauf wir (und nicht nur wir) gewartet haben: werf , unser Open Source-Dienstprogramm zum Erstellen von Anwendungen und zum Be...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>3-Wege-Fusion in Werf: Einsatz in Kubernetes mit Helm "auf Steroiden"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/476646/"> Es ist etwas passiert, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">worauf</a> wir (und nicht nur wir) gewartet haben: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werf</a> , unser Open Source-Dienstprogramm zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erstellen von</a> Anwendungen und zum Bereitstellen auf Kubernetes, unterst√ºtzt jetzt das Anwenden von √Ñnderungen mithilfe von 3-Wege-Merge-Patches!  Dar√ºber hinaus wurde es m√∂glich, vorhandene K8-Ressourcen in Helm-Releases zu √ºbernehmen, ohne diese Ressourcen neu zu erstellen. <br><br><img src="https://habrastorage.org/webt/os/yc/op/osycopyy-kknbg7fnwuf8cjohxi.png"><br><br>  Wenn es sehr kurz ist, setzen Sie <code>WERF_THREE_WAY_MERGE=enabled</code> - wir erhalten die Bereitstellung "wie in <code>kubectl apply</code> ", kompatibel mit bestehenden Installationen auf Helm 2 und sogar ein bisschen mehr. <br><br>  Aber fangen wir mit der Theorie an: Was sind 3-Wege-Merge-Patches im Allgemeinen, wie sind die Menschen mit ihrer Generation dazu gekommen, und warum sind sie in CI / CD-Prozessen mit Kubernetes-basierter Infrastruktur wichtig?  Und danach - mal sehen, was 3-Wege-Merge in werf ist, welche Modi standardm√§√üig verwendet werden und wie man es verwaltet. <a name="habracut"></a><br><br><h2>  Was ist ein 3-Wege-Merge-Patch? </h2><br>  Beginnen wir also mit der Aufgabe, die in den YAML-Manifesten in Kubernetes beschriebenen Ressourcen bereitzustellen. <br><br>  Um mit Ressourcen zu arbeiten, bietet die Kubernetes-API die folgenden grundlegenden Vorg√§nge: Erstellen, Patchen, Ersetzen und L√∂schen.  Es wird davon ausgegangen, dass mit ihrer Hilfe ein bequemer kontinuierlicher Rollout von Ressourcen in den Cluster erstellt werden muss.  Wie? <br><br><h3>  Imperative Kubectl-Teams </h3><br>  Der erste Ansatz zum Verwalten von Objekten in Kubernetes besteht darin, die zwingenden Kubectl-Befehle zum Erstellen, √Ñndern und L√∂schen dieser Objekte zu verwenden.  Einfach ausgedr√ºckt: <br><br><ul><li>  <code>kubectl run</code> Befehl <code>kubectl run</code> kann Deployment oder Job ausf√ºhren: <br><br><pre> <code class="bash hljs">kubectl run --generator=deployment/apps.v1 DEPLOYMENT_NAME --image=IMAGE</code> </pre> </li><li>  Befehl <code>kubectl scale</code> - Anzahl der Replikate √§ndern: <br><br><pre> <code class="bash hljs">kubectl scale --replicas=3 deployment/mysql</code> </pre> </li><li>  usw. </li></ul><br>  Ein solcher Ansatz mag auf den ersten Blick zweckm√§√üig erscheinen.  Es gibt jedoch Probleme: <br><br><ol><li>  Es ist schwer zu <b>automatisieren</b> . </li><li>  Wie <b>spiegelt sich die Konfiguration</b> in Git <b>wider</b> ?  Wie √ºberpr√ºfe ich √Ñnderungen an einem Cluster? </li><li>  Wie kann die <b>Reproduzierbarkeit der</b> Konfiguration beim Neustart sichergestellt werden? </li><li>  ... </li></ol><br>  Es ist klar, dass dieser Ansatz nicht gut zum Speichern der Anwendung und der Infrastruktur als Code (IaC oder sogar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitOps</a> als modernere Option, die im Kubernetes-√ñkosystem an Beliebtheit gewinnt) mit dem Code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">passt</a> .  Daher wurden diese Teams in kubectl nicht weiterentwickelt. <br><br><h3>  Vorg√§nge erstellen, abrufen, ersetzen und l√∂schen </h3><br>  Mit der prim√§ren <b>Erstellung ist</b> alles einfach: Wir senden das Manifest an die <code>create</code> von kube api und die Ressource wird erstellt.  Die YAML-Darstellung des Manifests kann in Git gespeichert werden. Zum Erstellen verwenden Sie den <code>kubectl create -f manifest.yaml</code> . <br><br>  <b>Das L√∂schen ist</b> ebenfalls einfach: Wir ersetzen das gleiche <code>manifest.yaml</code> von Git durch den <code>kubectl delete -f manifest.yaml</code> . <br><br>  Mit der <b><code>replace</code></b> k√∂nnen Sie die Ressourcenkonfiguration vollst√§ndig durch eine neue ersetzen, ohne die Ressource neu erstellen zu m√ºssen.  Dies bedeutet, dass es logisch ist, die aktuelle Version mit der Operation <code>get</code> anzufordern, zu √§ndern und mit der Operation <code>replace</code> aktualisieren, bevor eine √Ñnderung an einer Ressource vorgenommen wird.  Die optimistische Sperrung ist in kube apiserver integriert. Wenn sich das Objekt nach dem Abrufvorgang ge√§ndert hat, schl√§gt der <code>replace</code> fehl. <br><br>  Um die Konfiguration in Git zu speichern und mit replace zu aktualisieren, m√ºssen Sie einen <code>get</code> Vorgang ausf√ºhren, die Konfiguration von Git mit dem, was wir haben, halten und <code>replace</code> ausf√ºhren.  Normalerweise k√∂nnen Sie in kubectl nur den Befehl <code>kubectl replace -f manifest.yaml</code> , wobei <code>manifest.yaml</code> das vollst√§ndig vorbereitete (in unserem Fall angef√ºgte) Manifest ist, das installiert werden muss.  Es stellt sich heraus, dass der Benutzer Zusammenf√ºhrungsmanifeste implementieren muss, aber dies ist keine triviale Angelegenheit ... <br><br>  Es ist auch erw√§hnenswert, dass, obwohl <code>manifest.yaml</code> in Git gespeichert ist, wir nicht im Voraus wissen k√∂nnen, ob wir ein Objekt erstellen oder aktualisieren m√ºssen - dies sollte von der Anwendersoftware durchgef√ºhrt werden. <br><br>  Fazit: <b>K√∂nnen wir ein kontinuierliches Rollout</b> nur mit create, replace und delete erstellen, um sicherzustellen, dass die Infrastrukturkonfiguration zusammen mit dem Code und einer praktischen CI / CD in Git gespeichert wird? <br><br>  Grunds√§tzlich k√∂nnen wir ... Dazu m√ºssen wir <b>die Zusammenf√ºhrungsoperation der</b> Manifeste und eine Art Bindung <b>implementieren, die</b> : <br><br><ul><li>  pr√ºft, ob ein Objekt im Cluster vorhanden ist, </li><li>  f√ºhrt die anf√§ngliche Erstellung der Ressource durch, </li><li>  aktualisiert oder l√∂scht es. </li></ul><br>  Beim Aktualisieren m√ºssen Sie ber√ºcksichtigen, dass sich die <i>Ressource</i> seit dem letzten <i>Abruf m√∂glicherweise ge√§ndert</i> hat <code>get</code> und den Fall des optimistischen Sperrens automatisch behandeln. Versuchen Sie wiederholt, eine Aktualisierung durchzuf√ºhren. <br><br>  Warum jedoch das Rad neu erfinden, wenn kube-apiserver eine andere M√∂glichkeit zum Aktualisieren von Ressourcen bietet: den <code>patch</code> Vorgang, mit dem einige der vom Benutzer beschriebenen Probleme behoben werden? <br><br><h3>  Patch </h3><br>  Also kamen wir zu den Patches. <br><br>  Patches sind die Hauptmethode, um √Ñnderungen an vorhandenen Objekten in Kubernetes anzuwenden.  Der <code>patch</code> Vorgang funktioniert folgenderma√üen: <br><br><ul><li>  Der Benutzer von kube-apiserver muss den Patch im JSON-Format senden und das Objekt angeben. </li><li>  und apiserver selbst wird sich mit dem aktuellen Zustand des Objekts befassen und es in die gew√ºnschte Form bringen. </li></ul><br>  Ein optimistisches Sperren ist in diesem Fall nicht erforderlich.  Diese Operation ist aussagekr√§ftiger als das Ersetzen, obwohl es auf den ersten Blick andersherum erscheinen mag. <br><br>  Auf diese Weise: <br><br><ul><li>  Mit der Operation create <code>create</code> wir ein Objekt aus dem Manifest von Git. </li><li>  using <code>delete</code> - L√∂schen, wenn das Objekt nicht mehr ben√∂tigt wird, </li><li>  using <code>patch</code> - Wir modifizieren das Objekt und bringen es in die in Git beschriebene Form. </li></ul><br>  Dazu m√ºssen Sie jedoch den <i>richtigen Patch</i> erstellen! <br><br><h3>  Wie Patches in Helm 2 funktionieren: 2-Wege-Zusammenf√ºhrung </h3><br>  Bei der ersten Installation einer Version f√ºhrt Helm einen <code>create</code> f√ºr Diagrammressourcen durch. <br><br>  Beim Aktualisieren der Helm-Version f√ºr jede Ressource: <br><br><ul><li>  Z√§hlt den Patch zwischen der Version der Ressource aus dem vorherigen Diagramm und der aktuellen Version des Diagramms. </li><li>  wendet diesen Patch an. </li></ul><br>  Wir werden einen solchen Patch als <b>2-Wege-Merge-Patch bezeichnen</b> , da zwei Manifeste an seiner Erstellung beteiligt sind: <br><br><ul><li>  Ressourcenmanifest aus vorheriger Version, </li><li>  Das Manifest der Ressource aus der aktuellen Ressource. </li></ul><br>  Beim L√∂schen wird der <code>delete</code> in kube apiserver f√ºr Ressourcen aufgerufen, die in der vorherigen Version deklariert, in der aktuellen Version jedoch nicht deklariert wurden. <br><br>  Der Ansatz mit 2-Wege-Merge-Patch hat ein Problem: Er f√ºhrt zu einer <b>Desynchronisierung des tats√§chlichen Zustands der Ressource im Cluster und des Manifests in Git</b> . <br><br><h3>  Ein Beispiel f√ºr ein Problem </h3><br><ul><li>  In Git wird ein Manifest in dem Diagramm gespeichert, in dem das Feld Deployment- <code>image</code> den <code>ubuntu:18.04</code> Wert <code>ubuntu:18.04</code> . </li><li>  Der Benutzer hat durch <code>kubectl edit</code> den Wert dieses Feldes in <code>ubuntu:19.04</code> ge√§ndert. </li><li>  Wenn Sie das Diagramm erneut bereitstellen, <i>generiert</i> Helm <i>keinen Patch</i> , da das <code>image</code> in der vorherigen Version der Version und im aktuellen Diagramm identisch sind. </li><li>  Nach der wiederholten Bereitstellung von <code>image</code> bleibt <code>ubuntu:19.04</code> , obwohl <code>ubuntu:18.04</code> in der Tabelle <code>ubuntu:18.04</code> ist. </li></ul><br>  Wir haben Desync und Deklarativit√§t verloren. <br><br><h3>  Was ist eine synchronisierte Ressource? </h3><br>  Im Allgemeinen ist es unm√∂glich, eine <i>vollst√§ndige</i> √úbereinstimmung zwischen einem Ressourcenmanifest in einem laufenden Cluster und einem Manifest von Git zu erhalten.  Da im realen Manifest m√∂glicherweise Dienstanmerkungen / -beschriftungen, zus√§tzliche Container und andere Daten vorhanden sind, die von einigen Controllern dynamisch zur Ressource hinzugef√ºgt und daraus gel√∂scht wurden.  Wir k√∂nnen und wollen diese Daten nicht in Git speichern.  Wir m√∂chten jedoch, dass beim Rollout die Felder, die wir explizit in Git angegeben haben, entsprechende Werte annehmen. <br><br>  Es stellt sich heraus, dass diese allgemeine <b>Regel einer synchronisierten Ressource gilt</b> : Wenn Sie eine Ressource bereitstellen, k√∂nnen Sie nur die Felder √§ndern oder l√∂schen, die explizit im Manifest von Git angegeben sind (oder in der vorherigen Version registriert wurden, jetzt aber gel√∂scht werden). <br><br><h3>  3-Wege-Merge-Patch </h3><br>  Die Hauptidee des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3-Wege-Merge-Patches</a> : Wir generieren einen Patch zwischen der zuletzt angewendeten Version des Manifests von Git und der Zielversion des Manifests von Git unter Ber√ºcksichtigung der aktuellen Version des Manifests aus dem Arbeitscluster.  Der endg√ºltige Patch muss der synchronisierten Ressourcenregel entsprechen: <br><br><ul><li>  Neue Felder, die der Zielversion hinzugef√ºgt wurden, werden mit dem Patch hinzugef√ºgt. </li><li>  Zuvor vorhandene Felder in der zuletzt angewendeten Version und nicht im Zielfeld vorhandene Felder werden mit dem Patch zur√ºckgesetzt. </li><li>  Felder in der aktuellen Version des Objekts, die sich von der Zielversion des Manifests unterscheiden, werden mit dem Patch aktualisiert. </li></ul><br>  Nach diesem Prinzip werden <code>kubectl apply</code> Patches generiert: <br><br><ul><li>  Die zuletzt angewendete Version des Manifests wird in der Annotation des Objekts selbst gespeichert. </li><li>  Ziel - aus der angegebenen YAML-Datei entnommen, </li><li>  current - aus einem Arbeitscluster. </li></ul><br>  Nachdem wir die Theorie herausgefunden haben, ist es Zeit, Ihnen zu erz√§hlen, was wir bei werf gemacht haben. <br><br><h2>  √Ñnderungen auf werf anwenden </h2><br>  Fr√ºher verwendete werf wie Helm 2 2-Wege-Merge-Patches. <br><br><h3>  Patch reparieren </h3><br>  Um zu einer neuen Art von Patches zu wechseln - 3-Wege-Merge - haben wir als ersten Schritt die sogenannten <b>Repair-Patches eingef√ºhrt</b> . <br><br>  Bei der Bereitstellung wird der standardm√§√üige 2-Wege-Merge-Patch verwendet, aber werf generiert zus√§tzlich einen Patch, der den tats√§chlichen Status der Ressource mit dem in Git geschriebenen synchronisiert (ein solcher Patch wird mit derselben synchronisierten Ressourcenregel wie oben beschrieben erstellt). <br><br>  Bei einer Rassynchronisierung erh√§lt der Benutzer am Ende der Bereitstellung eine WARNUNG mit der entsprechenden Meldung und dem entsprechenden Patch, die angewendet werden muss, um die Ressource in ein synchronisiertes Formular zu bringen.  Auch dieser Patch ist in einer speziellen Annotation <code>werf.io/repair-patch</code> .  Es wird davon ausgegangen, dass der Benutzer diesen Patch selbst mit den H√§nden anwendet: werf wird ihn grunds√§tzlich nicht anwenden. <br><br>  Das Generieren von Reparatur-Patches ist eine tempor√§re Ma√ünahme, mit der Sie die Erstellung von Patches nach dem Prinzip der 3-Wege-Zusammenf√ºhrung testen k√∂nnen, diese Patches jedoch nicht automatisch anwenden k√∂nnen.  Momentan ist diese Betriebsart standardm√§√üig aktiviert. <br><br><h3>  3-Wege-Merge-Patch nur f√ºr Neuerscheinungen </h3><br>  Ab dem 1. Dezember 2019 verwenden Beta- und Alpha-Versionen von werf <b>standardm√§√üig</b> vollwertige 3-Wege-Merge-Patches, um √Ñnderungen nur f√ºr neue Helm-Versionen anzuwenden, die √ºber werf eingef√ºhrt wurden.  In bestehenden Releases wird weiterhin der 2-Wege-Merge + Repair-Patch-Ansatz verwendet. <br><br>  Sie k√∂nnen diesen Betriebsmodus explizit <code>WERF_THREE_WAY_MERGE_MODE=onlyNewReleases</code> jetzt <code>WERF_THREE_WAY_MERGE_MODE=onlyNewReleases</code> . <br><br>  <i><b>Hinweis</b> : Die Funktion erschien in werf √ºber mehrere Releases: Im Alphakanal wurde sie ab Version <a href="">1.0.5-alpha.19</a> und im <a href="">Betakanal</a> mit Version <a href="">1.0.4-beta.20</a> <a href="">bereitgestellt</a> .</i> <br><br><h3>  3-Wege-Merge-Patch f√ºr alle Releases </h3><br>  Ab dem 15. Dezember 2019 verwenden die Beta- und Alpha-Versionen von werf standardm√§√üig vollwertige Patches f√ºr die 3-Wege-Zusammenf√ºhrung, um √Ñnderungen f√ºr alle Releases zu √ºbernehmen. <br><br>  Diese Betriebsart kann explizit <code>WERF_THREE_WAY_MERGE_MODE=enabled</code> indem <code>WERF_THREE_WAY_MERGE_MODE=enabled</code> jetzt <code>WERF_THREE_WAY_MERGE_MODE=enabled</code> . <br><br><h3>  Was ist mit Ressourcen f√ºr die automatische Skalierung zu tun? </h3><br>  Kubernetes bietet zwei Arten der automatischen Skalierung: HPA (horizontal) und VPA (vertikal). <br><br>  Horizontal w√§hlt automatisch die Anzahl der Replikate aus, vertikal die Anzahl der Ressourcen.  Sowohl die Anzahl der Replikate als auch die Ressourcenanforderungen werden im Ressourcenmanifest angegeben (siehe <code>spec.replicas</code> oder <code>spec.containers[].resources.limits.cpu</code> , <code>spec.containers[].resources.limits.memory</code> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">andere</a> ). <br><br>  Problem: Wenn ein Benutzer eine Ressource im Diagramm so konfiguriert, dass bestimmte Werte f√ºr Ressourcen oder Replikate angezeigt werden und f√ºr diese Ressource automatische Skalierer aktiviert sind, werden diese Werte bei jeder Bereitstellung auf die Werte zur√ºckgesetzt, die im Diagrammmanifest angegeben sind. <br><br>  Es gibt zwei L√∂sungen f√ºr das Problem.  F√ºr den Anfang ist es am besten, die explizite Angabe von Autoscale-Werten im Diagrammmanifest zu verwerfen.  Wenn diese Option aus irgendeinem Grund nicht passt (z. B. weil es bequem ist, die anf√§nglichen Ressourcenlimits und die Anzahl der Replikate im Diagramm festzulegen), bietet werf die folgenden Anmerkungen an: <br><br><ul><li> <code>werf.io/set-replicas-only-on-creation=true</code> </li> <li> <code>werf.io/set-resources-only-on-creation=true</code> </li> </ul><br>  Wenn eine solche Anmerkung vorhanden ist, setzt werf die entsprechenden Werte nicht bei jeder Bereitstellung zur√ºck, sondern legt sie nur beim erstmaligen Erstellen der Ressource fest. <br><br>  Weitere Informationen finden Sie in der Projektdokumentation f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HPA</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VPA</a> . <br><br><h3>  Verweigern Sie die Verwendung eines 3-Wege-Patches </h3><br>  Der Benutzer kann weiterhin die Verwendung neuer Patches in werf unter Verwendung der Umgebungsvariablen <code>WERF_THREE_WAY_MERGE_MODE=disabled</code> .  <b>Ab dem 1. M√§rz 2020 funktioniert dieses Verbot jedoch nicht mehr</b> und es k√∂nnen nur noch 3-Wege-Merge-Patches verwendet werden. <br><br><h2>  √úbernahme von Ressourcen in werf </h2><br>  Durch die Beherrschung der Methode zum Anwenden von √Ñnderungen in 3-Wege-Merge-Patches konnten wir eine Funktion wie die √úbernahme von Ressourcen, die im Cluster in der Helm-Version vorhanden sind, sofort implementieren. <br><br>  Helm 2 hat ein Problem: Sie k√∂nnen keine Ressource zu einem bereits im Cluster vorhandenen Diagrammmanifest hinzuf√ºgen, ohne diese Ressource von Grund auf neu zu erstellen (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="># 6031</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="># 3275</a> ).  Wir haben werf gelehrt, vorhandene Ressourcen in einer Version zu akzeptieren.  Dazu m√ºssen Sie in einem laufenden Cluster eine Anmerkung f√ºr die aktuelle Version der Ressource <code>kubectl edit</code> (z. B. mit <code>kubectl edit</code> ): <br><br><pre> <code class="plaintext hljs">"werf.io/allow-adoption-by-release": RELEASE_NAME</code> </pre> <br>  Nun muss die Ressource in der Tabelle beschrieben werden und bei der n√§chsten Bereitstellung durch die werf-Version der Version mit dem entsprechenden Namen wird die vorhandene Ressource in diese Version aufgenommen und bleibt unter ihrer Kontrolle.  Dar√ºber hinaus wird werf beim Akzeptieren der Ressource zur Freigabe den aktuellen Status der Ressource aus dem Arbeitscluster mit denselben 3-Wege-Merge-Patches und der synchronisierten Ressourcenregel in den im Diagramm beschriebenen Status versetzen. <br><br>  <i><b>Hinweis</b> : Die Einstellung von <code>WERF_THREE_WAY_MERGE_MODE</code> wirkt sich nicht auf die √úbernahme von Ressourcen aus. Im Falle einer √úbernahme wird immer ein 3-Wege-Merge-Patch verwendet.</i> <br><br>  Details finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> . <br><br><h2>  Schlussfolgerungen und Zukunftspl√§ne </h2><br>  Ich hoffe, dass nach diesem Artikel klarer wurde, was 3-Wege-Merge-Patches sind und warum sie zu ihnen gekommen sind.  Aus praktischer Sicht war die Implementierung des werf-Projekts ein weiterer Schritt zur Verbesserung des helmartigen Einsatzes.  Jetzt k√∂nnen Sie die Probleme bei der Konfigurationssynchronisierung vergessen, die bei der Verwendung von Helm 2 h√§ufig auftraten. Gleichzeitig wurde eine neue n√ºtzliche Funktion f√ºr die √úbernahme von Kubernetes-Ressourcen hinzugef√ºgt, die bereits in die Helm-Version hochgeladen wurden. <br><br>  Es gibt immer noch einige Probleme und Schwierigkeiten bei der helmartigen Bereitstellung, z. B. die Verwendung von Go-Vorlagen, und wir werden sie weiterhin l√∂sen. <br><br>  Informationen zu Ressourcenaktualisierungsmethoden und zur √úbernahme finden Sie auch auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser Dokumentationsseite</a> . <br><br><h3>  Helm 3 </h3><br>  Ein besonderer Hinweis verdient die k√ºrzlich ver√∂ffentlichte neue Hauptversion von Helm - v3 -, die ebenfalls 3-Wege-Merge-Patches verwendet und Tiller beseitigt.  Die neue Version von Helm erfordert die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Migration</a> vorhandener Installationen, um sie in ein neues Release-Speicherformat zu konvertieren. <br><br>  Werf seinerseits hat nun die Verwendung von Tiller beseitigt, auf 3-Wege-Zusammenf√ºhrung umgestellt und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">viel mehr</a> hinzugef√ºgt, wobei die Kompatibilit√§t mit vorhandenen Installationen auf Helm 2 erhalten bleibt (es sind keine Migrationsskripte erforderlich).  Bis werf auf Helm 3 umgestellt wird, verlieren werf-Benutzer daher nicht die Hauptvorteile von Helm 3 gegen√ºber Helm 2 (sie existieren auch in werf). <br><br>  Die Umstellung auf die Helm 3-Codebasis ist jedoch unumg√§nglich und wird in naher Zukunft erfolgen.  Vermutlich handelt es sich um werf 1.1 oder werf 1.2 (die Hauptversion von werf ist derzeit 1.0; weitere Informationen zum werf-Versionsger√§t finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ).  W√§hrend dieser Zeit hat Helm 3 Zeit, sich zu stabilisieren. <br><br><h2>  PS </h2><br>  Lesen Sie auch in unserem Blog: <br><br><ul><li>  Eine Reihe von Hinweisen zu Neuerungen in werf: <br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mit werf komplexe Helm-Charts ausrollen</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterst√ºtzung f√ºr monorepo und multirepo in werf und was hat die Docker Registry damit zu tun</a> "; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Msgstr</a> " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jetzt k√∂nnen Sie Docker - Images in werf mit der √ºblichen Docker - Datei erstellen</a> ." </li></ul></li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Werf ist unser CI / CD-Tool in Kubernetes (Rezension und Videobericht)</a> "; </li><li>  "Zusammenbau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">und Bereitstellung der gleichen Art von Microservices mit werf und GitLab CI</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wir stellen Helm 3 vor.</a> " </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de476646/">https://habr.com/ru/post/de476646/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de476626/index.html">PVS-Studio in den Wolken: GitLab CI / CD</a></li>
<li><a href="../de476628/index.html">PVS-Studio geht in die Cloud: GitLab CI / CD</a></li>
<li><a href="../de476636/index.html">Optimieren von Firebird und Linux f√ºr eine Datenbank mit einer Gr√∂√üe von 691 GB und mehr als 1000 Benutzern</a></li>
<li><a href="../de476640/index.html">Schutz von Zimbra OSE vor Brute-Force- und DoS-Angriffen</a></li>
<li><a href="../de476644/index.html">Sprachschichten</a></li>
<li><a href="../de476648/index.html">Lenovo auf der FINOPOLIS 2019</a></li>
<li><a href="../de476650/index.html">Der Ort der Aufz√§hlung in der sich ver√§ndernden Welt von heute</a></li>
<li><a href="../de476656/index.html">26. November Moskau - Alfa JS MeetUP # 3</a></li>
<li><a href="../de476658/index.html">VPS mit einer Grafikkarte (Teil 2): ‚Äã‚ÄãRechenf√§higkeiten</a></li>
<li><a href="../de476664/index.html">oktech: Frontend Meetup # 2: Sprecher-Mini-Interviews</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>