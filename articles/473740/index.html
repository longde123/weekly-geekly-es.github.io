<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìõ üí™ üêú CreateRemoteThread para Linux üë®üèº‚Äçüîß ü•© üë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="WinAPI tiene una funci√≥n CreateRemoteThread que le permite iniciar un nuevo hilo en el espacio de direcciones de otro proceso. Se puede usar para una ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>CreateRemoteThread para Linux</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473740/"><p><img src="https://habrastorage.org/webt/qu/fi/43/qufi43ym9g9-ptbmm43ajv-e_-4.jpeg" width="300" align="right" alt="Mitsuha trae nuevas transmisiones">  WinAPI tiene una funci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">CreateRemoteThread</a> que le permite iniciar un nuevo hilo en el espacio de direcciones de otro proceso.  Se puede usar para una variedad de inyecciones de DLL, tanto para fines malos (trucos en juegos, robo de contrase√±as, etc.) como para corregir un error en un programa en ejecuci√≥n sobre la marcha o agregar complementos a lugares donde no estaban proporcionado. </p><br><p>  En general, esta funci√≥n tiene una utilidad de aplicaci√≥n dudosa, por lo tanto, no es sorprendente que Linux no tenga un an√°logo listo de CreateRemoteThread.  Sin embargo, me preguntaba c√≥mo se puede implementar.  Estudiar el tema se convirti√≥ en una buena aventura. </p><br><p>  Hablar√© en detalle sobre c√≥mo, con la ayuda de la especificaci√≥n ELF, algunos conocimientos de arquitectura x86_64 y llamadas al sistema Linux, escribir su propio peque√±o depurador que pueda cargar y ejecutar c√≥digo arbitrario en un proceso que ya se est√° ejecutando y funciona. </p><br><p>  La comprensi√≥n del texto requerir√° conocimientos b√°sicos sobre la programaci√≥n del sistema para Linux: el lenguaje C, la escritura y los programas de depuraci√≥n, la comprensi√≥n del papel del c√≥digo de m√°quina y la memoria en la computadora, el concepto de llamadas al sistema, la familiaridad con las bibliotecas principales y la lectura de la documentaci√≥n. </p><a name="habracut"></a><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ideas principales</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bosquejo de la soluci√≥n</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Paso 1. Conexi√≥n al proceso</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Paso 2. Buscar bibliotecas en memoria</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Paso 3. Analizando im√°genes de la biblioteca ELF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Paso 4. Implementando el shellcode</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Paso 5. Comenzando un nuevo hilo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conclusi√≥n</a> </li></ul><br><p>  Como resultado, pude "agregar" la capacidad de obtener una vista previa de las contrase√±as en el Centro de control de Gnome: </p><br><p><img src="https://habrastorage.org/webt/0v/gu/we/0vguwedoumnnjh89zw5jtpaaltw.gif" alt="demostraci√≥n de inyecci√≥n en el Centro de Control de Gnomos"></p><br><h2 id="osnovnye-idei">  Ideas principales </h2><br><p>  Si no hubiera una cl√°usula en los requisitos sobre la carga del c√≥digo en un proceso que ya se est√° ejecutando, la soluci√≥n ser√≠a extremadamente simple: LD_PRELOAD.  Esta variable de entorno permite cargar una biblioteca arbitraria con la aplicaci√≥n.  En las bibliotecas compartidas, puede definir <em>funciones de constructor</em> que se ejecutan cuando se carga la biblioteca. </p><br><p>  Juntos, LD_PRELOAD y los constructores permiten ejecutar c√≥digo arbitrario en cualquier proceso utilizando un cargador din√°mico.  Esta es una caracter√≠stica relativamente conocida que se usa a menudo para la depuraci√≥n.  Por ejemplo, puede descargar su propia biblioteca con la aplicaci√≥n, que define las funciones malloc () y free (), que podr√≠an ayudar a detectar p√©rdidas de memoria. </p><br><p>  Desafortunadamente, LD_PRELOAD solo funciona cuando comienza el proceso.  No se puede usar para cargar una biblioteca en un proceso que ya se est√° ejecutando.  Hay una funci√≥n dlopen () para cargar bibliotecas mientras se ejecuta el proceso, pero, obviamente, el proceso en s√≠ debe llamarlo para cargar los complementos. </p><br><blockquote> <strong>Sobre ejecutables est√°ticos</strong> <br><br>  LD_PRELOAD solo funciona con programas que usan el cargador din√°mico.  Si el programa se cre√≥ con el <code>-static</code> , entonces incluye todas las bibliotecas necesarias.  En este caso, la resoluci√≥n de dependencias en las bibliotecas se realiza en el momento de la compilaci√≥n y el programa generalmente no est√° listo y no puede cargar din√°micamente las bibliotecas despu√©s del ensamblaje, en tiempo de ejecuci√≥n. <br><br>  En programas ensamblados est√°ticamente, puede incrustar c√≥digo en tiempo de ejecuci√≥n, pero esto debe hacerse de una manera ligeramente diferente.  Y esto no es del todo seguro, ya que el programa puede no estar listo para ese giro. </blockquote><p>  En general, no existe una soluci√≥n conveniente ya hecha, debe escribir su bicicleta.  De lo contrario, no leer√≠as este texto :) </p><br><p>  Conceptualmente, para forzar el proceso de otra persona para ejecutar alg√∫n tipo de c√≥digo, debe realizar las siguientes acciones: </p><br><ol><li>  Obtenga control en el proceso de destino. </li><li>  Cargue el c√≥digo en la memoria del proceso de destino. </li><li>  Prepare el c√≥digo descargado para su ejecuci√≥n en el proceso de destino. </li><li>  Organice la ejecuci√≥n del c√≥digo descargado por el proceso de destino. </li></ol><br><p>  Vamos ... </p><br><h3 id="poluchenie-upravleniya-v-processe">  Conseguir control en el proceso </h3><br><p>  En primer lugar, debemos subordinar el proceso objetivo a nuestra voluntad.  Despu√©s de todo, generalmente los procesos ejecutan solo su propio c√≥digo, o el c√≥digo de las bibliotecas cargadas, o los resultados de la compilaci√≥n JIT.  Pero ciertamente no es nuestro c√≥digo. </p><br><p>  Una opci√≥n es usar alg√∫n tipo de vulnerabilidad en el proceso que le permita tomar el control.  Un ejemplo cl√°sico de tutoriales: desbordamiento de b√∫fer, que permite reescribir la direcci√≥n de retorno en la pila.  Es divertido, a veces incluso funciona, pero no es adecuado para el caso general. </p><br><p>  Usaremos otra forma honesta para obtener el control: <em>depurar las llamadas del sistema</em> .  Los depuradores interactivos pueden detener perfectamente los procesos de terceros, evaluar expresiones y muchas otras cosas.  Ellos pueden, nosotros podemos. </p><br><p>  En Linux, la llamada principal del sistema de depuraci√≥n es <strong>ptrace ()</strong> .  Le permite conectarse a procesos, examinar su estado y controlar el progreso de su ejecuci√≥n.  ptrace () est√° bastante bien documentado por s√≠ solo, pero los detalles de su uso solo est√°n claros en la pr√°ctica. </p><br><h3 id="zagruzka-koda-v-pamyat-processa">  Cargando c√≥digo en la memoria de proceso </h3><br><p>  En el caso de desbordamientos del b√∫fer, la carga √∫til ( <em>c√≥digo de shell</em> ) generalmente se incluye en los contenidos que desbordan el mismo b√∫fer.  Cuando se usa el depurador, el c√≥digo necesario se puede escribir en la memoria del proceso directamente.  En WinAPI hay una funci√≥n especial WriteProcessMemory para esto.  Linux para este prop√≥sito cumple con la forma UNIX: para cada proceso en el sistema hay un archivo <strong>/ proc / $ pid / mem</strong> , que muestra la memoria de este proceso.  Es posible escribir algo en la memoria de proceso utilizando la entrada-salida habitual. </p><br><h3 id="podgotovka-koda-k-ispolneniyu">  Preparando c√≥digo para ejecuci√≥n </h3><br><p>  Simplemente escribir c√≥digo en la memoria no es suficiente.  Todav√≠a necesita escribirse <em>en la memoria ejecutable</em> .  En el caso de grabar a trav√©s de una vulnerabilidad, existen dificultades no triviales con esto, pero como podemos controlar completamente el proceso objetivo, no ser√° un problema para nosotros encontrar o asignar la memoria "correcta" para nosotros mismos. </p><br><p>  Otro punto importante de preparaci√≥n es el propio c√≥digo de shell.  En √©l, probablemente querremos usar algunas funciones de las bibliotecas, como entrada-salida, primitivas gr√°ficas, etc.  Sin embargo, tenemos que escribir el c√≥digo de m√°quina simple, que en s√≠ mismo no tiene idea de las direcciones de todas estas funciones interesantes en las bibliotecas.  ¬øDe d√≥nde los sacaste? </p><br><p>  Para simplificar la vida del sistema operativo y complicar la vida del c√≥digo malicioso, las bibliotecas generalmente no usan direcciones fijas (y contienen el llamado <em>c√≥digo independiente de la posici√≥n</em> ).  Entonces las direcciones no se pueden adivinar. </p><br><p>  Cuando el proceso comienza normalmente, el <em>cargador</em> que realiza las <em>reubicaciones</em> es responsable de determinar las direcciones exactas de las bibliotecas.  Sin embargo, solo cumple una vez al comienzo.  Si el proceso permite la carga din√°mica de bibliotecas, entonces hay un <em>cargador din√°mico</em> que puede hacer lo mismo mientras se ejecuta el proceso.  Sin embargo, la direcci√≥n del cargador din√°mico tampoco es fija. </p><br><p>  En general, con las bibliotecas, hay cuatro opciones: </p><br><ul><li>  no use bibliotecas en absoluto, haga todo en llamadas de sistema limpio </li><li>  poner copias de todas las bibliotecas necesarias en el c√≥digo de shell </li><li>  haz t√∫ mismo el trabajo del cargador din√°mico </li><li>  encuentra un gestor de arranque din√°mico y haz que cargue nuestras bibliotecas </li></ul><br><p>  Elegiremos este √∫ltimo, porque queremos las bibliotecas, y escribiremos nuestro cargador de arranque completo durante mucho tiempo.  Este no es el m√©todo m√°s reservado, ni el m√°s interesante, sino el m√°s simple, poderoso y confiable. </p><br><h3 id="peredacha-upravleniya-kodu">  Transferencia de control a c√≥digo </h3><br><p>  ptrace () le permite cambiar los registros del procesador, por lo que no deber√≠a haber problemas para transferir el control al c√≥digo cargado y preparado: simplemente escriba la direcci√≥n de nuestro c√≥digo en el registro% rip, ¬°y listo!  Sin embargo, en realidad, no todo es tan simple.  Las dificultades est√°n relacionadas con el hecho de que el proceso de depuraci√≥n en realidad no ha desaparecido y tambi√©n tiene alg√∫n tipo de c√≥digo que se ha ejecutado y continuar√° ejecut√°ndose. </p><br><h2 id="eskiz-resheniya">  Bosquejo de la soluci√≥n </h2><br><p>  Total, implementaremos nuestro flujo en un proceso de terceros de la siguiente manera: </p><br><ol><li>  Estamos conectados al proceso de destino para la depuraci√≥n. </li><li>  Encontramos las bibliotecas necesarias en la memoria: <br><ul><li>  libdl - para cargar una nueva biblioteca </li><li>  libpthread - para comenzar un nuevo hilo </li></ul></li><li>  Encontramos las funciones necesarias en las bibliotecas: <br><ul><li>  libdl: dlopen (), dlsym () </li><li>  libpthread: pthread_create (), pthread_detach () </li></ul></li><li><p>  Introducimos el c√≥digo de shell en la memoria del proceso de destino: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *payload = dlopen(<span class="hljs-string"><span class="hljs-string">"/path/to/payload.so"</span></span>, RTLD_LAZY); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *entry = dlsym(payload, <span class="hljs-string"><span class="hljs-string">"entry_point"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">pthread_t</span></span> thread; pthread_create(&amp;thread, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, entry, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); pthread_detach(thread); }</code> </pre> <br></li><li>  Damos el c√≥digo de shell para que se cumpla. </li></ol><br><p>  Como resultado, las bibliotecas har√°n lo correcto por nosotros: cargar√°n nuestra biblioteca con el c√≥digo que necesitamos en la memoria y comenzar√°n un nuevo hilo ejecutando este c√≥digo. </p><br><h3 id="ogranicheniya">  Limitaciones </h3><br><p>  El enfoque descrito anteriormente impone ciertas limitaciones: </p><br><ul><li>  El gestor de arranque debe tener privilegios suficientes para depurar el proceso de destino. </li><li>  El proceso debe usar libdl (listo para la carga din√°mica de m√≥dulos). </li><li>  El proceso debe usar libpthread (listo para subprocesamiento m√∫ltiple). </li><li>  Las aplicaciones est√°ticas no son compatibles. </li></ul><br><p>  Adem√°s, personalmente soy demasiado vago para molestarme con el soporte de todas las arquitecturas, por lo que nos limitaremos a x86_64.  (Incluso un x86 de 32 bits ser√≠a m√°s complicado). </p><br><p>  Como puede ver, todo esto pone fin al uso encubierto con objetivos maliciosos.  Sin embargo, la tarea a√∫n conserva el inter√©s de la investigaci√≥n e incluso deja una oportunidad d√©bil para uso industrial. </p><br><h3 id="otstuplenie-ob-ispolzovanii-libdl-i-libpthread">  Digresi√≥n: sobre el uso de libdl y libpthread </h3><br><p>  Un lector-lector experimentado puede preguntarse: ¬øpor qu√© requerir libdl si las funciones internas __libc_dlopen_mode () y __libc_dlsym () ya est√°n integradas en glibc, y libdl es solo una envoltura sobre ellas?  Del mismo modo, ¬øpor qu√© requerir libpthread si se puede crear f√°cilmente un nuevo hilo usando la llamada al sistema clone ()? </p><br><p>  De hecho, en Internet hay lejos de un ejemplo de c√≥mo se usan: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">https://github.com/gaffe23/linux-inject</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">https://github.com/TsarFox/hypodermic</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">http://hick.org/code/skape/papers/needle.txt</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">https://github.com/ice799/injectso64</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">http://www.ouah.org/subversiveld.pdf</a> </li></ul><br><p>  Incluso se mencionan en la literatura popular de hackers: </p><br><ul><li>  Aprendizaje del an√°lisis binario de Linux </li><li>  El arte de la memoria forense </li></ul><br><p>  Entonces, ¬øpor qu√© no?  Bueno, al menos porque no estamos escribiendo c√≥digo malicioso donde una soluci√≥n es adecuada que omite el 90% de las comprobaciones, ocupa 20 veces menos espacio, pero tambi√©n funciona en el 80% de los casos.  Adem√°s, quer√≠a probar todo con mis propias manos. </p><br><p>  De hecho, libdl no es <em>necesario</em> cargar la biblioteca en el caso de glibc.  Su uso por el proceso indica que est√° claramente listo para la carga din√°mica de c√≥digo.  A pesar de esto, en principio, puede negarse a usar libdl (dado que tambi√©n tendremos que buscar glibc m√°s adelante). </p><br><blockquote>  <strong>¬øPor qu√© dlopen () dentro de glibc?</strong> <br><br>  Esta es una pregunta interesante a su manera.  Respuesta corta: detalles de implementaci√≥n. <br><br>  El punto es el <em>conmutador de servicio de nombres</em> (NSS), una de las partes de glibc que proporciona traducci√≥n de varios nombres: nombres de m√°quinas, protocolos, usuarios, servidores de correo, etc. Es ella quien es responsable de funciones como getaddrinfo () para obtener direcciones IP mediante nombre de dominio y getpwuid () para obtener informaci√≥n sobre el usuario por su identificador num√©rico. <br><br>  NSS tiene una arquitectura modular y los m√≥dulos se cargan din√°micamente.  En realidad, para esto, glibc tambi√©n requer√≠a mecanismos para cargar bibliotecas din√°micamente.  Es por eso que cuando intenta utilizar getaddrinfo () en una aplicaci√≥n ensamblada est√°ticamente, el enlazador imprime una advertencia "incomprensible": <br><pre>
 /tmp/build/socket.o: en la funci√≥n `Socket :: bind ':
 socket.o :(. text + 0x374): advertencia: Uso de 'getaddrinfo' en enlaces est√°ticos
 las aplicaciones requieren en tiempo de ejecuci√≥n las bibliotecas compartidas de la versi√≥n glibc
 utilizado para vincular
</pre><br></blockquote><p>  En cuanto a los subprocesos, un subproceso generalmente no es solo una pila y un c√≥digo ejecutable, sino tambi√©n datos globales almacenados en <em>el almacenamiento local de subprocesos</em> (TLS).  La inicializaci√≥n correcta de un nuevo subproceso requiere la operaci√≥n coordinada del n√∫cleo del sistema operativo, un cargador de c√≥digo binario y un tiempo de ejecuci√≥n del lenguaje de programaci√≥n.  Por lo tanto, una simple llamada a clone () es suficiente para crear una secuencia que pueda escribir en el archivo "Hello world!", Pero esto puede no funcionar para un c√≥digo m√°s complejo que necesita acceso a TLS y otras cosas interesantes ocultas a los ojos del programador de la aplicaci√≥n. </p><br><p>  Otro punto relacionado con el subprocesamiento m√∫ltiple son los procesos de subproceso √∫nico.  ¬øQu√© sucede si creamos un nuevo hilo en un proceso que no fue concebido como multiproceso?  Correcto, comportamiento vago.  De hecho, en el proceso no hay sincronizaci√≥n de trabajo entre hilos, lo que tarde o temprano conducir√° a la corrupci√≥n de datos.  Si exigimos que la aplicaci√≥n use libpthread, entonces podemos estar seguros de que est√° lista para funcionar en un entorno de subprocesos m√∫ltiples (al menos deber√≠a estar lista). </p><br><h2 id="shag-1-podklyuchenie-k-processu">  Paso 1. Conexi√≥n al proceso </h2><br><p>  Primero, necesitamos conectarnos al proceso de destino para la depuraci√≥n, y luego, desconectarnos de nuevo.  Aqu√≠ es donde entra la llamada al sistema <em>ptrace</em> (). </p><br><h3 id="pervyy-kontakt-s-ptrace">  Primer contacto con ptrace () </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">En la documentaci√≥n de ptrace ()</a> puede encontrar casi toda la informaci√≥n necesaria: </p><br><pre>   Adjuntar y separar
        Se puede adjuntar un hilo al rastreador mediante la llamada<font></font>
<font></font>
            ptrace (PTRACE_ATTACH, pid, 0, 0);<font></font>
<font></font>
        o<font></font>
<font></font>
            ptrace (PTRACE_SEIZE, pid, 0, PTRACE_O_flags);<font></font>
<font></font>
        PTRACE_ATTACH env√≠a SIGSTOP a este hilo.  Si el trazador quiere esto
        SIGSTOP para no tener efecto, necesita suprimirlo.  Tenga en cuenta que si
        otras se√±ales se env√≠an simult√°neamente a este hilo durante la conexi√≥n, el
        el rastreador puede ver al traza ingresar se√±al-entrega-parada con otra se√±al
        nal (s) primero!  La pr√°ctica habitual es reinyectar estas se√±ales hasta
        Se ve SIGSTOP, luego suprima la inyecci√≥n de SIGSTOP.  El error de dise√±o
        aqu√≠ es que un archivo adjunto ptrace y un SIGSTOP entregado simult√°neamente
        carrera y el SIGSTOP concurrente pueden perderse.
</pre><br><p>  Entonces, el primer paso es usar PTRACE_ATTACH: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ptrace_attach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_ATTACH, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wait_for_process_stop(pid, SIGSTOP) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  Despu√©s de ptrace (), el proceso de destino no est√° listo para la depuraci√≥n.  Nos conectamos a √©l, pero para un estudio interactivo del estado del proceso, debe detenerse.  ptrace () env√≠a una se√±al SIGSTOP al proceso, pero a√∫n debemos esperar hasta que el proceso realmente se detenga. </p><br><p>  Para esperar, use la llamada al sistema <em>waitpid</em> ().  Al mismo tiempo, vale la pena se√±alar varios casos l√≠mite interesantes.  En primer lugar, el proceso puede simplemente terminar o morir sin haber recibido SIGSTOP.  En este caso, no podemos hacer nada.  En segundo lugar, alguna otra se√±al puede enviarse previamente al proceso.  En este caso, debemos dejar que el proceso lo procese (usando PTRACE_CONT), y a nosotros mismos, continuar esperando m√°s para nuestro SIGSTOP: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_for_process_stop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> expected_signal)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> status = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* ,    -  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (waitpid(pid, &amp;status, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*      ‚Äî   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WIFSIGNALED(status) || WIFEXITED(status)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   ,     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WIFSTOPPED(status)) { <span class="hljs-comment"><span class="hljs-comment">/* *  WSTOPSIG()   , *   ptrace()   *     . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stop_signal = status &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    ,    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stop_signal == expected_signal) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*        */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_CONT, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, stop_signal) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*   ‚Äî   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h3 id="otklyuchenie-ot-processa">  Desconexi√≥n del proceso </h3><br><p>  Detener el proceso de depuraci√≥n es mucho m√°s simple: solo use PTRACE_DETACH: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ptrace_detach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_DETACH, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  Estrictamente hablando, deshabilitar expl√≠citamente el depurador no siempre es necesario.  Cuando finaliza el proceso del depurador, se desconecta autom√°ticamente de todos los procesos depurados, y los procesos se reanudan si fueron detenidos por ptrace ().  Sin embargo, si el depurador detuvo expl√≠citamente el proceso de depuraci√≥n utilizando la se√±al SIGSTOP sin utilizar ptrace (), no se activar√° sin la se√±al SIGCONT o PTRACE_DETACH correspondiente.  Por lo tanto, es mejor desconectarse de los procesos culturalmente. </p><br><h3 id="nastroyka-ptrace_scope">  Configuraci√≥n de Ptrace_scope </h3><br><p>  El depurador tiene control total sobre el proceso que se est√° depurando.  Si alguien pudiera depurar algo, ¬øcu√°l ser√≠a la extensi√≥n del c√≥digo malicioso?  Es obvio que la depuraci√≥n interactiva es una actividad bastante espec√≠fica, generalmente necesaria solo para desarrolladores.  Durante el funcionamiento normal del sistema, la mayor√≠a de las veces no es necesario depurar procesos. </p><br><p>  Por estas razones, por razones de seguridad, los sistemas generalmente deshabilitan la capacidad de depurar cualquier proceso por defecto.  El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">m√≥dulo de seguridad de <strong>Yama</strong></a> es responsable de esto, administrado a trav√©s del archivo / proc / sys / kernel / yama / ptrace_scope.  Proporciona cuatro comportamientos: </p><br><ul><li>  0: el usuario puede depurar cualquier proceso que haya iniciado </li><li>  1 - modo predeterminado, solo se pueden depurar los procesos iniciados por el depurador </li><li>  2: solo un administrador del sistema ra√≠z puede depurar procesos </li><li>  3 - la depuraci√≥n est√° prohibida para todos, el modo no se apaga hasta que el sistema se reinicia </li></ul><br><p>  Obviamente, para nuestros prop√≥sitos, deber√° poder depurar los procesos que se iniciaron antes de nuestro depurador, por lo que para los experimentos deber√° cambiar el sistema al modo de desarrollo escribiendo 0 en un archivo especial ptrace_scope (que requiere derechos de administrador): </p><br><pre> <code class="plaintext hljs">$ sudo sh -c 'echo 0 &gt; /proc/sys/kernel/yama/ptrace_scope'</code> </pre> <br><p>  o ejecute el depurador como administrador: </p><br><pre> <code class="plaintext hljs">$ sudo ./inject-thread ...</code> </pre> <br><h3 id="rezultaty-pervogo-shaga">  Resultados del primer paso </h3><br><p>  Como resultado, en el primer paso, podemos conectarnos al proceso de destino como depurador y luego desconectarnos de √©l. </p><br><p>  El proceso de destino se detendr√° y podemos asegurarnos de que el sistema operativo realmente nos vea como un depurador: </p><br><pre> <code class="plaintext hljs">$ sudo ./inject-thread --target $(pgrep docker) $ cat /proc/$(pgrep docker)/status | head Name: docker State: t (tracing stop) &lt;---    Tgid: 31330 Ngid: 0 Pid: 31330 PPid: 1 TracerPid: 2789 &lt;--- PID   Uid: 0 0 0 0 Gid: 0 0 0 0 FDSize: 64 $ ps a | grep [2]789 2789 pts/5 S+ 0:00 ./inject-thread --target 31330</code> </pre> <br><h2 id="shag-2-poisk-bibliotek-v-pamyati">  Paso 2. Buscar bibliotecas en memoria </h2><br><p>  El siguiente paso es m√°s simple: necesita encontrar en la memoria del proceso de destino la biblioteca con las funciones que necesitamos.  Pero hay mucha memoria, ¬øpor d√≥nde empezar a buscar y qu√© exactamente? </p><br><h3 id="fayl-procpidmaps">  Archivo / proc / $ pid / maps </h3><br><p>  Un archivo especial nos ayudar√° con esto, a trav√©s del cual el n√∫cleo informa sobre qu√© y d√≥nde se encuentra el proceso en la memoria.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Como sabe</a> , en el directorio / proc para cada proceso hay un subdirectorio.  Y hay un archivo que describe <em>la tarjeta de memoria de</em> proceso: </p><br><pre> $ cat / proc / self / maps
 00400000-0040c000 r-xp 00000000 fe: 01 1044592 / bin / cat
 0060b000-0060c000 r - p 0000b000 fe: 01 1044592 / bin / cat
 0060c000-0060d000 rw-p 0000c000 fe: 01 1044592 / bin / cat
 013d5000-013f6000 rw-p 00000000 00:00 0 [mont√≥n]
 7f9920bd1000-7f9920d72000 r-xp 00000000 fe: 01 920019 /lib/x86_64-linux-gnu/libc-2.19.so
 7f9920d72000-7f9920f72000 --- p 001a1000 fe: 01 920019 /lib/x86_64-linux-gnu/libc-2.19.so
 7f9920f72000-7f9920f76000 r - p 001a1000 fe: 01 920019 /lib/x86_64-linux-gnu/libc-2.19.so
 7f9920f76000-7f9920f78000 rw-p 001a5000 fe: 01 920019 /lib/x86_64-linux-gnu/libc-2.19.so
 7fc3f8381000-7fc3f8385000 rw-p 00000000 00:00 0
 7fc3f8385000-7fc3f83a6000 r-xp 00000000 fe: 01 920012 /lib/x86_64-linux-gnu/ld-2.19.so
 7fc3f83ec000-7fc3f840e000 rw-p 00000000 00:00 0
 7fc3f840e000-7fc3f8597000 r - p 00000000 fe: 01 657286 / usr / lib / locale / locale-archive
 7fc3f8597000-7fc3f859a000 rw-p 00000000 00:00 0
 7fc3f85a3000-7fc3f85a5000 rw-p 00000000 00:00 0
 7fc3f85a5000-7fc3f85a6000 r - p 00020000 fe: 01 920012 /lib/x86_64-linux-gnu/ld-2.19.so
 7fc3f85a6000-7fc3f85a7000 rw-p 00021000 fe: 01 920012 /lib/x86_64-linux-gnu/ld-2.19.so
 7fc3f85a7000-7fc3f85a8000 rw-p 00000000 00:00 0
 7ffdb6f0e000-7ffdb6f2f000 rw-p 00000000 00:00 0 [pila]
 7ffdb6f7f000-7ffdb6f81000 r-xp 00000000 00:00 0 [vdso]
 7ffdb6f81000-7ffdb6f83000 r - p 00000000 00:00 0 [vvar]
 ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0 [vsyscall]
</pre><br><p>  El n√∫cleo del sistema operativo genera el contenido de este archivo sobre la marcha a partir de estructuras internas que describen las regiones de memoria del proceso que nos interesa y contiene la siguiente informaci√≥n: </p><br><ul><li>  rango de direcciones asignado a la regi√≥n </li><li>  derechos de acceso a la regi√≥n <br><ul><li>  <code>r/-</code> : leer </li><li>  <code>w/-</code> : escribir </li><li>  <code>x/-</code> : ejecuci√≥n </li><li>  <code>p/s</code> : compartir memoria con otros procesos </li></ul></li><li>  desplazamiento de archivo (si lo hay) </li><li>  c√≥digo del dispositivo donde se encuentra el archivo mostrado </li><li>  n√∫mero de inodo de archivo (si lo hay) </li><li>  ruta al archivo mostrado (si lo hay) </li></ul><br><p>  Algunas regiones de la memoria se asignan a archivos: cuando un proceso lee dicha memoria, en realidad lee los datos de los archivos correspondientes en un desplazamiento espec√≠fico.  Si puede escribir en una regi√≥n, entonces los cambios en la memoria pueden ser visibles solo para el proceso en s√≠ (mecanismo de <em>copia en escritura</em> , el modo <code>p</code> es privado) o sincronizados con el disco ( <code>s</code> modo <code>s</code> es compartido). </p><br><p>  Otras regiones son <em>an√≥nimas</em> : esta memoria no corresponde a ning√∫n archivo.  El sistema operativo simplemente le da al proceso una pieza de memoria f√≠sica que utiliza.  Dichas regiones se utilizan, por ejemplo, para la memoria de proceso "normal": pila y mont√≥n.  Las regiones an√≥nimas pueden ser personales para un proceso o compartidas entre varios procesos (mecanismo de <em>memoria compartida</em> ). </p><br><p>  Adem√°s, hay varias regiones especiales en la memoria marcadas con los seud√≥nimos [vdso] y [vsyscall].  Se utilizan para optimizar algunas llamadas al sistema. </p><br><p>  Estamos interesados ‚Äã‚Äãen las regiones donde se muestran los contenidos de los archivos de la biblioteca.  Si leemos la tarjeta de memoria y filtramos las entradas por el nombre del archivo que se muestra, encontraremos todas las direcciones ocupadas por las bibliotecas que necesitamos.  El formato de la tarjeta de memoria es especialmente conveniente para el procesamiento del programa y se entiende f√°cilmente utilizando las funciones de la familia scanf (): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_proc_line</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *line, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *library, struct memory_region *region)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> vaddr_low = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> vaddr_high = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> read = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> write = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> execute = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> path_offset = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    /proc/$pid/maps */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sscanf</span></span>(line, <span class="hljs-string"><span class="hljs-string">"%lx-%lx %c%c%c%*c %*lx %*x:%*x %*d %n"</span></span>, &amp;vaddr_low, &amp;vaddr_high, &amp;read, &amp;write, &amp;execute, &amp;path_offset); <span class="hljs-comment"><span class="hljs-comment">/* ,       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>(line + path_offset, library)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*           */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region) { region-&gt;vaddr_low = vaddr_low; region-&gt;vaddr_high = vaddr_high; region-&gt;readable = (read == <span class="hljs-string"><span class="hljs-string">'r'</span></span>); region-&gt;writeable = (write == <span class="hljs-string"><span class="hljs-string">'w'</span></span>); region-&gt;executable = (execute == <span class="hljs-string"><span class="hljs-string">'x'</span></span>); region-&gt;content = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3 id="tayna-tretey-planety">    </h3><br><p>      ,  libc-2.19.so,     : </p><br><p><img src="https://habrastorage.org/webt/vf/lw/4m/vflw4m5jy3pwtbcxu0foudxnh3o.png" alt="agujero en libc-2.19.so"></p><br><p>        2   -    ?  51?   ?  ? </p><br><p> ,    ,          . </p><br><p>  ,     <em></em>   ,         .  <em> </em>         ,    ,   ,           (, ,        ). </p><br><p>      ,  <em></em> (  4  ).    ,            . </p><br><p>  ,           .       ‚Äî    ‚Äî      .           2    ‚Äî   ,        ( x86_64    4 , 2 , 1 ).                  . </p><br><h3 id="rezultaty-vtorogo-shaga">    </h3><br><p>     ,          : </p><br><ul><li>  libdl: dlopen()  dlsym() </li><li>  libpthread: pthread_create()  pthread_detach() </li></ul><br><p>    ,       ,   .      Linux       ( <em>address space layout randomization</em> , ASLR).        (- ,     ),             ‚Äî    - . </p><br><p>       ,           ,      ,     /proc/$pid/maps.     ,          . </p><br><h2 id="shag-3-razbor-elf-obrazov-bibliotek">  3.  ELF-  </h2><br><p> ,      ,        ,   . </p><br><p>   : </p><br><pre> <code class="plaintext hljs">$ nm -D /lib/x86_64-linux-gnu/libdl-2.19.so | grep dlopen 0000000000001090 T dlopen</code> </pre> <br><p>  <em>nm</em>             .                . </p><br><p>   -  ,      nm     ,        .  ,      dlsym(). </p><br><h3 id="chtenie-pamyati-celevogo-processa">     </h3><br><p>   ‚Äî    ELF-,    .        procfs.    UNIX way,         <strong>/proc/$pid/mem</strong> ,    ‚Äî      (     /proc/$pid/maps). </p><br><p>   Linux           mmap(),         (    ,   ).            : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map_region</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, struct memory_region *region)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> length = region-&gt;vaddr_high - region-&gt;vaddr_low; <span class="hljs-keyword"><span class="hljs-keyword">off_t</span></span> offset = region-&gt;vaddr_low; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> path[<span class="hljs-number"><span class="hljs-number">32</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">snprintf</span></span>(path, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(path), <span class="hljs-string"><span class="hljs-string">"/proc/%d/mem"</span></span>, pid); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd = open(path, O_RDONLY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fd &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *buffer = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!buffer) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error_close_file; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (read_region(fd, offset, buffer, length) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error_free_buffer; region-&gt;content = buffer; close(fd); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; error_free_buffer: <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(buffer); error_close_file: close(fd); error: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_region</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">off_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *buffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lseek(fd, offset, SEEK_SET) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> remaining = length; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ptr = buffer; <span class="hljs-comment"><span class="hljs-comment">/* *     .   , *      ,  . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (remaining &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> count = read(fd, ptr, remaining); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; remaining -= count; ptr += count; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>      ELF- .    , -,       ,  -,       . </p><br><h3 id="dvulikiy-elf">  ELF </h3><br><p>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">   ELF</a> ‚Äî         Linux.      ,    ,      . </p><br><p>      ELF   .    ELF    <em></em>    .    ‚Äî   <em></em> ,        .      ,  ‚Äî    .        ELF-. </p><br><p> ,   libdl-2.19.so  : </p><br><p><img src="https://habrastorage.org/webt/at/zw/up/atzwupwipysw3kip1yx95aa-eps.png" alt="secciones y segmentos libdl-2.19.so"></p><br><p> (          <code>readelf --headers</code> .) </p><br><p>   ,    ,   (29  9).    ‚Äî    ,           ,     .  ELF ‚Äî    ,      .  Linux, ,    LOAD,      (     ). </p><br><p>   ELF-     ,         . ,       . </p><br><p>       ,   . ¬´¬ª    .     .bss,   ,      (    ). </p><br><p>  ,   ELF     ‚Äî  ,     .       ... </p><br><h3 id="gde-lezhit-tablica-simvolov">    ? </h3><br><p>          ()   .        ,     dlsym(),       .  -   . </p><br><p>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"> ELF</a> (. 2-10).   ,        <strong>.dynamic</strong> ,     <strong>DYNAMIC</strong> .   .dynamic     ,  : </p><br><ul><li> <strong>.dynsym</strong> ‚Äî     ; </li><li> <strong>.dynstr</strong> ‚Äî     ; </li><li> <strong>.hash</strong> ‚Äî -,   . </li></ul><br><p>    ,     ,       ELF: </p><br><p><img src="https://habrastorage.org/webt/yw/y9/7d/ywy97dqzszhxz1jmoe45851oebe.png" alt="B√∫squeda de segmento DIN√ÅMICO"></p><br><p>     ELF,      (1),      (2),      (3),      (4) <del>  ,    </del>  . </p><br><h4 id="zagolovok-elf--tablica-segmentov">  ELF ‚Üí   </h4><br><p> ()   ELF      &lt;elf.h&gt;, ,   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"> </a> .   ,  ELF ‚Äî      .    32-  64- ,      ,      ,   .          x86_64,    ELF  . </p><br><p>  ELF-    ( <strong>Elf64_Ehdr</strong> ).          ( <em>program headers</em> ),    <strong>e_phoff</strong>  <strong>e_phnum</strong> : </p><br><p><img src="https://habrastorage.org/webt/1z/al/rn/1zalrn30vwfxce_smmy4vylj55g.png" alt="Encabezado ELF"></p><br><p>   ‚Äî    ,   ,  ELF-   ‚Äî     ,    ,     ,  ,    . </p><br><p>        e_phoff,       ,      .    e_phnum   e_phentsize  . </p><br><p>    (   ),        ELF ‚Äî    64 . </p><br><h4 id="tablica-segmentov--segment-dynamic">   ‚Üí  DYNAMIC </h4><br><p>      .   ‚Äî      <strong>Elf64_Phdr</strong> ( 64- ELF-),   .      <strong>PT_DYNAMIC</strong>   <strong>p_type</strong> : </p><br><p><img src="https://habrastorage.org/webt/i0/rg/cp/i0rgcpji9bl9wbsvegzrree9zfm.png" alt="Tabla de segmentos ELF"></p><br><p>          : </p><br><ul><li> <strong>p_vaddr</strong> ‚Äî   ,    ; </li><li> <strong>p_memsz</strong> ‚Äî      . </li></ul><br><p>     .dynamic      0x2D88 (     ).        DYNAMIC     ‚Äî   0x202D88.    0x210 (8448) .                . </p><br><h4 id="segment-dynamic--sekcii-dynsym-dynstr-hash">  DYNAMIC ‚Üí  .dynsym, .dynstr, .hash </h4><br><p>  .dynamic,    DYNAMIC,      .       <strong>Elf64_Dyn</strong> ,   : </p><br><p><img src="https://habrastorage.org/webt/dd/jp/th/ddjpthosvl8irw8ekelw0bdkaug.png" alt="Etiquetas de secci√≥n DIN√ÅMICAS"></p><br><p>    8     <strong>d_val</strong>  <strong>d_ptr</strong> ,   8-  <strong>d_tag</strong> ,  ,    .      : </p><br><ul><li> <strong>DT_HASH</strong> (4) ‚Äî    .hash ( d_ptr) </li><li> <strong>DT_STRTAB</strong> (5) ‚Äî    .dynstr ( d_ptr) </li><li> <strong>DT_SYMTAB</strong> (6) ‚Äî    .dynsym ( d_ptr) </li><li> <strong>DT_STRSZ</strong> (10) ‚Äî     .dynstr ( d_val) </li><li> <strong>DT_NULL</strong> (0) ‚Äî     </li></ul><br><p>       .     .dynamic     :  ,   ,    ,    . </p><br><p>    ,   DYNAMIC   <em></em>          ,    .      ,            ,  - ,   . </p><br><p>    .dynamic         ,          . -,   .dynstr   ,      ?     . </p><br><h3 id="poisk-funkciy-v-biblioteke">     </h3><br><p>            .     ,    <strong>.dynsym</strong>   ,        . (  ¬´¬ª   .symtab,      , ,  .    .) </p><br><h4 id="tablica-simvolov">   </h4><br><p>      <strong>Elf64_Sym</strong> ,        ELF ‚Äî , , , .       <code>dlopen</code> : </p><br><p><img src="https://habrastorage.org/webt/pd/5_/qh/pd5_qhcculmqmjk7p6krar1czjy.png" alt="Tabla de caracteres ELF"></p><br><p>      : </p><br><ul><li> <strong>st_name</strong> ‚Äî  ,       </li><li> <strong>st_info</strong> ‚Äî     (   ) </li><li> <strong>st_value</strong> ‚Äî     </li></ul><br><p> (  ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  nm</a>   ,  dlopen()     .text,   0x1090   .) </p><br><p>     ,       . </p><br><h4 id="tablica-strok">   </h4><br><p>   ‚Äî     - ,    .            (   ).        <strong>.dynstr</strong> ,      libdl-2.19.so  : </p><br><p><img src="https://habrastorage.org/webt/mg/b9/1v/mgb91vjtwrr_kqrncnrojgg6jum.png" alt="Mesa de fila ELF"></p><br><p> ,           ( ¬´dlopen¬ª,   0xA5)      ,    .        . </p><br><h4 id="hesh-tablica"> - </h4><br><p>  <strong>.hash</strong>  <em>-</em> ,       .   - ‚Äî    ‚Äî      ELF-,       . ,         .dynsym,       ,      .   ( )     - . </p><br><p>  -      &lt;elf.h&gt;,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"> </a> (. 2-19).   -   ,   : </p><br><p><img src="https://habrastorage.org/webt/ez/a3/ku/eza3ku71zydhqm_e3je0xbtjec8.png" alt="tabla hash ELF"></p><br><p>  donde </p><br><ul><li> nbuckets ‚Äî    buckets </li><li> nchains ‚Äî    chains (  ) </li><li> buckets ‚Äî      </li><li> chains ‚Äî      </li></ul><br><p>  -  : </p><br><ol><li>   <strong>h</strong>    . </li><li>   <strong>i</strong>  <code>buckets[h % nbuckets]</code> ,     . </li><li>      (     )  ,   . </li><li>    ‚Äî  <code>chains[i % nchains]</code> . </li><li>   3‚Äî4           ,       . </li></ol><br><p>  -,  ELF: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">elf_hash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> h = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> g; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (*name) { h = (h &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) + *name++; g = h &amp; <span class="hljs-number"><span class="hljs-number">0xF0000000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (g) h ^= g &gt;&gt; <span class="hljs-number"><span class="hljs-number">24</span></span>; h &amp;= ~g; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> h; }</code> </pre> <br><p> ,   <code>"dlopen"</code> -   112420542     : </p><br><p><img src="https://habrastorage.org/webt/zu/ch/4i/zuch4ibwuspxmog6_erhbq1evyg.png" alt="buscar un personaje en una biblioteca"></p><br><p> libdl ‚Äî    ,    39   ,      .  -           . </p><br><h3 id="rezultaty-tretego-shaga">    </h3><br><p>              ,          : </p><br><ul><li> dlopen()  dlsym()   libdl </li><li> pthread_create()  pthread_detach()   libpthread </li></ul><br><p>   ,    . </p><br><p>         .            .      ,       . </p><br><p>     ELF-    .       ,      (  ).        ,    . ,    ,     .               . </p><br><h2 id="shag-4-vnedrenie-shell-koda">  4.  - </h2><br><p>   ,    ,    <em>-</em> ,     :         ,   .   -  . </p><br><h3 id="soderzhimoe-shell-koda">  - </h3><br><p> ,   -: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *payload = dlopen(<span class="hljs-string"><span class="hljs-string">"/path/to/payload.so"</span></span>, RTLD_LAZY); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*entry)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) = dlsym(payload, <span class="hljs-string"><span class="hljs-string">"entry_point"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">pthread_t</span></span> thread; pthread_create(&amp;thread, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, entry, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); pthread_detach(thread); }</code> </pre> <br><p>       ? </p><br><p> ,        ‚Äî   .    ,     ,      ,       -  ‚Äî  -     !    . </p><br><p>    ‚Äî   -  .         ,    ,           :        . </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* *      .rodata:   * .         , *        . */</span></span> .section .rodata <span class="hljs-comment"><span class="hljs-comment">/* *   .       . *      -:    ,  *  ,       . */</span></span> .global shellcode_start .global shellcode_address_dlopen .global shellcode_address_dlsym .global shellcode_address_pthread_create .global shellcode_address_pthread_detach .global shellcode_address_payload .global shellcode_address_entry .global shellcode_end <span class="hljs-comment"><span class="hljs-comment">/* *   dlopen().     #include &lt;dlfcn.h&gt;, *       . */</span></span> .set RTLD_LAZY, <span class="hljs-number"><span class="hljs-number">1</span></span> .align <span class="hljs-number"><span class="hljs-number">8</span></span> shellcode_start: <span class="hljs-comment"><span class="hljs-comment">/* * void *payload = dlopen(shellcode_address_payload, RTLD_LAZY); * *        x86_64: * * -     %rdi, %rsi, %rdx, %rcx * -     %rax * -      * *         . * *       %rax,    *     . */</span></span> lea shellcode_address_payload(%rip),%rdi mov $RTLD_LAZY,%rsi mov shellcode_address_dlopen(%rip),%rax callq *%rax <span class="hljs-comment"><span class="hljs-comment">/* * void (*entry)(void) = dlsym(payload, shellcode_address_entry); */</span></span> mov %rax,%rdi lea shellcode_address_entry(%rip),%rsi mov shellcode_address_dlsym(%rip),%rax callq *%rax <span class="hljs-comment"><span class="hljs-comment">/* * pthread_t thread; * pthread_create(&amp;thread, NULL, entry, NULL); * *            * ,     pthread_create(). */</span></span> sub $<span class="hljs-number"><span class="hljs-number">8</span></span>,%rsp mov %rsp,%rdi xor %rsi,%rsi mov %rax,%rdx xor %rcx,%rcx mov shellcode_address_pthread_create(%rip),%rax callq *%rax <span class="hljs-comment"><span class="hljs-comment">/* * pthread_detach(thread); * *    ,   ,  *     . */</span></span> mov (%rsp),%rdi add $<span class="hljs-number"><span class="hljs-number">8</span></span>,%rsp mov shellcode_address_pthread_detach(%rip),%rax callq *%rax <span class="hljs-comment"><span class="hljs-comment">/* *   - ‚Äî    ,     *      ret.    *     ,  *      . */</span></span> int $<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-comment"><span class="hljs-comment">/* *       ,   *   ,    - *     .   ‚Äú  *  ‚Äù (global offset table, GOT),   *           . */</span></span> .align <span class="hljs-number"><span class="hljs-number">8</span></span> shellcode_address_dlopen: .space <span class="hljs-number"><span class="hljs-number">8</span></span> shellcode_address_dlsym: .space <span class="hljs-number"><span class="hljs-number">8</span></span> shellcode_address_pthread_create: .space <span class="hljs-number"><span class="hljs-number">8</span></span> shellcode_address_pthread_detach: .space <span class="hljs-number"><span class="hljs-number">8</span></span> shellcode_address_payload: .space <span class="hljs-number"><span class="hljs-number">256</span></span> shellcode_address_entry: .space <span class="hljs-number"><span class="hljs-number">256</span></span> <span class="hljs-comment"><span class="hljs-comment">/* *  - . */</span></span> shellcode_end: .end</code> </pre> <br><p> ,   .      : </p><br><pre> <code class="plaintext hljs">$ as -o shellcode.o shellcode.S</code> </pre> <br><p>  ,      ,  ,   .            :   <em>  </em> (procedure linkage table, PLT),        . </p><br><p>     -    ,         (, )       .  <em>-</em>  <em></em> . </p><br><h3 id="razmeschenie-shell-koda-v-pamyati">  -   </h3><br><p>     <em>-</em>    . ,       ,   ,          .      ? </p><br><h4 id="trebovaniya-k-pamyati-pod-shell-kod">     - </h4><br><p>      ,       .      <em></em> ,       .    ,         .         ,       . </p><br><p>              (-  ),         :   ,    ,    . , ,   JIT-   ,       .    ? </p><br><h4 id="podhody-k-razmescheniyu-v-pamyati">      </h4><br><p>         : </p><br><ul><li>  -  ,     </li><li>   - ,    </li></ul><br><p>      ,  . -,    - ,     . -,       . -,      ,  -    -,     . </p><br><p>   ,      .     .  x86_64  <code>int $3</code>     ‚Äî 0xCC ‚Äî          .  ptrace()         PTRACE_POKETEXT ‚Äî ,     8   , . ,          ,     . </p><br><p> ,  ,   ,       :        .     -       ,  . </p><br><h4 id="kak-vydelit-novuyu-pamyat">    ? </h4><br><p>  ,  !    malloc()! </p><br><p> .      ,      -,    .       .          ,     mmap(): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject_shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *shellcode_src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shellcode_size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *shellcode_dst = mmap(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, shellcode_size, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANONYMOUS | MAP_PRIVATE, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); copy_shellcode(shellcode_dst, shellcode_src, shellcode_size); }</code> </pre> <br><p>  ,   ptrace()         ,     . </p><br><h3 id="vypolnenie-sistemnyh-vyzovov">    </h3><br><p>      ,     ?    ,            . Linux  x86_64   : </p><br><ul><li>       %rax </li><li>    ‚Äî    ‚Äî      %rsi, %rdi, %rdx, %r10, %r8, %r9 </li><li>   SYSCALL,     </li><li>       %rax </li></ul><br><p>  ptrace()           PTRACE_GETREGS  PTRACE_SETREGS.  ,        .   -   SYSCALL. </p><br><p>     :      ,       %rip.   ,   ,   SYSCALL. </p><br><h4 id="poisk-instrukcii-syscall">   SYSCALL </h4><br><p>    SYSCALL? ,    .   -   ,   <em>-</em>      .    ‚Äî   libc.  ,  ,      ,   : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_syscall_instruction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct library *library)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; library-&gt;region_count; i++) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">memory_region</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">region</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">library</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">regions</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class">];</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(region-&gt;readable &amp;&amp; region-&gt;executable)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *region_data = region-&gt;content; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> region_size = region-&gt;vaddr_high - region-&gt;vaddr_low; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region_size &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* * 0F 05 syscall */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> offset = <span class="hljs-number"><span class="hljs-number">0</span></span>; offset &lt; region_size - <span class="hljs-number"><span class="hljs-number">1</span></span>; offset++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region_data[offset + <span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-number"><span class="hljs-number">0x0F</span></span> &amp;&amp; region_data[offset + <span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-number"><span class="hljs-number">0x05</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> region-&gt;vaddr_low + offset; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>        , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  /proc/$pid/maps</a> .  x86_64     ,    -   .     <em></em>   ,    0x0F 0x05.     , ,  ARM,       0xDF 0x00 ( SVC #0),  <em>  </em> . </p><br><h4 id="ispolzovanie-ptrace_getsetregs">  PTRACE_{GET,SET}REGS </h4><br><p>      : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_registers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, struct user_regs_struct *registers)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_GETREGS, pid, registers, registers) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) err = -errno; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; }</code> </pre> <br><p>     <code>struct user_regs_struct</code> ,    &lt;sys/user.h&gt;.     .          .     ,        <em>varargs</em> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_regs_for_syscall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct user_regs_struct *registers, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> syscall_insn_vaddr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> syscall_number, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> args_count, va_list args)</span></span></span><span class="hljs-function"> </span></span>{ registers-&gt;rip = syscall_insn_vaddr; registers-&gt;rax = syscall_number; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; args_count; i++) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (i) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: registers-&gt;rdi = va_arg(args, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: registers-&gt;rsi = va_arg(args, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: registers-&gt;rdx = va_arg(args, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: registers-&gt;r10 = va_arg(args, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: registers-&gt;r8 = va_arg(args, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>: registers-&gt;r9 = va_arg(args, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -E2BIG; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perform_syscall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> syscall_insn_vaddr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> syscall_number, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> args_count, ...)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user_regs_struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">old_registers</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user_regs_struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new_registers</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* *    ,   *      . */</span></span> get_registers(pid, &amp;old_registers); <span class="hljs-comment"><span class="hljs-comment">/* *      ,   * ,     . */</span></span> new_registers = old_registers; va_list args; va_start(args, args_count); set_regs_for_syscall(&amp;new_registers, syscall_insn_vaddr, syscall_number, args_count, args); va_end(args); set_registers(pid, &amp;new_registers); <span class="hljs-comment"><span class="hljs-comment">/* *    ,    *   ,    * (  ),    . *     . */</span></span> wait_for_syscall_completion(pid); <span class="hljs-comment"><span class="hljs-comment">/* *       *    . *        . */</span></span> get_registers(pid, &amp;new_registers); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> result = new_registers.rax; set_registers(pid, &amp;old_registers); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><h4 id="ispolzovanie-ptrace_syscall">  PTRACE_SYSCALL </h4><br><p>       :        ,    ? </p><br><p>      PTRACE_SYSCALL.   PTRACE_CONT,     .   ,    - :    ,    . </p><br><p> PTRACE_SYSCALL    SIGTRAP    :      (     )       (      ).  , ptrace()   ,          ,         . </p><br><p>  ,           SIGTRAP: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_for_syscall_enter_exit_stop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_SYSCALL, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wait_for_process_stop(pid, SIGTRAP) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_for_syscall_completion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ wait_for_syscall_enter_exit_stop(pid); wait_for_syscall_enter_exit_stop(pid); }</code> </pre> <br><p>   ‚Äî   ,    ‚Äî       (wait_for_process_stop() <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> ).           .       ,     . </p><br><h4 id="opciya-ptrace_o_tracesysgood">  PTRACE_O_TRACESYSGOOD </h4><br><p>   , PTRACE_SYSCALL      :       ,   ,  -  .  ,      SIGTRAP       (    ). </p><br><p>     SIGTRAP       <em></em> .        PTRACE_O_TRACESYSGOOD,            : </p><br><ul><li> SIGTRAP ‚Äî -     </li><li> SIGTRAP | 0x80 ‚Äî     </li></ul><br><pre> <code class="diff hljs"> int ptrace_attach(pid_t pid) { if (ptrace(PTRACE_ATTACH, pid, 0, 0) &lt; 0) return -1; if (wait_for_process_stop(pid, SIGSTOP) &lt; 0) return -1; + /*     */ + unsigned long options = PTRACE_O_TRACESYSGOOD; + if (ptrace(PTRACE_SETOPTIONS, pid, 0, options) &lt; 0) + return -1; return 0; } static int wait_for_syscall_enter_exit_stop(pid_t pid) { if (ptrace(PTRACE_SYSCALL, pid, 0, 0) &lt; 0) return -1; - if (wait_for_process_stop(pid, SIGTRAP) &lt; 0) + if (wait_for_process_stop(pid, SIGTRAP | 0x80) &lt; 0) return -1; return 0; }</code> </pre> <br><h3 id="zagruzka-shell-koda-v-pamyat">  -   </h3><br><p> -       : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_text[SHELLCODE_TEXT_SIZE]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> shellcode_size = shellcode_end - shellcode_start; <span class="hljs-comment"><span class="hljs-comment">/*   ,  ,  . . */</span></span> prepare_shellcode(shellcode_text, shellcode_size); <span class="hljs-comment"><span class="hljs-comment">/*   -   */</span></span> write_remote_memory(target, shellcode_text_vaddr, shellcode_text, shellcode_size); }</code> </pre> <br><p>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   -</a>    :      dlopen(),               . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy_shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *shellcode_text, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *shellcode_addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">ptrdiff_t</span></span> offset = shellcode_addr - shellcode_start; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(shellcode_text + offset, data, length); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare_shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *shellcode_text, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shellcode_size)</span></span></span><span class="hljs-function"> </span></span>{ copy_shellcode(shellcode_text, shellcode_start, shellcode_start, shellcode_size); copy_shellcode(shellcode_text, shellcode_address_dlopen, &amp;dlopen_vaddr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(dlopen_vaddr)); copy_shellcode(shellcode_text, shellcode_address_dlsym, &amp;dlsym_vaddr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(dlsym_vaddr)); copy_shellcode(shellcode_text, shellcode_address_pthread_create, &amp;pthread_create_vaddr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(pthread_create_vaddr)); copy_shellcode(shellcode_text, shellcode_address_pthread_detach, &amp;pthread_detach_vaddr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(pthread_detach_vaddr)); copy_shellcode(shellcode_text, shellcode_address_payload, payload, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(payload)); copy_shellcode(shellcode_text, shellcode_address_entry, entry, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(entry)); }</code> </pre> <br><p>     ,    ,      -: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_start[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_address_dlopen[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_address_dlsym[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_address_pthread_create[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_address_pthread_detach[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_address_payload[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_address_entry[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> shellcode_end[];</code> </pre> <br><p>      ,              . </p><br><p>    -        .         /proc/$pid/mem, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">    </a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_remote_memory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vaddr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> path[<span class="hljs-number"><span class="hljs-number">32</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">snprintf</span></span>(path, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(path), <span class="hljs-string"><span class="hljs-string">"/proc/%d/mem"</span></span>, pid); <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd = open(path, O_WRONLY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fd &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lseek(fd, vaddr, SEEK_SET) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { close(fd); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err = do_write_remote_memory(fd, data, size); close(fd); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_write_remote_memory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> left = size; <span class="hljs-comment"><span class="hljs-comment">/* *    ,  ,     *   ,       *      . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (left &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> wrote = write(fd, data, left); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrote &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; data += wrote; left -= wrote; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h3 id="rezultaty-chetvyortogo-shaga">    </h3><br><p> ,             - ‚Äî ¬´ ¬ª .           .    - ,                . </p><br><h2 id="shag-5-zapusk-novogo-potoka">  5.    </h2><br><p>     -        .  ,    :    %rip  -,  PTRACE_SETREGS,  PTRACE_CONT    .     . </p><br><p> ,   ,    .      -?        ? </p><br><h3 id="pochemu-nuzhen-novyy-potok">     </h3><br><p>  ,    .    ,          ¬´ ¬ª  .  ,      .      : </p><br><ul><li>       </li><li>   (async-signal-safe)  </li></ul><br><p>      ‚Äî     . dlopen()  pthread_create()     .        -  dlopen(),      dlopen()  ? </p><br><p>        -, ,   ,       . ,     pthread_create()    .     ,       (     ).     clone(). </p><br><blockquote> <strong>  pthread_create()?</strong> <br><br>     ,  -     ,         ? <br><br> :          clone(). <br><br>          ,    (libc)    (pthread).   clone()       <em> </em> (thread control block, TCB)  <em> </em> (thread-local storage, TLS),        ,  . .     pthread_create()    ,    . <br><br>    ¬´¬ª,      clone()        libc  pthread.        ,    . </blockquote><br><h3 id="podgotovka-k-zapusku-potoka">     </h3><br><p>      clone()      : </p><br><ul><li>      ? </li><li>    ? </li><li>    -? </li></ul><br><h4 id="obrabotka-zaversheniya-potoka">    </h4><br><p>      :     -? </p><br><p>     ,  -       :   ,   ,       ,       . </p><br><p>        .  ,     ,        . ?  :     exit().          ,     . </p><br><p>         .     exit()   -: </p><br><pre> <code class="diff hljs"><span class="hljs-addition"><span class="hljs-addition">+.set __NR_exit, 60 .set RTLD_LAZY, 1 @@ - /* - *  . - */ - int $3 + /* + * exit(0); + */ + xor %rdi,%rdi + mov $__NR_exit,%rax + syscall</span></span></code> </pre> <br><p>  :   exit() ‚Äî    exit()   .   exit()    <em></em> ,    exit()    ‚Äî <em> </em>   .    Linux     exit_group(). </p><br><h4 id="vydelenie-pamyati-pod-stek">     </h4><br><p>     .         .     ,      ,   PROT_EXEC: </p><br><pre> <code class="cpp hljs">shellcode_stack_vaddr = remote_mmap(target, syscall_vaddr, <span class="hljs-number"><span class="hljs-number">0</span></span>, SHELLCODE_STACK_SIZE, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE | MAP_STACK | MAP_GROWSDOWN, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>   ,   Linux  x86_64  <em> </em> ‚Äî  ¬´¬ª  ,     .  mmap()      ,   clone()     .  ,    mmap()  MAP_GROWSDOWN,       ,    . </p><br><h4 id="opciya-ptrace_o_traceclone">  PTRACE_O_TRACECLONE </h4><br><p>        .       ,   -   .         waitpid(),     :      ,          . </p><br><p>        ‚Äî   PTRACE_O_TRACECLONE.          .  ,       . ,      ,     ,    .      ,       PTRACE_ATTACH  ,    . </p><br><p> -,       : </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- unsigned long options = PTRACE_O_TRACESYSGOOD; + unsigned long options = PTRACE_O_TRACESYSGOOD | PTRACE_O_TRACECLONE; if (ptrace(PTRACE_SETOPTIONS, pid, 0, options) &lt; 0) return -1;</span></span></code> </pre> <br><p> -,         clone(),    PTRACE_EVENT_CLONE,     ,  PTRACE_SYSCALL.        : </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">-void wait_for_syscall_completion(pid_t pid) +void wait_for_syscall_completion(pid_t pid, long syscall) { wait_for_syscall_enter_exit_stop(pid); + + /*  clone()   PTRACE_EVENT_CLONE */ + if (syscall == __NR_clone) + wait_for_clone_event(pid); wait_for_syscall_enter_exit_stop(pid); }</span></span></code> </pre> <br><p>     : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_for_clone_event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_CONT, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> event = SIGTRAP | (PTRACE_EVENT_CLONE &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wait_for_process_stop(pid, event) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>     clone()  PID  ,    .         : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear_ptrace_options</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ ptrace(PTRACE_SETOPTIONS, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><p>   ,   clone()    ptrace(),  PTRACE_O_TRACECLONE.     ,     ,  -     . </p><br><h3 id="zapusk-novogo-potoka">    </h3><br><p>      ,   - .       clone()   : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spawn_shell_thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ shell_tid = remote_clone(target, syscall_ret_vaddr, CLONE_FILES | CLONE_FS | CLONE_IO | CLONE_SIGHAND | CLONE_SYSVSEM | CLONE_THREAD | CLONE_VM, <span class="hljs-comment"><span class="hljs-comment">/*   **  */</span></span> shellcode_stack_vaddr + SHELLCODE_STACK_SIZE); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!shell_tid) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">clone()    </a> :    ,   ,     ,  .      ,  . </p><br><p> CLONE_FILES, CLONE_FS, CLONE_IO, CLONE_SIGHAND, CLONE_SYSVSEM, CLONE_VM ‚Äî         . ,   CLONE_FILES    <em></em>   ,    (  fork()).      ‚Äî    <em></em> ‚Äî      ,        .       . , CLONE_VM   ,       ,    . </p><br><p>  CLONE_THREAD       <em></em> :    Linux ‚Äî  ¬´   ¬ª,     .  , ,  getpid()         , kill() ‚Äî   -   , execve() ‚Äî       ,   . </p><br><p>  ,  clone()   fork():        ,    .      clone()      :    ,  ‚Äî   .        . ( , ,        .) </p><br><p>    ,  pthread_create()    ,      ,    .     ? </p><br><h3 id="peredacha-upravleniya">   </h3><br><p>    fork()  : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pid_t</span></span> child = fork(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (child &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* fork() ,    */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (child == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*     execve() */</span></span> } <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span></code> </pre> <br><p>  ,     .  clone()                 .            . </p><br><p>      <a href="" rel="nofollow"> </a> . ,   clone()      ,    .      syscall   ret,       ,     .           . </p><br><h4 id="poisk-pary-instrukciy-syscall--ret">    SYSCALL + RET </h4><br><p>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   </a> ,       .      ,     syscall   ret: </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">-if (region_size &lt; 2) +if (region_size &lt; 3) continue; /* * 0F 05 syscall + * C3 retq */ -for (size_t offset = 0; offset &lt; region_size - 1; offset++) { +for (size_t offset = 0; offset &lt; region_size - 2; offset++) { if (region_data[offset + 0] == 0x0F &amp;&amp; - region_data[offset + 1] == 0x05) + region_data[offset + 1] == 0x05 &amp;&amp; + region_data[offset + 2] == 0xC3) { return region-&gt;vaddr_low + offset; } }</span></span></code> </pre> <br><p>  ,       . </p><br><h4 id="podgotovka-steka">   </h4><br><p>     .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> prepare_shellcode()</a> ,    ,          : </p><br><pre> <code class="diff hljs"> void write_shellcode(void) { char shellcode_text[SHELLCODE_TEXT_SIZE]; size_t shellcode_size = shellcode_end - shellcode_start; /*   ,  ,  . . */ prepare_shellcode(shellcode_text, shellcode_size); /*   -   */ write_remote_memory(target, shellcode_text_vaddr, shellcode_text, shellcode_size); + /*    ¬´¬ª   */ + unsigned long retaddr_vaddr = + shellcode_stack_vaddr + SHELLCODE_STACK_SIZE - 8; + write_remote_memory(target, retaddr_vaddr, + &amp;shellcode_text_vaddr, sizeof(shellcode_text_vaddr)); }</code> </pre> <br><p>  ,      ,     . </p><br><p>  ,     ,   <em></em> . System V ABI ,   ( %rsp)     16    .  <code>shellcode_stack_vaddr + SHELLCODE_STACK_SIZE</code>  :       (  4096 ),     1 .  8 ,     ,      retq,      -    .   -   : </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- sub $8,%rsp + sub $16,%rsp /*   */ mov %rsp,%rdi xor %rsi,%rsi mov %rax,%rdx xor %rcx,%rcx mov shellcode_address_pthread_create(%rip),%rax callq *%rax</span></span></code> </pre> <br><p>     ,   %rsp    16       pthread_create().          SIGSEGV,     ‚Äî     pthread_create()   ,       . </p><br><h4 id="zapusk-potoka">   </h4><br><p>        ,       - ,      clone(): </p><br><pre> <code class="diff hljs"> static int spawn_shell_thread() { shell_tid = remote_clone(target, syscall_ret_vaddr, CLONE_FILES | CLONE_FS | CLONE_IO | CLONE_SIGHAND | CLONE_SYSVSEM | CLONE_THREAD | CLONE_VM, /*   **  */ - shellcode_stack_vaddr + SHELLCODE_STACK_SIZE); + shellcode_stack_vaddr + SHELLCODE_STACK_SIZE - 8); if (!shell_tid) return -1; return 0; }</code> </pre> <br><p>      ptrace()    SIGSTOP,     : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ignore_thread_stop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wait_for_process_stop(pid, SIGSTOP); }</code> </pre> <br><p>  Eso es todo.               ptrace(): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resume_thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ ptrace(PTRACE_CONT, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><h3 id="zavershenie-potoka">   </h3><br><p>  ,    ,  ,    exit().        waitpid().     ‚Äî  CLONE_THREAD   wait()  ,‚Äî    PTRACE_O_TRACECLONE,      : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_for_process_exit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> status = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (waitpid(pid, &amp;status, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!WIFEXITED(status)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WEXITSTATUS(status); }</code> </pre> <br><p>    pthread ,   ,  pthread_join()      pthread       ,        . ,  ‚Äî  .       ,   ,  . </p><br><h4 id="osvobozhdenie-pamyati">  Memoria libre </h4><br><p>     ,  -   .     ,   -   ,      munmap(): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remote_munmap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> syscall_insn_vaddr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ perform_syscall(pid, syscall_insn_vaddr, __NR_munmap, <span class="hljs-number"><span class="hljs-number">2</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) addr, (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) len); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unmap_shellcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ remote_munmap(target, syscall_ret_vaddr, shellcode_text_vaddr, SHELLCODE_TEXT_SIZE); remote_munmap(target, syscall_ret_vaddr, shellcode_stack_vaddr, SHELLCODE_STACK_SIZE); }</code> </pre> <br><p> ,  ,     ,      ‚Äî  ptrace()   .        (, SIGSTOP),    ,   <em> </em>    (    ): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop_thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (kill(pid, SIGSTOP) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wait_for_process_stop(pid, SIGSTOP) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h4 id="otklyuchenie-otladchika">   </h4><br><p> ,      ,    .     PTRACE_DETACH: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ptrace_detach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_DETACH, pid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h3 id="rezultaty-pyatogo-shaga">    </h3><br><p>                   ,      .     ,         .   ,      . </p><br><h2 id="zaklyuchenie">  Conclusi√≥n </h2><br><p>      ?   . ,       ,      . </p><br><p><img src="https://habrastorage.org/webt/0v/gu/we/0vguwedoumnnjh89zw5jtpaaltw.gif" alt="demostraci√≥n de inyecci√≥n en el Centro de Control de Gnomos"></p><br><p>    Linux    .     GTK+     .      ,       make: </p><br><pre> <code class="bash hljs">libpayload.so: payload.c $(CC) $(CFLAGS) $(shell pkg-config --cflags --libs gtk+-3.0) -shared -o <span class="hljs-variable"><span class="hljs-variable">$@</span></span> $&lt;</code> </pre> <br><p>     entry()            GTK- ‚Äî    GTK  UI      ,    : </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;glib.h&gt; #include &lt;gtk/gtk.h&gt; static gboolean actual_entry(gpointer _arg) { /*       : */ hook_gtk_entry_constructor(); /*   FALSE,       */ return FALSE; } void entry(void) { /*    -,   */ g_idle_add_full(G_PRIORITY_DEFAULT_IDLE, actual_entry, NULL, NULL); }</span></span></span></span></code> </pre> <br><p> ,   GTK   ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">GtkEntry</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"> "input-purpose"</a>     .       ¬´¬ª,    ,      . </p><br><p> GTK   glib ‚Äî     ‚Äî      GtkEntry       .    constructed(),     .    : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*old_gtk_entry_constructed)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GObject *object)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_gtk_entry_constructed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GObject *object)</span></span></span><span class="hljs-function"> </span></span>{ GtkEntry *entry = GTK_ENTRY(object); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> old_gtk_entry_constructed(object); <span class="hljs-comment"><span class="hljs-comment">/*    ,  ,   entry */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hook_gtk_entry_constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*     GtkEntry */</span></span> GTypeClass *entry_type_class = g_type_class_peek(GTK_TYPE_ENTRY); GObjectClass *entry_object_class = G_OBJECT_CLASS(entry_type_class); <span class="hljs-comment"><span class="hljs-comment">/* *     "constructed"     . */</span></span> old_gtk_entry_constructed = entry_object_class-&gt;constructed; entry_object_class-&gt;constructed = new_gtk_entry_constructed; }</code> </pre> <br><p>   GtkEntry   : </p><br><ul><li>   ,  ,   </li><li>        </li></ul><br><p>  ,    GtkEntry  <em></em> ,   ,    .     ,    : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_gtk_entry_constructed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GObject *object)</span></span></span><span class="hljs-function"> </span></span>{ GtkEntry *entry = GTK_ENTRY(object); old_gtk_entry_constructed(object); <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> g_signal_connect(entry, <span class="hljs-string"><span class="hljs-string">"notify::input-purpose"</span></span>, G_CALLBACK(input_purpose_changed), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> g_signal_connect(entry, <span class="hljs-string"><span class="hljs-string">"icon-press"</span></span>, G_CALLBACK(icon_pressed), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> g_signal_connect(entry, <span class="hljs-string"><span class="hljs-string">"icon-release"</span></span>, G_CALLBACK(icon_released), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); }</code> </pre> <br><p>   .                ,         .         . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">input_purpose_changed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkEntry *entry)</span></span></span><span class="hljs-function"> </span></span>{ GtkInputPurpose purpose = gtk_entry_get_input_purpose(entry); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (purpose == GTK_INPUT_PURPOSE_PASSWORD) { gtk_entry_set_icon_activatable(entry, GTK_ENTRY_ICON_PRIMARY, TRUE); gtk_entry_set_icon_from_icon_name(entry, GTK_ENTRY_ICON_PRIMARY, <span class="hljs-string"><span class="hljs-string">"list-remove"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { gtk_entry_set_icon_activatable(entry, GTK_ENTRY_ICON_PRIMARY, FALSE); gtk_entry_set_icon_from_icon_name(entry, GTK_ENTRY_ICON_PRIMARY, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); } }</code> </pre> <br><p>   : ,      ,   ,  -       ,      : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">icon_pressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkEntry *entry, GtkEntryIconPosition position)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (position != GTK_ENTRY_ICON_PRIMARY) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; gtk_entry_set_visibility(entry, TRUE); gtk_entry_set_icon_from_icon_name(entry, GTK_ENTRY_ICON_PRIMARY, <span class="hljs-string"><span class="hljs-string">"list-add"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">icon_released</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkEntry *entry, GtkEntryIconPosition position)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (position != GTK_ENTRY_ICON_PRIMARY) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; gtk_entry_set_visibility(entry, FALSE); gtk_entry_set_icon_from_icon_name(entry, GTK_ENTRY_ICON_PRIMARY, <span class="hljs-string"><span class="hljs-string">"list-remove"</span></span>); }</code> </pre> <br><p>  Eso es todo </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"> GitHub</a>         (GPLv2). </p><br><p> ,       .   gdb         : </p><br><pre> <code class="plaintext hljs">$ gdb --pid $(pgrep target) \ --batch \ -ex 'compile file -raw shell-code.c'</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/473740/">https://habr.com/ru/post/473740/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../473720/index.html">Dos formas de hacer pruebas unitarias confiables</a></li>
<li><a href="../473722/index.html">Aislamiento remoto, ansiedad y depresi√≥n.</a></li>
<li><a href="../473726/index.html">No es suficiente saber qu√© son Mutex, Semaphore y async / await. Necesitas saber todo de quanta</a></li>
<li><a href="../473728/index.html">Implementaci√≥n t√≠pica de monitoreo. Nikolay Sivko</a></li>
<li><a href="../473732/index.html">La historia del fraude en la construcci√≥n de una red de cable bajo el √Årtico por $ 1 mil millones</a></li>
<li><a href="../473742/index.html">Impresoras de ingenier√≠a Epson para CAD y GIS y algunas palabras sobre "dise√±o robusto"</a></li>
<li><a href="../473748/index.html">Curva de Bezier al servicio de los economistas laborales</a></li>
<li><a href="../473750/index.html">Stereopi + WebRTC = telepresense en casa</a></li>
<li><a href="../473752/index.html">Lo que est√° mal con Copy-on-Write para Linux al copiar</a></li>
<li><a href="../473756/index.html">HTTPS DNS: soluci√≥n media e incorrecta</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>