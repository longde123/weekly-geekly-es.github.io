<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🤝‍👨🏿 🧘🏽 🎻 Cara memasak bubur dari microservices 👴🏽 ➡️ 👩‍❤️‍💋‍👩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salah satu alasan untuk popularitas layanan-mikro adalah kemungkinan pengembangan yang mandiri dan mandiri. Pada dasarnya, arsitektur layanan mikro ad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara memasak bubur dari microservices</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469001/">  Salah satu alasan untuk popularitas layanan-mikro adalah kemungkinan pengembangan yang mandiri dan mandiri.  Pada dasarnya, arsitektur layanan mikro adalah pertukaran kemungkinan pengembangan otonom untuk penyebaran, pengujian, debugging, dan pemantauan yang lebih kompleks (dibandingkan dengan monolit).  Tetapi perlu diingat bahwa layanan mikro tidak memaafkan pemisahan tanggung jawab.  Jika pemisahan tugas tidak benar, perubahan tergantung yang sering terjadi di berbagai layanan.  Dan ini jauh lebih menyakitkan dan lebih rumit daripada perubahan terkoordinasi dalam kerangka berbagai modul atau paket di dalam monolit.  Perubahan yang konsisten dalam layanan microser diperumit oleh tata letak, penyebaran, pengujian, dll. Yang konsisten <br><br>  Dan saya ingin berbicara tentang berbagai pola dan antipattern dari pembagian tanggung jawab ke dalam layanan mikro. <br><a name="habracut"></a><br><h3>  Entitas Layanan sebagai Antipattern </h3><br>  "Service Entity" adalah salah satu kemungkinan pola (anti) desain arsitektur layanan mikro, yang mengarah pada kode yang sangat tergantung pada layanan yang berbeda dan secara longgar digabungkan dalam layanan. <br><br>  Bagi sebagian besar pengembang, tampaknya ketika memilih layanan sesuai dengan esensi area subjek: "kesepakatan", "orang", "klien", "pesanan", "gambar", ia mengikuti prinsip-prinsip tanggung jawab tunggal, dan terlebih lagi, sering kali ini tampak logis.  Tetapi pendekatan entitas layanan dapat berubah menjadi antipattern.  Ini terjadi karena sebagian besar fitur atau perubahan memengaruhi beberapa entitas, dan bukan satu.  Akibatnya, setiap layanan menggabungkan logika dari proses bisnis yang berbeda. <br><br>  Misalnya, ambil toko online.  Kami memutuskan untuk menyoroti layanan "produk", "pesanan", "klien". <br><br>  Perubahan dan layanan apa yang harus saya lakukan untuk menambahkan pengiriman ke rumah? <br>  Misalnya, Anda dapat melakukan ini: <br><br><ul><li>  dalam layanan "pesanan" tambahkan alamat pengiriman, waktu yang diinginkan dan petugas pengiriman </li><li>  di layanan klien tambahkan daftar alamat pengiriman yang dipilih untuk klien </li><li>  dalam "produk" layanan menambahkan daftar barang entitas </li></ul><br>  Untuk antarmuka pemasok, penting untuk membuat metode API terpisah dalam layanan "pesanan", yang akan memberikan daftar pesanan yang ditetapkan untuk penyedia khusus ini.  Selain itu, metode akan diperlukan untuk mengeluarkan barang dari pesanan yang tidak sesuai atau yang ditolak oleh klien pada saat pengiriman. <br><br>  Atau perubahan apa dan layanan apa yang harus saya buat untuk menambahkan diskon pada kode promosi? <br>  Minimal yang Anda butuhkan: <br><br><ul><li>  tambahkan kode promosi ke layanan "pesanan" </li><li>  dalam layanan "produk" tambahkan apakah diskon berlaku pada kode promosi untuk produk ini </li><li>  di layanan klien tambahkan daftar kode promosi yang dikeluarkan untuk klien </li></ul><br>  Di antarmuka manajer, menambahkan kode promosi yang dipersonalisasi ke klien adalah metode terpisah dalam layanan klien, yang hanya tersedia untuk manajer toko, tetapi tidak tersedia untuk klien sendiri.  Dan dalam layanan "produk", buat metode yang memberikan daftar produk yang dipengaruhi oleh kode promosi, sehingga lebih mudah bagi klien untuk memilih di antarmuka-nya. <br><br>  Sumber perubahan dalam layanan dapat berupa beberapa proses bisnis - pemilihan dan desain, pembayaran dan penagihan, pengiriman.  Setiap area masalah memiliki keterbatasan, invarian, dan persyaratan untuk pesanan.  Akibatnya, ternyata dalam layanan "produk" kami menyimpan informasi tentang produk, tentang diskon, dan saldo produk di gudang.  Dan dalam "urutan" disimpan logika pengirim barang. <br><br>  Dengan kata lain, perubahan logika bisnis yang tersebar di beberapa layanan mengarah ke perubahan dependen di beberapa layanan.  Dan pada saat yang sama dalam satu layanan adalah kode yang tidak terhubung satu sama lain. <br><br><h3>  Layanan Penyimpanan </h3><br>  Tampaknya masalah ini dapat diselesaikan jika layanan "lapisan" terpisah dibuat di atas layanan entitas, yang merangkum seluruh logika.  Tapi biasanya ini juga berakhir buruk.  Karena kemudian layanan entitas menjadi layanan penyimpanan, mis.  semua logika bisnis terhapus dari mereka, kecuali untuk penyimpanan. <br><br>  Jika data disimpan dalam database yang berbeda, pada mesin yang berbeda, maka kami <br><br><ul><li>  kami kehilangan kinerja karena kami tidak memberikan data langsung dari basis data, tetapi melalui lapisan layanan </li><li>  kami kehilangan fleksibilitas karena API layanan biasanya jauh kurang fleksibel daripada SQL atau bahasa permintaan lainnya </li><li>  kami kehilangan fleksibilitas, karena sulit membuat penggabungan data dari berbagai layanan <br></li></ul><br>  Jika layanan entitas yang berbeda memiliki akses ke database lain, maka komunikasi antara layanan terjadi secara implisit - melalui database umum, kemudian untuk membuat perubahan apa pun yang mempengaruhi perubahan skema data, hanya mungkin setelah memeriksa bahwa perubahan ini tidak akan merusak semua layanan lain yang menggunakan database atau tablet ini. . <br><br>  Selain pengembangan yang kompleks, layanan seperti itu menjadi sangat kritis dan sarat beban - dengan hampir setiap permintaan layanan tingkat atas, Anda harus membuat beberapa permintaan ke entitas layanan yang berbeda, yang berarti bahwa mengeditnya menjadi lebih sulit untuk memenuhi peningkatan persyaratan keandalan dan kinerja. <br><br>  Karena kesulitan dengan pengembangan dan dukungan layanan entitas dalam bentuk murni mereka, Anda jarang melihat suatu pola; biasanya layanan entitas berubah menjadi satu atau dua “monervice-monoliths” pusat, yang sering berubah dan mengandung logika bisnis utama dan placer dari layanan mikro kecil yang biasanya berupa infrastruktur dan yang kecil yang jarang berubah. <br><br><h3>  Pemisahan berdasarkan bidang masalah </h3><br>  Perubahan pada diri mereka sendiri tidak dilahirkan, mereka datang dari beberapa bidang masalah.  Area masalah adalah area tugas di mana masalah yang memerlukan perubahan kode dirumuskan dalam satu bahasa, menggunakan satu set konsep atau saling berhubungan oleh logika bisnis.  Dengan demikian, dalam kerangka satu bidang masalah, kemungkinan besar akan ada satu set kendala, invarian yang dapat Anda andalkan saat menulis kode. <br><br>  Pemisahan tanggung jawab layanan oleh bidang masalah, bukan oleh entitas, biasanya mengarah pada arsitektur yang lebih didukung dan dimengerti.  Area bermasalah paling sering berhubungan dengan proses bisnis.  Untuk toko online, area masalah yang paling mungkin adalah "pembayaran dan penagihan", "pengiriman", "proses pemesanan". <br><br>  Perubahan yang akan memengaruhi beberapa area masalah pada saat yang sama lebih kecil dari perubahan yang akan memengaruhi beberapa entitas. <br><br>  Selain itu, layanan yang dipecah oleh proses bisnis dapat digunakan kembali di masa depan.  Misalnya, jika di sebelah toko online kami ingin melakukan penjualan tiket pesawat lagi, kami dapat menggunakan kembali layanan umum "Penagihan dan Pembayaran".  Dan jangan membuat yang lain serupa, tetapi khusus untuk penjualan tiket. <br><br>  Sebagai contoh, kami dapat membagi layanan menjadi: <br><br><ul><li>  Suatu layanan atau sekelompok layanan “Pengiriman”, yang akan menyimpan logika kerja dengan pengiriman pesanan tertentu, organisasi pekerjaan pemasok, penilaian kualitas pekerjaan mereka, aplikasi mobile pemasok, dll. </li><li>  Layanan atau sekelompok layanan "Penagihan dan Pembayaran", yang akan menyimpan logika kerja dengan pembayaran, akun pembayaran untuk badan hukum, pembuatan kontrak dan dokumen penutup. </li><li>  Layanan atau grup layanan "Proses Pemesanan", yang menyimpan logika pilihan produk, katalog, merek, logika keranjang pelanggan, dll. </li><li>  Layanan "otorisasi dan otentikasi". </li><li>  Bahkan mungkin masuk akal untuk memisahkan layanan diskon. </li></ul><br>  Untuk berinteraksi satu sama lain, layanan dapat menggunakan model acara atau bertukar objek sederhana satu sama lain (api tenang, grpc, dll.).  Benar, perlu dicatat bahwa tidak mudah untuk mengatur interaksi antara layanan tersebut dengan benar.  Paling tidak, desentralisasi data memiliki masalah dengan konsistensi kadang-kadang (konsistensi akhirnya) dan transaksionalitas (dalam kasus ketika itu penting). <br><br>  Desentralisasi data, pertukaran benda-benda sederhana memiliki kelebihan, kekurangan, dan kekurangannya.  Di satu sisi, desentralisasi memungkinkan untuk mengembangkan dan mengoperasikan beberapa layanan secara mandiri.  Di sisi lain, biaya penyimpanan dua atau tiga salinan data dan menjaga konsistensi dalam sistem yang berbeda. <br><br>  Dalam kehidupan nyata, sesuatu sering terjadi di antaranya.  Entitas layanan dengan sekumpulan atribut minimum yang digunakan oleh semua layanan oleh konsumen.  Dan beberapa lapisan logika minimum - misalnya, model status, dan peristiwa dalam antrian dengan pemberitahuan semua perubahan dalam entitas.  Pada saat yang sama, layanan konsumen masih cukup sering menyimpan "cache" data.  Segala sesuatu yang mungkin sedang dilakukan sehingga ada perubahan sesedikit mungkin dalam layanan seperti itu, dan ini, pada prinsipnya, sulit dilakukan karena kenyataan bahwa ada banyak konsumen. <br><br>  Pada saat yang sama, penting untuk memahami bahwa partisi apa pun - baik berdasarkan sifat maupun masalah - bukan merupakan peluru perak, akan selalu ada fitur yang akan memerlukan perubahan bergantung pada beberapa layanan.  Hanya saja dengan satu gangguan akan ada lebih banyak perubahan seperti itu dibandingkan dengan yang lain.  Dan tugas pengembangan adalah meminimalkan jumlah perubahan yang tergantung. <br><br>  Perpecahan ideal hanya mungkin jika Anda memiliki dua produk yang sepenuhnya independen.  Dalam bisnis apa pun Anda semua terhubung dengan segalanya, satu-satunya pertanyaan adalah berapa banyak yang terhubung. <br><br>  Dan pertanyaannya adalah pemisahan tanggung jawab dan tingginya hambatan terhadap abstraksi. <br><br><h3>  API Layanan Desain </h3><br>  Merancang antarmuka dalam layanan mengulangi sejarah dengan penguraian menjadi layanan, hanya pada skala yang lebih kecil.  Mengubah antarmuka (bukan hanya ekstensi) sangat rumit dan memakan waktu.  Dalam aplikasi yang kompleks, antarmuka harus cukup universal untuk tidak menyebabkan perubahan konstan, dan harus spesifik dan spesifik agar tidak menyebabkan penyebaran tanggung jawab dan semantik. <br><br>  Oleh karena itu, antarmuka layanan harus dirancang agar semantiknya tahan terhadap perubahan.  Dan ini dimungkinkan jika semantik atau area tanggung jawab antarmuka bergantung pada keterbatasan area masalah. <br><br><h3>  Antarmuka CRUD untuk layanan dengan logika bisnis yang kompleks </h3><br>  Antarmuka yang terlalu lebar dan tidak spesifik berkontribusi pada erosi tanggung jawab atau kompleksitas yang berlebihan. <br><br>  Misalnya, CRUD API untuk layanan dengan logika bisnis yang kompleks. Antarmuka seperti itu tidak merangkum perilaku.  Mereka tidak hanya memungkinkan logika bisnis bocor ke layanan lain dan mengikis tanggung jawab layanan, mereka memprovokasi penyebaran logika bisnis - pembatasan, invarian dan metode bekerja dengan data sekarang di layanan lain.  Layanan antarmuka pengguna (API) harus mengimplementasikan logika sendiri. <br><br>  Jika kami mencoba, tanpa mengubah antarmuka secara signifikan, untuk mentransfer logika bisnis ke layanan, kami akan mendapatkan metode yang terlalu universal dan terlalu rumit. <br><br>  Misalnya, ada layanan tiket.  Tiket bisa dari berbagai jenis.  Setiap jenis memiliki kumpulan bidang yang berbeda dan validasi yang sedikit berbeda.  Tiket juga memiliki model status - mesin negara untuk transisi dari satu status ke status lainnya. <br><br>  Biarkan API terlihat seperti ini: Metode POST / PATCH / GET, url /api/v1/tickets/{ticket_idasket.json <br><br>  Jadi, Anda dapat memperbarui tiket <br><br><pre><code class="json hljs">PATCH /api/v<span class="hljs-number"><span class="hljs-number">1</span></span>/tickets/{ticket_id}.json { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"bug"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"status"</span></span>: <span class="hljs-string"><span class="hljs-string">"closed"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"   "</span></span> }</code> </pre> <br>  Jika model status akan tergantung pada tiket, maka konflik logika bisnis mungkin terjadi.  Pertama, ubah status sesuai dengan model status lama, lalu ubah jenis tiket.  Atau sebaliknya? <br><br>  Ternyata di dalam metode API akan ada kode yang tidak terhubung satu sama lain - bidang entitas yang berubah, daftar bidang yang tersedia, tergantung pada jenis tiket, dan model status.  Mereka berubah karena berbagai alasan dan masuk akal untuk mendistribusikannya sesuai dengan metode dan antarmuka API yang berbeda. <br><br>  Jika mengubah bidang dalam kerangka metode API CRUD bukan hanya perubahan data, tetapi operasi yang terkait dengan perubahan terkoordinasi dalam keadaan entitas, maka operasi ini harus dibawa ke metode terpisah dan tidak boleh diubah secara langsung.  Jika mengubah API tanpa kompatibilitas ke belakang sangat buruk (untuk API publik), maka lebih baik untuk segera memikirkannya saat merancang API. <br><br>  Oleh karena itu, untuk menghindari masalah seperti itu, lebih baik untuk membuat antarmuka kecil, spesifik dan berorientasi pada masalah mungkin, daripada yang universal data-sentris. <br><br>  Pola (anti) ini lebih sering menjadi ciri dari antarmuka RESTful, karena fakta bahwa secara default hanya ada beberapa "kata kerja" data-centric tindakan untuk membuat, menghapus, memperbarui, membaca.  Tidak ada operasi entitas khusus bisnis <br><br>  Apa yang bisa dilakukan untuk membuat RESTful lebih berorientasi pada masalah? <br>  Pertama, Anda bisa menambahkan metode ke entitas.  Antarmuka menjadi kurang tenang.  Tapi ada peluang seperti itu.  Kami masih tidak berjuang untuk kemurnian balapan, tetapi menyelesaikan masalah praktis <br><br>  Alih-alih sumber daya universal <code>/api/v1/tickets.json</code> tambahkan lebih banyak sumber daya: <br><br>  <code>/api/v1/tickets/{ticket_id}/migrate.json</code> - bermigrasi dari satu tipe ke tipe lainnya <br>  <code>/api/v1/tickets/{ticket_id}/status.json</code> - jika ada model status <br><br>  Kedua, Anda dapat membayangkan operasi apa pun sebagai sumber daya dalam kerangka kerja REST.  Apakah ada operasi migrasi tiket dari satu jenis ke yang lain (atau dari satu proyek ke yang lain?).  Ok, jadi akan ada sumber daya <br> <code>/api/v1/tickets/migration.json</code> <br> <br>  Apakah ada operasi bisnis untuk membuat langganan uji coba? <br> <code>/api/v1/subscriptions/trial.json</code> <br> <br>  Apakah ada operasi pengiriman uang? <br> <code>/api/v1/money_transfers.json</code> <br> <br>  Dll <br><br>  Antipattern dengan API data-sentris sebenarnya juga mengacu pada interaksi rpc.  Misalnya, keberadaan metode yang terlalu umum seperti editAccount (), atau editTicket ().  "Modifikasi objek" tidak membawa beban semantik yang terkait dengan area masalah.  Ini berarti bahwa metode ini akan dipanggil karena berbagai alasan, karena berbagai alasan untuk berubah. <br><br>  Perlu dicatat bahwa antarmuka data-sentris cukup ok, jika area masalahnya hanya menyimpan, menerima dan memodifikasi data. <br><br><h3>  Model acara </h3><br>  Salah satu cara untuk melepaskan potongan kode adalah mengatur interaksi antar layanan melalui antrian pesan. <br><br>  Misalnya, jika dalam layanan, saat mendaftarkan pengguna, kami perlu mengirimnya surat selamat datang, membuat permintaan dalam CRM untuk manajer klien, dll., Maka logis untuk tidak melakukan panggilan layanan eksternal, tetapi untuk menempatkan pesan "pengguna 123 terdaftar" di layanan pendaftaran ”, Dan semua layanan yang diperlukan akan membaca pesan ini dan mengambil tindakan yang diperlukan.  Pada saat yang sama, mengubah logika bisnis tidak akan memerlukan perubahan layanan pendaftaran. <br><br>  Paling sering, bukan hanya pesan yang dilemparkan ke antrian, tetapi acara.  Karena antrian hanyalah protokol transport, pembatasan yang sama berlaku untuk antarmuka data seperti antarmuka sinkron biasa.  Oleh karena itu, untuk menghindari masalah dengan mengubah antarmuka dan pengeditan berikutnya di layanan lain, yang terbaik adalah membuat peristiwa yang berorientasi pada masalah mungkin.  Tetap saja peristiwa seperti itu sering disebut peristiwa domain.  Pada saat yang sama, penggunaan model acara biasanya tidak banyak mempengaruhi batas-batas tempat layanan (mikro) bertarung. <br><br>  Karena peristiwa domain secara praktis 1 dalam 1 diterjemahkan ke dalam metode API sinkron, kadang-kadang mereka bahkan menyarankan menggunakan aliran peristiwa alih-alih aliran peristiwa alih-alih panggilan API (Perolehan Acara).  Dengan arus peristiwa, Anda selalu dapat memulihkan keadaan objek, tetapi juga memiliki riwayat gratis.  Faktanya, biasanya pendekatan ini tidak terlalu fleksibel - Anda harus mendukung semua acara, dan seringkali lebih mudah menyimpan cerita bersama API biasa. <br><br><h3>  Layanan dan kinerja mikro.  Cqrs </h3><br>  Pada prinsipnya, area masalah menyiratkan perubahan dalam kode yang terkait tidak hanya dengan persyaratan bisnis fungsional, tetapi juga dengan yang non-fungsional - misalnya, kinerja.  Jika ada dua bagian kode dengan persyaratan kinerja yang berbeda, maka ini berarti bahwa kedua bagian kode ini masuk akal untuk dipisahkan.  Dan mereka biasanya dibagi menjadi beberapa layanan terpisah untuk dapat menggunakan berbagai bahasa dan teknologi yang lebih cocok untuk tugas tersebut. <br><br>  Misalnya, ada metode kalkulator terikat-cpu dalam layanan yang ditulis dalam PHP yang melakukan perhitungan kompleks.  Dengan bertambahnya beban dan jumlah data, dia berhenti mengatasinya.  Dan tentu saja, sebagai salah satu opsi, masuk akal untuk melakukan perhitungan bukan dalam kode php, tetapi dalam daemon sistem kinerja tinggi yang terpisah. <br><br>  Sebagai salah satu contoh pembagian layanan dengan prinsip produktivitas - pemisahan layanan menjadi baca dan modifikasi (CQRS).  Pemisahan ini sering ditawarkan karena persyaratan kinerja layanan membaca dan menulis berbeda.  Beban baca sering urutan besarnya lebih tinggi dari beban tulis.  Dan persyaratan untuk kecepatan respons permintaan baca jauh lebih tinggi daripada untuk menulis. <br><br>  Klien menghabiskan 99% waktu untuk mencari barang, dan hanya 1% dari waktu dalam proses pemesanan.  Untuk klien dalam kondisi pencarian, kecepatan tampilan penting, dan fitur yang terkait dengan filter, berbagai opsi untuk menampilkan barang, dll.  Karena itu, masuk akal untuk menyoroti layanan terpisah yang bertanggung jawab untuk pencarian, penyaringan, dan tampilan barang.  Layanan seperti itu kemungkinan besar akan bekerja pada semacam ELK, basis data berorientasi dokumen dengan data yang didenormalkan. <br><br>  Jelas, divisi naif dalam membaca dan memodifikasi layanan mungkin tidak selalu baik. <br><br>  Sebuah contoh  Untuk seorang manajer yang bekerja dengan mengisi rangkaian produk, fitur utama adalah kemampuan untuk dengan mudah menambahkan barang, menghapus, mengubah dan melihat.  Tidak ada banyak beban, jika kita memisahkan bacaan dan mengubah menjadi layanan yang terpisah, kita tidak akan mendapatkan apa pun dari pemisahan tersebut, kecuali untuk masalah ketika perlu untuk membuat perubahan terkoordinasi dalam layanan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id469001/">https://habr.com/ru/post/id469001/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468991/index.html">Karakter sprite modular dan animasinya</a></li>
<li><a href="../id468993/index.html">Oculus Quest terhubung ke PC dan melihat tangan</a></li>
<li><a href="../id468995/index.html">Kebijakan keterbukaan: bagaimana pengguna memengaruhi proyek</a></li>
<li><a href="../id468997/index.html">Mentoring - bonus yang harus dimiliki atau bagus?</a></li>
<li><a href="../id468999/index.html">Negara mana yang memiliki Internet "paling lambat" dan yang memperbaiki situasi di wilayah yang sulit dijangkau</a></li>
<li><a href="../id469003/index.html">“Konferensi untuk orang-orang dan untuk menyelesaikan kebutuhan mereka”: Panitia program DevOpsDays tentang apa itu konferensi komunitas</a></li>
<li><a href="../id469005/index.html">Ohio Challenger 2P dan 4 KB RAM-nya</a></li>
<li><a href="../id469007/index.html">RubyRusia 2019. Nikita Shilnikov pada efek aljabar</a></li>
<li><a href="../id469009/index.html">Kultus kargo dalam pengembangan perangkat lunak</a></li>
<li><a href="../id469011/index.html">11 mitos tentang USB Type-C</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>