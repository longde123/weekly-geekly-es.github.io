<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ« ğŸŠ ğŸ‘˜ Kompresi array bilangan prima yang besar ğŸŒ«ï¸ ğŸ‘©ğŸ¼â€âš–ï¸ ğŸ§–ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Properti bilangan prima jarang memungkinkan Anda untuk bekerja dengannya secara berbeda daripada dalam bentuk array yang sudah dihitung sebelumnya - d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kompresi array bilangan prima yang besar</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417753/"><img src="https://habrastorage.org/webt/sr/yf/y8/sryfy8c2vpyfx-euoq7v_v3p_sa.jpeg" alt="kotak pasir" align="left"><br><p>  Properti bilangan prima jarang memungkinkan Anda untuk bekerja dengannya secara berbeda daripada dalam bentuk array yang sudah dihitung sebelumnya - dan lebih disukai sebanyak mungkin.  Format penyimpanan alami dalam bentuk bilangan bulat dari satu atau beberapa kapasitas digit lainnya menderita pada saat yang sama dari beberapa kerugian yang menjadi signifikan dengan pertumbuhan volume data. <br></p><p></p><p>  Jadi, format bilangan bulat tak bertanda 16-bit dengan ukuran tabel semacam itu sekitar 13 kilobyte, hanya berisi 6542 bilangan prima: diikuti oleh angka 65531 adalah nilai-nilai kedalaman bit yang lebih tinggi.  Meja seperti itu hanya cocok sebagai mainan. <br></p><p></p><p>  Format integer 32-bit paling populer dalam pemrograman terlihat jauh lebih solid - ini memungkinkan Anda untuk menyimpan sekitar 203 juta yang sederhana.  Tetapi meja seperti itu sudah menempati sekitar 775 megabita. <br></p><p></p><p>  Format 64-bit memiliki lebih banyak prospek.  Namun, dengan kekuatan teoretis dari urutan nilai 1e + 19, tabel akan memiliki ukuran 64 exabytes. <br></p><br><a name="habracut"></a><br><p></p><p>  Tidak benar-benar percaya bahwa kemanusiaan progresif kita akan pernah di masa mendatang menghitung tabel bilangan prima dari volume seperti itu.  Dan intinya di sini tidak begitu banyak dalam volume bahkan seperti pada waktu penghitungan algoritma yang tersedia.  Katakanlah, jika tabel semua 32-bit yang sederhana masih dapat dihitung secara mandiri dalam beberapa jam (Gbr. 1), maka untuk tabel setidaknya urutan besarnya lebih besar akan memakan waktu beberapa hari.  Tetapi volume seperti hari ini - ini hanya level awal. <br></p><br><br><img src="https://habrastorage.org/webt/ut/qn/gq/utqngqsvjfyolxj1afp9n--6jxw.jpeg" alt="gbr.  1"><br><br><p>  Seperti dapat dilihat dari diagram, waktu perhitungan spesifik setelah brengsek mulai dengan lancar beralih ke pertumbuhan asimptotik.  Dia agak lambat.  tetapi ini adalah pertumbuhan, yang berarti menambang setiap bagian data selanjutnya dari waktu ke waktu akan semakin sulit.  Jika Anda ingin membuat beberapa terobosan signifikan, Anda harus memparalelkan pekerjaan di seluruh core (dan itu paralel dengan baik) dan menggantungnya di superkomputer.  Dengan prospek mendapatkan 10 miliar pertama sederhana dalam seminggu, dan 100 miliar - hanya dalam setahun.  Tentu saja, ada algoritma yang lebih cepat untuk menghitung sederhana daripada bust sepele yang digunakan dalam pekerjaan rumah saya, tetapi, pada dasarnya, ini tidak mengubah masalah: setelah dua atau tiga urutan besarnya, situasinya menjadi serupa. <br></p><p></p><p>  Oleh karena itu, alangkah baiknya jika pernah melakukan pekerjaan penghitungan, untuk menyimpan hasilnya dalam bentuk tabel siap pakai, dan menggunakannya sesuai kebutuhan. <br></p><p></p><p>  Karena ide yang jelas, jaringan menemukan banyak tautan ke daftar bilangan prima yang sudah jadi yang sudah dihitung oleh seseorang.  Sayangnya, dalam kebanyakan kasus mereka hanya cocok untuk kerajinan siswa: satu seperti itu, misalnya, mengembara dari situs ke situs dan mencakup 50 juta yang sederhana.  Jumlah ini hanya dapat memukau yang belum tahu: sudah disebutkan di atas bahwa pada komputer rumah dalam beberapa jam Anda dapat menghitung sendiri tabel semua 32-bit yang sederhana, dan empat kali lebih besar.  Mungkin sekitar 15-20 tahun yang lalu, daftar seperti itu memang merupakan pencapaian heroik bagi komunitas awam.  Saat ini, di era multi-core multi-gigahertz dan perangkat multi-gigabyte, ini tidak lagi mengesankan. <br></p><p></p><p>  Saya beruntung bisa berkenalan dengan akses ke meja sederhana yang lebih representatif, yang akan saya gunakan lebih jauh sebagai ilustrasi dan pengorbanan untuk eksperimen lapangan saya.  Untuk tujuan konspirasi, saya akan memanggilnya <b>1TPrimo</b> .  Ini berisi semua bilangan prima kurang dari satu triliun. <br></p><p></p><p>  Menggunakan 1TPrimo sebagai contoh, mudah untuk melihat volume apa yang harus Anda tangani.  Dengan kapasitas sekitar 37,6 miliar nilai dalam format integer 64-bit, daftar ini adalah 280 gigabytes.  By the way - bagian itu yang bisa muat dalam 32 digit hanya menyumbang 0,5% dari jumlah angka yang diwakili di dalamnya.  Ini membuatnya sangat jelas bahwa setiap pekerjaan serius dengan bilangan prima pasti cenderung total kedalaman 64-bit (atau lebih). <br></p><p></p><p>  Dengan demikian, kecenderungan suramnya jelas: entah bagaimana tabel bilangan prima yang serius pasti memiliki volume yang sangat besar.  Dan kita entah bagaimana harus melawan ini. <br></p><p></p><p>  Hal pertama yang terlintas dalam pikiran ketika melihat sebuah tabel (Gbr. 2) adalah bahwa ia terdiri dari nilai-nilai berurutan yang hampir identik yang hanya berbeda dalam satu atau dua tempat desimal terakhir: <br></p><br><p><br><img src="https://habrastorage.org/webt/y7/hk/f5/y7hkf5s75ii-jdujarftwhpd14i.jpeg" alt="gbr.  2"><br><br></p><br><p>  Secara sederhana, dari pertimbangan abstrak yang paling umum: jika file memiliki banyak data duplikat, maka file tersebut harus dikompres dengan baik oleh pengarsipan.  Memang, kompresi tabel 1TPrimo dengan utilitas 7-zip yang populer pada pengaturan standar memberikan rasio kompresi yang agak tinggi: 8,5.  Benar, waktu pemrosesan - dengan ukuran besar tabel sumber - pada server 8-inti, dengan beban rata-rata semua inti sekitar 80-90%, adalah 14 jam 12 menit.  Algoritma kompresi universal dirancang untuk beberapa ide abstrak dan umum tentang data.  Dalam beberapa kasus khusus, algoritma kompresi khusus yang dibangun di atas fitur-fitur terkenal dari kumpulan data yang masuk dapat menunjukkan indikator yang jauh lebih efektif, yang dikhususkan untuk pekerjaan ini.  Dan seberapa efektif itu akan menjadi jelas di bawah ini. <br></p><p></p><p>  Nilai numerik dekat dari bilangan prima tetangga meminta keputusan untuk tidak menyimpan nilai-nilai ini sendiri, tetapi interval (perbedaan) di antara mereka.  Dalam hal ini, penghematan yang signifikan dapat dicapai karena fakta bahwa kedalaman bit dari interval jauh lebih rendah daripada kedalaman bit dari data awal (Gbr. 3). <br></p><br><p><br><img src="https://habrastorage.org/webt/7-/lk/ka/7-lkkafdhzaus8yglobx1t5t25w.jpeg" alt="gbr.  3"><br><br></p><br><p>  Dan tampaknya itu tidak tergantung pada kedalaman bit dari yang sederhana menghasilkan interval.  Pencarian lengkap menunjukkan bahwa nilai-nilai khas interval untuk bilangan prima yang diambil dari berbagai tempat dalam tabel 1TPrimo berada dalam satuan, puluhan, kadang-kadang ratusan, dan - sebagai kalimat kerja pertama - mereka mungkin bisa masuk ke dalam kisaran 8-bit bilangan bulat yang tidak ditandatangani, mis., byte.  Akan sangat nyaman, dan dibandingkan dengan format 64-bit, ini akan segera mengarah pada kompresi data 8 kali lipat - hanya di suatu tempat di tingkat yang ditunjukkan oleh pengarsipan 7-zip.  Selain itu, kesederhanaan algoritma kompresi dan dekompresi pada prinsipnya memiliki dampak besar pada kecepatan kompresi dan akses ke data dibandingkan dengan 7-zip.  Kedengarannya menggoda. <br></p><p></p><p>  Sangat jelas bahwa data yang dikonversi dari nilai absolut ke interval relatif di antara mereka hanya cocok untuk memulihkan serangkaian nilai yang muncul secara berurutan dari awal tabel utama.  Tetapi jika kita menambahkan struktur indeks blok minimal ke tabel interval seperti itu, maka dengan biaya overhead tambahan yang tidak signifikan ini akan memungkinkan kita untuk mengembalikan - tetapi sudah blok demi blok - baik elemen tabel dengan nomornya maupun elemen terdekat dengan nilai yang ditetapkan secara sewenang-wenang, dan operasi ini, bersama dengan operasi utama sampel urutan - secara umum, itu menguras bagian terbesar dari pertanyaan yang mungkin untuk data tersebut.  Pemrosesan statistik, tentu saja, akan menjadi lebih rumit, tetapi masih akan tetap cukup transparan  tidak ada trik khusus dalam memulihkannya "on the fly" dari interval yang tersedia saat mengakses blok data yang diperlukan. <br></p><p></p><p>  Tapi sayang sekali.  Eksperimen numerik sederhana pada data 1TPrimo menunjukkan bahwa sudah pada akhir dari puluhan juta ketiga (ini kurang dari seperseratus persen dari volume 1TPrimo) - dan kemudian di tempat lain - interval antara bilangan prima yang berdekatan secara teratur berada di luar kisaran 0,255. <br></p><p></p><p>  Namun demikian, percobaan numerik yang sedikit rumit mengungkapkan bahwa pertumbuhan interval maksimum antara bilangan prima tetangga dengan pertumbuhan tabel itu sendiri sangat, sangat lambat - yang berarti idenya masih bagus dalam beberapa hal. <br></p><p></p><p>  Yang kedua, melihat lebih dekat pada tabel interval menunjukkan bahwa mungkin untuk menyimpan bukan perbedaan itu sendiri, tetapi setengahnya.  Karena semua bilangan prima lebih besar dari 2 jelas aneh, masing-masing, perbedaan mereka jelas genap.  Dengan demikian, perbedaan dapat dikurangi 2 tanpa kehilangan nilai;  dan untuk kelengkapan, kita juga dapat mengurangi satu dari hasil bagi yang diperoleh untuk menggunakan nilai nol yang tidak diklaim sebaliknya (Gbr. 4).  Pengurangan interval seperti itu akan disebut selanjutnya monolitik, berbeda dengan bentuk awal yang longgar dan keropos, di mana semua nilai ganjil dan nol ternyata tidak diklaim. <br></p><br><p><br><img src="https://habrastorage.org/webt/ix/ob/fp/ixobfp-kfzmw2gkwjrkkmwcfxn4.jpeg" alt="gbr.  4"><br><br></p><br><p>  Perlu dicatat bahwa karena interval antara dua yang pertama sederhana (2 dan 3) tidak cocok dengan skema ini, maka 2 harus dikeluarkan dari tabel interval dan ingat fakta ini setiap saat. <br></p><p></p><p>  Teknik sederhana ini memungkinkan Anda untuk menyandikan interval dari 2 hingga 512 pada rentang nilai 0..255. Sekali lagi, harapan menjadi hidup bahwa metode perbedaan akan memungkinkan kita untuk mengemas urutan bilangan prima yang jauh lebih kuat.  Dan memang demikian: serangkaian nilai 37,6 miliar yang disajikan dalam daftar 1TPrimo hanya mengungkapkan 6 (enam!) Interval yang tidak berada dalam kisaran 2..512. <br></p><p></p><p>  Tapi itu kabar baik;  yang buruk adalah bahwa keenam interval ini tersebar di daftar dengan cukup bebas, dan yang pertama terjadi pada akhir sepertiga pertama daftar, mengubah dua pertiga sisanya menjadi pemberat yang tidak cocok untuk metode kompresi ini (Gbr. 5): <br></p><br><p><br><img src="https://habrastorage.org/webt/k_/0y/aw/k_0yaw46rbatmne64qzj0vp9mus.jpeg" alt="gbr.  5"><br><br></p><br><p>  Seperti flush (enam potong malang selama hampir empat puluh miliar! - dan pada Anda ...) bahkan dengan lalat di salep untuk membandingkan - untuk menunjukkan kehormatan tar.  Namun sayang, ini sebuah pola, bukan kecelakaan.  Jika kita melacak tampilan pertama interval antara bilangan prima tergantung pada panjang data, menjadi jelas bahwa fenomena ini terletak pada genetika bilangan prima, meskipun itu berkembang sangat lambat (Gambar 6 *). <br></p><br><p><br><img src="https://habrastorage.org/webt/sj/c_/ah/sjc_ah1hgw7ud9xewa3_s47edhq.jpeg" alt="gbr.  6"><br><br></p><br><p>  * Jadwal disusun sesuai dengan situs tematik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Thomas R. Nisley</a> , <br>  yang beberapa perintah besarnya lebih unggul dari kekuatan daftar 1TPrimo </p><br><p></p><p>  Tetapi bahkan kemajuan yang sangat lambat ini secara jelas mengisyaratkan: seseorang dapat membatasi diri pada kedalaman bit tertentu dari suatu interval hanya pada kekuatan tertentu dari daftar yang telah ditentukan.  Artinya, itu tidak cocok sebagai solusi universal. <br></p><p></p><p>  Namun, fakta bahwa metode yang diusulkan untuk mengompresi urutan bilangan prima memungkinkan Anda untuk mengimplementasikan tabel kompak sederhana dengan kapasitas hampir 12 miliar nilai sudah cukup hasilnya.  Tabel seperti ini menempati volume 11,1 gigabytes - melawan 89,4 gigabytes dalam format 64-bit yang sepele.  Tentunya untuk sejumlah aplikasi solusi semacam itu mungkin sudah cukup. <br></p><p></p><p>  Dan yang menarik: prosedur untuk menerjemahkan tabel 1TPrimo 64-bit ke format interval 8-bit dengan struktur blok, hanya menggunakan satu inti prosesor (untuk paralelisasi, Anda harus menggunakan komplikasi program yang signifikan, dan itu benar-benar tidak sepadan) dan tidak lebih dari 5 % dari beban prosesor (sebagian besar waktu dihabiskan untuk operasi file) hanya membutuhkan 19 menit Terhadap - Saya ingat - 14 jam pada delapan core pada 80-90% dari beban yang dihabiskan oleh pengarsipan 7-zip. <br></p><p></p><p>  Tentu saja, hanya sepertiga pertama dari tabel yang dikenakan terjemahan ini, di mana rentang interval tidak melebihi 512. Oleh karena itu, jika kita membawa 14 jam penuh ke sepertiga yang sama, maka 19 menit harus dibandingkan dengan hampir 5 jam dari pengarsipan 7-zip.  Dengan jumlah kompresi yang sebanding (8 dan 8,5), perbedaannya sekitar 15 kali.  Mempertimbangkan bahwa bagian terbesar dari waktu kerja program siaran ditempati oleh operasi file, perbedaannya bahkan akan lebih curam pada sistem disk yang lebih cepat.  Dan secara intelektual, waktu operasi 7-zip pada delapan core masih harus dihitung pada satu utas, dan kemudian perbandingannya akan menjadi sangat memadai. <br></p><p></p><p>  Pemilihan dari basis data semacam itu sangat sedikit berbeda dalam waktu dari pemilihan dari tabel data yang dibongkar dan hampir seluruhnya ditentukan oleh waktu operasi file.  Angka-angka spesifik sangat tergantung pada perangkat keras tertentu, pada server saya, rata-rata, akses ke blok data sewenang-wenang mengambil 37,8 Î¼s, sementara membaca blok berurutan - 4,2 Î¼s per blok, untuk membongkar lengkap blok - kurang dari 1 Î¼s.  Artinya, tidak masuk akal untuk membandingkan dekompresi data dengan karya pengarsip standar.  Dan ini merupakan nilai tambah yang besar. <br></p><p></p><p>  Dan, akhirnya, pengamatan menawarkan lagi, solusi ketiga yang menghilangkan batasan pada kekuatan data: interval coding dengan nilai-nilai panjang variabel.  Teknik ini telah lama digunakan dalam aplikasi terkait kompresi.  Artinya adalah jika ditemukan dalam input bahwa beberapa nilai sering ditemukan, beberapa kurang umum, dan beberapa sangat jarang, maka kita dapat menyandikan yang pertama dengan kode pendek, yang kedua dengan kode yang lebih otentik, dan yang ketiga - sangat panjang (mungkin bahkan sangat lama, karena itu tidak masalah: semua sama, data seperti itu sangat jarang).  Akibatnya, total panjang kode yang diterima bisa jauh lebih pendek daripada data input. <br></p><p></p><p>  Sudah melihat grafik tampilan interval pada Gambar. 7, kita dapat membuat asumsi bahwa jika intervalnya 2, 4, 6, dll.  muncul lebih awal daripada interval, katakanlah, 100, 102, 104, dll., maka yang pertama harus terus terjadi lebih sering daripada yang terakhir.  Dan sebaliknya - jika interval 514 hanya mulai dari 11,99 miliar, 516 - mulai dari 16,2 miliar, dan 518 - umumnya mulai hanya 87,7 miliar, maka mereka akan jarang bertemu.  Yaitu, apriori, kita dapat mengasumsikan hubungan terbalik antara ukuran interval dan frekuensinya dalam urutan bilangan prima.  Dan itu berarti - Anda dapat membangun struktur sederhana yang mengimplementasikan kode panjang variabel untuknya. <br></p><p></p><p>  Tentu saja, statistik pada frekuensi interval harus menjadi penentu pilihan metode pengkodean tertentu.  Untungnya, berbeda dengan data yang berubah-ubah, frekuensi interval antara bilangan prima - yang dengan sendirinya ditentukan secara ketat, sekali dan untuk semua urutan yang diberikan - juga ditentukan secara ketat, sekali dan untuk semua karakteristik yang ditentukan. <br></p><p></p><p>  Gambar 7 menunjukkan respons frekuensi interval untuk seluruh daftar 1TPrimo: <br></p><br><p><br><img src="https://habrastorage.org/webt/7q/ga/ii/7qgaii-1mwxlmuvicojaklwrbuk.jpeg" alt="gbr.  7"><br><br></p><br><p>  Di sini perlu disebutkan lagi bahwa interval antara bilangan prima pertama 2 dan 3 dikeluarkan dari grafik: interval ini adalah 1 dan terjadi tepat sekali dalam urutan bilangan prima, terlepas dari kekuatan daftar.  Interval ini sangat aneh sehingga lebih mudah untuk menghapus 2 dari daftar yang sederhana daripada terus-menerus menyimpang ke reservasi.  Sim dinyatakan bahwa <b>nomor 2 adalah virtual prime</b> : tidak terlihat dalam daftar, tetapi ada di sana.  Seperti gopher itu. <br></p><p></p><p>  Pada pandangan pertama, grafik frekuensi sepenuhnya menegaskan asumsi a priori yang diberikan oleh beberapa paragraf di atas.  Ini jelas menunjukkan heterogenitas statistik dari interval dan frekuensi tinggi dari nilai-nilai kecil dibandingkan dengan yang besar.  Namun, pada tampilan kedua, lebih cembung, grafik ternyata jauh lebih menarik (Gbr. 8): <br></p><br><p><br><img src="https://habrastorage.org/webt/qm/4_/xu/qm4_xuzdshet30cdd9ucm7t4q0m.jpeg" alt="gbr.  8"><br><br></p><br><p>  Secara tak terduga, ternyata interval yang paling sering bukan 2 dan 4, seperti yang tampaknya dari pertimbangan umum, tetapi 6, 12 dan 18, diikuti oleh 10 - dan hanya kemudian 2 dan 4 dengan frekuensi yang hampir sama (perbedaan dalam 7 digit). setelah titik desimal).  Dan selanjutnya, banyaknya nilai puncak dari angka 6 ditelusuri ke seluruh grafik. <br></p><p></p><p>  Yang lebih menarik, sifat grafik yang tidak sengaja terungkap ini bersifat universal - dan, dalam semua detail, dengan semua kekusutannya - di atas seluruh urutan interval sederhana yang diwakili oleh daftar 1TPrimo, kemungkinan grafik itu bersifat universal untuk setiap urutan interval sederhana (tentu saja, pernyataan berani seperti itu perlu bukti, yang dengan senang hati saya pindahkan ke pangkat spesialis dalam teori bilangan).  Gambar 10 menunjukkan perbandingan statistik interval penuh (garis merah) dengan sampel interval terbatas diambil di beberapa tempat acak pada daftar 1TPrimo (garis warna lain): <br></p><br><p><br><img src="https://habrastorage.org/webt/xs/jk/hd/xsjkhdqm8aztn2qztye3ftpf0yw.jpeg" alt="gbr.  9"><br></p><br><p>  Dapat dilihat dari grafik ini bahwa semua sampel ini saling mengulang dengan tepat, dengan hanya sedikit perbedaan di bagian kiri dan kanan gambar: mereka tampaknya sedikit diputar berlawanan arah jarum jam di sekitar titik interval dengan nilai 24. Rotasi ini mungkin disebabkan oleh fakta bahwa semakin tinggi di sebelah kiri bagian dari grafis dibangun di atas sampel dengan kedalaman bit yang lebih rendah.  Dalam sampel seperti itu, belum ada sama sekali, atau interval besar jarang terjadi, yang menjadi sering terjadi pada sampel dengan kedalaman bit yang lebih tinggi.  Dengan demikian, ketidakhadiran mereka mendukung frekuensi interval dengan nilai yang lebih rendah.  Dalam sampel dengan kedalaman bit yang lebih tinggi, banyak interval baru dengan nilai besar muncul, oleh karena itu, frekuensi interval yang lebih kecil sedikit menurun.  Kemungkinan besar, titik pivot, dengan peningkatan kekuatan daftar, akan bergeser ke nilai yang lebih besar.  Di suatu tempat di sana, di sebelahnya, adalah titik keseimbangan grafik, di mana jumlah semua nilai di sebelah kanan kira-kira sama dengan jumlah semua nilai di sebelah kiri. <br></p><p></p><p>  Sifat yang menarik dari frekuensi interval ini menunjukkan meninggalkan struktur sepele dari kode dengan panjang variabel.  Biasanya, struktur seperti itu terdiri dari paket bit dengan panjang dan tujuan yang beragam.  Sebagai contoh, pertama datang sejumlah bit awalan yang ditetapkan ke nilai tertentu, misalnya, 0. Ada bit stop di belakangnya, yang harus mengindikasikan penyelesaian awalan, dan, karenanya, harus berbeda dari awalan: 1 dalam kasus ini.  Awalan mungkin tidak memiliki panjang, yaitu, berulang-ulang, pengambilan sampel dapat segera dimulai dengan stop bit, sehingga menentukan urutan terpendek.  Bit stop biasanya diikuti oleh sufiks, yang panjangnya ditentukan dalam beberapa cara yang telah ditentukan oleh panjang awalan.      ,       ,      â€”        .      ,        -  .    -    (, , - )  ,          . <br></p><p></p><p>              ,   . <br></p><p></p><p> Dan di sini satu hal lagi yang penting harus dinyatakan.  Pada pandangan pertama, siklus yang diamati menyiratkan pembagian interval menjadi tiga kali lipat: <code>{2,4, <b>6</b> }</code> , <code>{8,10, <b>12</b> }</code> , <code>{14,16, <b>18</b> }</code> dan seterusnya (nilai-nilai dengan frekuensi maksimum di setiap tiga ditandai dengan huruf tebal) .  Namun, pada kenyataannya, siklus di sini sedikit berbeda. <br></p><p></p><p>  Saya tidak akan mengutip seluruh garis penalaran, yang, pada kenyataannya, tidak ada di sana: itu adalah tebakan yang intuitif, ditambah dengan metode pencacahan pilihan, perhitungan, dan sampel yang memakan waktu beberapa hari secara berselang.  Siklus yang diungkapkan sebagai hasilnya terdiri dari <b>enam</b> interval <code>{2,4, <b>6</b> ,8,10, <b>12</b> }</code> , <code>{14,16, <b>18</b> ,20,22, <b>24</b> }</code> , <code>{26,28, <b>30</b> ,32,34, <b>36</b> }</code> dan seterusnya (interval frekuensi maksimum sekali lagi disorot dalam huruf tebal). <br></p><p></p><p>  Singkatnya, algoritma pengemasan yang diusulkan adalah sebagai berikut. <br></p><p></p><p>  Membagi interval menjadi enam angka genap memungkinkan kita untuk merepresentasikan setiap interval <code>g</code> dalam bentuk <code>g = i * 12 + t</code> , di mana <code>i</code> adalah indeks dari enam di mana interval ini berada ( <code>i = {0,1,2,3, ...}</code> ) dan <code>t</code> adalah ekor yang mewakili salah satu nilai dari yang didefinisikan secara kaku, terikat, dan identik untuk enam set <code>{2,4,6,8,10,12}</code> .  Respons frekuensi indeks yang disorot di atas hampir persis berbanding terbalik dengan nilainya, sehingga logis untuk mengubah indeks enam menjadi struktur sepele dari kode panjang variabel, contoh yang diberikan di atas.  Karakteristik frekuensi dari penjepit memungkinkan Anda untuk membaginya menjadi dua kelompok yang dapat dikodekan dengan rantai bit dengan panjang yang berbeda: nilai 6 dan 12, yang paling sering ditemukan, dikodekan dengan satu bit, nilai 2, 4, 8 dan 10, yang lebih jarang ditemui, dikodekan dengan dua bit.  Tentu saja, satu bit lagi diperlukan untuk membedakan antara dua opsi ini. <br></p><p></p><p>  Array yang berisi paket bit dilengkapi dengan bidang tetap yang menentukan nilai awal dari data yang disajikan dalam blok, dan jumlah lain yang diperlukan untuk mengembalikan urutan sederhana atau sederhana dari urutan sederhana dari interval yang disimpan dalam blok. <br></p><p></p><p>  Selain struktur blok-indeks ini, penggunaan kode-panjang variabel rumit oleh biaya tambahan dibandingkan dengan interval bit tetap. <br></p><p></p><p>  Saat menggunakan interval ukuran tetap, menentukan blok untuk mencari bilangan prima dengan nomor seri adalah tugas yang cukup sederhana, karena jumlah interval per blok diketahui sebelumnya.  Tetapi pencarian solusi sederhana dengan nilai terdekat tidak memiliki solusi langsung.  Atau, Anda dapat menggunakan beberapa rumus empiris yang memungkinkan Anda menemukan perkiraan nomor blok dengan interval yang diperlukan, setelah itu Anda harus mencari blok yang diinginkan dengan pencarian lengkap. <br></p><p></p><p>  Untuk tabel dengan kode panjang variabel, pendekatan yang sama diperlukan untuk kedua tugas: baik untuk mengambil nilai dengan nomor maupun untuk pencarian berdasarkan nilai.  Karena panjang kode bervariasi, tidak pernah diketahui sebelumnya berapa banyak perbedaan disimpan dalam blok tertentu, dan di mana blok nilai yang diinginkan terletak.  Secara eksperimental ditentukan bahwa dengan ukuran blok 512 byte (yang mencakup beberapa header byte), kapasitas blok dapat naik hingga 10-12 persen dari nilai rata-rata.  Blok yang lebih kecil menghasilkan sebaran relatif yang lebih besar.  Pada saat yang sama, nilai rata-rata kapasitas blok itu sendiri cenderung perlahan menurun seiring bertambahnya tabel.  Pemilihan rumus empiris untuk penentuan blok awal yang tidak akurat untuk mencari nilai yang diinginkan baik dengan jumlah maupun nilai adalah tugas yang tidak sepele.  Atau, Anda dapat menggunakan pengindeksan yang lebih kompleks dan canggih. <br></p><p></p><p>  Faktanya, itu saja. <br></p><p></p><p>  Di bawah ini, seluk-beluk kompresi tabel utama menggunakan kode panjang variabel dan struktur yang terkait dengannya dijelaskan dengan cara yang lebih formal dan terperinci, dan kode untuk fungsi pengemasan dan interval pembongkaran dalam C diberikan. <br></p><p></p><p>  Hasilnya <br></p><p></p><p>  Jumlah data yang diterjemahkan dari Tabel 1TPrimo ke dalam kode panjang variabel, ditambah dengan struktur indeks blok, juga dijelaskan di bawah ini, berjumlah 26.309.295.104 byte (24,5 GB), yaitu, rasio kompresi mencapai 11,4.  Jelas, dengan meningkatnya kedalaman bit, rasio kompresi akan meningkat. <br></p><p></p><p>  Waktu siaran 280 GB dari tabel 1TPrimo dalam format baru adalah 1 jam.  Ini adalah hasil yang diharapkan setelah percobaan dengan interval pengemasan menjadi integer byte tunggal.  Dalam kedua kasus, terjemahan tabel sumber terutama terdiri dari operasi file dan hampir tidak memuat prosesor (dalam kasus kedua, beban masih lebih tinggi karena kompleksitas komputasi algoritma yang lebih tinggi).  Waktu akses data juga tidak jauh berbeda dari interval byte tunggal, tetapi waktu untuk membuka blok penuh dengan ukuran yang sama membutuhkan 1,5 Î¼s, karena kompleksitas algoritma yang lebih tinggi untuk mengekstraksi kode panjang variabel. <br></p><p></p><p>  Tabel (Gbr. 10) merangkum karakteristik volumetrik dari tabel bilangan prima yang disebutkan dalam teks ini. <br></p><br><p><br><img src="https://habrastorage.org/webt/dc/jw/6o/dcjw6oz2efm88nqvzolxsz7mx6m.jpeg" alt="gbr.  10"></p><br><p></p><p><br></p><h3>  Deskripsi Algoritma Kompresi </h3><br><h4>  Ketentuan dan Notasi </h4><br>  <code>P (prime): P1=3, P2=5, P3=7 ... Pn, Pn1</code> adalah bilangan prima sesuai dengan nomor seri mereka.  Sekali lagi (dan untuk terakhir kalinya) saya menekankan bahwa <code>P0=2</code> adalah bilangan prima virtual;  demi keseragaman formal, angka ini secara fisik dikecualikan dari daftar bilangan prima. <br><p></p><p>  <code>G (gap)</code> - interval antara dua bilangan prima berturut-turut <code>Gn = Pn1 - Pn; G={2,4,6,8 ...}</code>  <code>Gn = Pn1 - Pn; G={2,4,6,8 ...}</code> . <br></p><p></p><p>  <code>D (dense)</code> - direduksi menjadi interval bentuk monolitik: <code>D = G/2 -1; D={0,1,2,3 ...}</code>  <code>D = G/2 -1; D={0,1,2,3 ...}</code> .  Enam interval dalam bentuk monolitik terlihat seperti <code>{0,1,2,3,4,5}, {6,7,8,9,10,11}, {12,13,14,15,16,17}</code> dll. <br></p><p></p><p>  <code>Q (quotient)</code> - indeks keenam direduksi menjadi bentuk monolitik, <code>Q = D div 6; Q={0,1,2,3 ...}</code> <code>Q = D div 6; Q={0,1,2,3 ...}</code> <br></p><p></p><p>  <code>R (remainder)</code> - sisa dari enam monolitik <code>R = D mod 6. R</code> selalu memiliki nilai dalam kisaran <code>{0,1,2,3,4,5}</code> . <br></p><p></p><p>  Nilai <code>Q</code> dan <code>R</code> diperoleh dengan metode di atas dari sembarang interval <code>G</code> , karena karakteristik frekuensi stabilnya, tunduk pada kompresi dan penyimpanan dalam bentuk paket bit panjang variabel, dijelaskan di bawah ini.  Bit string yang menyandikan nilai <code>Q</code> dan <code>R</code> dalam sebuah paket dibuat dengan cara yang berbeda: untuk pengkodean indeks <code>Q</code> , rantai bit dari awalan <code>H</code> , fluks <code>F</code> dan bit bantu <code>S</code> , dan grup bit dari infix <code>X</code> dan bit bantu <code>A</code> digunakan untuk menyandikan sisanya <code>R</code> <br></p><p></p><p>  <code>A (arbiter)</code> - bit yang menentukan ukuran infiks <code>X</code> : 0 - infiks satu-bit, 1 - dua-bit. <br></p><p></p><p>  <code>X (infix)</code> - <code>X (infix)</code> 1- atau 2-bit, bersama-sama dengan bit arbiter <code></code> , saling menentukan nilai <code>R</code> cara tabular (tabel juga menunjukkan frekuensi keenam pertama dengan infiks tersebut sebagai referensi): <br></p><br><p><br><img src="https://habrastorage.org/webt/kp/hk/a4/kphka4ymveajnxr8icfzgggln4e.jpeg" alt="sedikit infiks"><br><br></p><br><p>  <code>F (fluxion)</code> adalah fluxion, turunan dari indeks <code>Q</code> panjang variabel <code>L={0,1,2...}</code> , yang dirancang untuk membedakan antara semantik string bit <code>(), 0, 00, 000,</code> atau <code>1, 01, 001</code> , dll. d. <br></p><p></p><p>  Rantai bit satuan panjang <code>L</code> dinyatakan sebagai <code>2^L - 1</code> (tanda <code>^</code> berarti eksponensial).  Dalam notasi C, nilai yang sama dapat diperoleh dengan ekspresi <code>1&lt;&lt;L - 1</code> .  Maka nilai fluksia panjang <code>L</code> dapat diperoleh dari <code>Q</code> ekspresi <br></p><p></p><p></p><pre> F = Q - (1 &lt;&lt; L - 1),
</pre><p></p><p>  dan mengembalikan <code>Q</code> dari fluxia dengan ekspresi <br></p><p></p><p></p><pre> Q = (1 &lt;&lt; L - 1) + F.
</pre><p></p><p>  Sebagai contoh, untuk kuantitas <code>Q = {0..15}</code> , rantai bit fluxia berikut akan diperoleh: <br></p><br><p><br><img src="https://habrastorage.org/webt/j0/kb/4y/j0kb4y3ob_yutugxxvpwlddqofc.jpeg" alt="bit fluks"><br><br></p><br><p>  Dua bidang bit terakhir yang diperlukan untuk pengemasan / pengembalian nilai adalah: <br></p><p></p><p>  <code>H (header)</code> - awalan, serangkaian bit diatur ke 0. <br></p><p></p><p>  <code>S (stop)</code> - berhenti bit yang diatur ke 1, mengakhiri awalan. <br></p><p></p><p>  Bahkan, bit ini diproses terlebih dahulu dalam string bit, mereka memungkinkan Anda untuk menentukan selama membongkar atau mengatur selama pengemasan ukuran fluks dan awal bidang arbiter dan fluks - segera setelah bit berhenti. <br></p><p></p><p>  <code>W (width)</code> - lebar seluruh kode dalam bit. <br></p><p></p><p>  Struktur lengkap dari paket bit ditunjukkan pada Gambar. 11: <br></p><br><p><br><img src="https://habrastorage.org/webt/ke/7u/tz/ke7utzoka0xkdd9dzzux6yden7e.jpeg" alt="gbr.  11"><br><br></p><br><p>  Nilai-nilai <code>Q</code> dan <code>R</code> pulih dari rantai ini memungkinkan kami untuk mengembalikan nilai awal interval: <br></p><p></p><p></p><pre> D = Q * 6 + R,
 G = (D + 1) * 2,
</pre><p></p><p>  dan urutan interval yang dipulihkan memungkinkan Anda untuk mengembalikan bilangan prima asli dari nilai dasar blok yang diberikan (seed seed of interval) dengan menambahkan padanya semua interval dari blok yang diberikan secara berurutan. <br></p><p></p><p>  Untuk bekerja dengan string bit, variabel integer 32-bit digunakan, di mana bit paling signifikan diproses dan setelah menggunakannya, bit digeser ke kiri saat pengemasan atau ke kanan saat membongkar. <br></p><p></p><br><h4>  Struktur blok </h4><br><p></p><p>  Selain string bit, blok berisi informasi yang diperlukan untuk mengambil atau menambahkan bit, serta untuk menentukan isi blok. <br></p><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    typedef unsigned char BYTE; typedef unsigned short WORD; typedef unsigned int LONG; typedef unsigned long long HUGE; typedef int BOOL; #define TRUE 1 #define FALSE 0 #define BLOCKSIZE (256) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ :   , #define HEADSIZE (8+8+2+2+2) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   , #define BODYSIZE (BLOCKSIZE-HEADSIZE) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/           typedef struct { HUGE base; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,      HUGE card; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        WORD count; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      WORD delta; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ base+delta =      WORD offset; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        BYTE body[BODYSIZE]; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    } crunch_block; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ,   put()  get() crunch_block block; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ NB:  len/val</span></span>  rev/rel     /<span class="hljs-regexp"><span class="hljs-regexp">/  ,    ,   /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . static struct tail_t { BYTE len; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      S  A BYTE val; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,   A  - S BYTE rev; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    BYTE rel; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    } tails[6] = { { 4, 3, 2, 3 }, { 4, 7, 5, 3 }, { 3, 1, 0, 4 }, { 4,11, 1, 4 }, { 4,15, 3, 4 }, { 3, 5, 4, 4 } }; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/             BOOL put(int gap) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 1.      int Q, R, L; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   (),  (),   int val = gap /</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>; Q = val / <span class="hljs-number"><span class="hljs-number">6</span></span>; R = val % <span class="hljs-number"><span class="hljs-number">6</span></span>; L = -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> .., <span class="hljs-number"><span class="hljs-number">0</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span> val = Q + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (val) { val <span class="hljs-meta"><span class="hljs-meta">&gt;&gt;= </span></span><span class="hljs-number"><span class="hljs-number">1</span></span>; L++; } /<span class="hljs-regexp"><span class="hljs-regexp">/    L val = Q - (1 &lt;&lt; L) + 1; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  val &lt;&lt;= tails[R].len; val += tails[R].val; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      val &lt;&lt;= L; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   L += L + tails[R].len; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 2.   val  L   buffer   put_index if (block.offset + L &gt; BODYSIZE * 8) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ !      return FALSE; Q = (block.offset /</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,      R = block.offset % <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     block.offset += L; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      block.count++; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     block.delta += gap; if (R &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) /<span class="hljs-regexp"><span class="hljs-regexp">/        { val &lt;&lt;= R; val |= block.body[Q]; L += R; } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     L = L /</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> + ((L % <span class="hljs-number"><span class="hljs-number">8</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     while (L-- &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { block.body[Q++] = (char)val; val &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; } return TRUE; } /<span class="hljs-regexp"><span class="hljs-regexp">/          int get_index; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      int get() { if (get_index &gt;= BODYSIZE * 8) return 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      int val = *((int*)&amp;block.body[get_index /</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>]) &gt;&gt; get_index % <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-number"><span class="hljs-number">4</span></span>   if (val == <span class="hljs-number"><span class="hljs-number">0</span></span>) return -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> !       int Q, R, L, F, M, len; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> , , , ,     L = <span class="hljs-number"><span class="hljs-number">0</span></span>; while (!(val &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>)) { val &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; L++; } /<span class="hljs-regexp"><span class="hljs-regexp">/  -     if ((val &amp; 3) == 1) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       R = (val &gt;&gt; 2) &amp; 1; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   else R = ((val &gt;&gt; 2) &amp; 3) + 2; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   len = tails[R].rel; get_index += 2 * L + len; val &gt;&gt;= len; M = ((1 &lt;&lt; L) - 1); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   F = val &amp; M; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    Q = F + M; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   return 2 * (1 + (6 * Q + tails[R].rev)); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         }</span></span></code> </pre><br><p></p><br><h4>  Perangkat tambahan </h4><br><p></p><p>  Jika kita memberi makan basis interval yang diperoleh ke pengarsipan 7-zip yang sama, maka dalam satu setengah jam kerja intensif pada server 8-core, ia berhasil mengompres file input sebesar hampir 5%.  Artinya, dalam database interval panjang variabel dari sudut pandang pengarsipan, masih ada beberapa redundansi.  Jadi ada alasan untuk berspekulasi sedikit (dalam arti kata yang baik) pada topik lebih lanjut mengurangi redundansi data. <br></p><p></p><p>  Determinisme mendasar dari urutan interval antara bilangan prima memungkinkan untuk membuat perhitungan yang tepat dari efisiensi pengkodean dengan satu metode atau yang lain.  Secara khusus, sketsa-sketsa kecil (dan agak kacau-balau) memungkinkan untuk menarik kesimpulan mendasar tentang kelebihan pengkodean sixes atas triples, dan tentang kelebihan metode yang diusulkan dibandingkan kode-kode sepele dengan panjang variabel (Gbr. 12): <br></p><br><p><br><img src="https://habrastorage.org/webt/w9/_l/9q/w9_l9qaibojgrxt5izuw4j7lxzc.jpeg" alt="gbr.  12"><br><br></p><br><p>  Namun, tingginya grafik merah yang menjengkelkan secara transparan mengisyaratkan bahwa mungkin ada metode penyandian lain yang akan membuat grafik lebih lembut. <br></p><p></p><p>  Arah lain menyarankan memeriksa frekuensi interval berurutan.  Dari pertimbangan umum: karena interval 6, 12, dan 18 adalah yang paling umum dalam populasi bilangan prima, maka mereka cenderung lebih sering ditemukan berpasangan (doublet), triples (triplet), dan kombinasi interval yang serupa.  Jika pengulangan duplets (dan bahkan mungkin kembar tiga ... yah, tiba-tiba!) Ternyata secara statistik signifikan dalam massa total interval, maka masuk akal untuk menerjemahkannya ke dalam beberapa kode terpisah. <br></p><p></p><p>  Eksperimen skala penuh tidak mengungkapkan dominasi tertentu dari doublet individu atas yang lain.  Namun, jika kepemimpinan absolut diharapkan untuk pasangan <code>(6,6)</code> - 1.37% dari semua doublet - maka pemenang lain dari peringkat ini jauh kurang jelas: <br></p><p><br><img src="https://habrastorage.org/webt/4m/jq/o-/4mjqo-jyxt27cpw6e6bnasgxl0s.jpeg" alt="statistik doublet"><br><br></p><br><p>  Dan, karena doublet <code>(6,6)</code> simetris, dan semua doublet yang dicatat lainnya asimetris dan ditemukan dalam pemeringkatan oleh mirror ganda dengan frekuensi yang sama, tampaknya catatan rekaman doublet <code>(6,6)</code> dalam seri ini harus dibagi dua di antara dua ganda yang tidak dapat dibedakan <code>(6,6)</code> dan <code>(6,6)</code> , yang membawa mereka 0,68% jauh ke batas daftar hadiah.  Dan ini sekali lagi menegaskan pengamatan bahwa tidak ada dugaan benar tentang bilangan prima dapat terjadi tanpa kejutan. <br></p><p></p><p>  Statistik kembar tiga juga menunjukkan kepemimpinan interval tiga kali lipat seperti itu, yang tidak cukup sesuai dengan asumsi spekulatif yang dimulai dari frekuensi tertinggi interval 6, 12, 18. Dalam menurunkan urutan popularitas, pemimpin frekuensi di antara kembar tiga terlihat sebagai berikut: <br></p><p><br><img src="https://habrastorage.org/webt/nn/if/sw/nnifswq5tugkq5kypoe44qllyj4.jpeg" alt="statistik rangkap tiga"><br><br></p><p>  dll. <br></p><p></p><p>  Saya takut, bagaimanapun, bahwa hasil spekulasi saya akan kurang menarik bagi programmer daripada untuk ahli matematika, mungkin karena koreksi tak terduga yang dilakukan oleh praktek menjadi tebakan intuitif.  Kecil kemungkinan bahwa akan mungkin untuk mengeluarkan dividen substansial dari persen frekuensi yang disebutkan demi peningkatan rasio kompresi lebih lanjut, sementara kompleksitas algoritme mengancam untuk tumbuh sangat signifikan. <br></p><p></p><p></p><h4>  Keterbatasan </h4><br><p></p><p>  Telah dicatat di atas bahwa peningkatan nilai maksimum interval sehubungan dengan kapasitas bilangan prima sangat, sangat lambat.  Secara khusus, dapat dilihat dari Gambar. 6 bahwa interval antara bilangan prima yang dapat direpresentasikan dalam format integer unsigned 64-bit jelas akan kurang dari 1600. <br></p><p></p><p>  Implementasi yang dijelaskan memungkinkan Anda untuk mengemas dan membongkar nilai interval 18-bit dengan benar (pada kenyataannya, kesalahan kemasan pertama terjadi dengan interval input 442358).  Saya tidak memiliki imajinasi yang cukup untuk menganggap bahwa basis data interval prima dapat tumbuh ke nilai-nilai seperti itu: begitu saja ada di suatu tempat di sekitar bilangan bulat 100-bit, dan untuk menghitung lebih tepatnya kemalasan.  Dalam kasus kebakaran, memperluas rentang interval pada waktu-waktu tertentu tidak akan sulit. <br></p><p></p><p>  Terima kasih sudah membaca tempat ini :) <br></p><br><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417753/">https://habr.com/ru/post/id417753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417741/index.html">27 Juli 2018 - gerhana bulan total dan konfrontasi hebat Mars</a></li>
<li><a href="../id417743/index.html">Amplifier Legendaris - Anatomi Tren Historis: Suara Transistor Dingin</a></li>
<li><a href="../id417745/index.html">Pengalaman Pribadi: Rekayasa Data di Upwork</a></li>
<li><a href="../id417747/index.html">Re: "Perbandingan kerangka JS: Bereaksi, Vue, dan Hyperapp"</a></li>
<li><a href="../id417749/index.html">Project Loon sebagai proyek komersial: kontrak pertama ditandatangani</a></li>
<li><a href="../id417755/index.html">Studi: 80% dari 2017 ICO dianggap curang</a></li>
<li><a href="../id417757/index.html">Membuat bot untuk berpartisipasi dalam cangkir mini AI. Pengalaman GPU</a></li>
<li><a href="../id417759/index.html">Jadilah bebek karet saya</a></li>
<li><a href="../id417761/index.html">GitLab bergerak dari Azure ke Google Cloud Platform. Berita Relokasi dan Tanggal Pemeliharaan</a></li>
<li><a href="../id417763/index.html">MVIDroid: tinjauan perpustakaan MVI baru (Model-View-Intent)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>