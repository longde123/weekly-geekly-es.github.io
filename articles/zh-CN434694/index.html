<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🍳 🐾 🍎 NeurIPS-2018概述（例如NIPS） ‼️ 🍟 🏂🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="12月初，蒙特利尔主办了第32届年度机器学习神经信息处理系统会议。 根据非官方的排名表，本次会议是世界上这种格式的前1名活动。 今年所有会议票都在创纪录的13分钟内售罄。 我们拥有一支由MTS数据科学家组成的庞大团队，但其中只有一个人-Marina Yaroslavtseva（ magoli ）-很...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>NeurIPS-2018概述（例如NIPS）</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ru_mts/blog/434694/"> 12月初，蒙特利尔主办了第32届年度机器学习<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">神经信息处理系统</a>会议。 根据非官方的排名表，本次会议是世界上这种格式的前1名活动。 今年所有会议票都在创纪录的13分钟内售罄。 我们拥有一支由MTS数据科学家组成的庞大团队，但其中只有一个人<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">-Marina</a> Yaroslavtseva（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">magoli</a> ）-很幸运能够到达蒙特利尔。 我们将与未获签证离开并跟随莫斯科会议的Danila Savenkov（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">danila_savenkov</a> ）一起讨论我们看来最有趣的作品。 该示例非常主观，但希望它会引起您的兴趣。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c10/868/6af/c108686af497e18c338a44c475d6d64e.png" alt="图片"><br><a name="habracut"></a><br>  <b>关系递归神经网络</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">摘要</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代号</a> <br><br> 使用序列时，序列元素之间如何相互关联通常非常重要。 递归网络的标准体系结构（GRU，LSTM）几乎无法对彼此相距遥远的两个元素之间的关系进行建模。 在某种程度上，注意力可以帮助解决此问题（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://youtu.be/SysgYptB198，https://youtu.be/quoGRI-1l0A</a> ），但这仍然不太正确。 注意使您可以确定权重，序列中每个步骤的隐藏状态将影响最终的隐藏状态，从而影响预测。 我们对序列元素的关系感兴趣。 <br><br> 去年，再次在NIPS上，谷歌建议完全放弃复发并使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">自我关注</a> 。 尽管主要针对seq2seq任务，但该方法被证明是非常好的（本文提供了机器翻译的结果）。 <br><br> 今年的文章将自我关注的概念用作LSTM的一部分。 更改不多： <br><br><ol><li> 我们将单元状态向量更改为“内存”矩阵M。在某种程度上，存储矩阵是许多单元状态向量（许多存储单元）。 获取序列的新元素后，我们确定该元素应更新每个存储单元多少。 </li><li> 对于序列中的每个元素，我们将使用多头点乘积注意（MHDPA，您可以在Google的上述文章中了解此方法）来更新此矩阵。 序列和矩阵M的当前元素的MHPDA结果通过一个完全连接的网格，S形，然后按照与LSTM中单元状态相同的方式进行更新 </li></ol><br> 有人认为，由于MHDPA，即使将序列元素彼此删除，网格也可以考虑序列元素的互连。 <br><br> 作为玩具问题，在向量序列中要求模型根据欧几里得距离，按与第M个的距离找到第N个向量。 例如，有一个10个向量的序列，我们要求您找到一个在第五个向量附近的第三个向量。 显然，为了回答模型的这个问题，有必要以某种方式评估从所有向量到第五个向量的距离并对它们进行排序。 在这里，作者提出的模型无疑击败了LSTM和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DNC</a> 。 此外，作者将他们的模型与“学习执行”（我们输入几行代码，给出结果），Mini-Pacman，语言建模等其他体系结构进行比较，并报告了最佳结果。 <br><br>  <b>生成对抗网络的多元时间序列归因</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">摘要</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代码</a> （尽管它们不在本文的链接中） <br><br> 通常，在多维时间序列中，存在大量遗漏，因此无法使用高级统计方法。 在这种情况下，标准解决方案-用均值/零填充，删除不完整的情况，基于矩阵展开来恢复数据通常不起作用，因为它们无法重现时间依赖性和多维时间序列的复杂分布。 <br><br> 生成对抗网络（GAN）模仿数据分布的能力，尤其是在“画脸”和生成句子的任务中，已广为人知。 但是，通常，这样的模型要么需要在没有间隙的完整数据集上进行初始训练，要么不考虑数据的一致性。 <br><br> 作者建议用一个新元素-归类归位插补单元（GRUI）来补充GAN。 与通常的GRU的主要区别在于，GRUI可以以观测之间不同长度的间隔从数据中学习，并根据观测与当前点之间的时间距离来调整观测的效果。 计算出一个特殊的衰减参数β，其值在0到1之间变化，值越小，当前观测值与先前的非空观测值之间的时滞越大。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ab/c71/63b/6abc7163bf3ff1b16310104100b53236.png" alt="图片"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/203/a64/599/203a6459932c852ad827db0d9574ef2c.png" alt="图片"><br><br> 鉴别器和GAN生成器均由GRUI层和完全连接的层组成。 与GAN中一样，生成器学习模拟源数据（在这种情况下，只需填充行中的间隙），而鉴别器则学习将生成器填充的行与实际的行区分开。 <br><br> 事实证明，这种方法即使在具有很大比例遗漏的时间序列中也可以非常充分地还原数据（在下表中-KDD数据集中的MSE数据恢复取决于遗漏的百分比和恢复方法。在大多数情况下，基于GAN的方法可以提供最高的准确性恢复）。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/188/737/e57/188737e575173058d1c0a79482b8679d.png" alt="图片"><br><br>  <b>词嵌入的维数</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">摘要</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代号</a> <br><br> 词的词嵌入/向量表示法是一种广泛用于各种NLP应用程序的方法：从推荐系统到对文本的情感着色和机器翻译的分析。 <br><br> 此外，如何最佳地设置向量维数这样重要的超参数的问题仍然存在。 在实践中，通常是通过经验穷举搜索来选择它，或者默认情况下将其设置为默认值，例如，在300的级别上。同时，维数太小不能反映单词之间的所有重要关系，而太大则可能导致重新训练。 <br><br> 该研究的作者通过最小化PIP损耗参数（这是两个嵌入选项之间差异的新度量）来提出解决方案。 <br> 该计算基于PIP矩阵，该矩阵包含语料库中单词的所有矢量表示形式对的标量积。  PIP损失是根据两个嵌入的PIP矩阵之间的Frobenius范数计算的：对数据进行训练（经训练的嵌入E_hat）和理想对噪声数据进行训练（对Oracle嵌入E）。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/135/a0a/1f2/135a0a1f216137c64ab73f9d2b86f0dc.png" alt="图片" width="300" height="200"></div><br><br> 这看起来很简单：您需要选择一个最小化PIP损失的维度，唯一无法理解的时刻是在哪里嵌入oracle。 在2015-2017年间，发表了许多作品，其中显示出各种用于构建嵌入的方法（word2vec，GloVe，LSA）隐式分解（降低维度）案例的信号矩阵。 在word2vec（跳过语法）的情况下，信号矩阵是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PMI</a> ，在GloVe的情况下，它是对数矩阵。 建议采用不大的字典，建立信号矩阵，并使用SVD进行oracle嵌入。 因此，oracle嵌入维数等于信号矩阵秩（实际上，对于10k个单词的字典，维数约为2k）。 但是，我们的经验信号矩阵始终是嘈杂的，我们必须采用棘手的方案来获得预兆嵌入并通过一个嘈杂的矩阵来估计PIP损失。 <br><br> 作者认为，要选择最佳的嵌入维数，只需使用10k个单词的字典就足够了，这不是很多，并且允许您在合理的时间内运行此过程。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/454/806/a20/454806a208dd7c10df8b9cbd365c440a.png" alt="图片"><br><br> 事实证明，以这种方式计算的嵌入尺寸在大多数情况下的误差最大为5％，这与根据专家估算值确定的最佳尺寸相吻合。 事实证明（预期）Word2Vec和GloVe实际上没有再训练（PIP损失在很大的范围内不会下降），但是LSA受到了非常强烈的再训练。 <br><br> 使用作者在github上发布的代码，可以搜索Word2Vec（略图），GloVe，LSA的最佳尺寸。 <br><br>  <b>FRAGE：与频率无关的单词表示</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">摘要</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代号</a> <br><br> 作者讨论了对于稀有词和流行词，嵌入如何不同地起作用。 流行，我的意思不是说停用词（我们根本不考虑它们），而是提供信息的词，这种情况并不罕见。 <br><br> 观察结果如下： <br><br> 如果我们谈论流行词，那么它们在余弦量度中的接近度反映得很好 <br><br><ol><li> 它们的语义亲和力。 对于稀有单词，情况并非如此（所期望的是），并且（最不期望的是）与稀有单词最接近的余弦词的前n个也很少见，同时在语义上也没有关系。 也就是说，嵌入空间中的稀有和频繁出现的单词生活在不同的地方（如果我们谈论余弦，则位于不同的圆锥体中） </li><li> 在训练过程中，流行词向量的更新频率要高得多，平均而言，其初始化距离是稀有词向量的两倍。 这导致了这样一个事实，即稀有词的嵌入平均而言更接近原点。 老实说，我一直相信，相反，稀有词的嵌入平均<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">更长，</a>而且我不知道如何与作者的statement = </li></ol><br> 无论嵌入的L2规范之间的关系如何，流行词和稀有词的可分离性不是一个很好的现象。 我们希望嵌入能够反映单词的语义，而不是单词的频率。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7e/f4d/e70/c7ef4de7034a8347269fa40d6bdc7005.png" alt="图片"><br><br> 图为SVD之后的Word2Vec流行（红色）和稀有（蓝色）单词。 这里的流行是指频率最高的20％单词。 <br><br> 如果问题仅在于嵌入的L2范数，我们可以对其进行归一化并快乐地生活，但是，正如我在第一段中所说的那样，稀有词也通过余弦接近度（在极坐标中）与流行的词分开。 <br><br> 作者建议，当然是GAN。 让我们做与以前相同的事情，但是添加一个区分器，尝试区分流行词和稀有词（同样，我们认为频率最高的前n％词是流行的）。 <br><br> 看起来像这样： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f0e/0a3/0b7/f0e0a30b77a9071ff63fa208401fad56.png" alt="图片"><br><br> 作者测试了该方法在单词相似性，机器翻译，文本分类和语言建模等任务上的性能，以及它们在性能上都比基准更好的地方。 用词相似性表示，稀有词的质量尤其明显提高。 <br><br> 一个例子：公民身份。 跳过问题：极乐，巴基斯坦，解雇，强化。 脆弱性问题：人口，社会地位，尊严，布尔格。  FRAGE中的“公民”和“公民”一词分别排在第79位和第7位（接近公民身份），在跳格图中它们不在前10000位。 <br><br> 由于某些原因，作者仅将代码发布用于机器翻译和语言建模，但没有显示库中的单词相似性和文本分类任务。 <br><br>  <b>语音和文本嵌入空间的无监督跨模态对齐</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">摘要</a> <br> 代码：无代码，但我想 <br><br> 最近的研究表明，使用嵌入算法（例如word2vec）在两种不同语言的文本主体上训练的两个向量空间可以彼此匹配，而无需在两个建筑物之间进行标记和内容匹配。 特别是，此方法用于Facebook上的机器翻译。 使用了嵌入空间的关键属性之一：在它们内部，相似的词在几何上应接近，而相异的词应彼此远离。 一般认为，向量空间的结构得以保留，而与语料库的教学语言无关。 <br><br> 本文的作者走得更远，并将类似的方法应用于自动语音识别和翻译领域。 建议针对感兴趣的语言（例如Wikipedia）分别针对文本语料库，针对录制的语音语料库（以音频格式）（可能是另一种语言）训练矢量空间，这些语言先前可能被分解为单词，然后以与对两个空间相同的方式比较这两个空间文字案。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d07/950/b6f/d07950b6f9bac05e9ce48dd80bb24838.png" alt="图片"><br><br> 对于文本语料库，将使用word2vec，对于语音，则将基于LSTM和用于word2vec的方法（CBOW / skip-gram）以类似的方法（由Speech2vec调用）进行，因此假定它是根据上下文和语义特征精确地组合单词的，没有声音。 <br><br> 在两个向量空间都经过训练之后，有两组嵌入-S（在语音主体上），由n个维度为d1的嵌入组成，T（在文本主体上），由m个维度为d2的嵌入组成，您需要对其进行比较。 理想情况下，我们有一个字典来确定S中的哪个向量与T中的哪个向量相对应。然后形成两个矩阵进行比较：从S中选择k个嵌入，形成大小为d1 xk的矩阵X。 从T中，还选择先前从S中选择的（根据字典）对应的k个嵌入，并且获得大小为d2×k的矩阵Y。 接下来，您需要找到一个线性映射W，使得： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db3/59e/e40/db359ee40ad9f907c6461d378db3d7aa.png" alt="图片" width="300" height="200"></div><br><br> 但是由于本文考虑了无监督方法，因此最初没有字典，因此，提出了一种由两部分组成的合成字典的生成过程。 首先，我们使用域对抗训练获得W的第一近似值（一种竞争模型，如GAN，而不是生成器-W的线性映射，通过它我们试图使S和T彼此无法区分，并且判别器试图确定嵌入的真正起源）。 然后，根据单词的嵌入相互之间显示出最佳匹配并且在两个建筑物中都最常见的单词，形成字典。 之后，根据上式对W进行细化。 <br><br> 这种方法提供的结果与在标记数据上学习的结果相当，这在识别和翻译来自很少有平行语音文本语料或不存在平行语种的稀有语言的语音的任务中非常有用。 <br><br>  <b>使用几何变换的深度异常检测</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">摘要</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代号</a> <br><br> 这组作者说，异常检测是一种非常不寻常的方法，大大击败了其他方法。 <br><br> 想法是这样的：让我们提出K个不同的几何变换（位移，90度旋转和反射的组合），并将其应用于原始数据集的每张图片。 通过第i次转换获得的图片现在将属于类别i，也就是说，总共将有K个类别，每个类别将由数据集中原始的图片数量表示。 现在，我们将在这种标记上讲授多类分类（作者选择了广泛的资源）。 <br><br> 现在我们可以为一张新图片获得尺寸为K的K个向量y（Ti（x）），其中Ti是第i个变换，x是图片，y是模型输出。  “正常”的基本定义如下： <br><br> 在这里，对于图像x，我们为所有变换添加了正确类别的预测概率。  “正态性”越大，从与训练样本相同的分布中获取图像的可能性就越大。 作者声称这已经很酷了，但是仍然提供了一种更复杂的方法，效果更好。 我们将假设每个Ti变换的向量y（Ti（x））是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Dirichlet</a>分布的，并且我们将似然对数作为图像“正态性”的量度。  Dirichlet分布参数是在训练集上估计的。 <br><br> 作者报告了与其他方法相比令人难以置信的性能提升。 <br><br>  <b>一个简单的统一框架，用于检测分布外样本和对抗性攻击</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">摘要</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代号</a> <br><br> 在样本中识别适用于案例模型的案例与训练样本的分布有显着差异，这是获得可靠分类结果的主要要求之一。 同时，神经网络以其特征（高度不正确）（以不正确的方式）对训练中未遇到或故意损坏的对象进行分类（对抗示例）而闻名。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1e0/780/f35/1e0780f3540fcb4ba894f38a40c31cbb.png" alt="图片"><br><br> 本文的作者提供了一种识别这些和其他“不良”案例的新方法。 该方法实现如下：首先，训练具有通常softmax输出的神经网络，然后获取其倒数第二层的输出，并在其上训练生成分类器。 假设有x-馈入模型的输入以用于特定的分类对象，y-对应的类标签，则假定我们具有以下形式的预先训练的softmax分类器： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/223/898/826/223898826445e2677c03a2078b182208.png" alt="图片" width="300" height="200"></div><br><br> 其中wc和bc是c类的softmax层的权重和常数，f（。）是倒数第二个大豆DNN的输出。 <br><br> 此外，在不对预训练分类器进行任何改变的情况下，向生成分类器进行过渡，即判别分析。 假设从softmax分类器的倒数第二层获取的特征具有多维正态分布，其每个分量对应于一个类别。 然后可以通过多维分布的矢量及其协方差矩阵来指定条件分布： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ada/0d8/e70/ada0d8e70536c7993a6061b154f3c0eb.png" alt="图片" width="300" height="200"></div><br><br> 为了评估生成分类器的参数，需要为每个类别计算经验平均值，以及来自训练样本{（x1，y1），...，（xN，yN）}的案例的协方差： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ada/0d8/e70/ada0d8e70536c7993a6061b154f3c0eb.png" alt="图片" width="300" height="200"></div><br><br> 其中N是训练集中相应类别的案例数。 然后，在测试样本上计算可靠性的度量-测试案例与最接近该案例的正态类别分布之间的马氏距离。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/095/928/03b/09592803b18f664fad5940fc81d47f77.png" alt="图片" width="400" height="300"></div><br><br> 事实证明，这种度量标准在非典型或损坏的对象上更可靠地工作，而无需像softmax层那样给出高估计。 在对不同数据进行的大多数比较中，所提出的方法显示出的结果超出了当前的最新水平，从而发现了两个不在训练中并故意损坏的情况。 <br><br> 此外，作者还考虑了其​​方法的另一个有趣应用：使用生成分类器突出显示尚未接受测试培训的新类，然后更新分类器本身的参数，以便将来可以确定该新类。 <br><br>  <b>欺骗计算机视觉和限时人类的对抗示例</b> <br> 摘要： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//arxiv.org/abs/1802.08195</a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作者考察了在人类感知方面的对抗性例子。如今，对于任何人来说，几乎永远都不会改变图像以使网络在其上犯错误，这不足为奇。但是，尚不清楚原始图片与一个人的对抗示例有多大差异以及它是否根本不同。显然，没有人会把右边的图片称为鸵鸟，但也许，一个人的右边图片与左边的图片并不完全相同，如果这样，一个人也可能遭受对抗攻击。</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/859/b13/cf0/859b13cf0bb3c14ac58eeab39b5a0945.png" alt="图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作者试图评估一个人对对抗性例子进行分类的能力。为了获得对抗性示例，使用了一种无法访问源网络体系结构的技术（作者的逻辑是，无论如何他们都不会被授予访问人脑体系结构的权限）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，如上图所示，一个人显示了一个对抗性示例，并被要求对其进行分类。显然，在正常情况下，结果是可以预测的，但此处在63毫秒内向一个人显示一张图像，此后他必须选择两个类别之一。在这种情况下，源图像的准确性比对抗性的要高10％。原则上，这可以通过以下事实来解释，即对抗图像只是嘈杂的，因此，在时间压力的情况下，人们会错误地对其进行分类，但这驳斥了以下实验。如果在将扰动添加到图像之前，我们垂直反映此扰动，则与原始图片相比，精度几乎不变。</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/966/f4d/e03/966f4de0389283dd83f73a1be2cf36cb.png" alt="图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在直方图上，adv是一个对抗示例，image是原始图像，flip是原始图像+对抗扰动，垂直反射。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显着性地图的健全性检查</font></font></b> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">摘要</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模型解释是当今讨论最多的主题之一。</font><font style="vertical-align: inherit;">当涉及深度学习时，他们通常谈论显着性图。</font><font style="vertical-align: inherit;">显着性图试图回答以下问题：输入值更改时，网格输出之一上的值如何更改。</font><font style="vertical-align: inherit;">这可能看起来像显着图，该图显示了哪些像素影响了图片被归类为“狗”的事实。</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/aa5/2c5/659/aa52c5659d4c00d7666661797671c4b9.png" alt="图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作者提出了一个非常合理的问题：“我们将如何验证构造显着图的方法？” </font><font style="vertical-align: inherit;">提出了两个需要验证的明显观点：</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 显着图应取决于网格权重 </font></font></li><li> Saliency map    ,     </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将通过以下方式检查第一个论点：将训练网格中的权重替换为随机值：级联随机化（从最后一层随机化层，并查看显着性图如何变化）和独立随机化（随机化特定层）。我们将像这样检查第二个论点：随机混合火车上的所有标签，使火车过拟合并查看显着性图。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果构造显着图的方法确实不错，并且可以让您了解模型的工作原理，那么这种随机化将极大地改变显着图。然而，作者指出：“令我们惊讶的是，一些广泛采用的显着性方法与训练模型的数据以及模型参数无关。”例如，在这里，看起来像级联随机化后使用各种算法获得的显着性图：</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/965/eaa/ca7/965eaaca7902d24ef5369a63d493b4ff.png" alt="图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意有趣的事实，最后一列对应于所有层中具有随机权重的网格。也就是说，网格可预测随机性，但某些显着性地图仍会绘制出一只鸟。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作者正确地指出-通过其可理解性和逻辑性对显着性图进行评估，而对结果与模型的工作原理之间的普遍关注不足则导致了确认偏差。显然，出于这个原因，事实证明，解释模型的通用方法根本无法解释模型。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">卷积神经网络的一个令人着迷的失败和CoordConv解决方案</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">摘要：</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">https</font></a><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">//arxiv.org/abs/1807.03247</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代码：已经有很多实现，并且总体上来说，这个想法是如此的优美和简单，以字面意义写成10行。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uber易于实施且很有前途的想法。卷积网络最初是为剪切不变性而锐化的，因此，对于此类网络而言，与确定对象坐标相关的任务非常困难。传统的卷积网络甚至无法解决玩具问题，例如确定图片中某个点的坐标或通过坐标绘制一个点：</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ed/408/c14/6ed408c1456a509c86a6260df5c5a23b.png" alt="图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提出了一种非常优雅的技巧：在图片中添加两个矩阵i和j（通常添加到CoodrConv层的输入中），其中包含相应像素的垂直和水平坐标：</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a2a/87e/8cb/a2a87e8cb6b7d283396a0fb3ef11fe30.png" alt="图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">据称：</font></font><br><br><ol><li>       ImageNet'.         , ,   ,    ,         </li><li> CoordConv   object detection.        MNIST,      Faster R-CNN,    IoU  21% </li><li>   CoordConv  GAN    . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fee/a18/425/feea18425335abbb7d784669a1b82bcd.png" alt="图片"><br><br>  GAN'   :                 LSUN.       ,     —     c.  ,   GAN'    , ,         .   CoordConv         ,      .    LSUN   d ,     ,  CoordConv GAN,    <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A2C中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用CoordConv </font><font style="vertical-align: inherit;">可以增加某些（并非全部）游戏。</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">就我个人而言，我对第二点最感兴趣，我想在真实数据集上查看结果，但是没有立即进行搜索。</font><font style="vertical-align: inherit;">同时CoordConv积极插入</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U形网</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://arxiv.org/abs/1812.01429,%2520"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://arxiv.org/abs/1812.01429，https://www.kaggle.com/c/tgs-salt-identification-challenge/discussion/69274</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTPS： //github.com/mjDelta/Kaggle-RSNA-Pneumonia-Detection-Challenge</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作者提供了一个很好的，更详细的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">视频</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过激活样本方差</font></font></b> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抽象</font></font></a> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">代码</font></a><b><font style="vertical-align: inherit;">的方差进行正则化</font></b></font><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作者提供了一个有趣的替代批标准化的方法。</font><font style="vertical-align: inherit;">我们将对网格进行细化处理，以实现某些层上激活分散的可变性。</font><font style="vertical-align: inherit;">实际上，他们是这样实现的：从批处理中获取两个不相交的子集S1和S2并计算出这样的值：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5f/2ea/97a/e5f2ea97aaebf6af472880bc2190b2cc.png" alt="图片" width="300" height="200"></div><br><br> 其中σ2是S1和S2中的样本方差，β是训练的正系数。 作者称这种东西为方差恒定损失（VCL），并将其加到总损失中。 <br><br> 在关于实验的部分中，作者抱怨如何不复制他人文章的结果，并承诺要自己设计可复制的代码（已设计）。 首先，他们在小图片（CIFAR-10和CIFAR-100）的数据集上实验了一个11层小的网格。 如果您使用Leaky ReLU或ELU作为激活，则可以证明VCL是可行的，但批处理规范化对ReLU的效果更好。 然后，他们将层数增加2倍，并切换到Tiny Imagenet-Tiny Imagenet的简化版本，具有200个类，分辨率为64x64。 在验证中，VCL在使用ELU以及ResNet-110和DenseNet-40时，在网格上的性能优于批次标准化，但在性能上优于Wide-ResNet-32。 有趣的一点是，当子集S1和S2由两个样本组成时，可获得最佳结果。 <br><br> 此外，作者在前馈网络中测试VCL，与具有批处理规范化或未进行规范化的网络相比，VCL获胜的频率更高。 <br><br>  <b>DropMax：自适应变分Softmax</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">摘要</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代号</a> <br><br> 在多类分类问题中，建议在每个样本的梯度下降迭代中随机丢弃一些不正确的类。 而且，我们还训练了我们针对一个或另一个对象放弃一个或另一个类的概率。 结果，事实证明网络“专注于”区分最难分离的类别。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b2d/f45/914/b2df45914519d3b6dd1d4f12d5513775.png" alt="图片"><br><br> 在MNIST，CIFAR和Imagenet子集上进行的实验表明，DropMax的性能优于标准SoftMax及其某些修改。 <br><br>  <b>具有成对交互的精确可理解模型</b> <br>  （朋友不要让朋友部署黑匣子模型：机器学习中可理解性的重要性） <br><br> 摘要： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//www.cs.cornell.edu/~yinlou/papers/lou-kdd13.pdf</a> <br> 代码：不存在。 我对作者如何在缺乏代码的情况下赋予这样一个有点命令性的名称非常感兴趣。 院士，先生=） <br><br> 您可以查看此软件包，例如： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//github.com/dswah/pyGAM</a> 。 不久之前就添加了功能交互（实际上是将GAM与GA2M区别开来）。 <br><br> 这篇文章是在“音频，语音和语言的可解释性和鲁棒性”研讨会的框架内介绍的，尽管它只讨论了模型的一般可解释性，而不是声音和语音分析领域，但可能每个人都在某种程度上面临着在模型的可解释性和模型之间做出选择的困境。其准确性。 如果我们使用通常的线性回归，那么我们可以通过系数来理解每个自变量如何影响因变量。 如果我们使用黑匣子模型（例如，不限制复杂性或深度神经网络的梯度增强），则在适当数据上正确调整的模型将非常准确，但跟踪和解释在数据中找到的模型的所有模式都会有问题。 因此，将很难向客户解释该模型并跟踪她是否学到了我们不想要的东西。 下表提供了各种类型模型的相对解释性和准确性的估计值。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fca/429/548/fca42954836ae74af472d4baacf732f1.png" alt="图片"><br><br> 该模型的可解释性差带来巨大风险的情况的一个示例：在一个医学数据集上，解决了预测患者死于肺炎的可能性的问题。 在数据中发现了以下有趣的模式：如果一个人患有支气管哮喘，那么死于肺炎的可能性比没有该疾病的人低。 当研究人员求助于执业医生时，事实证明确实存在这种模式，因为患有肺炎的哮喘患者会得到最直接的帮助和强有力的药物治疗。 如果我们在此数据集上对xgboost进行训练，则很可能他会抓住这种模式，并且我们的模型会将哮喘患者归为低危人群，并因此建议对他们的优先级和治疗强度较低。 <br><br> 本文的作者提供了一种同时可以解释和准确的替代方法-GA2M，它是广义加性模型的一个亚种。 <br><br> 经典GAM可以看作是GLM的进一步概括：模型是一个总和，模型的每个项仅反映一个自变量对因变量的影响，但该影响不是像GLM中那样由权重系数表示，而是由光滑的非参数函数表示（通常是分段定义）功能-小深度的花键或树木，包括“树桩”）。 由于此功能，GAM可以比简单的线性模型建模更复杂的关系。 另一方面，学习的依赖关系（功能）可以可视化和解释。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/643/828/ca8/643828ca8aaeb0f0728ba2d094de7e43.png" alt="图片"><br><br> 但是，标准GAM仍然经常达不到黑盒算法的准确性。 为了解决这个问题，本文的作者提出了一个折衷方案-除了将一个变量的功能添加到模型方程式之外，还添加少量的两个变量的功能-精心选择的对，其相互作用对于预测因变量具有重要意义。 因此，获得了GA2M。 <br><br> 首先，建立标准GAM（不考虑变量之间的相互作用），然后逐步添加变量对（其余GAM用作目标变量）。 对于存在大量变量并且在每个步骤之后都难以计算的情况下更新模型的情况，提出了一种FAST排名算法，您可以使用该算法预先选择可能有用的对，并避免完整的枚举。 <br><br> 这种方法使我们可以获得接近无限复杂度模型的质量。 该表显示了与随机森林相比通用加法模型的错误率，以解决不同数据集上的分类问题，并且在大多数情况下，采用FAST的GA2M和随机森林的预测质量没有显着差异。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e5b/809/a50/e5b809a50067cbfcd2f7bbb04f98630e.png" alt="图片"><br><br> 我想提请注意学者的工作特点，他们愿意将这些推动力和深远的影响传递给熔炉。 请注意，在其上显示结果的数据集包含不超过2万个对象（来自UCI存储库的所有数据集）。 随之而来的是一个自然的问题：在2018年，这样的实验真的没有正常大小的开放数据集吗？ 您可以进一步对50个对象的数据集进行比较-常量模型与随机森林的差异可能不会很大。 <br><br> 接下来是正则化。 在许多迹象上，即使没有互动也很容易重新训练。 作者可能认为这个问题不存在，唯一的问题是黑盒模型。 至少在本文中，尽管显然有必要，但在任何地方都没有提及正则化。 <br><br> 最后是关于可解释性。 如果我们有很多功能，那么即使线性模型也无法解释。 当您有一万个正态分布的权重时（在使用L2正则化的情况下将是这样），无法确切地说出哪些符号导致了predict_proba给出0.86的事实。 为了便于解释，我们不仅需要线性模型，还需要权重稀疏的线性模型。 看起来这可以通过L1正则化来实现，但是在这里也不是那么简单。 从一组高度相关的功能中，L1正则化几乎是偶然选择的。 其余的权重为0，尽管如果这些功能之一具有预测能力，则其他功能显然不仅仅是噪声。 就模型解释而言，这可能是可以的，就理解特征与目标变量的关系而言，这是非常糟糕的。 也就是说，即使使用线性模型，也不是所有事情都那么简单，有关可解释和可信模型的更多详细信息可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>找到。 <br><br>  <b>机器学习的可视化：UMAP</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">抽象</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代号</a> <br><br> 在上课当天，第一个执行的任务是Google Brain的“机器学习的可视化”。 在本教程中，我们从第一张图表的创建者开始了解到可视化的历史，还介绍了人脑的各种功能以及可以用来吸引人们注意图片中最重要事物的感知和技术，甚至包含许多小细节，例如突出显示形状，颜色，框架等，如下图所示。 我将跳过这一部分，但是有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">很好的评论</a> 。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/751/f0f/c31/751f0fc318a4bb3edadf59e35ecc7ba9.png" alt="图片"><br><br> 我个人最感兴趣的是多维数据集的可视化主题，特别是统一流形近似和投影（UMAP）方法-一种新的缩小维数的非线性方法。 它是在今年2月提出的，因此很少有人使用它，但是从工作时间和二维可视化中类的分离质量来看，它看起来都很有希望。 因此，在不同的数据集上，UMAP在速度方面比t-SNE和其他方法高2-10倍，并且数据维度越大，性能差距越大： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b82/045/a12/b82045a12b1cb8782c5c9fb64dfa46b9.png" alt="图片"><br><br> 此外，与t-SNE不同，UMAP的运行时间几乎与我们将数据集嵌入到其中的新空间的尺寸无关（请参见下图），这使其成为其他任务（可视化之外）的合适工具-特别是，在训练模型之前减小尺寸。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0c6/f14/56a/0c6f1456a68537b5e12f58f6e1dfb740.png" alt="图片"><br><br> 同时，在不同的数据集上进行的测试表明，UMAP在可视化方面并不差劲，而t-SNE在某些地方更胜一筹：例如，在MNIST和Fashion MNIST数据集上，使用UMAP的版本将类更好地分开： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f35/4b4/869/f354b48691226fd262e3f92af9fe398f.png" alt="图片"><br><br> 另外一个方便的实现是：UMAP类继承自sklearn类，因此您可以将其用作sklearn管道中的常规转换器。 另外，有人认为UMAP比t-SNE更可解释，因为 更好地维护全局数据结构。 <br><br> 将来，作者计划增加对半监督训练的支持-也就是说，如果我们至少有一些对象具有标签，则可以基于此信息构建UMAP。 <br><br> 您喜欢什么文章？ 写评论，问问题，我们会回答。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN434694/">https://habr.com/ru/post/zh-CN434694/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN434684/index.html">Rust 2019及以后：增长限制</a></li>
<li><a href="../zh-CN434686/index.html">KPI中的JavaScript和Node.js讲座</a></li>
<li><a href="../zh-CN434688/index.html">FreeBSD计划切换到ZFSonLinux</a></li>
<li><a href="../zh-CN434690/index.html">Haiku操作系统：移植应用程序和创建软件包</a></li>
<li><a href="../zh-CN434692/index.html">美国最昂贵的25家初创公司将于2018年死亡</a></li>
<li><a href="../zh-CN434696/index.html">IT巨头的员工想出了如何影响公司政策的方法</a></li>
<li><a href="../zh-CN434698/index.html">对多线程的悲观主义</a></li>
<li><a href="../zh-CN434700/index.html">开发Angular应用程序时遵循样式指南的优点</a></li>
<li><a href="../zh-CN434702/index.html">为什么现代SSD使我崩溃</a></li>
<li><a href="../zh-CN434704/index.html">俄罗斯移动流量成本下降的原因以及对2019年的预测</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>