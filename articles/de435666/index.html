<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßïüèΩ üë©üèø üôä Asynchrone Desynchronisation: Antimuster bei der Arbeit mit async / await in .NET üåõ ü¶ì üéóÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wer von uns m√§ht nicht? Ich sto√üe regelm√§√üig auf Fehler im asynchronen Code und mache sie selbst. Um dieses Rad von Samsara zu stoppen, teile ich mit ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Asynchrone Desynchronisation: Antimuster bei der Arbeit mit async / await in .NET</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dodopizzadev/blog/435666/"><p>  Wer von uns m√§ht nicht?  Ich sto√üe regelm√§√üig auf Fehler im asynchronen Code und mache sie selbst.  Um dieses Rad von Samsara zu stoppen, teile ich mit Ihnen die typischsten Pfosten von denen, die manchmal ziemlich schwer zu fangen und zu reparieren sind. </p><br><img src="https://habrastorage.org/webt/os/oz/lt/osozltujeowuulzfvdaxvehuvpg.png"><br><a name="habracut"></a><br><blockquote>  Dieser Text ist inspiriert vom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog von Stephen Clary</a> , einem Mann, der alles √ºber Wettbewerbsf√§higkeit, Asynchronit√§t, Multithreading und andere be√§ngstigende W√∂rter wei√ü.  Er ist der Autor des Buches <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Concurrency in C # Cookbook</a> , das eine Vielzahl von Mustern f√ºr die Arbeit mit dem Wettbewerb gesammelt hat. </blockquote><br><h2>  Klassischer asynchroner Deadlock </h2><br><p>  Um den asynchronen Deadlock zu verstehen, sollten Sie herausfinden, welcher Thread die mit dem Schl√ºsselwort await aufgerufene Methode ausf√ºhrt. </p><br><p>  Zun√§chst wird die Methode die Aufrufkette von asynchronen Methoden untersuchen, bis sie auf eine asynchrone Quelle st√∂√üt.  Wie genau die Quelle der Asynchronit√§t implementiert ist, ist ein Thema, das den Rahmen dieses Artikels sprengt.  Der Einfachheit halber nehmen wir an, dass dies ein Vorgang ist, f√ºr den kein Workflow erforderlich ist, w√§hrend auf das Ergebnis gewartet wird, z. B. eine Datenbankanforderung oder eine HTTP-Anforderung.  Der synchrone Start einer solchen Operation bedeutet, dass w√§hrend des Wartens auf das Ergebnis im System mindestens ein einschlafender Thread vorhanden ist, der Ressourcen verbraucht, aber keine n√ºtzliche Arbeit leistet. </p><br><p> Bei einem asynchronen Aufruf unterbrechen wir den Ausf√ºhrungsfluss von Befehlen f√ºr "vor" und "nach" der asynchronen Operation, und in .NET gibt es keine Garantie daf√ºr, dass der Code, der nach dem Warten liegt, im selben Thread ausgef√ºhrt wird wie der Code vor dem Warten.  In den meisten F√§llen ist dies nicht erforderlich, aber was ist zu tun, wenn ein solches Verhalten f√ºr das Funktionieren des Programms von entscheidender Bedeutung ist?  <code>SynchronizationContext</code> .  Dies ist ein Mechanismus, mit dem Sie den Threads, in denen der Code ausgef√ºhrt wird, bestimmte Einschr√§nkungen auferlegen k√∂nnen.  Als n√§chstes werden wir uns mit zwei Synchronisationskontexten befassen ( <code>WindowsFormsSynchronizationContext</code> und <code>AspNetSynchronizationContext</code> ), aber Alex Davis schreibt in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">seinem Buch,</a> dass es in .NET ungef√§hr ein Dutzend davon gibt.  √úber <code>SynchronizationContext</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> gut geschrieben, und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier hat der</a> Autor seinen eigenen implementiert, f√ºr den er gro√üen Respekt hat. </p><br><p>  Sobald der Code an der Quelle der Asynchronit√§t ankommt, speichert er den Synchronisationskontext, der sich in der thread-statischen Eigenschaft von <code>SynchronizationContext.Current</code> befand. Anschlie√üend wird die asynchrone Operation gestartet und der aktuelle Thread freigegeben.  Mit anderen Worten, w√§hrend wir auf den Abschluss der asynchronen Operation warten, blockieren wir keinen einzelnen Thread, und dies ist der Hauptgewinn der asynchronen Operation im Vergleich zur synchronen.  Nach Abschluss der asynchronen Operation m√ºssen wir den Anweisungen folgen, die sich nach der asynchronen Quelle befinden. Um zu entscheiden, in welchem ‚Äã‚ÄãThread der Code nach der asynchronen Operation ausgef√ºhrt werden soll, m√ºssen wir den zuvor gespeicherten Synchronisationskontext konsultieren.  Wie er sagt, werden wir das tun.  Er wird Ihnen sagen, dass Sie im selben Thread wie der Code ausf√ºhren sollen, bevor Sie warten - wir werden im selben Thread ausf√ºhren, nicht sagen - wir werden den ersten Thread aus dem Pool nehmen. </p><br><p>  Was aber, wenn es in diesem speziellen Fall f√ºr uns wichtig ist, dass der Code nach dem Warten in einem freien Thread aus dem Thread-Pool ausgef√ºhrt wird?  Sie m√ºssen das <code>ConfigureAwait(false)</code> Mantra <code>ConfigureAwait(false)</code> .  Der an den Parameter <code>continueOnCapturedContext</code> falsche Wert teilt dem System mit, dass jeder Thread aus dem Pool verwendet werden kann.  Und was passiert, wenn zum Zeitpunkt der Methodenausf√ºhrung mit Warten √ºberhaupt kein Synchronisationskontext vorhanden war ( <code>SynchronizationContext.Current == null</code> ), wie zum Beispiel in einer Konsolenanwendung.  In diesem Fall gibt es keine Einschr√§nkungen f√ºr den Thread, in dem der Code nach dem Warten ausgef√ºhrt werden soll, und das System nimmt den ersten Thread aus dem Pool, wie im Fall von <code>ConfigureAwait(false)</code> . </p><br><p>  Was ist ein asynchroner Deadlock? </p><br><h4>  Deadlock in WPF und WinForms </h4><br><p>  Der Unterschied zwischen WPF- und WinForms-Anwendungen liegt im Kontext der Synchronisierung.  Der Synchronisationskontext von WPF und WinForms hat einen speziellen Thread - den Benutzeroberfl√§chenthread.  Pro <code>SynchronizationContext</code> gibt es einen UI-Thread, und nur dieser Thread kann mit Elementen der Benutzeroberfl√§che interagieren.  Standardm√§√üig setzt der Code, der im UI-Thread zu arbeiten begonnen hat, den Betrieb nach einem asynchronen Vorgang fort. </p><br>  Schauen wir uns nun ein Beispiel an: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, System.Windows.RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { StartWork().Wait(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">"Just to illustrate the instruction following await"</span></span>; }</code> </pre><br>  Was passiert, wenn Sie <code>StartWork().Wait()</code> aufrufen <code>StartWork().Wait()</code> : <br><br><ol><li>  Der aufrufende Thread (und dies ist der Benutzeroberfl√§chenthread) wechselt in die <code>StartWork</code> Methode und in die Anweisung <code>await Task.Delay(100)</code> . </li><li>  Der UI-Thread startet die asynchrone <code>Task.Delay(100)</code> <code>Button_Click</code> und gibt die Steuerung an die <code>Button_Click</code> Methode zur√ºck. Dort <code>Wait()</code> die <code>Wait()</code> -Methode der <code>Task</code> Klasse darauf.  Wenn die <code>Wait()</code> -Methode aufgerufen wird, wird der UI-Thread bis zum Ende des asynchronen Vorgangs blockiert, und wir gehen davon aus, dass der UI-Thread nach Abschluss der Ausf√ºhrung sofort die Ausf√ºhrung aufnimmt und den Code weiterf√ºhrt. Es ist jedoch alles falsch. </li><li>  Sobald <code>Task.Delay(100)</code> abgeschlossen ist, muss der UI-Thread zuerst die <code>StartWork()</code> -Methode weiter ausf√ºhren und ben√∂tigt dazu genau den Thread, in dem die Ausf√ºhrung gestartet wurde.  Der UI-Thread wartet nun jedoch auf das Ergebnis der Operation. </li><li>  <code>StartWork()</code> : <code>StartWork()</code> kann die Ausf√ºhrung nicht fortsetzen und das Ergebnis zur√ºckgeben, und <code>Button_Click</code> wartet auf dasselbe Ergebnis. Aufgrund der Tatsache, dass die Ausf√ºhrung im Benutzeroberfl√§chenthread gestartet wurde, bleibt die Anwendung einfach h√§ngen, ohne dass die M√∂glichkeit besteht, weiter zu arbeiten. </li></ol><br>  Diese Situation kann ganz einfach behandelt werden, indem der Aufruf von <code>Task.Delay(100)</code> in <code>Task.Delay(100).ConfigureAwait(false)</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, System.Windows.RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { StartWork().Wait(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">100</span></span>).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">"Just to illustrate the instruction following await"</span></span>; }</code> </pre><br><p>  Dieser Code funktioniert ohne Deadlocks, da jetzt ein Thread aus dem Pool verwendet werden kann, um die <code>StartWork()</code> -Methode zu vervollst√§ndigen, anstatt ein blockierter UI-Thread.  Stephen Clary empfiehlt die Verwendung von <code>ConfigureAwait(false)</code> in allen ‚ÄûBibliotheksmethoden‚Äú in seinem Blog, betont jedoch ausdr√ºcklich, dass die Verwendung von <code>ConfigureAwait(false)</code> zur Behandlung von Deadlocks keine gute Vorgehensweise ist.  Stattdessen r√§t er, KEINE Blockierungsmethoden wie <code>Wait()</code> , <code>Result</code> , <code>GetAwaiter().GetResult()</code> und alle Methoden so zu <code>GetAwaiter().GetResult()</code> , dass sie nach M√∂glichkeit async / await verwenden (das sogenannte Async-All-Way-Prinzip). </p><br><h4>  Deadlock in ASP.NET </h4><br><p>  ASP.NET hat auch einen Synchronisationskontext, jedoch geringf√ºgig andere Einschr√§nkungen.  Sie k√∂nnen jeweils nur einen Thread pro Anforderung verwenden und m√ºssen au√üerdem den Code nach dem Warten im selben Thread wie den Code vor dem Warten ausf√ºhren. </p><br>  Ein Beispiel: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HomeController</span></span> : <span class="hljs-title"><span class="hljs-title">Controller</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ActionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Deadlock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { StartWork().Wait(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> View(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">"Just to illustrate the code following await"</span></span>; } }</code> </pre><br><p>  Dieser Code verursacht auch einen Deadlock, da zum Zeitpunkt des Aufrufs von <code>StartWork().Wait()</code> einzige zul√§ssige Thread blockiert wird und auf den <code>StartWork()</code> der <code>StartWork()</code> wartet und niemals endet, da der Thread, in dem die Ausf√ºhrung fortgesetzt werden soll, besch√§ftigt ist Warten. </p><br><p>  Dies wird alles durch dasselbe <code>ConfigureAwait(false)</code> behoben. </p><br><h4>  Deadlock in ASP.NET Core (eigentlich nicht) </h4><br><p>  Versuchen wir nun, den Code aus dem Beispiel f√ºr ASP.NET im Projekt f√ºr ASP.NET Core auszuf√ºhren.  Wenn wir dies tun, werden wir sehen, dass es keinen Deadlock geben wird.  Dies liegt daran, dass ASP.NET Core <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">keinen Synchronisationskontext hat</a> .  Gro√üartig!  Und jetzt k√∂nnen Sie den Code mit blockierenden Anrufen abdecken und haben keine Angst vor Deadlocks?  Genau genommen ja, aber denken Sie daran, dass der Thread w√§hrend des Wartens einschlafen muss, dh der Thread verbraucht Ressourcen, leistet aber keine n√ºtzliche Arbeit. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pv/qe/hc/pvqehcevrmzzqhylr7vtedbqwtc.png"></div><br><br><p></p><blockquote>  <b>Denken Sie daran, dass durch die Verwendung des Blockierens von Anrufen alle Vorteile der asynchronen Programmierung beseitigt werden und diese synchronisiert werden</b> .  Ja, manchmal ohne <code>Wait()</code> funktioniert das Schreiben eines Programms nicht, aber der Grund muss schwerwiegend sein. </blockquote><br><h2>  Fehlerhafte Verwendung von Task.Run () </h2><br><p>  Die <code>Task.Run()</code> -Methode wurde erstellt, um Vorg√§nge in einem neuen Thread zu starten.  Wie es sich f√ºr eine in einem TAP-Muster geschriebene Methode geh√∂rt, gibt sie <code>Task</code> oder <code>Task&lt;T&gt;</code> und Personen, die zum ersten Mal mit Async / <code>Task.Run()</code> konfrontiert sind, haben den gro√üen Wunsch, synchronen Code in <code>Task.Run()</code> zu verpacken und das Ergebnis dieser Methode zu verwenden.  Der Code schien asynchron zu werden, aber tats√§chlich hat sich nichts ge√§ndert.  Mal sehen, was mit dieser Verwendung von <code>Task.Run()</code> passiert. </p><br>  Ein Beispiel: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteOperation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Before: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{Thread.CurrentThread.ManagedThreadId}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Run(() =&gt; { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Inside before sleep: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{Thread.CurrentThread.ManagedThreadId}</span></span></span><span class="hljs-string">"</span></span>); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Inside after sleep: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{Thread.CurrentThread.ManagedThreadId}</span></span></span><span class="hljs-string">"</span></span>); }); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"After: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{Thread.CurrentThread.ManagedThreadId}</span></span></span><span class="hljs-string">"</span></span>); }</code> </pre><br>  Das Ergebnis dieses Codes ist: <br><br><pre> <code class="plaintext hljs">Before: 1 Inside before sleep: 3 Inside after sleep: 3 After: 3</code> </pre><br><p>  Hier ist <code>Thread.Sleep(1000)</code> eine Art synchroner Vorgang, f√ºr dessen Abschluss ein Thread erforderlich ist.  Angenommen, wir m√∂chten unsere L√∂sung asynchron machen und damit diese Operation eingeschl√§fert werden kann, haben wir sie in <code>Task.Run()</code> . </p><br><p>  Sobald der Code die <code>Task.Run()</code> -Methode erreicht, wird ein weiterer Thread aus dem Thread-Pool entnommen und der Code, den wir an <code>Task.Run()</code> darin ausgef√ºhrt.  Der alte Thread kehrt, wie es sich f√ºr einen anst√§ndigen Thread geh√∂rt, in den Pool zur√ºck und wartet darauf, dass er erneut aufgerufen wird, um die Arbeit zu erledigen.  Der neue Thread f√ºhrt den √ºbertragenen Code aus, erreicht die synchrone Operation, f√ºhrt ihn synchron aus (wartet, bis die Operation abgeschlossen ist) und geht weiter entlang des Codes.  Mit anderen Worten, die Operation blieb synchron: Wir verwenden den Stream wie zuvor w√§hrend der Ausf√ºhrung der synchronen Operation.  Der einzige Unterschied besteht darin, dass wir beim Aufrufen von <code>Task.Run()</code> und beim Zur√ºckkehren zu <code>ExecuteOperation()</code> Zeit damit verbracht haben, den Kontext zu <code>ExecuteOperation()</code> .  Alles ist etwas schlimmer geworden. </p><br><p>  Es versteht sich, dass trotz der Tatsache, dass in den Zeilen <code>Inside after sleep: 3</code> und <code>After: 3</code> dieselbe ID des Streams angezeigt wird, der Ausf√ºhrungskontext an diesen Stellen v√∂llig unterschiedlich ist.  ASP.NET ist einfach schlauer als wir und versucht, Ressourcen zu sparen, wenn der Kontext von Code in <code>Task.Run()</code> auf externen Code <code>Task.Run()</code> .  Hier beschloss er, zumindest den Hinrichtungsfluss nicht zu √§ndern. </p><br><p>  In solchen F√§llen ist es nicht sinnvoll, <code>Task.Run()</code> .  Stattdessen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">empfiehlt</a> Clary, alle Operationen asynchron zu machen, <code>Thread.Sleep(1000)</code> in unserem Fall <code>Thread.Sleep(1000)</code> durch <code>Thread.Sleep(1000)</code> zu <code>Task.Delay(1000)</code> , aber dies ist nat√ºrlich nicht immer m√∂glich.  Was tun, wenn wir Bibliotheken von Drittanbietern verwenden, die wir nicht umschreiben und bis zum Ende asynchron machen k√∂nnen oder wollen, aber aus dem einen oder anderen Grund die asynchrone Methode ben√∂tigen?  Es ist besser, <code>Task.FromResult()</code> zu verwenden, um das Ergebnis der Herstellermethoden in Task zu verpacken.  Dies macht den Code nat√ºrlich nicht asynchron, aber wir sparen zumindest beim Kontextwechsel. </p><br><p></p><blockquote>  <b>Warum dann Task.Run () verwenden?</b>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Antwort ist einfach:</a> F√ºr CPU-gebundene Vorg√§nge, wenn Sie die Reaktionsf√§higkeit der Benutzeroberfl√§che beibehalten oder die Berechnungen parallelisieren m√ºssen.  Hier muss gesagt werden, dass CPU-gebundene Operationen synchroner Natur sind.  <code>Task.Run()</code> synchrone Operationen in einem asynchronen Stil zu starten, wurde <code>Task.Run()</code> erfunden. </blockquote><br><h2>  Missbrauch der asynchronen Leere </h2><br>  Die M√∂glichkeit, asynchrone Methoden zu schreiben, die <code>void</code> wurde hinzugef√ºgt, um asynchrone Ereignishandler zu schreiben.  Mal sehen, warum sie Verwirrung stiften k√∂nnen, wenn sie f√ºr andere Zwecke verwendet werden: <br><br><ol><li>  Sie k√∂nnen nicht auf das Ergebnis warten. </li><li>  Ausnahmebehandlung durch Try-Catch wird nicht unterst√ºtzt. </li><li>  Es ist unm√∂glich, Aufrufe √ºber <code>Task.WhenAll()</code> , <code>Task.WhenAny()</code> und andere √§hnliche Methoden zu kombinieren. </li></ol><br><p>  Von all diesen Gr√ºnden ist der interessanteste Punkt die Behandlung von Ausnahmen.  Tatsache ist, dass bei asynchronen Methoden, die <code>Task</code> oder <code>Task&lt;T&gt;</code> , Ausnahmen abgefangen und in ein <code>Task</code> Objekt eingeschlossen werden, das dann an die aufrufende Methode √ºbergeben wird.  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ihrem Artikel f√ºr MSDN</a> schreibt Clary, dass es in async-void-Methoden keinen R√ºckgabewert gibt, dass nichts in Ausnahmen eingeschlossen werden kann und diese direkt im Kontext der Synchronisation ausgel√∂st werden.  Das Ergebnis ist eine nicht behandelte Ausnahme, aufgrund derer der Prozess abst√ºrzt und m√∂glicherweise Zeit hat, einen Fehler in die Konsole zu schreiben.  Sie k√∂nnen solche Ausnahmen <code>AppDomain.UnhandledException</code> und reservieren, indem Sie das Ereignis <code>AppDomain.UnhandledException</code> abonnieren. Sie k√∂nnen den Prozessabsturz jedoch auch im Handler dieses Ereignisses nicht mehr stoppen.  Dieses Verhalten ist nur f√ºr den Ereignishandler typisch, nicht jedoch f√ºr die √ºbliche Methode, von der wir die M√∂glichkeit einer Standardausnahmebehandlung durch Try-Catch erwarten. </p><br>  Wenn Sie beispielsweise in einer ASP.NET Core-Anwendung so schreiben, wird der Prozess garantiert abgebrochen: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IActionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ThrowInAsyncVoid</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ThrowAsynchronously(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> View(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ThrowAsynchronously</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Obviously, something happened"</span></span>); }</code> </pre><br><p>  Es lohnt sich jedoch, den R√ºckgabetyp der <code>ThrowAsynchronously</code> Methode in <code>Task</code> zu √§ndern (ohne das Schl√ºsselwort await hinzuzuf√ºgen), und die Ausnahme wird vom Standard-ASP.NET Core-Fehlerbehandler abgefangen, und der Prozess wird trotz der Ausf√ºhrung weiterhin ausgef√ºhrt. </p><br><p></p><blockquote>  <b>Seien Sie vorsichtig mit asynchronen Methoden</b> - sie k√∂nnen Sie in den Prozess einbeziehen. </blockquote><br><h2>  Warten Sie in einer einzeiligen Methode </h2><br><p>  Das letzte Antimuster ist nicht so be√§ngstigend wie die vorherigen.  Das Fazit ist, dass es keinen Sinn macht, async / await in Methoden zu verwenden, die beispielsweise einfach das Ergebnis einer anderen asynchronen Methode weiterleiten, mit der m√∂glichen Ausnahme der Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">await bei der Verwendung</a> . </p><br>  Anstelle dieses Codes: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethodAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); }</code> </pre><br>  es w√§re durchaus m√∂glich (und vorzugsweise) zu schreiben: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethodAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); }</code> </pre><br><p>  Warum funktioniert es?  Weil das Schl√ºsselwort await auf aufgaben√§hnliche Objekte angewendet werden kann und nicht auf Methoden, die mit dem Schl√ºsselwort async gekennzeichnet sind.  Das Schl√ºsselwort async teilt dem Compiler wiederum nur mit, dass diese Methode auf einer Zustandsmaschine bereitgestellt werden muss, und alle zur√ºckgegebenen Werte sollten in eine <code>Task</code> (oder in ein anderes Task-√§hnliches Objekt) eingeschlossen werden. </p><br><p>  Mit anderen Worten, das Ergebnis der ersten Version der Methode ist <code>Task</code> , die abgeschlossen wird, sobald das Warten auf <code>Task.Delay(1000)</code> endet, und das Ergebnis der zweiten Version der Methode ist <code>Task</code> , das von <code>Task.Delay(1000)</code> wird und <code>Completed</code> , sobald 1000 Millisekunden vergehen . </p><br><p>  Wie Sie sehen k√∂nnen, sind beide Versionen gleichwertig, aber gleichzeitig erfordert die erste viel mehr Ressourcen, um ein asynchrones ‚ÄûBodykit‚Äú zu erstellen. </p><br><p></p><blockquote>  Alex Davis schreibt, dass die <b>Kosten f√ºr das direkte Aufrufen der asynchronen Methode das Zehnfache der Kosten f√ºr das Aufrufen der synchronen Methode</b> betragen k√∂nnen. Es gibt also etwas zu versuchen. </blockquote><br><br>  <b>UPD:</b> <br>  Wie die Kommentare zu Recht hervorheben, f√ºhrt das Herauss√§gen von Async / Wait aus einzeiligen Methoden zu negativen Nebenwirkungen.  Wenn Sie beispielsweise eine Ausnahme ausl√∂sen, ist die Methode, mit der Task ausgel√∂st wird, im Stapel nicht sichtbar.  Daher wird das <b>Entfernen von Standardeinstellungen standardm√§√üig nicht empfohlen</b> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Clarys Post</a> mit Analyse. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435666/">https://habr.com/ru/post/de435666/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435652/index.html">Wie man keine Passw√∂rter in Python-Skripten verwendet</a></li>
<li><a href="../de435654/index.html">Fallstricke von benutzerdefinierten CSS-Eigenschaften</a></li>
<li><a href="../de435656/index.html">Roller Rolls Royce - Ninebot KickScooter ES4 von Segway</a></li>
<li><a href="../de435662/index.html">"Zuverl√§ssigkeit und Zuverl√§ssigkeit wie bei Google" - und nicht nur: √úbersetzung des Artikels "Berechnung der Servicezuverl√§ssigkeit"</a></li>
<li><a href="../de435664/index.html">Google-Suchmaschinen-Spoofing</a></li>
<li><a href="../de435668/index.html">Ein weiteres Gesetz des Fr√ºhlings: Der Abgeordnete schlug vor, der Polizei zu erm√∂glichen, den Standort von Kindern mithilfe der Geolokalisierung zu verfolgen</a></li>
<li><a href="../de435670/index.html">Oberster Algorithmus - Verteilung der Algorithmen nach Schwierigkeitsgrad</a></li>
<li><a href="../de435672/index.html">Umschulung in Business Intelligence</a></li>
<li><a href="../de435678/index.html">Vertrauen Sie den Speicherinformationen im Task-Manager nicht</a></li>
<li><a href="../de435680/index.html">AWS zeigte Open Source Mittelfinger</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>