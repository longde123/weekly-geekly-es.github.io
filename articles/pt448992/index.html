<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëΩ ü§∫ üôÖüèø Hash vers√°til e perfeito üè¥Û†ÅßÛ†Å¢Û†Å≥Û†Å£Û†Å¥Û†Åø üö∂üèæ ‚ôêÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Come√ßamos a semana com material √∫til dedicado ao lan√ßamento do curso "Algoritmos para desenvolvedores" . Boa leitura. 



 1. Vis√£o geral 

 Hashing √©...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hash vers√°til e perfeito</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/448992/">  Come√ßamos a semana com material √∫til dedicado ao lan√ßamento do curso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Algoritmos para desenvolvedores"</a> .  Boa leitura. <br><br><img src="https://habrastorage.org/webt/na/5_/ja/na5_jaknhrabunnqxjqmc1yjtvi.png"><br><br>  <b>1. Vis√£o geral</b> <br><br>  Hashing √© uma √≥tima ferramenta pr√°tica, com uma teoria interessante e sutil.  Al√©m de usar dados como uma estrutura de vocabul√°rio, o hash tamb√©m √© encontrado em muitas √°reas diferentes, incluindo criptografia e teoria da complexidade.  Nesta palestra, descrevemos dois conceitos importantes: hash universal (tamb√©m conhecido como fam√≠lia universal de fun√ß√µes de hash) e hash ideal. <a name="habracut"></a><br><br>  O material destacado nesta palestra inclui: <br><br><ul><li>  A configura√ß√£o formal e a id√©ia geral de hash. </li><li>  Hash universal. </li><li>  Hash perfeito. </li></ul><br>  <b>2. Introdu√ß√£o</b> <br><br>  Vamos considerar o principal problema com o dicion√°rio que discutimos anteriormente e duas vers√µes: est√°tica e din√¢mica: <br><br><ul><li>  <i>Est√°tico</i> : considerando muitos elementos S, queremos armazen√°-lo de forma que possamos executar rapidamente uma pesquisa. </li><li>  Por exemplo, um dicion√°rio fixo. </li><li>  <i>Din√¢mico</i> : aqui temos uma sequ√™ncia de solicita√ß√µes de inser√ß√£o, pesquisa e possivelmente remo√ß√£o.  Queremos fazer tudo isso de forma eficaz. </li></ul><br>  Para o primeiro problema, poder√≠amos usar uma matriz classificada e uma pesquisa bin√°ria.  Para o segundo, poder√≠amos usar uma √°rvore de pesquisa equilibrada.  No entanto, o hash fornece uma abordagem alternativa, que geralmente √© a maneira mais r√°pida e conveniente de resolver esses problemas.  Por exemplo, suponha que voc√™ esteja escrevendo um programa para pesquisa de IA e deseje armazenar situa√ß√µes que voc√™ j√° resolveu (posi√ß√µes no quadro ou elementos do espa√ßo de estados) para n√£o repetir os mesmos c√°lculos ao encontr√°-los novamente.  O hash fornece uma maneira f√°cil de armazenar essas informa√ß√µes.  Existem tamb√©m muitas aplica√ß√µes em criptografia, redes, teoria da complexidade. <br><br>  <b>3. No√ß√µes b√°sicas de hash</b> <br><br>  A configura√ß√£o formal para o hash √© a seguinte. <br><br><ul><li>  As chaves pertencem a um conjunto grande de U. (Por exemplo, imagine que U seja uma cole√ß√£o de todas as cadeias com um comprimento m√°ximo de 80 caracteres ascii.) </li><li>  Existem algumas chaves S em U que realmente precisamos (as chaves podem ser est√°ticas ou din√¢micas).  Seja N = | S |.  Imagine que N √© muito menor que o tamanho de U. Por exemplo, S √© o conjunto de nomes de alunos em uma classe que √© muito menor que 128 ^ 80. </li><li>  Realizaremos inser√ß√µes e pesquisas usando uma matriz A de algum tamanho M e uma <b>fun√ß√£o de hash</b> h: U ‚Üí {0, ..., M - 1}.  Dado o elemento x, a id√©ia do hash √© que queremos armazen√°-lo em A [h (x)].  Observe que se U fosse pequeno (por exemplo, cadeias de caracteres de 2 caracteres), voc√™ poderia salvar x em A [x], como na classifica√ß√£o de blocos.  O problema √© que U √© grande, ent√£o precisamos de uma fun√ß√£o de hash. </li><li>  Precisamos de um m√©todo para resolver colis√µes.  Uma colis√£o √© quando h (x) = h (y) para duas chaves diferentes x e y.  Nesta palestra, lidaremos com colis√µes definindo cada elemento de A como uma lista vinculada.  Existem v√°rios outros m√©todos, mas para os problemas nos quais focaremos aqui, este √© o mais adequado.  Este m√©todo √© chamado de m√©todo de encadeamento.  Para inserir um item, basta coloc√°-lo no topo da lista.  Se h √© uma boa fun√ß√£o de hash, esperamos que as listas sejam pequenas. </li></ul><br>  Uma das grandes vantagens do hash √© que todas as opera√ß√µes do dicion√°rio s√£o incrivelmente f√°ceis de implementar.  Para procurar a chave x, basta calcular o √≠ndice i = h (x) e, em seguida, percorrer a lista em A [i] at√© encontr√°-la (ou sair da lista).  Para inserir, basta colocar um novo item no topo de sua lista.  Para excluir, basta executar a opera√ß√£o de exclus√£o na lista vinculada.  Agora, passamos √† pergunta: o que precisamos para obter um bom desempenho? <br><br>  Propriedades desej√°veis.  Principais propriedades desej√°veis ‚Äã‚Äãpara um bom esquema de hash: <br><br><ol><li>  As chaves est√£o bem dispersas para que n√£o tenhamos muitas colis√µes, pois elas afetam o tempo de pesquisa e exclus√£o. </li><li>  M = O (N): em particular, gostar√≠amos que nosso circuito atingisse a propriedade (1) sem a necessidade de o tamanho da tabela M ser muito maior que o n√∫mero de elementos N. </li><li>  A fun√ß√£o h deve ser calculada rapidamente.  Em nossa an√°lise atual, consideraremos o tempo para calcular h (x) como uma constante.  No entanto, vale lembrar que n√£o deve ser muito complicado, pois afeta o tempo de execu√ß√£o geral. </li></ol><br>  Diante disso, o tempo de pesquisa para o elemento x √© O (o tamanho da lista √© A [h (x)]).  O mesmo vale para exclus√µes.  As inser√ß√µes levam tempo O (1), independentemente do tamanho das listas.  Ent√£o, queremos analisar o tamanho dessas listas. <br><br>  Intui√ß√£o b√°sica: uma maneira de distribuir elementos lindamente √© distribu√≠-los aleatoriamente.  Infelizmente, n√£o podemos apenas usar o gerador de n√∫meros aleat√≥rios para decidir para onde direcionar o pr√≥ximo elemento, porque nunca mais o encontraremos.  Ent√£o, queremos que ele seja algo "pseudo-aleat√≥rio" em algum sentido formal. <br><br>  Agora apresentaremos m√°s not√≠cias e outras boas. <br><br>  Instru√ß√£o 1 (m√°s not√≠cias) Para qualquer fun√ß√£o de hash h se | U |  ‚â• (N ‚àí1) M +1, h√° um conjunto S de N elementos que todos os hash em um s√≥ lugar. <br><br>  Prova: pelo princ√≠pio de Dirichlet.  Em particular, para considerar contrapontos, se cada local n√£o tivesse mais do que N - 1 elementos de U que o misturassem, ent√£o U poderia ter um tamanho n√£o superior a M (N - 1). <br><br>  √â em parte por isso que o hash parece t√£o misterioso - como se pode argumentar que o hash √© bom se, para qualquer fun√ß√£o de hash, voc√™ puder pensar em maneiras de evit√°-lo?  Uma resposta √© que existem muitas fun√ß√µes simples de hash que funcionam bem na pr√°tica para conjuntos t√≠picos S. Mas e se quisermos uma boa garantia do pior caso? <br><br>  Aqui est√° a id√©ia principal: vamos usar a randomiza√ß√£o em nosso construto h, semelhante ao quicksort randomizado.  (Escusado ser√° dizer que h ser√° uma fun√ß√£o determin√≠stica).  Mostraremos que, para qualquer sequ√™ncia de opera√ß√µes de inser√ß√£o e pesquisa (n√£o precisamos assumir que o conjunto de elementos S inseridos √© aleat√≥rio), se escolhermos h dessa maneira probabil√≠stica, o desempenho de h nessa sequ√™ncia ser√° bom em antecipa√ß√£o.  Portanto, essa √© a mesma garantia que em quicksort ou armadilhas aleat√≥rias.  Em particular, essa √© a id√©ia do hash universal. <br><br>  Depois de desenvolvermos essa id√©ia, a usaremos para um aplicativo particularmente agrad√°vel chamado "hash perfeito". <br><br>  <b>4. Hash Universal</b> <br><br>  Defini√ß√£o 1. Um algoritmo aleat√≥rio H para construir fun√ß√µes de hash h: U ‚Üí {1, ..., M} <br>  universal se para todos x! = y em U tivermos <br><br><img src="https://habrastorage.org/webt/bj/h3/hd/bjh3hdghlrhmfl-4mf6i3xybf14.png"><br><br>  Tamb√©m podemos dizer que o conjunto H de fun√ß√µes hash √© uma fam√≠lia universal de fun√ß√µes hash se o procedimento ‚Äúselecionar aleatoriamente h ‚àà H‚Äù for universal.  (Aqui, identificamos o conjunto de fun√ß√µes com uma distribui√ß√£o uniforme sobre o conjunto.) <br><br>  Teorema 2. Se H √© universal, ent√£o para qualquer conjunto S ‚äÜ U de tamanho N, para qualquer x ‚àà U (por exemplo, o que poder√≠amos procurar), se construirmos h aleatoriamente de acordo com H, o n√∫mero esperado de colis√µes entre x e outros elementos em S n√£o mais que N / M. <br><br>  Prova: cada y ‚àà S (y! = X) tem no m√°ximo 1 / M de chance de uma colis√£o com x pela defini√ß√£o de ‚Äúuniversal‚Äù.  Ent√£o <br><br><ul><li>  Deixe Cxy = 1 se x e y colidirem, e 0 caso contr√°rio. </li><li>  Deixe Cx denotar o n√∫mero total de colis√µes para x.  Ent√£o, Cx = Py‚ààS, y! = X Cxy. </li><li>  Sabemos que E [Cxy] = Pr (x e y colidem) ‚â§ 1 / M. </li><li>  Assim, na linearidade da expectativa, E [Cx] = Py E [Cxy] &lt;N / M. </li></ul><br>  Agora temos o seguinte corol√°rio. <br><br>  Corol√°rio 3. Se H for universal, para qualquer sequ√™ncia de opera√ß√µes de inser√ß√£o, pesquisa e exclus√£o L, nas quais possa haver no m√°ximo M elementos no sistema ao mesmo tempo, o custo total esperado de opera√ß√µes L para uma h aleat√≥ria h ‚àà H √© apenas O (L) (visualiza√ß√£o do tempo para calcular h como constantes). <br><br>  Prova: para qualquer opera√ß√£o dada na sequ√™ncia, seu custo esperado √© constante no Teorema 2, portanto o custo total esperado das opera√ß√µes L √© O (L) na linearidade da expectativa. <br><br>  Pergunta: podemos realmente construir um H universal?  Se n√£o, ent√£o tudo isso √© in√∫til.  Felizmente, a resposta √© sim. <br><br>  <i><b>4.1</b></i>  <i><b>Criando uma fam√≠lia de hash universal: m√©todo de matriz</b></i> <br><br>  Suponha que as chaves tenham bits em u.  Digamos que o tamanho da tabela M seja igual ao grau 2; portanto, o √≠ndice √© b-bit longo com M = 2b. <br><br>  O que faremos √© escolher h como a matriz aleat√≥ria 0/1 b-por-u e definir h (x) = hx, onde adicionamos o mod 2. Essas matrizes s√£o curtas e grossas.  Por exemplo: <br><br><img src="https://habrastorage.org/webt/ly/q4/4k/lyq44kg-g4d8iloztroepglar9k.png"><br><br>  Proposi√ß√£o 4. Para x! = Y Prh [h (x) = h (y)] = 1 / M = 1 / 2b. <br><br>  Prova: primeiro, o que significa multiplicar h por x?  Podemos pensar nisso como adicionar algumas das colunas h (fazendo adi√ß√£o de vetor mod 2), em que 1 bit em x indica quais adicionar.  (por exemplo, adicionamos a primeira e a terceira colunas de h acima) <br><br>  Agora pegue um par de chaves arbitr√°rio x, y tal que x! = Y.  Eles devem ser diferentes em algum lugar, de modo que, digamos, sejam diferentes na i-√©sima coordenada e, quanto √† concretiza√ß√£o, dizemos xi = 0 e yi = 1. Imagine que primeiro selecionamos todos h, exceto a i-√©sima coluna.  Para as demais amostras da i-√©sima coluna, h (x) √© corrigido.  Entretanto, cada uma das 2b configura√ß√µes diferentes da i-√©sima coluna fornece um valor diferente de h (y) (em particular, toda vez que giramos um pouco nessa coluna, transformamos o bit correspondente em h (y)).  Portanto, h√° exatamente uma chance de 1 / 2b de h (x) = h (y). <br><br>  Existem outros m√©todos para construir fam√≠lias de hash universais, que tamb√©m se baseiam na multiplica√ß√£o de n√∫meros primos (consulte a Se√ß√£o 6.1). <br><br>  A pr√≥xima pergunta que consideraremos: se corrigirmos o conjunto S, podemos encontrar uma fun√ß√£o de hash h de modo que todas as pesquisas tenham tempo constante?  A resposta √© sim, e isso leva ao t√≥pico do hash perfeito. <br><br>  <b>5. Hash perfeito</b> <br><br>  Dizemos que uma fun√ß√£o de hash √© ideal para S se todas as pesquisas ocorrerem em O (1).  Aqui est√£o duas maneiras de criar fun√ß√µes hash perfeitas para um determinado conjunto S. <br><br>  <i><b>5.1 M√©todo 1: uma solu√ß√£o no espa√ßo O (N2)</b></i> <br><br>  Digamos que queremos ter uma tabela cujo tamanho seja quadr√°tico no tamanho N do nosso dicion√°rio S. Ent√£o, aqui est√° um m√©todo simples para construir uma fun√ß√£o hash ideal.  Seja H universal e M = N2.  Em seguida, basta escolher um h aleat√≥rio de H e experiment√°-lo!  A afirma√ß√£o √© de que h√° pelo menos 50% de chance de ela n√£o ter colis√µes. <br><br>  Proposi√ß√£o 5. Se H √© universal e M = N2, ent√£o Prh‚àºH (sem colis√µes em S) ‚â• 1/2. <br><br>  Prova: <br><br>  ‚Ä¢ Quantos pares (x, y) existem em S?  A resposta √©: <img src="https://habrastorage.org/webt/1n/oh/w7/1nohw79oejhbrsciul36nklg4sq.png"><br>  ‚Ä¢ Para cada par, a probabilidade de colis√£o √© ‚â§ 1 / M, por defini√ß√£o de universalidade. <br>  ‚Ä¢ Ent√£o Pr (h√° uma colis√£o) ‚â§ <img src="https://habrastorage.org/webt/1n/oh/w7/1nohw79oejhbrsciul36nklg4sq.png">  / M &lt;1/2. <br><br>  √â como o outro lado do "paradoxo do anivers√°rio".  Se o n√∫mero de dias for muito maior que o n√∫mero de pessoas ao quadrado, h√° uma chance razo√°vel de que nenhum casal tenha o mesmo anivers√°rio. <br><br>  Ent√£o, escolhemos um h aleat√≥rio de H e, se surgirem colis√µes, escolhemos um novo h.  Em m√©dia, precisaremos fazer isso apenas duas vezes.  Agora, e se quisermos usar apenas o espa√ßo O (N)? <br><br>  5.2 M√©todo 2: uma solu√ß√£o no espa√ßo O (N) <br><br>  A quest√£o de saber se √© poss√≠vel obter um hash perfeito no espa√ßo O (N) est√° aberta h√° algum tempo: "As tabelas devem ser classificadas?"  Ou seja, para um conjunto fixo, voc√™ pode obter um tempo de pesquisa constante apenas com espa√ßo linear?  Houve uma s√©rie de tentativas cada vez mais complexas, at√© que finalmente foi resolvido usando a boa id√©ia de fun√ß√µes de hash universais em um esquema de dois n√≠veis. <br><br>  O m√©todo √© o seguinte.  Primeiro, vamos fazer o hash em uma tabela de tamanho N usando o hash universal.  Isso levar√° a algumas colis√µes (a menos que tenhamos sorte).  No entanto, refazemos novamente cada cesta usando o m√©todo 1, ajustando o tamanho da cesta para obter zero colis√£o.  Assim, o esquema consiste no fato de termos uma fun√ß√£o de hash do primeiro n√≠vel he uma tabela A do primeiro n√≠vel, e ent√£o N fun√ß√µes de hash do segundo n√≠vel h1, ..., hN e N da tabela de segundo n√≠vel A1, ..., A.N ... Para encontrar o elemento x, primeiro calculamos i = h (x) e depois encontramos o elemento em Ai [hi (x)].  (Se voc√™ fez isso na pr√°tica, poder√° definir o sinalizador para que voc√™ d√™ o segundo passo apenas se realmente houver conflitos com o √≠ndice i, caso contr√°rio, voc√™ apenas colocaria o pr√≥prio x em A [i], mas vamos n√£o vamos nos preocupar com isso aqui.) <br><br>  Digamos que uma fun√ß√£o hash hashes n elementos de S no local i.  J√° provamos (analisando o m√©todo 1) que podemos encontrar h1, ..., hN, de modo que o espa√ßo total usado nas tabelas secund√°rias √© Pi (ni) 2. Resta mostrar que podemos encontrar uma fun√ß√£o de primeiro n√≠vel h de modo que Pi (ni) 2 = O (N).  De fato, mostraremos o seguinte: <br><br>  Teorema 6. Se escolhermos o ponto inicial h do conjunto universal H, ent√£o <br><br><pre><code class="plaintext hljs">Pr[X i (ni)2 &gt; 4N] &lt; 1/2.</code> </pre> <br>  Prova.  Vamos provar isso mostrando que E [Pi (ni) 2] &lt;2N.  Isso implica o que queremos da desigualdade de Markov.  (Se houvesse uma probabilidade de at√© 1/2 de que a soma pudesse ser superior a 4N, apenas esse fato significaria que a expectativa deveria ser superior a 2N. Portanto, se a expectativa for menor que 2N, a probabilidade de falha dever√° ser menor. 1/2.) <br><br>  Agora, o truque mais complicado √© que uma maneira de calcular esse valor √© contar o n√∫mero de pares ordenados que t√™m uma colis√£o, incluindo colis√µes consigo mesmo.  Por exemplo, se a cesta tiver {d, e, f}, d ter√° um conflito com cada um de {d, e, f}, e ter√° um conflito com cada um de {d, e, f} ef ter√° um conflito com cada um de {d, e, f}, obtemos 9. Ent√£o, temos: <br><br><pre> <code class="plaintext hljs">E[X i (ni)2] = E[X x X y Cxy] (Cxy = 1 if x and y collide, else Cxy = 0) = N +X x X y6=x E[Cxy] ‚â§ N + N(N ‚àí 1)/M (where the 1/M comes from the definition of universal) &lt; 2N. (since M = N)</code> </pre><br>  Ent√£o, apenas tentamos um h aleat√≥rio de H at√© encontrarmos um tal que Pi n2 i &lt;4N e, em seguida, corrigindo essa fun√ß√£o h, encontramos N fun√ß√µes hash secund√°rias h1, ..., hN, como no m√©todo 1. <br><br>  <b>6. Discuss√£o adicional</b> <br><br>  <i><b>6.1 Outro m√©todo de hash universal</b></i> <br><br>  Aqui est√° outro m√©todo para construir fun√ß√µes hash universais, que √© um pouco mais eficiente do que o m√©todo matricial fornecido anteriormente. <br><br>  No m√©todo matricial, consideramos a chave como um vetor de bits.  Nesse m√©todo, consideraremos a chave x como um vetor de n√∫meros inteiros [x1, x2, ..., xk] com o √∫nico requisito de que cada xi esteja no intervalo {0, 1, ..., M-1}.  Por exemplo, se tivermos hash de comprimento k, xi pode ser o i-√©simo caractere (se o tamanho da nossa tabela for pelo menos 256) ou o i-√©simo par de caracteres (se o tamanho da nossa tabela for pelo menos 65536).  Al√©m disso, exigiremos que o tamanho da nossa tabela M seja primo.  Para selecionar a fun√ß√£o hash h, selecionamos k n√∫meros aleat√≥rios r1, r2, ..., pk de {0, 1, ..., M - 1} e determinamos: <br><br><pre> <code class="plaintext hljs">h(x) = r1x1 + r2x2 + . . . + rkxk mod M.</code> </pre> <br>  A prova de que esse m√©todo √© universal √© constru√≠da da mesma maneira que a prova do m√©todo da matriz.  Seja x e y duas chaves diferentes.  Queremos mostrar que Prh (h (x) = h (y)) ‚â§ 1 / M. Dado que x! = Y, deve haver um caso em que exista algum √≠ndice i tal que xi! = Yi.  Agora imagine que voc√™ selecionou primeiro todos os n√∫meros aleat√≥rios rj para j! = I.  Seja h ‚Ä≤ (x) = Pj6 = i rjxj.  Ent√£o, escolhendo ri, obtemos h (x) = h ‚Ä≤ (x) + rixi.  Isso significa que temos um conflito entre x e y exatamente quando <br><br><pre> <code class="plaintext hljs">h‚Ä≤(x) + rixi = h‚Ä≤(y) + riyi mod M, or equivalently when ri(xi ‚àí yi) = h‚Ä≤(y) ‚àí h‚Ä≤(x) mod M.</code> </pre> <br>  Como M √© primo, a divis√£o por um valor diferente de zero do mod M √© v√°lida (todo n√∫mero inteiro de 1 a M -1 tem um m√≥dulo inverso multiplicativo M), o que significa que existe exatamente um valor ri m√≥dulo M para o qual a equa√ß√£o acima √© v√°lida verdadeiro, ou seja, ri = (h ‚Ä≤ (y) - h ‚Ä≤ (x)) / (xi - yi) mod M. Portanto, a probabilidade desse incidente √© exatamente 1 / M. <br><br>  <b><i>6.2 Outros usos do hash</i></b> <br><br>  Suponha que tenhamos uma longa sequ√™ncia de elementos e queremos ver quantos elementos diferentes est√£o na lista.  Existe uma boa maneira de fazer isso? <br><br>  Uma maneira √© criar uma tabela de hash e, em seguida, fazer uma passagem pela sequ√™ncia, pesquisando cada elemento e inserindo se ainda n√£o estiver na tabela.  O n√∫mero de elementos individuais √© simplesmente o n√∫mero de inser√ß√µes. <br><br>  E agora, e se a lista for realmente grande e n√£o tivermos um local para armazen√°-la, mas uma resposta aproximada for adequada para n√≥s.  Por exemplo, imagine que somos um roteador e observe quantos pacotes passam e queremos (aproximadamente) ver quantos endere√ßos IP de origem diferentes existem. <br><br>  Aqui est√° uma boa id√©ia: digamos que temos uma fun√ß√£o hash h que se comporta como uma fun√ß√£o aleat√≥ria e imaginemos que h (x) √© um n√∫mero real de 0 a 1. Uma coisa que podemos fazer √© acompanhar o m√≠nimo o valor do hash foi produzido at√© o momento (portanto, n√£o teremos uma tabela).  Por exemplo, se as chaves s√£o 3,10,3,3,12,10,12 eh (3) = 0,4, h (10) = 0,2, h (12) = 0,7, obtemos 0, 2) <br><br>  O fato √© que, se selecionarmos N n√∫meros aleat√≥rios em [0, 1], o valor m√≠nimo esperado ser√° 1 / (N + 1).  Al√©m disso, h√° uma boa chance de que ele esteja bem pr√≥ximo (podemos melhorar nossa estimativa executando v√°rias fun√ß√µes de hash e medindo a mediana dos m√≠nimos). <br><br>  Pergunta: por que usar uma fun√ß√£o hash, e n√£o apenas escolher um n√∫mero aleat√≥rio toda vez?  Isso ocorre porque nos preocupamos com o n√∫mero de elementos diferentes, e n√£o apenas com o n√∫mero total de elementos (esse problema √© muito mais simples: basta usar um contador ...). <br><br>  Amigos, este artigo foi √∫til para voc√™?  Escreva nos coment√°rios e participe do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dia aberto</a> , que ser√° realizado no dia 25 de abril. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt448992/">https://habr.com/ru/post/pt448992/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt448974/index.html">Abordagem sem servidor para o r√°pido desenvolvimento de um servi√ßo de v√≠deo em funcionamento</a></li>
<li><a href="../pt448976/index.html">Eventos de primavera Gamedev em HSE</a></li>
<li><a href="../pt448980/index.html">Nosso primeiro almo√ßo juntos: por que e como passamos o dia do teste</a></li>
<li><a href="../pt448982/index.html">CMS sem cabe√ßa. Por que estou escrevendo o meu</a></li>
<li><a href="../pt448986/index.html">Engenharia reversa 3D com digitaliza√ß√£o 3D</a></li>
<li><a href="../pt448994/index.html">√â t√£o dif√≠cil iniciar o caminho de um recrutador de TI?</a></li>
<li><a href="../pt448996/index.html">Criando uma pol√≠tica de senha no Linux</a></li>
<li><a href="../pt448998/index.html">Se a conex√£o √© apenas estanque, √© necess√°rio enterr√°-la</a></li>
<li><a href="../pt449000/index.html">O Deno √© o novo Node.js?</a></li>
<li><a href="../pt449002/index.html">Verifica√ß√£o formal do exemplo do problema do lobo, cabra e couve</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>