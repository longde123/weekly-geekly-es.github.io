<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👵 ☢️ 👨‍❤️‍💋‍👨 DDD, Hexagonal, Onion, Clean, CQRS ... comment je mets tout cela ensemble 🤳🏻 🕤 🌎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article fait partie de la Chronique de l'architecture logicielle , une série d'articles sur l'architecture logicielle. J'y écris ce que j'ai appri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DDD, Hexagonal, Onion, Clean, CQRS ... comment je mets tout cela ensemble</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427739/"> <a href=""><img src="https://habrastorage.org/webt/mm/07/bx/mm07bx1u2dxlgab0prkzllunvf8.png"></a> <br><br>  Cet article fait partie de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la Chronique de l'architecture logicielle</a> , une série d'articles sur l'architecture logicielle.  J'y écris ce que j'ai appris sur l'architecture logicielle, ce que j'en pense et comment j'utilise les connaissances.  Le contenu de cet article peut avoir plus de sens si vous lisez les articles précédents de la série. <br><br>  Après avoir obtenu mon diplôme universitaire, j'ai commencé à travailler en tant que professeur de lycée, mais il y a quelques années, j'ai arrêté de travailler et suis allé chez les développeurs de logiciels à temps plein. <br><br>  Depuis lors, j'ai toujours ressenti le besoin de récupérer le temps «perdu» et de le découvrir le plus rapidement possible.  Par conséquent, j'ai commencé à m'impliquer un peu dans les expériences, à lire et à écrire beaucoup, en accordant une attention particulière à la conception et à l'architecture du logiciel.  C'est pourquoi j'écris ces articles pour m'aider dans mes études. <br><a name="habracut"></a><br>  Dans les derniers articles, j'ai parlé de nombreux concepts et principes que j'ai appris, et un peu comment je raisonne à leur sujet.  Mais je les imagine comme des fragments d'un grand puzzle. <br><br>  Cet article explique comment j'ai rassemblé tous ces fragments.  Je pense que je devrais leur donner un nom, donc je les appellerai <b>architecture explicite</b> .  De plus, tous ces concepts sont <i>«testés au combat»</i> et sont utilisés en production sur des plateformes hautement fiables.  L'un d'eux est une plateforme de commerce électronique SaaS avec des milliers de boutiques en ligne à travers le monde, l'autre est une plateforme de trading opérant dans deux pays avec un bus de messages qui traite plus de 20 millions de messages par mois. <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Blocs fondamentaux du système</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les outils</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Connecter les outils et les mécanismes de livraison au cœur de l'application</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ports</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Adaptateurs primaires ou de contrôle</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Adaptateurs secondaires ou gérés</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Inversion de contrôle</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Organisation du cœur d'application</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Niveau d'application</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Au niveau du domaine</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Services de domaine</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Modèle de domaine</a> </li></ul></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Composants</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Déconnexion des composants</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Déclenchement de la logique dans d'autres composants</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Récupération de données à partir d'autres composants</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Stockage de données partagé pour les composants</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Stockage de données séparé pour le composant</a> </li></ul></li></ul></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Contrôle du flux</a> </li></ul><br><a name="1"></a><h1>  Blocs fondamentaux du système </h1><br>  Commençons par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rappeler les</a> architectures <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">EBI</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ports &amp; Adapters</a> .  Les deux séparent clairement le code interne et externe de l'application, ainsi que les adaptateurs pour connecter le code interne et externe. <br><br>  De plus, l'architecture des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ports et adaptateurs</a> définit explicitement les trois blocs de code fondamentaux du système: <br><br><ul><li>  Cela vous permet d'exécuter l' <b>interface utilisateur</b> , quel que soit son type. </li><li>  <b>Logique métier</b> système ou <b>cœur d'application</b> .  Il est utilisé par l'interface utilisateur pour effectuer des transactions réelles. </li><li>  Le code d' <b>infrastructure</b> qui relie le cœur de notre application à des outils tels que la base de données, le moteur de recherche ou les API tierces. </li></ul><br> <a href=""><img src="https://habrastorage.org/webt/7q/gt/h5/7qgth5e95mntgholpnrryv4zbm4.png"></a> <br><br>  Le cœur de l'application est la chose la plus importante à penser.  Ce code vous permet d'effectuer des actions réelles dans le système, c'est-à-dire, c'est notre application.  Plusieurs interfaces utilisateur (une application Web progressive, une application mobile, une CLI, une API, etc.) peuvent fonctionner avec, tout fonctionne sur un cœur. <br><br>  Comme vous pouvez l'imaginer, un flux d'exécution typique passe du code de l'interface utilisateur au cœur de l'application au code d'infrastructure, puis au cœur de l'application et, enfin, la réponse est fournie à l'interface utilisateur. <br><br> <a href=""><img src="https://habrastorage.org/webt/vn/7q/5u/vn7q5usrs1m2ftgkfmzagymrlfw.png"></a> <br><br><a name="2"></a><h1>  Les outils </h1><br>  Loin du code du noyau le plus important, il existe encore des outils que l'application utilise.  Par exemple, le moteur de base de données, le moteur de recherche, le serveur Web et la console CLI (bien que les deux derniers soient également des mécanismes de livraison). <br><br> <a href=""><img src="https://habrastorage.org/webt/_o/aj/rn/_oajrnom8cuphtclxgw-m-sgars.png"></a> <br><br>  Il semble étrange de placer la console CLI dans la même section thématique que le SGBD, car ils ont un objectif différent.  Mais en fait, les deux sont des outils utilisés par l'application.  La principale différence est que la console CLI et le serveur Web <b>indiquent à l'application de faire quelque chose</b> , le noyau SGBD, au contraire, <b>reçoit des commandes de l'application</b> .  Il s'agit d'une différence très importante, car elle affecte considérablement la façon dont nous écrivons du code pour connecter ces outils au cœur de l'application. <br><br><a name="3"></a><h1>  Connecter les outils et les mécanismes de livraison au cœur de l'application </h1><br>  Les blocs d'outils de connexion de code au cœur de l'application sont appelés adaptateurs ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">architecture des ports et adaptateurs</a> ).  Ils permettent à la logique métier d'interagir avec un outil spécifique et vice versa. <br><br>  Les adaptateurs qui indiquent à l'application de faire quelque chose sont appelés <b>adaptateurs principaux ou de contrôle</b> , tandis que les adaptateurs qui indiquent à l'application de faire quelque chose sont appelés <b>adaptateurs secondaires ou gérés</b> . <br><br><a name="4"></a><h2>  Ports </h2><br>  Cependant, ces <i>adaptateurs</i> ne sont pas créés par hasard, mais pour correspondre à un point d'entrée spécifique dans le noyau de l'application, le <i><b>port</b></i> .  Un port n'est <b>rien de plus qu'une spécification</b> de la façon dont l'outil peut utiliser le cœur de l'application ou vice versa.  Dans la plupart des langues et dans sa forme la plus simple, ce port sera une interface, mais en fait il peut être composé de plusieurs interfaces et DTO. <br><br>  Il est important de noter que les <b>ports (interfaces) sont à l'intérieur de la logique métier</b> et que les adaptateurs sont à l'extérieur.  Pour que ce modèle fonctionne correctement, il est extrêmement important de créer des ports conformément aux besoins du cœur de l'application, et pas seulement de reproduire les API de l'outil. <br><br><a name="5"></a><h2>  Adaptateurs primaires ou de contrôle </h2><br>  Les adaptateurs principaux ou de contrôle <b>s'enroulent autour d'un port</b> et l'utilisent pour indiquer au noyau de l'application quoi faire.  <b>Ils transforment toutes les données du mécanisme de livraison en appels de méthode dans le cœur de l'application.</b> <br><br> <a href=""><img src="https://habrastorage.org/webt/p3/6x/rc/p36xrcnsvtfgxpmnpb2f48vtguw.png"></a> <br><br>  En d'autres termes, nos adaptateurs de contrôle sont des contrôleurs ou des commandes de console, ils sont intégrés dans leur constructeur avec un objet dont la classe implémente l'interface (port) requise par une commande de contrôleur ou de console. <br><br>  Dans un exemple plus spécifique, le port peut être l'interface de service ou l'interface de référentiel requise par le contrôleur.  Une implémentation spécifique d'un service, d'un référentiel ou d'une demande est ensuite implémentée et utilisée dans le contrôleur. <br><br>  De plus, le port peut être un bus de commande ou une interface de bus de requête.  Dans ce cas, une implémentation spécifique du bus de commande ou de requête est entrée dans le contrôleur, qui crée ensuite une commande ou une requête et la transmet au bus correspondant. <br><br><a name="6"></a><h2>  Adaptateurs secondaires ou gérés </h2><br>  Contrairement aux adaptateurs de contrôle qui entourent un port, les <b>adaptateurs gérés</b> implémentent un port, une interface, puis entrent dans le cœur de l'application où le port est requis (avec le type). <br><br> <a href=""><img src="https://habrastorage.org/webt/rw/hz/bo/rwhzboewldt79asfbycnq9pwii0.png"></a> <br><br>  Par exemple, nous avons une application native qui doit enregistrer des données.  Nous créons une interface de persistance avec une méthode d' <i>enregistrement d'un</i> tableau de données et une méthode de <i>suppression d'une</i> ligne dans une table par son ID.  Désormais, partout où l'application doit enregistrer ou supprimer des données, nous aurons besoin dans le constructeur d'un objet qui implémente l'interface de persistance que nous avons définie. <br><br>  Créez maintenant un adaptateur spécifique à MySQL qui implémentera cette interface.  Il aura des méthodes pour enregistrer le tableau et supprimer la ligne dans le tableau, et nous l'introduirons partout où l'interface de persistance est requise. <br><br>  Si à un moment donné, nous décidons de changer le fournisseur de base de données, par exemple, pour PostgreSQL ou MongoDB, nous avons juste besoin de créer un nouvel adaptateur qui implémente l'interface de persistance spécifique à PostgreSQL et d'introduire un nouvel adaptateur au lieu de l'ancien. <br><br><a name="7"></a><h2>  Inversion de contrôle </h2><br>  Une caractéristique de ce modèle est que les adaptateurs dépendent d'un outil spécifique et d'un port spécifique (en implémentant une interface).  Mais notre logique métier ne dépend que du port (interface), qui est conçu pour répondre aux besoins de la logique métier et ne dépend pas d'un adaptateur ou d'un outil spécifique. <br><br> <a href=""><img src="https://habrastorage.org/webt/lz/8c/8m/lz8c8mla7fg4vuq9piocz1rb4ko.png"></a> <br><br>  Cela signifie que les dépendances sont dirigées vers le centre, c'est-à-dire qu'il y a une <b>inversion du principe de contrôle au niveau architectural</b> . <br><br>  Bien que, encore une fois, <b>il est impératif que les ports soient créés conformément aux besoins du cœur de l'application, et non pas simplement imitent les API de l'outil</b> . <br><br><a name="8"></a><h1>  Organisation du cœur d'application </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'architecture Onion</a> récupère les couches DDD et les intègre dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">architecture</a> du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">port et de l'adaptateur</a> .  Ces niveaux sont conçus pour mettre de l'ordre dans la logique métier, à l'intérieur de l '«hexagone» des ports et des adaptateurs.  Comme précédemment, la direction des dépendances est vers le centre. <br><br><a name="9"></a><h2>  Couche d'application (couche d'application) </h2><br>  Les cas d'utilisation sont des processus qui peuvent être lancés dans le noyau par une ou plusieurs interfaces utilisateur.  Par exemple, un CMS peut avoir une interface utilisateur pour les utilisateurs réguliers, une autre interface utilisateur indépendante pour les administrateurs CMS, une autre CLI et une API Web.  Ces interfaces utilisateur (applications) peuvent déclencher des cas d'utilisation uniques ou courants. <br><br>  Les cas d'utilisation sont définis au niveau de l'application - le premier niveau de DDD et l'architecture Onion. <br><br> <a href=""><img src="https://habrastorage.org/webt/en/x2/97/enx297n0fviyyevojd6u3y_mx3q.png"></a> <br><br>  Cette couche contient des services d'application (et leurs interfaces) en tant qu'objets de première classe, et contient également des interfaces de port et d'adaptateur (ports), qui incluent des interfaces ORM, des interfaces de moteur de recherche, des interfaces de messagerie, etc. Dans le cas où nous utilisons le bus de commande et / ou le bus de requête, à ce niveau sont les gestionnaires de commande et de requête correspondants. <br><br>  Les services d'application et / ou les gestionnaires de commandes contiennent la logique de déploiement d'un cas d'utilisation, un processus métier.  En règle générale, leur rôle est le suivant: <br><br><ol><li>  utiliser le référentiel pour rechercher une ou plusieurs entités; </li><li>  demander à ces entités d'exécuter une logique de domaine; </li><li>  et utiliser le stockage pour réenregistrer les entités, enregistrant efficacement les modifications des données. </li></ol><br>  Les gestionnaires de commandes peuvent être utilisés de deux manières: <br><br><ol><li>  Ils peuvent contenir une logique pour exécuter un cas d'utilisation; </li><li>  Ils peuvent être utilisés comme de simples parties d'une connexion dans notre architecture qui reçoivent une commande et invoquent simplement la logique qui existe dans le service d'application. </li></ol><br>  L'approche à utiliser dépend du contexte, par exemple: <br><br><ul><li>  Nous avons déjà des services d'application et maintenant le bus de commande est ajouté? </li><li>  Le bus de commandes vous permet-il de spécifier une classe / méthode en tant que gestionnaire, ou avez-vous besoin d'étendre ou d'implémenter des classes ou des interfaces existantes? </li></ul><br>  Cette couche contient également des <b>événements d'application</b> déclencheurs qui représentent certains résultats d'un cas d'utilisation.  Ces événements déclenchent une logique qui est un effet secondaire d'un cas d'utilisation, comme l'envoi d'e-mails, la notification d'une API tierce, l'envoi d'une notification push ou même le lancement d'un autre cas d'utilisation appartenant à un autre composant de l'application. <br><br><a name="10"></a><h2>  Au niveau du domaine </h2><br>  Plus à l'intérieur, il y a un niveau de domaine.  Les objets de ce niveau contiennent des données et une logique de gestion de ces données, qui sont spécifiques au domaine lui-même et sont indépendantes des processus métier qui déclenchent cette logique.  Ils sont indépendants et ignorent complètement le niveau d'application. <br><br> <a href=""><img src="https://habrastorage.org/webt/sm/tl/z2/smtlz2wmhuiysntbvasfqotc7zs.png"></a> <br><br><a name="11"></a><h3>  Services de domaine </h3><br>  Comme je l'ai mentionné ci-dessus, le rôle du service d'application: <br><br><ol><li>  utiliser le référentiel pour rechercher une ou plusieurs entités; </li><li>  demander à ces entités d'exécuter une logique de domaine; </li><li>  et utiliser le stockage pour réenregistrer les entités, enregistrant efficacement les modifications des données. </li></ol><br>  Mais parfois, nous rencontrons une logique de domaine, qui comprend diverses entités du même type ou de types différents, et cette logique de domaine n'appartient pas aux entités elles-mêmes, c'est-à-dire que la logique n'est pas leur responsabilité directe. <br><br>  Par conséquent, notre première réaction peut être de placer cette logique en dehors des entités dans le service d'application.  Cependant, cela signifie que dans d'autres cas, la logique du domaine ne sera pas réutilisée: la logique du domaine doit rester en dehors du niveau de l'application! <br><br>  La solution consiste à créer un service de domaine dont le rôle est d'obtenir un ensemble d'entités et d'exécuter une logique métier sur celles-ci.  Un service de domaine appartient à un niveau de domaine et ne sait donc rien des classes au niveau de l'application, telles que les services d'application ou les référentiels.  D'autre part, il peut utiliser d'autres services de domaine et, bien sûr, des objets de modèle de domaine. <br><br><a name="12"></a><h3>  Modèle de domaine </h3><br>  Au centre se trouve le modèle de domaine.  Il ne dépend de rien en dehors de ce cercle et contient des objets métier qui représentent quelque chose dans le domaine.  Des exemples de tels objets sont, tout d'abord, les entités, ainsi que les objets de valeur, les énumérations et tous les objets utilisés dans le modèle de domaine. <br><br>  Les événements de domaine vivent également dans le modèle de domaine.  Lorsqu'un ensemble de données spécifique change, ces événements sont déclenchés, qui contiennent de nouvelles valeurs des propriétés modifiées.  Ces événements sont idéaux, par exemple, pour une utilisation dans le module de sourcing d'événements. <br><br><a name="13"></a><h1>  Composants </h1><br>  Jusqu'à présent, nous avons isolé le code en couches, mais c'est une isolation du code trop détaillée.  Il est tout aussi important de regarder l'image avec un aspect plus général.  Nous parlons de diviser le code en sous-domaines et <i><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">contextes associés</a></b></i> conformément aux idées de Robert Martin exprimées dans l' <i><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">architecture hurlante</a></b></i> [c'est-à-dire que l'architecture devrait "crier" sur l'application elle-même, et non sur les cadres qu'elle utilise - env.  trans.].  Ils parlent de l'organisation des packages par fonction ou composant, et non par couche, et Simon Brown l'a très bien expliqué dans son article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Packages de composants et tests conformément à l'architecture»</a> de son blog: <br><br> <a href=""><img src="https://habrastorage.org/webt/mf/n5/un/mfn5unjrsm8lmkufaoj55mfyqk0.png"></a> <br><br>  Je suis partisan de l'organisation des packages de composants et je souhaite changer sans vergogne le diagramme de Simon Brown comme suit: <br><br> <a href=""><img src="https://habrastorage.org/webt/xn/ng/nd/xnngndzw3fq5rcvzvitudp-kpns.png"></a> <br><br>  Ces sections du code sont transversales pour toutes les couches décrites précédemment, et ce sont les <i><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">composants de</a></b></i> notre application.  La facturation, l'utilisateur, la vérification ou le compte sont des exemples de composants, mais ils sont toujours associés à un domaine.  Les contextes limités, tels que l'autorisation et / ou l'authentification, doivent être considérés comme des outils externes pour lesquels nous créons un adaptateur et nous cachons derrière un port. <br><br> <a href=""><img src="https://habrastorage.org/webt/9v/kd/ou/9vkdouyaegscibkngn0ui0ltbko.png"></a> <br><br><a name="14"></a><h2>  Déconnexion des composants </h2><br>  Tout comme dans les unités de code à grain fin (classes, interfaces, traits, mixins, etc.), les grandes unités (composants) bénéficient d'un couplage faible et d'une connectivité étroite. <br><br>  Pour séparer les classes, nous utilisons l'injection de dépendances, introduisant des dépendances dans la classe, plutôt que de les créer à l'intérieur de la classe, et inversant également les dépendances, rendant la classe dépendante des abstractions (interfaces et / ou classes abstraites) au lieu de classes spécifiques.  Cela signifie que la classe dépendante ne sait rien de la classe spécifique qu'elle utilisera, elle n'a pas de référence au nom complet des classes dont elle dépend. <br><br>  De même, dans les composants complètement déconnectés, chaque composant ne sait rien des autres composants.  En d'autres termes, il n'a aucun lien vers un bloc de code à grain fin provenant d'un autre composant, même vers l'interface!  Cela signifie que l'injection de dépendance et l'inversion de dépendance ne suffisent pas pour séparer les composants, nous aurons besoin d'une sorte de construction architecturale.  Des événements, un tronc commun, une cohérence éventuelle et même un service de découverte peuvent être nécessaires! <br><br> <a href=""><img src="https://habrastorage.org/webt/wp/gk/2w/wpgk2wxy5fgyjtrwuzctapvv19y.png"></a> <br><br><a name="15"></a><h3>  Déclenchement de la logique dans d'autres composants </h3><br>  Lorsqu'un de nos composants (composant B) doit faire quelque chose à chaque fois que quelque chose d'autre se produit dans un autre composant (composant A), nous ne pouvons pas simplement appeler directement le composant A vers la classe / méthode du composant B, car alors A sera connecté à B. <br><br>  Cependant, nous pouvons utiliser le gestionnaire d'événements pour distribuer l'événement d'application, qui sera remis à tout composant qui l'écoute, y compris B, et l'écouteur d'événement dans B déclenchera l'action souhaitée.  Cela signifie que le composant A dépendra du gestionnaire d'événements, mais sera distinct du composant B. <br><br>  Cependant, si l'événement lui-même "vit" dans A, cela signifie que B connaît l'existence de A et y est associé.  Pour supprimer cette dépendance, nous pouvons créer une bibliothèque avec un ensemble de fonctionnalités du cœur de l'application qui seront partagées par tous les composants - un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cœur commun</a> .  Cela signifie que les deux composants dépendront du noyau commun, mais seront séparés l'un de l'autre.  Un noyau commun contient des fonctionnalités telles que les événements d'application et de domaine, mais il peut également contenir des objets de spécification et tout ce qui a du sens à partager.  En même temps, il doit être d'une taille minimale, car tout changement dans le noyau commun affectera tous les composants de l'application.  De plus, si nous avons un système polyglotte, disons, un écosystème de microservices dans différentes langues, le noyau commun ne devrait pas dépendre de la langue pour que tous les composants le comprennent.  Par exemple, au lieu d'un noyau commun avec une classe d'événements, il contiendra une description de l'événement (c'est-à-dire un nom, des propriétés, peut-être même des méthodes, bien qu'elles soient plus utiles dans l'objet de spécification) dans un langage universel comme JSON afin que tous les composants / microservices puissent l'interpréter et peut-être même générer automatiquement leurs propres implémentations spécifiques. <br><br>  Cette approche fonctionne à la fois dans les applications monolithiques et distribuées, telles que les écosystèmes de microservices.  Mais si les événements ne peuvent être délivrés que de manière asynchrone, cette approche n'est pas suffisante pour les contextes où la logique de déclenchement dans d'autres composants devrait fonctionner immédiatement!  Ici, le composant A devra effectuer un appel HTTP direct au composant B. Dans ce cas, pour déconnecter les composants, nous avons besoin d'un service de découverte.  La composante A lui demandera où envoyer la demande pour lancer l'action souhaitée.  Sinon, faites une demande au service de découverte, qui la transmettra au service approprié et retournera finalement une réponse au demandeur.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cette approche associe des composants à un service de découverte, mais ne les associe pas entre eux. </font></font><br><br><a name="16"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Récupération de données à partir d'autres composants </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Selon moi, le composant n'est pas autorisé à modifier des données qu'il ne «possède» pas, mais il peut demander et utiliser n'importe quelle donnée. </font></font><br><br><a name="17"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stockage de données partagé pour les composants </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si le composant doit utiliser des données appartenant à un autre composant (par exemple, le composant de facturation doit utiliser le nom du client qui appartient au composant de comptes), alors il contient l'objet de demande au stockage de données. </font><font style="vertical-align: inherit;">Autrement dit, le composant de facturation peut connaître n'importe quel ensemble de données, mais doit utiliser des données en lecture seule d'autres pays.</font></font><br><br><a name="18"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stockage de données séparé pour le composant </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans ce cas, le même modèle est appliqué, mais le niveau de stockage des données devient plus compliqué. </font><font style="vertical-align: inherit;">La présence de composants avec leur propre entrepôt de données signifie que chaque entrepôt de données contient:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Un ensemble de données qu'un composant possède et peut changer, ce qui en fait la seule source de vérité; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un ensemble de données qui est une copie des données d'autres composants qu'il ne peut pas modifier par lui-même, mais qui est nécessaire pour la fonctionnalité du composant. </font><font style="vertical-align: inherit;">Ces données doivent être mises à jour chaque fois qu'elles changent dans le composant propriétaire.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaque composant créera une copie locale des données dont il a besoin à partir d'autres composants, qui sera utilisée au besoin. </font><font style="vertical-align: inherit;">Lorsque les données changent dans le composant auquel elles appartiennent, ce composant propriétaire déclenche un événement de domaine qui entraîne des modifications de données. </font><font style="vertical-align: inherit;">Les composants contenant une copie de ces données écouteront cet événement de domaine et mettront à jour leur copie locale en conséquence.</font></font><br><br><a name="19"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Contrôle du flux </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme je l'ai dit ci-dessus, le flux de contrôle va de l'utilisateur au cœur de l'application, aux outils d'infrastructure, puis à nouveau au cœur de l'application - et retourne à l'utilisateur. </font><font style="vertical-align: inherit;">Mais comment fonctionnent exactement les classes ensemble? </font><font style="vertical-align: inherit;">Qui dépend de qui? </font><font style="vertical-align: inherit;">Comment les composons-nous? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme Oncle Bob, dans mon article sur l'architecture propre, je vais essayer d'expliquer le flux de la gestion des schémas UMLish ...</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sans bus de commande / demande </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous n'utilisons pas le bus de commande, les contrôleurs dépendront du service d'application ou de l'objet de requête. </font></font><br><br> <sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Supplément 18/11/2017] J'ai complètement ignoré le DTO, que j'utilise pour renvoyer les données de la demande, alors je l'ai ajouté maintenant. Merci à </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MorphineAdministered</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indiqué</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> un espace.</font></font></sup> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans le diagramme ci-dessus, nous utilisons l'interface pour le service d'application, bien que nous puissions dire qu'elle n'est pas vraiment nécessaire, car le service d'application fait partie de notre code d'application. Mais nous ne voulons pas changer la mise en œuvre, bien que nous puissions procéder à une refactorisation complète.</font></font><br> <a href=""><img src="https://habrastorage.org/webt/hg/ak/_p/hgak_pjjk5jb-5klihtccnlb7dy.png"></a> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'objet Query contient une requête optimisée qui renvoie simplement des données brutes qui seront affichées à l'utilisateur. Ces données sont renvoyées au DTO, qui est intégré dans le ViewModel. Ce ViewModel peut avoir une sorte de logique de vue et sera utilisé pour remplir la vue. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D'un autre côté, le service d'application contient une logique de cas d'utilisation qui se déclenche lorsque nous voulons faire quelque chose sur le système, et pas seulement afficher certaines données. Le service d'application dépend des référentiels qui renvoient des entités qui contiennent la logique qui doit être lancée. Il peut également dépendre du service de domaine pour coordonner le processus de domaine sur plusieurs entités, mais c'est un cas rare.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après avoir analysé le cas d'utilisation, le service d'application peut informer l'ensemble du système qu'un cas d'utilisation s'est produit, puis il dépendra du répartiteur d'événements pour déclencher l'événement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est intéressant de noter que nous hébergeons des interfaces à la fois sur le moteur de persistance et les référentiels. </font><font style="vertical-align: inherit;">Cela peut sembler redondant, mais ils servent à différentes fins:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L'interface de persistance est une couche d'abstraction sur ORM, afin que nous puissions échanger ORM sans changer le cœur de l'application. </font></font></li><li>       persistence-. ,     MySQL  MongoDB.    persistence-    ,         ORM,       .   ,    ,      ,        ,       ,   ,    MongoDB  SQL. </li></ul><br><h2> C  / </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si notre application utilise le bus de commande / requête, le schéma reste quasiment le même, sauf que le contrôleur dépend désormais du bus, ainsi que des commandes ou requêtes. Une instance d'une commande ou d'une demande est créée ici et transmise au bus, qui trouvera le gestionnaire approprié pour recevoir et traiter la commande. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le diagramme ci-dessous, le gestionnaire de commandes utilise le service d'application. Mais ce n'est pas toujours nécessaire, car dans la plupart des cas, le gestionnaire contiendra toute la logique du cas d'utilisation. Tout ce que nous devons faire est d'extraire la logique du gestionnaire dans un service d'application distinct si nous devons réutiliser la même logique dans un autre gestionnaire. </font></font><br><br> <sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Supplément 18/11/2017] J'ai complètement ignoré le DTO, que j'utilise pour renvoyer les données de la demande, alors je l'ai ajouté maintenant. Je vous remercie</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MorphineAdministered</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indiquait</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> un espace. </font></font></sup> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous avez peut-être remarqué qu'il n'y a pas de dépendances entre le bus, la commande, la demande et les gestionnaires. </font><font style="vertical-align: inherit;">En fait, ils n'ont pas besoin de se connaître pour assurer une bonne séparation. </font><font style="vertical-align: inherit;">La méthode de direction du bus vers un gestionnaire spécifique pour le traitement d'une commande ou d'une demande est configurée dans une configuration simple. </font><font style="vertical-align: inherit;">Dans les deux cas, toutes les flèches - dépendances qui traversent la limite du noyau de l'application - pointent vers l'intérieur. </font><font style="vertical-align: inherit;">Comme expliqué précédemment, c'est la règle fondamentale des ports et adaptateurs, de l'oignon et de l'architecture propre.</font></font><br> <a href=""><img src="https://habrastorage.org/webt/dh/vh/c1/dhvhc1qxek9af6wc2ztmfqq4m4u.png"></a> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <a href=""><img src="https://habrastorage.org/webt/la/3y/qs/la3yqsseqajawy91dvvrzcgzuku.png"></a> <br><br><h1>  Conclusion </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comme toujours, l'objectif est d'obtenir une base de code déconnectée avec une connectivité élevée, dans laquelle vous pouvez facilement, rapidement et en toute sécurité apporter des modifications. </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les plans sont inutiles, mais la planification est tout. </font><font style="vertical-align: inherit;">- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eisenhower</font></font></i> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette infographie est une carte conceptuelle. </font><font style="vertical-align: inherit;">La connaissance et la compréhension de tous ces concepts vous aident à planifier une architecture saine et une application viable. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une carte n'est pas un territoire. </font><font style="vertical-align: inherit;">- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alfred Korzybsky</font></font></i> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En d'autres termes, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ce ne sont que des recommandations! </font><font style="vertical-align: inherit;">Une application est un territoire, une réalité, un cas d'utilisation spécifique où nous devons appliquer nos connaissances, et cela détermine à quoi ressemblera la vraie architecture! </font></font></b> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons comprendre tous ces modèles, mais nous devons également toujours penser et comprendre ce dont notre application a besoin, jusqu'où nous pouvons aller pour la séparation et la connectivité. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette décision dépend de nombreux facteurs, allant des exigences fonctionnelles du projet, au calendrier de développement de l'application, à sa durée de vie, à l'expérience de l'équipe de développement, etc. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est comme ça que j'imagine tout ça pour moi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ces idées sont discutées plus en détail dans l'article suivant: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Plus que de simples couches concentriques</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">"</font></a></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr427739/">https://habr.com/ru/post/fr427739/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr427729/index.html">Comment configurer le pare-feu sur un serveur avec Zimbra?</a></li>
<li><a href="../fr427731/index.html">Linus Torvalds de retour en service après la sortie de la version 4.19 du noyau</a></li>
<li><a href="../fr427733/index.html">Cyberpunk 2000: Outils de création Deus Ex</a></li>
<li><a href="../fr427735/index.html">Analyse du jeu des camarades de classe au Joker 2018</a></li>
<li><a href="../fr427737/index.html">Voyage au pays des géants: ONYX BOOX Gulliver Review</a></li>
<li><a href="../fr427741/index.html">Générateur de code pour Laravel - pour l'entrée OAS, pour la sortie JSON-API</a></li>
<li><a href="../fr427743/index.html">Drôle et bizarre: nous avons rassemblé des requêtes de recherche que nous aimons</a></li>
<li><a href="../fr427745/index.html">Trucs et astuces Kubernetes: accès aux sites de développement</a></li>
<li><a href="../fr427747/index.html">Qui écraser une voiture sans pilote: résultats de l'expérience Moral Machine</a></li>
<li><a href="../fr427749/index.html">Apple et Samsung pour la première fois condamnés à une amende pour avoir ralenti de vieux téléphones</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>