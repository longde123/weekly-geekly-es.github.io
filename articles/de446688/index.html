<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ì ü§£ üë©üèΩ SIMD-Erweiterung auf C ++ OpenMP in Visual Studio üåÅ üíáüèø üé≤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im Zeitalter allgegenw√§rtiger KI-Anwendungen steigt die Nachfrage des Compilers, der rechenintensiven Code f√ºr maschinelles Lernen f√ºr vorhandene Hard...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SIMD-Erweiterung auf C ++ OpenMP in Visual Studio</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/446688/"><p>  Im Zeitalter allgegenw√§rtiger KI-Anwendungen steigt die Nachfrage des Compilers, der rechenintensiven Code f√ºr maschinelles Lernen f√ºr vorhandene Hardware beschleunigt.  Ein solcher Code f√ºhrt normalerweise mathematische Berechnungen wie Matrixtransformation und -manipulation durch und liegt normalerweise in Form von Schleifen vor.  Die SIMD-Erweiterung von OpenMP bietet Benutzern eine m√ºhelose M√∂glichkeit, Schleifen zu beschleunigen, indem die Vektoreinheit moderner Prozessoren explizit genutzt wird.  Wir sind stolz darauf, C / C ++ OpenMP SIMD-Vektorisierung in Visual Studio 2019 anbieten zu k√∂nnen. </p><br><p>  Die OpenMP C / C ++ - Anwendungsprogrammschnittstelle wurde urspr√ºnglich entwickelt, um die Anwendungsleistung zu verbessern, indem Code in den 90er Jahren auf mehreren Prozessoren effektiv parallel ausgef√ºhrt werden konnte.  Im Laufe der Jahre wurde der OpenMP-Standard erweitert, um zus√§tzliche Konzepte wie aufgabenbasierte Parallelisierung, SIMD-Vektorisierung und Prozessor-Offloading zu unterst√ºtzen.  Seit 2005 unterst√ºtzt Visual Studio den OpenMP 2.0-Standard, der sich auf Multithread-Parallelisierung konzentriert.  W√§hrend sich die Welt in eine KI-√Ñra bewegt, sehen wir eine wachsende Chance, die Codequalit√§t zu verbessern, indem die Unterst√ºtzung des OpenMP-Standards in Visual Studio erweitert wird.  Wir setzen unsere Reise in Visual Studio 2019 fort, indem wir Unterst√ºtzung f√ºr OpenMP SIMD hinzuf√ºgen. </p><br><img src="https://habrastorage.org/webt/74/-s/cs/74-scsh4qdjqqdw-qj3ynz5ircc.jpeg"><a name="habracut"></a><br><br><p>  OpenMP SIMD, das erstmals im OpenMP 4.0-Standard eingef√ºhrt wurde, zielt haupts√§chlich auf die Vektorisierung von Schleifen ab.  Laut unserer Forschung ist es die bislang am h√§ufigsten verwendete OpenMP-Funktion beim maschinellen Lernen.  Durch Annotieren einer Schleife mit einer OpenMP SIMD-Direktive kann der Compiler Vektorabh√§ngigkeiten ignorieren und die Schleife so weit wie m√∂glich vektorisieren.  Der Compiler respektiert die Absicht der Benutzer, mehrere Schleifeniterationen gleichzeitig ausf√ºhren zu lassen. </p><br><pre><code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp simd for (i = 0; i &lt; count; i++) { a[i] = b[i] + 1; }</span></span></code> </pre> <br><p>  Wie Sie vielleicht wissen, bietet C ++ in Visual Studio bereits √§hnliche Nicht-OpenMP-Schleifen-Pragmas wie <strong>#pragma vector</strong> und <strong>#pragma ivdep</strong> .  Der Compiler kann jedoch mehr mit OpenMP SIMD tun.  Zum Beispiel: </p><br><ol><li>  Der Compiler darf vorhandene Vektorabh√§ngigkeiten immer ignorieren. </li><li>  / fp: schnell ist innerhalb der Schleife aktiviert. </li><li>  Schleifen mit Funktionsaufrufen sind vektorisierbar. </li><li>  √Ñu√üere Schleifen sind vektorisierbar. </li><li>  Verschachtelte Schleifen k√∂nnen zu einer Schleife zusammengef√ºhrt und vektorisiert werden. </li><li>  Hybridbeschleunigung ist mit <strong>#pragma omp for simd erreichbar</strong> , um grobk√∂rniges Multithreading und feink√∂rnige Vektorisierung zu erm√∂glichen. </li></ol><br><p>  Dar√ºber hinaus kann die OpenMP SIMD-Direktive die folgenden Klauseln enthalten, um die Vektorisierung weiter zu verbessern: </p><br><ul><li>  <strong>simdlen (</strong> <em>L√§nge</em> <strong>):</strong> <strong>Geben Sie</strong> die Anzahl der Vektorspuren an </li><li>  <strong>safelen (</strong> <em>L√§nge</em> <strong>):</strong> <strong>Geben Sie</strong> den Abstand der <strong>Vektorabh√§ngigkeit an</strong> </li><li>  <strong>linear (</strong> <em>Liste [</em> <strong>:</strong> <em>linearer Schritt]</em> <strong>):</strong> Die lineare Zuordnung von der Schleifeninduktionsvariablen zum Array-Abonnement </li><li>  <strong>ausgerichtet (</strong> <em>Liste [</em> <strong>:</strong> <em>Ausrichtung]</em> <strong>):</strong> die Ausrichtung von Daten </li><li>  <strong>privat (</strong> <em>Liste</em> <strong>):</strong> Datenprivatisierung angeben </li><li>  <strong>lastprivate (</strong> <em>Liste</em> <strong>):</strong> <strong>Geben Sie die Datenprivatisierung</strong> mit dem Endwert der letzten Iteration an </li><li>  <strong>Reduktion (</strong> <em>Reduktionskennung</em> <strong>:</strong> <em>Liste</em> <strong>):</strong> Geben Sie benutzerdefinierte Reduktionsoperationen an </li><li>  <strong>Zusammenbruch (</strong> <em>n</em> <strong>):</strong> Verschmelzungsschleifennest </li></ul><br><h3>  New <em>-openmp: experimenteller</em> Schalter </h3><br><p>  Ein mit OpenMP-SIMD annotiertes Programm kann mit einem neuen CL-Schalter <strong>-openmp: experimentell</strong> kompiliert <strong>werden.</strong>  Dieser neue Switch <strong>aktiviert</strong> zus√§tzliche OpenMP-Funktionen, die unter <strong>-openmp</strong> nicht verf√ºgbar <strong>sind</strong> .  W√§hrend der Name dieses Switches "experimentell" ist, werden der Switch selbst und die von ihm aktivierten Funktionen vollst√§ndig unterst√ºtzt und sind produktionsbereit.  Der Name gibt an, dass keine vollst√§ndige Teilmenge oder Version eines OpenMP-Standards aktiviert wird.  Zuk√ºnftige Iterationen des Compilers k√∂nnen diesen Schalter verwenden, um zus√§tzliche OpenMP-Funktionen zu aktivieren, und neue OpenMP-bezogene Schalter k√∂nnen hinzugef√ºgt werden.  Der <strong>experimentelle</strong> Schalter <strong>-openmp:</strong> <strong>fasst den</strong> Schalter <strong>-openmp zusammen</strong> , was bedeutet, dass er mit allen OpenMP 2.0-Funktionen kompatibel ist.  Beachten Sie, dass die SIMD-Direktive und ihre Klauseln nicht mit dem Schalter <strong>-openmp</strong> kompiliert werden <strong>k√∂nnen</strong> . </p><br><p>  F√ºr Schleifen, die nicht vektorisiert sind, gibt der Compiler f√ºr jede von ihnen eine Nachricht wie unten aus.  Zum Beispiel </p><br><p>  cl -O2 -openmp: experimentelle mycode.cpp </p><br><p>  mycode.cpp (84): info C5002: Omp-simd-Schleife aus Grund '1200' nicht vektorisiert </p><br><p>  mycode.cpp (90): info C5002: Omp-simd-Schleife aus Grund '1200' nicht vektorisiert </p><br><p>  F√ºr Schleifen, die vektorisiert sind, bleibt der Compiler stumm, es sei denn, ein Vektorisierungsprotokollierungsschalter ist vorhanden: </p><br><p>  cl -O2 -openmp: experimentell -Qvec-Bericht: 2 mycode.cpp </p><br><p>  mycode.cpp (84): info C5002: Omp-simd-Schleife aus Grund '1200' nicht vektorisiert </p><br><p>  mycode.cpp (90): info C5002: Omp-simd-Schleife aus Grund '1200' nicht vektorisiert </p><br><p>  mycode.cpp (96): info C5001: Omp simd loop vektorisiert </p><br><p>  Als ersten Schritt zur Unterst√ºtzung von OpenMP SIMD haben wir das SIMD-Pragma grunds√§tzlich mit dem Backend-Vektorisierer unter dem neuen Switch verbunden.  Wir haben uns auf die Vektorisierung der innersten Schleifen konzentriert, indem wir die Vektorisierer- und Alias-Analyse verbessert haben.  Zum Zeitpunkt dieses Schreibens ist keine der SIMD-Klauseln in Visual Studio 2019 wirksam.  Sie werden analysiert, aber vom Compiler mit einer Warnung ignoriert, die zur Kenntnisnahme des Benutzers ausgegeben wird.  Zum Beispiel wird der Compiler ausgeben </p><br><p>  Warnung C4849: OpenMP-Klausel 'simdlen' wird in der Anweisung 'simd' ignoriert </p><br><p>  f√ºr den folgenden Code: </p><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp simd simdlen(8) for (i = 1; i &lt; count; i++) { a[i] = a[i-1] + 1; b[i] = *c + 1; bar(i); }</span></span></code> </pre> <br><h3>  Weitere Informationen zur Semantik der OpenMP SIMD-Direktive </h3><br><p>  Die OpenMP SIMD-Direktive bietet Benutzern die M√∂glichkeit, den Compiler zum Vektorisieren einer Schleife zu diktieren.  Der Compiler darf die offensichtliche Rechtm√§√üigkeit einer solchen Vektorisierung ignorieren, indem er das Versprechen der Benutzer zur Richtigkeit akzeptiert.  Es liegt in der Verantwortung der Benutzer, wenn bei der Vektorisierung unerwartetes Verhalten auftritt.  Durch Annotieren einer Schleife mit der OpenMP SIMD-Direktive m√∂chten Benutzer, dass mehrere Schleifeniterationen gleichzeitig ausgef√ºhrt werden.  Dies gibt dem Compiler viel Freiheit beim Generieren von Maschinencode, der SIMD- oder Vektorressourcen auf dem Zielprozessor nutzt.  Der Compiler ist zwar nicht daf√ºr verantwortlich, die Richtigkeit und den Gewinn einer solchen benutzerdefinierten Parallelit√§t zu untersuchen, <strong>muss jedoch</strong> das sequentielle Verhalten einer einzelnen Schleifeniteration sicherstellen. </p><br><p>  Beispielsweise wird die folgende Schleife mit der OpenMP SIMD-Direktive kommentiert.  Es gibt keine perfekte Parallelit√§t zwischen Schleifeniterationen, da eine R√ºckw√§rtsabh√§ngigkeit von a [i] zu a [i-1] besteht.  Aufgrund der SIMD-Direktive kann der Compiler jedoch weiterhin aufeinanderfolgende Iterationen der ersten Anweisung in einen Vektorbefehl packen und parallel ausf√ºhren. </p><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp simd for (i = 1; i &lt; count; i++) { a[i] = a[i-1] + 1; b[i] = *c + 1; bar(i); }</span></span></code> </pre> <br><p>  Daher ist die folgende transformierte Vektorform der Schleife <strong>zul√§ssig,</strong> da der Compiler das sequentielle Verhalten jeder urspr√ºnglichen Schleifeniteration beibeh√§lt.  Mit anderen Worten, a [i] wird nach a [-1] ausgef√ºhrt, b [i] nach a [i] und der Aufruf von bar erfolgt schlie√ülich. </p><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp simd for (i = 1; i &lt; count; i+=4) { a[i:i+3] = a[i-1:i+2] + 1; b[i:i+3] = *c + 1; bar(i); bar(i+1); bar(i+2); bar(i+3); }</span></span></code> </pre> <br><p>  Es ist illegal, die Speicherreferenz <em>* c</em> aus der Schleife zu verschieben, wenn sie mit <em>a [i]</em> oder <em>b [i]</em> alias ist.  Es ist auch illegal, die Anweisungen innerhalb einer urspr√ºnglichen Iteration neu zu ordnen, wenn dadurch die sequentielle Abh√§ngigkeit aufgehoben wird.  Beispielsweise ist die folgende transformierte Schleife <strong>nicht</strong> zul√§ssig. </p><br><pre> <code class="cs hljs">c = b; t = *c; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp simd for (i = 1; i &lt; count; i+=4) { a[i:i+3] = a[i-1:i+2] + 1; bar(i); // illegal to reorder </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> bar[i] depends on b[i] b[i:i+3] = t + 1; // illegal to move *c out of the loop bar(i+1); bar(i+2); bar(i+3); }</span></span></code> </pre> <br><h3>  Zukunftspl√§ne und Feedback </h3><br><p>  Wir empfehlen Ihnen, diese neue Funktion auszuprobieren.  Wie immer freuen wir uns √ºber Ihr Feedback.  Wenn Sie eine OpenMP SIMD-Schleife sehen, von der Sie erwarten, dass sie vektorisiert wird, die jedoch nicht oder der generierte Code nicht optimal ist, teilen Sie uns dies bitte mit.  Sie erreichen uns √ºber die folgenden Kommentare, per E-Mail ( <a href="">visualcpp@microsoft.com</a> ), Twitter (@visualc) oder √ºber die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwickler-Community</a> . </p><br><p>  In Zukunft w√ºrden wir gerne h√∂ren, dass OpenMP-Funktionen in Visual Studio fehlen.  Da OpenMP seit dem 2.0-Standard mehrere wichtige Entwicklungen erfahren hat, verf√ºgt OpenMP jetzt √ºber enorme Funktionen, die Ihnen die Erstellung von Hochleistungsprogrammen erleichtern.  Beispielsweise ist ab OpenMP 3.0 eine aufgabenbasierte Parallelit√§tsprogrammierung verf√ºgbar.  Heterogenes Computing (CPU + Beschleuniger) wird in OpenMP 4.0 unterst√ºtzt.  Erweiterte Unterst√ºtzung f√ºr SIMD-Vektorisierung und DOACROSS-Schleifenparallelisierung sind jetzt auch im neuesten OpenMP-Standard verf√ºgbar.  Die vollst√§ndigen Standardrevisionen und Funktionss√§tze finden Sie auf der offiziellen OpenMP-Website: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.openmp.org</a> .  Wir bitten Sie aufrichtig um Ihre Meinung zu den spezifischen OpenMP-Funktionen, die Sie sehen m√∂chten.  Wir sind auch daran interessiert zu erfahren, wie Sie OpenMP verwenden, um Ihren Code zu beschleunigen.  Ihr Feedback ist wichtig, damit es die Richtung der OpenMP-Unterst√ºtzung in Visual Studio bestimmt. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/f42/a43/b5a/f42a43b5aa8fbbbee8c5c57453dcf1ed.jpg" alt="Avatar" width="96" height="96"><br><h5>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hongtao Yu</a> </h5></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446688/">https://habr.com/ru/post/de446688/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446674/index.html">Wir modellieren den MUSIC-Algorithmus zur Bestimmung der Ankunftsrichtung einer elektromagnetischen Welle</a></li>
<li><a href="../de446676/index.html">Fehlende Schl√ºssel f√ºr die Commodore 116-Gummitastatur erstellen</a></li>
<li><a href="../de446678/index.html">Live Battle: Porto ICPC Finale</a></li>
<li><a href="../de446680/index.html">Der Hauptinstinkt des Encoders besteht darin, ineffektive L√∂sungen von √ºberall zu entfernen</a></li>
<li><a href="../de446682/index.html">Beschleunigen von WebGL / Three.js mit OffscreenCanvas und Web Workers</a></li>
<li><a href="../de446690/index.html">Electrolux bringt intelligente Luftreiniger f√ºr die am st√§rksten verschmutzten St√§dte auf den Markt</a></li>
<li><a href="../de446694/index.html">JBOD modularer Speicher und Freiheitsgrade</a></li>
<li><a href="../de446696/index.html">Mythen √ºber 152-FZ, die f√ºr den Betreiber personenbezogener Daten teuer sein k√∂nnen</a></li>
<li><a href="../de446700/index.html">Lazydocker - GUI f√ºr Docker direkt im Terminal</a></li>
<li><a href="../de446702/index.html">Und noch ein komischer Kopfh√∂rer - zum Schlafen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>