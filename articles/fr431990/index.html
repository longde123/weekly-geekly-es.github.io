<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛹🏾 🙅🏼 🐢 Des lacunes ont gagné. Traduction de la documentation des conventions de codage Kotlin à partir de JetBrains 👨🏾‍🔧 🔺 🤽🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! J'attire votre attention sur la traduction par l'auteur de la page de documentation des conventions de codage Kotlin de JetBrains. 


 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Des lacunes ont gagné. Traduction de la documentation des conventions de codage Kotlin à partir de JetBrains</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431990/"><p>  Bonjour, Habr!  J'attire votre attention sur la traduction par l'auteur de la page de documentation des conventions de codage Kotlin de JetBrains. </p><br><p>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Documentation originale</a> </p><a name="habracut"></a><br><p>  Contenu: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utilisation du guide de style sur Intellij Idea</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Structure du projet</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Structure des dossiers</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nom des fichiers source</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Organisation des fichiers source</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Structure des classes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cadre de mise en œuvre de l'interface</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Remplace la structure</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Règles de dénomination</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nom de la fonction</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nom des méthodes d'essai</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dénomination des propriétés</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Attribution d'un nom aux propriétés masquées</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Choisir les bons noms</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Formatage</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Espaces horizontaux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Colon</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Formatage de la déclaration de classe</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Modificateurs</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mettre en forme les annotations</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Annotations de fichier</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Formatage des fonctions</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Formatage d'expression sur une seule ligne</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Formatage des propriétés</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Formatage des instructions de contrôle</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Formatage des appels de méthode</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Formatage d'un appel de fonction de chaîne</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Formatage des expressions lambda</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Paperasse</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Éviter les constructions inutiles</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utilisez le mot-clé Unité</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Point-virgule</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Modèles de chaînes</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utilisation idiomatique des fonctionnalités linguistiques</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Immuabilité</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Valeur de paramètre par défaut</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Création d'alias [Type d'alias]</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dénomination des paramètres dans les expressions lambda</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Renvoyer des valeurs à partir d'expressions lambda</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Méthodes d'appel avec nommage d'arguments</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Règles pour les structures de contrôle avec conditions</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>if</code> vs <code>when</code></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Vous utilisez des valeurs booléennes?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans les instructions conditionnelles</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utilisation de boucles</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cycles de gamme</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Formatage des chaînes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctions vs propriétés</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utilisation des fonctionnalités d'extension</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utilisation des fonctions d'infixe</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Caractéristiques d'usine</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Types de plateformes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>  apply</code> / <code>with</code> / <code>run</code> / <code>also</code> / <code>let</code></a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Règles de création de bibliothèques</a> </li></ul><br><p>  <strong>Utilisation du guide de style sur Intellij Idea</strong> </p><br><p>  Pour appliquer le formatage dans Intellij Idea conformément au manuel actuel, vous devez installer le plugin Kotlin version 1.2.20 ou ultérieure, allez dans Paramètres |  Editeur |  Style de code |  Kotlin, cliquez sur le lien "Définir à partir de ..." dans le coin supérieur droit et sélectionnez "Style prédéfini" / Guide de style Kotlin "dans le menu déroulant. </p><br><p>  Pour vérifier que votre code est formaté selon le style recommandé, accédez au paramètre d'inspection et activez la case à cocher "Kotlin | Problèmes de style | Le fichier n'est pas formaté selon les paramètres du projet".  D'autres règles de validation, telles que les conventions de dénomination, sont activées par défaut. </p><br><h1 id="struktura-proekta">  Structure du projet </h1><br><h2 id="struktura-papok">  Structure des dossiers </h2><br><p>  Dans les projets utilisant différentes langues, les fichiers avec le code Kotlin doivent se trouver dans le même dossier que le code dans les autres langues et utiliser la même structure de fichiers acceptée pour la langue principale.  Par exemple, pour Java, les fichiers doivent se trouver dans la structure de dossiers en fonction du nom du package. </p><br><p>  Dans les projets utilisant uniquement Kotlin, la structure de dossiers recommandée est la suivante: utilisez des dossiers pour organiser les packages avec le répertoire racine ignoré, c'est-à-dire  si tout le code du projet se trouve dans le package "org.example.kotlin" et ses packages, les fichiers source appartenant au package "org.example.kotlin" doivent se trouver dans le répertoire racine du projet et les fichiers avec le code source du package "org. example.kotlin.foo.bar "doit se trouver dans le sous-répertoire" foo / bar "par rapport à la racine du projet. </p><br><h2 id="naimenovanie-faylov-s-ishodnym-kodom">  Nom des fichiers source </h2><br><p>  Si le fichier Kotlin ne contient qu'une seule classe (éventuellement liée à la déclaration de niveau supérieur), il doit être nommé, ainsi qu'une classe avec l'extension <code>.kt</code> .  Si le fichier contient plusieurs classes ou n'a que des déclarations de niveau supérieur, choisissez un nom qui décrit ce que le fichier contient et nommez le fichier en conséquence.  Utilisez une bosse de chameau avec une première lettre majuscule pour nommer les fichiers (par exemple <code>ProcessDeclarations.kt</code> ). </p><br><p>  Le nom du fichier doit décrire ce que fait le code dans le fichier.  Autrement dit, vous devez éviter les mots dénués de sens comme «Util» pour nommer les fichiers. </p><br><h2 id="organizaciya-faylov-s-ishodnym-kodom">  Organisation des fichiers source </h2><br><p>  Placer plusieurs déclarations (classes, fonctions ou propriétés de niveau supérieur) dans le même fichier source Kotlin est bienvenu si ces déclarations sont étroitement liées sémantiquement et que la taille du fichier reste raisonnable (pas plus de plusieurs centaines de lignes). </p><br><p>  En particulier, lorsque vous définissez des fonctions d'extension pour une classe qui s'appliquent à tous les aspects de l'application de cette classe, placez-les dans le même fichier où la classe elle-même est définie.  Lorsque vous définissez des fonctions d'extension qui n'ont de sens que pour le contexte spécifique d'utilisation de cette classe, placez-les à côté du code qui utilise la fonction d'extension.  Ne créez pas de fichiers uniquement pour stocker "toutes les extensions Foo". </p><br><h2 id="struktura-klassa">  Structure des classes </h2><br><p>  En règle générale, le contenu d'une classe est trié dans l'ordre suivant: </p><br><ul><li>  Déclarations de propriétés et blocs d'initialisation </li><li>  Constructeurs secondaires </li><li>  Déclarations de méthode </li><li>  Objets compagnons </li></ul><br><p>  Ne triez pas les déclarations de méthode par ordre alphabétique ou visuel et ne séparez pas les méthodes ordinaires des méthodes d'extension.  Au lieu de cela, assemblez le code connecté de manière logique afin que quelqu'un qui lit la classe de haut en bas puisse suivre la logique de ce qui se passe.  Choisissez un ordre de tri (code de niveau supérieur en premier [éléments de niveau supérieur en premier] et détails plus tard ou vice versa) et respectez-le. </p><br><p>  Placez les classes imbriquées à côté du code qui utilise ces classes.  Si les classes sont destinées à un usage externe et ne sont pas référencées dans la classe, placez-les à la fin après l'objet compagnon. </p><br><h2 id="struktura-realizacii-interfeysov">  Cadre de mise en œuvre de l'interface </h2><br><p>  Lors de la mise en œuvre d'une interface, conservez la même structure que l'interface en cours de mise en œuvre (si nécessaire, en l'alternant avec des méthodes privées supplémentaires utilisées pour la mise en œuvre) </p><br><h2 id="struktura-pereopredeleniy">  Remplace la structure </h2><br><p>  Des redéfinitions toujours mises en place, l'une après l'autre. </p><br><h1 id="pravila-naimenovaniya">  Règles de dénomination </h1><br><p>  Kotlin suit les mêmes conventions de dénomination que Java.  En particulier: </p><br><p>  Noms de packages en minuscules et n'utilisez pas de tirets bas (org.example.myproject).  L'utilisation de noms à plusieurs mots n'est généralement pas recommandée, mais si vous devez utiliser plusieurs mots, vous pouvez simplement les combiner ensemble ou utiliser une bosse de chameau (org.examle.myProject). </p><br><p>  Les majuscules et les noms d'objet commencent par une majuscule et utilisent une bosse de chameau: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeclarationProcessor</span></span></span><span class="hljs-class"> </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> EmptyDeclarationProcessor : DeclarationProcessor() { ... }</code> </pre> <br><h2 id="naimenovanie-funkciy">  Nom de la fonction </h2><br><p>  Les noms des fonctions, des propriétés et des variables locales commencent par une lettre minuscule et ne contiennent pas de soulignement: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processDeclarations</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> declarationCount = ...</code> </pre> <br><p>  Exception: les fonctions d'usine utilisées pour instancier des classes peuvent avoir le même nom que la classe en cours de création: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ ... } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooImpl</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Foo { ... } fun Foo</span></span></span></span>(): Foo { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FooImpl(...) }</code> </pre> <br><h2 id="naimenovanie-testovyh-metodov">  Nom des méthodes d'essai </h2><br><p>  Dans les tests (et uniquement dans les tests), il est permis d'utiliser des noms de méthode avec des espaces entre virgules inversées.  (Notez que ces noms de méthode ne sont actuellement pas pris en charge par le runtime Android.) Les soulignements dans les noms de méthode sont également autorisés dans le code de test. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyTestCase</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> `ensure everything works`</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ensureEverythingWorks_onAndroid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... } }</code> </pre> <br><h2 id="imenovanie-svoystv">  Dénomination des propriétés </h2><br><p>  Les noms de constantes (propriétés étiquetées <code>const</code> , ou propriétés de niveau supérieur ou un objet <code>val</code> sans fonction <code>get</code> personnalisée qui contient des données immuables) doivent être capitalisés, séparés par des traits de soulignement: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> MAX_COUNT = <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> USER_NAME_FIELD = <span class="hljs-string"><span class="hljs-string">"UserName"</span></span></code> </pre> <br><p>  Les noms de haut niveau ou les propriétés d'objet qui contiennent des objets avec un comportement ou des données modifiables doivent utiliser des noms communs dans la bosse du chameau: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> mutableCollection: MutableSet&lt;String&gt; = HashSet()</code> </pre> <br><p>  Les noms de propriété qui font référence aux objets Singleton peuvent utiliser le même style de dénomination que les déclarations de classe: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> PersonComparator: Comparator&lt;Person&gt; = ...</code> </pre> <br><p>  Pour les énumérations, vous pouvez utiliser des noms écrits en lettres majuscules séparées par des traits de soulignement ou dans le style bosse de chameau, en commençant par une lettre majuscule, selon l'utilisation. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span><span class="hljs-class"> </span></span>{ RED, GREEN }</code> </pre> <br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span><span class="hljs-class"> </span></span>{ RedColor, GreenColor }</code> </pre> <br><blockquote><blockquote>  Note du traducteur: ne mélangez pas différents styles.  Choisissez un style et respectez-le dans votre conception. </blockquote><br></blockquote><br><h3 id="imenovanie-skrytyh-svoystv">  Attribution d'un nom aux propriétés masquées </h3><br><p>  Si la classe possède deux propriétés conceptuellement identiques, mais que l'une fait partie de l'API publique et l'autre fait partie de l'implémentation, utilisez le trait de soulignement comme préfixe pour le nom de la propriété masquée: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> _elementList = mutableListOf&lt;Element&gt;() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> elementList: List&lt;Element&gt; <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = _elementList }</code> </pre> <br><h2 id="vybor-pravilnyh-naimenovaniy">  Choisir les bons noms </h2><br><p>  Le nom de la classe est généralement un nom ou une phrase expliquant ce qu'est la classe: </p><br><pre> <code class="plaintext hljs">List, PersonReader</code> </pre> <br><p>  Le nom de la méthode est généralement un verbe ou une expression qui explique ce que fait la méthode: </p><br><pre> <code class="plaintext hljs">close, readPersons</code> </pre> <br><p>  Le nom doit également indiquer si la méthode modifie l'objet ou en renvoie un nouveau.  Par exemple, le <code>sort</code> est un tri qui modifie la collection et <code>sorted</code> est le retour d'une nouvelle copie triée de la collection. </p><br><p>  Les noms doivent clairement indiquer le but de l'entité, il est donc préférable d'éviter l'utilisation de mots dénués de sens ( <code>Manager</code> , <code>Wrapper</code> , etc.) dans les noms. </p><br><p>  Lorsque vous utilisez l'acronyme dans le nom de l'annonce, utilisez des majuscules s'il se compose de deux lettres ( <code>IOStream</code> );  ou en majuscule uniquement la première lettre, si elle est plus longue ( <code>XmlFormatter</code> , <code>HttpInputStream</code> ). </p><br><h1 id="formatirovanie">  Formatage </h1><br><p>  Dans la plupart des cas, Kotlin suit les conventions de formatage Java. </p><br><p>  Utilisez 4 espaces pour mettre en retrait.  N'utilisez pas d'onglets. </p><br><p>  Pour les croisillons, placez le croisillon d'ouverture à la fin de la ligne où commence la structure et le croisillon de fermeture sur une ligne distincte, aligné horizontalement avec la structure d'ouverture. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elements != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (element <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> elements) { <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre> <br><blockquote><blockquote>  (Remarque: dans Kotlin, un point-virgule est facultatif, donc l'habillage de ligne est important. La conception du langage suppose des accolades de style Java et vous pouvez rencontrer un comportement d'exécution de code inattendu si vous essayez d'utiliser un style de mise en forme différent.) </blockquote><br></blockquote><br><h2 id="gorizontalnye-probely">  Espaces horizontaux </h2><br><p>  Placez des espaces autour des opérateurs binaires <code>(a + b)</code> .  Exception: ne placez pas d'espaces autour de l'opérateur "range to" <code>(0..i)</code> </p><br><p>  Ne placez pas d'espaces autour des opérateurs unaires <code>(a++)</code> </p><br><p>  Placez des espaces entre les mots clés de contrôle ( <code>if</code> , <code>when</code> , <code>for</code> et <code>while</code> ) et les crochets d'ouverture correspondants. </p><br><p>  Ne placez pas d'espace avant la parenthèse ouvrante dans la déclaration principale d'un constructeur, d'une méthode ou d'une méthode. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { foo(<span class="hljs-number"><span class="hljs-number">1</span></span>) }</code> </pre> <br><p>  Ne placez jamais d'espace après <code>(</code> , <code>[</code> ou avant <code>]</code> , <code>)</code> . </p><br><p>  Ne placez jamais d'espace autour d'un point <code>.</code>  ou opérateur <code>?.</code>  : </p><br><pre> <code class="kotlin hljs">foo.bar().filter { it &gt; <span class="hljs-number"><span class="hljs-number">2</span></span> }.joinToString() foo?.()</code> </pre> <br><p>  Mettez un espace après la double barre oblique pour le commentaire <code>//</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre> <br><p>  Ne placez pas d'espaces autour des parenthèses angulaires utilisées pour indiquer les paramètres de type: </p><br><pre> <code class="kotlin hljs">Class Map&lt;K, V&gt; { ... }</code> </pre> <br><p>  Ne placez pas d'espaces autour des deux points pour indiquer une référence à la méthode <code>::</code> class: </p><br><pre> <code class="kotlin hljs">Foo::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">:</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">:length</span></span></span></span></code> </pre> <br><p>  Ne mettez pas d'espace avant <code>?</code>  utilisé pour marquer un <code>null</code> : </p><br><pre> <code class="kotlin hljs">String?</code> </pre> <br><p>  Évitez généralement tout type d'alignement horizontal.  Renommer un identifiant en un nom d'une longueur différente ne doit pas affecter la mise en forme du code. </p><br><h2 id="dvoetochie">  Colon </h2><br><p>  Mettez un espace avant les deux points <code>:</code> dans les cas suivants: </p><br><ul><li>  quand il est utilisé pour séparer le type du super type; </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">out T : Any</span></span></span><span class="hljs-class">&gt;</span></span></code> </pre> <br><ul><li>  lors de la délégation à un constructeur de superclasse ou à un autre constructeur de la même classe; </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x: String) : <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(x) { ... } <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x: String) : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(x) { ... }</code> </pre> <br><ul><li>  après l'objet mot clé. </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : IFoo { ... }</code> </pre> <br><p>  Ne mettez pas d'espace avant <code>:</code> lorsqu'il sépare une annonce et son type. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: T</code> </pre> <br><p>  Mettez toujours un espace après <code>:</code> </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">out T : Any</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IFoo { abstract fun foo</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>): T } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooImpl</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Foo</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x: String) : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(x) { ... } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : IFoo { ... } }</code> </pre> <br><h2 id="formatirovanie-obyavleniya-klassov">  Formatage de la déclaration de classe </h2><br><p>  Les classes avec plusieurs paramètres constructeurs de base et noms abrégés peuvent être écrites sur une seule ligne: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(id: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, name: String)</code> </pre> <br><p>  Les classes avec des noms plus longs ou le nombre de paramètres doivent être formatées de manière à ce que chaque paramètre principal du constructeur soit sur une ligne distincte avec indentation.  De plus, le support de fermeture doit se trouver sur une nouvelle ligne.  Si nous utilisons l'héritage, alors l'appel au constructeur de la superclasse ou la liste des interfaces implémentées devrait être situé sur la même ligne que le support: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>( id: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, name: String, surname: String ) : Human(id, name) { ... }</code> </pre> <br><p>  Lorsque vous spécifiez l'interface et appelez le constructeur de la superclasse, le constructeur de la superclasse doit d'abord être localisé, puis le nom de l'interface sur une nouvelle ligne est justifié à gauche: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>( id: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, name: String, surname: String ) : Human(id, name), KotlinMaker { ... }</code> </pre> <br><p>  Pour les classes avec une longue liste de super types, vous devez mettre un saut de ligne après les deux points et aligner tous les noms de super types horizontalement vers la gauche: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyFavouriteVeryLongClassHolder</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyLongHolder</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyFavouriteVeryLongClass</span></span></span><span class="hljs-class">&gt;</span></span>(), SomeOtherInterface, AndAnotherOne { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... } }</code> </pre> <br><p>  Pour séparer clairement l'en-tête de classe et son corps lorsque l'en-tête de classe est long, placez une ligne vide après l'en-tête de classe (comme dans l'exemple ci-dessus), ou placez l'accolade ouvrante sur une ligne distincte: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyFavouriteVeryLongClassHolder</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyLongHolder</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyFavouriteVeryLongClass</span></span></span><span class="hljs-class">&gt;</span></span>(), SomeOtherInterface, AndAnotherOne { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... } }</code> </pre> <br><p>  Utilisez une indentation régulière (4 espaces) pour les paramètres du constructeur. </p><br><blockquote><blockquote>  Justification: cela garantit que les propriétés déclarées dans le constructeur principal ont la même indentation que les propriétés déclarées dans le corps de la classe. </blockquote><br></blockquote><br><h2 id="modifikatory">  Modificateurs </h2><br><p>  Si une annonce contient plusieurs modificateurs, organisez-les toujours dans l'ordre suivant: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> / <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> / <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> / <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">expect</span></span> / <span class="hljs-keyword"><span class="hljs-keyword">actual</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> / <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> / <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> / <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> / <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">tailrec</span></span> <span class="hljs-keyword"><span class="hljs-keyword">vararg</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> / <span class="hljs-keyword"><span class="hljs-keyword">annotation</span></span> <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span></code> </pre> <br><p>  Mettez toutes les annotations avant les modificateurs: </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Named(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Foo"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> foo: Foo</code> </pre> <br><p>  Si vous ne travaillez pas sur une bibliothèque, omettez les modificateurs redondants (par exemple publics). </p><br><h2 id="formatirovanie-annotaciy">  Mettre en forme les annotations </h2><br><p>  Les annotations sont généralement placées sur des lignes distinctes avant la déclaration à laquelle elles sont jointes, et avec le même tiret: </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Target(AnnotationTarget.PROPERTY)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">annotation</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonExclude</span></span></span></span></code> </pre> <br><p>  Les annotations sans arguments peuvent être situées sur une seule ligne: </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@JsonExclude</span></span> <span class="hljs-meta"><span class="hljs-meta">@JvmField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x: String</code> </pre> <br><p>  Une annotation sans arguments peut être placée sur la même ligne que la déclaration correspondante: </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... }</code> </pre> <br><h2 id="faylovye-annotacii">  Annotations de fichier </h2><br><p>  Les annotations aux fichiers sont placées après le commentaire sur le fichier (le cas échéant), avant l'instruction package et sont séparées du package par une ligne vide (pour souligner le fait qu'elles visent le fichier, pas le package). </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">/** License, copyright and whatever */</span></span> <span class="hljs-meta"><span class="hljs-meta">@file:JvmName</span></span>(<span class="hljs-string"><span class="hljs-string">"FooBar"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">package</span></span> foo.bar</code> </pre> <br><h2 id="formatirovanie-funkciy">  Formatage des fonctions </h2><br><p>  Si la signature de la méthode ne tient pas sur une seule ligne, utilisez la syntaxe suivante: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">longMethodName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( argument: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ArgumentType</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = defaultValue, argument2: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AnotherArgumentType</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>: ReturnType { <span class="hljs-comment"><span class="hljs-comment">// body }</span></span></code> </pre> <br><p>  Utilisez une indentation régulière (4 espaces) pour les paramètres de fonction. </p><br><blockquote><blockquote>  Justification: cohérence avec les paramètres du constructeur </blockquote><br></blockquote><p>  Il est préférable d'utiliser une expression sans accolades pour les fonctions constituées d'une seule ligne. </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> { <span class="hljs-comment"><span class="hljs-comment">// bad return 1 } fun foo() = 1 // good</span></span></code> </pre> <br><h2 id="formatirovanie-odnostrochnogo-vyrazheniya">  Formatage d'expression sur une seule ligne </h2><br><p>  Si le corps d'une fonction sur une seule ligne ne tient pas sur la même ligne que la déclaration, mettez le signe = dans la première ligne.  Indentation du corps de l'expression par 4 espaces. </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = x.length</code> </pre> <br><h2 id="formatirovanie-svoystviya">  Formatage des propriétés </h2><br><p>  Pour les propriétés simples en lecture seule, il est préférable d'utiliser un formatage sur une seule ligne: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isEmpty: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = size == <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br><p>  Pour des propriétés plus complexes, utilisez toujours <code>get</code> et <code>set</code> sur des lignes distinctes: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> foo: String <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() { ... }</code> </pre> <br><p>  Pour les propriétés avec initialisation, si l'initialiseur est trop long, ajoutez un saut de ligne après le signe égal et un retrait de quatre espaces pour la chaîne d'initialisation: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> defaultCharset: Charset? = EncodingRegistry.getInstance().getDefaultCharsetForPropertiesFiles(file)</code> </pre><br><h2 id="formatirovanie-upravlyayuschiy-instrukciy">  Formatage des instructions de contrôle </h2><br><p>  Si la condition dans l'instruction <code>if</code> ou <code>when</code> est multiligne, utilisez toujours des accolades autour du corps de l'instruction.  Indenter chaque ligne suivante de la condition de 4 espaces par rapport au début de l'instruction.  Placez les crochets de fermeture de la condition ainsi que l'accolade ouvrante sur une ligne distincte: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!component.isSyncing &amp;&amp; !hasAnyKotlinRuntimeInScope(module) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> createKotlinNotConfiguredPanel(module) }</code> </pre> <br><blockquote><blockquote>  Justification: alignement net et séparation claire du corps de condition et du corps de condition </blockquote><br></blockquote><p>  Placez les mots-clés <code>else</code> , <code>catch</code> , <code>finally</code> , ainsi que le mot-clé <code>while</code> de la boucle do / while sur la même ligne que le crochet précédent. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition) { <span class="hljs-comment"><span class="hljs-comment">// body } else { // else part } try { // body } finally { // cleanup }</span></span></code> </pre> <br><p>  Si les conditions <code>when</code> les instructions sont constituées de plusieurs blocs, il est recommandé de les séparer les uns des autres par une ligne vide: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parsePropertyValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(propName: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, token: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Token</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (token) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Token.ValueToken -&gt; callback.visitValue(propName, token.value) Token.LBRACE -&gt; { <span class="hljs-comment"><span class="hljs-comment">// ... } } }</span></span></code> </pre> <br><p>  Placez les blocs courts des instructions <code>when</code> sur la même ligne sans accolades. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (foo) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; bar() <span class="hljs-comment"><span class="hljs-comment">// good false -&gt; { baz() } // bad }</span></span></code> </pre> <br><h2 id="formatirovanie-vyzovov-metodov">  Formatage des appels de méthode </h2><br><p>  Lorsque vous utilisez une longue liste de paramètres, placez le saut de ligne après la parenthèse.  Mettez en retrait 4 espaces et regroupez les arguments liés logiquement sur une seule ligne. </p><br><pre> <code class="kotlin hljs">drawSquare( x = <span class="hljs-number"><span class="hljs-number">10</span></span>, y = <span class="hljs-number"><span class="hljs-number">10</span></span>, width = <span class="hljs-number"><span class="hljs-number">100</span></span>, height = <span class="hljs-number"><span class="hljs-number">100</span></span>, fill = <span class="hljs-literal"><span class="hljs-literal">true</span></span> )</code> </pre> <br><p>  Utilisez des espaces autour du signe égal entre le nom du paramètre et sa valeur. </p><br><h2 id="formatirovanie-cepochnogo-vyzova-funkciy">  Formatage d'un appel de fonction de chaîne </h2><br><p>  Lorsque vous utilisez des appels en chaîne, mettez <code>.</code>  ou <code>?.</code>  opérateurs sur une nouvelle ligne avec une indentation dans 4 espaces: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> anchor = owner ?.firstChild!! .siblings(forward = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) .dropWhile { it <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> PsiComment || it <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> PsiWhiteSpace }</code> </pre> <br><p>  Le premier appel dans la chaîne devrait généralement avoir un saut de ligne devant lui, mais il est normal de ne pas le faire si le code est mieux lu et si cela a du sens. </p><br><h2 id="formatirovanie-lyambda-vyrazheniy">  Formatage des expressions lambda </h2><br><p>  Dans les expressions lambda, les espaces doivent être utilisés autour des accolades et autour de la flèche qui sépare les paramètres du corps.  Si un appel accepte un seul caractère lambda, il doit être utilisé en dehors des parenthèses chaque fois que possible. </p><br><pre> <code class="kotlin hljs">list.filter { it &gt; <span class="hljs-number"><span class="hljs-number">10</span></span> }</code> </pre> <br><p>  Lors de l'attribution d'une étiquette à une expression lambda, ne mettez pas d'espace entre l'étiquette et l'accolade ouvrante: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ints.forEach <span class="hljs-symbol"><span class="hljs-symbol">lit@</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre> <br><p>  Lorsque vous déclarez des noms de paramètres dans une expression lambda sur plusieurs lignes, placez les noms sur la première ligne, puis sur la flèche et sur la nouvelle ligne, le début du corps de la fonction: </p><br><pre> <code class="kotlin hljs">appendCommaSeparated(properties) { prop -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> propertyValue = prop.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(obj) <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Si la liste des paramètres ne tient pas sur une seule ligne, placez la flèche sur une ligne distincte: </p><br><pre> <code class="kotlin hljs">foo { context: Context, environment: Env -&gt; context.configureEnv(environment) }</code> </pre> <br><h1 id="oformlenie-dokumentacii">  Paperasse </h1><br><p>  Lorsque vous utilisez la documentation multiligne, mettez <code>/**</code> sur une ligne distincte et démarrez chaque ligne suivante avec un astérisque: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">/** * This is a documentation comment * on multiple lines. */</span></span></code> </pre> <br><p>  Une courte documentation peut être placée sur une seule ligne: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">/** This is a short documentation comment. */</span></span></code> </pre> <br><p>  En général, évitez d'utiliser les balises <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">param</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">return</a> .  Au lieu de cela, incluez une description des paramètres et renvoyez des valeurs directement dans le commentaire de la documentation et ajoutez des références de paramètres partout où ils sont mentionnés.  Utilisez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">param</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">return</a> uniquement lorsqu'une longue description est requise qui ne correspond pas à la signification du texte principal. </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// Avoid doing this: /** * Returns the absolute value of the given number. * @param number The number to return the absolute value for. * @return The absolute value. */ fun abs(number: Int) = ... // Do this instead: /** * Returns the absolute value of the given [number]. */ fun abs(number: Int) = ...</span></span></code> </pre> <br><h1 id="izbeganie-nenuzhnyh-konstrukciy">  Éviter les constructions inutiles </h1><br><p>  De nombreuses constructions syntaxiques dans Kotlin sont facultatives et mises en évidence par l'environnement de développement comme inutiles, vous ne devez pas les utiliser dans votre code juste pour rendre votre code «clair». </p><br><h3 id="ispolzvanie-klyuchevogo-slova-unit">  Utilisez le mot-clé Unité </h3><br><p>  Dans les fonctions, l'utilisation du mot-clé Unit ne doit pas être utilisée: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// ": Unit" is omitted here }</span></span></code> </pre> <br><h3 id="tochka-s-zapyatoy">  Point-virgule </h3><br><p>  Évitez d'utiliser un point-virgule à chaque occasion. </p><br><h3 id="strokovye-shablony">  Modèles de chaînes </h3><br><p>  N'utilisez pas d'accolades lorsque vous insérez une variable simple dans une chaîne de modèle.  Utilisez des accolades uniquement pour les expressions longues. </p><br><pre> <code class="kotlin hljs">println(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$name</span></span></span><span class="hljs-string"> has </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${children.size}</span></span></span><span class="hljs-string"> children"</span></span>)</code> </pre> <br><h1 id="idiomaticheskoe-ispolzovanie-yazykovyh-osobennostey">  Utilisation idiomatique des fonctionnalités linguistiques </h1><br><h2 id="neizmenyaemost">  Immuabilité </h2><br><p>  Il est préférable d'utiliser des données immuables avant les données mutables.  Déclarez toujours les variables et propriétés locales comme <code>val</code> , pas <code>var</code> , à moins qu'elles ne changent vraiment. </p><br><p>  Utilisez toujours des interfaces de collection immuables ( <code>Collection</code> , <code>List</code> , <code>Set</code> , <code>Map</code> ) pour déclarer les collections qui ne changent pas.  À chaque occasion, lorsque vous utilisez des méthodes d'usine pour créer une collection, utilisez une implémentation qui renvoie des collections immuables: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// Bad: use of mutable collection type for value which will not be mutated fun validateValue(actualValue: String, allowedValues: HashSet&lt;String&gt;) { ... } // Good: immutable collection type used instead fun validateValue(actualValue: String, allowedValues: Set&lt;String&gt;) { ... } // Bad: arrayListOf() returns ArrayList&lt;T&gt;, which is a mutable collection type val allowedValues = arrayListOf("a", "b", "c") // Good: listOf() returns List&lt;T&gt; val allowedValues = listOf("a", "b", "c")</span></span></code> </pre> <br><blockquote><blockquote>  :         . </blockquote><br></blockquote><br><h2 id="znachenie-parametrov-po-umolchaniyu">     </h2><br><p>             . </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// Bad fun foo() = foo("a") fun foo(a: String) { ... } // Good fun foo(a: String = "a") { ... }</span></span></code> </pre> <br><h2 id="sozdanie-psevdonimov-type-alias">   [Type alias] </h2><br><p>           ,      ,     : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> MouseClickHandler = (Any, MouseEvent) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> PersonIndex = Map&lt;String, Person&gt;</code> </pre> <br><h2 id="imenovanie-parametrov-v-lyambda-vyrazheniyah">    - </h2><br><p>  -,      ,    <code>it</code>     .   -       . </p><br><h2 id="vozvraschenie-znacheniy-iz-lyambda-vyrazheniy">    - </h2><br><p>        .    -  ,      .      ,    -   . </p><br><p>    ( <code>@</code> )     . </p><br><h2 id="vyzov-metodov-s-imenovaniem-argumentov">      </h2><br><p>    ,           ,     <code>boolean</code> ,         . </p><br><pre> <code class="kotlin hljs">drawSquare(x = <span class="hljs-number"><span class="hljs-number">10</span></span>, y = <span class="hljs-number"><span class="hljs-number">10</span></span>, width = <span class="hljs-number"><span class="hljs-number">100</span></span>, height = <span class="hljs-number"><span class="hljs-number">100</span></span>, fill = <span class="hljs-literal"><span class="hljs-literal">true</span></span>)</code> </pre> <br><h2 id="pravila-dlya-upravlyayuschih-konstrukciy-s-usloviyami">       </h2><br><p>     <code>try</code> , <code>if</code>  <code>when</code> ,       <code>return</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x) foo() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> bar() <span class="hljs-comment"><span class="hljs-comment">//   ,    if (x) return foo() else return bar() // return when(x) { 0 -&gt; "zero" else -&gt; "nonzero" } //   ,    when(x) { 0 -&gt; return "zero" else -&gt; return "nonzero" }</span></span></code> </pre> <br><h2 id="if-protiv-when"> <code>if</code>  <code>when</code> </h2><br><p>   <code>if</code>       <code>when</code> </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (x) { <span class="hljs-literal"><span class="hljs-literal">null</span></span> -&gt; ... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; ... } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ... <span class="hljs-comment"><span class="hljs-comment">//     </span></span></code> </pre> <br><p>      ,   <code>when</code> . </p><br><h2 id="ispolzovanie-znacheniy-boolean-v-uslovnyh-operatorah">   Boolean?    </h2><br><p>    <code>Boolean?</code>    ,       <code>if (value == true)</code>  <code>if (value == false)</code> ,    <code>if (value ?: false)</code>  <code>if (value != null &amp;&amp; value)</code> . </p><br><h2 id="ispolzovanie-ciklov">   </h2><br><p>       <code>filtet</code> , <code>map</code>  ..  . : <code>forEach</code> (    <code>for</code>     null  <code>forEach</code>     ) </p><br><p>     ,    ,         ,        . </p><br><h2 id="cikly-dlya-diapazonov">    </h2><br><p>  <code>until</code>     ( ): </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..n - <span class="hljs-number"><span class="hljs-number">1</span></span>) { ... } <span class="hljs-comment"><span class="hljs-comment">// bad for (i in 0 until n) { ... } // good</span></span></code> </pre> <br><h2 id="formatirovanie-strok">   </h2><br><p>       . </p><br><p>   <code>\n</code> escape-        . </p><br><p>      ,  <code>trimIndent</code> ,       ,  <code>trimMargin</code> ,    : </p><br><pre> <code class="kotlin hljs">assertEquals( <span class="hljs-string"><span class="hljs-string">""" Foo Bar """</span></span>.trimIndent(), value ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-string"><span class="hljs-string">"""if(a &gt; 1) { | return a |}"""</span></span>.trimMargin()</code> </pre> <br><h2 id="funkcii-protiv-svoystv">    </h2><br><p>              .    ,      ,    . </p><br><p>      : </p><br><ul><li>    </li><li>   (    ) </li><li>       ,      </li></ul><br><h2 id="ispolzovanie-funkciy-rasshireniy">    </h2><br><p>      .  ,     ,     ,      ,      .    API,     ,   .      ,           . </p><br><h2 id="ispolzovanie-infiksnyh-funkciy">    </h2><br><p>    <code>infix</code> ,       ,   .  : <code>and</code> , <code>to</code> , <code>zip</code> .  : <code>add</code> . </p><br><p>     <code>infix</code> ,     . </p><br><h2 id="funkcii-fabriki">   </h2><br><p>      ,       ,    .    ,   ,      .      ,     ,   . </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: <span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> y: <span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromPolar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(angle: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Double</span></span></span></span><span class="hljs-function"><span class="hljs-params">, radius: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Double</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = Point(...) } }</code> </pre> <br><p>       ,                   ,      . </p><br><h2 id="platformennye-tipy">   </h2><br><blockquote><blockquote>  :  ,       ,    Kotlin     <code>null</code> ,    <code>null</code> </blockquote><br></blockquote><p> <code>public</code> /,    ,     Kotlin: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apiCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: String = MyJavaApi.getProperty(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)</code> </pre> <br><p>   (package-level  class-level)          Kotlin: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String = MyJavaApi.getProperty(<span class="hljs-string"><span class="hljs-string">"name"</span></span>) }</code> </pre> <br><p>  ,    ,      Kotlin : </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name = MyJavaApi.getProperty(<span class="hljs-string"><span class="hljs-string">"name"</span></span>) println(name) }</code> </pre> <br><h2 id="ispolzovanie-funkciy-applywithrunalsolet">   <code>apply</code> / <code>with</code> / <code>run</code> / <code>also</code> / <code>let</code> </h2><br><p> Kotlin           .    ,  : </p><br><ul><li>               ?   ,    ,          <code>it</code> ,    <code>this</code> ( <code>also</code>  <code>let</code> ).  <code>also</code> ,       . </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// Context object is 'it' class Baz { var currentBar: Bar? val observable: Observable val foo = createBar().also { currentBar = it // Accessing property of Baz observable.registerCallback(it) // Passing context object as argument } } // Receiver not used in the block val foo = createBar().also { LOG.info("Bar created") } // Context object is 'this' class Baz { val foo: Bar = createBar().apply { color = RED // Accessing only properties of Bar text = "Foo" } }</span></span></code> </pre> <br><ul><li>     ?      ,  <code>apply</code>  <code>also</code> .       ,  <code>with</code> , <code>let</code>  <code>run</code> . </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// Return value is context object class Baz { val foo: Bar = createBar().apply { color = RED // Accessing only properties of Bar text = "Foo" } } // Return value is block result class Baz { val foo: Bar = createNetworkConnection().let { loadBar() } }</span></span></code> </pre> <br><ul><li>     null      ?   ,  <code>apply</code> , <code>let</code>  <code>run</code> .   ,  <code>with</code>  <code>also</code> . </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// Context object is nullable person.email?.let { sendEmail(it) } // Context object is non-null and accessible directly with(person) { println("First name: $firstName, last name: $lastName") }</span></span></code> </pre> <br><h1 id="pravila-pri-sozdanii-bibliotek">     </h1><br><p>            API: </p><br><ul><li>      (        API) </li><li>           (         ) </li><li>   KDoc   public api,   ,         / </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr431990/">https://habr.com/ru/post/fr431990/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr431978/index.html">Promotion de la boutique en ligne: ce qui devra être corrigé</a></li>
<li><a href="../fr431982/index.html">Digerati, Hakerazzi et Cholesterol dans les données: à propos de l'argot informatique</a></li>
<li><a href="../fr431984/index.html">Interface de génération de client basée sur la base de données Golang</a></li>
<li><a href="../fr431986/index.html">Histoire de Fuck Up: comment j'ai été déçu par les services numériques pour les entreprises et que j'avais ma propre entreprise (enfin, presque)</a></li>
<li><a href="../fr431988/index.html">Quand le théorème est devenu un axiome: ONYX BOOX Euclid review</a></li>
<li><a href="../fr431992/index.html">Biométrie: comment ça se passe avec nous et avec eux</a></li>
<li><a href="../fr431994/index.html">Discussion sur la licence PVS-Studio gratuite pour les projets hébergés sur GitHub</a></li>
<li><a href="../fr431996/index.html">Smart Engines Science Corporate (ou comment nous avons conduit à ICMV 2018)</a></li>
<li><a href="../fr431998/index.html">Rencontrez Yandex.Phone - maintenant officiellement</a></li>
<li><a href="../fr432002/index.html">Microsoft développe un navigateur basé sur Chromium, qui sera livré par défaut à la place d'Edge</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>