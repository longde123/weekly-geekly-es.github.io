<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘µğŸ» ğŸŒ‹ ğŸ¤´ğŸ» Operasi Perbandingan di C ++ 20 ğŸ‘¨ğŸ¼â€âš–ï¸ ğŸ” ğŸ–±ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pertemuan di Cologne telah berlalu, standar C ++ 20 telah direduksi menjadi lebih atau kurang jadi (setidaknya sampai munculnya catatan khusus), dan s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Operasi Perbandingan di C ++ 20</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/465575/">  Pertemuan di Cologne telah berlalu, standar C ++ 20 telah direduksi menjadi lebih atau kurang jadi (setidaknya sampai munculnya catatan khusus), dan saya ingin berbicara tentang salah satu inovasi yang akan datang.  Ini adalah mekanisme yang biasanya disebut <i>operator &lt;=&gt;</i> (standar mendefinisikannya sebagai "operator perbandingan tiga arah", tetapi memiliki julukan informal "pesawat ruang angkasa"), tetapi saya percaya bahwa cakupannya jauh lebih luas. <br><br>  Kami tidak hanya akan memiliki operator baru - semantik perbandingan akan mengalami perubahan signifikan pada tingkat bahasa itu sendiri. <br><a name="habracut"></a><br>  Bahkan jika Anda tidak dapat mengeluarkan hal lain dari artikel ini, ingatlah tabel ini: <br><div class="scrollable-table"><table><tbody><tr><td></td><td>  <b>Kesetaraan</b> <br></td><td>  <b>Merampingkan</b> <br></td></tr><tr><td>  <b>Dasar</b> <br></td><td>  <i>==</i> <br></td><td>  <i>&lt;=&gt;</i> <br></td></tr><tr><td>  <b>Derivatif</b> <br></td><td>  <i>! =</i> <br></td><td>  <i>&lt;</i> , <i>&gt;</i> , <i>&lt;=</i> , <i>&gt; =</i> <br></td></tr></tbody></table></div><br>  Sekarang kita akan memiliki operator baru, <i>&lt;=&gt;</i> , tetapi, yang lebih penting, operator sekarang sistematis.  Ada operator dasar dan ada operator turunan - setiap grup memiliki kemampuannya sendiri. <br><br>  Kami akan berbicara tentang fitur-fitur ini secara singkat dalam pendahuluan dan mempertimbangkan lebih detail di bagian berikut. <br><br>  Operator dasar dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>dibalik</b></a> (mis. Ditulis ulang dengan urutan parameter terbalik).  Pernyataan yang diturunkan dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>ditulis ulang</b></a> melalui pernyataan dasar yang sesuai.  Baik kandidat yang dikonversi atau ditulis ulang tidak menghasilkan fungsi baru, mereka hanya penggantian pada tingkat kode sumber dan dipilih dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>serangkaian kandidat yang diperluas</b></a> .  Sebagai contoh, ekspresi <i>a &lt;9</i> sekarang dapat dievaluasi sebagai <i>operator. &lt;=&gt; (9) &lt;0</i> , dan ekspresi <i>10! = B</i> sebagai <i>! Operator == (b, 10)</i> .  Ini berarti bahwa akan dimungkinkan untuk membuang satu atau dua operator di mana, untuk mencapai perilaku yang sama, sekarang diperlukan untuk menulis 2, 4, 6, atau bahkan 12 operator secara manual.  Gambaran <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">singkat</a> dari aturan akan disajikan di bawah ini bersama dengan tabel dari semua transformasi yang mungkin. <br><br>  Baik operator dasar dan derivatif dapat didefinisikan sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>standar</b></a> .  Dalam hal operator dasar, ini berarti bahwa operator akan diterapkan pada setiap anggota dalam urutan deklarasi;  dalam hal operator turunan, kandidat yang ditulis ulang akan digunakan. <br><br>  Perlu dicatat bahwa tidak ada transformasi semacam itu di mana operator dari satu jenis (mis., Kesetaraan atau pemesanan) dapat dinyatakan dalam istilah operator dari jenis lain.  Dengan kata lain, kolom dalam tabel kami sama sekali tidak bergantung satu sama lain.  Ekspresi <i>a == b</i> tidak akan pernah dievaluasi sebagai <i>operator &lt;=&gt;</i> <i>(a, b) == 0</i> secara implisit (tapi, tentu saja, tidak ada yang menghalangi Anda untuk mendefinisikan <i>operator</i> Anda <i>==</i> menggunakan <i>operator &lt;=&gt;</i> jika Anda mau). <br><br>  Pertimbangkan contoh kecil di mana kami menunjukkan bagaimana kode terlihat sebelum dan sesudah menerapkan fungsi baru.  Kita akan menulis tipe string yang tidak case-sensitive, <i>CIString</i> , yang objeknya dapat dibandingkan satu sama lain dan dengan <i>char const *</i> . <br><br>  Dalam C ++ 17, untuk tugas kita, kita perlu menulis 18 fungsi perbandingan: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CIString</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> assize() == bssize() &amp;&amp; ci_compare(asc_str(), bsc_str()) == <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt; (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ci_compare(asc_str(), bsc_str()) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(a == b); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt; (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b &lt; a; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(a &lt; b); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(b &lt; a); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ci_compare(asc_str(), b) == <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt; (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ci_compare(asc_str(), b) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(a == b); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt; (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b &lt; a; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(a &lt; b); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(b &lt; a); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ci_compare(a, bsc_str()) == <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt; (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ci_compare(a, bsc_str()) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(a == b); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt; (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b &lt; a; } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(a &lt; b); } <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(b &lt; a); } };</code> </pre> <br>  Di C ++ 20, Anda dapat melakukan hanya 4 fungsi: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CIString</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.size() == bssize() &amp;&amp; ci_compare(s.c_str(), bsc_str()) == <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::weak_ordering <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CIString&amp; b) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ci_compare(s.c_str(), bsc_str()) &lt;=&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* b) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ci_compare(s.c_str(), b) == <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::weak_ordering <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* b) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ci_compare(s.c_str(), b) &lt;=&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } };</code> </pre> <br>  Saya akan memberi tahu Anda apa artinya semua ini, secara lebih rinci, tetapi pertama-tama, mari kembali sedikit dan ingat bagaimana perbandingan bekerja hingga standar C ++ 20. <br><br><h2>  Perbandingan dalam Standar dari C ++ 98 ke C ++ 17 </h2><br>  Operasi perbandingan tidak banyak berubah sejak penciptaan bahasa.  Kami memiliki enam operator: <i>== ,!</i> <i>=</i> , <i>&lt;</i> , <i>&gt;</i> , <i>&lt;=</i> Dan <i>&gt; =</i> .  Standar mendefinisikan masing-masing untuk tipe bawaan, tetapi secara umum mereka mematuhi aturan yang sama.  Ketika mengevaluasi ekspresi <i>a @ b</i> (di mana <i>@</i> adalah salah satu dari enam operator perbandingan), kompiler mencari fungsi anggota, fungsi bebas, dan kandidat bawaan bernama <i>operator @</i> , yang dapat dipanggil dengan tipe <i>A</i> atau <i>B</i> dalam urutan yang ditentukan.  Kandidat yang paling cocok dipilih dari mereka.  Itu saja.  Faktanya, <i>semua</i> operator bekerja dengan cara yang sama: operasi <i>&lt;</i> tidak berbeda dari <i>&lt;&lt;</i> . <br><br>  Sekumpulan aturan sederhana seperti itu mudah dipelajari.  Semua operator benar-benar independen dan setara.  Tidak masalah apa yang kita manusia ketahui tentang hubungan mendasar antara <i>==</i> dan <i>! =</i> Operasi.  Dari segi bahasa, ini satu dan sama.  Kami menggunakan idiom.  Sebagai contoh, kami mendefinisikan operator <i>! =</i> Melalui <i>==</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;, A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; lhs, A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(lhs == rhs); }</code> </pre> <br>  Demikian pula, melalui operator <i>&lt;</i> kami mendefinisikan semua operator hubungan lainnya.  Kami menggunakan idiom-idiom ini karena, terlepas dari aturan bahasa, kami tidak benar-benar menganggap keenam operator itu setara.  Kami menerima bahwa keduanya adalah dasar ( <i>==</i> dan <i>&lt;</i> ), dan melaluinya semua yang lain sudah dinyatakan. <br><br>  Bahkan, Perpustakaan Templat Standar dibangun sepenuhnya di atas dua operator ini, dan sejumlah besar tipe dalam kode yang dieksploitasi mengandung definisi hanya satu dari mereka atau keduanya. <br><br>  Namun, operator <i>&lt;</i> sangat tidak cocok untuk peran dasar karena dua alasan. <br><br>  Pertama, operator hubungan lainnya tidak dapat dijamin untuk mengekspresikannya.  Ya, <i>a&gt; b</i> berarti persis sama dengan <i>b &lt;a</i> , tetapi tidak benar bahwa <i>a &lt;= b</i> berarti persis sama dengan <i>! (B &lt;a)</i> .  Dua ungkapan terakhir akan setara jika ada properti trikotomi, di mana untuk dua nilai apa pun hanya satu dari tiga pernyataan yang benar: <i>a &lt;b</i> , <i>a == b</i> atau <i>a&gt; b</i> .  Jika ada trikotomi, ekspresi <i>a &lt;= b</i> berarti kita berurusan dengan kasus pertama atau kedua ... dan ini setara dengan pernyataan bahwa kita tidak berurusan dengan kasus ketiga.  Karenanya <i>(a &lt;= b) ==! (A&gt; b) ==! (B &lt;a)</i> . <br><br>  Tetapi bagaimana jika sikap tersebut tidak memiliki properti trikotomi?  Ini adalah karakteristik dari hubungan urutan parsial.  Contoh klasik adalah angka floating point yang salah satu dari operasi <i>1.f &lt;NaN</i> , <i>1.f == NaN</i> dan <i>1.f&gt; NaN</i> memberikan <i>false</i> .  Oleh karena itu, <i>1.f &lt;= NaN</i> juga memberikan <i>kebohongan</i> , tetapi pada saat yang sama <i>! (NaN &lt;1.f)</i> <i>benar</i> . <br><br>  Satu-satunya cara untuk mengimplementasikan operator <i>&lt;=</i> secara umum melalui operator dasar adalah mengecat kedua operasi sebagai <i>(a == b) ||</i>  <i>(a &lt;b)</i> , yang merupakan langkah besar ke belakang jika kita <i>masih</i> harus berurusan dengan urutan linier, sejak saat itu tidak satu fungsi akan dipanggil, tetapi dua (misalnya, ungkapan <i>â€œabc..xyz9â€ &lt;= â€œabc ..xyz1 "</i> harus ditulis ulang sebagai <i>(" abc..xyz9 "==" abc..xyz1 ") || (" abc..xyz9 "&lt;" abc..xyz1 ")</i> dan dua kali untuk membandingkan seluruh baris). <br><br>  Kedua, operator <i>&lt;sangat</i> tidak cocok untuk peran dasar karena kekhasan penggunaannya dalam perbandingan leksikografis.  Pemrogram sering membuat kesalahan ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> T t; U u; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t == rhs.t &amp;&amp; u == rhs.u; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt; (A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t &lt; rhs.t &amp;&amp; u &lt; rhs.u; } };</code> </pre> <br>  Untuk menentukan operator == untuk kumpulan elemen, cukup untuk menerapkan <i>==</i> ke setiap anggota sekali, tetapi ini tidak akan berfungsi dengan <i>&lt;</i> operator.  Dari sudut pandang implementasi ini, himpunan <i>A {1, 2}</i> dan <i>A {2, 1}</i> akan dianggap setara (karena tidak ada yang lebih rendah dari yang lain).  Untuk memperbaikinya, terapkan operator <i>&lt;</i> dua kali untuk setiap anggota kecuali yang terakhir: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt; (A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &lt; rhs.t) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rhs.t &lt; t) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> u &lt; rhs.u; }</code> </pre> <br>  Akhirnya, untuk menjamin operasi yang benar dari perbandingan objek heterogen - yaitu  untuk memastikan bahwa ekspresi <i>a == 10</i> dan <i>10 == a</i> berarti hal yang sama - mereka biasanya merekomendasikan penulisan perbandingan sebagai fungsi bebas.  Bahkan, ini biasanya satu-satunya cara untuk menerapkan perbandingan seperti itu.  Ini tidak nyaman karena, pertama, Anda harus memantau kepatuhan dengan rekomendasi ini, dan kedua, Anda biasanya harus mendeklarasikan fungsi-fungsi seperti itu sebagai teman tersembunyi untuk implementasi yang lebih nyaman (mis. Di dalam tubuh kelas). <br><br>  Perhatikan bahwa ketika membandingkan objek dari tipe yang berbeda tidak selalu perlu untuk menulis <i>operator == (X, int)</i> ;  mereka juga bisa berarti kasus di mana <i>int</i> dapat dilemparkan ke <i>X</i> secara implisit. <br><br>  Mari kita meringkas aturan dengan standar C ++ 20: <br><br><ul><li>  Semua pernyataan ditangani dengan cara yang sama. </li><li>  Kami menggunakan idiom untuk memfasilitasi implementasi.  Operator <i>==</i> dan <i>&lt;</i> kami menggunakan idiom dasar dan mengekspresikan operator hubungan yang tersisa melalui mereka. </li><li>  Itu hanya operator <i>&lt;sangat</i> tidak cocok untuk peran pangkalan. </li><li>  Penting (dan disarankan) untuk menulis perbandingan objek heterogen sebagai fungsi bebas. </li></ul><br><h2>  Operator pemesanan dasar baru: &lt;=&gt; </h2><br>  Perubahan paling signifikan dan nyata dalam pekerjaan perbandingan di C ++ 20 adalah penambahan operator baru - <i>operator &lt;=&gt;</i> , operator perbandingan tiga arah. <br><br>  Kita sudah terbiasa dengan perbandingan tiga arah dengan fungsi <i>memcmp</i> / <i>strcmp</i> di C dan <i>basic_string :: compare ()</i> di C ++.  Mereka semua mengembalikan nilai tipe <i>int</i> , yang diwakili oleh angka positif arbitrer jika argumen pertama lebih besar dari yang kedua, <i>0</i> jika mereka sama, dan angka negatif arbitrer sebaliknya. <br><br>  Operator "pesawat ruang angkasa" tidak mengembalikan nilai <i>int</i> , tetapi objek milik salah satu kategori perbandingan, yang nilainya mencerminkan jenis hubungan antara objek yang dibandingkan.  Ada tiga kategori utama: <br><br><ul><li>  <i>strong_ordering</i> : hubungan urutan linier di mana kesetaraan menyiratkan pertukaran elemen (mis. <i>(a &lt;=&gt; b) == strong_ordering :: equal</i> menyiratkan bahwa <i>f (a) == f (b)</i> berlaku untuk semua fungsi yang sesuai <i>f</i> Istilah "fungsi yang sesuai" sengaja tidak diberikan definisi yang jelas, tetapi ini tidak termasuk fungsi yang mengembalikan alamat argumen mereka atau <i>kapasitas () dari</i> vektor, dll. Kami hanya tertarik pada properti "esensial", yang juga sangat kabur, tetapi memungkinkan secara kondisional. menganggap bahwa kita berbicara tentang <i>nilai</i> tipe. Nilai vektor terkandung di dalamnya  m elemen, tetapi bukan alamatnya, dll.).  Kategori ini mencakup nilai-nilai berikut: <i>strong_ordering :: lebih besar</i> , <i>strong_ordering :: sama</i> dan <i>kuat_ordering :: kurang</i> . </li><li>  <i>lemah_ordering</i> : hubungan urutan linier di mana kesetaraan hanya mendefinisikan kelas ekivalen tertentu.  Contoh klasiknya adalah perbandingan string tidak peka huruf besar-kecil, ketika dua objek bisa menjadi <i>lemah_ordering :: setara</i> , tetapi tidak sepenuhnya sama (ini menjelaskan penggantian kata <i>sama</i> dengan <i>setara</i> dalam nama nilai). </li><li>  <i>partial_ordering</i> : relasi urutan parsial.  Dalam kategori ini, satu nilai lagi ditambahkan ke nilai-nilai yang <i>lebih besar</i> , <i>setara,</i> dan <i>kurang</i> (seperti pada <i>lemah_ordering</i> ) - <i>tidak teratur</i> ("tidak teratur").  Ini dapat digunakan untuk mengekspresikan hubungan urutan parsial dalam sistem tipe: <i>1.f &lt;=&gt; NaN</i> memberikan nilai <i>partial_ordering :: unordered</i> . </li></ul><br>  Anda terutama akan bekerja dengan kategori <i>strong_ordering</i> ;  Ini juga merupakan kategori optimal untuk digunakan secara default.  Sebagai contoh, <i>2 &lt;=&gt; 4</i> mengembalikan <i>strong_ordering :: kurang</i> , dan <i>3 &lt;=&gt; -1</i> <i>mengembalikan strong_ordering :: lebih besar</i> . <br><br>  Kategori-kategori dari tatanan yang lebih tinggi dapat secara implisit direduksi menjadi kategori-kategori dengan tatanan yang lebih lemah (mis., <i>Strong_ordering</i> dapat direduksikan menjadi <i>lemah_ordering</i> ).  Dalam kasus ini, tipe hubungan saat ini dipertahankan (mis., <i>Strong_ordering :: equal</i> berubah menjadi <i>lemah_ordering :: setara</i> ). <br><br>  Nilai-nilai kategori perbandingan dapat dibandingkan dengan literal <i>0</i> (tidak dengan <i>int</i> apa pun dan tidak dengan <i>int</i> sama dengan <i>0</i> , tetapi hanya dengan literal <i>0</i> ) menggunakan salah satu dari enam operator perbandingan: <br><br><pre> <code class="cpp hljs">strong_ordering::less &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-comment"><span class="hljs-comment">// true strong_ordering::less == 0 // false strong_ordering::less != 0 // true strong_ordering::greater &gt;= 0 // true partial_ordering::less &lt; 0 // true partial_ordering::greater &gt; 0 // true // unordered -  ,   //       partial_ordering::unordered &lt; 0 // false partial_ordering::unordered == 0 // false partial_ordering::unordered &gt; 0 // false</span></span></code> </pre> <br>  Berkat perbandingan dengan <i>0</i> literal kita dapat mengimplementasikan operator relasi: <i>a @ b</i> setara dengan <i>(a &lt;=&gt; b) @ 0</i> untuk masing-masing operator ini. <br><br>  Sebagai contoh, <i>2 &lt;4</i> dapat dihitung sebagai <i>(2 &lt;=&gt; 4) &lt;0</i> , yang berubah menjadi <i>strong_ordering :: less &lt;0</i> dan memberikan nilai <i>true</i> . <br><br>  Operator <i>&lt;=&gt;</i> cocok dengan peran elemen dasar jauh lebih baik daripada operator <i>&lt;</i> , karena ia menghilangkan kedua masalah yang terakhir. <br><br>  Pertama, ekspresi <i>a &lt;= b</i> dijamin setara dengan <i>(a &lt;=&gt; b) &lt;= 0</i> bahkan dengan pemesanan parsial.  Untuk dua nilai tidak berurutan, <i>a &lt;=&gt; b</i> akan memberikan nilai <i>partial_ordered :: unordered</i> , dan <i>partial_ordered :: unordered &lt;= 0</i> akan memberikan <i>false</i> , yang merupakan apa yang kita butuhkan.  Ini dimungkinkan karena <i>&lt;=&gt;</i> dapat mengembalikan lebih banyak varietas nilai: misalnya, kategori <i>partial_ordering</i> berisi empat nilai yang mungkin.  Nilai tipe <i>bool</i> hanya bisa <i>benar</i> atau <i>salah</i> , jadi sebelum kita tidak bisa membedakan antara perbandingan nilai yang dipesan dan yang tidak teratur. <br><br>  Untuk kejelasan, pertimbangkan contoh hubungan urutan parsial yang tidak terkait dengan angka floating point.  Misalkan kita ingin menambahkan status NaN ke tipe <i>int</i> , di mana NaN hanyalah nilai yang tidak membentuk pasangan yang dipesan dengan nilai apa pun yang terlibat.  Anda dapat melakukan ini menggunakan <i>std :: opsional</i> untuk menyimpannya: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntNan</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; val = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::nullopt; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(IntNan <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!val || !rhs.val) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *val == *rhs.val; } partial_ordering <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(IntNan <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!val || !rhs.val) { <span class="hljs-comment"><span class="hljs-comment">//  unordered   //     return partial_ordering::unordered; } // &lt;=&gt;   strong_ordering  int, //        partial_ordering return *val &lt;=&gt; *rhs.val; } }; IntNan{2} &lt;=&gt; IntNan{4}; // partial_ordering::less IntNan{2} &lt;=&gt; IntNan{}; // partial_ordering::unordered //     .    IntNan{2} &lt; IntNan{4}; // true IntNan{2} &lt; IntNan{}; // false IntNan{2} == IntNan{}; // false IntNan{2} &lt;= IntNan{}; // false</span></span></code> </pre> <br>  Operator <i>&lt;=</i> mengembalikan nilai yang benar karena sekarang kita dapat mengekspresikan lebih banyak informasi pada level bahasa itu sendiri. <br><br>  Kedua, untuk mendapatkan semua informasi yang diperlukan, cukup menerapkan <i>&lt;=&gt;</i> sekali, yang memfasilitasi penerapan perbandingan leksikografis: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> T t; U u; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t == rhs.t &amp;&amp; u == rhs.u; } strong_ordering <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    //  t.   != 0 (..  t // ),    //   if (auto c = t &lt;=&gt; rhs.t; c != 0) return c; //     //    return u &lt;=&gt; rhs.u; };</span></span></code> </pre> <br>  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">P0515</a> , kalimat asli untuk menambahkan <i>operator &lt;=&gt;, untuk</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diskusi yang</a> lebih rinci <i>.</i> <br><br><h2>  Fitur operator baru </h2><br>  Kami tidak hanya mendapatkan operator baru.  Pada akhirnya, jika contoh yang ditunjukkan di atas dengan deklarasi struktur <i>A</i> hanya mengatakan bahwa alih-alih <i>x &lt;y kita</i> sekarang harus menulis <i>(x &lt;=&gt; y) &lt;0</i> setiap kali, tidak ada yang akan menyukainya. <br><br>  Mekanisme untuk menyelesaikan perbandingan dalam C ++ 20 berbeda nyata dari pendekatan lama, tetapi perubahan ini terkait langsung dengan konsep baru dua operator perbandingan dasar: <i>==</i> dan <i>&lt;=&gt;</i> .  Jika sebelumnya itu adalah idiom (merekam melalui <i>==</i> dan <i>&lt;</i> ), yang kami gunakan, tetapi yang tidak diketahui oleh kompiler, sekarang ia akan memahami perbedaan ini. <br><br>  Sekali lagi, saya akan memberikan tabel yang sudah Anda lihat di awal artikel: <br><div class="scrollable-table"><table><tbody><tr><td></td><td>  <b>Kesetaraan</b> <br></td><td>  <b>Merampingkan</b> <br></td></tr><tr><td>  <b>Dasar</b> <br></td><td>  <i>==</i> <br></td><td>  <i>&lt;=&gt;</i> <br></td></tr><tr><td>  <b>Derivatif</b> <br></td><td>  <i>! =</i> <br></td><td>  <i>&lt;</i> , <i>&gt;</i> , <i>&lt;=</i> , <i>&gt; =</i> <br></td></tr></tbody></table></div><br>  Setiap operator dasar dan turunan menerima kemampuan baru, yang akan saya ucapkan beberapa kata lebih lanjut. <br><br><h3>  Pembalikan operator dasar </h3><br>  Sebagai contoh, ambil tipe yang hanya bisa dibandingkan dengan <i>int</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i == j; } };</code> </pre> <br>  Dari sudut pandang aturan lama, tidak mengherankan bahwa ungkapan <i>a == 10</i> berfungsi dan dievaluasi menjadi <i>a.operator == (10)</i> . <br><br>  Tetapi bagaimana dengan <i>10 == a</i> ?  Dalam C ++ 17, ungkapan ini akan dianggap sebagai kesalahan sintaksis yang jelas.  Tidak ada operator seperti itu.  Agar kode tersebut dapat berfungsi, Anda harus menulis <i>operator</i> simetris <i>==</i> , yang pertama-tama akan mengambil nilai <i>int</i> , dan kemudian <i>A</i> ... dan untuk mengimplementasikannya harus dalam bentuk fungsi bebas. <br><br>  Dalam C ++ 20, operator dasar dapat dibalik.  Untuk <i>10 == a,</i> kompiler akan menemukan kandidat <i>operator == (A, int)</i> (sebenarnya, ini adalah fungsi anggota, tetapi untuk kejelasan, saya menuliskannya di sini sebagai fungsi bebas), dan kemudian tambahan - varian dengan urutan parameter terbalik, yaitu. .  <i>operator == (int, A)</i> .  Kandidat kedua ini bertepatan dengan ekspresi kami (dan idealnya), jadi kami akan memilihnya.  Ekspresi <i>10 == a</i> dalam C ++ 20 dievaluasi sebagai <i>a.operator == (10)</i> .  Kompiler memahami bahwa kesetaraan adalah simetris. <br><br>  Sekarang kami akan memperluas jenis kami sehingga dapat dibandingkan dengan <i>int</i> tidak hanya melalui operator kesetaraan, tetapi juga melalui operator pemesanan: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i == j; } strong_ordering <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i &lt;=&gt; j; } };</code> </pre> <br>  Sekali lagi, ekspresi <i>a &lt;=&gt; 42</i> berfungsi dengan baik dan dihitung sesuai dengan aturan lama sebagai <i>operator. &lt;=&gt; (42)</i> , tetapi <i>42 &lt;=&gt;</i> a akan salah dari sudut pandang C ++ 17, bahkan jika operator <i>&lt; =&gt;</i> sudah ada dalam bahasa.  Tetapi dalam C ++ 20, <i>operator &lt;=&gt;</i> , seperti <i>operator ==</i> , simetris: ia mengenali kandidat yang terbalik.  Untuk <i>42 &lt;=&gt;</i> a, <i>operator</i> fungsi anggota <i>&lt;=&gt;</i> <i>(A, int)</i> akan ditemukan (sekali lagi, saya menulisnya di sini sebagai fungsi bebas hanya untuk kejelasan yang lebih besar), serta <i>operator</i> kandidat sintetis <i>&lt;=&gt;</i> <i>(int, A)</i> .  Versi terbalik ini sama persis dengan ekspresi kami - kami memilihnya. <br><br>  Namun, <i>42 &lt;=&gt;</i> <i>a</i> TIDAK dihitung sebagai <i>operator.</i> <i>&lt;=&gt;</i> <i>(42)</i> .  Itu salah.  Ungkapan ini dievaluasi menjadi <i>0 &lt;=&gt; a.operator &lt;=&gt; (42)</i> .  Coba cari tahu mengapa entri ini benar. <br><br>  Penting untuk dicatat bahwa kompiler tidak membuat fungsi baru.  Ketika menghitung <i>10 == a</i> , operator <i>operator baru == (int, A)</i> tidak muncul, dan ketika menghitung <i>42 &lt;=&gt; a</i> , <i>operator</i> <i>&lt;=&gt;</i> <i>(int, A)</i> tidak muncul.  Hanya dua ekspresi yang ditulis ulang melalui kandidat yang terbalik.  Saya ulangi: tidak ada fungsi baru yang dibuat. <br><br>  Juga perhatikan bahwa catatan dengan urutan parameter terbalik hanya tersedia untuk operator dasar, tetapi untuk turunannya tidak.  Itu adalah: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; }; b != <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ok   C++17,   C++20 42 != b; //    C++17,   C++20</span></span></code> </pre> <br><h3>  Penulisan Ulang Operator Turunan </h3><br>  Mari kita kembali ke contoh kita dengan struktur <i>A</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i == j; } strong_ordering <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i &lt;=&gt; j; } };</code> </pre> <br>  Ambil ungkapan <i>a! = 17</i> .  Dalam C ++ 17, ini adalah kesalahan sintaksis karena <i>operator! =</i> Operator tidak ada.  Namun, dalam C ++ 20, untuk ekspresi yang mengandung operator perbandingan turunan, kompiler juga akan mencari operator dasar yang sesuai dan mengekspresikan perbandingan turunan melalui mereka. <br><br>  Kita tahu bahwa dalam matematika, operasinya <i>! = Pada</i> dasarnya berarti TIDAK <i>==</i> .  Sekarang ini diketahui oleh kompiler.  Untuk ungkapan <i>a! = 17,</i> ia tidak hanya akan mencari <i>operator! = Operator</i> , tetapi juga <i>operator ==</i> (dan, seperti dalam contoh sebelumnya, <i>operator</i> terbalik <i>==</i> ).  Untuk contoh ini, kami menemukan operator kesetaraan yang hampir cocok untuk kami - kami hanya perlu menulis ulang sesuai dengan semantik yang diinginkan: <i>a! = 17</i> akan dihitung sebagai <i>! (A == 17)</i> . <br><br>  Demikian pula, <i>17! =</i> A dihitung sebagai <i>! A.operator == (17)</i> , yang merupakan versi ditulis ulang dan versi terbalik. <br><br>  Transformasi serupa juga dilakukan untuk memesan operator.  Jika kami menulis <i>&lt;9</i> , kami akan mencoba (tidak berhasil) untuk menemukan <i>operator &lt;</i> , dan juga mempertimbangkan kandidat dasar: <i>operator &lt;=&gt;</i> .  Penggantian yang sesuai untuk operator relasi terlihat seperti ini: <i>a @ b</i> (di mana <i>@</i> adalah salah satu operator relasi) dihitung sebagai <i>(a &lt;=&gt; b) @ 0</i> .  Dalam kasus kami, <i>a.operator &lt;=&gt; (9) &lt;0</i> .  Demikian pula, <i>9 &lt;= a</i> dihitung sebagai <i>0 &lt;= a.operator &lt;=&gt; (9)</i> . <br><br>  Perhatikan bahwa, seperti dalam kasus panggilan, kompiler tidak membuat fungsi baru untuk kandidat yang ditulis ulang.  Mereka hanya dihitung secara berbeda, dan semua transformasi dilakukan hanya pada tingkat kode sumber. <br><br>  Di atas membawa saya ke saran berikut: <br><br>  <b><i>HANYA OPERATOR DASAR</i></b> <i>: Tetapkan hanya operator dasar (== dan &lt;=&gt;) dalam jenis Anda.</i> <br><br>  Karena operator dasar memberikan seluruh rangkaian perbandingan, cukup untuk mendefinisikannya saja.  Ini berarti bahwa Anda hanya perlu 2 operator untuk membandingkan objek dari tipe yang sama (bukan 6, seperti yang sekarang) dan hanya 2 operator untuk membandingkan berbagai jenis objek (bukan 12).  Jika Anda hanya memerlukan operasi persamaan, maka cukup tulis 1 fungsi untuk membandingkan objek dari tipe yang sama (bukan 2) dan 1 fungsi untuk membandingkan berbagai jenis objek (bukan 4).  Kelas <i>std :: sub_match</i> adalah kasus ekstrem: di C ++ 17 menggunakan 42 operator perbandingan, dan di C ++ 20 hanya menggunakan 8, sedangkan fungsi tidak menderita sama sekali. <br><br>  Karena kompiler juga mempertimbangkan kandidat terbalik, semua operator ini dapat diimplementasikan sebagai fungsi anggota.  Anda tidak lagi harus menulis fungsi gratis hanya untuk membandingkan berbagai jenis objek. <br><br><h3>  Aturan khusus untuk menemukan kandidat </h3><br>  Seperti yang telah saya sebutkan, pencarian kandidat untuk <i>@ b</i> di C ++ 17 dilakukan sesuai dengan prinsip berikut: kami menemukan semua <i>operator @ operator</i> dan memilih yang paling cocok dari mereka. <br><br>  C ++ 20 menggunakan serangkaian kandidat yang diperluas.  Sekarang kita akan mencari semua <i>operator @</i> .  Biarkan <i>@@</i> menjadi operator dasar untuk <i>@</i> (itu bisa menjadi operator yang sama).  Kami juga menemukan semua <i>operator @@</i> dan untuk masing-masing kami tambahkan versinya yang terbalik.  Dari semua kandidat yang ditemukan, kami memilih yang paling cocok. <br><br>  Perhatikan bahwa overloading operator diizinkan dalam <b>sekali</b> jalan.  Kami tidak mencoba untuk menggantikan kandidat yang berbeda.  Pertama kita kumpulkan semuanya, lalu pilih yang terbaik dari mereka.  Jika ini tidak ada, pencarian, seperti sebelumnya, gagal. <br><br>  Sekarang kami memiliki lebih banyak kandidat potensial, dan karenanya lebih banyak ketidakpastian.  Perhatikan contoh berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(C <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(C <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(C x, C y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x != y; }</code> </pre> <br>  Dalam C ++ 17, kami hanya memiliki satu kandidat untuk <i>x! = Y</i> , dan sekarang ada tiga: <i>x.operator! = (Y)</i> <i>,! X.operator == (y)</i> dan <i>! Y.operator == (x)</i> .  Apa yang harus dipilih?  Semuanya sama saja!  (Catatan: kandidat <i>y.operator! = (X)</i> tidak ada, karena hanya operator dasar yang dapat <i>dibalik</i> .) <br><br>  Dua aturan tambahan telah diperkenalkan untuk menghapus ketidakpastian ini.  Kandidat yang belum bertobat lebih disukai daripada yang dikonversi;    .  ,  <i>x.operator!=(y)</i> Â«Â» <i>!x.operator==(y)</i> ,   Â«Â» <i>!y.operator==(x)</i> .      ,   Â«Â»   . <br><br>   :           <i>operator@@</i> .    .   ,       . <br><br>        -.    â€”    (,   <i>x &lt; y</i> ,    â€”  <i>(x &lt;=&gt; y) &lt; 0</i> ),        (, <i>x &lt;=&gt; y</i>  <i>void</i>  -  ,       DSL),    .          .       ,       <i>bool</i>      (  :  <i>operator==</i>   <i>bool</i> ,        ?) <br><br>  Sebagai contoh: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Base&amp;, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Base&amp;); <span class="hljs-comment"><span class="hljs-comment">// #1 friend bool operator==(const Base&amp;, const Base&amp;); }; struct Derived : Base { friend void operator&lt;=&gt;(const Derived&amp;, const Derived&amp;); // #2 }; bool f(Derived d1, Derived d2) { return d1 &lt; d2; }</span></span></code> </pre> <br>   <i>d1 &lt; d2</i>    : <i>#1</i>  <i>#2</i> .   â€” <i>#2</i> ,      , ,   .    ,  <i>d1 &lt; d2</i>   <i>(d1 &lt;=&gt; d2) &lt; 0</i> .    ,    <i>void</i>  <i>0</i> â€” ,    . ,          - ,    <i>#1</i> . <br><br><h3>    </h3><br> ,     ,    C++17,         .    ,  -    .     : <br><br><ul><li>       </li><li>      (  ) </li><li>            ,         </li><li>               ,   . </li></ul><br>         <b>  </b> ,        .     . <br><br>             .          ,    ,  ,   ,   ,      (   ).  ,         : <br><div class="scrollable-table"><table><tbody><tr><td> <b> </b> <br></td><td> <b> 1</b> <br></td><td> <b> 2</b> <br></td></tr><tr><td> <i>a == b</i> <br></td><td> <i>b == a</i> <br></td><td><br></td></tr><tr><td> <i>a != b</i> <br></td><td> <i>!(a == b)</i> <br></td><td> <i>!(b == a)</i> <br></td></tr><tr><td> <i>a &lt;=&gt; b</i> <br></td><td> <i>0 &lt;=&gt; (b &lt;=&gt; a)</i> <br></td><td><br></td></tr><tr><td> <i>a &lt; b</i> <br></td><td> <i>(a &lt;=&gt; b) &lt; 0</i> <br></td><td> <i>(b &lt;=&gt; a) &gt; 0</i> <br></td></tr><tr><td> <i>a &lt;= b</i> <br></td><td> <i>(a &lt;=&gt; b) &lt;= 0</i> <br></td><td> <i>(b &lt;=&gt; a) &gt;= 0</i> <br></td></tr><tr><td> <i>a &gt; b</i> <br></td><td> <i>(a &lt;=&gt; b) &gt; 0</i> <br></td><td> <i>(b &lt;=&gt; a) &lt; 0</i> <br></td></tr><tr><td> <i>a &gt;= b</i> <br></td><td> <i>(a &lt;=&gt; b) &gt;= 0</i> <br></td><td> <i>(b &lt;=&gt; a) &lt;= 0</i> <br></td></tr></tbody></table></div><br>   Â« Â»         ,     , .. <i>a &lt; b</i>   <i>0 &lt; (b &lt;=&gt; a)</i> ,       ,   ,      . <br><br><h3>       </h3><br>    C++17       .      .           : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> T t; U u; V v; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t == rhs.t &amp;&amp; u == rhs.u &amp;&amp; v == rhs.v; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == rhs); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt; (A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    ,     , //     ?:  &amp;&amp;/|| if (t &lt; rhs.t) return true; if (rhs.t &lt; t) return false; if (u &lt; rhs.u) return true; if (rhs.u &lt; u) return false; return v &lt; rhs.v; } bool operator&gt; (A const&amp; rhs) const { return rhs &lt; *this; } bool operator&lt;=(A const&amp; rhs) const { return !(rhs &lt; *this); } bool operator&gt;=(A const&amp; rhs) const { return !(*this &lt; rhs); } };</span></span></code> </pre> <br>      - <i>std::tie()</i> ,     . <br><br>       ,   :    : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> T t; U u; V v; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t == rhs.t &amp;&amp; u == rhs.u &amp;&amp; v == rhs.v; } strong_ordering <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   T if (auto c = t &lt;=&gt; rhs.t; c != 0) return c; // ...  U if (auto c = u &lt;=&gt; rhs.u; c != 0) return c; // ...  V return v &lt;=&gt; rhs.v; } };</span></span></code> </pre> <br>     .   <i>&lt;=&gt;</i>         <i>&lt;</i> .  ,        .  <i>c != 0</i>    ,      ,          ( <i></i>  <i></i> ),     . <br><br>        <i> </i> .   C++20    ,   : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> T t; U u; V v; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; strong_ordering <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; };</code> </pre> <br>   ,        .     ,     : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> T t; U u; V v; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; };</code> </pre> <br>    .   ,         ,     : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> T t; U u; V v; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; };</code> </pre> <br>   ,     ,     .     :        <i>operator==</i> ,     <i>operator&lt;=&gt;</i> . <br><br><h2>    </h2><br>         C++20:        .          .         ,    ,        ,     . <br><br><h2>   </h2><br>  PVS-Studio      ,            &lt;=&gt;  .         ,       -.   ,     ,            (.  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">    </a> ").  ++          . <br><br>      PVS-Studio        &lt;,     : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt; (A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t &lt; rhs.t &amp;&amp; u &lt; rhs.u; }</code> </pre> <br>        . ,   -  .  . <br><br> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Comparisons in C++20</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id465575/">https://habr.com/ru/post/id465575/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id465561/index.html">Apa yang saya pelajari dari seorang programmer terkemuka</a></li>
<li><a href="../id465567/index.html">Menguji kode SQL Server dengan tSQLt</a></li>
<li><a href="../id465569/index.html">Peta Pengembangan Pengembang Seluler</a></li>
<li><a href="../id465571/index.html">Cara menjual rokok pria untuk wanita dan membuat orang biadab melindungi diri mereka sendiri: copywriter yang bisa</a></li>
<li><a href="../id465573/index.html">Semua kekuatan IntelliJ IDEA pada contoh satu bahasa (dalam gambar)</a></li>
<li><a href="../id465577/index.html">Jenis baru penanda mikro untuk cuplikan interaktif lanjutan</a></li>
<li><a href="../id465579/index.html">Membuat Obrolan Perusahaan dan Konferensi Video dengan Tim Zextras</a></li>
<li><a href="../id465583/index.html">Rincian kampanye jahat untuk pengguna iPhone diungkapkan</a></li>
<li><a href="../id465585/index.html">Bagaimana mengelola Bereaksi Data Grid melalui Redux</a></li>
<li><a href="../id465587/index.html">Analisis: apa pasar OTC, dan transaksi apa yang dilakukan di sana</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>