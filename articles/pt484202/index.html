<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé≥ üàØÔ∏è ‚ô®Ô∏è Aprendizado de m√°quina na an√°lise est√°tica do c√≥digo-fonte do programa üë©üèª‚Äçüöí üòö üëßüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O aprendizado de m√°quina est√° firmemente consolidado em uma variedade de campos humanos, desde o reconhecimento de fala at√© o diagn√≥stico m√©dico. A po...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aprendizado de m√°quina na an√°lise est√°tica do c√≥digo-fonte do programa</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/484202/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38e/0e0/738/38e0e0738ea8b928bdecb77040a207c1.png" alt="Aprendizado de m√°quina na an√°lise est√°tica do c√≥digo-fonte do programa"></div><br>  O aprendizado de m√°quina est√° firmemente consolidado em uma variedade de campos humanos, desde o reconhecimento de fala at√© o diagn√≥stico m√©dico.  A popularidade dessa abordagem √© t√£o grande que as pessoas tentam us√°-la sempre que poss√≠vel.  Algumas tentativas de substituir abordagens cl√°ssicas por redes neurais acabam sendo malsucedidas.  Desta vez, consideraremos o aprendizado de m√°quina em termos de cria√ß√£o de analisadores de c√≥digo est√°tico eficazes para encontrar bugs e poss√≠veis vulnerabilidades. <br><a name="habracut"></a><br>  Muitas vezes perguntam √† equipe do PVS-Studio se queremos come√ßar a usar o aprendizado de m√°quina para encontrar erros no c√≥digo fonte do software.  A resposta curta √© sim, mas de forma limitada.  Acreditamos que, com o aprendizado de m√°quina, existem muitas armadilhas ocultas nas tarefas de an√°lise de c√≥digo.  Na segunda parte do artigo, falaremos sobre eles.  Vamos come√ßar com uma revis√£o de novas solu√ß√µes e id√©ias. <br><br><h2>  Novas abordagens </h2><br>  Atualmente, existem muitos analisadores est√°ticos baseados em ou usando aprendizado de m√°quina, incluindo aprendizado profundo e PNL para detec√ß√£o de erros.  N√£o apenas os entusiastas dobraram o potencial de aprendizado de m√°quina, mas tamb√©m as grandes empresas, por exemplo, Facebook, Amazon ou Mozilla.  Alguns projetos n√£o s√£o analisadores est√°ticos completos, pois s√≥ encontram alguns erros em confirma√ß√µes. <br><br>  Curiosamente, quase todos eles est√£o posicionados como produtos que mudam o jogo, que far√£o uma inova√ß√£o no processo de desenvolvimento devido √† intelig√™ncia artificial. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28c/cde/532/28ccde53241d54d5b927234ff729a19d.png"></div><br><br>  Vejamos alguns dos exemplos conhecidos: <br><br><ol><li>  Deepcode </li><li>  Infer, Sapienz, SapFix </li><li>  Embold </li><li>  Origem {d} </li><li>  Assistente inteligente de confirma√ß√£o, confirma√ß√£o </li><li>  CodeGuru </li></ol><br><h3>  Deepcode </h3><br>  O Deep Code √© uma ferramenta de pesquisa de vulnerabilidades para c√≥digo de software Java, JavaScript, TypeScript e Python que apresenta o aprendizado de m√°quina como um componente.  Segundo Boris Paskalev, mais de 250.000 regras j√° est√£o em vigor.  Essa ferramenta aprende com as altera√ß√µes feitas pelos desenvolvedores no c√≥digo fonte dos projetos de c√≥digo aberto (um milh√£o de reposit√≥rios).  A pr√≥pria empresa diz que seu projeto √© algum tipo de gram√°tica para desenvolvedores. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c0/f09/8df/0c0f098dfabd07a95df228b434ab3bfb.png"></div><br><br>  De fato, este analisador compara sua solu√ß√£o com sua base de projetos e oferece a melhor solu√ß√£o pretendida com a experi√™ncia de outros desenvolvedores. <br><br>  Em maio de 2018, os desenvolvedores disseram que o suporte ao C ++ est√° a caminho, mas at√© agora, esse idioma n√£o √© suportado.  Embora, conforme declarado no site, o suporte ao novo idioma possa ser adicionado em quest√£o de semanas devido ao fato de o idioma depender apenas de um est√°gio, que est√° sendo analisado. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a38/68e/7e5/a3868e7e5efa50016e7a7858054da47a.png"></div><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/111/984/4f5/1119844f5406645778271c64f12d0df9.png"></div><br><br>  Uma s√©rie de postagens sobre m√©todos b√°sicos do analisador tamb√©m est√° dispon√≠vel no site. <br><br><h3>  Inferir </h3><br>  O Facebook √© bastante zeloso em suas tentativas de introduzir novas abordagens abrangentes em seus produtos.  O aprendizado de m√°quina tamb√©m n√£o ficou √† margem.  Em 2013, eles compraram uma startup que desenvolveu um analisador est√°tico baseado em aprendizado de m√°quina.  E em 2015, o c√≥digo fonte do projeto <a href="https://github.com/facebook/infer">tornou-se aberto</a> . <br><br>  Infer √© um analisador est√°tico para projetos em Java, C, C ++ e Objective-C, desenvolvido pelo Facebook.  Segundo o site, ele tamb√©m √© usado no Amazon Web Services, Oculus, Uber e outros projetos populares. <br><br>  Atualmente, o Infer √© capaz de encontrar erros relacionados √† desreferencia√ß√£o de ponteiro nulo e vazamentos de mem√≥ria.  Infer √© baseado na l√≥gica de Hoare, l√≥gica de separa√ß√£o e bi-abdu√ß√£o, bem como na teoria da interpreta√ß√£o abstrata.  O uso dessas abordagens permite ao analisador dividir o programa em partes e analis√°-las independentemente. <br><br>  Voc√™ pode tentar usar o Infer em seus projetos, mas os desenvolvedores alertam que, enquanto nos projetos do Facebook gera cerca de 80% dos avisos √∫teis, um n√∫mero baixo de falsos positivos n√£o √© garantido em outros projetos.  Aqui est√£o alguns erros que o Infer n√£o conseguiu detectar at√© o momento, mas os desenvolvedores est√£o trabalhando na implementa√ß√£o desses avisos: <br><br><ul><li>  √≠ndice de matriz fora dos limites; </li><li>  exce√ß√µes de convers√£o de tipo; </li><li>  vazamentos de dados n√£o verificados; </li><li>  condi√ß√£o de corrida. </li></ul><br><h3>  Sapfix </h3><br>  SapFix √© uma ferramenta de edi√ß√£o automatizada.  Ele recebe informa√ß√µes da Sapienz, uma ferramenta de automa√ß√£o de testes e do analisador est√°tico Infer.  Com base em altera√ß√µes e mensagens recentes, o Infer seleciona uma das v√°rias estrat√©gias para corrigir bugs. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/547/de6/baa/547de6baa2d74f4e3be984a78c704d45.png"></div><br><br>  Em alguns casos, o SapFix reverte todas as altera√ß√µes ou partes delas.  Em outros casos, ele tenta resolver o problema gerando um patch a partir de seu conjunto de padr√µes de corre√ß√£o.  Esse conjunto √© formado a partir de padr√µes de corre√ß√µes coletados pelos pr√≥prios programadores a partir de um conjunto de corre√ß√µes que j√° foram feitas.  Se esse padr√£o n√£o corrigir um erro, o SapFix tenta ajust√°-lo √† situa√ß√£o fazendo pequenas modifica√ß√µes em uma √°rvore de sintaxe abstrata at√© que a solu√ß√£o potencial seja encontrada. <br><br>  Mas como uma solu√ß√£o em potencial n√£o √© suficiente, o SapFix coleta v√°rias solu√ß√µes com base em alguns pontos: se h√° erros de compila√ß√£o, se ela falha ou se apresenta novas falhas.  Depois que as edi√ß√µes s√£o totalmente testadas, os patches s√£o revisados ‚Äã‚Äãpor um programador, que decide qual das edi√ß√µes melhor resolve o problema. <br><br><h3>  Embold </h3><br>  O Embold √© uma plataforma de inicializa√ß√£o para an√°lise est√°tica do c√≥digo-fonte do software chamado Gamma antes da renomea√ß√£o.  O analisador est√°tico funciona com base nos pr√≥prios diagn√≥sticos da ferramenta, al√©m de usar analisadores incorporados, como Cppcheck, SpotBugs, SQL Check e outros. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f40/406/bd8/f40406bd824b5eeb1815de357d95565b.png"></div><br><br>  Al√©m dos pr√≥prios diagn√≥sticos, a plataforma concentra-se em infogr√°ficos v√≠vidos sobre a carga da base de c√≥digo e na visualiza√ß√£o conveniente dos erros encontrados, bem como na busca de uma poss√≠vel refatora√ß√£o.  Al√©m disso, este analisador possui um conjunto de antipadr√µes que permite detectar problemas na estrutura do c√≥digo no n√≠vel de classe e m√©todo, al√©m de v√°rias m√©tricas para calcular a qualidade de um sistema. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/220/74f/abb/22074fabb8b67de2ce5d5427729387f7.png"></div><br><br>  Uma das principais vantagens √© o sistema inteligente de oferecer solu√ß√µes e edi√ß√µes que, al√©m do diagn√≥stico convencional, verifica edi√ß√µes com base em informa√ß√µes sobre altera√ß√µes anteriores. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e5/122/c46/6e5122c462cd33320eafecd4deac2a49.png"></div><br><br>  Com a PNL, o Embold divide o c√≥digo e procura por interconex√µes e depend√™ncias entre fun√ß√µes e m√©todos, economizando tempo de refatora√ß√£o. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/94e/129/3fe/94e1293fe9e031d4065beb9ea1b21932.png"></div><br><br>  Dessa forma, o Embold basicamente oferece uma visualiza√ß√£o conveniente dos resultados da an√°lise do c√≥digo fonte por v√°rios analisadores, bem como por seus pr√≥prios diagn√≥sticos, alguns dos quais baseados no aprendizado de m√°quina. <br><br><h3>  Origem {d} </h3><br>  A fonte {d} √© a ferramenta mais aberta em termos de formas de implementa√ß√£o, em compara√ß√£o com os analisadores que analisamos.  √â tamb√©m uma <a href="https://github.com/src-d/sourced-ce">solu√ß√£o de c√≥digo-fonte aberto</a> .  Em seu site, em troca do seu endere√ßo de e-mail, voc√™ pode obter um folheto do produto descrevendo as tecnologias que eles usam.  Al√©m disso, o site fornece um <a href="https://github.com/src-d/awesome-machine-learning-on-source-code">link</a> para o banco de dados de publica√ß√µes relacionadas ao uso de aprendizado de m√°quina para an√°lise de c√≥digo, bem como ao <a href="https://github.com/src-d/datasets/tree/master/PublicGitArchive">reposit√≥rio</a> com conjunto de dados para aprendizado baseado em c√≥digo.  O produto em si √© uma plataforma inteira para analisar o c√≥digo-fonte e o produto de software, e n√£o se concentra nos desenvolvedores, mas nos gerentes.  Entre suas capacidades est√° o c√°lculo do tamanho da d√≠vida t√©cnica, gargalos no processo de desenvolvimento e outras estat√≠sticas globais do projeto. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af2/b8c/425/af2b8c42537b1a2628c95773165ed190.png"></div><br><br>  Sua abordagem para a an√°lise de c√≥digo atrav√©s do aprendizado de m√°quina √© baseada na Hip√≥tese Natural, conforme descrito no artigo " <a href="https://people.inf.ethz.ch/suz/publications/natural.pdf">Sobre a naturalidade do software</a> ". <br><br>  <i>"As linguagens de programa√ß√£o, em teoria, s√£o complexas, flex√≠veis e poderosas, mas os programas que as pessoas reais realmente escrevem s√£o na maioria simples e bastante repetitivas e, portanto, possuem propriedades estat√≠sticas previs√≠veis que podem ser capturadas em modelos de linguagem estat√≠stica e aproveitadas para engenharia de software" tarefas. ‚Äù</i> <br><br>  Com base nessa hip√≥tese, quanto maior a base de c√≥digo, maiores ser√£o as propriedades estat√≠sticas e mais precisas ser√£o as m√©tricas, obtidas atrav√©s do aprendizado. <br><br>  Para analisar o c√≥digo na fonte {d}, √© usado o servi√ßo Babelfish, que pode analisar o arquivo de c√≥digo em qualquer um dos idiomas dispon√≠veis, obter uma √°rvore de sintaxe abstrata e convert√™-lo em uma √°rvore de sintaxe universal. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39e/bbd/c4d/39ebbdc4d561895c1f7b9e251d44e17c.png"></div><br><br>  No entanto, a fonte {d} n√£o procura erros no c√≥digo.  Com base na √°rvore que usa o ML em todo o projeto, a fonte {d} detecta a formata√ß√£o do c√≥digo, o estilo aplicado no projeto e em uma confirma√ß√£o.  Se o novo c√≥digo n√£o corresponder ao estilo do c√≥digo do projeto, ele far√° algumas edi√ß√µes. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7f/196/c0a/e7f196c0a742ba8f68436b157708c109.png"></div><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/deb/f51/7bd/debf517bd5d74c2553a9b7fbd112a1b2.png"></div><br><br>  O aprendizado se concentra em v√°rios elementos b√°sicos: espa√ßos, tabula√ß√£o, quebras de linha etc. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39a/ade/8c5/39aade8c5ea77cb3bf89d4a0e999c5f7.png"></div><br><br>  Leia mais sobre isso em sua publica√ß√£o: " <a href="https://arxiv.org/abs/1904.00935">STYLE-ANALYZER: corrigindo inconsist√™ncias de estilo de c√≥digo com algoritmos n√£o supervisionados interpret√°veis</a> ". <br><br>  Em suma, o source {d} √© uma ampla plataforma para coletar diversas estat√≠sticas sobre o c√≥digo-fonte e o processo de desenvolvimento do projeto: desde c√°lculos de efici√™ncia dos desenvolvedores at√© custos de tempo para a revis√£o do c√≥digo. <br><br><h3>  Confirma√ß√£o inteligente </h3><br>  O Clever-Commit √© um analisador criado pela Mozilla em colabora√ß√£o com a Ubisoft.  Ele √© baseado em um estudo <a href="https://static-wordpress.akamaized.net/montreal.ubisoft.com/wp-content/uploads/2018/03/03172129/clever-commit-msr18.pdf">CLEVER</a> (Combinando n√≠veis de t√©cnicas de preven√ß√£o e resolu√ß√£o de erros) da Ubisoft e seu produto filho, Commit Assistant, que detecta confirma√ß√µes suspeitas com probabilidade de conter um erro.  Como o CLEVER √© baseado na compara√ß√£o de c√≥digos, ele pode apontar para um c√≥digo perigoso e fazer sugest√µes para poss√≠veis edi√ß√µes.  De acordo com a descri√ß√£o, em 60-70% dos casos, o Clever-Commit encontra locais problem√°ticos e oferece edi√ß√µes corretas com a mesma probabilidade.  Em geral, h√° pouca informa√ß√£o sobre este projeto e sobre os erros que ele consegue encontrar. <br><br><h3>  CodeGuru </h3><br>  Recentemente, o CodeGuru, um produto da Amazon, se alinhou aos analisadores que usam o aprendizado de m√°quina.  √â um servi√ßo de aprendizado de m√°quina que permite encontrar erros no c√≥digo, bem como identificar √°reas caras nele.  A an√°lise est√° dispon√≠vel apenas para o c√≥digo Java at√© agora, mas os autores prometem suportar outras linguagens no futuro.  Embora tenha sido anunciado recentemente, Andy Jassy, ‚Äã‚ÄãCEO da AWS (Amazon Web Services), diz que √© usado na Amazon h√° muito tempo. <br><br>  O site diz que o CodeGuru estava aprendendo na base de c√≥digos da Amazon, bem como em mais de 10.000 projetos de c√≥digo aberto. <br><br>  Basicamente, o servi√ßo √© dividido em duas partes: CodeGuru Reviewer, ensinado usando a busca de regras associativas e procurando erros no c√≥digo, e CodeGuru Profiler, monitorando o desempenho dos aplicativos. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee0/662/3a6/ee06623a61ab3f1345d05f169f3325ac.png"></div><br><br>  Em geral, n√£o h√° muita informa√ß√£o dispon√≠vel sobre este projeto.  Conforme o site afirma, o Revisor analisa as bases de c√≥digo da Amazon e pesquisa solicita√ß√µes pull, contendo as chamadas da API da AWS para aprender como detectar desvios das "melhores pr√°ticas".  A seguir, ele analisa as altera√ß√µes feitas e as compara aos dados da documenta√ß√£o, que √© analisada ao mesmo tempo.  O resultado √© um modelo de "melhores pr√°ticas". <br><br>  Tamb√©m √© dito que as recomenda√ß√µes para o c√≥digo do usu√°rio tendem a melhorar depois de receber feedback sobre eles. <br><br>  A lista de erros aos quais o Revisor responde √© bastante borrada, pois nenhuma documenta√ß√£o espec√≠fica sobre erros foi publicada: <br><br><ul><li>  Pr√°ticas recomendadas da AWS </li><li>  Concorr√™ncia </li><li>  Vazamentos de recursos </li><li>  Vazamento de informa√ß√µes confidenciais </li><li>  "Pr√°ticas recomendadas" gerais de codifica√ß√£o </li></ul><br><h2>  Nosso ceticismo </h2><br>  Agora, vamos considerar a pesquisa de erros do ponto de vista da nossa equipe, que desenvolve analisadores est√°ticos h√° muitos anos.  Vemos v√°rios problemas de alto n√≠vel na aplica√ß√£o de m√©todos de aprendizado, que gostar√≠amos de abordar.  Para come√ßar, dividiremos todas as abordagens de ML em dois tipos: <br><br><ol><li>  Aqueles que ensinam manualmente um analisador est√°tico a procurar v√°rios problemas, usando exemplos de c√≥digos sint√©ticos e reais; </li><li>  Aqueles que ensinam algoritmos em um grande n√∫mero de c√≥digo-fonte aberto e hist√≥rico de revis√µes (GitHub), ap√≥s o qual o analisador come√ßar√° a detectar bugs e at√© a oferecer edi√ß√µes. </li></ol><br>  Falaremos sobre cada dire√ß√£o separadamente, pois elas t√™m diferentes inconvenientes.  Depois disso, acho que os leitores entender√£o por que n√£o negamos as possibilidades de aprendizado de m√°quina, mas ainda n√£o compartilhamos o entusiasmo. <br><br>  <b>Nota</b>  N√≥s olhamos da perspectiva do desenvolvimento de um analisador universal est√°tico de uso geral.  Nosso foco √© desenvolver o analisador, que qualquer equipe poder√° usar, e n√£o aquele focado em uma base de c√≥digo espec√≠fica. <br><br><h3>  Ensino manual de um analisador est√°tico </h3><br>  Digamos que queremos usar o ML para come√ßar a procurar os seguintes tipos de falhas no c√≥digo: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A == A)</code> </pre> <br>  √â estranho comparar uma vari√°vel consigo mesma.  Podemos escrever muitos exemplos de c√≥digo correto e incorreto e ensinar o analisador a procurar esses erros.  Al√©m disso, voc√™ pode adicionar exemplos reais de erros j√° encontrados nos testes.  Bem, a quest√£o √© onde encontrar esses exemplos.  Ok, vamos assumir que √© poss√≠vel.  Por exemplo, temos v√°rios exemplos desses erros: <a href="https://www.viva64.com/en/examples/v501/">V501</a> , <a href="https://www.viva64.com/en/examples/v3001/">V3001</a> , <a href="https://www.viva64.com/en/examples/v6001/">V6001</a> . <br><br>  Ent√£o, √© poss√≠vel identificar esses defeitos no c√≥digo usando os algoritmos ML?  √â sim.  A quest√£o √© - por que precisamos disso? <br><br>  Veja, para ensinar ao analisador, precisamos gastar muito esfor√ßo na prepara√ß√£o dos exemplos para o ensino.  Outra op√ß√£o √© marcar o c√≥digo de aplicativos reais, indicando os fragmentos nos quais o analisador deve emitir um aviso.  De qualquer forma, muito trabalho precisar√° ser feito, pois deve haver milhares de exemplos de aprendizado.  Ou dezenas de milhares. <br><br>  Afinal, queremos detectar n√£o apenas (A == A) casos, mas tamb√©m: <br><br><ul><li>  if (X e&amp;A == A) </li><li>  if (A + 1 == A + 1) </li><li>  if (A [i] == A [i]) </li><li>  se ((A) == (A)) </li><li>  e assim por diante. </li></ul><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19e/a51/95d/19ea5195d9075802dbdcd3feda3c4aad.png"></div><br>  Vejamos a implementa√ß√£o potencial de um diagn√≥stico t√£o simples no PVS-Studio: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RulePrototype_V501</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VivaWalker &amp;walker, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *right, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *operation)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SafeEq(operation, <span class="hljs-string"><span class="hljs-string">"=="</span></span>) &amp;&amp; SafeEqual(left, right)) { walker.AddError(<span class="hljs-string"><span class="hljs-string">"Oh boy! Holy cow!"</span></span>, left, <span class="hljs-number"><span class="hljs-number">501</span></span>, Level_1, <span class="hljs-string"><span class="hljs-string">"CWE-571"</span></span>); } }</code> </pre> <br>  E √© isso a√≠!  Voc√™ n√£o precisa de nenhuma base de exemplos para o ML! <br><br>  No futuro, o diagn√≥stico precisar√° aprender a levar em considera√ß√£o v√°rias exce√ß√µes e emitir avisos para (A [0] == A [1-1]).  Como sabemos, pode ser facilmente programado.  Pelo contr√°rio, neste caso, as coisas v√£o ficar ruins com a base de exemplos. <br><br>  Observe que, nos dois casos, precisaremos de um sistema de testes, documenta√ß√£o e assim por diante.  Quanto √† contribui√ß√£o trabalhista na cria√ß√£o de um novo diagn√≥stico, a abordagem cl√°ssica, onde a regra √© rigidamente programada no c√≥digo, assume a lideran√ßa. <br><br>  Ok, √© hora de outra regra.  Por exemplo, aquele em que o resultado de algumas fun√ß√µes deve ser usado.  N√£o faz sentido cham√°-los e n√£o usar o resultado.  Aqui est√£o algumas dessas fun√ß√µes: <br><br><ul><li>  malloc </li><li>  memcmp </li><li>  string :: vazio </li></ul><br>  √â isso que o diagn√≥stico PVS-Studio <a href="https://www.viva64.com/en/w/v530/">V530</a> faz. <br><br>  Ent√£o, o que queremos √© detectar chamadas para essas fun√ß√µes, cujo resultado n√£o √© usado.  Para fazer isso, voc√™ pode gerar muitos testes.  E achamos que tudo vai funcionar bem.  Mas, novamente, n√£o est√° claro por que √© necess√°rio. <br><br>  A implementa√ß√£o do diagn√≥stico V530, com todas as exce√ß√µes, utilizou 258 linhas de c√≥digo no analisador PVS-Studio, 64 das quais s√£o coment√°rios.  H√° tamb√©m uma tabela com anota√ß√µes de fun√ß√µes, onde √© observado que o resultado deve ser usado.  √â muito mais f√°cil preencher essa tabela do que criar exemplos sint√©ticos. <br><br>  As coisas v√£o piorar com os diagn√≥sticos que usam a an√°lise de fluxo de dados.  Por exemplo, o analisador PVS-Studio pode rastrear o valor dos ponteiros, o que permite encontrar esse vazamento de mem√≥ria: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* BnNew() { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>[kBigIntSize]; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(result, <span class="hljs-number"><span class="hljs-number">0</span></span>, kBigIntSize * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AndroidRSAPublicKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(crypto::RSAPrivateKey* key)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* n = BnNew(); .... RSAPublicKey pkey; pkey.len = kRSANumWords; pkey.exponent = <span class="hljs-number"><span class="hljs-number">65537</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Fixed public exponent pkey.n0inv = 0 - ModInverse(n0, 0x100000000LL); if (pkey.n0inv == 0) return kDummyRSAPublicKey; // &lt;= .... }</span></span></code> </pre> <br>  O exemplo √© retirado do artigo " <a href="https://www.viva64.com/en/b/0555/">Chromium: Memory Leaks</a> ".  Se a condi√ß√£o <i>(pkey.n0inv == 0)</i> for verdadeira, a fun√ß√£o sai sem liberar o buffer, o ponteiro para o qual √© armazenado na vari√°vel <i>n</i> . <br><br>  Do ponto de vista do PVS-Studio, n√£o h√° nada complicado aqui.  O analisador estudou a fun√ß√£o <i>BnNew</i> e lembrou que retornou um ponteiro para o bloco de mem√≥ria alocado.  Em outra fun√ß√£o, percebeu que o buffer pode n√£o liberar e o ponteiro para ele se perde no momento em que sai da fun√ß√£o. <br><br>  √â um algoritmo comum de rastreamento de valores funcionando.  N√£o importa como o c√≥digo est√° escrito.  N√£o importa o que mais h√° na fun√ß√£o que n√£o esteja relacionada ao trabalho do ponteiro.  O algoritmo √© universal e o diagn√≥stico V773 encontra muitos erros em v√°rios projetos.  Veja qu√£o diferentes s√£o os <a href="https://www.viva64.com/en/examples/v773/">fragmentos de c√≥digo</a> com erros detectados! <br><br>  N√£o somos especialistas em ML, mas temos a sensa√ß√£o de que grandes problemas est√£o chegando aqui.  H√° um n√∫mero incr√≠vel de maneiras de escrever c√≥digo com vazamentos de mem√≥ria.  Mesmo que a m√°quina aprendesse bem como rastrear valores de vari√°veis, seria necess√°rio entender que tamb√©m h√° chamadas para fun√ß√µes. <br><br>  Suspeitamos que seja necess√°rio tantos exemplos para aprender que a tarefa se torna inacess√≠vel.  N√£o estamos dizendo que n√£o √© realista.  Duvidamos que o custo de cria√ß√£o do analisador seja compensador. <br><br>  <b>Analogia</b>  O que me vem √† cabe√ßa √© a analogia com uma calculadora, onde, em vez de diagn√≥sticos, √© preciso programar a√ß√µes aritm√©ticas.  Temos certeza de que voc√™ pode ensinar uma calculadora baseada em ML a resumir bem os n√∫meros, alimentando-a com os resultados das opera√ß√µes 1 + 1 = 2, 1 + 2 = 3, 2 + 1 = 3, 100 + 200 = 300 e assim por diante .  Como voc√™ entende, a viabilidade de desenvolver uma calculadora desse tipo √© uma grande quest√£o (a menos que seja atribu√≠da uma subven√ß√£o :).  Uma calculadora muito mais simples, r√°pida, precisa e confi√°vel pode ser escrita usando a opera√ß√£o simples "+" no c√≥digo. <br><br>  <b>Conclus√£o</b> Bem, desta maneira, funcionar√°.  Mas us√°-lo, em nossa opini√£o, n√£o faz sentido pr√°tico.  O desenvolvimento consumir√° mais tempo, mas o resultado - menos confi√°vel e preciso, especialmente quando se trata de implementar diagn√≥sticos complexos com base na an√°lise do fluxo de dados. <br><br><h3>  Aprendendo sobre grande quantidade de c√≥digo-fonte aberto </h3><br>  Ok, resolvemos com exemplos sint√©ticos manuais, mas tamb√©m h√° o GitHub.  Voc√™ pode acompanhar o hist√≥rico de consolida√ß√£o e deduzir os padr√µes de altera√ß√£o / corre√ß√£o de c√≥digo.  Ent√£o voc√™ pode apontar n√£o apenas para fragmentos de c√≥digo suspeito, mas at√© sugerir uma maneira de corrigi-lo. <br><br>  Se voc√™ parar nesse n√≠vel de detalhe, tudo ficar√° bem.  O diabo, como sempre, est√° nos detalhes.  Ent√£o, vamos falar bem sobre esses detalhes. <br><br>  <b>A primeira nuance.</b>  <b>Fonte de dados.</b> <br><br>  As edi√ß√µes do GitHub s√£o bastante aleat√≥rias e diversas.  As pessoas costumam ter pregui√ßa de fazer confirma√ß√µes at√¥micas e fazer v√°rias edi√ß√µes no c√≥digo ao mesmo tempo.  Voc√™ sabe como isso acontece: voc√™ consertaria o bug e, ao mesmo tempo, o refatoraria um pouco ("E aqui vou acrescentar o tratamento de um caso como esse ...").  Mesmo uma pessoa pode ent√£o ser incompreens√≠vel, independentemente de esses fatores estarem relacionados ou n√£o. <br><br>  O desafio √© como distinguir erros reais de adicionar novas funcionalidades ou outra coisa.  Obviamente, √© poss√≠vel obter 1000 pessoas que marcar√£o manualmente os commits.  As pessoas ter√£o que apontar: aqui um erro foi corrigido, aqui est√° refatorando, aqui est√° uma nova funcionalidade, aqui os requisitos foram alterados e assim por diante. <br><br>  Essa marca√ß√£o √© poss√≠vel?  Sim!  Mas observe a rapidez com que a falsifica√ß√£o acontece.  Em vez de "o algoritmo aprender a si pr√≥prio com base no GitHub", j√° estamos discutindo como confundir centenas de pessoas por um longo tempo.  O trabalho e o custo de cria√ß√£o da ferramenta est√£o aumentando drasticamente. <br><br>  Voc√™ pode tentar identificar automaticamente onde os bugs foram corrigidos.  Para fazer isso, voc√™ deve analisar os coment√°rios aos commits, prestar aten√ß√£o √†s pequenas edi√ß√µes locais, que provavelmente s√£o essas mesmas corre√ß√µes.  √â dif√≠cil dizer qu√£o bem voc√™ pode procurar automaticamente por corre√ß√µes de erros.  De qualquer forma, essa √© uma grande tarefa que requer pesquisa e programa√ß√£o separadas. <br><br>  Ent√£o, ainda nem aprendemos e j√° existem nuances :). <br><br>  <b>A segunda nuance.</b>  <b>Um atraso no desenvolvimento.</b> <br><br>  Os analisadores que aprender√£o com base nessas plataformas, como o GitHub, estar√£o sempre sujeitos a essa s√≠ndrome, como "atraso de retardo mental".  Isso ocorre porque as linguagens de programa√ß√£o mudam com o tempo. <br><br>  Desde o C # 8.0, existem tipos de refer√™ncia nula, ajudando a combater as exce√ß√µes de refer√™ncia nula (NRE).  No JDK 12, um novo operador de switch ( <a href="https://openjdk.java.net/jeps/325">JEP 325</a> ) apareceu.  No C ++ 17, existe a possibilidade de executar constru√ß√µes condicionais em tempo de compila√ß√£o ( <a href="https://www.bfilipek.com/2018/03/ifconstexpr.html">constexpr if</a> ).  E assim por diante <br><br>  Linguagens de programa√ß√£o est√£o evoluindo.  Al√©m disso, como C ++, desenvolvem-se muito rapidamente.  Novas constru√ß√µes aparecem, novas fun√ß√µes padr√£o s√£o adicionadas e assim por diante.  Juntamente com os novos recursos, h√° novos padr√µes de erro que tamb√©m gostar√≠amos de identificar com a an√°lise de c√≥digo est√°tica. <br><br>  Neste ponto, o m√©todo ML enfrenta um problema: o padr√£o de erro j√° est√° claro, gostar√≠amos de detect√°-lo, mas n√£o h√° base de c√≥digo para o aprendizado. <br><br>  Vejamos esse problema usando um exemplo espec√≠fico.  O loop for baseado em intervalo apareceu no C ++ 11.  Voc√™ pode escrever o seguinte c√≥digo, percorrendo todos os elementos no cont√™iner: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; numbers; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num : numbers) foo(num);</code> </pre> <br>  O novo loop trouxe o novo padr√£o de erro.  Se alterarmos o cont√™iner dentro do loop, isso resultar√° na invalida√ß√£o de iteradores "shadow". <br><br>  Vamos dar uma olhada no seguinte c√≥digo incorreto: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num : numbers) { numbers.push_back(num * <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  O compilador ir√° transform√°-lo em algo como isto: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> __begin = begin(numbers), __end = end(numbers); __begin != __end; ++__begin) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = *__begin; numbers.push_back(num * <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  Durante <i>push_back</i> , os iteradores <i>__begin</i> e <i>__end</i> podem ser invalidados, se a mem√≥ria for realocada dentro do vetor.  O resultado ser√° o comportamento indefinido do programa. <br><br>  Portanto, o padr√£o de erro j√° √© conhecido e descrito na literatura.  O analisador PVS-Studio o diagnostica com o diagn√≥stico <a href="https://www.viva64.com/en/w/v789/">V789</a> e j√° encontrou <a href="https://www.viva64.com/en/examples/v789/">erros reais</a> em projetos de c√≥digo aberto. <br><br>  Em quanto tempo o GitHub ter√° c√≥digo novo o suficiente para perceber esse padr√£o?  Boa pergunta ... √â importante ter em mente que, se houver um loop for baseado em intervalo, isso n√£o significa que todos os programadores come√ßar√£o a us√°-lo imediatamente de uma vez.  Pode levar anos at√© que haja muito c√≥digo usando o novo loop.  Al√©m disso, muitos erros devem ser cometidos e, em seguida, devem ser corrigidos para que o algoritmo possa observar o padr√£o nas edi√ß√µes. <br><br>  Quantos anos levar√°?  Cinco?  Dez? <br><br>  Dez √© demais, ou √© uma previs√£o pessimista?  Longe disso.  No momento em que o artigo foi escrito, fazia oito anos que um loop for baseado em intervalo apareceu em C ++ 11.  At√© agora, por√©m, em nosso banco de dados, existem apenas <a href="https://www.viva64.com/en/examples/v789/">tr√™s casos</a> desse erro.  Tr√™s erros n√£o s√£o muitos e n√£o s√£o poucos.  N√£o se deve tirar nenhuma conclus√£o desse n√∫mero.  O principal √© confirmar que esse padr√£o de erro √© real e faz sentido detect√°-lo. <br><br>  Agora compare esse n√∫mero, por exemplo, com este padr√£o de erro: o <a href="https://www.viva64.com/en/examples/v595/">ponteiro √© desreferenciado antes da verifica√ß√£o</a> .  No total, j√° identificamos 1.716 casos ao verificar projetos de c√≥digo aberto. <br><br>  Talvez n√£o devamos procurar erros nos loops baseados em intervalo?  N√£o.  Os programadores s√£o inerciais e esse operador est√° se tornando popular muito lentamente.  Gradualmente, haver√° mais c√≥digo e erros, respectivamente. <br><br>  √â prov√°vel que isso aconte√ßa apenas 10 a 15 anos ap√≥s o aparecimento do C ++ 11.  Isso leva a uma quest√£o filos√≥fica.  Suponhamos que j√° conhe√ßamos o padr√£o de erro, esperaremos muitos anos at√© que tenhamos muitos erros em projetos de c√≥digo aberto.  Ser√° que vai ser assim? <br><br>  Se "sim", √© seguro diagnosticar "atraso no desenvolvimento mental" para todos os analisadores baseados em ML. <br><br>  Se "n√£o", o que devemos fazer?  N√£o h√° exemplos.  Escreva-os manualmente?  Mas, dessa maneira, voltamos ao cap√≠tulo anterior, onde fornecemos uma descri√ß√£o detalhada da op√ß√£o em que as pessoas escreviam um pacote inteiro de exemplos para aprender. <br><br>  Isso pode ser feito, mas a quest√£o da conveni√™ncia surge novamente.  A implementa√ß√£o do diagn√≥stico V789 com todas as exce√ß√µes no analisador PVS-Studio leva apenas 118 linhas de c√≥digo, das quais 13 s√£o coment√°rios.  Ou seja, √© um diagn√≥stico muito simples, que pode ser facilmente programado de maneira cl√°ssica. <br><br>  A situa√ß√£o ser√° semelhante a qualquer outra inova√ß√£o que apare√ßa em outros idiomas.  Como se costuma dizer, h√° algo em que pensar. <br><br>  <b>A terceira nuance.</b>  <b>Documenta√ß√£o</b> <br><br>  Um componente importante de qualquer analisador est√°tico √© a documenta√ß√£o que descreve cada diagn√≥stico.  Sem ele, ser√° extremamente dif√≠cil ou imposs√≠vel usar o analisador.  Na <a href="https://www.viva64.com/en/w/">documenta√ß√£o do</a> PVS-Studio, temos uma descri√ß√£o de cada diagn√≥stico, que fornece um exemplo de c√≥digo incorreto e como corrigi-lo.  Tamb√©m fornecemos o link para o <a href="https://cwe.mitre.org/">CWE</a> , onde √© poss√≠vel ler uma descri√ß√£o alternativa do problema.  E, ainda assim, √†s vezes os usu√°rios n√£o entendem algo e nos fazem perguntas esclarecedoras. <br><br>  No caso de analisadores est√°ticos baseados em ML, o problema da documenta√ß√£o √©, de alguma forma, oculto.  Sup√µe-se que o analisador simplesmente aponte para um local que lhe pare√ßa suspeito e que possa at√© sugerir como consert√°-lo.  A decis√£o de fazer ou n√£o uma edi√ß√£o depende da pessoa.  √â a√≠ que o problema come√ßa ... N√£o √© f√°cil tomar uma decis√£o sem poder ler, o que faz o analisador parecer suspeito de um determinado local no c√≥digo. <br><br>  Obviamente, em alguns casos, tudo ser√° √≥bvio.  Suponha que o analisador aponte para este c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(src + <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(p, src);</code> </pre> <br>  E sugira que a substituamos por: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(src) + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(p, src);</code> </pre> <br>  √â imediatamente claro que o programador cometeu um erro de digita√ß√£o e adicionou 1 no lugar errado.  Como resultado, menos mem√≥ria ser√° alocada que o necess√°rio. <br><br>  Aqui est√° tudo claro, mesmo sem documenta√ß√£o.  No entanto, esse nem sempre ser√° o caso. <br><br>  Imagine que o analisador "silenciosamente" aponte para este c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint8 *hash_stage2)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE); }</code> </pre> <br>  E sugere que alteremos o tipo de caractere do valor de retorno para int: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint8 *hash_stage2)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE); }</code> </pre> <br>  N√£o h√° documenta√ß√£o para o aviso.  Aparentemente, tamb√©m n√£o haver√° texto na mensagem do aviso, se estivermos falando de um analisador completamente independente. <br><br>  O que devemos fazer?  Qual a diferen√ßa?  Vale a pena fazer uma substitui√ß√£o? <br><br>  Na verdade, eu poderia me arriscar e concordar em corrigir o c√≥digo.  Embora concordar com as corre√ß√µes sem entend√™-las seja uma pr√°tica grosseira ... :) Voc√™ pode examinar a descri√ß√£o da fun√ß√£o <a href="http://www.cplusplus.com/reference/cstring/memcmp/"><i>memcmp</i></a> e descobrir que a fun√ß√£o realmente retorna valores como <i>int</i> : 0, mais que zero e menos que zero.  Mas ainda n√£o est√° claro por que fazer edi√ß√µes, se o c√≥digo j√° estiver funcionando bem. <br><br>  Agora, se voc√™ n√£o souber qual √© a edi√ß√£o, confira a descri√ß√£o do diagn√≥stico da <a href="https://www.viva64.com/en/w/v642/">V642</a> .  Torna-se imediatamente claro que este √© um bug real.  Al√©m disso, pode causar uma vulnerabilidade. <br><br>  Talvez o exemplo n√£o parecesse convincente.  Afinal, o analisador sugeriu um c√≥digo que provavelmente seria melhor.  Ok  Vejamos outro exemplo de pseudoc√≥digo, desta vez, para uma mudan√ßa, em Java. <br><br><pre> <code class="cpp hljs">ObjectOutputStream out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectOutputStream(....); SerializedObject obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializedObject(); obj.state = <span class="hljs-number"><span class="hljs-number">100</span></span>; out.writeObject(obj); obj.state = <span class="hljs-number"><span class="hljs-number">200</span></span>; out.writeObject(obj); out.close();</code> </pre> <br>  H√° um objeto.  Est√° serializando.  Em seguida, o estado do objeto muda e √© serializado novamente.  Parece bom.  Agora imagine que, de repente, o analisador n√£o gosta do c√≥digo e deseja substitu√≠-lo pelo seguinte: <br><br><pre> <code class="cpp hljs">ObjectOutputStream out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectOutputStream(....); SerializedObject obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializedObject(); obj.state = <span class="hljs-number"><span class="hljs-number">100</span></span>; out.writeObject(obj); obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializedObject(); <span class="hljs-comment"><span class="hljs-comment">// The line is added obj.state = 200; out.writeObject(obj); out.close();</span></span></code> </pre> <br>  Em vez de alterar o objeto e reescrev√™-lo, um novo objeto √© criado e ser√° serializado. <br><br>  N√£o h√° descri√ß√£o do problema.  Nenhuma documenta√ß√£o.  O c√≥digo ficou mais longo.  Por alguma raz√£o, um novo objeto √© criado.  Voc√™ est√° pronto para fazer essa edi√ß√£o no seu c√≥digo? <br><br>  Voc√™ dir√° que n√£o est√° claro.  Na verdade, √© incompreens√≠vel.  E ser√° assim o tempo todo.  Trabalhar com um analisador "silencioso" ser√° um estudo intermin√°vel, na tentativa de entender por que o analisador n√£o gosta de nada. <br><br>  Se houver documenta√ß√£o, tudo se torna transparente.  A classe <i>java.io.ObjectOuputStream</i> usada para serializa√ß√£o, armazena em cache os objetos gravados.  Isso significa que o mesmo objeto n√£o ser√° serializado duas vezes.  A classe serializa o objeto uma vez e, na segunda vez, apenas grava no fluxo uma refer√™ncia ao mesmo primeiro objeto.  Leia mais: <a href="https://www.viva64.com/en/w/v6076/">V6076</a> - A serializa√ß√£o recorrente usar√° o estado do objeto em cache desde a primeira serializa√ß√£o. <br><br>  Esperamos ter conseguido explicar a import√¢ncia da documenta√ß√£o.  A√≠ vem a pergunta.  Como a documenta√ß√£o do analisador baseado em ML ser√° exibida? <br><br>  Quando um analisador de c√≥digo cl√°ssico √© desenvolvido, tudo √© simples e claro.  H√° um padr√£o de erros.  N√≥s o descrevemos na documenta√ß√£o e implementamos o diagn√≥stico. <br><br>  No caso de ML, o processo √© inverso.  Sim, o analisador pode observar uma anomalia no c√≥digo e apontar para ele.  Mas n√£o sabe nada sobre a ess√™ncia do defeito.  Ele n√£o entende e n√£o diz por que voc√™ n√£o pode escrever um c√≥digo assim.  Essas s√£o abstra√ß√µes de n√≠vel muito alto.  Dessa forma, o analisador tamb√©m deve aprender a ler e <b>entender a</b> documenta√ß√£o das fun√ß√µes. <br><br>  Como eu disse, como o problema da documenta√ß√£o √© evitado nos artigos sobre aprendizado de m√°quina, n√£o estamos prontos para nos aprofundar nisso.  Apenas outra grande nuance que falamos. <br><br>  <b>Nota</b>  Voc√™ poderia argumentar que a documenta√ß√£o √© opcional.  O analisador pode se referir a muitos exemplos de corre√ß√µes no GitHub e a pessoa, examinando os commit e os coment√°rios, entender√° o que √© o qu√™.  Sim √© verdade.  Mas a ideia n√£o parece atraente.  Aqui, o analisador √© o cara mau, que mais confunde um programador do que o ajuda. <br><br>  <b>Quarta nuance.</b>  <b>Idiomas altamente especializados.</b> <br><br>  A abordagem descrita n√£o √© aplic√°vel a linguagens altamente especializadas, para as quais a an√°lise est√°tica tamb√©m pode ser extremamente √∫til.  O motivo √© que o GitHub e outras fontes simplesmente n√£o t√™m uma base de c√≥digo fonte grande o suficiente para fornecer um aprendizado eficaz. <br><br>  Vejamos isso usando um exemplo concreto.  Primeiro, vamos ao GitHub e procuraremos reposit√≥rios para a popular linguagem Java. <br><br>  Resultado: idioma: "Java": <b>3.128.884</b> resultados dispon√≠veis do reposit√≥rio <br><br>  Agora pegue o idioma especializado "1C Enterprise" usado em aplicativos de contabilidade produzidos pela empresa russa <a href="https://ru.wikipedia.org/wiki/1%25D0%25A1">1C</a> . <br><br>  Resultado: idioma: ‚Äú1C Enterprise‚Äù: <b>551</b> resultados dispon√≠veis no reposit√≥rio <br><br>  Talvez os analisadores n√£o sejam necess√°rios para esse idioma?  N√£o, eles s√£o.  Existe uma necessidade pr√°tica de analisar esses programas e j√° existem analisadores apropriados.  Por exemplo, existe o plug-in SonarQube 1C (BSL), produzido pela empresa " <a href="https://silverbulleters.org/">Silver Bullet</a> ". <br><br>  Penso que n√£o s√£o necess√°rias explica√ß√µes espec√≠ficas sobre o motivo pelo qual a abordagem de ML ser√° dif√≠cil para idiomas especializados. <br><br>  <b>A quinta nuance.</b>  <b>C, C ++, #include</b> . <br><br>  Os artigos sobre an√°lise de c√≥digo est√°tico baseados em ML s√£o principalmente sobre linguagens como Java, JavaScript e Python.  Isso √© explicado por sua extrema popularidade.  Quanto ao C e C ++, eles s√£o meio ignorados, mesmo que voc√™ n√£o possa cham√°-los de impopulares. <br><br>  Sugerimos que n√£o se trata de sua popularidade / perspectiva promissora, mas de problemas com as linguagens C e C ++.  E agora vamos trazer √† tona um problema desconfort√°vel. <br><br>  Um arquivo c / cpp abstrato pode ser muito dif√≠cil de compilar.  Pelo menos voc√™ n√£o pode carregar um projeto no GitHub, escolha um arquivo cpp aleat√≥rio e apenas compile-o.  Agora vamos explicar o que tudo isso tem a ver com o ML. <br><br>  Ent√£o, queremos ensinar o analisador.  Fizemos o download de um projeto no GitHub.  Conhecemos o patch e assumimos que ele corrige o bug.  Queremos que esta edi√ß√£o seja um exemplo de aprendizado.  Em outras palavras, temos um arquivo .cpp antes e depois da edi√ß√£o. <br><br>  √â a√≠ que o problema come√ßa.  N√£o basta apenas estudar as corre√ß√µes.  Contexto completo tamb√©m √© necess√°rio.  Voc√™ precisa conhecer a declara√ß√£o das classes usadas, os prot√≥tipos das fun√ß√µes usadas, voc√™ precisa saber como as macros se expandem e assim por diante.  E para fazer isso, voc√™ precisa executar o <a href="https://en.wikipedia.org/wiki/C_preprocessor">pr√©-processamento de</a> arquivo completo. <br><br>  Vejamos o exemplo.  No in√≠cio, o c√≥digo era assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Class::IsMagicWord() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_name == <span class="hljs-string"><span class="hljs-string">"ML"</span></span>; }</code> </pre> <br>  Foi corrigido desta maneira: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Class::IsMagicWord() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(m_name, <span class="hljs-string"><span class="hljs-string">"ML"</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  O analisador deve come√ßar a aprender para sugerir <i>(x == "y") a</i> substitui√ß√£o do forstrcmp (x, "y")? <br><br>  Voc√™ n√£o pode responder a essa pergunta sem saber como o membro <i>m_name</i> √© declarado na classe.  Pode haver, por exemplo, essas op√ß√µes: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *m_name; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_name; };</code> </pre> <br>  Edi√ß√µes ser√£o feitas, caso falemos de um ponteiro comum.  Se n√£o levarmos em conta o tipo de vari√°vel, o analisador poder√° aprender a emitir avisos bons e ruins (para o caso com <i>std :: string</i> ). <br><br>  As declara√ß√µes de classe geralmente est√£o localizadas nos arquivos de cabe√ßalho.  Aqui havia a necessidade de executar o pr√©-processamento para obter todas as informa√ß√µes necess√°rias.  √â extremamente importante para C e C ++. <br><br>  Se algu√©m disser que √© poss√≠vel fazer sem pr√©-processamento, ele √© uma fraude ou n√£o est√° familiarizado com as linguagens C ou C ++. <br><br>  Para reunir todas as informa√ß√µes necess√°rias, voc√™ precisa do pr√©-processamento correto.  Para fazer isso, voc√™ precisa saber onde e quais arquivos de cabe√ßalho est√£o localizados, quais macros s√£o definidas durante o processo de cria√ß√£o.  Voc√™ tamb√©m precisa saber como um arquivo cpp espec√≠fico √© compilado. <br><br>  Esse √© o problema.  N√£o basta compilar o arquivo (ou melhor, especificar a chave do compilador para gerar um arquivo de pr√©-processo).  Precisamos descobrir como esse arquivo √© compilado.  Esta informa√ß√£o est√° nos scripts de constru√ß√£o, mas a quest√£o √© como obt√™-la a partir da√≠.  Em geral, a tarefa √© complicada. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91b/aaf/95a/91baaf95a62415697b40f23298d115c2.png"></div><br><br>  Al√©m disso, muitos projetos no GitHub s√£o uma bagun√ßa.  Se voc√™ pegar um projeto abstrato a partir da√≠, geralmente precisar√° mexer para compil√°-lo.  Um dia voc√™ n√£o tem uma biblioteca e precisa encontr√°-lo e baix√°-lo manualmente.  Outro dia, √© utilizado algum tipo de sistema de cria√ß√£o auto-escrito, que precisa ser tratado.  Poderia ser qualquer coisa.  √Äs vezes, o projeto baixado simplesmente se recusa a criar e precisa ser ajustado de alguma forma.  Voc√™ n√£o pode simplesmente obter e obter automaticamente uma representa√ß√£o pr√©-processada (.i) para arquivos .cpp.  Pode ser complicado, mesmo quando feito manualmente. <br><br>  Podemos dizer, bem, que o problema com projetos que n√£o s√£o de constru√ß√£o √© compreens√≠vel, mas n√£o crucial.  Vamos trabalhar apenas com projetos que podem ser constru√≠dos.  Ainda h√° a tarefa de pr√©-processar um arquivo espec√≠fico.  Sem mencionar os casos em que lidamos com alguns compiladores especializados, por exemplo, para sistemas embarcados. <br><br>  Afinal, o problema descrito n√£o √© intranspon√≠vel.  No entanto, tudo isso √© muito dif√≠cil e exige muito trabalho.  No caso de C e C ++, o c√≥digo fonte localizado no GitHub n√£o faz nada.  H√° muito trabalho a ser feito para aprender a executar automaticamente os compiladores. <br><br>  <b>Nota</b>  Se o leitor ainda n√£o entender a profundidade do problema, convidamos voc√™ a participar da experi√™ncia a seguir.  Pegue dez projetos aleat√≥rios de tamanho m√©dio do GitHub e tente compil√°-los e obtenha a vers√£o pr√©-processada para arquivos .cpp.  Depois disso, a pergunta sobre o labor desta tarefa desaparecer√° :). <br><br>  Pode haver problemas semelhantes com outras linguagens, mas eles s√£o particularmente √≥bvios em C e C ++. <br><br>  <b>Sexta nuance.</b>  <b>O pre√ßo da elimina√ß√£o de falsos positivos.</b> <br><br>  Os analisadores est√°ticos s√£o propensos a gerar falsos positivos e precisamos refinar constantemente os diagn√≥sticos para reduzir o n√∫mero de falsos avisos. <br><br>  Agora voltaremos ao diagn√≥stico <a href="https://www.viva64.com/en/w/v789/">V789</a> considerado anteriormente, detectando altera√ß√µes de cont√™ineres dentro do loop for baseado em intervalo.  Digamos que n√£o tenhamos cuidado o suficiente ao escrev√™-lo, e o cliente relata um falso positivo.  Ele escreve que o analisador n√£o leva em considera√ß√£o o cen√°rio quando o loop termina depois que o cont√™iner √© alterado e, portanto, n√£o h√° problema.  Em seguida, ele fornece o seguinte exemplo de c√≥digo em que o analisador fornece um falso positivo: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; numbers; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num : numbers) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) { numbers.push_back(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">// or, for example, return } }</span></span></code> </pre> <br>  Sim, √© uma falha.  Em um analisador cl√°ssico, sua elimina√ß√£o √© extremamente r√°pida e barata.  No PVS-Studio, a implementa√ß√£o desta exce√ß√£o consiste em 26 linhas de c√≥digo. <br><br>  Essa falha tamb√©m pode ser corrigida quando o analisador √© constru√≠do sobre algoritmos de aprendizado.  Com certeza, isso pode ser ensinado coletando dezenas ou centenas de exemplos de c√≥digo que devem ser considerados corretos. <br><br>  Novamente, a quest√£o n√£o est√° na viabilidade, mas na abordagem pr√°tica.  Suspeitamos que a luta contra falsos positivos espec√≠ficos, que incomodam os clientes, seja muito mais cara no caso de BC.  Ou seja, o suporte ao cliente em termos de elimina√ß√£o de falsos positivos custar√° mais dinheiro. <br><br>  <b>S√©tima nuance.</b>  <b>Recursos raramente usados ‚Äã‚Äãe cauda longa.</b> <br><br>  Anteriormente, lidamos com o problema de idiomas altamente especializados, para os quais talvez n√£o seja o c√≥digo-fonte suficiente para o aprendizado.  Um problema semelhante ocorre com fun√ß√µes raramente usadas (do sistema, WinAPI, de bibliotecas populares etc.). <br><br>  Se estamos falando sobre essas fun√ß√µes da linguagem C, como <i>strcmp</i> , existe realmente uma base para o aprendizado.  GitHub, resultados de c√≥digo dispon√≠veis: <br><br><ul><li>  strcmp - 40.462.158 </li><li>  stricmp - 1.256.053 </li></ul><br>  Sim, existem muitos exemplos de uso.  Talvez o analisador aprenda a observar, por exemplo, os seguintes padr√µes: <br><br><ul><li>  √â estranho se a string √© comparada consigo mesma.  √â consertado. </li><li>  √â estranho se um dos ponteiros for NULL.  √â consertado. </li><li>  √â estranho que o resultado dessa fun√ß√£o n√£o seja usado.  √â consertado. </li><li>  E assim por diante </li></ul><br>  N√£o √© legal?  N√£o.  Aqui enfrentamos o problema da "cauda longa".  Muito brevemente o ponto da "cauda longa" a seguir.  N√£o √© pr√°tico vender apenas o Top50 dos livros mais populares e agora lidos em uma livraria.  Sim, cada um desses livros ser√° comprado, digamos, 100 vezes mais frequentemente do que os livros que n√£o est√£o nesta lista.  No entanto, a maior parte da receita ser√° composta por outros livros que, como dizem, encontram seu leitor.  Por exemplo, uma loja online Amazon.com recebe mais da metade dos lucros do que est√° fora dos 130.000 "itens mais populares". <br><br>  Existem fun√ß√µes populares e existem poucas.  Existem impopulares, mas existem muitos.  Por exemplo, existem as seguintes varia√ß√µes da fun√ß√£o de compara√ß√£o de cadeias: <br><br><ul><li>  g_ascii_strncasecmp - 35.695 </li><li>  lstrcmpiA - 27.512 </li><li>  _wcsicmp_l - 5,737 </li><li>  _strnicmp_l - 5.848 </li><li>  _mbscmp_l - 2.458 </li><li>  e outros </li></ul><br>  Como voc√™ pode ver, eles s√£o usados ‚Äã‚Äãcom muito menos frequ√™ncia, mas quando voc√™ os usa, pode cometer os mesmos erros.  Existem poucos exemplos para identificar padr√µes.  No entanto, essas fun√ß√µes n√£o podem ser ignoradas.  Individualmente, eles raramente s√£o usados, mas muitos c√≥digos s√£o escritos com o uso deles, o que √© melhor verificar.  √â a√≠ que a "cauda longa" se mostra. <br><br>  No PVS-Studio, anotamos recursos manualmente.  Por exemplo, no momento cerca de 7.200 fun√ß√µes foram anotadas para C e C ++.  √â isso que marcamos: <br><br><ul><li>  Winapi </li><li>  Biblioteca C padr√£o, </li><li>  Biblioteca de modelos padr√£o (STL), </li><li>  glibc (Biblioteca GNU C) </li><li>  Qt </li><li>  Mfc </li><li>  zlib </li><li>  libpng </li><li>  Openssl </li><li>  e outros </li></ul><br>  Por um lado, parece um caminho sem sa√≠da.  Voc√™ n√£o pode anotar tudo.  Por outro lado, funciona. <br><br>  Agora aqui est√° a quest√£o.  Quais benef√≠cios o ML pode ter?  Vantagens significativas n√£o s√£o t√£o √≥bvias, mas voc√™ pode ver a complexidade. <br><br>  Voc√™ pode argumentar que os algoritmos criados no ML encontrar√£o padr√µes com fun√ß√µes usadas com freq√º√™ncia e eles n√£o precisam ser anotados.  Sim, √© verdade.  No entanto, n√£o h√° problema em anotar independentemente fun√ß√µes populares como <i>strcmp</i> ou <i>malloc</i> . <br><br>  No entanto, a cauda longa causa problemas.  Voc√™ pode ensinar fazendo exemplos sint√©ticos.  No entanto, voltamos √† parte do artigo, onde diz√≠amos que era mais f√°cil e r√°pido escrever diagn√≥sticos cl√°ssicos, em vez de gerar muitos exemplos. <br><br>  Tomemos, por exemplo, uma fun√ß√£o, como <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/fread-nolock"><i>_fread_nolock</i></a> .  Obviamente, √© usado com menos frequ√™ncia do que o <i>medo</i> .  Mas quando voc√™ o usa, pode cometer os mesmos erros.  Por exemplo, o buffer deve ser grande o suficiente.  Esse tamanho n√£o deve ser menor que o resultado da multiplica√ß√£o do segundo e terceiro argumento.  Ou seja, voc√™ deseja encontrar esse c√≥digo incorreto: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> buffer[<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> n = _fread_nolock(buffer, size_of(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), <span class="hljs-number"><span class="hljs-number">100</span></span>, stream);</code> </pre> <br>  Aqui est√° a apar√™ncia da anota√ß√£o dessa fun√ß√£o no PVS-Studio: <br><br><pre> <code class="cpp hljs">C_<span class="hljs-string"><span class="hljs-string">"size_t _fread_nolock"</span></span> <span class="hljs-string"><span class="hljs-string">"(void * _DstBuf, size_t _ElementSize, size_t _Count, FILE * _File);"</span></span> ADD(HAVE_STATE | RET_SKIP | F_MODIFY_PTR_1, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-string"><span class="hljs-string">"_fread_nolock"</span></span>, POINTER_1, BYTE_COUNT, COUNT, POINTER_2). Add_Read(from_2_3, to_return, buf_1). Add_DataSafetyStatusRelations(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>  √Ä primeira vista, essa anota√ß√£o pode parecer dif√≠cil, mas, na verdade, quando voc√™ come√ßa a escrev√™-la, torna-se simples.  Al√©m disso, √© um c√≥digo somente para grava√ß√£o.  Escreveu e esqueceu.  As anota√ß√µes mudam raramente. <br><br>  Agora vamos falar sobre essa fun√ß√£o do ponto de vista do ML.  O GitHub n√£o vai nos ajudar.  Existem cerca de 15.000 men√ß√µes a essa fun√ß√£o.  Existe ainda menos c√≥digo bom.  Uma parte significativa dos resultados da pesquisa inclui o seguinte: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> fread_unlocked _fread_nolock</span></span></code> </pre> <br>  Quais s√£o as op√ß√µes? <ol><li>  N√£o fa√ßa nada.  √â um caminho para lugar nenhum. </li><li>  Imagine, ensine o analisador escrevendo centenas de exemplos apenas para uma fun√ß√£o, para que o analisador compreenda a interconex√£o entre o buffer e outros argumentos.  Sim, voc√™ pode fazer isso, mas √© economicamente irracional.  √â uma rua sem sa√≠da. </li><li>  Voc√™ pode criar uma maneira semelhante √† nossa quando as anota√ß√µes de fun√ß√µes ser√£o definidas manualmente.  √â uma maneira boa e sensata.  Isso √© apenas ML, que n√£o tem nada a ver com isso :).  Este √© um retrocesso √† maneira cl√°ssica de escrever analisadores est√°ticos. </li></ol><br>  Como voc√™ pode ver, ML e a cauda longa dos recursos raramente usados ‚Äã‚Äãn√£o combinam. <br><br>  Nesse ponto, havia pessoas relacionadas √† ML que se opuseram e disseram que n√£o t√≠nhamos levado em conta a op√ß√£o quando o analisador aprenderia todas as fun√ß√µes e tiraria conclus√µes do que estava fazendo.  Aqui, aparentemente, ou n√≥s n√£o entendemos os especialistas ou eles n√£o entendem o que queremos dizer. <br><br>  Corpos de fun√ß√µes podem ser desconhecidos.  Por exemplo, poderia ser uma fun√ß√£o relacionada ao WinAPI.  Se essa √© uma fun√ß√£o raramente usada, como o analisador entender√° o que est√° fazendo?  Podemos fantasiar que o analisador utilizar√° o pr√≥prio Google, encontre uma descri√ß√£o da fun√ß√£o, leia e <b>entenda</b> .  Al√©m disso, teria que tirar conclus√µes de alto n√≠vel da documenta√ß√£o.  A descri√ß√£o <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/fread-nolock"><i>_fread_nolock</i></a> n√£o diz nada sobre a interconex√£o entre o buffer, o segundo e o terceiro argumento.  Essa compara√ß√£o deve ser deduzida por intelig√™ncia artificial por si s√≥, com base no entendimento dos princ√≠pios gerais de programa√ß√£o e como a linguagem C ++ funciona.  Acho que dever√≠amos pensar seriamente em 20 anos. <br><br>  Corpos de fun√ß√µes podem estar dispon√≠veis, mas pode n√£o haver utilidade disso.  Vejamos uma fun√ß√£o, como <i>memmove</i> .  √â frequentemente implementado em algo como isto: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memmove</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *dest, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> __builtin___memmove_chk(dest, src, len, __builtin_object_size(dest, <span class="hljs-number"><span class="hljs-number">0</span></span>)); }</code> </pre> <br>  O que √© <i>__builtin___memmove_chk</i> ?  Essa √© uma fun√ß√£o intr√≠nseca que o pr√≥prio compilador j√° est√° implementando.  Esta fun√ß√£o n√£o possui o c√≥digo fonte. <br><br>  Ou <i>memmove</i> pode ser algo como isto: <a href="">a primeira vers√£o do assembly</a> .  Voc√™ pode ensinar o analisador a entender as diferentes op√ß√µes de montagem, mas essa abordagem parece errada. <br><br>  Ok, √†s vezes os corpos de fun√ß√µes s√£o realmente conhecidos.  Al√©m disso, tamb√©m sabemos corpos de fun√ß√µes no c√≥digo do usu√°rio.  Parece que, neste caso, o ML obt√©m enormes vantagens ao ler e entender o que todas essas fun√ß√µes fazem. <br><br>  No entanto, mesmo neste caso, estamos cheios de pessimismo.  Esta tarefa √© muito complexa.  √â complicado at√© para um humano.  Pense em como √© dif√≠cil para voc√™ entender o c√≥digo que n√£o escreveu.  Se √© dif√≠cil para uma pessoa, por que essa tarefa deve ser f√°cil para uma IA?  Na verdade, a IA tem um grande problema na compreens√£o de conceitos de alto n√≠vel.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se estamos falando sobre a compreens√£o do c√≥digo, n√£o podemos prescindir da capacidade de abstrair dos detalhes da implementa√ß√£o e considerar o algoritmo em um n√≠vel alto. Parece que essa discuss√£o tamb√©m pode ser adiada por 20 anos. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outras nuances</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> H√° outros pontos que tamb√©m devem ser levados em considera√ß√£o, mas n√£o nos aprofundamos neles. A prop√≥sito, o artigo acaba sendo bastante longo. Portanto, listaremos brevemente algumas outras nuances, deixando-as para reflex√£o do leitor.</font></font><br><br><ul><li> <b>Outdated recommendations.</b> As mentioned, languages change, and recommendations for their use change, respectively. If the analyzer learns on old source code, it might start issuing outdated recommendations at some point. Example. Formerly, C++ programmers have been recommended using <a href="http://www.cplusplus.com/reference/memory/auto_ptr/"><i>auto_ptr</i></a> instead of half-done pointers. This smart pointer is now considered obsolete and it is recommended that you use <i>unique_ptr</i> . </li><li> <b>Data models.</b> At the very least, C and C++ languages have such a thing as a <a href="https://www.viva64.com/en/t/0012/">data model</a> . This means that data types have different number of bits across platforms. If you don't take this into account, you can incorrectly teach the analyzer. For example, in Windows 32/64 the <i>long</i> type always has 32 bits. But in Linux, its size will vary and take 32/64 bits depending on the platform's number of bits. Without taking all this into account, the analyzer can learn to miscalculate the size of the types and structures it forms. But the types also align in different ways. All this, of course, can be taken into account. You can teach the analyzer to know about the size of the types, their alignment and mark the projects (indicate how they are building). However, all this is an additional complexity, which is not mentioned in the research articles. </li><li> <b>Behavioral unambiguousness.</b> Since we're talking about ML, the analysis result is more likely to have probabilistic nature. That is, sometimes the erroneous pattern will be recognized, and sometimes not, depending on how the code is written. From our experience, we know that the user is extremely irritated by the ambiguity of the analyzer's behavior. He wants to know exactly which pattern will be considered erroneous and which will not, and why. In the case of the classical analyzer developing approach, this problem is poorly expressed. Only sometimes we need to explain our clients why there is a/there is no analyzer warning and how the algorithm works, what exceptions are handled in it. Algorithms are clear and everything can always be easily explained. An example of this kind of communication: " <a href="https://www.viva64.com/en/b/0612/">False Positives in PVS-Studio: How Deep the Rabbit Hole Goes</a> ". It's not clear how the described problem will be solved in the analyzers built on ML. </li></ul><br><h2> Conclusions </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o negamos as perspectivas da dire√ß√£o do ML, incluindo sua aplica√ß√£o em termos de an√°lise de c√≥digo est√°tico. O ML pode ser potencialmente usado em erros de localiza√ß√£o de tarefas, ao filtrar falsos positivos, ao procurar novos padr√µes de erro (ainda n√£o descritos) e assim por diante. No entanto, n√£o compartilhamos o otimismo que permeia os artigos dedicados ao ML em termos de an√°lise de c√≥digo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neste artigo, destacamos alguns problemas nos quais um ter√° que ser resolvido se ele usar o ML. As nuances descritas negam amplamente os benef√≠cios da nova abordagem. Al√©m disso, as antigas abordagens cl√°ssicas da implementa√ß√£o de analisadores s√£o mais lucrativas e economicamente vi√°veis.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curiosamente, os artigos dos adeptos da metodologia ML n√£o mencionam essas armadilhas. </font><font style="vertical-align: inherit;">Bem, nada de novo. </font><font style="vertical-align: inherit;">O ML provoca certo hype e provavelmente n√£o devemos esperar uma avalia√ß√£o equilibrada de seus apologistas em rela√ß√£o √† aplicabilidade do ML em tarefas de an√°lise de c√≥digo est√°tico. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do nosso ponto de vista, o aprendizado de m√°quina ir√° preencher um nicho de tecnologias, usadas em analisadores est√°ticos, juntamente com a an√°lise de fluxo de controle, execu√ß√µes simb√≥licas e outras. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A metodologia da an√°lise est√°tica pode se beneficiar da introdu√ß√£o do ML, mas n√£o exagera nas possibilidades dessa tecnologia.</font></font><br><br><h2>  PS </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o artigo √© geralmente cr√≠tico, alguns podem pensar que temos medo do novo e, como os </font></font><a href="https://en.wikipedia.org/wiki/Luddite"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">luditas se</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> voltaram contra o ML por medo de perder o mercado para ferramentas de an√°lise est√°tica.</font></font><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/659/1f4/7fa/6591f47faa384c2ac9472bc1f5eeacb9.png" alt="Luddites"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o, n√£o temos medo. Simplesmente n√£o vemos sentido em gastar dinheiro com abordagens ineficientes no desenvolvimento do analisador de c√≥digo PVS-Studio. De uma forma ou de outra, adotaremos o ML. Al√©m disso, alguns diagn√≥sticos j√° cont√™m elementos de algoritmos de autoaprendizagem. No entanto, seremos definitivamente muito conservadores e tomaremos apenas o que claramente ter√° um efeito maior do que as abordagens cl√°ssicas, baseadas em loops e ifs :). Afinal, precisamos criar uma ferramenta eficaz, e n√£o trabalhar com uma concess√£o :). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O artigo foi escrito pelo motivo de mais e mais perguntas serem feitas sobre o assunto e quer√≠amos ter um artigo expositivo que colocasse tudo em seu lugar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obrigado pela aten√ß√£o. Convidamos voc√™ a ler o artigo "</font></font><a href="https://www.viva64.com/en/b/0687/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que voc√™ deve escolher o est√°tico analisador PVS-Studio para integrar-se ao seu processo de desenvolvimento</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . "</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt484202/">https://habr.com/ru/post/pt484202/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt484192/index.html">F√°cil e f√°cil de implantar aplicativos no cartucho Tarantool (parte 2)</a></li>
<li><a href="../pt484194/index.html">Kubernetes traduzido em crian√ßas</a></li>
<li><a href="../pt484196/index.html">Gravando som JS de um microfone ou coment√°rios de voz</a></li>
<li><a href="../pt484198/index.html">Verso da moeda: quem ganhou e perdeu com o crescimento das a√ß√µes da Tesla</a></li>
<li><a href="../pt484200/index.html">Como definir metas para alcan√ß√°-las</a></li>
<li><a href="../pt484204/index.html">FTCODE ransomware sem arquivo agora rouba contas</a></li>
<li><a href="../pt484206/index.html">Uso de mixins no Dart</a></li>
<li><a href="../pt484208/index.html">Usando o aprendizado de m√°quina na an√°lise est√°tica do c√≥digo-fonte do programa</a></li>
<li><a href="../pt484212/index.html">Material gratuito para karma - a hist√≥ria de uma startup bielorrussa que muda o princ√≠pio do consumo</a></li>
<li><a href="../pt484214/index.html">Tensores em TensorFlow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>