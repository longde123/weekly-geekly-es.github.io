<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗃️ 👩‍🎨 👩‍🏭 Datang, lihat, digeneralisasi: direndam dalam Java Generics 👨🏾‍🤝‍👨🏽 👨‍👨‍👧 👩🏾‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Java Generics adalah salah satu perubahan paling signifikan dalam sejarah bahasa Java. Generik yang tersedia dengan Java 5 telah menjadikan penggunaan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Datang, lihat, digeneralisasi: direndam dalam Java Generics</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/416413/">  Java Generics adalah salah satu perubahan paling signifikan dalam sejarah bahasa Java.  Generik yang tersedia dengan Java 5 telah menjadikan penggunaan Java Collection Framework lebih mudah, lebih nyaman, dan lebih aman.  Kesalahan yang terkait dengan penggunaan tipe yang salah sekarang terdeteksi pada tahap kompilasi.  Ya, dan bahasa Jawa sendiri menjadi lebih aman.  Terlepas dari kesederhanaan jenis generik yang tampak, banyak pengembang mengalami kesulitan menggunakannya.  Dalam posting ini saya akan berbicara tentang fitur-fitur bekerja dengan Java Generics, sehingga Anda memiliki lebih sedikit kesulitan ini.  Berguna jika Anda bukan guru umum, dan akan membantu menghindari banyak kesulitan saat membahas topik tersebut. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/770/63e/016/77063e016a04378dbffb1372c68e33cc.png"><br><a name="habracut"></a><br><h2>  Bekerja dengan koleksi </h2><br>  Misalkan bank perlu menghitung jumlah tabungan di rekening pelanggan.  Sebelum munculnya "obat generik," metode penghitungan jumlah tampak seperti ini: <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List accounts)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, n = accounts.size(); i &lt; n; i++) {       Object account = accounts.get(i);       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (account <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Account) {           sum += ((Account) account).getAmount();       }   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; }</code> </pre> <br>  Kami mengulang, menelusuri daftar akun, dan memeriksa apakah elemen dari daftar ini benar-benar turunan dari kelas <code>Account</code> - yaitu, akun pengguna.  Jenis objek kami dari kelas <code>Account</code> dan metode <code>getAmount</code> , yang mengembalikan jumlah dalam akun ini.  Kemudian mereka menyimpulkan semuanya dan mengembalikan jumlah total.  Diperlukan dua langkah: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (account <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Account) { <span class="hljs-comment"><span class="hljs-comment">// (1)</span></span></code> </pre> <br><pre> <code class="java hljs">sum += ((Account) account).getAmount(); <span class="hljs-comment"><span class="hljs-comment">// (2)</span></span></code> </pre> <br>  Jika Anda tidak memeriksa ( <code>instanceof</code> ) dari milik kelas <code>Account</code> , maka pada tahap kedua <code>ClassCastException</code> dimungkinkan - yaitu, crash program.  Karena itu, cek semacam itu wajib. <br><br>  Dengan munculnya Generics, kebutuhan untuk pengecekan dan pengecoran tipe telah menghilang: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSum2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Account&gt; accounts)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Account account : accounts) {      sum += account.getAmount();  }  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; }</code> </pre><br>  Sekarang metode <pre> <code class="hljs lisp">getSum2(<span class="hljs-name"><span class="hljs-name">List&lt;Account&gt;</span></span> accounts)</code> </pre>  menerima sebagai argumen hanya daftar objek <code>Account</code> kelas.  Pembatasan ini ditunjukkan dalam metode itu sendiri, dalam tanda tangannya, programmer tidak dapat mentransfer daftar lain - hanya daftar akun klien. <br><br>  Kita tidak perlu memeriksa tipe elemen dari daftar ini: itu tersirat oleh deskripsi tipe parameter metode <pre> <code class="hljs xml">List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Account</span></span></span><span class="hljs-tag">&gt;</span></span> accounts</code> </pre>  (dapat dibaca sebagai <code>   Account</code> ).  Dan kompiler akan melempar kesalahan jika terjadi kesalahan - yaitu, jika seseorang mencoba meneruskan daftar objek selain kelas <code>Account</code> ke metode ini. <br><br>  Pada baris kedua cek, kebutuhan juga hilang.  Jika perlu, <code>casting</code> akan dilakukan pada tahap kompilasi. <br><br><h2>  Prinsip substitusi </h2><br>  Prinsip substitusi dari Barbara Liskov adalah definisi spesifik dari subtipe dalam pemrograman berorientasi objek.  Gagasan Liskov tentang “subtipe” mendefinisikan konsep substitusi: jika <code>S</code> adalah subtipe dari <code>T</code> , maka objek tipe <code>T</code> dalam suatu program dapat digantikan oleh objek tipe <code>S</code> tanpa ada perubahan pada sifat yang diinginkan dari program ini. <br><br><table><tbody><tr><td>  <b>Jenis</b> <br></td><td>  <b>Subtipe</b> <br></td></tr><tr><td>  <i>Nomor</i> <br></td><td>  <i>Integer</i> <br></td></tr><tr><td>  <i>Daftar</i> &lt;E&gt; <br></td><td>  <i>ArrayList</i> &lt;E&gt; <br></td></tr><tr><td>  <i>Koleksi</i> &lt;E&gt; <br></td><td>  <i>Daftar</i> &lt;E&gt; <br></td></tr><tr><td>  <i>Berterima kasih</i> &lt;E&gt; <br></td><td>  <i>Koleksi</i> &lt;E&gt; <br></td></tr></tbody></table><br>  <i>Contoh / Jenis Hubungan Contoh</i> <br><br>  Berikut adalah contoh penggunaan prinsip substitusi di Jawa: <br><pre> <code class="java hljs">Number n = Integer.valueOf(<span class="hljs-number"><span class="hljs-number">42</span></span>); List&lt;Number&gt; aList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); Collection&lt;Number&gt; aCollection = aList; Iterable&lt;Number&gt; iterable = aCollection;</code> </pre> <br>  <code>Integer</code> adalah subtipe dari <code>Number</code> , oleh karena itu, variabel <code>n</code> type <code>Number</code> dapat diberi nilai yang dikembalikan oleh metode <code>Integer.valueOf(42)</code> . <br><br><h2>  Kovarian, contravariance dan invarian </h2><br>  Pertama, sedikit teori.  Kovarian adalah pelestarian hierarki pewarisan tipe sumber dalam tipe turunan dalam urutan yang sama.  Misalnya, jika <i>Kucing</i> adalah subtipe <i>Hewan</i> , maka Perangkat <i>&lt;Cats&gt;</i> adalah subtipe <i>dari Perangkat &lt;Hewan&gt;</i> .  Oleh karena itu, dengan mempertimbangkan prinsip substitusi, seseorang dapat melakukan penugasan berikut: <br><br>  <i>Many &lt;Hewan&gt; = Banyak &lt;Cats&gt;</i> <br><br>  Contravariance adalah pembalikan hirarki tipe sumber dalam tipe turunan.  Misalnya, jika <i>Kucing</i> adalah subtipe <code></code> , maka <i>Set &lt;Hewan&gt;</i> adalah subtipe dari <i>Set &lt;Cat&gt;</i> .  Oleh karena itu, dengan mempertimbangkan prinsip substitusi, seseorang dapat melakukan penugasan berikut: <br><br>  <i>Many &lt;Cats&gt; = Many &lt;Animals&gt;</i> <br><br>  Invariance - kurangnya pewarisan antara tipe turunan.  Jika <i>Kucing</i> adalah subtipe <i>Hewan</i> , maka Perangkat <i>&lt;Cats&gt;</i> bukan subtipe <i>dari Perangkat &lt;Hewan&gt;</i> dan Perangkat <i>&lt;Hewan&gt;</i> bukan subtipe <i>dari Perangkat &lt;Cat&gt;</i> . <br><br>  <b>Array di Jawa adalah kovarian</b> .  Tipe <code>S[]</code> adalah subtipe dari <code>T[]</code> jika <code>S</code> adalah subtipe dari <code>T</code>  Contoh Penugasan: <br><pre> <code class="java hljs">String[] strings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String[] {<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>}; Object[] arr = strings;</code> </pre><br>  Kami menetapkan tautan ke array string ke <code>arr</code> variabel, jenisnya adalah <code>« »</code> .  Jika array bukan kovarian, kami tidak akan dapat melakukan ini.  Java memungkinkan Anda untuk melakukan ini, program mengkompilasi dan berjalan tanpa kesalahan. <br><br><pre> <code class="java hljs">arr[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ArrayStoreException.      </span></span></code> </pre> <br>  Tetapi jika kita mencoba mengubah isi array melalui variabel <code>arr</code> dan menulis angka 42 di sana, kita akan mendapatkan <code>ArrayStoreException</code> pada tahap eksekusi program, karena 42 bukan string, tetapi angka.  Ini adalah kelemahan dari kovarians array Java: kita tidak dapat melakukan pemeriksaan pada tahap kompilasi, dan sesuatu mungkin sudah rusak saat runtime. <br><br>  <b>"Generik" tidak berubah.</b>  Berikut ini sebuah contoh: <br><pre> <code class="java hljs">List&lt;Integer&gt; ints = Arrays.asList(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>); List&lt;Number&gt; nums = ints; <span class="hljs-comment"><span class="hljs-comment">// compile-time error.      nums.set(2, 3.14); assert ints.toString().equals("[1, 2, 3.14]");</span></span></code> </pre> <br>  Jika Anda mengambil daftar bilangan bulat, maka itu bukan subtipe dari <code>Number</code> , atau subtipe lainnya.  Dia hanya subtipe dari dirinya sendiri.  Yaitu, <code>List &lt;Integer&gt;</code> adalah <code>List&lt;Integer&gt;</code> dan tidak ada yang lain.  Compiler akan memastikan bahwa variabel <code>ints</code> dideklarasikan sebagai daftar objek kelas <i>Integer yang</i> hanya berisi objek kelas <code>Integer</code> dan tidak ada yang lain.  Pada tahap kompilasi, pemeriksaan dilakukan, dan tidak ada yang akan jatuh pada runtime kami. <br><br><h2>  Kartu liar </h2><br>  Apakah Generik selalu invarian?  Tidak.  Saya akan memberikan contoh: <br><pre> <code class="java hljs">List&lt;Integer&gt; ints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(); List&lt;? extends Number&gt; nums = ints;</code> </pre> <br>  Ini adalah kovarians.  <code>List&lt;Integer&gt;</code> - subtipe <code>List&lt;? extends Number&gt;</code> <code>List&lt;? extends Number&gt;</code> <br><br><pre> <code class="java hljs">List&lt;Number&gt; nums = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Number&gt;(); List&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> Integer&gt; ints = nums;</code> </pre> <br>  Ini adalah penghinaan.  <code>List&lt;Number&gt;</code> adalah subtipe <code>List&lt;? super Integer&gt;</code>  <code>List&lt;? super Integer&gt;</code> . <br><br>  Catatan seperti <code>"? extends ..."</code> atau <code>"? super ..."</code> disebut wildcard atau wildcard, dengan batas atas ( <code>extends</code> ) atau batas bawah ( <code>super</code> ). <code>List&lt;? extends Number&gt;</code>  <code>List&lt;? extends Number&gt;</code> dapat berisi objek yang kelasnya <code>Number</code> atau diwarisi dari <code>Number</code> . <code>List&lt;? super Number&gt;</code>  <code>List&lt;? super Number&gt;</code> dapat berisi objek yang kelasnya <code>Number</code> atau yang <code>Number</code> adalah pewarisnya (supertype from <code>Number</code> ). <br><br><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/e86/5e1/836/e865e18363e605bc801e70474241d458.png"><br></td><td>  meluas <i>B</i> - wildcard dengan batas atas <br>  super <i>B</i> - wildcard dengan batas bawah <br>  di mana <i>B</i> - mewakili perbatasan <br><br>  Catatan bentuk T2 &lt;= T1 berarti bahwa himpunan tipe yang dijelaskan oleh T2 adalah himpunan bagian dari himpunan tipe yang dijelaskan oleh T <sub>1</sub> <br><br>  yaitu <br>  Angka &lt;=?  memperpanjang Object <br>  ?  memperpanjang Number &lt;=?  memperpanjang Object <br>  dan <br>  ?  super Object &lt;=?  nomor super <br><br></td></tr></tbody></table><br>  <i>Lebih banyak interpretasi matematis dari topik</i> <br><br>  Sepasang tugas untuk menguji pengetahuan: <br><br>  1. Mengapa kesalahan waktu kompilasi dalam contoh di bawah ini?  Nilai apa yang bisa saya tambahkan ke daftar <code>nums</code> ? <br><pre> <code class="java hljs">List&lt;Integer&gt; ints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(); ints.add(<span class="hljs-number"><span class="hljs-number">1</span></span>); ints.add(<span class="hljs-number"><span class="hljs-number">2</span></span>); List&lt;? extends Number&gt; nums = ints; nums.add(<span class="hljs-number"><span class="hljs-number">3.14</span></span>); <span class="hljs-comment"><span class="hljs-comment">// compile-time error</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Jawabannya</b> <div class="spoiler_text">  Haruskah wadah dideklarasikan dengan wildcard <code>? extends</code>  <code>? extends</code> , Anda hanya bisa membaca nilai.  Tidak ada yang bisa ditambahkan ke daftar kecuali <code>null</code> .  Untuk menambahkan objek ke daftar, kita perlu jenis wildcard lain - <code>? super</code> <code>? super</code> <br></div></div><br><br>  2. Mengapa saya tidak bisa mendapatkan item dari daftar di bawah ini? <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFirst</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; list)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list.get(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// compile-time error }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Jawabannya</b> <div class="spoiler_text">  Tidak dapat membaca item dari wadah dengan wildcard <code>? super</code>  <code>? super</code> , kecuali objek <code>Object</code> kelas <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFirst</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; list)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list.get(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br></div></div><br><br><h3>  Prinsip Get and Put atau PECS (Produser Memperpanjang Super Konsumen) </h3><br>  Fitur wildcard dengan batas atas dan bawah memberikan fitur tambahan yang terkait dengan penggunaan jenis yang aman.  Anda hanya bisa membaca dari satu jenis variabel, hanya menulis ke yang lain (pengecualiannya adalah kemampuan untuk menulis <code>null</code> untuk <code>extends</code> dan membaca <code>Object</code> untuk <code>super</code> ).  Untuk membuatnya lebih mudah diingat ketika menggunakan wildcard yang mana, ada prinsip PECS - Produser Memperluas Konsumen Super. <br><br><ul><li>  Jika kami mendeklarasikan <i>wildcard dengan extends</i> , maka ini adalah <i>produser</i> .  Dia hanya "menghasilkan", menyediakan elemen dari wadah, dan dia tidak menerima apa pun. <br></li><li>  Jika kami mengumumkan <i>wildcard dengan super</i> , maka ini adalah <i>konsumen</i> .  Dia hanya menerima, tetapi tidak bisa memberikan apa-apa. <br></li></ul><br>  Pertimbangkan menggunakan Wildcard dan prinsip PECS menggunakan metode salin di kelas java.util.Collections sebagai contoh. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; dest, List&lt;? extends T&gt; src)</span></span></span><span class="hljs-function"> </span></span>{ … }</code> </pre> <br>  Metode ini menyalin elemen dari daftar <code>src</code> asli ke daftar tujuan.  <code>src</code> - dideklarasikan dengan wildcard <code>? extends</code>  <code>? extends</code> dan merupakan produser, dan <code>dest</code> dinyatakan dengan wildcard <code>? super</code>  <code>? super</code> dan merupakan konsumen.  Mengingat kovarians dan contravariance wildcard, Anda dapat menyalin elemen dari daftar <code>ints</code> ke daftar <code>nums</code> : <br><pre> <code class="java hljs">List&lt;Number&gt; nums = Arrays.&lt;Number&gt;asList(<span class="hljs-number"><span class="hljs-number">4.1F</span></span>, <span class="hljs-number"><span class="hljs-number">0.2F</span></span>); List&lt;Integer&gt; ints = Arrays.asList(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>); Collections.copy(nums, ints);</code> </pre> <br><br>  Jika kita keliru parameter metode salin karena kesalahan dan mencoba untuk menyalin dari daftar <code>nums</code> ke daftar <code>ints</code> , kompiler tidak akan mengizinkan kita untuk melakukan ini: <br><pre> <code class="java hljs">Collections.copy(ints, nums); <span class="hljs-comment"><span class="hljs-comment">// Compile-time error</span></span></code> </pre> <br><br><h3>  &lt;?&gt; dan Jenis mentah </h3><br>  Di bawah ini adalah wildcard dengan wildcard tak terbatas.  Kami hanya menempatkan <code>&lt;?&gt;</code> , Tanpa kata kunci <code>super</code> atau <code>extends</code> : <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printCollection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;?&gt; c)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-comment"><span class="hljs-comment">// a wildcard collection  for (Object o : c) {      System.out.println(o);  } }</span></span></code> </pre><br><br>  Bahkan, wildcard "tak terbatas" semacam itu masih terbatas, dari atas.  <code>Collection&lt;?&gt;</code> Apakah juga wildcard, seperti " <code>? extends Object</code> ".  Catatan bentuk <code>Collection&lt;?&gt;</code> setara dengan <code>Collection&lt;? extends Object&gt;</code>  <code>Collection&lt;? extends Object&gt;</code> , yang berarti bahwa koleksi dapat berisi objek dari kelas apa saja, karena semua kelas di Jawa mewarisi dari <code>Object</code> - sehingga substitusi disebut tidak terbatas. <br><br>  Jika kita menghilangkan indikasi jenis, misalnya, seperti di sini: <br><pre> <code class="java hljs">ArrayList arrayList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList();</code> </pre> <br>  kemudian mereka mengatakan bahwa <code>ArrayList</code> adalah tipe <code>Raw</code> dari <i>ArrayList yang</i> diparameterisasi <i>&lt;T&gt;</i> .  Menggunakan tipe Raw, kami kembali ke era generik dan secara sadar meninggalkan semua fitur yang melekat pada tipe parameter. <br><br>  Jika kita mencoba memanggil metode parameterisasi pada tipe Raw, kompiler akan memberi kita peringatan "Panggilan tidak dicentang".  Jika kita mencoba untuk menetapkan referensi ke tipe Raw yang diparameterisasi menjadi suatu tipe, kompiler akan memberikan peringatan "Penandaan yang tidak dicentang".  Mengabaikan peringatan ini, seperti yang akan kita lihat nanti, dapat menyebabkan kesalahan selama eksekusi aplikasi kita. <br><pre> <code class="java hljs">ArrayList&lt;String&gt; strings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); ArrayList arrayList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); arrayList = strings; <span class="hljs-comment"><span class="hljs-comment">// Ok strings = arrayList; // Unchecked assignment arrayList.add(1); //unchecked call</span></span></code> </pre><br><br><h3>  Pengambilan wildcard </h3><br>  Sekarang mari kita coba menerapkan metode yang memungkinkan elemen daftar dalam urutan terbalik. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;?&gt; list)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ! public static void reverse(List&lt;?&gt; list) { List&lt;Object&gt; tmp = new ArrayList&lt;Object&gt;(list); for (int i = 0; i &lt; list.size(); i++) {   list.set(i, tmp.get(list.size()-i-1)); // compile-time error } }</span></span></code> </pre> <br>  Kesalahan kompilasi terjadi karena metode <code>reverse</code> mengambil daftar dengan karakter wildcard tak terbatas <code>&lt;?&gt;</code> Sebagai argumen. <br>  <code>&lt;?&gt;</code> Berarti sama dengan <code>&lt;? extends Object&gt;</code>  <code>&lt;? extends Object&gt;</code> .  Oleh karena itu, sesuai dengan prinsip PECS, <code>list</code> adalah <code>producer</code> .  Dan <code>producer</code> hanya menghasilkan elemen.  Dan kita dalam <code>for</code> loop memanggil metode <code>set()</code> , mis.  mencoba menulis ke <code>list</code> .  Jadi kami bersandar pada perlindungan Java, yang tidak memungkinkan kami untuk menetapkan beberapa nilai berdasarkan indeks. <br><br>  Apa yang harus dilakukan  Pola Pengambilan <code>Wildcard Capture</code> akan membantu kami.  Di sini kita membuat metode <code>rev</code> generik.  Ini dideklarasikan dengan variabel tipe <code>T</code>  Metode ini menerima daftar tipe <code>T</code> , dan kita dapat membuat satu set. <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;?&gt; list)</span></span></span><span class="hljs-function"> </span></span>{ rev(list); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rev</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;T&gt; list)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;T&gt; tmp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;T&gt;(list); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; list.size(); i++) {   list.set(i, tmp.get(list.size()-i-<span class="hljs-number"><span class="hljs-number">1</span></span>)); } }</code> </pre> <br>  Sekarang semuanya akan dikompilasi bersama kami.  Penangkapan wildcard ditangkap di sini.  Ketika metode <code>reverse(List&lt;?&gt; list)</code> disebut <code>reverse(List&lt;?&gt; list)</code> , daftar beberapa objek (misalnya, string atau bilangan bulat) dilewatkan sebagai argumen.  Jika kita dapat menangkap tipe objek-objek ini dan menetapkannya ke variabel tipe <code>X</code> , maka kita dapat menyimpulkan bahwa <code>T</code> adalah <code>X</code> <br><br>  Anda dapat membaca lebih lanjut tentang <code>Wildcard Capture</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h3>  Kesimpulan </h3><br>  Jika Anda perlu membaca dari wadah, maka gunakan wildcard dengan batas atas " <code>? extends</code> ".  Jika Anda perlu menulis ke wadah, maka gunakan wildcard dengan batas bawah " <code>? super</code> ".  Jangan gunakan wildcard jika Anda perlu merekam dan membaca. <br><br>  Jangan gunakan jenis <code>Raw</code> !  Jika argumen tipe tidak didefinisikan, maka gunakan wildcard <code>&lt;?&gt;</code> . <br><br><h2>  Ketik variabel </h2><br>  Ketika kami menuliskan pengidentifikasi dalam kurung sudut, misalnya, <code>&lt;T&gt;</code> atau <code>&lt;E&gt;</code> saat mendeklarasikan kelas atau metode, kami membuat <i>variabel tipe</i> .  Variabel tipe adalah pengidentifikasi tanpa kualifikasi yang dapat digunakan sebagai tipe di tubuh kelas atau metode.  Variabel tipe dapat dibatasi di atas. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;T&gt; coll)</span></span></span><span class="hljs-function"> </span></span>{ T candidate = coll.iterator().next(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (T elt : coll) {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (candidate.compareTo(elt) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) candidate = elt; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> candidate; }</code> </pre> <br>  Dalam contoh ini, ekspresi <code>T extends Comparable&lt;T&gt;</code> mendefinisikan <code>T</code> (variabel tipe) yang dibatasi di atas oleh tipe <code>Comparable&lt;T&gt;</code> .  Tidak seperti wildcard, variabel tipe hanya dapat dibatasi di atas (hanya <code>extends</code> ).  Tidak bisa menulis <code>super</code> .  Selain itu, dalam contoh ini, <code>T</code> tergantung pada dirinya sendiri, itu disebut <code>recursive bound</code> - perbatasan rekursif. <br><br>  Ini adalah contoh lain dari kelas Enum: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt;&gt;</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span></span></code> </pre> <br>  Di sini, kelas Enum diparameterisasi berdasarkan tipe E, yang merupakan subtipe dari <code>Enum&lt;E&gt;</code> . <br><br><h3>  Banyak batas </h3><br>  <code>Multiple Bounds</code> - beberapa batasan.  Ini ditulis melalui karakter " <code>&amp;</code> ", yaitu, kita mengatakan bahwa tipe yang diwakili oleh variabel tipe <code>T</code> harus dibatasi dari atas oleh kelas <code>Object</code> dan antarmuka yang <code>Comparable</code> . <br><br><pre> <code class="java hljs">&lt;T extends Object &amp; Comparable&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> T&gt;&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends T&gt; coll)</span></span></span></span></code> </pre> <br>  Rekam <code>Object &amp; Comparable&lt;? super T&amp;gt</code>  <code>Object &amp; Comparable&lt;? super T&amp;gt</code> membentuk tipe persimpangan <code>Multiple Bounds</code> .  Keterbatasan pertama - dalam hal ini, <code>Object</code> - digunakan untuk <code>erasure</code> , proses jenis penulisan ulang.  Ini dilakukan oleh kompiler pada tahap kompilasi. <br><br><h3>  Kesimpulan </h3><br>  Variabel tipe hanya dapat dibatasi di atas satu atau beberapa tipe.  Dalam kasus beberapa kendala, batas kiri (kendala pertama) digunakan dalam proses penulisan ulang (Penghapusan Jenis). <br><br><h2>  Ketik penghapusan </h2><br>  Penghapusan Tipe adalah pemetaan tipe (mungkin termasuk tipe parameter dan variabel tipe) ke tipe yang tidak pernah tipe parameter atau tipe variabel.  Kami menulis tipe <code>T</code> mashing sebagai <code>|T|</code>  . <br><br>  Tampilan mashing didefinisikan sebagai berikut: <br><ul><li>  Menghancurkan parameterisasi tipe <i>G</i> &lt; <i>T1</i> , ..., <i>Tn</i> &gt; adalah |  <i>G</i> | </li><li>  Menghancurkan tipe bersarang <i>TC</i> adalah |  <i>T</i> |.  <i>C</i> </li><li>  Menghancurkan array tipe <i>T []</i> adalah |  <i>T</i> | [] </li><li>  Menghancurkan variabel tipe sedang menumbuk batas kirinya </li><li>  Menghancurkan jenis lainnya adalah jenis ini sendiri </li></ul><br><br>  Selama pelaksanaan Penghapusan Jenis (type mashing), kompiler melakukan tindakan berikut: <br><ul><li>  menambahkan casting tipe untuk memberikan keamanan tipe jika perlu </li><li>  menghasilkan metode Bridge untuk mempertahankan polimorfisme </li></ul><br><br><table><tbody><tr><td>  <b>T (Jenis)</b> <br></td><td>  <b>| T |</b>  <b>(Tipe tumbuk)</b> <br></td></tr><tr><td>  <i>Daftar &lt;Integer&gt;, Daftar &lt;String&gt;, Daftar &lt;Daftar &lt;String &gt;&gt;</i> <br></td><td>  <i>Daftar</i> <br></td></tr><tr><td>  <i>Daftar &lt;Integer&gt; []</i> <br></td><td>  <i>Daftar []</i> <br></td></tr><tr><td>  <i>Daftar</i> <br></td><td>  <i>Daftar</i> <br></td></tr><tr><td>  <i>int</i> <br></td><td>  <i>int</i> <br></td></tr><tr><td>  <i>Integer</i> <br></td><td>  <i>Integer</i> <br></td></tr><tr><td>  <i>&lt;T extends Sebanding &lt;T&gt;&gt;</i> <br></td><td>  <i>Sebanding</i> <br></td></tr><tr><td>  <i>&lt;T memperluas Objek &amp; Sebanding &lt;?</i>  <i>super T &gt;&gt;</i> <br></td><td>  <i>Obyek</i> <br></td></tr><tr><td>  <i>LinkedCollection &lt;E&gt; .Node</i> <br></td><td>  <i>LinkedCollection.Node</i> <br></td></tr></tbody></table><br>  Tabel ini menunjukkan apa tipe yang berbeda berubah selama proses menumbuk, Type Erasure. <br><br>  Pada tangkapan layar di bawah ini adalah dua contoh program: <br><img src="https://habrastorage.org/getpro/habr/post_images/3a3/de2/396/3a3de23965478fc627221a1c20f4d600.png"><br><br>  Perbedaan antara keduanya adalah bahwa kesalahan waktu kompilasi terjadi di sebelah kiri, dan di sebelah kanan semuanya dikompilasi tanpa kesalahan.  Mengapa <br><br><div class="spoiler">  <b class="spoiler_title">Jawabannya</b> <div class="spoiler_text">  Di Jawa, dua metode berbeda tidak dapat memiliki tanda tangan yang sama.  Dalam proses Penghapusan Jenis, kompiler akan menambahkan metode jembatan <code>public int compareTo(Object o)</code> .  Tetapi kelas sudah berisi metode dengan tanda tangan sedemikian rupa sehingga akan menyebabkan kesalahan saat kompilasi. <br><br>  Kompilasi kelas Name dengan menghapus metode <code>compareTo(Object o)</code> dan lihat bytecode yang dihasilkan menggunakan javap: <br><pre> <code class="java hljs"># javap Name.class Compiled from <span class="hljs-string"><span class="hljs-string">"Name.java"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ru</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sberbank</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">training</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">generics</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Name</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lang</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ru</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sberbank</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">training</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">generics</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Name</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ru.sberbank.training.generics.Name(java.lang.String); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> java.lang.<span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compareTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ru.sberbank.training.generics.Name)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compareTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(java.lang.Object)</span></span></span></span>; }</code> </pre><br>  Kami melihat bahwa kelas tersebut berisi metode <code>int compareTo(java.lang.Object)</code> , meskipun kami menghapusnya dari kode sumber.  Ini adalah metode jembatan yang ditambahkan oleh kompiler. <br></div></div><br><br><h3>  Jenis yang dapat diverifikasi </h3><br>  Di Jawa, kami mengatakan bahwa suatu jenis dapat <code>reifiable</code> jika informasinya sepenuhnya dapat diakses pada saat dijalankan.  Jenis yang dapat diverifikasi meliputi: <br><ul><li>  Jenis primitif ( <i>int</i> , <i>panjang</i> , <i>boolean</i> ) </li><li>  Tipe-tipe yang tidakparameter (non-generik) ( <i>String</i> , <i>Integer</i> ) </li><li>  Tipe parameter yang parameternya direpresentasikan sebagai wildcard tak terbatas (karakter wildcard tak terbatas) ( <i>Daftar &lt;?&gt;</i> , <i>Koleksi &lt;?&gt;</i> ) </li><li>  <i>Jenis mentah</i> (tidak berbentuk) ( <i>Daftar</i> , <i>ArrayList</i> ) </li><li>  Array yang komponennya adalah jenis yang dapat diverifikasi ( <i>int []</i> , <i>Nomor []</i> , <i>Daftar &lt;?&gt; []</i> , <i>Daftar [</i> ) </li></ul><br><br>  Mengapa informasi tentang beberapa jenis tersedia tetapi tidak tentang yang lain?  Faktanya adalah bahwa karena proses menimpa jenis oleh kompiler, informasi tentang beberapa jenis mungkin hilang.  Jika hilang, maka jenis ini tidak lagi dapat diverifikasi.  Artinya, itu tidak tersedia saat runtime.  Jika tersedia - masing-masing, dapat diverifikasi. <br><br>  Keputusan untuk tidak menyediakan semua tipe generik pada saat run time adalah salah satu keputusan desain yang paling penting dan saling bertentangan dalam sistem tipe Java.  Ini dilakukan, pertama-tama, untuk kompatibilitas dengan kode yang ada.  Saya harus membayar untuk kompatibilitas migrasi - aksesibilitas penuh dari sistem tipe generik pada saat run time tidak dimungkinkan. <br><br>  Jenis apa yang tidak dapat diverifikasi: <br><ul><li>  Jenis variabel ( <i>T</i> ) </li><li>  Jenis parameter dengan tipe parameter yang ditentukan ( <i>Daftar &lt;Number&gt;</i> <i>ArrayList &lt;String&gt;</i> , <i>Daftar &lt;List &lt;String&gt;&gt;</i> ) </li><li>  Tipe parameter dengan batas atas atau bawah yang ditentukan ( <i>Daftar &lt;? Perluas Nomor&gt;, Sebandingi &lt;? Super String&gt;</i> ).  Tapi di sini ada reservasi: <i>Daftar &lt;?</i>  <i>extends Object&gt;</i> - <b>tidak dapat</b> diverifikasi, tetapi <i>List &lt;?&gt;</i> - reifiable </li></ul><br><br>  Dan satu tugas lagi.  Mengapa dalam contoh di bawah ini tidak dapat membuat Pengecualian berparameter? <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyException</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class"> </span></span>{  T t; }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Jawabannya</b> <div class="spoiler_text">  Setiap ekspresi catch dalam try-catch memeriksa tipe pengecualian yang diterima selama eksekusi program (yang setara dengan instanceof), masing-masing, tipe tersebut harus dapat diverifikasi.  Oleh karena itu, Throwable dan subtipe-nya tidak dapat diparameterisasi. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyException</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">// Generic class may not extend 'java.lang.Throwable'  T t; }</span></span></code> </pre> <br></div></div><br><br><h3>  Peringatan yang tidak dicentang </h3><br>  Mengkompilasi aplikasi kita dapat menghasilkan apa yang disebut <code>Unchecked Warning</code> - peringatan bahwa kompiler tidak dapat dengan benar menentukan tingkat keamanan penggunaan tipe kita.  Ini bukan kesalahan, tapi peringatan, jadi Anda bisa melewatinya.  Tetapi disarankan untuk memperbaiki semuanya agar terhindar dari masalah di masa depan. <br><br><h3>  Menumpuk polusi </h3><br>  Seperti yang kami sebutkan sebelumnya, menetapkan referensi ke tipe Raw ke variabel dari tipe parameter menyebabkan peringatan "Tidak ditandai tugas".  Jika kita mengabaikannya, sebuah situasi yang disebut " <code>Heap Pollution</code> " (heap polusi) mungkin terjadi.  Berikut ini sebuah contoh: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  List l = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Number&gt;();  l.add(<span class="hljs-number"><span class="hljs-number">1</span></span>);  List&lt;String&gt; ls = l; <span class="hljs-comment"><span class="hljs-comment">// (1)  ls.add("");  return ls; }</span></span></code> </pre> <br>  Pada baris (1), kompiler memperingatkan "Tugas tidak dicentang." <br><br>  Kita perlu memberikan contoh lain dari "tumpukan polusi" - ketika kita menggunakan objek parameterisasi.  Cuplikan kode di bawah ini dengan jelas menunjukkan bahwa tidak diperbolehkan menggunakan tipe parameter sebagai argumen untuk metode yang menggunakan <code>Varargs</code> .  Dalam kasus ini, parameter metode m adalah <code>List&lt;String&gt;…</code> , mis.  sebenarnya, sebuah array elemen dari tipe <code>List&lt;String&gt;</code> .  Diberi aturan menampilkan tipe selama mashing, tipe <code>stringLists</code> berubah menjadi array daftar mentah ( <code>List[]</code> ), mis.  tugas dapat dilakukan <code>Object[] array = stringLists;</code>  dan kemudian menulis ke <code>array</code> objek selain daftar string (1), yang akan <code>ClassCastException</code> dalam string (2). <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;String&gt;... stringLists)</span></span></span><span class="hljs-function"> </span></span>{  Object[] array = stringLists;  List&lt;Integer&gt; tmpList = Arrays.asList(<span class="hljs-number"><span class="hljs-number">42</span></span>);  array[<span class="hljs-number"><span class="hljs-number">0</span></span>] = tmpList; <span class="hljs-comment"><span class="hljs-comment">// (1)  String s = stringLists[0].get(0); // (2) }</span></span></code> </pre> <br><br>  Pertimbangkan contoh lain: <br><pre> <code class="java hljs">ArrayList&lt;String&gt; strings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); ArrayList arrayList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); arrayList = strings; <span class="hljs-comment"><span class="hljs-comment">// (1) Ok arrayList.add(1); // (2) unchecked call</span></span></code> </pre> <br>  Java mengizinkan penugasan pada baris (1).  Ini diperlukan untuk kompatibilitas ke belakang.  Tetapi jika kita mencoba menjalankan metode <code>add</code> pada baris (2), kita mendapatkan peringatan <code>Unchecked call</code> - kompiler memperingatkan kita akan kemungkinan kesalahan.  Faktanya, kami mencoba menambahkan integer ke daftar string. <br><br><h3>  Refleksi </h3><br>  Meskipun, selama kompilasi, tipe parameterisasi menjalani prosedur tipe erasure, kita bisa mendapatkan beberapa informasi menggunakan Reflection. <br><br><ul><li>  Semua dapat diverifikasi tersedia melalui mekanisme Refleksi. <br></li><li>  Informasi tentang jenis bidang kelas, parameter metode, dan nilai yang dikembalikan oleh mereka tersedia melalui Refleksi. <br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika kami ingin mendapatkan informasi tentang jenis objek melalui Refleksi dan jenis ini tidak </font></font><code>Reifiable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, maka kami tidak akan berhasil. </font><font style="vertical-align: inherit;">Tetapi, jika, misalnya, objek ini dikembalikan kepada kami dengan beberapa metode, maka kami bisa mendapatkan jenis nilai yang dikembalikan oleh metode ini:</font></font><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.lang</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.reflect</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Method</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.getGenericReturnType</span></span>()</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan munculnya Generics, kelas telah </font></font><code>java.lang.Class</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menjadi parameter. </font><font style="vertical-align: inherit;">Pertimbangkan kode ini:</font></font><br><pre> <code class="java hljs">List&lt;Integer&gt; ints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(); Class&lt;? extends List&gt; k = ints.getClass(); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> k == ArrayList.class;</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variabelnya </font></font><code>ints</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah tipe </font></font><code>List&lt;Integer&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan berisi referensi ke objek tipe </font></font><code>ArrayList&lt; Integer&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Maka itu </font></font><code>ints.getClass()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan mengembalikan objek bertipe </font></font><code>Class&lt;ArrayLis&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, karena </font></font><code>List&lt;Integer&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ditimpa dalam </font></font><code>List</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>Class&lt;ArrayList&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisakah </font><font style="vertical-align: inherit;">objek tipe </font><font style="vertical-align: inherit;">ditugaskan ke variabel </font></font><code>k</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tipe </font></font><code>Class&lt;? extends List&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sesuai dengan kovarian karakter wildcard? </font></font><code>extends</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A </font></font><code>ArrayList.class</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengembalikan objek bertipe </font></font><code>Class&lt;ArrayList&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3>  Kesimpulan </h3><br>         ,     Reifiable.  Reifiable  :  ,  ,      , Raw   ,    reifiable. <br><br>  Unchecked Warnings    « »      . <br><br> Reflection       ,    Reifiable.  Reflection        ,         . <br><br><h2> Type Inference </h2><br>     « ».     ()   .   : <br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;();</code> </pre> <br>   -   Java 7       <code>ArrayList</code> : <br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;();</code> </pre> <br>    <code>ArrayList</code>   – <code>List&lt;Integer&gt;</code> .     <code>type inference</code> . <br><br>  Java 8       JEP 101. <br>             Type Inference.          : <br><ul><li>  (reduction) <br></li><li>  (incorporation) <br></li><li>  (resolution) <br></li></ul><br>    :    ,      ,   —   . <br>         ,     .     JEP 101      . <br><br>       ,    : <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;Z&gt; <span class="hljs-function"><span class="hljs-function">List&lt;Z&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nil</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... };  <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;Z&gt; <span class="hljs-function"><span class="hljs-function">List&lt;Z&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cons</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Z head, List&lt;Z&gt; tail)</span></span></span><span class="hljs-function"> </span></span>{ ... };  <span class="hljs-function"><span class="hljs-function">E </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">head</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } }</code> </pre> <br>    <code>List.nil()</code>      : <br><pre> <code class="java hljs">List&lt;String&gt; ls = List.nil();</code> </pre> <br>     ,      <code>List.nil()</code>  <code>String</code> —    JDK 7,  . <br><br>  ,        ,            , : <br><pre> <code class="java hljs">List.cons(<span class="hljs-number"><span class="hljs-number">42</span></span>, List.nil()); <span class="hljs-comment"><span class="hljs-comment">//error: expected List&lt;Integer&gt;, found List&lt;Object&gt;</span></span></code> </pre> <br>  JDK 7    compile-time error.   JDK 8 .      JEP-101,    —     .        JDK 8 —        : <br><pre> <code class="java hljs">List.cons(<span class="hljs-number"><span class="hljs-number">42</span></span>, List.&lt;Integer&gt;nil());</code> </pre> <br><br>   JEP-101   ,          , : <br><pre> <code class="java hljs">String s = List.nil().head(); <span class="hljs-comment"><span class="hljs-comment">//error: expected String, found Object</span></span></code> </pre> <br>        ,         . ,    JDK    ,      : <br><pre> <code class="java hljs">String s = List.&lt;String&gt;nil().head();</code> </pre> <br><br>   JEP 101  StackOverflow     .  ,  ,    7- ,  8-   –    ?    : <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{      System.out.println(<span class="hljs-string"><span class="hljs-string">"one"</span></span>);  }  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] o)</span></span></span><span class="hljs-function"> </span></span>{      System.out.println(<span class="hljs-string"><span class="hljs-string">"two"</span></span>);  }  <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;  }  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{      m(g());  } }</code> </pre> <br><br>   -    JDK1.8: <br><pre> <code class="java hljs">  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(java.lang.String[])</span></span></span></span>;   descriptor: ([Ljava/lang/String;)V   flags: ACC_PUBLIC, ACC_STATIC   Code:     stack=<span class="hljs-number"><span class="hljs-number">1</span></span>, locals=<span class="hljs-number"><span class="hljs-number">1</span></span>, args_size=<span class="hljs-number"><span class="hljs-number">1</span></span>        <span class="hljs-number"><span class="hljs-number">0</span></span>: invokestatic  #<span class="hljs-number"><span class="hljs-number">6</span></span>   <span class="hljs-comment"><span class="hljs-comment">// Method g:()Ljava/lang/Object;        3: checkcast     #7   // class "[Ljava/lang/String;"        6: invokestatic  #8   // Method m:([Ljava/lang/String;)V        9: return     LineNumberTable:       line 15: 0       line 16: 9</span></span></code> </pre><br><br>    0    <code>g:()Ljava/lang/Object;</code>   <code>java.lang.Object</code> . ,  3    («») ,        <code>java.lang.String</code> ,   6   <code>m:([Ljava/lang/String;)</code> ,      «two». <br><br>   -    JDK1.7 –    Java 7: <br><pre> <code class="java hljs">  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(java.lang.String[])</span></span></span></span>;   flags: ACC_PUBLIC, ACC_STATIC   Code:     stack=<span class="hljs-number"><span class="hljs-number">1</span></span>, locals=<span class="hljs-number"><span class="hljs-number">1</span></span>, args_size=<span class="hljs-number"><span class="hljs-number">1</span></span>        <span class="hljs-number"><span class="hljs-number">0</span></span>: invokestatic  #<span class="hljs-number"><span class="hljs-number">6</span></span>   <span class="hljs-comment"><span class="hljs-comment">// Method g:()Ljava/lang/Object;        3: invokestatic  #7   // Method m:(Ljava/lang/Object;)V        6: return            LineNumberTable:       line 15: 0       line 16: 6</span></span></code> </pre><br><br>  ,     <code>checkcast</code> ,   Java 8,     <code>m:(Ljava/lang/Object;)</code> ,     «one». <code>Checkcast</code> –    ,      Java 8. <br><br>    , Oracle  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>    JDK1.7  JDK 1.8    ,         Java,  ,     . <br><br>    ,        Java 8    ,    Java 7,    : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ m((Object)g()); }</code> </pre><br><br><h2>  Kesimpulan </h2><br>      Java Generics   .   ,      : <br><br><ul><li> Naftalin, Maurice; Wadler, Philip. Java Generics and Collections. O'Reilly Media. ISBN-13: 978-0596527754 <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://docs.oracle.com/javase/specs/jls/se8/html/index.html</a> <br></li><li>   Java SE 8. Addison-Wesley. ISBN: 978-5-8459-1875-8 <br></li></ul><br><ul><li> Bloch, Joshua. Effective Java. Third Edition. Addison-Wesley. ISBN-13: 978-0-13-468599-1 <br></li></ul><br>      ,        Java Generics. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id416413/">https://habr.com/ru/post/id416413/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id416403/index.html">Intisari Fintech: serangan terhadap bank PIR, Layanan Pajak Federal dan pajak dari transfer dari satu kartu ke kartu lainnya, serta beberapa blockchain dan cryptocurrency.</a></li>
<li><a href="../id416405/index.html">Program sarjana dalam kemitraan dengan Yandex</a></li>
<li><a href="../id416407/index.html">Menghemat lalu lintas dari sniffer Mikrotik</a></li>
<li><a href="../id416409/index.html">5 kesalahan umum dalam mengembangkan strategi dan cara untuk menghadapinya</a></li>
<li><a href="../id416411/index.html">Ceritakan kisah dengan data</a></li>
<li><a href="../id416415/index.html">Kami memindahkan semua yang ada di unit uji Vivaldi 1.16.1230.3</a></li>
<li><a href="../id416417/index.html">"Sungai Surgawi" - Cina akan menciptakan hujan buatan dengan kekuatan yang belum pernah terjadi sebelumnya</a></li>
<li><a href="../id416419/index.html">Generator Gua Dua Dimensi Acak</a></li>
<li><a href="../id416421/index.html">Berjalan-jalan di pit lane, atau bagaimana teknologi IaaS membantu tim balap</a></li>
<li><a href="../id416423/index.html">Bagaimana orang Rusia mengingatkan prosesor Amerika, atau ulasan tentang AdvoCam-FD8 Gold-II DVR (GPS + GLONASS)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>