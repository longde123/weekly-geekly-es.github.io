<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïù üßú ü§µüèΩ WBOIT in OpenGL: Transparenz ohne Sortierung üßëüèæ‚Äçü§ù‚ÄçüßëüèΩ ‚è≠Ô∏è ü§òüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Beitrag geht es um gewichtete gemischte auftragsunabh√§ngige Transparenz (WBOIT) - der Trick, der 2013 in JCGT behandelt wurde. 

 Wenn mehre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WBOIT in OpenGL: Transparenz ohne Sortierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457292/">  In diesem Beitrag geht es um gewichtete gemischte auftragsunabh√§ngige Transparenz (WBOIT) - der Trick, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der 2013</a> in JCGT behandelt wurde. <br><a name="habracut"></a><br>  Wenn mehrere transparente Objekte auf einem Bildschirm angezeigt werden, h√§ngt die Pixelfarbe davon ab, welches n√§her am Betrachter liegt.  Hier ist ein bekannter Mischoperator, der in diesem Fall verwendet wird: <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><merror><mtext>\&amp;#xA0;begin&amp;#xA0;{matrix}&amp;#xA0;C&amp;#xA0;=&amp;#xA0;C_&amp;#xA0;{nah}&amp;#xA0;\&amp;#xA0;alpha&amp;#xA0;+&amp;#xA0;C_&amp;#xA0;{fern}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;alpha)&amp;#xA0;&amp;amp;&amp;amp;&amp;#xA0;(1)&amp;#xA0;\&amp;#xA0;end&amp;#xA0;{matrix}</mtext></merror></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><span class="noError" aria-hidden="true" style="display: inline-block;">\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;C_&nbsp;{nah}&nbsp;\&nbsp;alpha&nbsp;+&nbsp;C_&nbsp;{fern}&nbsp;(1-&nbsp;\&nbsp;alpha)&nbsp;&amp;&amp;&nbsp;(1)&nbsp;\&nbsp;end&nbsp;{matrix}</span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><merror><mtext>\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;C_&nbsp;{nah}&nbsp;\&nbsp;alpha&nbsp;+&nbsp;C_&nbsp;{fern}&nbsp;(1-&nbsp;\&nbsp;alpha)&nbsp;&amp;&amp;&nbsp;(1)&nbsp;\&nbsp;end&nbsp;{matrix}</mtext></merror></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> \ begin {matrix} C = C_ {nah} \ alpha + C_ {fern} (1- \ alpha) && (1) \ end {matrix} </script></p><br><br>  Die Bestellung von Fragmenten ist wichtig.  Der Operator enth√§lt die Farbe (C <sub>nah</sub> ) und die Opazit√§t ( <i>Œ±</i> ) eines nahen Fragments sowie die Gesamtfarbe (C <sub>fern</sub> ) aller dahinter liegenden Fragmente.  Die Deckkraft kann zwischen 0 und 1 liegen.  0 bedeutet, dass das Objekt vollst√§ndig transparent (unsichtbar) ist und 1 bedeutet, dass es vollst√§ndig undurchsichtig ist. <br><br>  Um diesen Operator verwenden zu k√∂nnen, m√ºssen Sie Fragmente nach Tiefe sortieren.  Stellen Sie sich vor, was f√ºr ein Fluch es ist.  Im Allgemeinen m√ºssen Sie eine Sortierung pro Frame durchf√ºhren.  Wenn Sie Objekte sortieren, m√ºssen Sie m√∂glicherweise mit unregelm√§√üig geformten Fl√§chen umgehen, die in Abschnitte geschnitten werden m√ºssen, und dann m√ºssen abgeschnittene TEILE dieser Fl√§chen sortiert werden (Sie m√ºssen dies definitiv f√ºr sich √ºberschneidende Fl√§chen tun).  Wenn Sie Fragmente sortieren, platzieren Sie die eigentliche Sortierung in Ihren Shadern.  Diese Methode wird als "Auftragsunabh√§ngige Transparenz" (OIT) bezeichnet und basiert auf einer verkn√ºpften Liste, die im Videospeicher gespeichert ist.  Es ist fast unm√∂glich vorherzusagen, wie viel Speicher f√ºr diese Liste reserviert werden muss.  Und wenn Sie nicht gen√ºgend Speicher haben, werden Artefakte auf dem Bildschirm angezeigt. <br><br>  Betrachten Sie sich als gl√ºcklich, wenn Sie die Anzahl der transparenten Objekte in Ihrer Szene regulieren und ihre relativen Positionen anpassen k√∂nnen.  Wenn Sie jedoch einen CAD entwickeln, m√ºssen die Benutzer ihre Objekte positionieren, sodass so viele Objekte vorhanden sind, wie sie m√∂chten, und ihre Platzierung ist einfach willk√ºrlich. <br><br>  Jetzt sehen Sie, warum es so verlockend ist, einen Mischoperator zu finden, der keine vorl√§ufige Sortierung erfordert.  Und es gibt einen solchen Operator - in einem Artikel, den ich am Anfang erw√§hnt habe.  Tats√§chlich gibt es mehrere Formeln, aber eine davon betrachten die Autoren (und ich) als die besten: <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display"><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><merror><mtext>\&amp;#xA0;begin&amp;#xA0;{matrix}&amp;#xA0;C&amp;#xA0;=&amp;#xA0;{{\&amp;#xA0;sum_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;C_i&amp;#xA0;\&amp;#xA0;alpha_i}&amp;#xA0;\&amp;#xA0;over&amp;#xA0;{\&amp;#xA0;sum_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;\&amp;#xA0;alpha_i}}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;prod_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;alpha_i))&amp;#xA0;+&amp;#xA0;C_0&amp;#xA0;\&amp;#xA0;prod_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;alpha_i)&amp;#xA0;&amp;amp;&amp;amp;&amp;#xA0;(2)&amp;#xA0;\&amp;#xA0;end&amp;#xA0;{matrix}</mtext></merror></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><span class="noError" aria-hidden="true" style="display: inline-block;">\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;{{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;C_i&nbsp;\&nbsp;alpha_i}&nbsp;\&nbsp;over&nbsp;{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;\&nbsp;alpha_i}}&nbsp;(1-&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i))&nbsp;+&nbsp;C_0&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i)&nbsp;&amp;&amp;&nbsp;(2)&nbsp;\&nbsp;end&nbsp;{matrix}</span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><merror><mtext>\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;{{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;C_i&nbsp;\&nbsp;alpha_i}&nbsp;\&nbsp;over&nbsp;{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;\&nbsp;alpha_i}}&nbsp;(1-&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i))&nbsp;+&nbsp;C_0&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i)&nbsp;&amp;&amp;&nbsp;(2)&nbsp;\&nbsp;end&nbsp;{matrix}</mtext></merror></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-2"> \ begin {matrix} C = {{\ sum_ {i = 1} ^ {n} C_i \ alpha_i} \ over {\ sum_ {i = 1} ^ {n} \ alpha_i}} (1- \ prod_ {i = 1} ^ {n} (1- \ alpha_i)) + C_0 \ prod_ {i = 1} ^ {n} (1- \ alpha_i) && (2) \ end {matrix} </script></p><br><br><img src="https://habrastorage.org/webt/65/b9/oz/65b9ozbni1afvlupqfso9uve2ey.png" width="1000"><br><br>  Auf dem Screenshot sieht man Gruppen transparenter Dreiecke, die auf vier Tiefenebenen angeordnet sind.  Auf der linken Seite wurden sie mit WBOIT gerendert, und auf der rechten Seite wurde die klassische auftragsabh√§ngige Mischung - mit Formel (1) - verwendet (ich werde sie von nun an CODB nennen). <br><br>  Bevor wir mit dem Rendern transparenter Objekte beginnen k√∂nnen, m√ºssen wir alle nicht transparenten Objekte rendern.  Danach werden transparente Objekte mit einem Tiefentest gerendert, ohne jedoch etwas in einen <code>glEnable(GL_DEPTH_TEST); glDepthMask(GL_FALSE);</code> zu schreiben (dies kann folgenderma√üen erfolgen: <code>glEnable(GL_DEPTH_TEST); glDepthMask(GL_FALSE);</code> ). <br><br>  Schauen wir uns nun an, was irgendwann mit Bildschirmraumkoordinaten (x, y) passiert.  Transparente Fragmente - die zuf√§llig n√§her als der nicht transparente sind - bestehen den Tiefentest, unabh√§ngig davon, wie sie relativ zu den bereits gerenderten transparenten Fragmenten platziert sind.  Diese transparenten Fragmente, die hinter das nicht transparente fallen - nun, sie bestehen den Tiefentest nicht und werden nat√ºrlich verworfen. <br><br>  C <sub>0</sub> in Formel (2) ist die Farbe des nicht transparenten Fragments, das an diesem Punkt (x, y) gerendert wird.  Wir haben insgesamt n transparente Fragmente, die den Tiefentest bestanden haben, und sie haben Indizes i ‚àà [1, n].  C <sub>i</sub> ist die Farbe des transparenten Fragments und <i>Œ± <sub>i</sub></i> ist seine Opazit√§t. <br><br>  Formel (2) ist Formel (1) etwas √§hnlich, obwohl es nicht sehr offensichtlich ist.  Ersetzen <img src="https://habrastorage.org/webt/xz/w1/z8/xzw1z8f-nsnfuokbqssbhic6tpw.png" width="60">  mit C <sub>nah</sub> , C <sub>0</sub> mit C <sub>fern</sub> und <img src="https://habrastorage.org/webt/li/tu/em/lituem-w98r3gl7cee5184y6b7q.png" width="100">  mit <i>Œ±</i> und Formel (1) wird genau das sein, was Sie bekommen.  In der Tat, <img src="https://habrastorage.org/webt/xz/w1/z8/xzw1z8f-nsnfuokbqssbhic6tpw.png" width="60">  ist das <b>gewichtete arithmetische Mittel</b> der Farben aller transparenten Fragmente (es gibt eine √§hnliche Formel in der Mechanik f√ºr "Massenschwerpunkt"), und es wird f√ºr die Farbe des nahen Fragments C <sub>nahe gew√§hlt</sub> .  C <sub>0</sub> ist die Farbe des nicht transparenten Fragments hinter all den transparenten Fragmenten, f√ºr die wir das gewichtete arithmetische Mittel berechnen.  Mit anderen Worten, wir ersetzen alle transparenten Fragmente durch ein "gewichtetes Mittel" -Fragment und verwenden den Standard-Mischoperator - Formel (1).  Nun gibt es eine etwas ausgefeilte Formel f√ºr <i>Œ±</i> , und wir m√ºssen ihre Bedeutung noch herausfinden. <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mtext>&amp;#xA0;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi><mo>=</mo><mn>1</mn><mo>&amp;#x2212;</mo><mtext>&amp;#xA0;</mtext><mi>p</mi><mi>r</mi><mi>o</mi><msubsup><mi>d</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>n</mi></mrow></msubsup><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>&amp;#x2212;</mo><mtext>&amp;#xA0;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msub><mi>a</mi><mi>i</mi></msub><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="34.233ex" height="2.901ex" viewBox="0 -832 14738.9 1249" role="img" focusable="false" style="vertical-align: -0.969ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhhqSc-IZ5UsQ-_GXuMQkrKc_-fJ9Q#MJMATHI-61" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhhqSc-IZ5UsQ-_GXuMQkrKc_-fJ9Q#MJMATHI-6C" x="779" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhhqSc-IZ5UsQ-_GXuMQkrKc_-fJ9Q#MJMATHI-70" x="1078" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhhqSc-IZ5UsQ-_GXuMQkrKc_-fJ9Q#MJMATHI-68" x="1581" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhhqSc-IZ5UsQ-_GXuMQkrKc_-fJ9Q#MJMATHI-61" x="2158" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhhqSc-IZ5UsQ-_GXuMQkrKc_-fJ9Q#MJMAIN-3D" x="2965" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhhqSc-IZ5UsQ-_GXuMQkrKc_-fJ9Q#MJMAIN-31" x="4021" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhhqSc-IZ5UsQ-_GXuMQkrKc_-fJ9Q#MJMAIN-2212" x="4744" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhhqSc-IZ5UsQ-_GXuMQkrKc_-fJ9Q#MJMATHI-70" x="5995" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhhqSc-IZ5UsQ-_GXuMQkrKc_-fJ9Q#MJMATHI-72" x="6498" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhhqSc-IZ5UsQ-_GXuMQkrKc_-fJ9Q#MJMATHI-6F" x="6950" y="0"></use><g transform="translate(7435,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhhqSc-IZ5UsQ-_GXuMQkrKc_-fJ9Q#MJMATHI-64" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhhqSc-IZ5UsQ-_GXuMQkrKc_-fJ9Q#MJMATHI-6E" x="741" y="499"></use><g transform="translate(520,-308)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhhqSc-IZ5UsQ-_GXuMQkrKc_-fJ9Q#MJMATHI-69" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhhqSc-IZ5UsQ-_GXuMQkrKc_-fJ9Q#MJMAIN-3D" x="345" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhhqSc-IZ5UsQ-_GXuMQkrKc_-fJ9Q#MJMAIN-31" x="1124" y="0"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhhqSc-IZ5UsQ-_GXuMQkrKc_-fJ9Q#MJMAIN-28" x="9204" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhhqSc-IZ5UsQ-_GXuMQkrKc_-fJ9Q#MJMAIN-31" x="9594" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhhqSc-IZ5UsQ-_GXuMQkrKc_-fJ9Q#MJMAIN-2212" x="10316" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhhqSc-IZ5UsQ-_GXuMQkrKc_-fJ9Q#MJMATHI-61" x="11567" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhhqSc-IZ5UsQ-_GXuMQkrKc_-fJ9Q#MJMATHI-6C" x="12097" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhhqSc-IZ5UsQ-_GXuMQkrKc_-fJ9Q#MJMATHI-70" x="12395" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhhqSc-IZ5UsQ-_GXuMQkrKc_-fJ9Q#MJMATHI-68" x="12899" y="0"></use><g transform="translate(13475,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhhqSc-IZ5UsQ-_GXuMQkrKc_-fJ9Q#MJMATHI-61" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhhqSc-IZ5UsQ-_GXuMQkrKc_-fJ9Q#MJMATHI-69" x="748" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhhqSc-IZ5UsQ-_GXuMQkrKc_-fJ9Q#MJMAIN-29" x="14349" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>&nbsp;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi><mo>=</mo><mn>1</mn><mo>‚àí</mo><mtext>&nbsp;</mtext><mi>p</mi><mi>r</mi><mi>o</mi><msubsup><mi>d</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></msubsup><mo stretchy="false">(</mo><mn>1</mn><mo>‚àí</mo><mtext>&nbsp;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">)</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-3"> \ alpha = 1- \ prod_ {i = 1} ^ {n} (1- \ alpha_i) </script></p><br>  Es ist eine Skalarfunktion im n-dimensionalen Raum.  Alle <i>Œ± <sub>i</sub></i> sind in [0, 1] enthalten, so dass seine partielle Ableitung in Bezug auf eines von <i>Œ± <sub>i</sub></i> eine nicht negative Konstante ist.  Dies bedeutet, dass die Opazit√§t des "gewichteten Mittelwerts" -Fragments zunimmt, wenn Sie die Opazit√§t eines der transparenten Fragmente erh√∂hen, was genau das ist, was wir wollen.  Dar√ºber hinaus steigt es linear an. <br><br>  Wenn die Deckkraft eines Fragments 0 ist, ist es vollst√§ndig unsichtbar.  Es tr√§gt √ºberhaupt nicht zur resultierenden Farbe bei. <br><br>  Wenn mindestens ein Fragment eine Opazit√§t von 1 hat, ist auch <i>Œ±</i> 1.  Das hei√üt, ein nicht transparentes Fragment wird unsichtbar, was gut ist.  Das Problem ist, dass die anderen transparenten Fragmente (hinter diesem Fragment mit Opazit√§t = 1) immer noch durchsichtig sind und zur resultierenden Farbe beitragen: <br><br><img src="https://habrastorage.org/webt/3s/lm/3y/3slm3yxglf43xno7dyqu8g7ua-o.png" width="300"><br><br>  Das orangefarbene Dreieck auf diesem Bild liegt oben, das gr√ºne Dreieck liegt darunter und unter dem gr√ºnen Dreieck liegen graue und cyanfarbene Dreiecke.  Der Hintergrund ist schwarz.  Die Deckkraft des orangefarbenen Dreiecks betr√§gt 1;  Alle anderen haben eine Deckkraft von 0,5.  Hier k√∂nnen Sie sehen, dass WBOIT sehr schlecht aussieht.  Der einzige Ort, an dem echte orange Farbe erscheint, ist der Rand des gr√ºnen Dreiecks, der mit einer nicht transparenten wei√üen Linie umrandet ist.  Wie bereits erw√§hnt, ist ein nicht transparentes Fragment unsichtbar, wenn ein transparentes Fragment mit einer Deckkraft von 1 dar√ºber liegt. <br><br>  Auf dem n√§chsten Bild ist es besser zu sehen: <br><br><img src="https://habrastorage.org/webt/-3/dc/ey/-3dcey8p1s2ynmgq9oyatw1ojma.png" width="300"><br><br>  Die Deckkraft des orangefarbenen Dreiecks betr√§gt 1, das gr√ºne Dreieck mit deaktivierter Transparenz wird nur mit nicht transparenten Objekten gerendert.  Es sieht so aus, als w√ºrde die GR√úNE Farbe des Dreiecks hinter dem oberen Dreieck als ORANGE-Farbe angezeigt. <br><br>  Der einfachste Weg, um Ihr Bild plausibel erscheinen zu lassen, besteht darin, Ihren Objekten keine hohe Deckkraft zu verleihen.  In einem Projekt, in dem ich diese Technik verwende, stelle ich die Deckkraft nicht mehr als 0,5 ein.  Es handelt sich um 3D-CAD, bei dem Objekte schematisch gezeichnet werden und nicht sehr realistisch aussehen m√ºssen. Daher ist diese Einschr√§nkung akzeptabel. <br><br>  Bei geringer Deckkraft sehen die linken und rechten Bilder sehr √§hnlich aus: <br><br><img src="https://habrastorage.org/webt/hz/pc/ud/hzpcud9vuojz7vk0rsofbidyumy.png" width="1000"><br><br>  Und sie unterscheiden sich merklich bei hohen Tr√ºbungen: <br><br><img src="https://habrastorage.org/webt/iv/hq/_l/ivhq_lqrb8ofbxie323mtwpfg-q.png" width="1000"><br><br>  Hier ist ein transparentes Polyeder: <br><br><img src="https://habrastorage.org/webt/nm/oi/6u/nmoi6u1xvycmbwvt50z6pinofbg.png" width="500"><br><img src="https://habrastorage.org/webt/ej/9u/p1/ej9up1muignigkr73kn2mi5byrs.png" width="500"><br><br>  Es hat orangefarbene Seitenfl√§chen und gr√ºne horizontale Fl√§chen, was leider nicht offensichtlich ist, was bedeutet, dass das Bild nicht glaubw√ºrdig aussieht.  Wo immer ein orangefarbenes Gesicht oben ist, muss die Farbe orange sein, und wo es sich hinter einem gr√ºnen Gesicht befindet, muss die Farbe gr√ºner sein.  Besser mit einer Farbe zeichnen: <br><br><img src="https://habrastorage.org/webt/a2/eg/bf/a2egbfdzwlwmaltuc4lpyna45gs.png" width="500"><br><br><h3>  Injizieren Sie die Tiefe in den Mischoperator </h3><br>  Um den Mangel an Tiefensortierung auszugleichen, haben die Autoren des oben genannten JCGT-Papiers verschiedene M√∂glichkeiten gefunden, die Tiefe in Formel (2) zu injizieren.  Dies erschwert die Implementierung und macht das Ergebnis weniger vorhersehbar.  Damit es funktioniert, m√ºssen die Mischparameter auf eine bestimmte 3D-Szene abgestimmt werden.  Ich habe mich nicht eingehend mit diesem Thema befasst. Wenn Sie also mehr wissen m√∂chten, lesen Sie die Zeitung. <br><br>  Autoren behaupten, dass WBOIT manchmal in der Lage ist, etwas zu tun, was CODB nicht kann.  Betrachten Sie beispielsweise das Zeichnen eines Rauches als Partikelsystem mit zwei Partikeln: dunklem Rauch und hellerem Rauch.  Wenn sich die Partikel bewegen und ein Partikel durch ein anderes hindurchgeht, wechselt ihre Mischfarbe sofort von dunkel zu hell, was nicht gut ist.  Der WBOIT-Operator mit Tiefe erzeugt ein bevorzugteres Ergebnis mit einem reibungslosen Farb√ºbergang.  Haare oder Fell, die als d√ºnne R√∂hrchen modelliert sind, haben die gleichen Eigenschaften. <br><br><h3>  Der Code </h3><br>  Nun zur OpenGL-Implementierung der Formel (2).  Sie k√∂nnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Implementierung</a> auf GitHub sehen.  Es ist eine Qt-basierte App, und die Bilder, die Sie hier sehen, stammen gr√∂√ütenteils davon. <br><br>  Wenn Sie mit transparentem Rendern noch nicht vertraut sind, finden Sie hier ein gutes Einstiegsmaterial: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lerne OpenGL.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mischen</a> <br><br>  Ich empfehle es zu lesen, bevor Sie mit diesem Beitrag fortfahren. <br><br>  Um Formel (2) auszuwerten, ben√∂tigen wir 2 zus√§tzliche Framebuffer, 3 Multisamle-Texturen und einen Tiefen-Renderpuffer.  Nicht transparente Objekte werden in der ersten Textur, colorTextureNT, gerendert.  Sein Typ ist GL_RGB10_A2.  Die zweite Textur (colorTexture) ist vom Typ GL_RGBA16F.  Die ersten drei Komponenten von colorTexture enthalten diesen Teil der Formel (2): <img src="https://habrastorage.org/webt/9p/7i/vm/9p7ivmikwxs8ltenmceiumeogoo.png" width="70">  und <img src="https://habrastorage.org/webt/i2/bg/uc/i2bguc_jhzovzvn6ybqfkkuds4q.png" width="50">  wird in die vierte Komponente geschrieben.  Die letzte Textur, alphaTexture, vom Typ GL_R16 enth√§lt <img src="https://habrastorage.org/webt/ma/si/f0/masif074trzop-clpwvbwtfj92i.png" width="90">  . <br><br>  Zuerst m√ºssen wir alle diese Objekte erstellen und ihre Bezeichner von OpenGL erhalten: <br><pre> <code class="cpp hljs"> f-&gt;glGenFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebufferNT ); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTextureNT ); f-&gt;glGenRenderbuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;depthRenderbuffer); f-&gt;glGenFramebuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebuffer ); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTexture); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;alphaTexture);</code> </pre> <br>  Wie Sie sich erinnern, verwende ich Qt framewok und alle Aufrufe von OpenGL erfolgen von einem Objekt vom Typ QOpenGLFunctions_4_5_Core, f√ºr das ich immer den Namen f verwende. <br><br>  Die Speicherzuweisung erfolgt als N√§chstes: <br><pre> <code class="cpp hljs"> f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_RGB16F, w, h, GL_TRUE ); f-&gt;glBindRenderbuffer(GL_RENDERBUFFER, depthRenderbuffer); f-&gt;glRenderbufferStorageMultisample( GL_RENDERBUFFER, numOfSamples, GL_DEPTH_COMPONENT, w, h ); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTexture); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_RGBA16F, w, h, GL_TRUE ); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, alphaTexture); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_R16F, w, h, GL_TRUE );</code> </pre> <br>  Framebuffer-Setup: <br><pre> <code class="cpp hljs"> f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebufferNT); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT, <span class="hljs-number"><span class="hljs-number">0</span></span> ); f-&gt;glFramebufferRenderbuffer( GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderbuffer ); f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, colorTexture, <span class="hljs-number"><span class="hljs-number">0</span></span> ); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_2D_MULTISAMPLE, alphaTexture, <span class="hljs-number"><span class="hljs-number">0</span></span> ); GLenum attachments[<span class="hljs-number"><span class="hljs-number">2</span></span>] = {GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1}; f-&gt;glDrawBuffers(<span class="hljs-number"><span class="hljs-number">2</span></span>, attachments); f-&gt;glFramebufferRenderbuffer( GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderbuffer );</code> </pre> <br>  W√§hrend des zweiten Rendering-Durchlaufs erfolgt die Ausgabe des Fragment-Shaders in zwei Texturen, die mit glDrawBuffers explizit angegeben werden m√ºssen. <br>  Der gr√∂√üte Teil dieses Codes wird einmalig ausgef√ºhrt, wenn das Programm gestartet wird.  Der Code f√ºr die Textur- und Renderpufferspeicherzuordnung wird jedes Mal ausgef√ºhrt, wenn die Fenstergr√∂√üe ge√§ndert wird.  Nun fahren wir mit dem Code fort, der jedes Mal ausgef√ºhrt wird, wenn der Inhalt des Fensters aktualisiert wird. <br><pre> <code class="cpp hljs"> f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebufferNT); <span class="hljs-comment"><span class="hljs-comment">// ... rendering non-transparent objects ... // ....... // done! (you didn't expect me to explain how do I render primitives in OpenGL, did you? // It's not relevant for this topic</span></span></code> </pre> <br>  Wir haben gerade alle nicht transparenten Objekte in colorTextureNT gerendert und Tiefen in den Renderpuffer geschrieben.  Bevor Sie denselben Renderpuffer beim n√§chsten Rendering-Durchgang verwenden, m√ºssen Sie sicherstellen, dass alle Schreibvorg√§nge im Tiefen-Renderpuffer von nicht transparenten Objekten abgeschlossen sind.  Dies wird mit GL_FRAMEBUFFER_BARRIER_BIT erreicht.  Nachdem die transparenten Objekte gerendert wurden, rufen wir die Funktion ApplyTextures () auf, die den endg√ºltigen Rendering-Durchgang ausf√ºhrt, bei dem der Fragment-Shader aus den Texturen colorTextureNT, colorTexture und alphaTexture abtastet, um die Formel (2) anzuwenden.  Die Texturen m√ºssen zu diesem Zeitpunkt fertig sein, daher verwenden wir GL_TEXTURE_FETCH_BARRIER_BIT, bevor wir ApplyTextures () aufrufen. <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> GLfloat clearColor[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> GLfloat clearAlpha = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); f-&gt;glClearBufferfv(GL_COLOR, <span class="hljs-number"><span class="hljs-number">0</span></span>, clearColor); f-&gt;glClearBufferfv(GL_COLOR, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;clearAlpha); f-&gt;glMemoryBarrier(GL_FRAMEBUFFER_BARRIER_BIT); PrepareToTransparentRendering(); { <span class="hljs-comment"><span class="hljs-comment">// ... rendering transparent objects ... } CleanupAfterTransparentRendering(); f-&gt;glMemoryBarrier(GL_TEXTURE_FETCH_BARRIER_BIT); f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, defaultFBO); ApplyTextures();</span></span></code> </pre> <br>  defaultFBO ist ein Framebuffer, mit dem wir das Bild auf dem Bildschirm anzeigen.  In den meisten F√§llen ist es 0, in Qt jedoch QOpenGLWidget :: defaultFramebufferObject (). <br><br>  Bei jedem Aufruf eines Fragment-Shaders haben wir Zugriff auf Farbe und Deckkraft des aktuellen Fragments.  In colorTexture muss jedoch eine Summe (und in alphaTexture ein Produkt) dieser Entit√§ten erscheinen.  Daf√ºr verwenden wir Blending.  Wenn wir ber√ºcksichtigen, dass wir f√ºr die erste Textur eine Summe berechnen, w√§hrend wir f√ºr die zweite ein Produkt berechnen, m√ºssen wir f√ºr jeden Anhang unterschiedliche Mischungseinstellungen (glBlendFunc und glBlendEquation) bereitstellen. <br><br>  Hier ist der Inhalt der Funktion PrepareToTransparentRendering (): <br><pre> <code class="cpp hljs"> f-&gt;glEnable(GL_DEPTH_TEST); f-&gt;glDepthMask(GL_FALSE); f-&gt;glDepthFunc(GL_LEQUAL); f-&gt;glDisable(GL_CULL_FACE); f-&gt;glEnable(GL_MULTISAMPLE); f-&gt;glEnable(GL_BLEND); f-&gt;glBlendFunci(<span class="hljs-number"><span class="hljs-number">0</span></span>, GL_ONE, GL_ONE); f-&gt;glBlendEquationi(<span class="hljs-number"><span class="hljs-number">0</span></span>, GL_FUNC_ADD); f-&gt;glBlendFunci(<span class="hljs-number"><span class="hljs-number">1</span></span>, GL_DST_COLOR, GL_ZERO); f-&gt;glBlendEquationi(<span class="hljs-number"><span class="hljs-number">1</span></span>, GL_FUNC_ADD);</code> </pre> <br><br>  Und Inhalt der Funktion CleanupAfterTransparentRendering (): <br><pre> <code class="cpp hljs"> f-&gt;glDepthMask(GL_TRUE); f-&gt;glDisable(GL_BLEND);</code> </pre> <br>  In meinem Fragment-Shader steht w f√ºr Deckkraft.  Das Produkt aus Farbe und w - und w selbst - geht zum ersten Ausgabeparameter und 1 - w geht zum zweiten Ausgabeparameter.  F√ºr jeden Ausgabeparameter muss ein Layoutqualifizierer in Form von "location = X" festgelegt werden, wobei X ein Index eines Elements im Anhangsarray ist - das, das wir der Funktion glDrawBuffers gegeben haben.  Um genau zu sein, geht der Ausgabeparameter mit location = 0 an die an GL_COLOR_ATTACHMENT1 gebundene Textur und der Parameter mit location = 1 an die an GL_COLOR_ATTACHMENT1 gebundene Textur.  Dieselben Zahlen werden in den Funktionen glBlendFunci und glBlendEquationi verwendet, um anzugeben, f√ºr welchen Farbanhang wir die Mischparameter festlegen. <br><br>  Der Fragment-Shader: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core in vec3 color; layout (location = 0) out vec4 outData; layout (location = 1) out float alpha; layout (location = 2) uniform float w; void main() { outData = vec4(w * color, w); alpha = 1 - w; }</span></span></code> </pre> <br>  In der ApplyTextures () -Funktion zeichnen wir einfach ein Rechteck, das das gesamte Ansichtsfenster abdeckt.  Der Fragment-Shader tastet Daten aus allen drei Texturen ab, wobei aktuelle Bildschirmraumkoordinaten als Texturkoordinaten und ein aktueller Beispielindex (gl_SampleID) als Beispielindex f√ºr Mehrfachmustertexturen verwendet werden.  Das Vorhandensein der Variablen gl_SampleID im Shader-Code veranlasst das System, den Fragment-Shader einmal pro Sample aufzurufen (w√§hrend er normalerweise einmal pro Pixel aufgerufen wird und seine Ausgabe in alle Samples schreibt, die in ein Grundelement fallen). <br><br>  Der Vertex-Shader ist einfach trivial: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core const vec2 p[4] = vec2[4]( vec2(-1, -1), vec2( 1, -1), vec2( 1, 1), vec2(-1, 1) ); void main() { gl_Position = vec4(p[gl_VertexID], 0, 1); }</span></span></code> </pre> <br><br>  Der Fragment-Shader: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core out vec4 outColor; layout (location = 0) uniform sampler2DMS colorTextureNT; layout (location = 1) uniform sampler2DMS colorTexture; layout (location = 2) uniform sampler2DMS alphaTexture; void main() { ivec2 upos = ivec2(gl_FragCoord.xy); vec4 cc = texelFetch(colorTexture, upos, gl_SampleID); vec3 sumOfColors = cc.rgb; float sumOfWeights = cc.a; vec3 colorNT = texelFetch(colorTextureNT, upos, gl_SampleID).rgb; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (sumOfWeights == 0) { outColor = vec4(colorNT, 1.0); return; } float alpha = 1 - texelFetch(alphaTexture, upos, gl_SampleID).r; colorNT = sumOfColors / sumOfWeights * alpha + colorNT * (1 - alpha); outColor = vec4(colorNT, 1.0); }</span></span></code> </pre> <br>  Und schlie√ülich - ApplyTextures () -Funktion: <br><pre> <code class="cpp hljs"> f-&gt;glActiveTexture(GL_TEXTURE0); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); f-&gt;glActiveTexture(GL_TEXTURE1); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTexture); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); f-&gt;glActiveTexture(GL_TEXTURE2); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, alphaTexture); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); f-&gt;glEnable(GL_MULTISAMPLE); f-&gt;glDisable(GL_DEPTH_TEST); f-&gt;glDrawArrays(GL_TRIANGLE_FAN, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre> <br><br>  Am Ende m√ºssen OpenGL-Ressourcen freigegeben werden.  Ich mache es im Destruktor meines OpenGL-Widgets: <br><pre> <code class="cpp hljs"> f-&gt;glDeleteFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebufferNT); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTextureNT); f-&gt;glDeleteRenderbuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;depthRenderbuffer); f-&gt;glDeleteFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebuffer); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTexture); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;alphaTexture);</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457292/">https://habr.com/ru/post/de457292/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457282/index.html">"Tod Gottes" oder der Zusammenbruch allgemein anerkannter Gesetze zum Aufbau von IT-Teams und zur Schaffung von IT-Systemen im 21. Jahrhundert</a></li>
<li><a href="../de457284/index.html">WBOIT in OpenGL: Transparenz ohne Sortierung</a></li>
<li><a href="../de457286/index.html">Die L√∂sung von WorldSkills-Aufgaben des Netzwerkmoduls in der Kompetenz von "CCA". Teil 1 - Grundeinstellung</a></li>
<li><a href="../de457288/index.html">Kryptografische Workstation basierend auf PKCS # 11-Token. Elektronische Signatur. Teil 2</a></li>
<li><a href="../de457290/index.html">DEFCON 25 Konferenz. Garry Kasparov. "Die letzte Schlacht des Gehirns." Teil 2</a></li>
<li><a href="../de457294/index.html">"Live high" oder meine Geschichte vom Aufschub bis zur Selbstentwicklung</a></li>
<li><a href="../de457298/index.html">Frontend Weekly Digest (17. - 23. Juni 2019)</a></li>
<li><a href="../de457300/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 370 (17. - 23. Juni 2019)</a></li>
<li><a href="../de457302/index.html">10 Funktionen zur Beschleunigung der Datenanalyse in Python</a></li>
<li><a href="../de457304/index.html">Statistikdienste f√ºr mobile Anwendungen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>