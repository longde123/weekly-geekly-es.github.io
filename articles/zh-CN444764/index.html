<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👐🏿 👩🏻‍🎓 🤳🏾 Java密码学 💿 🤰 🤞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 我向您介绍Jakob Jenkov撰写的文章“ Java密码学”的翻译。 


 该出版物是第一篇Java密码学文章的翻译，该文章是针对那些想学习Java密码学基础知识的初学者的。 
 目录： 


1. Java密码学 
2. 密码 
3. 留言摘要 
4. Mac电脑 
5. 签章 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Java密码学</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444764/"><p>哈Ha！ 我向您介绍Jakob Jenkov撰写的文章<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ Java密码学”</a>的翻译。 </p><br><p> 该出版物是第一篇<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Java密码学</a>文章的翻译，该文章是针对那些想学习Java密码学基础知识的初学者的。 </p><a name="habracut"></a><br><h2 id="oglavlenie"> 目录： </h2><br><ol><li>  Java密码学 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">密码</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">留言摘要</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Mac电脑</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">签章</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">密钥对</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">密钥生成器</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">密钥对生成器</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">密钥库</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">按键工具</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">证明书</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">证书工厂</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">证书路径</a> </li></ol><br><h1 id="java-cryptography">  Java密码学 </h1><br><p>  <strong>Java密码学API</strong>提供了对Java中的数据进行加密和解密以及管理密钥，签名和认证（认证）消息，计算密码哈希等等的功能。 </p><br><p> 本文介绍了如何使用Java密码API执行需要安全加密的各种任务的基础知识。 </p><br><p> 本文不介绍密码学理论的基础。 您将不得不在其他地方看到此信息。 </p><br><h2 id="rasshirenie-kriptografii-java">  Java密码学扩展 </h2><br><p>  Java密码学API由所谓的<strong>Java密码学扩展</strong> （JCE）提供。  JCE长期以来一直是Java平台的一部分。 最初，由于美国对加密技术的出口限制，JCE与Java分离。 因此，最强的加密算法未包含在标准Java平台中。 如果您的公司位于美国，则可以应用这些更强大的加密算法，但是在其他情况下，您将不得不使用较弱的算法或实现自己的加密算法并将其连接到JCE。 </p><br><p> 自2017年以来，美国出口加密算法的规则已大大放宽，在世界上大多数地区，您都可以通过Java JCE使用国际加密标准。 </p><br><p>  Java密码体系结构 </p><br><p>  <strong>Java密码体系结构（JCA）</strong>是Java内部密码API设计的名称。  JCA是围绕几个核心类和通用接口构建的。 这些接口的实际功能由供应商提供。 因此，您可以使用Cipher类来加密和解密某些数据，但是密码（加密算法）的具体实现取决于所使用的特定提供程序。 </p><br><p> 您也可以实现并连接自己的提供程序，但是您必须小心谨慎。 正确实现没有安全漏洞的加密非常困难！ 如果您不知道自己在做什么，最好使用内置Java提供程序或使用诸如Bouncy Castle之类的受信任提供程序。 </p><br><h3 id="osnovnye-klassy-i-interfeysy"> 主要类别和介面 </h3><br><p>  Java密码学API包含以下Java软件包： </p><br><ul><li>  java.security </li><li>  java.security.cert </li><li>  java.security.spec </li><li>  java.security.interfaces </li><li>  javax.crypto </li><li>  javax.crypto.spec </li><li>  javax.crypto.interfaces </li></ul><br><p> 这些软件包的主要类和接口： </p><br><ul><li> 提供者 </li><li> 安全随机 </li><li> 密码 </li><li> 留言摘要 </li><li> 签章 </li><li>  Mac电脑 </li><li> 算法参数 </li><li>  AlgorithmParameterGenerator </li><li> 关键工厂 </li><li>  SecretKeyFactory </li><li> 密钥对生成器 </li><li> 密钥生成器 </li><li> 关键协议 </li><li> 密钥库 </li><li> 证书工厂 </li><li>  CertPathBuilder </li><li>  CertPathValidator </li><li> 证书库 </li></ul><br><h3 id="provider-postavschik-kriptografii"> 提供者 </h3><br><p>  Provider类（java.security.Provider）是Java crypto API中的中心类。 为了使用Java crypto API，您需要安装密码提供程序。  Java SDK带有自己的加密提供程序。 除非您明确设置密码提供程序，否则将使用默认提供程序。 但是，此密码提供程序可能不支持您要使用的加密算法。 因此，您可能必须安装自己的加密提供程序。 </p><br><p>  Java加密API最受欢迎的加密提供程序之一称为Bouncy Castle。 这是一个示例，其中BouncyCastleProvider设置为加密提供程序： </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.bouncycastle.jce.provider.BouncyCastleProvider; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.security.Security; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProviderExample</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Security.addProvider(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BouncyCastleProvider()); } }</code> </pre> <br><h3 id="cipher-shifr"> 密码 </h3><br><p>  Cipher类（javax.crypto.Cipher）表示一种加密算法。 密码可用于加密和解密数据。 以下各节将对Cipher类进行更详细的说明，并在下面进行简要说明。 </p><br><p> 创建使用AES加密算法供内部使用的密码类的实例： </p><br><pre> <code class="java hljs">Cipher cipher = Cipher.getInstance(<span class="hljs-string"><span class="hljs-string">"AES/CBC/PKCS5Padding"</span></span>);</code> </pre> <br><p>  <em>Cipher.getInstance（...）</em>方法接受一个字符串，该字符串确定要使用的加密算法以及其他一些算法参数。 <br> 在上面的示例中： </p><br><ul><li>  AES-加密算法 </li><li>  CBC是AES算法可以工作的一种模式。 </li><li>  PKCS5Padding是AES算法应如何处理数据的最后字节进行加密的方式。 这到底是什么意思，请整体上看密码手册，而不是本文。 </li></ul><br><h4 id="inicializaciya-shifra"> 密码初始化 </h4><br><p> 在使用密码实例之前，必须对其进行初始化。 通过调用<em>init（）</em>方法初始化密码实例。  <em>init（）</em>方法采用两个参数： </p><br><ul><li> 模式-加密/解密 </li><li> 关键 </li></ul><br><p> 第一个参数指示密码实例的操作模式：加密或解密数据。 第二个参数指示它们用于加密或解密数据的密钥。 </p><br><p> 一个例子： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] keyBytes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[]{<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-number"><span class="hljs-number">13</span></span>,<span class="hljs-number"><span class="hljs-number">14</span></span>,<span class="hljs-number"><span class="hljs-number">15</span></span>}; String algorithm = <span class="hljs-string"><span class="hljs-string">"RawBytes"</span></span>; SecretKeySpec key = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecretKeySpec(keyBytes, algorithm); cipher.init(Cipher.ENCRYPT_MODE, key);</code> </pre><br><p> 请注意，此示例中的密钥创建方法是不安全的，不应在实践中使用。 以下各节中的本文将说明如何更安全地创建密钥。 </p><br><p> 要初始化密码实例以解密数据，必须使用Cipher.DECRYPT_MODE，例如： </p><br><pre> <code class="java hljs">cipher.init(Cipher.DECRYPT_MODE, key);</code> </pre> <br><h4 id="shifrovanie-ili-deshifrovanie-dannyh"> 数据加密或解密 </h4><br><p> 初始化密码后，您可以通过调用<em>update（）</em>或<em>doFinal（）</em>方法开始加密或解密数据。 如果要加密或解密一条数据，则使用<em>update（）</em>方法。 当您加密最后一条数据或传递给<em>doFinal（）</em>的数据块是用于加密的单个数据集时，将调用<em>doFinal（）</em>方法。 </p><br><p> 使用<em>doFinal（）</em>方法进行数据加密的示例： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] plainText = <span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvwxyz"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] cipherText = cipher.doFinal(plainText);</code> </pre> <br><p> 要解密数据，您需要将密文（数据）传递给<em>doFinal（）</em>或<em>doUpdate（）</em>方法。 </p><br><h3 id="keys-klyuchi"> 按键 </h3><br><p> 要加密或解密数据，您需要一个密钥。 密钥有两种，具体取决于使用哪种加密算法： </p><br><ul><li> 对称键 </li><li> 非对称密钥 </li></ul><br><p> 对称密钥用于对称加密算法。 对称加密算法使用相同的密钥进行加密和解密。 <br> 非对称密钥用于非对称加密算法。 非对称加密算法将一个密钥用于加密，将另一个密钥用于解密。 公钥和私钥加密算法是非对称加密算法的示例。 </p><br><p> 不知何故，需要解密数据的一方必须知道解密数据所需的密钥。 如果解密者不是数据加密的一方，则双方必须就密钥达成一致或交换密钥。 这称为密钥交换。 </p><br><h4 id="bezopasnost-klyucha"> 密钥安全 </h4><br><p> 密钥必须很难猜测，以使攻击者无法轻易获取加密密钥。 在上一节有关Cipher类的示例中，使用了一个非常简单的硬编码密钥。 实际上，这是不值得做的。 如果各方的密钥很容易猜到，那么攻击者将很容易解密加密的数据，并有可能自行创建虚假消息。 制作难以猜测的密钥非常重要。 因此，密钥应由随机字节组成。 随机字节越多，猜测就越困难，因为存在更多可能的组合。 </p><br><h4 id="generaciya-klyucha"> 密钥生成 </h4><br><p> 要生成随机加密密钥，可以使用Java KeyGenerator类。 以下几章将更详细地描述KeyGenerator，这是在此使用的一个小示例： </p><br><pre> <code class="java hljs">KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="hljs-string"><span class="hljs-string">"AES"</span></span>); SecureRandom secureRandom = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecureRandom(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> keyBitSize = <span class="hljs-number"><span class="hljs-number">256</span></span>; keyGenerator.init(keyBitSize, secureRandom); SecretKey secretKey = keyGenerator.generateKey();</code> </pre> <br><p> 可以将生成的SecretKey实例传递给<em>Cipher.init（）</em>方法，例如： </p><br><pre> <code class="java hljs">cipher.init(Cipher.ENCRYPT_MODE, secretKey);</code> </pre> <br><h4 id="generaciya-pary-klyuchey"> 密钥对生成 </h4><br><p> 非对称加密算法使用由公共密钥和私有密钥组成的密钥对来加密和解密数据。 要创建非对称密钥对，可以使用KeyPairGenerator（java.security.KeyPairGenerator）。 以下几章将更详细地描述KeyPairGenerator，以下是使用Java KeyPairGenerator的简单示例： </p><br><pre> <code class="java hljs">SecureRandom secureRandom = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecureRandom(); KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(<span class="hljs-string"><span class="hljs-string">"DSA"</span></span>); KeyPair keyPair = keyPairGenerator.generateKeyPair();</code> </pre> <br><h4 id="hranilische-klyuchey--key-store"> 密钥库 </h4><br><p>  Java KeyStore是可以包含密钥的数据库。  Java KeyStore由KeyStore类（java.security.KeyStore）表示。 密钥库可以包含以下类型的密钥： </p><br><ul><li> 私钥 </li><li> 公钥和证书（公钥+证书） </li><li> 秘钥 </li></ul><br><p> 私钥和公钥用于非对称加密。 公钥可以具有关联的证书。 证书是证明声称拥有公钥的个人，组织或设备的身份的文档。 </p><br><p> 证书通常由依赖方进行数字签名作为证据。 <br> 私钥用于对称加密，KeyStore类非常复杂，这就是为什么稍后在Java KeyStore的单独一章中对其进行详细描述的原因。 </p><br><h4 id="instrument-upravleniya-klyuchami-keytool"> 密钥管理工具（Keytool） </h4><br><p>  Java Keytool是可以与Java KeyStore文件一起使用的命令行工具。  Keytool可以在KeyStore文件中生成密钥对，导出证书并将证书导入KeyStore和其他一些功能。  Keytool随附Java安装。 稍后将在Java Keytool的单独一章中更详细地描述Keytool。 </p><br><h3 id="daydzhest-soobscheniya-messagedigest"> 留言文摘 </h3><br><p> 当您从另一端收到加密数据时，可以确定没有人在去往您的途中更改过加密数据吗？ </p><br><p> 通常，解决方案是先对数据中的消息摘要进行加密，然后再对数据和消息摘要进行加密，然后通过网络发送。 消息摘要是基于消息数据计算的哈希值。 如果加密数据中的至少一个字节被更改，则从该数据计算出的消息摘要也将更改。 </p><br><p> 收到加密的数据时，将其解密，从它们中计算出消息摘要，然后将计算出的消息摘要与随加密​​数据一起发送的消息摘要进行比较。 如果两个消息摘要相同，则很有可能（但不是100％）数据没有被更改。 </p><br><p>  Java MessageDigest（java.security.MessageDigest）可用于计算消息摘要。 若要创建MessageDigest的实例，将调用<em>MessageDigest.getInstance（）</em>方法。 有几种不同的消息摘要算法。 您需要指定创建MessageDigest实例时要使用的算法。 在Java MessageDigest一章中将更详细地描述使用MessageDigest。 </p><br><h4 id="kratkoe-vvedenie-v-klass-messagedigest">  MessageDigest类的简要介绍： </h4><br><pre> <code class="java hljs">MessageDigest messageDigest = MessageDigest.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA-256"</span></span>);</code> </pre> <br><p> 本示例创建一个MessageDigest实例，该实例使用SHA-256内部加密哈希算法来计算消息摘要。 </p><br><p> 要计算某些数据的消息摘要，请调用<em>update（）</em>或<em>digest（）</em>方法。 可以多次调用<em>update（）</em>方法，并在对象内部更新消息摘要。 传递完要包含在消息摘要中的所有数据后，可以调用<em>digest（）</em>并检索消息摘要摘要。 </p><br><p> 多次调用<em>update（）</em> ，然后调用<em>摘要（）</em>的示例： </p><br><pre> <code class="java hljs">MessageDigest messageDigest = MessageDigest.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA-256"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data1 = <span class="hljs-string"><span class="hljs-string">"0123456789"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data2 = <span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvxyz"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); messageDigest.update(data1); messageDigest.update(data2); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] digest = messageDigest.digest();</code> </pre> <br><p> 您还可以调用一次<em>digest（）</em> ，传递所有数据以计算消息的摘要。 一个例子： </p><br><pre> <code class="java hljs">MessageDigest messageDigest = MessageDigest.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA-256"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data1 = <span class="hljs-string"><span class="hljs-string">"0123456789"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] digest = messageDigest.digest(data1);</code> </pre> <br><h3 id="kod-autentifikacii-soobscheniya-mac"> 消息验证码（MAC） </h3><br><p>  Java Mac类用于从消息创建MAC（消息身份验证代码）。  MAC与消息摘要类似，但是使用其他密钥来加密消息摘要。 仅具有源数据和密钥，您可以检查MAC。 因此，与消息摘要相比，MAC是一种保护数据块免受修改的更安全的方法。  Mac类在Java Mac章节中有更详细的描述，然后进行简要介绍。 </p><br><p> 通过调用<em>Mac.getInstance（）</em>方法并传递要用作参数的算法名称来创建Java Mac实例。 看起来是这样的： </p><br><pre> <code class="java hljs">Mac mac = Mac.getInstance(<span class="hljs-string"><span class="hljs-string">"HmacSHA256"</span></span>);</code> </pre> <br><p> 从数据创建MAC之前，必须使用密钥初始化Mac实例。 这是使用密钥初始化Mac实例的示例： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] keyBytes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[]{<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span> ,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-number"><span class="hljs-number">13</span></span>,<span class="hljs-number"><span class="hljs-number">14</span></span>,<span class="hljs-number"><span class="hljs-number">15</span></span>}; String algorithm = <span class="hljs-string"><span class="hljs-string">"RawBytes"</span></span>; SecretKeySpec key = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecretKeySpec(keyBytes, algorithm); mac.init(key);</code> </pre> <br><p> 初始化Mac实例后，您可以通过调用<em>update（）</em>和<em>doFinal（）</em>方法从数据中计算MAC。 如果拥有用于计算MAC的所有数据，则可以立即调用<em>doFinal（）</em>方法。 看起来是这样的： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data = <span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvxyz"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data2 = <span class="hljs-string"><span class="hljs-string">"0123456789"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); mac.update(data); mac.update(data2); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] macBytes = mac.doFinal();</code> </pre> <br><h3 id="podpis-signature"> 签章 </h3><br><p>  Signature类（java.security.Signature）用于对数据进行数字签名。 对数据签名后，将从该数据创建数字签名。 因此，签名与数据分离。 </p><br><p> 通过从数据创建消息摘要（哈希）并使用必须对数据进行签名的设备，个人或组织的私钥对该消息摘要进行加密，可以创建数字签名。 加密消息的摘要称为数字签名。 </p><br><p> 要创建Signature的实例，请调用<em>Signature.getInstance（...）</em>方法： </p><br><pre> <code class="java hljs">Signature signature = Signature.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA256WithDSA"</span></span>);</code> </pre> <br><h4 id="podpis-dannyh"> 数据签名 </h4><br><p> 要对数据进行签名，必须通过调用initSign（...）方法并传递私钥对数据进行签名，从而以签名方式初始化签名实例。 在签名模式下初始化签名实例的示例： </p><br><pre> <code class="java hljs">signature.initSign(keyPair.getPrivate(), secureRandom);</code> </pre> <br><p> 初始化签名实例后，可以使用它对数据进行签名。 这是通过调用update（）方法并将签名数据作为参数传递来完成的。 您可以多次调用update（）方法来补充用于创建签名的数据。 将所有数据传递给update（）方法之后，将调用sign（）方法以获得数字签名。 看起来是这样的： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data = <span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvxyz"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); signature.update(data); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] digitalSignature = signature.sign();</code> </pre> <br><h4 id="proverka-podpisi"> 签名验证 </h4><br><p> 要验证签名，您需要在验证模式下通过调用<em>initVerify（...）</em>方法来初始化签名实例，并将用于验证签名的公钥作为参数传递。 在验证模式下初始化签名实例的示例如下所示： </p><br><pre> <code class="java hljs">Signature signature = Signature.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA256WithDSA"</span></span>); signature.initVerify(keyPair.getPublic());</code> </pre> <br><p> 在验证模式下初始化后，已签名的数据将传输到<em>update（）</em>方法。 取决于是否可以验证签名，对<em>verify（）</em>方法的调用将返回<em>true</em>或<em>false</em> 。 这是签名验证： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data2 = <span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvxyz"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); signature2.update(data2); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> verified = signature2.verify(digitalSignature);</code> </pre> <br><h4 id="polnyy-primer-podpisi-i-proverki"> 完整的签名和验证示例 </h4><br><pre> <code class="java hljs">SecureRandom secureRandom = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecureRandom(); KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(<span class="hljs-string"><span class="hljs-string">"DSA"</span></span>); KeyPair keyPair = keyPairGenerator.generateKeyPair(); Signature signature = Signature.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA256WithDSA"</span></span>); signature.initSign(keyPair.getPrivate(), secureRandom); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data = <span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvxyz"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); signature.update(data); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] digitalSignature = signature.sign(); Signature signature2 = Signature.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA256WithDSA"</span></span>); signature2.initVerify(keyPair.getPublic()); signature2.update(data); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> verified = signature2.verify(digitalSignature); System.out.println(<span class="hljs-string"><span class="hljs-string">"verified = "</span></span> + verified);</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN444764/">https://habr.com/ru/post/zh-CN444764/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN444752/index.html">SXSW的历史：一切起步</a></li>
<li><a href="../zh-CN444756/index.html">DARPA将开发火箭核发动机</a></li>
<li><a href="../zh-CN444758/index.html">BI系统的技术差异（Power BI，Qlik Sense，Tableau）</a></li>
<li><a href="../zh-CN444760/index.html">躺在车库里的数控机床</a></li>
<li><a href="../zh-CN444762/index.html">CSTroN-老式CSTN矩阵上的家用显示器，带有VGA输入和FPGA控制板</a></li>
<li><a href="../zh-CN444766/index.html">Facebook员工可以访问Facebook和Instagram用户密码</a></li>
<li><a href="../zh-CN444768/index.html">在生成对抗网络中减少对标记数据的依赖</a></li>
<li><a href="../zh-CN444770/index.html">我们如何在SameWeb中搜索数据泄漏</a></li>
<li><a href="../zh-CN444774/index.html">Google Chrome中的ru-RU语言环境迁移错误以及如何摆脱它</a></li>
<li><a href="../zh-CN444776/index.html">不要害怕尝试，否则我将在18岁以上成为程序员</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>