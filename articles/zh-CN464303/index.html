<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚈 🆔 🚈 关系DBMS中的时间序列数据。 PostgreSQL的TimescaleDB和PipelineDB扩展 🚒 🏽 👧🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="时间序列数据或时间序列是随时间变化的数据。 货币报价，运输运动的遥测，服务器访问或CPU负载的统计信息是时间序列数据。 要存储它们，需要特定的工具-临时数据库。 有许多工具，例如InfluxDB或ClickHouse。 但是，即使最好的时间序列存储解决方案也有缺点。 所有时间序列存储都是低级的，仅适...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>关系DBMS中的时间序列数据。 PostgreSQL的TimescaleDB和PipelineDB扩展</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/464303/"> 时间序列数据或时间序列是随时间变化的数据。 货币报价，运输运动的遥测，服务器访问或CPU负载的统计信息是时间序列数据。 要存储它们，需要特定的工具-临时数据库。 有许多工具，例如InfluxDB或ClickHouse。 但是，即使最好的时间序列存储解决方案也有缺点。 所有时间序列存储都是低级的，仅适用于时间序列数据，运行和注入当前堆栈非常昂贵且痛苦。 <br><br><img src="https://habrastorage.org/webt/sx/9x/bz/sx9xbzv26lix6lh-frspdsopknw.jpeg"><br><br> 但是，如果您拥有PostgreSQL堆栈，则可以忽略InfluxDB和所有其他时态数据库。 安装两个扩展，TimescaleDB和PipelineDB，并直接在PostgreSQL生态系统中存储，处理和分析时间序列数据。 没有引入第三方解决方案，没有临时存储的缺点，也没有运行它们的问题。 这些扩展是什么，它们的优点和功能是什么，将告诉“第一监控公司”开发部主管<b>Ivan Muratov（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">binakot</a> ）</b> 。 <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/3WkNp7mllv0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2> 什么是时间序列数据或时间序列？ </h2><br><blockquote> 这是关于他生命中不同阶段收集的过程的数据。 </blockquote><br> 例如，汽车的位置：速度，坐标，方向或服务器上资源的使用以及CPU上的负载，已使用的RAM和可用磁盘空间上的数据。 <br><br> 时间序列具有多个功能。 <br><br><ul><li> 在<b>固定带上</b> 。 任何时间序列记录都有一个带有时间戳的字段，在该字段上记录了该值。 <br></li><li>  <b>过程的特征，称为序列的级别</b> ：速度，坐标，负载数据。 <br></li><li> 几乎总是使用此类数据，它们<b>以仅追加模式工作</b> 。 这意味着新数据不会替代旧数据。 仅删除过时的数据。 <br></li><li>  <b>条目不能彼此分开考虑</b> 。 数据仅集体用于时间窗口，间隔或时间段。 <br></li></ul><br><h3> 流行的存储解决方案 </h3><br> 我从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">db-engines.com</a>拍摄的图表显示了过去两年中各种存储模型的流行。 <br><br><img src="https://habrastorage.org/webt/w2/wf/_u/w2wf_uryfor_djey8enzmrskywo.jpeg"><br><br> 领先的是时间序列存储，其次是图形数据库，然后是键值数据库和关系数据库。 专用存储库的普及与信息技术集成的快速增长相关：大数据，社交网络，物联网，高负载基础架构的监视。 除了有用的业务数据，甚至日志和指标也占用了大量资源。 <br><br><h3> 流行的时间序列数据存储解决方案 </h3><br> 该图显示了用于存储时间序列数据的专用解决方案。 比例是对数的。 <br><br><img src="https://habrastorage.org/webt/ny/bz/6_/nybz6_-_3ce7t0y7xre1oxkbks8.jpeg"><br><br> 稳定的领导者InfluxDB。 接触时间序列数据的每个人都听说过该产品。 但是该图显示TimescaleDB增长了十倍-关系DBMS的扩展正在争夺最初根据时间序列开发的产品在阳光下的地位。 <br><br><blockquote>  PostgreSQL不仅是一个很好的数据库，还是一个用于开发专用解决方案的可扩展平台。 </blockquote><br><h2>  Postgres，Postgis和TimescaleDB </h2><br> 第一监视公司使用卫星监视车辆的行驶。 我们跟踪20,000辆汽车，并存储两年的行驶数据。 总共，我们有10 TB的当前遥测数据。 平均而言，每辆车在行驶时每分钟会发送5条遥测记录。 数据通过导航设备发送到我们的远程信息处理服务器。 他们每秒接收500个导航数据包。 <br><br> 不久前，我们决定在全球范围内升级基础架构，并从整体迁移到微服务。 我们称这种新系统为Waliot，它已经在生产中-90％的车辆都转移到了该系统上。 <br><br> 基础架构发生了很多变化，但是中央链接保持不变-这是PostgreSQL数据库。 现在，我们正在开发版本10，并准备升级到11。除了PostgreSQL作为主要存储之外，在堆栈中，我们还使用PostGIS进行地理空间计算，并使用TimescaleDB来存储大量时间序列数据。 <br><br><h3> 为什么选择PostgreSQL？ </h3><br> 为什么我们要使用关系数据库来存储时间序列，而不是<s>使用</s>针对这种数据类型的<s>ClickHouse</s>专用解决方案？ 因为在积累专业知识和使用PostgreSQL的印象的背景下，我们不想将未知的解决方案用作主要存储。 <br><br><blockquote> 切换到新的解决方案是有风险的。 </blockquote><br> 有许多用于存储和处理时间序列数据的专业解决方案。 文档并不总是足够的，并且很多解决方案也不总是很好。 似乎每个新产品的开发人员都希望从头开始编写所有内容，因为在以前的解决方案中有些不愉快。 要了解到底不喜欢什么，您必须查找信息，进行分析和比较。 各种各样的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">top</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">评级</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">比较</a>比刺激尝试有些吓人。 您将不得不花费大量时间自行尝试所有解决方案。 我们承受不起几个月只能适应一种解决方案的负担。 这是一项艰巨的任务，所花费的时间永远也无法回报。 因此，我们选择了PostgreSQL扩展。 <br><br> 在Waliot基础架构的开发阶段，我们认为InfluxDB是主要的遥测存储库。 但是，当我遇到TimescaleDB并对其进行测试时，对选择没有任何疑问。 具有TimescaleDB扩展名的PostgreSQL允许您在同一PostGIS或PipelineDB存储中使用其他扩展名。 我们不需要提取数据，进行转换，进行分析并通过网络传输它们。 一切都位于一台服务器或群集系统中-无需拖动数据。 所有计算均在同一级别上进行。 <br><br> 最近，postgresmen帐户的作者<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nikolay Samokhvalov</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">发布了</a>一篇有趣的文章<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的链接</a> ，该文章有关使用SQL进行流数据处理。 本文的六分之五的作者参与了各种Apache产品的开发并使用流处理。 因此，本文提到了Confluent的Apache Spark，Apache Flink，Apache Beam，Apache Calcite和KSQL。 <br><br> 但是，并不是文章本身很有趣，而是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">讨论了Hacker News上</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">主题</a> 。 该主题的作者根据该文章写道，他几乎实现了所有基于PostgreSQL 11的想法。他使用CitusDB扩展进行水平缩放和分片，使用PipelineDB进行流计算和实例化视图，使用TimescaleDB来存储时间序列数据和分段。 他还使用了多个外部数据包装器。 <br><br><blockquote>  PostgreSQL及其扩展的疯狂组合再次证实PostgreSQL不仅仅是一个DBMS，它还是一个平台。 </blockquote><br> 当可插拔存储设备交付时……...！ <br><br> 具有讽刺意味的是，在研究解决方案时，我们发现了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Outflux（TimescaleDB</a>团队的发展），他们于4月1日发布了该出版物。 你觉得她做什么？ 这是一个实用程序，可在一个命令中从InfluxDB迁移到TimescaleDB ... <br><br><h3>  Postgres大肆宣传！ </h3><br> 不要小看炒作的力量！ 我们经常开玩笑说“发展是由炒作驱动的”，因为它会影响我们对调优和基础架构组件的看法。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">HighLoad ++上，</a>我们对PostgreSQL，ClickHouse，Tarantool进行了很多讨论-这些都是炒作。 只是不要说这不会影响您对基础架构的偏好和解决方案的选择...当然，这不是主要因素，但是有什么效果吗？ <br><br> 我已经使用PostgreSQL已有5年了。 我喜欢这个解决方案。 他几乎用力解决了我所有的任务。 每当这个基地出现问题时，我的双手都应该怪罪。 因此，选择是预定的。 <br><br><h2>  TimescaleDB VS PipelineDB </h2><br> 让我们继续扩展TimescaleDB和PipelineDB。 他们的创作者对扩展有何评价？ <br><br>  <b>TimescaleDB是一个</b>开源<b>时间序列数据库</b> ，已针对快速插入和复杂查询进行了优化。 <br><br>  <b>PipelineDB</b>是一种高性能扩展，旨在<b>对时间序列数据</b>运行连续的SQL查询。 <br><br> 除了使用时间序列数据外，它们都有类似的故事。  Timescale成立于2015年，Pipeline成立于2013年。第一个工作版本分别于2017年和2015年出现。 团队花了两年时间才发布最低功能。 这两个扩展的生产版本于去年10月发布，相差一个星期。 显然，彼此匆忙。 <br><br>  GitHub上有一堆星星和叉子，像往常一样，它们不是单个提交。 这就是开放源代码的工作方式，无需执行任何操作。 但是有很多明星， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TimescaleDB</a>比<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PipelineDB</a>还要多，甚至比PostgreSQL本身还要多。 <br><br> 扩展似乎是相似的，但是它们的位置不同。 <br><br>  <b>TimescaleDB</b>声称每秒插入数百万条记录，并存储了数千亿行和数十兆兆字节的数据。 该扩展比InfluxDB，Cassandra，MongoDB或Vanilla PostgreSQL更快。 支持流复制和备份工具。  TimescaleDB是扩展，而不是PostgreSQL的分支。 <br><br>  <b>PipelineDB</b>仅存储流计算的结果，而无需存储原始数据进行计算。 该扩展能够在实时数据流上连续聚合，并与常规表结合以在域域的上下文中进行计算。  PipelineDB是一个扩展，不是一个fork，但最初是一个fork。 <br><br><h2> 时间刻度 </h2><br> 现在详细介绍扩展。 让我们从TimescaleDB开始。 我和他一起工作了将近两年。 在发行版本之前将其拖到生产中。 让我们看一下如何应用它的示例。 <br><br>  <b>存储基础结构指标</b> 。 我们有Docker容器资源消耗指标，指标提交时间，容器标识符和资源消耗字段，例如空闲内存。 我们需要显示所有容器的统计信息，这些容器的平均可用内存窗口数为10秒。 您看到的查询解决了此问题，TimescaleDB可用作基础结构指标的存储库。 <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> time_bucket(<span class="hljs-string"><span class="hljs-string">'10 seconds'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">period</span></span>, container_id, <span class="hljs-keyword"><span class="hljs-keyword">avg</span></span>(free_mem) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> metrics <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>() - <span class="hljs-built_in"><span class="hljs-built_in">interval</span></span> <span class="hljs-string"><span class="hljs-string">'10 minutes'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">period</span></span>, container_id <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">period</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>, container_id;</code> </pre> <br><pre> <code class="plaintext hljs">period | container_id | avg -----------------------+--------------+--- 2019-06-24 12:01:00+00 | 16 | 72202 2019-06-24 12:01:00+00 | 73 | 837725 2019-06-24 12:01:00+00 | 96 | 412237 2019-06-24 12:00:50+00 | 16 | 1173393 2019-06-24 12:00:50+00 | 73 | 90104 2019-06-24 12:00:50+00 | 96 | 784596</code> </pre> <br>  <b>用于计算</b> 。 我们需要按天数计算离开克拉斯诺达尔的卡车数量及其总吨位。 <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> time_bucket(<span class="hljs-string"><span class="hljs-string">'1 day'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">day</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> trucks_exiting, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(weight) / <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> tonnage <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> vehicles <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> cities <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> cities.name = <span class="hljs-string"><span class="hljs-string">'Krasnodar'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> ST_Within(last_location, ST_Polygon(cities.geom, <span class="hljs-number"><span class="hljs-number">4326</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> ST_Within(current_location, ST_Polygon(cities.geom, <span class="hljs-number"><span class="hljs-number">4326</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">day</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">day</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre> <br> 它还使用PostGIS扩展程序中的函数来计算离开城市的交通量，而不仅仅是在城市中行驶。 <br><br>  <b>货币汇率监测</b> 。 第三个例子是关于加密货币的。 该请求使您可以显示以太坊的价格在过去两周中相对于比特币和美元的变化。 <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> time_bucket(<span class="hljs-string"><span class="hljs-string">'14 days'</span></span>, c.time) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">period</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">last</span></span>(c.closing_price, c.time) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> closing_price_btc, <span class="hljs-keyword"><span class="hljs-keyword">last</span></span>(c.closing_price, c.time) * <span class="hljs-keyword"><span class="hljs-keyword">last</span></span>(b.closing_price, c.time) filter (<span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> b.currency_code = <span class="hljs-string"><span class="hljs-string">'USD'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> closing_price_usd <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> crypto_prices c <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> btc_prices b <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> time_bucket(<span class="hljs-string"><span class="hljs-string">'1 day'</span></span>, c.time) = time_bucket(<span class="hljs-string"><span class="hljs-string">'1 day'</span></span>, b.time) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c.currency_code = <span class="hljs-string"><span class="hljs-string">'ETH'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">period</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">period</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre> <br> 对于我们的SQL来说，这一切都是同样清晰和方便的。 <br><br><h3>  TimescaleDB有什么很棒的地方？ </h3><br> 为什么不使用内置的表分区工具？ 为什么还要打碎桌子？ 显而易见的答案是<b>在此类数据库中的插入速度</b> 。 该图显示了不带分区的常规原始表格PostgreSQL 10与TimescaleDB超表之间每秒行数插入率的实际测量值。 <br><br><img src="https://habrastorage.org/webt/gq/ln/xd/gqlnxdxeupbqkf_i-wdeihs0zlq.jpeg"><br><br> 该基准测试在一台机器上写入了10亿行，模拟了从基础架构收集指标的场景。 该记录包含时间，基础结构组件的标识符和10个指标。 该基准测试在具有8个内核和28 GB RAM的Azure VM以及网络SSD驱动器上运行。 批量执行了1万条记录。 <br><br>  PostgreSQL性能的这种下降是从哪里来的？ 因为在插入时，还需要更新表索引。 当它们不适合缓存时，我们开始加载磁盘。 如果将我们要插入数据的部分的索引放在RAM中，则分区可以解决此问题。 <br><br> 让我们看下面的图表。 这比较了PostgreSQL 10中内置的声明性分区系统和TimescaleDB超表。 在水平轴上，截面数。 <br><br><img src="https://habrastorage.org/webt/kd/dz/xd/kddzxdttzspi9peoiriem7sipms.jpeg"><br><br> 在TimescaleDB中，随着节数的增加，降级可以忽略不计。 扩展开发人员声称他们在一个PostgreSQL实例中可以处理10,000个部分。 <br><br> 在PostgreSQL中，本机实现在3,000之后会大大降低，一般来说，PostgreSQL中的声明式分区是向前迈出的一大步，但仅适用于负载较小的表。 例如，对于商品，买方和其他进入系统的域实体，其强度不如度量标准。 <br><br> 在PostgreSQL的11和12版本中，将显示本机分区支持，您可以尝试对具有新版本的时间序列数据进行比较测试。 但是，在我看来，TimescaleDB仍然更好。  TimescaleDB的所有基准都可以在其<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github</a>上找到并尝试。 <br><br><h3> 主要特点 </h3><br> 希望您已经对该扩展感兴趣。 让我们看一下TimescaleDB的主要功能，以巩固这种感觉。 <br><br>  <b>通过超表进行分区</b> 。 对于已应用了create_hypertable（）函数的表，TimescaleDB使用术语“超速”。 之后，该表将成为所有继承节（块）的父项。 父表本身将不包含任何数据，但在自动创建新节时将成为所有查询的入口点和模板。 所有部分都不存储在数据的主要方案中，而是存储在特殊方案中。 这很方便，因为在数据模式中看不到成千上万的这些部分。 <br><br>  <b>该扩展已集成到调度程序和查询执行程序中</b> 。 通过PostgreSQL中的特殊钩子，TimescaleDB可以了解何时访问超表。  TimescaleDB分析查询，并根据SQL调用本身中的指定条件将查询仅重定向到必要的部分。 这使您可以在提取大量数据的过程中将工作与各部分并行化。 <br><br>  <b>扩展不对SQL施加限制</b> 。 您可以自由使用联合，聚合，窗口函数，CTE和其他索引。 如果您看到了内置分区系统的限制列表，则应该满意。 <br><br> 特定于时间序列数据的<b>其他有用功能</b> ： <br><br><ul><li>  “ Time_bucket”-健康人的“date_trun”； <br></li><li> 直方图-使用插值或最近的已知值填充错过的时间间隔； <br></li><li> 后台工作者的服务-允许您执行后台操作的服务：清理旧部分，重新​​组织。 <br></li></ul><br>  <b>TimescaleDB允许您停留在功能强大的PostgreSQL生态系统中</b> 。 此扩展不会破坏PostgreSQL，因此所有高可用性解决方案，备份系统，监视工具将继续起作用。  TimescaleDB和Grafana，Periscope，Prometheus，Telegraf，Zabbix，Kubernetes，Kafka，Seeq，JackDB是朋友。 <br><br>  <b>Grafana</b>已经对<b>TimescaleDB</b>作为数据源提供了本地支持。  Grafana开箱即用地了解PostscreSQL具有TimescaleDB。 仪表盘上Grafana中的查询构建器可以理解其他TimescaleDB函数，例如“ time_bucket”，“ first”，“ last”。 您可以使用这些时间序列函数直接从关系数据库中构建图，而无需进行大量查询。 <br><br>  <b>Prometheus有</b>一个适配器，允许您合并其中的数据并将TimescaleDB用作可靠的数据仓库。 使用适配器多年来不会在Prometheus中存储数据。 <br><br> 还有一个<b>Telegraf插件</b> 。 该解决方案使您可以完全删除Prometheus。 基础结构数据立即传输到TimescaleDB并通过Telegraf读取。 <br><br><h3> 许可证和新闻 </h3><br> 不久前，该公司转用了新的许可模式。 大多数代码在Apache 2.0下获得许可。 一小部分可免费使用，但已获得TSL的许可。 <br><br> 有一个带有商业许可证的企业版。 不用担心，不是企业版中的所有优点。 基本上，存在自动化，例如自动删除过时的块，这可以通过简单的“ cron”和类似的操作来完成。 <br><br> 现在，该公司正在积极研究集群解决方案。 也许它将落入企业版。 对于希望在投资者资金用尽之前设法进入市场的初创企业，还有一个云版本。 <br><br> 来自新闻： <br><br><ul><li> 在过去的一年半中，下载量达到了一百万； <br></li><li> 投资3100万美元； <br></li><li> 与MS Azure就物联网解决方案进行积极合作。 <br></li></ul><br><h3> 总结一下 </h3><br><blockquote>  TimescaleDB旨在存储时间序列数据。 与PostgreSQL中的本机分区相比，这是一个功能强大的分区系统，具有最小的限制。 </blockquote><br> 不幸的是，该扩展程序还没有多节点版本。 如果您需要多主机或分片，则必须使用CitusDB，例如。 如果要逻辑复制，将很受伤。 但这总是伤害着她。 <br><br><h2> 管道数据库 </h2><br> 现在让我们讨论第二个扩展。 不幸的是，我们无法在战斗中对其进行适当的测试。 现在它正在经历我们系统的适应阶段。 没错，我将在最后谈到一个问题。 <br><br> 与前面的情况一样，我们从实际示例开始。 容易理解扩展程序的好处以及使用它的动机。 <br><br>  <b>统计收集</b> 。 想象一下，我们收集了有关访问我们网站的统计信息。 我们需要分析最受欢迎的页面，唯一身份用户的数量以及一些资源延迟的想法。 所有这些都应该实时更新。 但是我们不想每次都触摸数据表并建立查询，或者更新表顶部的视图。 <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> CONTINUOUS <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">url</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> total_count, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">DISTINCT</span></span> cookie::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> uniques, <span class="hljs-keyword"><span class="hljs-keyword">percentile_cont</span></span>(<span class="hljs-number"><span class="hljs-number">0.99</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WITHIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> latency::<span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> p99_latency <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> page_views <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">url</span></span>;</code> </pre> <br><pre> <code class="plaintext hljs">url | total_count | uniques | p99_latency -----------+-------------+---------+------------ some/url/0 | 633 | 51 | 178 some/url/1 | 688 | 37 | 139 some/url/2 | 508 | 88 | 121 some/url/3 | 848 | 36 | 59 some/url/4 | 126 | 64 | 159</code> </pre> <br> 流处理和PipelineDB扩展可助您一臂之力。 该扩展添加了CONTINUES VIEW抽象。 在俄语版本中，这听起来像是“连续演示”。 将视图插入访问表后，此视图将自动更新，而只是基于新数据，而不会预先读取已记录的记录。 <br><br>  <b>数据流</b> 。  PipelineDB不仅限于新的视图类型。 假设我们进行A / B测试并收集有关新业务解决方案有效性的实时分析。 但是我们不想将数据存储在用户操作本身上。 我们只对结果感兴趣-哪个组的转化次数最多。 <br><br> 为了避免直接存储原始数据以进行流计算，我们需要诸如<b>streams-data stream</b>这样的抽象。  PipelineDB引入了此功能。 您可以创建类似于常规表的流。 在幕后，它将是基于ZeroMQ队列的“ FOREIGN TABLE”，扩展名是我们故意使用的。 数据进入ZeroMQ内部队列并触发对连续视图的更新。 <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> STREAM ab_event_stream ( <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, ab_group <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, event_type <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>), cookie <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> CONTINUOUS <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> ab_test_monitor <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, ab_group, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> WHENevent_type = <span class="hljs-string"><span class="hljs-string">'v'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> view_count, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> WHENevent_type = <span class="hljs-string"><span class="hljs-string">'c'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> conversion_count, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">DISTINCT</span></span> cookie) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> uniques <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ab_event_stream <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, ab_group;</code> </pre> <br> 然后，我们根据先前创建的流中的数据创建“连续视图”。 当数据到达流中时，将基于此数据更新视图。 之后，数据将被简单地丢弃，不会保存在任何地方并且不会占用磁盘空间。 这使您可以在几乎无限量的数据上进行分析，将其加载到PipelineDB数据流中，并从连续视图中读取计算结果。 <br><br>  <b>流计算</b> 创建数据流和连续视图之后，就可以使用流计算了。 看起来像这样。 <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> ab_event_stream (<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, ab_group, event_type, cookie) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">round</span></span>(random() * <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">round</span></span>(random() * <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ab_group, (<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> WHENrandom() &gt; <span class="hljs-number"><span class="hljs-number">0.4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'v'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-string"><span class="hljs-string">'c'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> event_type, <span class="hljs-keyword"><span class="hljs-keyword">md5</span></span>(random()::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> cookie <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">100000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ab_group, uniques <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ab_test_monitor; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ab_group, view_count * <span class="hljs-number"><span class="hljs-number">100</span></span> / (conversion_count + view_count) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> conversion_rate <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ab_test_monitor;</code> </pre> <br> 第一个“ SELECT”给出组“ ab”和唯一身份访问者的数量。 第二个-给出组之间的比率-转化。 这就是对关系数据库中五个SQL调用的所有A / B测试。 <br><br> 视图是动态更新的。 您不能等待整个数据阵列的处理，而是读取已经处理的中间结果。 视图的读取方式与常规PostgreSQL相同。 您还可以将视图与表或什至其他视图组合。 没有任何限制。 <br><br><h3> 拓扑结构 </h3><br>  Kafka接收遥测，Kafka中的主题将该数据发送到PostgreSQL，我们将其进一步汇总。 例如，我们结合一些普通表并将数据重定向到流。 此外，他引发了相应连续演示的更新，数据库客户端可以从中读取完成的数据。 <br><br><img src="https://habrastorage.org/webt/0e/4p/zb/0e4pzbehsh35td5tdiillcaq82m.jpeg"><br><br>  <i>PostgreSQL内部PipelineDB组件的拓扑示例。</i>  <i>该电路借鉴了德里克·尼尔森<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">（</a> Derek Nelson）的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">演讲</a> 。</i> <br><br> 除了流和视图之外，该扩展还提供了“转换”的抽象-转换器或增变器。 该视图旨在将传入的数据流转换为修改后的输出。 使用这些转换器，您可以更改数据的表示形式或对其进行过滤。 从增变器，所有这些都将进入“连续视图”视图。 我们已经在其中查询业务了。 任何熟悉函数式编程的人都应该理解这个想法。 <br><br> 在PipelineDB中，我们可以将触发器挂在视图上并执行操作，例如“警报”。 通过所有这些计算，我们永远不会自己存储原始数据，而我们都是以此为基础进行计算的。 这些可以是TB，我们可以按顺序将其上载到具有100 GB磁盘的服务器上。 毕竟，我们只对计算结果感兴趣。 <br><br><h3> 主要特点 </h3><br>  PipelineDB扩展比TimescaleDB难学习。 在TimescaleDB中，我们创建一个表，告诉她她是一个超表，并使用扩展提供的其他一些功能来享受生活。 <br><br>  <b>PipelineDB解决了关系数据库中的流计算问题</b> 。 就集成和使用而言，流数据处理的任务比分区要复杂得多。 但是，并非每个人都有海量数据和数十亿行。 如果有PipelineDB，为什么还要使基础架构复杂化？ 该扩展提供了自己的表示，流，转换器和聚合的实现，用于流处理。 它还<b>集成到查询计划器中，查询执行器</b>允许在关系数据库中实现流计算的概念。 <br><br> 与TimescaleDB一样，PipelineDB扩展<b>在PostgreSQL中没有施加SQL限制</b> 。 有几个功能，例如，您不能合并两个流，但这不是必需的。 <br><br>  <b>支持概率数据结构和算法</b> 。 该扩展直接在SQL中将Bloom Filter用于SELECT DISTINCT，将HyperLogLog用于COUNT（DISTINCT），将T-Digest用于percentile_count（）。 这提高了生产率。 <br><br>  <b>生态系统</b> 该扩展允许您使用常规的高可用性解决方案，监视工具以及PostgreSQL中熟悉的所有其他功能。 <br><br> 鉴于流计算的细节，PipelineDB <b>与Apache Kafka</b>和实时分析服务Amazon Kinesis <b>集成在一起</b> 。 由于PipelineDB不再是分支，而是扩展，因此与动物园其余部分的集成也应该是开箱即用的。 必须的，但我们并不生活在理想的世界中，一切都值得检查。 <br><br><h3> 许可证和新闻 </h3><br> 所有代码均在Apache 2.0下获得许可。 付费订阅可以支持不同的摄影画廊，以及具有商业许可的集群版本。 该公司基于PipelineDB提供Stride分析服务。 <br><br> 在开始讨论扩展名之前，我说过一个“但是”。 现在该谈论他了。 在2019年5月1日，PipelineDB团队宣布它现已成为Confluent的一部分。 这是一家开发KSQL的公司，KSQL是一种使用SQL语法在Kafka中流式传输数据的引擎。 现在，播客Debriefing的联合创始人Victor Gamov正在那里工作。 <br><br> 随之而来的是什么？  PipelineDB在1.0.0版上冻结。 除了修复关键错误外，没有任何计划。 由于这项收购，我们希望Uber将Kafka与PostgreSQL集成。 也许是基于可插拔存储的Confluent会做一些很棒的事情。 <br><br> 怎么办 转到TimescaleDB。 在最新版本中，他们使用二十一点制作了“连续视图”。 当然，现在的功能不如PipelineDB那样酷，但这只是时间问题。 <br><br><h3> 总结一下 </h3><br><blockquote>  PipelineDB专为高性能流数据处理而设计。 它使您可以对大型数据集执行计算，而不必保存数据本身。 </blockquote><br> 使用PipelineDB，当我们以流的形式将数据流发送到PostgreSQL时，我们认为它们是虚拟的。 我们不保存数据，而是汇总，计算和丢弃。 您可以创建一个200 GB的服务器，并通过流输出TB级的数据。 我们将得到结果，但是数据本身将被丢弃。 <br><br> 如果出于某种原因，TimescaleDB的“连续视图”对您来说还不够，请尝试使用PipelineDB。 这是Apache许可下的一个开源项目。 尽管不再积极开发它，但它不会走到任何地方。 但是情况可能会改变，Confluent尚未撰写有关扩展计划的文章。 <br><br><h2> 使用TimescaleDB和PipelineDB </h2><br> 使用PostgreSQL和两个扩展， <b>我们可以存储和处理大量时间序列数据</b> 。 您可以想到许多应用程序。 让我们从我的学科领域来看一个例子-车辆监控。 <br><br><img src="https://habrastorage.org/webt/mx/_k/ru/mx_krumolcfgrlfrraktizshhem.jpeg"><br><br> 导航设备不断将遥测记录发送到我们的服务器。 他们将各种文本和二进制协议解析为通用格式，并以特殊主题将数据发送到Kafka。 从那里，他们通过与PipelineDB集成到PostgreSQL内部的遥测数据流中。 该流更新了车辆当前状态和整个车队分析的视图，并基于触发器触发了在TimescaleDB超表中记录遥测记录。 <br><br> 通过扩展，我们具有三个优点。 <br><br><ul><li> 实时分析。 <br></li><li> 存储时间序列数据。 <br></li><li> 减少存储的遥测量。 使用PipelineDB增幅器，我们可以汇总数据（例如，在一分钟内），以计算平均值。 <br></li></ul><br>  Grafana具有对TimescaleDB功能的内置支持。 因此，有可能直接从框中根据业务度量标准构建图形，直到按坐标在地图上的轨迹进行构建。 分析部门会很高兴。 <br><br> 要自己“接触”所有内容，请查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub上的演示</a>并运行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Docker映像</a> -在最新PostgreSQL，TimescaleDB和PipelineDB的程序集中。 <br><br><h2> 合计 </h2><br>  PostgreSQL允许您组合各种扩展，以及添加自己的数据类型和函数来解决特定问题。 在我们的案例中，使用TimescaleDB和PostGIS扩展几乎可以完全满足存储时间序列数据和地理空间计算的需求。 借助PipelineDB扩展，我们可以对各种分析和统计数据执行连续的计算，并且使用JSONB列允许我们在关系数据库中存储结构较弱的数据。 头脑风暴足以解决开源问题-我们不使用商业解决方案。 <br><br> 这些扩展实际上并不限制PostgreSQL周围的生态系统，例如高可用性解决方案，备份系统，监视和日志分析工具。 如果有JSONB列，则不需要MongoDB；如果有TimescaleDB，则不需要InfluxDB。 <br><br><blockquote> 您是否喜欢伊凡（Ivan）的故事并希望分享类似的内容？ 在9月7日<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">之前</a>在莫斯科的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">HighLoad ++</a>上申请。 该计划正在逐步填补。    ,    ,  , ,  .    ,    ! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN464303/">https://habr.com/ru/post/zh-CN464303/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN464289/index.html">如何编写Go软件包</a></li>
<li><a href="../zh-CN464291/index.html">过去50年中十种最具影响力的编程语言及其创建者</a></li>
<li><a href="../zh-CN464293/index.html">钩子可以在React Redux中替换吗？</a></li>
<li><a href="../zh-CN464295/index.html">使用一些新的JavaScript功能的示例</a></li>
<li><a href="../zh-CN464299/index.html">0、0、1、0、2、0、2、2、1、6、0、5、0、2、6、5、4、0、5、3、0、3、2、9、0， 4，9，3，6，14，0，6，3，5，15，0，5，3，5 ...</a></li>
<li><a href="../zh-CN464305/index.html">小，是的。 爆竹微虚拟拆箱</a></li>
<li><a href="../zh-CN464307/index.html">在Scala上进行微服务的集成测试</a></li>
<li><a href="../zh-CN464309/index.html">DIY通话按钮。 Raspberry Pi，MajorDoMo，Freeswitch和Linphonec</a></li>
<li><a href="../zh-CN464315/index.html">有土壤的薄膜。 Yandex研究和按含义搜索的简要历史</a></li>
<li><a href="../zh-CN464317/index.html">Konbanwa项目</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>