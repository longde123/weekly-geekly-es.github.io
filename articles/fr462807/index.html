<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçì üèõÔ∏è üõåüèª WinForms: erreurs, Holmes üë™ üí™üèæ üîù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous aimons rechercher des bogues dans les projets Microsoft. Pourquoi? C'est simple: leurs projets sont g√©n√©ralement faciles √† v√©rifier (le travail p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WinForms: erreurs, Holmes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/462807/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/71b/aeb/a84/71baeba847a8865aef0cc8148effbb8c.png" alt="Image 5"></div><br>  Nous aimons rechercher des bogues dans les projets Microsoft.  Pourquoi?  C'est simple: leurs projets sont g√©n√©ralement faciles √† v√©rifier (le travail peut √™tre effectu√© imm√©diatement dans l'environnement Visual Studio, pour lequel PVS-Studio dispose d'un plug-in pratique) et ils contiennent peu d'erreurs.  Par cons√©quent, l'algorithme de travail habituel est le suivant: rechercher et t√©l√©charger un projet ouvert √† partir de MS;  v√©rifiez-le;  choisissez des erreurs int√©ressantes;  assurez-vous qu'ils sont peu nombreux;  √©crire un article sans oublier de f√©liciter les d√©veloppeurs.  Super!  Gagnant-gagnant-gagnant: cela a pris un peu de temps, le manuel est heureux de voir de nouveaux documents sur le blog, et le karma est en parfait √©tat.  Mais cette fois, quelque chose s'est mal pass√©.  Voyons ce qui a √©t√© trouv√© dans le code source de Windows Forms et si Microsoft devrait √™tre lou√© cette fois. <br><a name="habracut"></a><br>  <b>Pr√©sentation</b> <br><br>  D√©but d√©cembre 2018, Microsoft a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">annonc√©</a> la sortie de .NET Core 3 Preview 1. Un peu plus t√¥t (approximativement √† partir de la mi-octobre), GitHub a commenc√© un travail actif sur la publication du code source de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Windows Forms</a> , la plate-forme d'interface utilisateur .NET Core pour cr√©er des applications de bureau Windows.  Vous pouvez voir les statistiques de validation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Maintenant, n'importe qui peut t√©l√©charger le code source de WinForms pour examen. <br><br>  J'ai √©galement t√©l√©charg√© les sources pour y rechercher des erreurs √† l'aide de PVS-Studio.  La v√©rification n'a pas caus√© de difficult√©s.  Requis: Visual Studio 2019, aper√ßu du SDK .NET Core 3.0, PVS-Studio.  Et maintenant, le journal d'avertissement de l'analyseur est re√ßu. <br><br>  Apr√®s avoir re√ßu le journal PVS-Studio, je le trie g√©n√©ralement par ordre croissant de num√©ros de diagnostic (la fen√™tre avec le journal des messages PVS-Studio dans Visual Studio propose diff√©rentes options pour trier et filtrer la liste).  Cela vous permet de travailler avec des groupes d'erreurs du m√™me type, ce qui simplifie consid√©rablement l'analyse du code source.  Je marque des erreurs int√©ressantes dans la liste avec un ast√©risque, et seulement ensuite, apr√®s avoir analys√© l'int√©gralit√© du journal, j'√©cris des fragments de code et fais une description.  Et comme il y a g√©n√©ralement peu d'erreurs, je les m√©lange, en essayant de placer les plus int√©ressantes au d√©but et √† la fin de l'article.  Mais cette fois, les erreurs se sont av√©r√©es un peu importantes (oh, il n'a pas √©t√© possible de sauver l'intrigue pendant longtemps), et je les apporterai par ordre de num√©ros de diagnostic. <br><br>  Qu'a-t-on trouv√©?  833 avertissements du niveau de confiance √©lev√© et moyen (249 et 584, respectivement) ont √©t√© √©mis pour 540 000 lignes de code (√† l'exclusion des lignes vides) dans des fichiers de 1670 cs.  Et oui, selon la tradition, je n'ai pas v√©rifi√© les tests et n'ai pas pris en compte les avertissements du niveau de confiance faible (215 ont √©t√© √©mis).  Selon mes observations pr√©c√©dentes, il y a trop d'avertissements pour le projet de la part de MS.  Mais tous les avertissements ne sont pas des erreurs. <br><br>  Pour ce projet, le nombre de faux positifs √©tait d'environ 30%.  Dans environ 20% des cas, je ne pouvais tout simplement pas tirer une conclusion exacte quant √† savoir si c'√©tait une erreur ou non, car je ne connaissais pas bien le code.  Eh bien, au moins 20% des erreurs que j'ai manqu√©es peuvent √™tre attribu√©es au facteur humain: h√¢te, fatigue, etc.  √Ä propos, l'effet inverse est √©galement possible: j'ai regard√© √† travers certains d√©clencheurs du m√™me type, dont le nombre pourrait atteindre 70-80, √† travers un qui pourrait occasionnellement augmenter le nombre d'erreurs que je consid√©rais comme r√©elles. <br><br>  Dans tous les cas, 30% des avertissements indiquent des erreurs r√©elles, ce qui est un pourcentage tr√®s √©lev√©, √©tant donn√© que l'analyseur n'a pas √©t√© pr√©configur√©. <br><br>  Donc, le nombre d'erreurs que j'ai pu d√©tecter √©tait d'environ 240, ce qui est dans les limites des statistiques.  Je r√©p√®te, √† mon avis, pour un projet de MS, ce n'est pas le r√©sultat le plus remarquable (bien que ce ne soit que 0,44 erreur pour 1000 lignes de code), et il y a probablement plus d'erreurs r√©elles dans le code WinForms.  Je propose de parler des raisons √† la fin de l'article, mais voyons maintenant les erreurs les plus int√©ressantes. <br><br>  <b>Erreurs</b> <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3003</a> L'utilisation du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mod√®le</a> 'if (A) {...} else if (A) {...}' a √©t√© d√©tect√©e.  Il y a une probabilit√© de pr√©sence d'erreur logique.  V√©rifiez les lignes: 213, 224. ButtonStandardAdapter.cs 213 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PaintWorker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PaintEventArgs e, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> up, CheckState state)</span></span></span><span class="hljs-function"> </span></span>{ up = up &amp;&amp; state == CheckState.Unchecked; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (up &amp; IsHighContrastHighlighted()) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (up &amp; IsHighContrastHighlighted()) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } .... }</code> </pre> <br>  Dans les blocs <i>if</i> et <i>else if</i> , la m√™me condition est v√©rifi√©e.  Cela ressemble √† du copier-coller.  Est-ce une erreur?  Si vous regardez la d√©claration de la m√©thode <i>IsHighContrastHighlighted</i> , il y a un doute: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsHighContrastHighlighted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SystemInformation.HighContrast &amp;&amp; Application.RenderWithVisualStyles &amp;&amp; (Control.Focused || Control.MouseIsOver || (Control.IsDefault &amp;&amp; Control.Enabled)); }</code> </pre> <br>  La m√©thode peut probablement renvoyer diff√©rentes valeurs lors d'appels successifs.  Et ce qui est fait dans la m√©thode d'appel semble √©trange, bien s√ªr, mais il a droit √† la vie.  Cependant, je conseillerais aux auteurs de jeter un ≈ìil √† ce morceau de code.  Juste au cas o√π.  Et pourtant, c'est un bon exemple de la difficult√© de tirer des conclusions lors de l'analyse de code inconnu. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3004</a> L' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">instruction</a> 'then' est √©quivalente √† l'instruction 'else'.  RichTextBox.cs 1018 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SelectionCharOffset { get { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> selCharOffset = <span class="hljs-number"><span class="hljs-number">0</span></span>; .... NativeMethods.CHARFORMATA cf = GetCharFormat(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">// if the effects member contains valid info if ((cf.dwMask &amp; RichTextBoxConstants.CFM_OFFSET) != 0) { selCharOffset = cf.yOffset; // &lt;= } else { // The selection contains characters of different offsets, // so we just return the offset of the first character. selCharOffset = cf.yOffset; // &lt;= } .... } .... }</span></span></code> </pre> <br>  Et ici, l'erreur de copier-coller est d√©finitivement commise.  Quelle que soit la condition, la variable <i>selCharOffset obtiendra</i> toujours la m√™me valeur. <br><br>  Il y avait deux autres erreurs similaires dans le code WinForms: <ul><li>  V3004 L'instruction 'then' est √©quivalente √† l'instruction 'else'.  SplitContainer.cs 1700 </li><li>  V3004 L'instruction 'then' est √©quivalente √† l'instruction 'else'.  ToolstripProfessionalRenderer.cs 371 </li></ul><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3008</a> La variable se voit attribuer des valeurs deux fois de suite.  C'est peut-√™tre une erreur.  V√©rifiez les lignes: 681, 680. ProfessionalColorTable.cs 681 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitSystemColors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ref Dictionary&lt;KnownColors, Color&gt; rgbTable)</span></span></span><span class="hljs-function"> </span></span>{ .... rgbTable[ProfessionalColorTable.KnownColors.msocbvcrCBBdrOuterDocked] = buttonFace; rgbTable[ProfessionalColorTable.KnownColors.msocbvcrCBBdrOuterDocked] = buttonShadow; .... }</code> </pre> <br>  La m√©thode remplit le dictionnaire <i>rgbTable</i> .  L'analyseur a point√© un morceau de code o√π deux valeurs diff√©rentes sont √©crites s√©quentiellement sur la m√™me cl√©.  Et tout irait bien, mais il y avait 16 autres emplacements de ce type dans cette m√©thode, ce qui ne ressemble plus √† une seule erreur.  Mais pourquoi faire √ßa, pour moi √ßa reste un myst√®re.  Je n'ai trouv√© aucun signe de code g√©n√©r√© automatiquement.  Dans l'√©diteur, cela ressemble √† ceci: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/006/f68/827/006f688275da3701f28abe7918835ce9.png" alt="Image 3"></div><br>  Je donnerai les dix premi√®res op√©rations avec une liste: <br><br><ol><li>  V3008 La variable se voit attribuer des valeurs deux fois de suite.  C'est peut-√™tre une erreur.  V√©rifiez les lignes: 785, 784. ProfessionalColorTable.cs 785 </li><li>  V3008 La variable se voit attribuer des valeurs deux fois de suite.  C'est peut-√™tre une erreur.  V√©rifiez les lignes: 787, 786. ProfessionalColorTable.cs 787 </li><li>  V3008 La variable se voit attribuer des valeurs deux fois de suite.  C'est peut-√™tre une erreur.  V√©rifiez les lignes: 789, 788. ProfessionalColorTable.cs 789 </li><li>  V3008 La variable se voit attribuer des valeurs deux fois de suite.  C'est peut-√™tre une erreur.  V√©rifiez les lignes: 791, 790. ProfessionalColorTable.cs 791 </li><li>  V3008 La variable se voit attribuer des valeurs deux fois de suite.  C'est peut-√™tre une erreur.  V√©rifiez les lignes: 797, 796. ProfessionalColorTable.cs 797 </li><li>  V3008 La variable se voit attribuer des valeurs deux fois de suite.  C'est peut-√™tre une erreur.  V√©rifiez les lignes: 799, 798. ProfessionalColorTable.cs 799 </li><li>  V3008 La variable se voit attribuer des valeurs deux fois de suite.  C'est peut-√™tre une erreur.  V√©rifiez les lignes: 807, 806. ProfessionalColorTable.cs 807 </li><li>  V3008 La variable se voit attribuer des valeurs deux fois de suite.  C'est peut-√™tre une erreur.  V√©rifiez les lignes: 815, 814. ProfessionalColorTable.cs 815 </li><li>  V3008 La variable se voit attribuer des valeurs deux fois de suite.  C'est peut-√™tre une erreur.  V√©rifiez les lignes: 817, 816. ProfessionalColorTable.cs 817 </li><li>  V3008 La variable se voit attribuer des valeurs deux fois de suite.  C'est peut-√™tre une erreur.  V√©rifiez les lignes: 823, 822. ProfessionalColorTable.cs 823 </li></ol><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3011</a> Deux conditions oppos√©es ont √©t√© rencontr√©es.  La deuxi√®me condition est toujours fausse.  V√©rifiez les lignes: 5242, 5240. DataGrid.cs 5242 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckHierarchyState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (checkHierarchy &amp;&amp; listManager != null &amp;&amp; myGridTable != null) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (myGridTable == null) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { // there was nothing to check return; } for (int j = 0; j &lt; myGridTable.GridColumnStyles.Count; j++) { DataGridColumnStyle gridColumn = myGridTable.GridColumnStyles[j]; } checkHierarchy = false; } }</span></span></code> </pre> <br>  L' <i>instruction de retour</i> ne sera jamais ex√©cut√©e.  Tr√®s probablement, la condition <i>myGridTable! = Null</i> dans le bloc <i>if</i> externe a √©t√© ajout√©e ult√©rieurement lors du refactoring.  Et maintenant, v√©rifier <i>myGridTable == null est</i> inutile.  Pour am√©liorer la qualit√© du code, supprimez cette coche. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3019 Il est</a> possible qu'une variable incorrecte soit compar√©e √† null apr√®s la conversion de type √† l'aide du mot cl√© 'as'.  V√©rifiez les variables ¬´gauche¬ª, ¬´cscLeft¬ª.  TypeCodeDomSerializer.cs 611 <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3019 Il est</a> possible qu'une variable incorrecte soit compar√©e √† null apr√®s la conversion de type √† l'aide du mot cl√© 'as'.  V√©rifiez les variables ¬´droite¬ª, ¬´cscRight¬ª.  TypeCodeDomSerializer.cs 615 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Compare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object left, object right)</span></span></span><span class="hljs-function"> </span></span>{ OrderedCodeStatementCollection cscLeft = left as OrderedCodeStatementCollection; OrderedCodeStatementCollection cscRight = right as OrderedCodeStatementCollection; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (right == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (right == left) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cscLeft.Order - cscRight.Order; <span class="hljs-comment"><span class="hljs-comment">// &lt;= }</span></span></code> </pre> <br>  L'analyseur a imm√©diatement √©mis deux avertissements pour la m√©thode <i>Compare</i> .  Quel est le probl√®me?  C'est que les valeurs de <i>cscLeft</i> et <i>cscRight</i> ne sont pas v√©rifi√©es pour l'√©galit√© <i>nulle</i> .  Ils peuvent obtenir cette valeur apr√®s une <i>conversion</i> infructueuse vers le type <i>OrderedCodeStatementCollection</i> .  Ensuite, une exception sera lev√©e dans la derni√®re <i>instruction de retour</i> .  Une telle situation est possible lorsque tous les contr√¥les de <i>gauche</i> et de <i>droite</i> passent et n'aboutissent pas √† une sortie pr√©alable de la m√©thode. <br><br>  Pour corriger le code, <i>cscLeft</i> / <i>cscRight</i> doit √™tre utilis√© <i>partout</i> au lieu de <i>gauche</i> / <i>droite</i> . <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3020</a> Une ¬´pause¬ª inconditionnelle dans une boucle.  SelectionService.cs 421 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ISelectionService.SetSelectedComponents( ICollection components, SelectionTypes selectionType) { .... <span class="hljs-comment"><span class="hljs-comment">// Handle the click case object requestedPrimary = null; int primaryIndex; if (fPrimary &amp;&amp; 1 == components.Count) { foreach (object o in components) { requestedPrimary = o; if (o == null) { throw new ArgumentNullException(nameof(components)); } break; } } .... }</span></span></code> </pre> <br>  Ce fragment fait plut√¥t r√©f√©rence au code "avec odeur".  Il n'y a pas d'erreur ici.  Mais des questions se posent quant √† l'organisation du cycle <i>foreach</i> .  Pourquoi est-il n√©cessaire ici - c'est clair: en raison de la n√©cessit√© d'extraire les √©l√©ments de la collection, pass√©s sous <i>ICollection</i> .  Mais pourquoi dans la boucle, initialement con√ßue pour une seule it√©ration (une condition pr√©alable est la pr√©sence d'un seul √©l√©ment dans la collection de <i>composants</i> ), un filet de s√©curit√© suppl√©mentaire sous forme de <i>rupture √©tait</i> n√©cessaire?  Probablement, la r√©ponse peut √™tre envisag√©e: "Elle s'est d√©velopp√©e historiquement".  Le code a l'air moche. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3022 L'</a> expression 'ocxState! = Null' est toujours vraie.  AxHost.cs 2186 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> State OcxState { .... <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... ocxState = value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ocxState != null) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { axState[manualUpdate] = ocxState._GetManualUpdate(); licenseKey = ocxState._GetLicenseKey(); } else { axState[manualUpdate] = false; licenseKey = null; } .... } }</span></span></code> </pre> <br>  En raison d'une erreur logique, un ¬´code mort¬ª a √©t√© form√© dans ce fragment.  Les expressions du bloc <i>else</i> ne seront jamais ex√©cut√©es. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3027</a> La variable 'e' a √©t√© utilis√©e dans l'expression logique avant d'√™tre v√©rifi√©e par rapport √† null dans la m√™me expression logique.  ImageEditor.cs 99 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... ImageEditor e = ....; Type myClass = GetType(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!myClass.Equals(e.GetType()) &amp;&amp; e != null &amp;&amp; myClass.IsInstanceOfType(e)) { .... } .... }</code> </pre> <br>  La variable <i>e</i> dans la condition est d'abord utilis√©e, puis v√©rifi√©e pour l'in√©galit√© <i>nulle</i> .  Salut, <i>NullReferenceException</i> . <br><br>  Une autre erreur similaire: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3027</a> La variable 'dropDownItem' a √©t√© utilis√©e dans l'expression logique avant d'√™tre v√©rifi√©e par rapport √† null dans la m√™me expression logique.  ToolStripMenuItemDesigner.cs 1351 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnterInSituEdit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ToolStripItem toolItem)</span></span></span><span class="hljs-function"> </span></span>{ .... ToolStripDropDownItem dropDownItem = toolItem as ToolStripDropDownItem; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(dropDownItem.Owner is ToolStripDropDownMenu) &amp;&amp; dropDownItem != null &amp;&amp; dropDownItem.Bounds.Width &lt; commitedEditorNode.Bounds.Width) { .... } .... }</code> </pre> <br>  Une situation similaire √† la pr√©c√©dente, uniquement avec la variable <i>dropDownItem</i> .  Je pense que de telles erreurs apparaissent √† la suite d'une inattention lors du refactoring.  Probablement une partie de la condition <i>! (DropDownItem.Owner est ToolStripDropDownMenu) a</i> √©t√© ajout√©e au code plus tard. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">contr√¥le</a> r√©current <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3030</a> .  La condition 'columnCount&gt; 0' a d√©j√† √©t√© v√©rifi√©e √† la ligne 3900. ListView.cs 3903 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal ColumnHeader </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InsertColumn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, ColumnHeader ch, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> refreshSubItems)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// Add the column to our internal array int columnCount = (columnHeaders == null ? 0 : columnHeaders.Length); if (columnCount &gt; 0) { ColumnHeader[] newHeaders = new ColumnHeader[columnCount + 1]; if (columnCount &gt; 0) { System.Array.Copy(columnHeaders, 0, newHeaders, 0, columnCount); } .... } .... }</span></span></code> </pre> <br>  Une erreur qui peut sembler inoffensive.  En effet, eh bien, une v√©rification suppl√©mentaire est effectu√©e, ce qui n'affecte pas la logique du travail.  Et parfois, ils le font m√™me lorsque vous devez rev√©rifier l'√©tat d'un composant visuel, par exemple, en obtenant le nombre d'entr√©es dans la liste.  Seulement dans ce cas, ils rev√©rifient la variable <i>locale</i> <i>columnCount</i> .  C'est tr√®s suspect.  Soit ils voulaient v√©rifier une autre variable, soit dans l'un des contr√¥les, ils utilisent la mauvaise condition. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3061 Le</a> param√®tre 'lprcClipRect' est toujours r√©√©crit dans le corps de la m√©thode avant d'√™tre utilis√©.  WebBrowserSiteBase.cs 281 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> UnsafeNativeMethods.IOleInPlaceSite.GetWindowContext( out UnsafeNativeMethods.IOleInPlaceFrame ppFrame, out UnsafeNativeMethods.IOleInPlaceUIWindow ppDoc, NativeMethods.COMRECT lprcPosRect, NativeMethods.COMRECT lprcClipRect, NativeMethods.tagOIFI lpFrameInfo) { ppDoc = null; ppFrame = Host.GetParentContainer(); lprcPosRect.left = Host.Bounds.X; lprcPosRect.top = Host.Bounds.Y; .... lprcClipRect = WebBrowserHelper.GetClipRect(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= if (lpFrameInfo != null) { lpFrameInfo.cb = Marshal.SizeOf&lt;NativeMethods.tagOIFI&gt;(); lpFrameInfo.fMDIApp = false; .... } return NativeMethods.S_OK; }</span></span></code> </pre> <br>  Erreur √©vidente.  Oui, le param√®tre <i>lprcClipRect est</i> vraiment initialis√© avec une nouvelle valeur, sans l'utiliser en aucune fa√ßon.  Mais qu'est-ce que cela donne?  Je pense que quelque part dans le code appelant, le lien pass√© par ce param√®tre restera inchang√©, bien qu'il ait √©t√© con√ßu diff√©remment.  En effet, regardez travailler avec d'autres variables dans cette m√©thode.  M√™me son nom (le pr√©fixe ¬´Get¬ª) indique qu'une certaine initialisation sera effectu√©e √† l'int√©rieur de la m√©thode via les param√®tres pass√©s.  Et il en est ainsi.  Les deux premiers param√®tres ( <i>ppFrame</i> et <i>ppDoc</i> ) sont pass√©s avec le modificateur <i>out</i> et obtiennent de nouvelles valeurs.  Les liens <i>lprcPosRect</i> et <i>lpFrameInfo</i> permettent d'acc√©der aux champs de la classe et de les initialiser.  Et seul <i>lprcClipRect</i> sort de la liste g√©n√©rale.  Tr√®s probablement, le modificateur <i>out</i> ou <i>ref</i> est requis pour ce param√®tre. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3066</a> Ordre incorrect possible des arguments pass√©s √† la m√©thode 'AdjustCellBorderStyle': 'isFirstDisplayedRow' et 'isFirstDisplayedColumn'.  DataGridViewComboBoxCell.cs 1934 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnMouseMove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DataGridViewCellMouseEventArgs e)</span></span></span><span class="hljs-function"> </span></span>{ .... dgvabsEffective = AdjustCellBorderStyle( DataGridView.AdvancedCellBorderStyle, dgvabsPlaceholder, singleVerticalBorderAdded, singleHorizontalBorderAdded, isFirstDisplayedRow, <span class="hljs-comment"><span class="hljs-comment">// &lt;= isFirstDisplayedColumn); // &lt;= .... }</span></span></code> </pre> <br>  L'analyseur soup√ßonnait que les deux derniers arguments √©taient m√©lang√©s.  Jetons un coup d'≈ìil √† la d√©claration de la m√©thode <i>AdjustCellBorderStyle</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> DataGridViewAdvancedBorderStyle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustCellBorderStyle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DataGridViewAdvancedBorderStyledataGridViewAdvancedBorderStyleInput, DataGridViewAdvancedBorderStyle dataGridViewAdvancedBorderStylePlaceholder, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> singleVerticalBorderAdded, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> singleHorizontalBorderAdded, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isFirstDisplayedColumn, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isFirstDisplayedRow)</span></span></span><span class="hljs-function"> </span></span>{ .... }</code> </pre> <br>  On dirait une erreur.  Oui, souvent certains arguments sont intentionnellement pass√©s dans l'ordre inverse, par exemple, afin d'√©changer certaines variables.  Mais je ne pense pas que ce soit exactement le cas.  Rien dans les m√©thodes appelantes ou appel√©es ne dit un tel mod√®le d'utilisation.  Tout d'abord, les variables de type <i>bool√©en</i> sont confuses.  Deuxi√®mement, les noms des m√©thodes sont √©galement courants: pas de ¬´Swap¬ª ou ¬´Reverse¬ª.  De plus, il n'est pas si difficile de se tromper comme √ßa.  Les gens per√ßoivent souvent diff√©remment l'ordre de la paire ligne / colonne.  Pour moi, par exemple, juste ¬´ligne / colonne¬ª est familier.  Mais pour l'auteur de la m√©thode appel√©e <i>AdjustCellBorderStyle</i> , √©videmment, l'ordre le plus familier est ¬´colonne / ligne¬ª. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3070</a> La variable non initialis√©e 'LANG_USER_DEFAULT' est utilis√©e lors de l'initialisation de la variable 'LOCALE_USER_DEFAULT'.  NativeMethods.cs 890 <br><br><pre> <code class="cpp hljs">internal <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NativeMethods</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LOCALE_USER_DEFAULT = MAKELCID(LANG_USER_DEFAULT); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LANG_USER_DEFAULT = MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT); .... }</code> </pre> <br>  Une erreur rare.  L'ordre d'initialisation des champs de classe est m√©lang√©.  Pour calculer la valeur du champ <i>LOCALE_USER_DEFAULT</i> , utilisez le champ <i>LANG_USER_DEFAULT</i> , qui n'est pas encore initialis√© et a une valeur de 0. Par ailleurs, la variable <i>LANG_USER_DEFAULT</i> n'est utilis√©e nulle part ailleurs dans le code.  Je n'√©tais pas trop paresseux et j'ai √©crit un petit programme de console qui simule la situation.  Au lieu des valeurs de certaines constantes utilis√©es dans le code WinForms, j'ai substitu√© leurs valeurs r√©elles: <br><br><pre> <code class="cpp hljs">internal <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NativeMethods</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LOCALE_USER_DEFAULT = MAKELCID(LANG_USER_DEFAULT); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LANG_USER_DEFAULT = MAKELANGID(<span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x01</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MAKELANGID</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> primary, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sub)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((((ushort)(sub)) &lt;&lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) | (ushort)(primary)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MAKELCID</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lgid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MAKELCID(lgid, <span class="hljs-number"><span class="hljs-number">0x0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MAKELCID</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lgid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sort)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((<span class="hljs-number"><span class="hljs-number">0xFFFF</span></span> &amp; lgid) | (((<span class="hljs-number"><span class="hljs-number">0x000f</span></span>) &amp; sort) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>)); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Program</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.Console.WriteLine(NativeMethods.LOCALE_USER_DEFAULT); } }</code> </pre> <br>  √Ä la suite du lancement, les √©l√©ments suivants seront affich√©s sur la console: 0. Maintenant, nous <i>√©changeons</i> la d√©claration des <i>champs</i> <i>LOCALE_USER_DEFAULT</i> et <i>LANG_USER_DEFAULT</i> .  Le r√©sultat du programme sous cette forme: 1024. Je pense qu'il n'y a rien de plus √† commenter ici. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3080 D√©r√©f√©rence</a> nulle possible.  Envisagez d'inspecter les ¬´ces¬ª.  CodeDomSerializerBase.cs 562 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeserializeStatement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( IDesignerSerializationManager manager, CodeStatement statement)</span></span></span><span class="hljs-function"> </span></span>{ .... CodeExpressionStatement ces = statement as CodeExpressionStatement; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ces != null) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... DeserializeExpression(manager, null, ces.Expression); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } .... }</span></span></code> </pre> <br>  Le code qui doit "tomber" est suffisamment stable, car vous pouvez entrer dans la branche <i>else</i> juste au moment o√π la r√©f√©rence <i>ces</i> est <i>nulle</i> . <br><br>  Un autre exemple similaire: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3080 D√©r√©f√©rence</a> nulle possible.  Pensez √† inspecter 'comboBox'.  ComboBox.cs 6610 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateOwnerDrawRegions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ComboBox comboBox, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (comboBox != null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Rectangle topOwnerDrawArea = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rectangle(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, comboBox.Width, innerBorder.Top); .... }</code> </pre> <br>  Le code paradoxal.  Apparemment, ils ont m√©lang√© le test en √©crivant <i>if (comboBox! = Null)</i> au lieu de <i>if (comboBox == null)</i> .  Et donc - nous recevrons la prochaine <i>NullReferenceException</i> . <br><br>  Nous avons examin√© deux erreurs assez √©videntes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3080</a> , o√π vous pouvez suivre visuellement la situation de l'utilisation possible de r√©f√©rences nulles dans la m√©thode.  Mais les diagnostics du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3080 sont</a> beaucoup plus intelligents et peuvent rechercher des erreurs similaires pour les cha√Ænes d'appels de m√©thode.  Il n'y a pas si longtemps, nous avons consid√©rablement renforc√© les m√©canismes de flux de donn√©es et d'analyse interproc√©durale.  Vous pouvez en savoir plus √† ce sujet dans l'article " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Types de r√©f√©rence nullables en C # 8.0 et analyse statique</a> ".  Et voici une erreur similaire trouv√©e dans WinForms: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3080 D√©r√©f√©rence</a> nulle possible √† l'int√©rieur de la m√©thode sur 'reader.NameTable'.  Pensez √† inspecter le 1er argument: contentReader.  ResXResourceReader.cs 267 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnsureResData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... XmlTextReader contentReader = null; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fileContents != null) { contentReader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlTextReader(....); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reader != null) { contentReader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlTextReader(....); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fileName != null || stream != null) { .... contentReader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlTextReader(....); } SetupNameTable(contentReader); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } finally { .... } .... }</span></span></code> </pre> <br>  Regardez ce qui se passe avec la variable <i>contentReader</i> dans le corps de la m√©thode.  Apr√®s l'initialisation avec une r√©f√©rence nulle, suite √† l'une des v√©rifications, le lien sera initialis√©.  Cependant, une s√©rie de v√©rifications ne se termine pas par un bloc <i>else</i> .  Cela signifie que dans certains cas rares (ou en raison d'une refactorisation √† l'avenir), le lien peut toujours rester nul.  Ensuite, il sera transmis √† la m√©thode <i>SetupNameTable</i> , o√π il est utilis√© sans aucune v√©rification: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetupNameTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XmlReader reader)</span></span></span><span class="hljs-function"> </span></span>{ reader.NameTable.Add(ResXResourceWriter.TypeStr); reader.NameTable.Add(ResXResourceWriter.NameStr); .... }</code> </pre> <br>  Il s'agit d'un code potentiellement dangereux. <br><br>  Et encore une erreur, o√π l'analyseur a d√ª passer par une cha√Æne d'appels pour identifier un probl√®me: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3080 D√©r√©f√©rence</a> nulle possible.  Pensez √† inspecter la ¬´disposition¬ª.  DockAndAnchorLayout.cs 156 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Rectangle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAnchorDestination</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( IArrangedElement element, Rectangle displayRect, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> measureOnly)</span></span></span><span class="hljs-function"> </span></span>{ .... AnchorInfo layout = GetAnchorInfo(element); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> left = layout.Left + displayRect.X; .... }</code> </pre> <br>  L'analyseur pr√©tend qu'il est possible d'obtenir une r√©f√©rence nulle √† partir de la m√©thode <i>GetAnchorInfo</i> , qui <i>l√®vera</i> une exception lors du calcul de la valeur <i>gauche</i> .  Passons en revue toute la cha√Æne des appels et v√©rifions si c'est le cas: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> AnchorInfo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAnchorInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IArrangedElement element)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (AnchorInfo)element.Properties.GetObject(s_layoutInfoProperty); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key)</span></span></span><span class="hljs-function"> </span></span>=&gt; GetObject(key, out _); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key, out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> found)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> keyIndex = SplitKey(key, out <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> element); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!LocateObjectEntry(keyIndex, out <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index)) { found = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } <span class="hljs-comment"><span class="hljs-comment">// We have found the relevant entry. See if // the bitmask indicates the value is used. if (((1 &lt;&lt; element) &amp; s_objEntries[index].Mask) == 0) { found = false; return null; } found = true; switch (element) { case 0: return s_objEntries[index].Value1; .... default: Debug.Fail("Invalid element obtained from LocateObjectEntry"); return null; } }</span></span></code> </pre> <br>  En effet, dans certains cas, la m√©thode <i>GetObject</i> qui ferme la cha√Æne d'appel retournera <i>null</i> , qui sans aucun contr√¥le suppl√©mentaire sera pass√© √† la m√©thode appelante.  Probablement, la m√©thode <i>GetAnchorDestination</i> devrait pr√©voir une telle situation. <br><br>  Dans le code WinForms, il y avait pas mal d'erreurs de ce type, <b>plus de 70</b> .  Ils sont tous similaires et je ne donnerai pas leur description dans l'article. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3091</a> Analyse empirique.  Il est possible qu'une faute de frappe soit pr√©sente √† l'int√©rieur du litt√©ral de cha√Æne: "ShowCheckMargin".  Le mot ¬´ShowCheckMargin¬ª est suspect.  PropertyNames.cs 136 <br><br><pre> <code class="cpp hljs">internal <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PropertyNames</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ShowImageMargin = <span class="hljs-string"><span class="hljs-string">"ShowCheckMargin"</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ShowCheckMargin = <span class="hljs-string"><span class="hljs-string">"ShowCheckMargin"</span></span>; .... }</code> </pre> <br>  Un bon exemple d'une erreur qui n'est pas si facile √† d√©tecter.  Lors de l'initialisation des champs de classe, ils utilisent la m√™me valeur, bien que l'auteur du code ne le pense √©videmment pas (le copier-coller est √† bl√¢mer).  L'analyseur a tir√© cette conclusion en comparant les noms des variables et les valeurs des cha√Ænes attribu√©es.  Je n'ai donn√© que les lignes d'erreur, mais regardez √† quoi cela ressemble dans l'√©diteur de code: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/313/196/4de/3131964de8f3f5161678c44086ed2e40.png" alt="Image 2"></div><br>  C'est la d√©tection de telles erreurs qui d√©montre la puissance et le soin infini des outils d'analyse statique. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3095</a> L'objet 'currentForm' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 3386, 3404. Application.cs 3386 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunMessageLoopInner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reason, ApplicationContext context)</span></span></span><span class="hljs-function"> </span></span>{ .... hwndOwner = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HandleRef( null, UnsafeNativeMethods.GetWindowLong( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HandleRef(currentForm, currentForm.Handle), <span class="hljs-comment"><span class="hljs-comment">// &lt;= NativeMethods.GWL_HWNDPARENT)); .... if (currentForm != null &amp;&amp; ....) .... }</span></span></code> </pre> <br>  Classique  La variable <i>currentForm est</i> utilis√©e sans aucun contr√¥le.  Mais plus loin dans le code, il y a sa v√©rification de <i>l'</i> √©galit√© <i>nulle</i> .  Dans ce cas, je peux vous conseiller d'√™tre plus prudent lorsque vous travaillez avec des types de r√©f√©rence, ainsi que d'utiliser des analyseurs statiques :). <br><br>  Une autre erreur similaire: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3095</a> L'objet 'backgroundBrush' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 2331, 2334. DataGrid.cs 2331 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color BackgroundColor { .... <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!value.Equals(backgroundBrush.Color)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { if (backgroundBrush != null &amp;&amp; BackgroundBrush != DefaultBackgroundBrush) .... } } }</span></span></code> </pre> <br>  Dans le code WinForms, j'ai rencontr√© plus <b>de 60</b> erreurs de ce type.  √Ä mon avis, tous sont assez critiques et n√©cessitent l'attention des d√©veloppeurs.  Mais dans l'article, il n'est pas si int√©ressant d'en parler, je me limiterai donc aux deux mentionn√©s ci-dessus. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3125</a> L'objet '_propInfo' a √©t√© utilis√© et a √©t√© v√©rifi√© par rapport √† null dans diff√©rentes branches d'ex√©cution.  V√©rifiez les lignes: 996, 982. Binding.cs 996 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetPropValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object value)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_propInfo != null) .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _propInfo.SetValue(_control, value); } .... }</code> </pre> <br>  Pour compl√©ter l'image - √©galement une sorte de classique, bug <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3125</a> .  La situation inverse.  Au d√©but, une r√©f√©rence potentiellement nulle est utilis√©e en toute s√©curit√©, v√©rifiant la valeur <i>null</i> , mais ensuite, ils ne le font plus dans le code. <br><br>  Et une autre erreur similaire: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3125</a> L'objet 'propri√©taire' a √©t√© utilis√© apr√®s avoir √©t√© v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 64, 60. FlatButtonAppearance.cs 64 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> BorderSize { .... <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (owner != null &amp;&amp; owner.ParentInternal != null) { LayoutTransaction.DoLayoutIf(....); } owner.Invalidate(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } }</span></span></code> </pre> <br>  La beaut√©  Mais c'est du point de vue d'un chercheur ext√©rieur.  En effet, en plus de ces deux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3125</a> , l'analyseur a trouv√© plus <b>de 50</b> mod√®les similaires dans le code WinForms.  Les d√©veloppeurs ont du travail √† faire. <br><br>  Et enfin - une erreur assez int√©ressante, √† mon avis. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3137</a> La variable 'hCurrentFont' est affect√©e mais n'est pas utilis√©e √† la fin de la fonction.  DeviceContext2.cs 241 <br><br><pre> <code class="cpp hljs">sealed partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeviceContext</span></span></span><span class="hljs-class"> :</span></span> .... { WindowsFont selectedFont; .... <span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DisposeFont</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> disposing)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (disposing) { DeviceContexts.RemoveDeviceContext(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (selectedFont != null &amp;&amp; selectedFont.Hfont != IntPtr.Zero) { IntPtr hCurrentFont = IntUnsafeNativeMethods.GetCurrentObject( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HandleRef(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, hDC), IntNativeMethods.OBJ_FONT); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hCurrentFont == selectedFont.Hfont) { <span class="hljs-comment"><span class="hljs-comment">// select initial font back in IntUnsafeNativeMethods.SelectObject(new HandleRef(this, Hdc), new HandleRef(null, hInitialFont)); hCurrentFont = hInitialFont; // &lt;= } selectedFont.Dispose(disposing); selectedFont = null; } } .... }</span></span></code> </pre> <br>  Voyons ce que l'analyseur a alert√© et pourquoi le fait qu'une variable se voit attribuer une valeur, mais qu'elle ne sera pas utilis√©e dans la m√©thode √† l'avenir, peut indiquer un probl√®me. <br><br>  Une classe partielle est d√©clar√©e dans le fichier <i>DeviceContext2.cs</i> .  La m√©thode <i>DisposeFont est</i> utilis√©e pour lib√©rer des ressources apr√®s avoir travaill√© avec des graphiques: le contexte de l'appareil et les polices.  Pour une meilleure compr√©hension, j'ai fourni l'int√©gralit√© de la m√©thode <i>DisposeFont</i> .  Faites attention √† la variable locale <i>hCurrentFont</i> .  Le probl√®me est que la d√©claration de cette variable dans une m√©thode masque le champ de classe du m√™me nom.  J'ai trouv√© deux m√©thodes de la classe <i>DeviceContext</i> o√π un <b>champ</b> appel√© <i>hCurrentFont est utilis√©</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IntPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectFont</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WindowsFont font)</span></span></span><span class="hljs-function"> </span></span>{ .... hCurrentFont = font.Hfont; .... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetFont</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... hCurrentFont = hInitialFont; }</code> </pre> <br>  Jetez un ≈ìil √† la m√©thode <i>ResetFont</i> .  La derni√®re ligne <i>indique</i> exactement ce que fait la m√©thode <i>DisposeFont</i> dans le bloc <i>if</i> imbriqu√© (l'analyseur pointe vers cet endroit).  Et ce champ <i>hCurrentFont</i> du m√™me nom a √©t√© <i>d√©clar√©</i> dans une autre partie de la classe partielle dans le fichier <i>DeviceContext.cs</i> : <br><br><pre> <code class="cpp hljs">sealed partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeviceContext</span></span></span><span class="hljs-class"> :</span></span> .... { .... IntPtr hInitialFont; .... IntPtr hCurrentFont; <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br>  Ainsi, une erreur √©vidente a √©t√© commise.  Une autre question est sa criticit√©.  Maintenant, √† la suite de la m√©thode <i>DisposeFont travaillant</i> dans la section marqu√©e avec le commentaire ¬´s√©lectionner la police initiale de retour¬ª, le champ <i>hCurrentFont</i> ne se verra pas attribuer une valeur initiale.  Je pense que seuls les auteurs de code peuvent donner un verdict exact. <br><br>  <b>Conclusions</b> <br><br>  Donc, cette fois, je dois ¬´gronder¬ª un peu la SP.  Dans WinForms, il y avait beaucoup d'erreurs qui n√©cessitent une attention particuli√®re de la part des d√©veloppeurs.  Cela est peut-√™tre d√ª √† une certaine pr√©cipitation avec laquelle MS travaille sur .NET Core 3 et ses composants, y compris WinForms.  √Ä mon avis, le code WinForms est toujours "humide", mais j'esp√®re que la situation va bient√¥t changer pour le mieux. <br><br>  La deuxi√®me raison d'un grand nombre d'erreurs est peut-√™tre que notre analyseur s'est encore am√©lior√© pour les rechercher :). <br><br>  Soit dit en passant, un article de mon coll√®gue Sergey Vasiliev sera bient√¥t publi√© dans lequel il recherche et trouve pas mal de probl√®mes dans le code des biblioth√®ques .NET Core.  J'esp√®re que son travail contribuera √©galement √† am√©liorer les performances de la plateforme .NET, car nous essayons toujours de communiquer les r√©sultats de l'analyse de leurs projets aux d√©veloppeurs. <br><br>  Eh bien, pour ceux qui veulent am√©liorer leurs produits par eux-m√™mes ou mener des recherches pour trouver des erreurs dans les projets d'autres personnes, je sugg√®re de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">t√©l√©charger et d'essayer</a> PVS-Studio. <br><br>  Tout code propre! <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br>  Si vous souhaitez partager cet article avec un public anglophone, veuillez utiliser le lien vers la traduction: Sergey Khrenov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WinForms: erreurs, Holmes</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr462807/">https://habr.com/ru/post/fr462807/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr462795/index.html">Sch√©ma d√©claratif et ce qui ne va pas dans Magento 2</a></li>
<li><a href="../fr462797/index.html">Et encore une fois sur les nuages, pas seulement les pros</a></li>
<li><a href="../fr462801/index.html">15 outils indispensables pour les chefs de produit en 2019</a></li>
<li><a href="../fr462803/index.html">Migration d'un syst√®me ERP √† un autre</a></li>
<li><a href="../fr462805/index.html">Analyse: comment l'argent est-il r√©ellement prot√©g√© lors de la n√©gociation en bourse</a></li>
<li><a href="../fr462809/index.html">WinForms: erreurs, Holmes</a></li>
<li><a href="../fr462811/index.html">Pourquoi avons-nous besoin de g√©n√©riques dans Go?</a></li>
<li><a href="../fr462813/index.html">Ekaterinbourg, 14 ao√ªt - Mitap du groupe d'utilisateurs d'Atlassian</a></li>
<li><a href="../fr462819/index.html">Carences dans l'enseignement des langues dans la CEI: une vision polyglotte</a></li>
<li><a href="../fr462821/index.html">Comment √©valuer les ordinateurs qui n'existent pas encore</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>