<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✋🏿 👖 🔽 Wang Tiles untuk Simulasi Mesin Turing 👩🏼‍🤝‍👨🏿 🚉 🤱</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ubin Wang (domino) diciptakan oleh Hao Wang pada tahun 1961 untuk masalah matematika, tetapi banyak digunakan dalam game untuk membuat grafis ubin. Be...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wang Tiles untuk Simulasi Mesin Turing</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484974/">  Ubin Wang (domino) diciptakan oleh Hao Wang pada tahun 1961 untuk masalah matematika, tetapi banyak digunakan dalam game untuk membuat grafis ubin.  Berkat mereka, hasilnya tidak terlihat berulang, baik dalam tekstur 2D dan dalam model 3D dengan ubin. <br><br>  Tampaknya ubin Van juga mampu mengeksekusi mesin Turing, dan karenanya, Turing-complete, yang berarti mereka dapat menjalankan program apa pun. <br><br>  Ini adalah pernyataan yang luar biasa dan tidak bisa dipahami, jadi dalam posting ini saya akan menyelidiki sedikit masalah ini. <br><br><h2>  Secara singkat tentang Van Tiles </h2><br>  Ubin van adalah ubin persegi panjang di mana masing-masing wajah hanya dapat sesuai dengan wajah tertentu lainnya, tetapi untuk wajah tertentu ada beberapa ubin yang mungkin bisa sesuai dengan wajah itu.  Dengan mencocokkan wajah, maksud saya mereka terhubung dengan mulus tanpa membuat artefak visual atau tanda-tanda jahitan di antara ubin. <br><br>  Properti ini berguna untuk grafik, karena memungkinkan Anda untuk membuat grafik ubin yang mulus, tetapi konfigurasi lokasi ubin dapat sepenuhnya acak, asalkan semua wajah kompatibel satu sama lain.  Hasilnya adalah grafik ubin, yang sama sekali tidak seperti yang berulang, karena pola visual menjadi jauh lebih terlihat daripada grafik ubin tradisional. <br><br>  Contoh grafik, informasi lebih rinci, dan tautan ke Shadertoy dapat ditemukan di sini: <a href="https://blog.demofox.org/2014/08/13/wang-tiling/">Wang Tiling</a> . <br><br>  Ini adalah contoh yang saya buat.  Grafik saya adalah "programmer seni", tapi saya harap idenya jelas.  Gambar itu terdiri dari 16 ubin, dan untuk setiap wajah ada dua jenis wajah yang berbeda. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1dd/f35/586/1ddf35586684620140e0d28b0118dce1.png"></div><a name="habracut"></a><br><h2>  Secara singkat tentang mesin Turing </h2><br>  Mesin Turing diciptakan pada tahun 1936 oleh Alan Turing sebagai komputer umum, yang terbukti dapat menjalankan algoritma apa pun. <br><br>  Mesin Turing terdiri dari beberapa komponen utama: kaset memori, kepala baca / tulis, dan mesin negara. <br><br>  Kaset memori memiliki panjang tak terbatas, yaitu, ia memiliki kapasitas penyimpanan tak terbatas, dan pada awalnya itu diinisialisasi dengan nol saja. <br><br>  Kepala baca / tulis dimulai dari posisi tertentu dari kaset dan dapat membaca / menulis nilai-nilai, dan juga bergerak ke kiri dan ke kanan sepanjang rekaman itu. <br><br>  Mesin negara mengontrol kepala baca / tulis. <br><br>  Mesin negara tahu keadaan apa itu, dan memiliki aturan tentang apa yang harus dilakukan di setiap negara bagian ketika membaca nilai dari rekaman itu. <br><br>  Misalnya, di negara A, jika 0 dibaca dari kaset, maka aturannya adalah menulis 1 ke posisi rekaman saat itu, memindahkan kepala baca / tulis ke kanan, atau pergi ke negara B. Negara B dapat memiliki logika yang sama sekali berbeda dan dapat melakukan transisi kembali ke negara A, atau tetap di negara B, atau pindah ke negara yang sama sekali berbeda. <br><br>  Dengan menggunakan logika transisi antar negara yang begitu sederhana, algoritma komputer apa pun dapat dijalankan. <br><br>  Mesin Turing mungkin juga memiliki "Halt State," yang berarti bahwa program telah menyelesaikan eksekusi dan responsnya telah dihitung. <br><br>  Mencari beberapa program.  dapat dengan mudah dilihat.  bahwa seiring berjalannya waktu, mereka akan berakhir atau akan berada dalam lingkaran yang tak terbatas dan tidak akan pernah berhenti.  Beberapa program terletak di antara mereka, mereka kompleks dan tidak begitu mudah untuk menentukan apakah mereka akan pernah berhenti.  Turing membuktikan bahwa tidak ada solusi umum untuk menentukan apakah mesin Turing akan berhenti (ini adalah program komputer), dan ini disebut <a href="https://en.wikipedia.org/wiki/Halting_problem">masalah berhenti</a> .  Secara umum, satu-satunya cara untuk mengetahui apakah suatu program berhenti adalah menunggu.  Faktanya, dalam kasus umum, jawaban untuk pertanyaan ini adalah "ya" atau "belum", namun, dalam kasus banyak program tertentu, Anda dapat melihat bahwa setelah peluncuran mereka akan berakhir seiring waktu. <br><br><h2>  Perhitungan Wang Tile </h2><br>  Ternyata ubin Wang dapat mensimulasikan mesin Turing, yaitu, mereka Turing-lengkap, yang berarti bahwa mereka dapat menjalankan algoritma komputer apa pun. <br><br>  Untuk mewujudkan hal ini, kita memerlukan kolom ubin Van yang menunjukkan keadaan mesin Turing pada titik waktu tertentu, mulai dari waktu 0 di kolom paling kiri.  Kami akan menempatkan ubin di kolom di sebelah kanan dengan semua aturan wajah, dan kemudian membuat kolom di sebelah kanannya, dan seterusnya, sampai program berakhir (atau kami akan melakukan ini selamanya jika tidak berakhir).  Jika Anda memilih set ubin yang benar, maka memeriksa kepatuhan dengan aturan wajah dalam proses mengatur ubin akan cukup untuk menyelesaikan mesin Turing. <br><br>  Mari kita lihat contoh sederhana yang memiliki aturan logika mesin negara berikut: <br><br><ol><li>  Ketika mesin dalam keadaan A, maka dalam kasus membaca 0, kita menulis 1, memindahkan kepala baca / tulis ke bawah dan pergi ke negara B. </li><li>  Ketika mesin dalam keadaan A, dalam kasus membaca 1, program berhenti (beralih ke keadaan akhir). </li><li>  Ketika mesin dalam keadaan B, dalam kasus membaca 0, kita menulis 1, naikkan kepala baca-tulis dan lanjutkan ke keadaan A. </li><li>  Ketika mesin dalam keadaan B, dalam kasus membaca 1, program berhenti (masuk ke keadaan akhir) </li></ol><br><h3>  Tape drive </h3><br>  Pertama-tama, kita membutuhkan penyimpanan permanen untuk rekaman itu.  Untuk melakukan ini, kita perlu dua ubin berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d81/125/5dc/d811255dc542e1d46ff70e7dbeb94123.png"></div><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/adc/bd4/f89/adcbd4f89a80ff7b2dbed991803a2dba.png"></div><br>  Untuk menguji pekerjaan mereka, kami dapat menyiapkan segmen pita dengan beberapa nilai (membuat kolom ubin Van) dan memastikan bahwa ubin Van yang cocok yang terletak di sebelah kolom awal adalah ubin yang mentransfer nilai 0 dan 1 ke depan dalam waktu tanpa mengubah mereka. <br><br>  Dalam diagram di bawah ini, kami menginisialisasi rekaman dengan nilai 0101 di kolom paling kiri (waktu 0).  Hanya memiliki ubin dengan wajah yang kompatibel, kita melihat bahwa nilai-nilai dalam memori disimpan selamanya.  Kami telah mengimplementasikan drive memori! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/773/2b8/cff/7732b8cffe9ffaf7b33320070373485d.png"></div><br>  Kami akan mulai menunjukkan contoh kami dengan memori yang diinisialisasi ke 0, dan gambar di atas hanya menunjukkan kegigihan memori. <br><br><h3>  Mesin kepala baca-tulis </h3><br>  Kepala baca / tulis mesin Turing disajikan sebagai bagian dari informasi wajah.  Jadi, selain menyimpan wajah 0 atau 1, jika kepala baca / tulis ada di dalamnya, maka ia juga menyimpan keadaan mesin negara. <br><br>  Dalam contoh kami, dua status digunakan (tidak termasuk status akhir): A dan B. Jika 1 dibaca, maka di salah satu negara bagian (A atau B) program berakhir. <br><br>  Untuk menangani ini, kita perlu ubin berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d9/4a3/988/7d94a39887d1a95352c0205ff9f530eb.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4d/31b/a7a/a4d31ba7a6b49c895390e7caeda59479.png"></div><br>  Sekarang kita memiliki aturan untuk beralih ke kondisi akhir (aturan 2 dan 4), kita perlu memahami bagaimana menerapkan aturan yang mengontrol peralihan dari satu kondisi ke kondisi lain (aturan 1 dan 3). <br><br><h3>  Memindahkan kepala baca / tulis </h3><br>  Aturan 1 menyatakan bahwa jika kita berada dalam keadaan A dan membaca 0, kita harus menulis 1, memindahkan kepala baca / tulis ke bawah dan pergi ke negara B. <br><br>  Kita perlu ubin ini untuk membaca 0 dalam keadaan A, untuk menulis 1 sebagai keluaran, dan memerintahkan ubin di bawah ini untuk masuk ke keadaan B. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a3/85d/f54/3a385df54323ebee4f460b42899498a9.png"></div><br>  Ubin di bawah yang saat ini dapat memiliki nilai 0 atau 1;  tanpa mengetahui nilai tertentu, kita harus menyimpannya, tetapi menerima kepala baca / tulis dan dalam keadaan B. Untuk ini, kita perlu dua ubin - satu untuk 0 pada rekaman di posisi ini, yang lain untuk 1 pada pita. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/973/18c/7f8/97318c7f8e44bf70cb6537da8c2bbd9e.png"></div><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f8e/ab0/772/f8eab0772ad7827b994646a275b9f23b.png"></div><br>  Aturan 3 menyatakan bahwa jika kita berada di negara B dan membaca 0, kita harus menulis 1, memindahkan kepala baca-tulis ke atas dan pergi ke negara A. <br><br>  Untuk melakukan ini, kita memerlukan konstruksi yang mirip dengan konstruksi untuk aturan 1, tetapi kita tidak bergerak turun, tetapi naik.  Tiga ubin berikut akan memberikan hasil yang diinginkan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1a/d68/bd0/c1ad68bd057f7b7fa0bb228d158bb36b.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6f/e96/0da/a6fe960da1b315bda9d7461c7f2f4e6e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/a94/88e/8f3a9488eb5b556ed35942c58a02ddab.png"></div><br><h2>  Ubin Kolom Awal </h2><br>  Kami akan melihat batas-batas area simulasi seolah-olah mereka memiliki wajah "x". <br><br>  Ini berarti bahwa untuk membuat kolom awal (mesin Turing pada waktu 0) kita perlu dua ubin khusus.  Satu ubin diperlukan untuk menyimpan nilai 0 pada kaset, yang menginisialisasi rekaman itu, dan ubin lain - untuk menyimpan posisi kepala baca / tulis dalam keadaan A, yang merupakan keadaan awal kami. <br><br>  Dua ubin ini adalah: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edb/d34/969/edbd349698db9c4871c63fc44298fefe.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/199/6df/449/1996df4494d4b8ea4854ea1b3d2f9036.png"></div><br><h2>  Set ubin siap </h2><br>  Ini adalah 12 ubin lengkap yang akan kita gunakan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/853/d56/8c1/853d568c1a623fe7c1fc123dff3dd671.png"></div><br><h2>  Simulasi penuh </h2><br>  Berikut adalah desain asli dari mesin Turing kami pada waktu 0. Perhatikan bahwa ini adalah salah satu kondisi awal yang mungkin, tetapi ini adalah kondisi yang kami pilih.  Kami tidak memberikan kesempatan untuk memilih dari mana kepala baca / tulis dimulai, dan kehadirannya juga.  Jika kita hanya mengikuti aturan wajah, maka kita bisa mendapatkan 4 atau 0 kepala baca-tulis, atau nomor apa pun di antara mereka. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33e/5b8/e7a/33e5b8e7a21b1c52a54b28324f50665d.png"></div><br>  Dari sini, untuk membuat kolom kedua, kita mulai dari atas dan bergerak ke bawah, memilih ubin yang cocok dengan batasan wajah yang disentuhnya.  Pada langkah pertama ini, kepala membaca 0, menulis 1, bergerak ke bawah dan pergi ke keadaan B. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c6/551/9b1/4c65519b125288868d742b3f362e7380.png"></div><br>  Inilah langkah kedua, di mana kepala membaca 0, menulis 1, bergerak ke atas dan masuk ke keadaan A. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e2/5bd/1e0/3e25bd1e0afad891f739c61a500dbf4c.png"></div><br>  Berikut ini adalah langkah terakhir di mana kepala membaca 1 dan memasuki keadaan akhir, menunjukkan bahwa program selesai. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb8/25d/6bb/bb825d6bb75417f9863376d7f23524df.png"></div><br>  Program berakhir dan memberi kami nilai output 0110, atau 6. Nilai-nilai output ini tidak terlalu signifikan, tetapi program lain dapat menghasilkan output yang signifikan.  Sebagai contoh, kita dapat memaksa mesin Turing untuk menambahkan dua angka, dan output akan menjadi jumlah dari dua angka ini. <br><br><h2>  Detail penting </h2><br>  Di sini kita harus menyebutkan detail penting yang tidak kita pertimbangkan di atas, dan yang tidak disebutkan dalam sebagian besar penjelasan mesin Turing pada ubin Van. <br><br>  Ketika menempatkan ubin kedua untuk waktu 2, satu-satunya batasan pada wajah adalah bahwa ubin harus memiliki x di atas dan 1 di sebelah kiri.  Bahkan, karena ini, situasinya menjadi ambigu, karena tidak jelas mana dari dua ubin yang ditunjukkan di bawah ini yang harus dipilih. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/adc/bd4/f89/adcbd4f89a80ff7b2dbed991803a2dba.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/a94/88e/8f3a9488eb5b556ed35942c58a02ddab.png"></div><br>  Lalu bagaimana kita memilih yang benar? <br><br>  Jawabannya adalah kita hanya membuat asumsi dan memilih salah satunya.  Jika dalam kasus ini ubin yang salah dipilih, maka ketika kita beralih ke ubin berikutnya, kita akan mencari ubin dengan x di atas dan B0 di sebelah kiri.  Ubin semacam itu tidak ada, jadi kami tidak dapat menempatkan ubin tersebut.  Ketika ini terjadi, kita perlu kembali ke ubin terakhir dan mencoba salah satu opsi lain. <br><br>  Sayangnya, ketika mensimulasikan mesin Turing menggunakan ubin Wang, secara harfiah ada proses coba-coba, tetapi setidaknya itu cukup mudah dikelola.  Ini benar-benar menyulitkan perhitungan sedikit di pixel shader (atau di perangkat lain dengan paralelisme tinggi), tetapi biayanya tidak lebih. <br><br><h2>  Kesimpulan dan tautan </h2><br>  Beberapa tautan di bawah ini membahas ubin Wang dan mesin Turing, tetapi diskusi tersebut tampaknya tidak sepenuhnya mematuhi mesin Turing.  Sebagai contoh, Anda mungkin memperhatikan bahwa dalam beberapa contoh data diizinkan untuk mengembalikan "waktu" - ketika program berakhir, jawabannya ada pada rekaman pada waktu 0 dari mesin Turing, meskipun fakta bahwa data ini tidak ada pada waktu 0. Ini menunjukkan bahwa ubin Wang dapat melakukan perhitungan sendiri, tidak hanya mensimulasikan mesin Turing, tapi saya tidak tahu persis apa teknik ini akan disebut. <br><br>  Selain itu, jika Anda tertarik untuk mengetahui apa yang berguna dalam komputasi menggunakan ubin Wang, maka secara pribadi saya tidak bisa membayangkan kasus-kasus aplikasi praktis mereka.  Namun, para ilmuwan tampaknya telah menemukan bahwa DNA dapat bertindak dalam cara yang sama seperti ubin Van dalam arti bahwa koneksi dibuat hanya antara wajah yang kompatibel.  Berkat ini, perhitungan berbasis DNA sekarang sedang diteliti berdasarkan proses komputasi menggunakan ubin Wang.  Topik yang cukup menarik! <br><br>  Berikut adalah implementasi penghitungan bilangan prima menggunakan ubin Wang di Shadertoy di pixel shader WebGL: <br><br>  <a href="https://www.shadertoy.com/view/4sV3zK">Shadertoy: WangTiles: PrimeGenerator</a> <br><br>  Berikut adalah beberapa video hebat tentang mobil Turing dan masalah berhenti: <br><br>  <a href="https://www.youtube.com/watch%3Fv%3DdNRDvLACg5Q">Mesin Turing Dijelaskan - Computerphile</a> <br><br>  <a href="https://www.youtube.com/watch%3Fv%3DmacM_MtS_w4">Turing &amp; Masalah Pemutusan - Computerphile</a> <br><br>  Dan inilah beberapa tautan lagi: <br><br>  <a href="https://moyix.wordpress.com/2012/04/06/computing-with-tiles/">Komputasi dengan ubin</a> <br><br>  <a href="https://en.wikipedia.org/wiki/Wang_tile">Wikipedia: Ubin van</a> <br><br>  <a href="http://grahamshawcross.com/2012/10/12/wang-tiles-and-turing-machines/">Wang Tiles dan Mesin Turing</a> <br><br>  <a href="https://because0fbeauty.wordpress.com/2014/02/28/wang-tiles-1/">Wang Tiles - 1</a> <br><br>  Inilah beberapa artikel ilmiah: <br><br>  <a href="http://www.math.oregonstate.edu/~math_reu/proceedings/REU_Proceedings/Proceedings1989/2_Michie89.pdf">Komputasi dengan ubin</a> <br><br>  <a href="http://link.springer.com/chapter/10.1007%252F978-0-387-09680-3_13">Kompabilitas tilings</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id484974/">https://habr.com/ru/post/id484974/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id484954/index.html">Panduan Pemecahan Masalah Visual untuk Kubernetes</a></li>
<li><a href="../id484964/index.html">Mengkonfigurasi keseimbangan beban pada InfoWatch Traffic Monitor</a></li>
<li><a href="../id484966/index.html">Template siap pakai untuk pengujian menggunakan Spring</a></li>
<li><a href="../id484968/index.html">WPF DataGrid. Berjuang untuk Templat</a></li>
<li><a href="../id484972/index.html">Wine 5.0 dirilis</a></li>
<li><a href="../id484978/index.html">PubSub hampir gratis: PEMBERITAHUAN fitur di PostgreSQL</a></li>
<li><a href="../id484982/index.html">Apakah mudah untuk mengatur bisnis Anda untuk spesialis IT</a></li>
<li><a href="../id484984/index.html">Pengembang game unity. Kursus baru dari OTUS</a></li>
<li><a href="../id484990/index.html">Luxoft TechTalks - podcast video dari pakar IT global dan banyak lagi</a></li>
<li><a href="../id484992/index.html">Lebih cantik dalam proyek-proyek besar: luangkan 20 menit untuk pengaturan, lupakan memformat selamanya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>