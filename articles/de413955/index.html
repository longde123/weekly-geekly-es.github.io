<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔬 🕸️ 😘 Kompletter Entwicklungszyklus des IoT-Geräts zur Steuerung der Poolheizung auf dem ESP8266 in einer Arduino-Umgebung 🏳️‍🌈 👨🏿‍⚖️ 👩‍🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In dieser Veröffentlichung werde ich meine Erfahrungen mit der Erstellung eines IoT-Geräts von Grund auf teilen: von der Entstehung einer Idee und ihr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kompletter Entwicklungszyklus des IoT-Geräts zur Steuerung der Poolheizung auf dem ESP8266 in einer Arduino-Umgebung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413955/"><p>  In dieser Veröffentlichung werde ich meine Erfahrungen mit der Erstellung eines IoT-Geräts von Grund auf teilen: von der Entstehung einer Idee und ihrer Implementierung in Hardware bis zur Erstellung einer Firmware für einen Controller und einer Webschnittstelle für die Verwaltung eines erstellten Geräts über das Internet. </p><br><p>  Vor dem Erstellen dieses Geräts habe ich: </p><br><ul><li>  Schaltkreise fast nicht verstanden.  Nur auf der Ebene der Arbeitsprinzipien <br>  Widerstand / Transistor ... Ich hatte keine Erfahrung mit der Erstellung komplizierter Schaltungen. </li><li>  Nie entworfene Leiterplatten. </li><li>  Nie gelötete SMD-Komponente.  Das Niveau des Lötkolbens lag auf dem Niveau der Lötdrähte und einer Art Relais. </li><li>  Ich habe noch nie so komplexe Programme für einen Mikrocontroller geschrieben.  Die ganze Erfahrung war auf der Ebene „LED in Arduino anzünden“, und ich traf zum ersten Mal den ESP8266-Controller. </li><li>  Ich habe ziemlich viel C ++ für den "großen Bruder" geschrieben, aber das war vor mehr als einem Dutzend Jahren und alles wurde vor langer Zeit vergessen. </li></ul><br><p>  Die Erfahrung als Programmierer (hauptsächlich Microsoft .NET) und systemisches Denken haben mir natürlich geholfen, das Thema zu verstehen.  Ich denke, der Leser wird dazu in der Lage sein.  Nützliche Links und Artikel im Internet Meer.  Am interessantesten und hilfreichsten, um das Thema zu verstehen, bringe ich den Artikel mit. </p><a name="habracut"></a><br><h2>  Erklärung des Problems </h2><br><p>  Ich wohne in einem Privathaus in der Nähe von Minsk, und mein eigener Pool, wenn auch der einfachste, ist ein wesentlicher Bestandteil der „Vorteile“, die viele Menschen in einem Landhaus erhalten.  In unserem instabilen Klima stellte sich heraus, dass das Schwimmen im Pool im Freien unangenehm ist: Das Wasser kühlt sich nachts ab und windiges Wetter am Tag macht das Schwimmen nicht angenehm.  Letztes Jahr habe ich mit meinen eigenen Händen eine geodätische Kuppel eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">volleren</a> über dem Pool gebaut, einen Hügel gesetzt und einen Bungee aufgehängt - die Kinder sind glücklich. </p><br><img src="https://habrastorage.org/webt/hh/ec/xp/hhecxpolfqsqevq41tmn-84npsg.jpeg"><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Fotobericht über den</em> Bau der Kuppel auf Flickr.</a> </p><br><p>  Dieses Jahr ging ich noch weiter und beschloss, eine Poolheizung aus einem Gaskessel zu organisieren, <br>  Dies dient zum Heizen des Hauses im Winter und zum Heizen des Warmwassers im Sommer. </p><br><p>  Im Sommer schaltet der "Heizkreis" des Kessels mit Hilfe von Ventilen auf Heizung um <br>  Pool.  Das Poolwasser wird mit Hilfe eines Titan-Wärmetauschers erwärmt, dessen Primärkreislauf das Kühlmittel (heißes Wasser ohne Verunreinigungen) aus dem Heizkreislauf und das Sekundärwasser aus dem Pool durch eine Umwälzpumpe des Filtersystems pumpt.  Da ich den Pool mit einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chlorator benutze</a> (viele interessante Themen werden im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ForumHouse beschrieben</a> ), enthält das Wasser etwas Salz und ein Titan-Wärmetauscher wird benötigt.  Sie können das Wasser nicht einfach direkt durch den Kessel nehmen und lassen - sonst korrodieren Sie alle Rohre mit Salz. </p><br><img src="https://habrastorage.org/webt/d6/_k/pz/d6_kpzjpyzyvy2-vzk9aukvstko.png"><br><p>  Beim Durchgang durch den Wärmetauscher gibt der vom Kessel mit einer Temperatur von etwa 70 bis 90 ° C erhitzte Wärmeträger dem Wasser aus dem Pool Wärme ab und erwärmt es um einige Grad.  Das Kühlmittel selbst kühlt sich um einige zehn Grad ab und kehrt zum Kessel zurück, um wieder zu sein <br>  aufgewärmt.  Das Verhältnis der Wasserkühlung vom Kessel zur Warmwasserbereitung des Pools hängt von vielen Faktoren ab: der Kapazität des Wärmetauschers und der Geschwindigkeit der Wasserzirkulation im Primär- und Sekundärkreislauf. </p><br><p>  Die vom Pool mit dem Wärmetauscher verbundenen Rohre sind gewöhnliche Polyethylenrohre <br>  Wird derzeit zur Versorgung von Privathaushalten mit kaltem Wasser verwendet.  Billigkeit, Druckfestigkeit, Korrosionsfreiheit - das sind die Hauptvorteile solcher Rohre.  Bei allen Rohren aus Polyethylen ist die Betriebstemperatur ausnahmslos auf 40 Grad Celsius begrenzt.  Im Prinzip ist dies mehr als genug für den Pool. </p><br><p>  Es besteht jedoch eine hohe Wahrscheinlichkeit eines Notfalls bei der Pumpe <br>  Die Wasserumwälzung des Poolwassers stoppt aus irgendeinem Grund und der Kessel heizt den Wärmetauscher weiter auf. In diesem Fall steigt das Wasser im Sekundärkreis des Wärmetauschers schnell genug auf die Temperatur des Primärkreises an, was bedeutet, dass die Abschnitte der Polyethylenrohre neben dem Wärmetauscher schmelzen und das Wasser aus dem Pool flutet den ganzen Raum herum. </p><br><p>  Es muss möglich sein, die Überhitzung des Wärmetauschers zu schützen. </p><br><h2>  Schnelle Lösung </h2><br><p>  Um dieses Problem zu lösen, wurde ein Durchflusssensor, der nach dem Prinzip des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hall-Effekts arbeitet,</a> in den Kreislauf des Poolwasser-Umwälzkreislaufs aufgenommen.  Zusätzlich befinden sich Temperatursensoren im Sekundärkreis <br>  Wärmetauscher bieten eine zweite Verteidigungsstufe und verfolgen mögliche Überhitzung. </p><br><p>  Es ist unmöglich, die Überhitzung nur durch Temperatursensoren zu kontrollieren: Das System hat eine große Trägheit: nach einem plötzlichen Wasserstopp im Poolkreislauf bei <br>  Beim Abschalten des Kessels steigt die Temperatur noch einige Zeit an  Der Kessel treibt das erwärmte Wasser immer noch durch Trägheit entlang des Kreislaufs und verhindert so eine Überhitzung von „mir selbst, meinem Geliebten“. </p><br><p>  Daher ist es wichtig, so schnell wie möglich zu reagieren: nämlich den Wasserfluss im Kreislauf zu stoppen <br>  Pool. </p><br><p>  Ein Durchflusssensor wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">z</a> .  Das Kunststoffgehäuse und der fehlende Kontakt des Sensors mit Wasser ermöglichen die Verwendung in Salzwasser. </p><br><p>  Bei Temperatursensoren wurde beschlossen, den Dallas DS18B20 zu verwenden. Sie können problemlos mehrere Teile gleichzeitig an einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1-Draht-</a> Bus anschließen. </p><br><img src="https://habrastorage.org/webt/nd/pj/d5/ndpjd5v3_0lbaklr-ogjnaxribi.jpeg"><br><p>  Es wurde beschlossen, ein Paar Sensoren an den Ein- und Ausgang des Sekundär- und Primärteils zu hängen <br>  Schaltung: insgesamt 4 Sensoren.  Ein zusätzlicher Vorteil dieses Ansatzes ist <br>  Die Möglichkeit, Systemparameter zu überwachen: Sie können überwachen, wie stark das Kühlmittel im Primärkreislauf gekühlt und wie viel Wasser aus dem Pool im Sekundärkreislauf erwärmt wird.  Also - um die Heizoptimalität zu überwachen und den Zeitpunkt des Aufheizens vorherzusagen. </p><br><div class="spoiler">  <b class="spoiler_title">Sensorpositionen an Wärmetauscher- und Einlassrohren</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/en/vw/mi/envwmicj0l1hc76r23a_uvyjd3w.jpeg"></div></div><br><h2>  Geräteparameter </h2><br><p>  Der erste Prototyp des Geräts wurde auf Basis von Arduino Uno gebaut und erfolgreich gestartet. </p><br><img src="https://habrastorage.org/webt/ol/xh/rg/olxhrgxw-w4qqnjpzxkuhj7mc7u.png"><br><p>  Aber dann wurde klar, dass ich mehr möchte.  16 Kubikmeter Wasser erhitzt, auch nur knapp <br>  ein paar grad sind nicht schnell.  Und ich möchte die Heizparameter direkt von der Arbeit aus überwachen, ein- und ausschalten.  Gleichzeitig wäre es aber interessant, beispielsweise Heizpläne pro Tag zu erstellen. </p><br><p>  Nun, da wir bereits ein IoT-Gerät erhalten, warum steuern wir dann nicht gleichzeitig die Fernaktivierung des Poolchlorators und der Pumpe dafür? </p><br><h2>  Leistungsbeschreibung </h2><br><p>  Daher wurde beschlossen, ein Gerät zu entwickeln - einen multifunktionalen Pool-Controller.  Er muss in der Lage sein: </p><br><ul><li>  Um die Poolheizung über den Wärmetauscher zu steuern, schalten Sie den Gaskessel zum Erhitzen von Wasser ein / aus. </li><li>  Verhindern Sie eine Überhitzung des Wärmetauschers, indem Sie das Vorhandensein eines Poolwasserflusses im Sekundärkreislauf und die Übertemperatur des Sekundärkreislaufs überwachen. <br></li><li>  Anzeige der Heizungsstatistik in Echtzeit (Temperatur am Einlass und Auslass beider Kreisläufe). </li><li>  Zeichnen Sie die Temperaturwerte (Protokoll) im Flash-Speicher auf.  Daten anzeigen für <br>  ein bestimmter Zeitraum in Form eines Diagramms. </li><li>  Schalten Sie die Poolpumpen und den Chlorator mit einem Relais ein / aus. </li><li>  Verwalten Sie alle Geräteparameter remote über den integrierten Micro-Web-Server. </li></ul><br><p>  Es gab auch die Versuchung, Blink, MQTT zu schrauben.  Aber von diesen "Schnickschnack" in der ersten Stufe <br>  Es wurde beschlossen, abzulehnen.  Und noch mehr, ich würde die Möglichkeit der Kontrolle nicht irgendwo nach außen nutzen wollen.  Der eingebaute Webserver für meine Zwecke ist völlig ausreichend.  Die Sicherheit wird dadurch gewährleistet, dass Sie nur über ein VPN von außen in das Heimnetzwerk gelangen können. </p><br><h2>  Hardware </h2><br><p>  Als Controller wurde beschlossen, den billigen und beliebten ESP8266 zu verwenden.  Es war perfekt für meine Zwecke, abgesehen von einer Sache: Anpassung der Signalpegel von 5-Volt-Sensoren an die 3,3-Volt-Reglerlogik.  Im Prinzip scheinen Dallas-Sensoren bei 3 Volt zu arbeiten, aber ich habe eine ziemlich lange Leitung vom Controller zu den Sensoren, ungefähr 7 Meter.  Daher ist es besser, die Spannung zu erhöhen. </p><br><p>  Es wurde festgestellt, dass die Hardware erforderlich ist: </p><br><ul><li>  ESP8266-Controller oder sein älterer Bruder ESP32 (als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DevKit-</a> Modul). <br></li><li>  Ausrichtung der Signalpegel für Sensoren. </li><li>  Der Leistungsregler ist ein 5-Volt-Teil der Schaltung. </li><li>  Relaissteuermodul. </li><li>  RTC-Uhr + Flash-Speicher für die Protokollierung. </li><li>  Das einfachste 2-zeilige LCD-Display zur Anzeige der aktuellen Werte der Sensoren und des Status des Geräts und des Relais. </li><li>  Mehrere physische Tasten zur Steuerung des Status des Geräts ohne Zugriff über das Internet. </li></ul><br><p>  Viele Komponenten aus der Liste werden als Module für Arduino verkauft und viele Module sind mit 3.3V-Logik kompatibel.  Ich wollte dies jedoch nicht mit Drahtbündeln auf dem Steckbrett „jammen“, weil ich ein ordentlich schönes „Gerät“ haben möchte.  Ja, und für das Geld, das den Chinesen für die Module gegeben wird, können Sie Ihre individuelle Leiterplatte vollständig zeichnen und bestellen, und die Erwartung ihrer Ankunft wird durch eine relativ schnelle und zuverlässige Installation kompensiert. </p><br><p>  Ich stelle noch einmal fest, dass dies meine erste Erfahrung in der Schaltung und beim Entwerfen der Hardware solcher Dinge ist.  Ich musste viel lernen.  In meiner Spezialität bin ich ein bisschen distanziert von Mikrocontrollern.  Aber alles "auf meinen Knien" zu tun, erlaubte nicht den Geist des Perfektionismus, der in mir lebt. </p><br><h2>  Schaltplan </h2><br><p>  Es gibt eine große Anzahl von Programmen auf dem Markt, mit denen Sie eine Schaltung und eine Leiterplatte zeichnen können.  Ohne Erfahrung in diesem Bereich mochte ich sofort <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EasyEDA</a> - einen kostenlosen Online-Editor, mit dem Sie einen Schaltplan wunderschön malen, überprüfen können, ob nichts vergessen wurde und alle Komponenten Verbindungen haben, eine Leiterplatte zeichnen und dann sofort die Produktion bestellen. </p><br><p>  Die erste Schwierigkeit, auf die ich gestoßen bin: Es gibt viele Optionen für den DevKit ESP8266- oder ESP32-Controller, einige unterscheiden sich in der Position der Stifte und ihrem Zweck, andere sogar in der Breite.  Es wurde beschlossen, die Schaltung so zu zeichnen, dass DevKit in beliebiger Breite und mit beliebiger Position der Klemmen und an den Seiten davon angebracht werden kann - 2 Reihen Paar Überbrückungslöcher und anschließende Verkabelung, um die erforderlichen Klemmen in Bezug auf den speziell gekauften Controller zu verbinden. </p><br><p>  Platzieren Sie unter dem Controller und 2 Reihen gepaarter Jumper: JH1 und JH2 im Diagramm: </p><br><img src="https://habrastorage.org/webt/mz/a0/nl/mza0nlxbzvfaqjqcti7vc32ikbe.png"><br><p>  Die Position der Pins von Eingang 5 V und Ausgang 3,3 V der Stromversorgung des eingebauten Stabilisators sowie von GND schien mir für verschiedene DevKit gleich zu sein, aber ich entschied mich trotzdem, auf Nummer sicher zu gehen und sie auch zu Jumpern zu machen: JP1, JP2, JP3 im Diagramm. </p><br><p>  Ich beschloss, die Jumper zu signieren, indem ich sie mit Funktionen an die Komponenten der Schaltung anschloss, die sie wahrscheinlich ausführen werden. </p><br><div class="spoiler">  <b class="spoiler_title">Und so sieht es mit dem DevKit ESP8266 aus, das ich schließlich gekauft und installiert habe</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/cg/3p/b5/cg3pb5pg7clju7haw77dah1udhs.png"></div></div><br><p>  Hier sind D1 (GPIO5) und D2 (GPIO4) für den I2C-Bus verantwortlich, D5 (GPIO14) für 1-Draht, D6 (GPIO12) - für den Empfang von Impulsen vom Durchflusssensor. </p><br><p>  Schaltplan: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ar/jj/n3/arjjn3bgb-ffz_yjofhjy72q_cq.png"></a> <br>  (Bild anklickbar) </p><br><p>  Trotz des Vorhandenseins eines eingebauten Leistungsreglers für 3,3 V an Bord des ESP8266 benötigen wir immer noch 5 Volt für die Stromversorgung der Sensoren und des LCD und 12 Volt für die Stromversorgung des Relais.  Es wurde beschlossen, die Platine mit 12 Volt zu versorgen und den Spannungsregler AMS1117-5.0 am Eingang anzubringen, um die gewünschten 5 Volt am Ausgang zu erhalten. </p><br><p>  Um die Signalpegel auf dem 1-Draht-Bus anzupassen, habe ich einen BSS138 c-Feldeffekttransistor mit beidseitiger Spannung verwendet. </p><br><img src="https://habrastorage.org/webt/y_/sx/st/y_sxstfcgm3kys4hntq5beb5xby.png"><br><p>  Sehr gut über die Pegelanpassung wird im Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anpassen der logischen Pegel von 5-V- und 3,3-V-Geräten beschrieben</a> . </p><br><p>  Um die Signalpegel des Durchflusssensors anzupassen, habe ich nur einen Spannungsteiler über den Widerständen verwendet.  Der Durchflusssensor ist einfach ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offenes Kollektorgerät</a> .  Einige Sensoren verfügen möglicherweise bereits über einen eingebauten Pull-up-Widerstand. Dies sollte berücksichtigt werden: </p><br><img src="https://habrastorage.org/webt/9v/8e/br/9v8ebrvm_bsfzounu3kamf4grc8.png"><br><p>  Blau im Diagramm ist eine schematische Bezeichnung der Durchflusssensoranordnung.  Rechts vom Stecker befinden sich Spannungsteiler, die von mir ausgewählt wurden, um einen maximalen Pegel von 3,3 Volt am Ausgang zu haben. </p><br><p>  Am I2C-Bus habe ich eine DS3231SN-Echtzeituhr und einen AT24C256C-Flash-Speicher zum Speichern von Protokollen aufgehängt.  Der im ESP8266 integrierte Flash-Speicher ist nicht geeignet, da er nur wenige Umschreibzyklen aufweist (10 Tausend gegenüber 1 Million für AT24Cxxx laut Datenblättern). </p><br><p>  Die Relaissteuerung ist auf einer Reihe von PCF8574AT- und ULN2803A-Chips organisiert. </p><br><img src="https://habrastorage.org/webt/9v/8e/br/9v8ebrvm_bsfzounu3kamf4grc8.png"><br><p>  Der erste Chip ist ein I2C-Mikrocontroller-Port-Expander.  Der Status des aktiven Ausgangs oder Eingangs PCF8574AT wird durch Auswahl einer Adresse auf dem I2C-Bus ausgewählt. <br>  Der Chip verfügt über einige interessante Funktionen, die im Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">I2C-Port-Expander PCF8574 ausführlich beschrieben sind</a> . </p><br><p>  Der Chip kann die Last (Relais) nicht direkt steuern.  Hierzu wird eine Transistormatrix ULN2803A verwendet.  Es gibt eine Funktion: Die Matrix kann ihre Ausgänge leicht mit einer Last gegen Masse ziehen. Wenn also eine Versorgungsspannung an den zweiten Pol des Relais angelegt wird, fließt Strom durch die Relaiswicklung und die Relaiskontakte schließen.  Leider erhalten wir mit dieser Einbeziehung einen Nebeneffekt: Der Signalwert von der Steuerung wird invertiert und alle Relais "klicken", wenn die Schaltung eingeschaltet wird.  Ich habe noch nicht herausgefunden, wie diese Funktion entfernt werden kann. </p><br><p>  Weitere Informationen zum Chip finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><p>  Der Port-Expander PCF8574AT kann auch als Eingang verwendet werden: An einigen Eingängen können Hardwaretasten aufgehängt werden, um deren Werte auf dem I2C-Bus zu lesen.  In der Abbildung können die Pins 4-7 verwendet werden, um den Status der Tasten zu lesen.  Die Hauptsache ist nicht zu vergessen, programmgesteuert die eingebaute Straffung der entsprechenden Beine zur Ernährung zu ermöglichen. </p><br><p>  Gleichzeitig habe ich die Verkabelung der Transistormatrix überlassen, falls Sie plötzlich zusätzliche Relais anschließen möchten.  Für mögliche Verbindungen habe ich alle Kabel zu den Steckern gebracht (genauer gesagt zu den Löchern darunter, in denen die Drähte gelötet oder der Standard-2,54-mm-DIP-Stecker gelötet werden kann). </p><br><p>  Mit dem Pin des INT-Port-Expanders kann schnell auf Knopfdruck reagiert werden.  Es kann an einen freien Port des Controllers angeschlossen werden und den Interrupt-Trigger so einstellen, dass der Status dieses Pins geändert wird. </p><br><p>  Das zweizeilige LCD-Display wird ebenfalls über den PCF8574AT-Expander gesteuert.  Der Hauptpunkt: Das Display wird mit 5 Volt betrieben, während das Display selbst mit 3-Volt-Logik gesteuert wird.  Standard-Arduino-Adapter für I2C sind übrigens nicht für doppelte Spannung ausgelegt.  Ich habe die Idee einer solchen Verbindung irgendwo im Internet gefunden, leider habe ich den Link verloren, daher zitiere ich die Quelle nicht. </p><br><h2>  Leiterplatte </h2><br><p>  Bei der Entwicklung der Platine stellte sich heraus, dass normale Teile mit Beinen zu viel Platz beanspruchen und viele Chips im DIP-Design nicht leicht zu finden sind.  Nachdem ich im Internet gelesen hatte, dass die SMD-Installation nicht so kompliziert und mit den richtigen Fähigkeiten noch weniger zeitaufwändig ist, entschied ich mich, die Platine für SMD-Teile zu entwerfen.  Und ich habe mich nicht geirrt.  Es stellte sich heraus, dass es sich um ein kompaktes, wunderschönes Motherboard handelte, auf dem ich problemlos alles platzieren konnte, was ich brauchte.  SMD-Teile mit einem guten Lötkolben, Flussmittel und Lötmittel erwiesen sich als sehr einfach zu montieren. </p><br><p>  Auf der Platine habe ich ein paar quadratische Ränder von Löchern für das Prototyping hinzugefügt, wenn ich plötzlich etwas anderes löten möchte. </p><br><p>  Ich habe eine Leiterplatte mit den Maßen 97x97 mm hergestellt.  Es passt problemlos in einen Standard-Elektrokasten.  Darüber hinaus sind Platten mit einer Größe von weniger als 100 x 100 billig herzustellen.  Die Herstellung einer Mindestcharge von 5 Platten gemäß dem entwickelten Layout kostete 5 USD, die Lieferung nach Weißrussland weitere 9 USD. </p><br><img src="https://habrastorage.org/webt/u9/ov/ou/u9ovouhbfeuadqoixu_je1zjd54.png"><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Design des Boards</a> befindet sich auf der EasyEDA-Website und steht jedem zur Verfügung. </p><br><p>  Ich stelle fest, dass auf dem Foto des Controllers unten das erste Beispiel der Platine zu sehen ist, auf dem ich viele unnötige und unnötige Dinge "verdreht" habe (in der Hoffnung, diese minimale Menge von 5 Platinen in anderen Projekten zu verwenden).  Hier und auf EasyEDA habe ich eine "gereinigte" Version all dieser unnötigen Dinge gepostet. </p><br><img src="https://habrastorage.org/webt/vb/jn/p9/vbjnp97xoyff3jde4oeyh2hkvpg.jpeg"><br><div class="spoiler">  <b class="spoiler_title">Fotos von beiden Seiten der Tafel</b> <div class="spoiler_text"><p>  Vorderseite: </p><br><img src="https://habrastorage.org/webt/fs/8_/it/fs8_itdlmt1qredzy8b2h0prk4k.jpeg"><br><p>  Rückseite: </p><br><img src="https://habrastorage.org/webt/l8/tc/bo/l8tcboqf53vonco7zla9koydq2s.jpeg"></div></div><br><h2>  Software-Teil </h2><br>  Um den Mikrocontroller zu programmieren, wurde angesichts des Rückstands in Form eines Prototyps auf Arduino Uno beschlossen, die Arduino-Umgebung mit dem installierten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arduino Core</a> ESP8266 zu verwenden.  Ja, Sie können <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lua</a> auf dem ESP8266 verwenden, aber sie sagen, dass es Hänge gibt.  Ich würde angesichts der kritischen Funktion überhaupt nicht wollen. <br>  Die Arduino-Umgebung selbst scheint mir etwas veraltet zu sein, aber zum Glück gibt es eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erweiterung</a> für Visual Studio von Visual Micro.  In der Umgebung können Sie IntelliSence-Codehinweise verwenden, schnell zu Funktionsdeklarationen und Refactor-Code springen: Im Allgemeinen alles, was die Umgebung für "erwachsene" Computer zulässt.  Mit der kostenpflichtigen Version von Visual Micro können Sie auch bequem Code debuggen, aber ich war mit der kostenlosen Option zufrieden. <br><h2>  Projektstruktur </h2><br>  Das Projekt besteht aus folgenden Dateien: <br><div class="spoiler">  <b class="spoiler_title">Projektstruktur in Visual Studio</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/4i/dn/hu/4idnhu7toeunqk727_fnhcmpl34.png"></div></div><br><table><tbody><tr><th>  Datei </th><th>  Termin </th></tr><tr><td>  WaterpoolManager.ino <br></td><td>  Deklaration grundlegender Variablen und Konstanten.  Initialisierung.  Hauptschleife. <br></td></tr><tr><td>  HeaterMainLogic.ino <br></td><td>  Die Grundlogik zur Steuerung des Kesselrelais (je nach Temperatur) und der Hilfsrelais. <br></td></tr><tr><td>  Sensors.ino <br></td><td>  Sensordaten lesen <br></td></tr><tr><td>  Settings.ino <br></td><td>  Geräteeinstellungen, die im Flash-Speicher des Controllers gespeichert werden <br></td></tr><tr><td>  LCD.ino <br></td><td>  Informationsausgabe auf dem LCD <br></td></tr><tr><td>  ClockTimer.ino <br></td><td>  RTC Clock Reading oder Clock Simulation <br></td></tr><tr><td>  Relays.ino <br></td><td>  Relais Ein / Aus-Steuerung <br></td></tr><tr><td>  ButtonLogic.ino <br></td><td>  Logik der Reaktion auf den Status der Hardwaretasten <br></td></tr><tr><td>  ReadButtonStates.ino <br></td><td>  Hardware-Schaltflächenzustände lesen <br></td></tr><tr><td>  EEPROM_Logging.ino <br></td><td>  Sensordatenerfassung im EEPROM <br></td></tr><tr><td>  WebServer.ino <br></td><td>  Eingebauter Webserver für Geräteverwaltung und Statusanzeige <br></td></tr><tr><td>  <b>Webseiten</b> <br></td><td>  Webserverseiten werden in diesem Ordner gespeichert. <br></td></tr><tr><td>  index.h <br></td><td>  Die Hauptseite zur Anzeige des Gerätestatus.  Lesen des aktuellen Status mit Ajax-Aufruf.  Alle 5 Sekunden aktualisieren. <br></td></tr><tr><td>  loggraph.h <br></td><td>  Zeigt ein Protokoll der Sensordaten und Relaiszustände in einem Diagramm an.  Die jqPlot-Bibliothek wird verwendet - die gesamte Konstruktion erfolgt auf der Clientseite.  Die Anfrage an die Steuerung geht nur an eine Binärdatei - Kopien von Daten aus dem EEPROM. <br></td></tr><tr><td>  logtable.h <br></td><td>  auch, aber in Form einer Tabelle <br></td></tr><tr><td>  settings.h <br></td><td>  Verwalten der Geräteeinstellungen: Festlegen von Grenzwerten für Temperatur, Wasserdurchfluss und Häufigkeit der Datenerfassung <br></td></tr><tr><td>  time.h <br></td><td>  Aktuelle Zeiteinstellung <br></td></tr><tr><td><br></td><td>  <b>Bibliotheken</b> <br></td></tr><tr><td>  EepromLogger.cpp <br></td><td>  Flash-Protokollbibliothek <br></td></tr><tr><td>  EepromLogger.h <br></td></tr><tr><td>  crc8.cpp <br></td><td>  8-Bit-CRC für eine Bibliothek zählen <br></td></tr><tr><td>  crc8.h <br></td></tr><tr><td> TimeSpan.cpp <br></td><td>      <br></td></tr><tr><td> TimeSpan.h <br></td></tr></tbody></table><br><h2>   </h2><br><p>          OneWire       tempSensAddr.              .       (    4    ): </p><br><pre><code class="hljs powershell"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ds.search(tempSensAddr[<span class="hljs-type"><span class="hljs-type">lastSensorIndex</span></span>]) &amp;&amp; lastSensorIndex &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) { Serial.print(<span class="hljs-string"><span class="hljs-string">"ROM ="</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; i++) { Serial.print(<span class="hljs-string"><span class="hljs-string">' '</span></span>); Serial.print(tempSensAddr[<span class="hljs-type"><span class="hljs-type">lastSensorIndex</span></span>][<span class="hljs-type"><span class="hljs-type">i</span></span>], HEX); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (OneWire::crc8(tempSensAddr[<span class="hljs-type"><span class="hljs-type">lastSensorIndex</span></span>], <span class="hljs-number"><span class="hljs-number">7</span></span>) != tempSensAddr[<span class="hljs-type"><span class="hljs-type">lastSensorIndex</span></span>][<span class="hljs-number"><span class="hljs-number">7</span></span>]) { Serial.print(<span class="hljs-string"><span class="hljs-string">" CRC is not valid!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> lastSensorIndex++; Serial.println(); } ds.reset_search(); lastSensorIndex--; Serial.print(<span class="hljs-string"><span class="hljs-string">"\r\nTemperature sensor count: "</span></span>); Serial.print(lastSensorIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>, DEC);  ,       ().       Serial   LCD  : // Read sensor values and print temperatures ds.reset(); ds.write(<span class="hljs-number"><span class="hljs-number">0</span></span>xCC, TEMP_SENSOR_POWER_MODE); // Request all sensors at the one time ds.write(<span class="hljs-number"><span class="hljs-number">0</span></span>x44, TEMP_SENSOR_POWER_MODE); // Acquire temperatures delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); // Delay is required by temp. sensors char tempString[<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte addr = <span class="hljs-number"><span class="hljs-number">0</span></span>; addr &lt;= lastSensorIndex; addr++) { ds.reset(); ds.select(tempSensAddr[<span class="hljs-type"><span class="hljs-type">addr</span></span>]); ds.write(<span class="hljs-number"><span class="hljs-number">0</span></span>xBE, TEMP_SENSOR_POWER_MODE); // Read Scratchpad tempData[<span class="hljs-type"><span class="hljs-type">addr</span></span>] = ds.read() | (ds.read() &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>); // Read first <span class="hljs-number"><span class="hljs-number">2</span></span> bytes which carry temperature <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> int tempInCelsius = (tempData[<span class="hljs-type"><span class="hljs-type">addr</span></span>] + <span class="hljs-number"><span class="hljs-number">8</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">In</span></span> celsius, with math rounding Serial.print(tempInCelsius, DEC); // Print temperature Serial.println(<span class="hljs-string"><span class="hljs-string">" C"</span></span>); }</code> </pre> <br><p>  Laut Datenblatt benötigen Sensoren zwischen der Anforderung eines Temperaturwerts und dem Empfang einer Antwort vom Sensor eine Verzögerung von mindestens 750 ms.  Daher führte der Code eine Verzögerung mit einem kleinen Spielraum ein. </p><br><p>  Diese Verzögerung, wenn das gesamte Gerät nur auf eine Antwort wartet, ist zu Beginn akzeptabel, es ist jedoch absolut unangemessen, jedes Mal mit einer regelmäßigen Abfrage der Sensoren zu warten.  Daher wurde der folgende knifflige Code geschrieben, der alle 50 ms vom Timer aufgerufen wird: </p><br><pre> <code class="hljs lua">#define TEMP_MEASURE_PERIOD <span class="hljs-number"><span class="hljs-number">20</span></span> // Time of measuring, * TEMP_TIMER_PERIODICITY ms #define TEMP_TIMER_PERIODICITY <span class="hljs-number"><span class="hljs-number">50</span></span> // Periodicity of timer calling, ms timer.attach_ms(TEMP_TIMER_PERIODICITY, tempReadTimer); int tempMeasureCycleCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; void tempReadTimer() // Called many times <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> second, perform only one small operation per call { tempMeasureCycleCount++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tempMeasureCycleCount &gt;= TEMP_MEASURE_PERIOD) { tempMeasureCycleCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; // Start cycle again } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tempMeasureCycleCount == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ds.reset(); ds.<span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(<span class="hljs-number"><span class="hljs-number">0xCC</span></span>, TEMP_SENSOR_POWER_MODE); // Request all sensors at the one <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> ds.<span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(<span class="hljs-number"><span class="hljs-number">0x44</span></span>, TEMP_SENSOR_POWER_MODE); // Acquire temperatures } // Between phases above <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> below should be &gt; <span class="hljs-number"><span class="hljs-number">750</span></span> ms int addr = TEMP_MEASURE_PERIOD - tempMeasureCycleCount - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (addr &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; addr &lt;= lastSensorIndex) { ds.reset(); ds.<span class="hljs-built_in"><span class="hljs-built_in">select</span></span>(tempSensAddr[addr]); ds.<span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(<span class="hljs-number"><span class="hljs-number">0xBE</span></span>, TEMP_SENSOR_POWER_MODE); // Read Scratchpad tempData[addr] = ds.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>() | (ds.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>() &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>); // Read first <span class="hljs-number"><span class="hljs-number">2</span></span> bytes which carry temperature data } }</code> </pre> <br><p>  Zu Beginn jedes tempMeasureCycleCount-Zyklus werden Sensoren aufgefordert, ihre Werte zu lesen.  Nach ungefähr 50 solcher Zyklen (und insgesamt sind es 50 · 20 = 1000 ms = 1 s) wird der Wert jedes Sensors einzeln gelesen.  Alle Arbeiten sind in Teile zerlegt, sodass der Code, der im Timer-Interrupt ausgeführt wird, vom Controller nicht viel Zeit in Anspruch nimmt. </p><br><p>  Der Wert des Durchflusssensors wird wie folgt berechnet.  Durch Unterbrechung des Stifts, an dem der Sensor hängt, erhöhen wir den Wert des Zählers der Zecken, die vom Durchflusssensor kamen: </p><br><pre> <code class="hljs pgsql">pinMode(FLOW_SENSOR_PIN, <span class="hljs-keyword"><span class="hljs-keyword">INPUT</span></span>); attachInterrupt(digitalPinToInterrupt(FLOW_SENSOR_PIN), flow, RISING); // Setup Interrupt <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> flow_frequency; // Flow sensor pulses <span class="hljs-type"><span class="hljs-type">int</span></span> flowMeasureCycleCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-type"><span class="hljs-type">void</span></span> flow() // Flow sensor interrupt <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> { flow_frequency++; }</code> </pre> <br><p>  In demselben Timer, in dem Temperatursensoren abgefragt werden, nehmen wir diesen Tick-Wert einmal pro Sekunde und übersetzen ihn mit der Konstante FLOW_SENSOR_CONST in Liter, deren Wert in den Eigenschaften des Sensors angegeben ist: </p><br><pre> <code class="hljs pgsql">flowMeasureCycleCount++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flowMeasureCycleCount &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> / TEMP_TIMER_PERIODICITY) { flowMeasureCycleCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; litersInMinute = (flow_frequency / FLOW_SENSOR_CONST); // Pulse frequency (Hz) = FLOW_SENSOR_CONST*Q, Q <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> flow rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> L/min. flow_frequency = <span class="hljs-number"><span class="hljs-number">0</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">Reset</span></span> Counter }</code> </pre> <br><h2>  Protokollierung von Daten von Sensoren und Gerätestatus </h2><br><p>  Bei der Entwicklung des Protokollierungsmechanismus kann die Tatsache, dass das Gerät plötzlich ausgeschaltet werden kann, d.h.  in fast jedem Moment.  Wenn Sie die Aufnahme beenden, müssen wir in der Lage sein, alles, was aufgenommen wurde, bis zum letzten Moment wiederherzustellen.  Gleichzeitig können wir nicht ständig denselben Bereich des Flash-Speichers neu schreiben (z. B. einen bestimmten Titel an einem bestimmten Ort, wobei wir uns an die Adresse erinnern, an die die Aufnahme zuletzt gesendet wurde), um ein beschleunigtes „Löschen“ des Flash-Laufwerks an diesem Ort zu vermeiden. </p><br><p>  Nach einiger „Kumulierung“ wurde das folgende Aufzeichnungsmodell erfunden und implementiert: </p><br><img src="https://habrastorage.org/webt/ue/zv/vg/uezvvgglwxhvsvn5uhdmkiic8ju.png"><br><p>  Jeder Datensatz ist ein Datensatz, der Informationen über den aktuellen Wert des Wasserflusses, die Sensortemperaturen sowie den Status des im Byte codierten Geräts enthält (einzelne Bits geben an, ob das Relais eingeschaltet ist oder nicht, ob die Heizung aktiviert ist oder nicht): </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LogEvent</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> litersInMinute = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> tempCelsius[<span class="hljs-number"><span class="hljs-number">4</span></span>]{ <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> deviceStatus = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  Nach jedem Datensatz gibt es ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CRC-</a> Prüfsummenbyte, das angibt, ob der Datensatz korrekt geschrieben wurde und ob im Allgemeinen mindestens etwas an diesem Speicherort geschrieben wurde. </p><br><p>  Da es zu teuer wäre, Daten zur aktuellen Zeit ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeitstempel</a> ) für jeden Datensatz in Bezug auf das Volumen aufzuzeichnen, sind die Daten in großen Blöcken mit jeweils N Datensätzen organisiert.  Der Zeitstempel für jeden Block wird im Übrigen nur einmal aufgezeichnet - er wird anhand von Informationen über die Häufigkeit der Protokollierung berechnet. </p><br><pre> <code class="hljs vhdl"><span class="hljs-built_in"><span class="hljs-built_in">unsigned</span></span> int logRecordsInBlock = <span class="hljs-number"><span class="hljs-number">60</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span> / loggingPeriodSeconds; // <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">block</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> hour <span class="hljs-built_in"><span class="hljs-built_in">unsigned</span></span> int block_size = sizeof(Block_Header) + logRecordsInBlock * (record_size + crcSize); <span class="hljs-built_in"><span class="hljs-built_in">unsigned</span></span> int block_count = total_storage_size / block_size;</code> </pre> <br><p>  Bei einer Protokollierungshäufigkeit von einmal alle 30 Sekunden haben wir beispielsweise 120 Einträge in einem Block, und die Blockgröße beträgt ungefähr 840 Byte.  Insgesamt können wir 39 Blöcke in den Speicher eines Flash-Laufwerks mit einer Größe von 32 Kilobyte einfügen.  Bei einer solchen Organisation stellt sich heraus, dass jeder Block an einer genau definierten Adresse im Speicher beginnt und das „Durchlaufen“ aller Blöcke kein Problem darstellt. </p><br><p>  Dementsprechend haben wir mit einer plötzlichen Unterbrechung des Datensatzes während des letzten Herunterfahrens des Geräts einen unvollendeten Block (dh, in dem einige der Datensätze fehlen).  Wenn das Gerät eingeschaltet ist, sucht der Algorithmus nach dem letzten gültigen Blockheader (Zeitstempel + crc).  Und setzt die Aufnahme fort, beginnend mit dem nächsten Block.  Die Aufzeichnung erfolgt zyklisch: Der letzte Block überschreibt die Daten des ältesten Blocks. </p><br><p>  Beim Lesen werden alle Blöcke nacheinander gelesen.  Ungültige Blöcke (solche, die CRC für den Zeitstempel nicht bestehen) werden vollständig ignoriert.  Datensätze in jedem Block werden bis zum Treffen des ersten ungültigen Datensatzes gelesen (d. H. Desjenigen, bei dem die Aufzeichnung das letzte Mal unterbrochen wurde, wenn der Block nicht vollständig aufgezeichnet wurde).  Der Rest wird ignoriert. <br>  Für jeden Datensatz wird die aktuelle Zeit basierend auf dem Zeitstempel des Blocks und der Seriennummer des Datensatzes im Block berechnet. </p><br><h2>  LCD </h2><br><p>  Das Gerät verwendet eine Anzeige QC1602A, die 2 Zeilen mit 16 Zeichen anzeigen kann.  In der ersten Zeile werden die aktuellen Informationen zu den aktuellen Werten der Sensoren angezeigt: Durchfluss und Temperaturen.  Wenn der angegebene Grenzwert überschritten wird, wird neben dem Wert ein Ausrufezeichen angezeigt.  Die zweite Zeile zeigt den Status des Heizungsrelais und der Pumpe sowie die Zeit, die seit dem Ein- und Ausschalten der Heizung vergangen ist.  Alle 5 Sekunden zeigt das Display in der zweiten Zeile kurz die aktuellen Grenzwerte an.  Fotos der Anzeige in verschiedenen Modi werden am Ende der Veröffentlichung angezeigt. </p><br><h2>  Grafiken </h2><br><p>  Auf Anforderung über den integrierten Webserver werden die Protokolldaten in binärer Form mit JavaScript gelesen: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xhttp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); xhttp.open(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-string"><span class="hljs-string">"logs.bin"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); xhttp.responseType = <span class="hljs-string"><span class="hljs-string">"arraybuffer"</span></span>; xhttp.onprogress = updateProgress; xhttp.onload = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">oEvent</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arrayBuffer = xhttp.response; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arrayBuffer) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> byteArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>(arrayBuffer); … }}; xhttp.send(<span class="hljs-literal"><span class="hljs-literal">null</span></span>);</code> </pre> <br><p>  Das Lesen in einem gängigen nicht-binären Format wie Ajax wäre ein unzulässiger Luxus für den Controller, vor allem wegen der großen Menge, die der eingebaute http-Server zurückgeben müsste. </p><br><p>  Aus dem gleichen Grund wird die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jqPlot-</a> JavaScript-Bibliothek zum Erstellen von Diagrammen verwendet, und die JS-Bibliotheksdateien selbst werden von gängigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CDNs</a> geladen. </p><br><p>  Ein Beispiel für den Zeitplan des Geräts: </p><br><img src="https://habrastorage.org/webt/uh/kr/bc/uhkrbccsl1k8l6w_3am6tunwe5a.png"><br><p>  Es ist deutlich zu sehen, dass gegen 9:35 Uhr das Gerät zum Heizen eingeschaltet wurde und der Kessel begann, den Heizkreislauf allmählich zu erwärmen (Sensoren T3, T4), wonach die Temperatur des Poolkreislaufs zu steigen begann (Sensoren T1, T2).  Irgendwann gegen 10:20 Uhr schaltete der Kessel auf Warmwasser im Haus um, die Temperatur des Heizkreislaufs sank.  Nach weiteren 10 Minuten kehrte der Kessel zum Erhitzen des Poolwassers zurück.  Um 10:50 Uhr ereignete sich ein Unfall: Die Pumpe für das zirkulierende Wasser im Pool wurde plötzlich ausgeschaltet.  Der Wasserdurchfluss fiel stark auf Null ab, das Heizungsrelais wurde ausgeschaltet (rot gepunktete Linie in der 2. Tabelle), um eine Überhitzung zu vermeiden.  Das Gerät blieb jedoch in einem Heizzustand (rote Linie in der 2. Tabelle).  Das heißt,  Wenn die Pumpe wieder eingeschaltet würde und die Temperaturen normal wären, würde das Gerät wieder heizen.  Ich stelle fest, dass nach einer Notabschaltung der Pumpe die Temperaturen im Poolwasserkreislauf (T1, T2) aufgrund der Überhitzung des Wärmetauschers stark anstiegen.  Und wenn der Kessel nicht scharf abgeschaltet würde, gäbe es Probleme. </p><br><h2>  Eingebetteter Webserver </h2><br><p>  Für die Kommunikation mit der Außenwelt wird die Standardklasse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ESP8266WebServer verwendet</a> .  Wenn das Gerät gestartet wird, wird es als Zugriffspunkt mit dem in #define AP_PASS angegebenen Standardkennwort initialisiert.  Eine Webseite wird automatisch geöffnet, um ein verfügbares WLAN-Netzwerk auszuwählen und ein Passwort einzugeben.  Nach Eingabe des Kennworts wird das Gerät neu gestartet und stellt eine Verbindung zum angegebenen Zugriffspunkt her. </p><br><h2>  Fertiges Gerät </h2><br><p>  Das fertige Gerät wurde zur Verkabelung in eine Standardschneidbox gelegt.  Darin wurde ein Loch für das LCD und Löcher für die Anschlüsse ausgeschnitten. </p><br><img src="https://habrastorage.org/webt/dz/si/tx/dzsitx4tim2kcxqnticd7ln2vho.jpeg"><br><div class="spoiler">  <b class="spoiler_title">Fotos der Fassade des Geräts in verschiedenen Modi</b> <div class="spoiler_text"><p>  Mit der Anzeige der nach dem Einschalten verstrichenen Zeit: </p><br><img src="https://habrastorage.org/webt/fh/gn/fn/fhgnfnf-emu1rl31w7bm4fbmmvs.jpeg"><br><p>  Mit angezeigten Grenzwerten: </p><br><img src="https://habrastorage.org/webt/qi/8c/r2/qi8cr2ex8uwr3e9xgzs5ms__vou.jpeg"></div></div><br><h2>  Fazit </h2><br><p>  Abschließend möchte ich sagen, dass ich bei der Entwicklung eines solchen Geräts große Erfahrungen mit Schaltkreisen, Leiterplattendesign, Installationsfähigkeiten für SMD-Komponenten, der Architektur und Programmierung von Mikrocontrollern gesammelt habe. Ich erinnerte mich an fast vergessenes C ++ und den sorgfältigen Umgang mit Speicher und anderen begrenzten Controller-Ressourcen.  In gewissem Umfang waren auch Kenntnisse in HTML5, JavaScript und Debugging-Fähigkeiten von Skripten im Browser hilfreich. </p><br><p>  Diese Fähigkeiten und die Freude an der Entwicklung des Geräts sind die Hauptvorteile.  Und die Quellcodes des Geräts, Schaltplan, Leiterplatten - bitte verwenden, ändern.  Alle Projektquellcodes befinden sich auf GitHab.  Hardware in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">öffentlichen Projekt</a> auf EasyEDA.  Ich habe Daten zu den im Projekt verwendeten Chips auf einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Netzlaufwerk</a> gesammelt. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413955/">https://habr.com/ru/post/de413955/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de413945/index.html">Einfacher als es klingt. Kapitel 4-5</a></li>
<li><a href="../de413947/index.html">Implementierung der Arbeit mit dem Long Poll-Server im VKontakte-Client für Sailfish OS</a></li>
<li><a href="../de413949/index.html">Warum lesen wir immer noch Papierbücher?</a></li>
<li><a href="../de413951/index.html">Bringen Sie anderen bei, ein besserer Programmierer zu werden</a></li>
<li><a href="../de413953/index.html">Wann und warum lohnt es sich, ES6-Pfeilfunktionen zu verwenden, und wann nicht?</a></li>
<li><a href="../de413957/index.html">Ein Beispiel für die Erstellung einer Echtzeit-Sportanwendung auf Node.js.</a></li>
<li><a href="../de413959/index.html">Kleinstes Docker-Image - Weniger als 1000 Byte</a></li>
<li><a href="../de413963/index.html">Mini CRM für kleine Unternehmen</a></li>
<li><a href="../de413965/index.html">Codeüberprüfung: Sie machen es falsch</a></li>
<li><a href="../de413967/index.html">Animal Crossing Entwicklermodus Reverse Engineering</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>