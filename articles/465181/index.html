<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤠 👨🏾‍💼 🆙 Lugares resbaladizos en C ++ 17 👍 👨🏿‍🤝‍👨🏼 😝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En los últimos años, C ++ ha avanzado a pasos agigantados, y mantenerse al día con todas las sutilezas y complejidades del lenguaje puede ser muy, muy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lugares resbaladizos en C ++ 17</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/playrix/blog/465181/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/fp/nd/-g/fpnd-ggxjx4-xafw3sb7rx2keca.png" alt="imagen"></a> <br><br>  En los últimos años, C ++ ha avanzado a pasos agigantados, y mantenerse al día con todas las sutilezas y complejidades del lenguaje puede ser muy, muy difícil.  Un nuevo estándar no está lejos, sin embargo, la introducción de nuevas tendencias no es el proceso más rápido y fácil, por lo tanto, si bien hay un poco de tiempo antes de C ++ 20, sugiero actualizar o descubrir algunos lugares especialmente "resbaladizos" del estándar actual idioma <br><br>  Hoy les diré por qué si constexpr no es un reemplazo para las macros, cuáles son las "partes internas" del enlace estructurado y sus "escollos" y es cierto que la elisión de copia siempre funciona ahora y puede escribir cualquier devolución sin dudarlo. <br><br>  Si no tienes miedo de ensuciarte un poco las manos, profundizando en el "interior" de tu lengua, bienvenido a Cat. <br><a name="habracut"></a><br><hr><br><h1>  si constexpr </h1><br>  Comencemos con el más simple: <code>if constexpr</code> permite descartar la rama de expresión condicional para la que no se cumple la condición deseada, incluso en la etapa de compilación. <br><br>  Parece que este es un reemplazo para la macro <code>#if</code> para desactivar la lógica "extra"?  No  En absoluto <br><br>  En primer lugar, un <code>if</code> tiene propiedades que no están disponibles para macros: en el interior puede contar cualquier expresión <code>constexpr</code> que se pueda <code>constexpr</code> a <code>bool</code> .  Bueno, y en segundo lugar, el contenido de la rama descartada debe ser sintáctica y semánticamente correcta. <br><br>  Debido al segundo requisito, <code>if constexpr</code> no se puede utilizar, por ejemplo, funciones inexistentes (el código dependiente de la plataforma no se puede separar explícitamente de esta manera) o incorrecto desde el punto de vista del lenguaje de construcción (por ejemplo, " <code>void T = 0;</code> "). <br><br>  ¿Cuál es el punto de usar <code>if constexpr</code> ?  El punto principal está en las plantillas.  Hay una regla especial para ellos: la rama descartada no se instancia cuando se instancia la plantilla.  Esto facilita la escritura de código que de alguna manera depende de las propiedades de los tipos de plantilla. <br><br>  Sin embargo, en las plantillas, no se debe olvidar que el código dentro de las ramas debe ser correcto al menos para alguna variante de instanciación (incluso puramente potencial), por lo tanto, es simplemente <code>static_assert(false)</code> escribir, por ejemplo, <code>static_assert(false)</code> dentro de una de las ramas (es necesario que esto <code>static_assert</code> dependía de algún parámetro dependiente de la plantilla). <br><br>  Ejemplos: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-comment"><span class="hljs-comment">//    ,       if constexpr ( os == OS::win ) {        win_api_call(); //         }    else {        some_other_os_call(); //  win      } }</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class">() {</span></span>    <span class="hljs-comment"><span class="hljs-comment">//    ,    T      if constexpr ( os == OS::win ) {        T::win_api_call(); //  T   ,    win    }    else {        T::some_other_os_call(); //  T   ,         } }</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class">() {</span></span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(condition1)</span></span></span><span class="hljs-function"> </span></span>{        <span class="hljs-comment"><span class="hljs-comment">// ...    }    else if constexpr (condition2) {        // ...    }    else {        // static_assert(false); //          static_assert(trait&lt;T&gt;::value); // ,   ,  trait&lt;T&gt;::value   false    } }</span></span></code> </pre><br><h2>  Cosas para recordar </h2><br><ol><li>  El código en todas las ramas debe ser correcto. <br></li><li>  Dentro de las plantillas, el contenido de las ramas descartadas no se instancia. <br></li><li>  El código dentro de cualquier rama debe ser correcto para al menos una variante puramente potencial de instanciación de la plantilla. <br></li></ol><br><h1>  Enlace estructurado </h1><br><img src="https://habrastorage.org/webt/0v/jl/x4/0vjlx42it96fu5j20yz-m-pvhpq.png"><br><br>  En C ++ 17, apareció un mecanismo bastante conveniente para descomponer varios objetos tipo tupla, lo que le permite vincular de manera conveniente y concisa sus elementos internos a variables con nombre: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     —    : for (const auto&amp; [key, value] : map) {    std::cout &lt;&lt; key &lt;&lt; ": " &lt;&lt; value &lt;&lt; std::endl; }</span></span></code> </pre><br>  Por un objeto similar a una tupla, me referiré a un objeto para el que se conoce el número de elementos internos disponibles en el momento de la compilación (de "tupla" - una lista ordenada con un número fijo de elementos (vector)). <br><br>  Dichas definiciones se incluyen en esta definición como: <code>std::pair</code> , <code>std::tuple</code> , <code>std::array</code> , matrices de la forma " <code>T a[N]</code> ", así como varias estructuras y clases auto escritas. <br><br>  Parar ... ¿Puedes usar tus propias estructuras en la unión estructural?  Spoiler: puedes (aunque a veces tienes que trabajar duro (pero más sobre eso a continuación)). <br><br><h2>  Como funciona </h2><br>  El trabajo de vinculación estructural merece un artículo separado, pero como estamos hablando específicamente de lugares "resbaladizos", intentaré explicar brevemente cómo funciona todo. <br><br>  El estándar proporciona la siguiente sintaxis para definir el enlace: <br><br>  <i>attr</i> (opcional) <i>cv-auto</i> <i>ref-operator</i> (opcional) [ <i>identifier-list</i> ] <i>expresión</i> ; <br><br><ul><li>  <code>attr</code> - lista de atributos opcionales; <br></li><li>  <code>cv-auto</code> - auto con posibles modificadores constantes / volátiles; <br></li><li>  <code>ref-operator</code> referencia: especificador de referencia opcional (&amp; o &amp;&amp;); <br></li><li>  <code>identifier-list</code> - una lista de nombres de nuevas variables; <br></li><li>  <code>expression</code> es una expresión que da como resultado un objeto tipo tupla que se usa para la unión (la expresión puede tener la forma " <code>= expr</code> ", " <code>{expr}</code> " o " <code>(expr)</code> "). <br></li></ul><br>  Es importante tener en cuenta que el número de nombres en la <code>identifier-list</code> debe coincidir con el número de elementos en el objeto resultante de la <code>expression</code> . <br><br>  Todo esto le permite escribir construcciones de la forma: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp; [a,b,c] = Foo{};</code> </pre><br>  Y aquí llegamos al primer lugar "resbaladizo": encontrar una expresión de la forma " <code>auto a = expr;</code>  ", Generalmente quiere decir que el tipo" <code>a</code> "se calculará con la expresión" <code>expr</code> ", y espera que en la expresión" <code>const auto&amp; [a,b,c] = expr;</code>  "Se hará lo mismo, solo los tipos para" <code>a,b,c</code> "serán los tipos <code>const&amp;</code> elementos correspondientes de" <code>expr</code> "... <br><br>  La verdad es diferente: el especificador <code>cv-auto ref-operator</code> se usa para calcular el tipo de una variable invisible, a la que se asigna el resultado del cálculo de expr (es decir, el compilador reemplaza " <code>const auto&amp; [a,b,c] = expr</code> " con " <code>const auto&amp; e = expr</code> "). <br><br>  Por lo tanto, aparece una nueva entidad invisible (en adelante la llamaré {e}), sin embargo, la entidad es muy útil: por ejemplo, puede materializar objetos temporales (por lo tanto, puede conectarlos con seguridad " <code>const auto&amp; [a,b,c] = Foo {};</code> "). <br><br>  El segundo lugar resbaladizo se deduce inmediatamente del reemplazo que hace el compilador: si el tipo deducido para {e} no es una referencia, entonces el resultado de <code>expr</code> se copiará en {e}. <br><br>  ¿Qué tipos tendrán las variables en <code>identifier-list</code> ?  Para empezar, estos no serán exactamente variables.  Sí, se comportan como variables reales, ordinarias, pero solo con la diferencia de que en su interior se refieren a una entidad asociada con ellas, y el <code>decltype</code> de <code>decltype</code> de una variable de "referencia" de este tipo producirá el tipo de entidad a la que se refiere esta variable: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; t(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [a, b] = t; <span class="hljs-comment"><span class="hljs-comment">// decltype(a) — int, decltype(b) — float ++a; // ,  « »,   t std::cout &lt;&lt; std::get&lt;0&gt;(t); //  2</span></span></code> </pre><br>  Los tipos mismos se definen de la siguiente manera: <br><br><ol><li>  Si <b>{e}</b> es una matriz ( <code>T a[N]</code> ), entonces el tipo será uno: T, los modificadores cv coincidirán con los de la matriz. <br></li><li>  Si <b>{e}</b> es de tipo E y admite la interfaz de tupla, las estructuras se definen: <br><br><pre> <code class="plaintext hljs">std::tuple_size&lt;E&gt;</code> </pre> <br><pre> <code class="plaintext hljs">std::tuple_element&lt;i, E&gt;</code> </pre> <br>  y función: <br><br><pre> <code class="plaintext hljs">get&lt;i&gt;({e}); //  {e}.get&lt;i&gt;()</code> </pre> <br>  entonces el tipo de cada variable será el tipo <code>std::tuple_element_t&lt;i, E&gt;</code> <br></li><li>  En otros casos, el tipo de la variable corresponderá al tipo de elemento de estructura al que se realiza el enlace. <br></li></ol><br>  Entonces, si es muy breve, se toman los siguientes pasos con el enlace estructural: <br><br><ol><li>  Cálculo del tipo e inicialización de la entidad invisible {e} en función de los modificadores de tipo <code>expr</code> y <code>cv-ref</code> . <br></li><li>  Crea pseudo-variables y únelas a elementos {e}. <br></li></ol><br><h2>  Vinculando estructuralmente sus clases / estructuras </h2><br>  El principal obstáculo para vincular sus estructuras es la falta de reflexión en C ++.  Incluso el compilador, que, al parecer, debe saber con certeza cómo se organiza esta o aquella estructura en su interior, tiene dificultades: los modificadores de acceso (públicos / privados / protegidos) y la herencia complican mucho las cosas. <br><br>  Debido a tales dificultades, las restricciones en el uso de sus clases son muy estrictas (al menos por ahora: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">P1061</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">P1096</a> ): <br><br><ol><li>  Todos los campos internos no estáticos de una clase deben ser de la misma clase base y deben estar disponibles en el momento del uso. <br></li><li>  O la clase debe implementar "reflexión" (admite la interfaz de tupla). <br></li></ol><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  «»  struct A { int a; }; struct B : A {}; struct C : A { int c; }; class D { int d; }; auto [a] = A{}; //  (a -&gt; A::a) auto [a] = B{}; //  (a -&gt; B::A::a) auto [a, c] = C{}; // : a  c    auto [d] = D{}; // : d — private void D::foo() {    auto [d] = *this; //  (d   ) }</span></span></code> </pre><br>  La implementación de la interfaz de tupla le permite usar cualquiera de sus clases para el enlace, pero se ve un poco engorroso y conlleva otra trampa.  Usemos de inmediato un ejemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,      int   class Foo; template&lt;&gt; struct std::tuple_size&lt;Foo&gt; : std::integral_constant&lt;std::size_t, 1&gt; {}; template&lt;&gt; struct std::tuple_element&lt;0, Foo&gt; { using type = int&amp;; }; class Foo { public: template&lt;std::size_t i&gt; std::tuple_element_t&lt;i, Foo&gt; const&amp; get() const; template&lt;std::size_t i&gt; std::tuple_element_t&lt;i, Foo&gt; &amp; get(); private: int _foo = 0; int&amp; _bar = _foo; }; template&lt;&gt; std::tuple_element_t&lt;0, Foo&gt; const&amp; Foo::get&lt;0&gt;() const { return _bar; } template&lt;&gt; std::tuple_element_t&lt;0, Foo&gt; &amp; Foo::get&lt;0&gt;() { return _bar; }</span></span></code> </pre><br>  Ahora nos unimos: <br><br><pre> <code class="cpp hljs">Foo foo; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [f1] = foo; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [f2] = foo; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [f3] = foo; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [f4] = foo;</code> </pre><br>  ¿Y es hora de pensar en qué tipos tenemos?  (Quien pueda responder de inmediato merece un delicioso cariño). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f1); <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f2); <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f3); <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f4);</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Respuesta correcta</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f1); <span class="hljs-comment"><span class="hljs-comment">// int&amp; decltype(f2); // int&amp; decltype(f3); // int&amp; decltype(f4); // int&amp; ++f1; //     foo._foo,  {e}    const</span></span></code> </pre><br></div></div><br>  ¿Por qué sucedió esto?  La respuesta se encuentra en la especialización predeterminada para <code>std::tuple_element</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:tuple_element&lt;i, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">add_const_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">tuple_element_t</span></span>&lt;i, T&gt;&gt;; };</code> </pre><br>  <code>std::add_const</code> no agrega <code>const</code> a los tipos de referencia, por lo que el tipo para <code>Foo</code> siempre será <code>int&amp;</code> . <br><br>  ¿Cómo ganar esto?  Solo agrega especialización para <code>const Foo</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:tuple_element&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Foo&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp;; };</code> </pre><br>  Entonces se esperarán todos los tipos: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f1); <span class="hljs-comment"><span class="hljs-comment">// const int&amp; decltype(f2); // const int&amp; decltype(f3); // int&amp; decltype(f4); // int&amp; ++f1; //    </span></span></code> </pre><br>  Por cierto, el mismo comportamiento es cierto para, por ejemplo, <code>std::tuple&lt;T&amp;&gt;</code> <br>  - puede obtener una referencia no constante al elemento interno, aunque el objeto en sí sea constante. <br><br><h2>  Cosas para recordar </h2><br><ol><li>  " <code>cv-auto ref</code> " en " <code>cv-auto ref [a1..an] = expr</code> " se refiere a la variable invisible {e}. <br></li><li>  Si no se hace referencia al tipo inferido {e}, {e} se inicializará copiando (cuidadosamente con las clases "pesadas"). <br></li><li>  Las variables <code>decltype</code> son enlaces "implícitos" (se comportan como enlaces, aunque <code>decltype</code> devuelve un tipo de no referencia (a menos que la variable se refiera a un enlace)). <br></li><li>  Se debe tener cuidado al usar tipos de referencia para la unión. <br></li></ol><br><h1>  Optimización del valor de retorno (rvo, copia de elisión) </h1><br><img src="https://habrastorage.org/webt/gt/0i/ln/gt0iln8n664yvitfqfpkjk9vuds.png"><br><br>  Quizás esta fue una de las características más discutidas del estándar C ++ 17 (al menos en mi círculo de amigos).  Y de hecho: C ++ 11 trajo la semántica del movimiento, que simplificó enormemente la transferencia de lo "interno" del objeto y la creación de varias fábricas, y C ++ 17 en general, al parecer, hizo posible no pensar en cómo devolver el objeto de algún método de fábrica , - ahora todo debería ser sin copiar y, en general, "pronto todo florecerá en Marte" ... <br><br>  Pero seamos un poco realistas: optimizar el valor de retorno no es lo más fácil de implementar.  Recomiendo ver esta presentación de cppcon2018: Arthur O'Dwyer " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Optimización del valor de retorno: más difícil de lo que parece</a> ", en la que el autor explica por qué es difícil. <br><br>  Spoiler corto: <br><br>  Existe una "ranura para el valor de retorno".  Esta ranura es esencialmente solo un lugar en la pila que es asignado por quien llama y pasa a la llamada.  Si el código llamado sabe exactamente qué objeto individual se devolverá, simplemente puede crearlo inmediatamente en este espacio directamente (siempre que el tamaño y el tipo del objeto y el espacio sean los mismos). <br><br>  ¿Qué se sigue de esto?  Vamos a desarmarlo con ejemplos. <br><br>  Todo estará bien aquí: NRVO funcionará, el objeto se construirá inmediatamente en la "ranura": <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Base a; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; }</code> </pre><br>  Aquí ya no es posible determinar inequívocamente qué objeto debería ser el resultado, por lo que el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">constructor de movimiento</a> (c ++ 11) se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">llamará implícitamente</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Base a,b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; }</code> </pre><br>  Aquí es un poco más complicado ... Dado que el tipo del valor de retorno es diferente del tipo declarado, no puede invocar implícitamente <code>move</code> , por lo que se llama al constructor de copia de forma predeterminada.  Para evitar que esto suceda, debe llamar explícitamente a <code>move</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Derived a,b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(a); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(b); }</code> </pre><br>  Parece que esto es lo mismo que <code>foo2</code> , pero el operador ternario es algo muy <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">peculiar</a> ... <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Base a, b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(c ? a : b); }</code> </pre><br>  Similar a <code>foo4</code> , pero también de un tipo diferente, por <code>move</code> necesita <code>move</code> exactamente: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo5</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Derived a, b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(c ? a : b); }</code> </pre><br>  Como puede ver en los ejemplos, uno todavía tiene que pensar en cómo devolver el significado incluso en casos aparentemente triviales ... ¿Hay alguna forma de simplificar un poco su vida?  Hay: clang desde hace algún tiempo ahora apoya el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">diagnóstico de la</a> necesidad de llamar explícitamente <code>move</code> , y hay varias propuestas ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">P1155</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">P0527</a> ) en el nuevo estándar que harán que el <code>move</code> explícito sea menos necesario. <br><br><h2>  Cosas para recordar </h2><br><ol><li>  RVO / NRVO solo funcionará si: <br><ul><li>  se sabe inequívocamente qué objeto único se debe crear en el "espacio de valor de retorno"; </li><li>  Los objetos de retorno y los tipos de función son iguales. </li></ul></li><li>  Si hay ambigüedad en el valor de retorno, entonces: <br><ul><li>  si los tipos del objeto y la función devueltos coinciden, se llamará a move implícitamente; </li><li>  de lo contrario, debe llamar explícitamente a move. </li></ul></li><li>  Precaución con el operador ternario: es conciso, pero puede requerir un movimiento explícito. <br></li><li>  Es mejor usar compiladores con diagnósticos útiles (o al menos analizadores estáticos). <br></li></ol><br><h1>  Conclusión </h1><br>  Y sin embargo, amo C ++;) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/465181/">https://habr.com/ru/post/465181/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../465167/index.html">Planificación de recursos. ¿Por qué no funciona? Parte 1</a></li>
<li><a href="../465169/index.html">Bricolaje de PVS-Studio: Gamificación de logros</a></li>
<li><a href="../465173/index.html">Cómo cambiar el costo de la suscripción creada en su aplicación. App Store Connect y Google Play Console</a></li>
<li><a href="../465177/index.html">No es la nueva reliquia: una mirada a Datadog y Atatus</a></li>
<li><a href="../465179/index.html">¿La automatización reemplazará las pruebas manuales?</a></li>
<li><a href="../465185/index.html">Nuevos estándares de videovigilancia: color por la noche, antirruido, ePoE</a></li>
<li><a href="../465187/index.html">6 frases en inglés que pueden usarse en negociaciones salariales con empresas extranjeras</a></li>
<li><a href="../465189/index.html">Equipo de desarrollo de Workflow One Sprint</a></li>
<li><a href="../465191/index.html">Entrenamiento Cisco 200-125 CCNA v3.0. Día 25. Estudio en profundidad de IPv6</a></li>
<li><a href="../465193/index.html">Crear un proyecto de Android en un contenedor acoplable</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>