<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå¶Ô∏è ü§ú üêÑ Herramientas para iniciar y desarrollar aplicaciones Java, compilaci√≥n, ejecuci√≥n en la JVM üòô üõÖ üñêüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No es ning√∫n secreto que, por el momento, Java es uno de los lenguajes de programaci√≥n m√°s populares del mundo. La fecha oficial de lanzamiento de Jav...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Herramientas para iniciar y desarrollar aplicaciones Java, compilaci√≥n, ejecuci√≥n en la JVM</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471772/"><p>  No es ning√∫n secreto que, por el momento, Java es uno de los lenguajes de programaci√≥n m√°s populares del mundo.  La fecha oficial de lanzamiento de Java es el 23 de mayo de 1995. <br><br>  Este art√≠culo est√° dedicado a los conceptos b√°sicos: describe las caracter√≠sticas b√°sicas del lenguaje, lo que ser√° √∫til para los "javists" principiantes, y los desarrolladores Java experimentados podr√°n actualizar sus conocimientos. <br><br>  <i>* El art√≠culo fue preparado sobre la base de un informe de Eugene Freiman, desarrollador Java de IntexSoft.</i> <i><br></i>  <i>El art√≠culo contiene enlaces a materiales externos</i> . <br></p><br><br><img src="https://habrastorage.org/webt/sv/ru/1d/svru1d4lpapnwhjllxc2dfw5do4.png"><br><a name="habracut"></a><br><h3>  1. JDK, JRE, JVM </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Java Development Kit</a> es un kit de desarrollo de aplicaciones <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Java</a> .  Incluye las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">herramientas de desarrollo de Java</a> y el Java Runtime Environment ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JRE</a> ). <br><br>  <b>Las herramientas de desarrollo de Java</b> incluyen alrededor de 40 herramientas diferentes: javac (compilador), java (lanzador de aplicaciones), javap (desensamblador de archivos de clase java), jdb (depurador java), etc. <br><br>  El tiempo de ejecuci√≥n de JRE es un paquete de todo lo necesario para ejecutar un programa Java compilado.  Incluye la m√°quina virtual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JVM</a> y la <b>Biblioteca de clases Java</b> . <br><br>  <b>JVM</b> es un programa dise√±ado para ejecutar bytecode.  La primera ventaja de la JVM es el principio de <i>"Escribir una vez, ejecutar en cualquier lugar"</i> .  Significa que una aplicaci√≥n escrita en Java funcionar√° igual en todas las plataformas.  Esta es una gran ventaja de JVM y Java. <br><br>  Antes de Java, muchos programas de computadora se escrib√≠an para sistemas inform√°ticos espec√≠ficos, y se daba preferencia a la administraci√≥n manual de memoria, como m√°s eficiente y predecible.  Desde la segunda mitad de la d√©cada de 1990, despu√©s del advenimiento de Java, la administraci√≥n autom√°tica de memoria se ha convertido en una pr√°ctica com√∫n. <br><br>  Hay muchas implementaciones de JVM, tanto comerciales como de c√≥digo abierto.  Uno de los objetivos de crear nuevas JVM es aumentar el rendimiento de una plataforma espec√≠fica.  Cada JVM se escribe por separado para la plataforma, mientras que es posible escribirlo para que funcione m√°s r√°pido en una plataforma espec√≠fica.  La implementaci√≥n de JVM m√°s com√∫n es el punto de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">acceso</a> JVM de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OpenJDK</a> .  Tambi√©n hay implementaciones de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IBM J9</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Excelsior JET</a> . <br><br><h3>  2. Ejecuci√≥n de c√≥digo JVM </h3><br>  De acuerdo con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la especificaci√≥n Java SE</a> , para que el c√≥digo se ejecute en la JVM, debe completar 3 pasos: <br><br><ul><li>  Cargando bytecode e instanciando la clase Class <br>  En t√©rminos generales, para acceder a la JVM, la clase debe estar cargada.  Hay clases de cargador separadas para esto, volveremos a ellas un poco m√°s tarde. </li><li>  Vinculaci√≥n o vinculaci√≥n <br>  Despu√©s de cargar la clase, comienza el proceso de vinculaci√≥n, en el que se analiza y comprueba el c√≥digo de bytes.  El proceso de vinculaci√≥n, a su vez, tiene lugar en 3 pasos: <br><br>  - verificaci√≥n o verificaci√≥n de bytecode: se verifica la exactitud de las instrucciones, la posibilidad de desbordamiento de pila en esta secci√≥n del c√≥digo, la compatibilidad de los tipos de variables;  la verificaci√≥n ocurre una vez para cada clase; <br>  - preparaci√≥n o preparaci√≥n: en esta etapa, de acuerdo con la especificaci√≥n, se asigna memoria para campos est√°ticos y se produce su inicializaci√≥n; <br>  - resoluci√≥n o resoluci√≥n: resoluci√≥n de enlaces simb√≥licos (cuando en bytecode abrimos archivos con la extensi√≥n .class, vemos valores num√©ricos en lugar de enlaces simb√≥licos). </li><li>  Inicializando el objeto Class resultante <br>  En la √∫ltima etapa, la clase que creamos se inicializa y la JVM puede comenzar a ejecutarla. </li></ul><br><h3>  3. Cargadores de clases y su jerarqu√≠a. </h3><br>  De vuelta a los cargadores de clases, estas son clases especiales que forman parte de la JVM.  Cargan clases en la memoria y las ponen a disposici√≥n para su ejecuci√≥n.  Los cargadores funcionan con todas las clases: tanto las nuestras como las que se necesitan directamente para Java. <br><br>  Imagine la situaci√≥n: escribimos nuestra solicitud y, adem√°s de las clases est√°ndar, existen nuestras clases y hay muchas.  ¬øC√≥mo funcionar√° la JVM con esto?  Java implementa la carga diferida de clases, en otras palabras, la carga diferida.  Esto significa que la carga de las clases no se realizar√° hasta que en la aplicaci√≥n no haya una llamada a la clase. <br><br><h4>  Jerarqu√≠a del cargador de clases </h4><br><br><img src="https://habrastorage.org/webt/r3/em/cw/r3emcwi3knisqdoex6tgrwpgafs.png"><br><br>  El cargador de primera clase es el <b>cargador de clases Bootstrap</b> .  Est√° escrito en C ++.  Este es el cargador base que carga todas las clases del sistema desde el archivo <i>rt.jar</i> .  Al mismo tiempo, hay una ligera diferencia entre cargar clases desde <i>rt.jar</i> y nuestras clases: cuando la JVM carga clases desde <i>rt.jar</i> , no realiza todos los pasos de verificaci√≥n que se realizan al cargar cualquier otro archivo de clase desde  La JVM es consciente inicialmente de que todas estas clases ya est√°n validadas.  Por lo tanto, no debe incluir ninguno de sus archivos en este archivo. <br><br>  El siguiente gestor de arranque es el <b>cargador de clases de Extensi√≥n.</b>  Carga clases de extensi√≥n desde la carpeta <i>jre / lib / ext</i> .  Suponga que desea que se cargue una clase cada vez que se inicia la m√°quina Java.  Para hacer esto, puede copiar el archivo de clase de origen en esta carpeta y se cargar√° autom√°ticamente. <br><br>  Otro gestor de arranque es el <b>cargador de clases del sistema</b> .  Carga las clases del classpath que especificamos cuando se inici√≥ la aplicaci√≥n. <br><br>  El proceso de carga de clases ocurre en una jerarqu√≠a: <br><br><ul><li>  En primer lugar, solicitamos una b√∫squeda en el cach√© del cargador de clases del sistema (el cach√© del cargador del sistema contiene clases que ya han sido cargadas por √©l); </li><li>  Si la clase no se encuentra en el cach√© del cargador del sistema, miramos el cargador de clases de la Extensi√≥n de cach√©; </li><li>  Si la clase no se encuentra en la memoria cach√© del cargador de extensiones, se solicita la clase del cargador Bootstrap. </li></ul><br>  Si la clase no se encuentra en el cach√© de Bootstrap, intenta cargar esta clase.  Si Bootstrap no pudo cargar la clase, delega la carga de la clase al cargador de extensiones.  Si en este punto se carga la clase, permanece en el cach√© del cargador de clases de Extensi√≥n y la carga de la clase se completa. <br><br><h3>  4. Estructura de archivos de clase y proceso de arranque </h3><br>  Procedemos directamente a la estructura de los archivos de clase. <br><br>  Una clase escrita en Java se compila en un solo archivo con la extensi√≥n .class.  Si hay varias clases en nuestro archivo Java, un archivo Java puede compilarse en varios archivos con la extensi√≥n .class - archivos de bytecode de estas clases. <br><br>  Todos los n√∫meros, cadenas, punteros a clases, campos y m√©todos se almacenan en el <i>grupo Constante</i> , el √°rea de memoria del <i>espacio Meta</i> .  La descripci√≥n de la clase se almacena en el mismo lugar y contiene el nombre, modificadores, superclase, superinterfaces, campos, m√©todos y atributos.  Los atributos, a su vez, pueden contener cualquier informaci√≥n adicional. <br><br>  Por lo tanto, al cargar clases: <br><br><ul><li>  lectura del archivo de clase, es decir, validaci√≥n de formato </li><li>  La representaci√≥n de clase se crea en el grupo Constante (Meta espacio) </li><li>  se cargan super clases y super interfaces;  si no est√°n cargados, entonces la clase en s√≠ no se cargar√° </li></ul><br><h3>  5. Ejecuci√≥n de bytecode en la JVM </h3><br>  En primer lugar, para ejecutar bytecode, la JVM puede <i>interpretarlo</i> .  La interpretaci√≥n es un proceso bastante lento.  En el proceso de interpretaci√≥n, el int√©rprete "corre" l√≠nea por l√≠nea a trav√©s del archivo de clase y lo traduce en comandos que la JVM puede entender. <br><br>  Adem√°s, la JVM puede <i>transmitirlo</i> , es decir  compilar en c√≥digo de m√°quina que se ejecutar√° directamente en la CPU. <br><br>  Los comandos que se ejecutan con frecuencia no se interpretar√°n, pero se transmitir√°n de inmediato. <br><br><h3>  6. Compilaci√≥n </h3><br>  <b>Un compilador</b> es un programa que convierte las partes fuente de los programas escritos en un lenguaje de programaci√≥n de alto nivel en un programa de lenguaje de m√°quina que es "comprensible" para una computadora. <br><br>  Los compiladores se dividen en: <br><br><ul><li>  <i>No optimizando</i> </li><li>  <i>Optimizaci√≥n simple</i> (Hotspot Client): trabaje r√°pidamente, pero genere c√≥digo no √≥ptimo </li><li>  <i>Optimizaci√≥n compleja</i> (Hotspot Server): realice transformaciones de optimizaci√≥n complejas antes de generar bytecode </li></ul><br><br>  Los compiladores tambi√©n se pueden clasificar por tiempo de compilaci√≥n: <br><br><ul><li>  <i>Compiladores din√°micos</i> <br>  Trabajan simult√°neamente con el programa, lo que afecta el rendimiento.  Es importante que estos compiladores se ejecuten en c√≥digo que a menudo se ejecuta.  Durante la ejecuci√≥n del programa, la JVM sabe qu√© c√≥digo se ejecuta con mayor frecuencia y, para no interpretarlo constantemente, la m√°quina virtual lo traduce inmediatamente en comandos que ya se ejecutar√°n directamente en el procesador. </li><li>  <i>Compiladores est√°ticos</i> <br>  Compila m√°s tiempo, pero genera el c√≥digo √≥ptimo para la ejecuci√≥n.  De los profesionales: no requieren recursos durante la ejecuci√≥n del programa, cada m√©todo se compila utilizando optimizaciones. </li></ul><br><h3>  7. Organizaci√≥n de la memoria en Java. </h3><br>  <b>Una pila</b> es un √°rea de memoria en Java que funciona de acuerdo con el esquema LIFO: " <i>√öltimo en entrar - Fisrt fuera</i> " o " <i>√öltimo</i> <i>en entrar</i> <i>, primero en</i> <i>salir</i> ". <br><br><img src="https://habrastorage.org/webt/iv/u-/aw/ivu-awjajuj-fiwyzv6kzgsp9cq.png"><br><br>  Es necesario para almacenar m√©todos.  Las variables en la pila existen mientras se ejecute el m√©todo en el que fueron creadas. <br><br>  Cuando se llama a cualquier m√©todo en Java, se crea un marco o √°rea de memoria en la pila, y el m√©todo se coloca en la parte superior.  Cuando un m√©todo completa la ejecuci√≥n, se elimina de la memoria, liberando memoria para los siguientes m√©todos.  Si la memoria de la pila est√° llena, Java lanzar√° una excepci√≥n <i>java.lang.StackOverFlowError</i> .  Por ejemplo, esto puede suceder si tenemos una funci√≥n recursiva que se llamar√° a s√≠ misma y no habr√° suficiente memoria en la pila. <br><br>  Caracter√≠sticas clave de la pila: <br><br><ul><li>  La pila se llena y libera a medida que se llaman y completan nuevos m√©todos. </li><li>  El acceso a esta √°rea de memoria es m√°s r√°pido que el mont√≥n. </li><li>  El tama√±o de la pila est√° determinado por el sistema operativo. </li><li>  Es seguro para subprocesos, ya que cada pila tiene su propia pila separada. </li></ul><br>  Otra √°rea de memoria en Java es <b>Heap</b> o <b>heap</b> .  Se utiliza para almacenar objetos y clases.  Siempre se crean nuevos objetos en el mont√≥n, y las referencias a ellos se almacenan en la pila.  Todos los objetos en el mont√≥n tienen acceso global, es decir, se puede acceder a ellos desde cualquier lugar de la aplicaci√≥n. <br><br>  El mont√≥n se divide en varias partes m√°s peque√±as llamadas generaciones: <br><br><ul><li>  <i>Generaci√≥n joven</i> : el √°rea donde se encuentran los objetos creados recientemente </li><li>  <i>Generaci√≥n antigua (tenencia)</i> : el √°rea donde se almacenan los objetos "longevos" </li><li>  Antes de Java 8, hab√≠a otra √°rea, la <i>generaci√≥n permanente</i> , que contiene metainformaci√≥n sobre clases, m√©todos y variables est√°ticas.  Despu√©s del advenimiento de Java 8, se decidi√≥ almacenar esta informaci√≥n por separado, fuera del mont√≥n, es decir, en el espacio Meta </li></ul><br><br><img src="https://habrastorage.org/webt/po/zg/f5/pozgf5m8ortucbcb_fr10p76xji.png"><br><br>  ¬øPor qu√© abandon√≥ la generaci√≥n permanente?  En primer lugar, esto se debe a un error asociado con el desbordamiento del √°rea: dado que Perm ten√≠a un tama√±o constante y no pod√≠a expandirse din√°micamente, tarde o temprano la memoria se agot√≥, se produjo un error y la aplicaci√≥n se bloque√≥. <br><br>  El metaespacio tiene un tama√±o din√°mico, y en tiempo de ejecuci√≥n puede expandirse a tama√±os de memoria JVM. <br><br>  Caracter√≠sticas clave del mont√≥n: <br><br><ul><li>  Cuando esta √°rea de memoria est√° llena, Java arroja <i>java.lang.OutOfMemoryError</i> </li><li>  El acceso al mont√≥n es m√°s lento que el acceso a la pila </li><li>  El recolector de basura trabaja para recolectar objetos no utilizados </li><li>  Un mont√≥n, a diferencia de una pila, no es seguro para subprocesos, ya que cualquier subproceso puede acceder a √©l </li></ul><br><br>  Con base en la informaci√≥n anterior, considere c√≥mo se realiza la administraci√≥n de memoria utilizando un ejemplo simple: <br><br><pre><code class="coffeescript hljs">public <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">public</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">main</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">[] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class"> = 23; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pName</span></span></span><span class="hljs-class"> = "</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Jon</span></span></span><span class="hljs-class">"; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">null</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pName</span></span></span><span class="hljs-class">); } } </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pid</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">; // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constructors</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">getters</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setters</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><br>  Tenemos una clase de aplicaci√≥n en la que el √∫nico m√©todo <i>principal</i> consiste en: <br><br>  - variable de <b>identificaci√≥n</b> primitiva de tipo <b>int</b> con valor <b>23</b> <br>  - <b>pName</b> variable de referencia de tipo <b>String</b> con valor <b>Jon</b> <br>  - variable de referencia <b>p de</b> tipo <b>persona</b> <br><br><img src="https://habrastorage.org/webt/ks/kr/yi/kskryittdimovhicuavhnx4z7se.png"><br><br>  Como ya se mencion√≥, cuando se llama a un m√©todo, se crea un √°rea de memoria en la parte superior de la pila en la que se almacenan los datos necesarios para almacenar este m√©todo. <br>  En nuestro caso, esta es una referencia a la clase de <i>persona</i> : el objeto en s√≠ se almacena en el mont√≥n y el enlace se almacena en la pila.  Tambi√©n se inserta un enlace a la cadena en la pila, y la cadena en s√≠ se almacena en el mont√≥n en el grupo de cadenas.  La primitiva se almacena directamente en la pila. <br><br>  Para llamar al constructor con los par√°metros <i>Person (String)</i> del m√©todo <i>main ()</i> en la pila, adem√°s de la llamada <i>main ()</i> anterior, se crea un marco separado en la pila que almacena: <br><br>  - <b>esto</b> - enlace al objeto actual <br>  - valor de <b>identificaci√≥n</b> primitivo <br>  - la variable de referencia <b>personName</b> , que apunta a una cadena en el conjunto de cadenas. <br><br>  Despu√©s de llamar al constructor, se llama a <i>setPersonName ()</i> , despu√©s de lo cual se crea un nuevo marco en la pila nuevamente, donde se almacenan los mismos datos: referencia de objeto, referencia de l√≠nea, valor variable. <br><br>  Por lo tanto, cuando se ejecuta el m√©todo de establecimiento, el marco desaparece, la pila se borra.  A continuaci√≥n, se ejecuta el constructor, se borra el marco que se cre√≥ para el constructor, despu√©s de lo cual el m√©todo <i>main ()</i> finaliza su trabajo y tambi√©n se elimina de la pila. <br><br>  Si se llaman otros m√©todos, tambi√©n se crear√°n nuevos marcos para ellos con el contexto de estos m√©todos espec√≠ficos. <br><br><h3>  8. Recolector de basura </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El recolector de basura</a> est√° trabajando en el mont√≥n, un programa que se ejecuta en la m√°quina virtual Java que elimina los objetos a los que no se puede acceder. <br><br>  Diferentes JVM pueden tener diferentes algoritmos de recolecci√≥n de basura; tambi√©n hay diferentes recolectores de basura. <br><br>  Hablaremos sobre el colector <b>GC</b> m√°s simple.  Solicitamos la recolecci√≥n de basura utilizando <i>System.gc ()</i> . <br><br><img src="https://habrastorage.org/webt/kh/pe/ku/khpekusa0miezejuxbdwkcc-mdc.png"><br><br>  Como se mencion√≥ anteriormente, el mont√≥n se divide en 2 √°reas: Nueva generaci√≥n y Vieja generaci√≥n. <br><br>  La nueva generaci√≥n (generaci√≥n m√°s joven) incluye 3 regiones: <i>Eden</i> , <i>Survivor 0</i> y <i>Survivor 1</i> . <br><br>  La generaci√≥n anterior incluye la regi√≥n de <i>tenencia</i> . <br><br>  ¬øQu√© sucede cuando creamos un objeto en Java? <br><br>  En primer lugar, el objeto cae en el <i>Ed√©n</i> .  Si ya hemos creado muchos objetos y no hay m√°s espacio en el <i>Ed√©n</i> , el recolector de basura dispara y libera memoria.  Esta es la llamada <i>recolecci√≥n de basura peque√±a</i> : en la primera pasada, limpia el √°rea del <i>Ed√©n</i> y coloca los objetos "sobrevivientes" en la regi√≥n <i>Survivor 0</i> .  Por lo tanto, la regi√≥n del <i>Ed√©n</i> est√° completamente liberada. <br><br>  Si sucede que el √°rea del <i>Ed√©n</i> se ha vuelto a llenar, el recolector de basura comienza a trabajar con el √°rea del <i>Ed√©n</i> y el <i>Superviviente 0</i> , que actualmente est√° ocupado.  Despu√©s de la limpieza, los objetos sobrevivientes caer√°n en otra regi√≥n: <i>Survivor 1</i> , y los otros dos permanecer√°n limpios.  Tras la posterior recolecci√≥n de basura, <i>Survivor 0</i> nuevamente se seleccionar√° como la regi√≥n de destino.  Por eso es importante que una de las regiones de <i>Survivor</i> est√© siempre vac√≠a. <br><br>  La JVM supervisa los objetos que se copian constantemente y se mueven de una regi√≥n a otra.  Y para optimizar este mecanismo, despu√©s de un cierto umbral, el recolector de basura mueve dichos objetos a la regi√≥n de <i>tenencia</i> . <br><br>  Cuando no hay suficiente espacio para nuevos objetos en <i>Tenured</i> , hay una recolecci√≥n de basura completa: <b>Mark-Sweep-Compact</b> . <br><br><img src="https://habrastorage.org/webt/yt/a1/j1/yta1j1gobagrvcbehbifdtnq5ia.png"><br><br>  Durante este mecanismo, se determina qu√© objetos ya no se usan, la regi√≥n se borra de estos objetos y el <i>√°rea de</i> memoria <i>tenured se</i> desfragmenta, es decir  Secuencialmente lleno de los objetos necesarios. <br><br><h4>  Conclusi√≥n </h4><br>  En este art√≠culo, examinamos las herramientas b√°sicas del lenguaje Java: JVM, JRE, JDK, el principio y las etapas de la ejecuci√≥n del c√≥digo JVM, la compilaci√≥n, la organizaci√≥n de la memoria, as√≠ como el principio del recolector de basura. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/471772/">https://habr.com/ru/post/471772/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../471756/index.html">C√≥mo se inicia el servidor</a></li>
<li><a href="../471758/index.html">¬øC√≥mo traducir texto a un idioma diferente?</a></li>
<li><a href="../471760/index.html">Edward Snowden: El campo de batalla - Cifrado</a></li>
<li><a href="../471766/index.html">Manejo de errores de Kotlin / Java: ¬øc√≥mo hacerlo bien?</a></li>
<li><a href="../471770/index.html">Conozca las herramientas de Big Data: compatibilidad con port√°tiles Spark y Zeppelin en IntelliJ IDEA</a></li>
<li><a href="../471774/index.html">Android Camera2 API de la tetera, parte 2, escribir un video</a></li>
<li><a href="../471776/index.html">Laravel: explica los conceptos b√°sicos. Segunda parte: pr√°ctica</a></li>
<li><a href="../471778/index.html">Rompiendo Micosoft Lunix en HackQuest 2019</a></li>
<li><a href="../471792/index.html">¬øDe d√≥nde vino el mago "Milagro ordinario"</a></li>
<li><a href="../471794/index.html">La era de los micr√≥fonos de techo plano</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>