<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤹🏿 👩🏼‍🏭 👌🏾 Primeiro conhecimento do Assistente Doméstico 🤸🏾 😗 👨🏼‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O Home Assistant é um aplicativo popular de código aberto para organizar uma casa inteligente. A primeira experiência do autor com o Assistente Domést...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Primeiro conhecimento do Assistente Doméstico</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471822/"><img width="25%" align="right" src="https://habrastorage.org/webt/sj/wt/mu/sjwtmujve5xdbroiyxjiebxbc5o.png"><br>  O Home Assistant é um aplicativo popular de código aberto para organizar uma casa inteligente.  A primeira experiência do autor com o Assistente Doméstico se baseia na tentativa de integrar uma panela de arroz inteligente.  O autor tentará descrever os principais componentes e recursos deste aplicativo, que ele teve a chance de conhecer passo a passo.  O artigo é, de certa forma, uma revisão, de certa forma um guia para quem deseja iniciar um relacionamento com o Assistente Doméstico. <br><a name="habracut"></a><br>  Para quem tem pouco tempo livre, aconselho que você pule o ditado - o primeiro capítulo - e vá direto para o segundo.  Você só precisa saber que trabalharemos com uma panela de arroz chinesa inteligente da Xiaomi. <br><br><h3>  Panela de arroz inteligente </h3>  Uma panela de arroz é obviamente uma panela de arroz.  Wiki nos mostra vapores de arroz em cerâmica do Museu Britânico que remontam a 1250 aC  Em 1945, a Mitsubishi se tornou a primeira empresa de panela elétrica de arroz do Japão.  Nosso modelo - Panela de Arroz da Xiaomi - pode cozinhar não apenas arroz.  “Este é um ótimo dispositivo para fazer não apenas arroz, mas outros tipos de pratos.  Pode cozinhar sopas, doces e muito mais ”, diz o anúncio.  Mas o mais importante é a presença de um módulo wi-fi, software com recursos de automação e mais de 200 receitas instaladas por software.  "O caminho para uma casa inteligente através do estômago é correto", pensou o autor e decidiu. <br><br>  O Xiaomi Rice Cooker, como convém a um dispositivo digital, é externamente muito atraente, agrada a sua forma redonda e minimalismo geral.  Para configurá-lo e usá-lo, o fabricante oferece o aplicativo Mi Home.  Depois de registrar a conta Mi, o programa encontra com facilidade um novo dispositivo e você o registra na sua rede local.  A interface do aplicativo não é a pior, fornece ferramentas básicas de automação e pode receber notificações dos dispositivos.  No entanto, existem desvantagens significativas.  Nem todo mundo pode ficar satisfeito com o envio de informações ao desenvolvedor sobre cada clique do usuário.  E uma expressão desagradável é frequentemente encontrada hoje em cores nacionais.  Em vez de mais de 200 receitas, apenas quatro são traduzidas e estão disponíveis em idiomas estrangeiros.  O resto é exclusivamente para o povo chinês.  Quando sua panela de arroz “inteligente” não é capaz de cumprir todos os deveres culinários prometidos, então, veja você, fica triste.  Depois de vagar por algum tempo na Internet, um triste autor se deparou com o próximo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">projeto</a> interessante (benefícios eternos para o autor).  O que acabou se dedicando ao desenvolvimento de um módulo para um determinado Assistente Doméstico. <br><br><h3>  Assistente de casa </h3>  Primeiro, algumas informações gerais.  Como nos dizem na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">página inicial do HA</a> , ”Este é um software de código aberto para automação residencial inteligente que se concentra no gerenciamento local e na privacidade.  Desenvolvido pelo trabalho de uma comunidade aberta de entusiastas, é ótimo para trabalhar em um Raspberry Pi ou servidor local. ”  O projeto tem mais de cinco anos, usa python e uma licença Apache 2.0.  A versão de lançamento no momento da escrita dessas linhas é 0.99.3. <br><br>  A HA usa módulos separados (integrações ou componentes) para gerenciar dispositivos.  Criar um é bem simples.  No site, você encontra um catálogo dos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">principais</a> módulos (aprovados e suportados pela comunidade).  Entre o número total (1485 peças), existem outros completamente diversos, os nomes amazon, google, xiaomi e até uma vez que o yandex está listado no catálogo. <br>  Vamos tentar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">instalar a</a> HA em um ambiente virtual na área de trabalho do Linux.  Nós precisaremos do gerenciador de pacotes python3 e pip. <br><pre><code class="bash hljs">python3 -m venv homeassistant <span class="hljs-comment"><span class="hljs-comment">#    cd homeassistant source bin/activate #    python3 -m pip install homeassistant #  Home Assistant hass --open-ui #  Home Assistant</span></span></code> </pre> <br>  Depois disso, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GUI</a> do HA ficará disponível em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http: // localhost: 8123</a> .  Na primeira vez que você fizer login, será necessário criar uma conta de usuário.  A interface da web do HA é bastante volumosa.  Alguns elementos importantes que merecem ser mencionados no início são a guia Configuração → Geral, onde você pode recarregar facilmente os arquivos de configuração ou o próprio servidor.  E também a página Informações na lista de ferramentas dos Desenvolvedores, onde você pode ver os logs de erros. <br><br>  O HA armazena todos os dados do usuário necessários, no caso do Linux, na pasta de configurações “~ / .homeassistant”.  Os arquivos de configuração são gravados no formato <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">YAML</a> , e o principal é "configuration.yaml".  Combina os dados dos módulos, automação, etc.  O recurso de importação permite dividir as configurações em arquivos organizados logicamente separados.  Os módulos são armazenados nas subpastas "componentes" (integrados) e "custom_components". <br><br>  Esse conhecimento deve ser suficiente para instalarmos um novo módulo.  Copie a pasta "xiaomi_cooker" do nosso repositório para o nosso "~ / .homeassistant / custom_components".  De acordo com a descrição, adicione as configurações do módulo ao arquivo "configuration.yaml": <br><div class="spoiler">  <b class="spoiler_title">configuration.yaml</b> <div class="spoiler_text"><pre> <code class="bash hljs">xiaomi_cooker: <span class="hljs-comment"><span class="hljs-comment">#   name: 'Akari' #   host: 192.168.1.10 # IP   token: '4921def609273302248d040a24243a25' #   Xiaomi model: chunmi.cooker.normal2 #  </span></span></code> </pre> <br></div></div><br>  Feito.  Após a reinicialização do HA, uma nova entrada de módulo será exibida na seção Geral → Integrações da interface da web. <br><br>  Qualquer módulo é um determinado conjunto de objetos (entidades) e serviços (serviços, em essência - funções).  Os objetos armazenam vários dados recebidos dos dispositivos.  Por exemplo, sensor.xiaomi_cooker_temperature é a temperatura da panela de arroz, sun.sun é a posição do sol.  Os dados de um objeto são expressos por um valor básico - status (estado) e um conjunto arbitrário de atributos adicionais (atributos).  Os serviços são usados ​​para transferir comandos e valores para dispositivos.  Por exemplo, xiaomi_cooker.start - o comando para iniciar a operação da panela de arroz, ou homeassistant.check_config - a inicialização da pesquisa de erros nos arquivos de configurações de alta disponibilidade.  A lista Ferramentas do desenvolvedor da interface da web contém a seção Serviços, onde você pode visualizar a lista de serviços disponíveis para você e brincar com as chamadas.  Perto é a seção Estados, onde, consequentemente, você pode visualizar e alterar os valores dos objetos.  Note-se que as alterações nos valores dos objetos na seção Estados são unilaterais.  I.e.  se, por exemplo, você alterar o estado do objeto lights.state aqui de desligado para ligado, isso não afetará o estado real do dispositivo e, na próxima vez em que os dados do dispositivo forem atualizados, o valor do objeto será substituído por real. <br><br><h3>  Automação </h3>  A principal ferramenta de gerenciamento para uma casa inteligente é a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">automação</a> .  Você pode adicioná-los e editá-los usando a interface gráfica na seção Geral → Automação ou diretamente no arquivo "automations.yaml".  A principal função da automação é chamar serviços quando determinadas condições forem atendidas.  Ferramentas básicas para definir as condições para chamar o valor dos objetos, incl.  dados de tempo.  Existem soluções um pouco mais específicas, como eventos.  Como um exemplo simples de automação, forneceremos um código que atualiza os dados de vantagem do autor com um período de 15 minutos: <br><div class="spoiler">  <b class="spoiler_title">automations.yaml</b> <div class="spoiler_text"><pre> <code class="bash hljs"> - id: <span class="hljs-string"><span class="hljs-string">'1565889970818'</span></span> <span class="hljs-comment"><span class="hljs-comment"># ID  alias: Umpiro decharging #  trigger: #   - platform: time_pattern #   -  minutes: /15 #   (   –    15 ) condition: [] #    action: #    - data: # ,     entity_id: sensor.umpiro_charge #  (: ) service: homeassistant.update_entity #   </span></span></code> </pre> <br></div></div><br>  Deve-se notar que até agora nem toda a automação disponível (por exemplo, a acima) pode ser configurada sem editar o código yaml por meio da interface gráfica, mas os desenvolvedores dizem que estão trabalhando ativamente para eliminar essa desvantagem. <br><br><h3>  Templating </h3>  Após a automação, é hora de falar sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">modelos</a> (modelos).  Vários elementos de configurações nos arquivos yaml permitem usar inserções na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">linguagem de script jinja2</a> .  Muitos desses elementos são unidos pelo nome comum 'Modelos', como service_template ou trigger_template.  Usando modelos, obtemos acesso aos valores dos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">objetos no HA</a> e a capacidade de usar esses dados em expressões matemáticas e lógicas complexas, o que expande bastante o nosso potencial.  Como exemplo, vamos usar um código um pouco mais complicado de sensor.umpiro_charge, escrito em "configuration.yaml".  Este é o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">template_sensor</a> , ou seja, "um sensor que forma dados com base nos valores de outros objetos".  Nosso sensor será um análogo de uma bateria gradualmente descarregada: <br><div class="spoiler">  <b class="spoiler_title">configuration.yaml</b> <div class="spoiler_text"><pre> <code class="bash hljs">sensor: <span class="hljs-comment"><span class="hljs-comment">#   platform: template #   -  sensors: #   #   – sensor.umpiro_charge umpiro_charge: #      UI () unit_of_measurement: '%' # ,    value_template: &gt;- #    –   'int' # +     {% if states('sensor.umpiro_charge')|int('unknown') is number %} #       #         {% set value = (states('sensor.umpiro_charge')|int - (as_timestamp(now()) - as_timestamp(states.sensor.umpiro_charge.last_updated))/60/15)|round %} #       {{ [[0, value]|max, 100]|min }} {% else %} # ,  HA   #      {{ 'unknown' }} {% endif %} # ID  ,     #      entity_id: [] friendly_name: 'Charge' #   #      UI () device_class: battery</span></span></code> </pre><br></div></div><br>  Deixamos o entity_id em branco porque já adicionamos automação que causará independentemente a atualização dos dados do objeto. <br><br><h3>  Scripts Python </h3>  Por sua vez, os scripts python são uma ferramenta simples para criar novos serviços.  Após adicionar a linha: “script python:” a “configuration.yaml”, todos os arquivos com a extensão “.py” que colocamos na pasta “~ / .homeassistant / python_scripts” ficarão disponíveis como serviços com os nomes “python_scripts. &lt; nome_do_arquivo&gt; ”.  Seu código é executado em um ambiente predefinido, onde os dados e variáveis ​​hass nos dão acesso aos argumentos da chamada de serviço, bem como aos objetos e serviços de alta disponibilidade.  Como exemplo, fornecemos o código do arquivo "charge_set.py" para o serviço "python_scripts.charge_set".  Sua função será definir a carga da nossa bateria: <br><div class="spoiler">  <b class="spoiler_title">python_scripts / charge_set.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#     name = data.get('name', 'sensor.umpiro_charge') #     new_state = data.get('charge', '100') #    attributes = hass.states.get(name).attributes #    hass.states.set(name, new_state, attributes)</span></span></code> </pre> <br></div></div><br><br><h3>  Criando integração </h3>  Tudo o que fizemos com a ajuda de modelos e scripts Python, talvez fosse mais fácil fazer isso escrevendo um módulo separado.  Como já mencionado, os módulos não oficiais são armazenados na pasta "custom_components".  No futuro, precisaremos de um objeto que armazene informações sobre a receita atual da nossa panela de arroz e um serviço que permita alterar esses dados.  Com base em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exemplo da documentação,</a> criaremos um novo módulo para isso, "sobrecarregar".  A primeira etapa é o arquivo custom_components / overmind / __ init__.py: <br><div class="spoiler">  <b class="spoiler_title">custom_components / overmind / __ init__.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#     DOMAIN = 'overmind' #       () DEFAULT_RECIPE = { "title": "Habr post", "description": "Post an article on habr.com", "profile": "471822" } #    def setup(hass, config): #    hass.states.set('overmind.current_recipe', 'on', DEFAULT_RECIPE) #       def handle_set(call): #    recipe = call.data.get('recipe', DEFAULT_RECIPE) #   -    hass.states.set('overmind.current_recipe', 'set', recipe) #   hass.services.register(DOMAIN, 'recipe_set', handle_set) return True</span></span></code> </pre> <br></div></div><br>  Depois disso, reportaremos o novo módulo ao arquivo de configuração “configuration.yaml”, adicionando uma linha com o nome do módulo: “overmind:”.  O problema está resolvido. <br><br><h3>  Interface do usuário Lovelace </h3>  Esse é o nome do HA de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">front-end</a> usado.  Essa interface gráfica, através da qual um usuário comum é convidado a controlar uma casa inteligente, é a primeira página da interface da web de alta disponibilidade.  A interface LUI é formada por cartões de vários tipos, que podem refletir os valores dos objetos, servem para chamar funções e outras tarefas.  Os cartões podem ser distribuídos nas páginas (visualização), por analogia com os favoritos do navegador.  A configuração é convenientemente organizada através da mesma interface gráfica, mas também é acessível através do código yaml, para o qual também há um editor de texto embutido.  Eu recomendo que você consulte a página <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://demo.home-assistant.io/</a> , onde existem vários exemplos diferentes de configurações da LUI e onde você pode ver, clicar e modificá-las com facilidade. <br><br><img src="https://habrastorage.org/webt/64/bd/zf/64bdzfwclc_3sqnoek13735wgqq.png"><br>  <i><font color="grey">Exemplo de configuração da GUI</font></i> <br><br>  Falando sobre as deficiências da interface, infelizmente, os próprios desenvolvedores admitem que o projeto está tentando se sentar simultaneamente nas cadeiras da área de trabalho e do smartphone.  A LUI, por padrão, gosta de determinar independentemente a localização e o tamanho dos cartões, o que às vezes pode transformar uma página que parece normal no monitor em uma bagunça na tela do smartphone e vice-versa.  Existem algumas ferramentas simples para otimizar a interface, mas, na minha experiência, nem sempre são eficazes. <br><br>  Eu acho que não faz muito sentido descrever a criação de uma interface usando ferramentas gráficas, então darei alguns exemplos na forma do código yaml que usei.  Depois de criar uma página separada (visualização) para a nossa panela de arroz, tentaremos preenchê-la com os elementos mais necessários para que não cause rejeição ao usar a tela do smartphone. <br><br>  Aqui, tentaremos essas ferramentas muito simples de ordenação de interfaces, que são a pilha horizontal e a pilha vertical.  Primeiro, crie uma pilha vertical a partir de cartões dos tipos botão de entidade e sensor.  O primeiro servirá para lançar nossa panela de arroz, o segundo - para exibir a temperatura: <br><div class="spoiler">  <b class="spoiler_title">pilha vertical</b> <div class="spoiler_text"><pre> <code class="bash hljs">cards: <span class="hljs-comment"><span class="hljs-comment">#    - type: entity-button #      entity: sensor.xiaomi_cooker_state # ,     icon: 'mdi:selection' #     icon_height: 100px #   name: Offline #    show_icon: true # show_name: true # tap_action: #    action: call-service #  –   service: script.turn_on #  –   service_data: #    entity_id: script.order_cooker_start #  –   hold_action: #    action: none # - type: sensor #      entity: sensor.xiaomi_cooker_temperature # ,     name: Temper #   type: vertical-stack #   –  </span></span></code> </pre> <br></div></div><br>  O Assistente Doméstico inclui um arquivo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ícones de Design</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Materiais</a> , que, por meio de nomes apropriados (por exemplo, mdi: selection), pode ser usado nos itens de configuração.  O script (neste caso, não python-, mas yaml-), que costumávamos chamar de serviço, é outra ferramenta conveniente de HA. <br><br>  Agora combine a pilha vertical acima com o cartão de retrato na pilha agora horizontal.  Tudo será tão simples: <br><div class="spoiler">  <b class="spoiler_title">pilha horizontal</b> <div class="spoiler_text"><pre> <code class="bash hljs">ards: <span class="hljs-comment"><span class="hljs-comment">#    - type: picture #   image: /local/akari_r.jpg #    - #         type: horizontal-stack #   –  </span></span></code> </pre> <br></div></div><br>  Aqui você precisa marcar a linha 'imagem:'.  Todos os arquivos que colocamos na pasta '~ / .homeassistant / www' ficam disponíveis no link <a href="">http: // localhost / local / filename</a> . <br><br>  O próximo passo é trabalhar um pouco no botão de chamada de serviço que criamos.  Seria conveniente para nós se funcionasse como uma chave seletora, ou seja,  on / off, e não da maneira como é feito agora.  Isso pode ser alcançado com o uso de um cartão do tipo condicional, cuja exibição na tela pode ser ajustada através da definição de determinadas condições.  Abaixo está o código do cartão, que é o botão para desligar a panela de arroz e só é visível se a panela estiver no processo de preparação do prato: <br><div class="spoiler">  <b class="spoiler_title">condicional</b> <div class="spoiler_text"><pre> <code class="bash hljs">card: <span class="hljs-comment"><span class="hljs-comment">#    entity: sensor.xiaomi_cooker_state # icon: 'mdi:star-box-outline' # icon_height: 100px # name: Running # tap_action: # action: call-service # service: xiaomi_cooker.stop # type: entity-button # conditions: #   # ,    entity: sensor.xiaomi_cooker_mode #  ,     state: Running type: conditional #  </span></span></code> </pre> <br></div></div><br>  Reescrevendo o código do botão liga / desliga criado anteriormente de maneira semelhante e combinando-o com isso, obtemos um botão que funciona tanto dentro quanto fora. <br><br>  Complementamos nosso interesse com outro cartão - com o tempo até o final do cozimento (semelhante ao cartão de temperatura) e mais um com os detalhes da receita (personalizada: cartão de receita) exibida.  Como resultado, temos algo parecido com isto: <br><div style="text-align:center;"><img width="50%" src="https://habrastorage.org/webt/k6/kv/zq/k6kvzqqugn8sizjtsemxyufquo8.jpeg"></div><br><h3>  Cartões personalizados </h3>  O Assistente de Casa, além da riqueza do conjunto interno de tipos de cartão, é claro, oferece a capacidade de criar o seu próprio.  Esses cartões são chamados de cartões personalizados e o javascript é usado para criá-los.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aqui</a> estão dois exemplos simples de código.  É fácil encontrar cartões prontos criados por vários <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">entusiastas na</a> rede e, se você quiser experimentar, será útil descobrir que existem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">módulos js</a> especiais criados para simplificar o trabalho de criação de novos.  Minha experiência com javascript continua a querer menos, portanto, como exemplo, darei apenas uma pequena parte do código do cartão usado para selecionar e exibir a receita atual. <br><div class="spoiler">  <b class="spoiler_title">www / receita-card.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     lit-element LitElement, html, css } from "https://unpkg.com/lit-element@latest/lit-element.js?module"; //      class RecipeCard extends LitElement { //     HA static get properties() { return { hass: {}, config: {} }; } //    callServiceEx() { this.hass.callService('persistent_notification', 'create', {message: 'example'}); } //  html-  render() { //    ,     const entityId = this.config.entity; //    const state = this.hass.states[entityId]; //    const titleStr = state ? state.attributes.title : 'unavailable'; const descrStr = state ? state.attributes.description : 'unavailable'; //    return html` &lt;ha-card&gt; &lt;div class="flex" style="margin-top:16px;"&gt; &lt;div class="icon"&gt; &lt;ha-icon icon="mdi:bowl"&gt;&lt;/ha-icon&gt; &lt;/div&gt; &lt;div class="header"&gt; &lt;span class="name"&gt;Recipe&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="flex info" style="margin-bottom:16px;"&gt; &lt;span class="recipe-title"&gt;${titleStr}&lt;/span&gt; &lt;span class="recipe-descr"&gt;${descrStr}&lt;/span&gt; &lt;/div&gt; &lt;/ha-card&gt; `; } //     customElements.define('recipe-card', RecipeCard);</span></span></code> </pre> <br></div></div><br><br>  Para usar o novo cartão, você precisará adicionar o seguinte código no início do arquivo de configurações da LUI: <br><div class="spoiler">  <b class="spoiler_title">cartão de receita</b> <div class="spoiler_text"><pre> <code class="bash hljs">resources: <span class="hljs-comment"><span class="hljs-comment">#    - type: module #   –  url: /local/recipe-card.js #  </span></span></code> </pre><br>  e entre a lista de cartões: <br><pre> <code class="bash hljs"> - <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>: <span class="hljs-string"><span class="hljs-string">'custom:recipe-card'</span></span> <span class="hljs-comment"><span class="hljs-comment">#   entity: overmind.current_recipe # ,    </span></span></code> </pre><br><br></div></div><br><h3>  Notificações </h3>  Uma parte necessária de uma casa inteligente está enviando mensagens para o usuário.  No HA, essas mensagens são chamadas de notificações e existem dois tipos básicos de notificações.  O primeiro são notificações persistentes.  Para enviá-los, o serviço interno "persistent_notification.create" é usado.  Uma lista dessas mensagens está disponível através do ícone de campainha na interface gráfica, elas usam a marcação de remarcação e são essencialmente bastante simples. <br><br>  Outra ferramenta mais interessante é o módulo de notificação embutido, que através da instalação de módulos adicionais permite enviar mensagens usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">plataformas de terceiros</a> .  Como exemplo, considere um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">módulo para telegrama</a> . <br><br>  Para usar o módulo, primeiro, precisamos criar um bot no próprio telegrama.  Ao configurar, precisamos do chat_id do nosso usuário e da API do bot de token.  Como obter esses dados - descritos em detalhes no link acima, assumimos que estamos prontos.  Movendo-se diretamente para a instalação do módulo, primeiro, como já fizemos, copie seu código-fonte para a pasta components e, em seguida, adicione suas configurações ao arquivo "configuration.yaml": <br><div class="spoiler">  <b class="spoiler_title">configuration.yaml</b> <div class="spoiler_text"><pre> <code class="bash hljs">telegram_bot: <span class="hljs-comment"><span class="hljs-comment">#   telegram platform: polling #   api_key: XXXXXXXXXXXXX # API Token   allowed_chat_ids: XXXXXXX # chat_id   proxy_url: socks5://XXXXXXXXXXXXX #     proxy_params: username: umpiro password: umpiro_password</span></span></code> </pre> <br>  mais configurações para o módulo de notificação: <br><pre> <code class="bash hljs">notify: <span class="hljs-comment"><span class="hljs-comment">#   notify name: notify_send #   (   –  notify.notify_send) platform: telegram #   chat_id: XXXXXXX # chat_id  </span></span></code> </pre> <br></div></div><br><br>  O módulo de telegrama nos permite enviar mensagens, fotos ou vídeos.  Como exemplo, criaremos automação para enviar uma mensagem com uma foto, notificando-nos do final do cozimento. <br><div class="spoiler">  <b class="spoiler_title">automations.yaml</b> <div class="spoiler_text"><pre> <code class="bash hljs"> - id: <span class="hljs-string"><span class="hljs-string">'1571074941908'</span></span> <span class="hljs-comment"><span class="hljs-comment"># ID  alias: EOC #   trigger: #    # ,   - entity_id: sensor.xiaomi_cooker_mode from: Running #    #   –    platform: state to: Waiting #    condition: [] #   action: #    - service: notify.notify_send #  –   data: # ,     title: End of Cooking #  message: "EOC" #  data: #    photo: #   -  #   - file: /home/umpiro/.homeassistant/www/cat.jpg #   caption: “EOC”</span></span></code> </pre> <br></div></div><br><br><h3>  Posfácio </h3>  O Assistente de residência pode ser de interesse para quem deseja tentar organizar o gerenciamento local de uma casa inteligente.  Este é um projeto amplo, interessante, de desenvolvimento aberto e ativo, devido aos esforços da comunidade.  A variedade de ferramentas do Assistente Doméstico não pode deixar de se alegrar (não tive tempo de mencionar algumas importantes).  Como sinal de menos, pode-se mencionar a relativa complexidade e incompletude da documentação. <br>  PS <br>  Recentemente, em 10 de outubro, houve, não sei se isso pode ser chamado de release, a transição do projeto da versão 0.99 para a versão 0.100. <br>  Citação das Notas da versão: <br><blockquote>  Bem-vindo às notas de lançamento de mais um lançamento maravilhoso!  Não, não estamos indo para 1.0, estamos fazendo 0.100!  Sentimos que ainda não estamos prontos com nossas metas para a 1.0, mas estamos progredindo todos os dias.  Para uma amostra do que estamos pensando, consulte o blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Modo simples no Home Assistant 1.0.</a> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt471822/">https://habr.com/ru/post/pt471822/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt471810/index.html">Compare as ferramentas para auditar alterações no Active Directory: Quest Change Auditor e Netwrix Auditor</a></li>
<li><a href="../pt471812/index.html">Biblioteca gratuita do Wolfram Engine para desenvolvedores de software</a></li>
<li><a href="../pt471814/index.html">WolframClientForPython | Nova biblioteca cliente da linguagem Wolfram para Python</a></li>
<li><a href="../pt471816/index.html">Como assinar aplicativos para o macOS Catalina 10.15</a></li>
<li><a href="../pt471820/index.html">Golpistas por telefone. Etapa três, na qual obtenho documentação de que meu celular do banco foi criado</a></li>
<li><a href="../pt471824/index.html">Câmera de disquete: 8 fatos interessantes sobre o Sony Mavica MVC-FD85 (muitas fotos)</a></li>
<li><a href="../pt471836/index.html">Visualização de código python automatizada. Parte Quatro: Suporte à Documentação</a></li>
<li><a href="../pt471838/index.html">Amor de matemática</a></li>
<li><a href="../pt471840/index.html">Por que ir a entrevistas</a></li>
<li><a href="../pt471844/index.html">5 razões para visitar EPAM INSIDER no Cazaquistão</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>