<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüîß üëπ üñêüèª Automatizaci√≥n de pruebas de servicios pagos en iOS ü§≥ üë®üèø‚Äç‚úàÔ∏è üå¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Para aquellos que est√©n interesados ‚Äã‚Äãen el tema de la automatizaci√≥n en iOS, tengo dos novedades: buenas y malas. Bien: en la aplicaci√≥n iOS para ser...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Automatizaci√≥n de pruebas de servicios pagos en iOS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/460667/">  Para aquellos que est√©n interesados ‚Äã‚Äãen el tema de la automatizaci√≥n en iOS, tengo dos novedades: buenas y malas.  Bien: en la aplicaci√≥n iOS para servicios pagos, solo se utiliza un punto de integraci√≥n: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">compras en la aplicaci√≥n</a> (compras <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">integradas en la aplicaci√≥n</a> ).  Malo: Apple no proporciona ninguna herramienta para automatizar las compras de prueba. <br><br>  En este art√≠culo, sugiero que usted y yo busquemos un m√©todo de automatizaci√≥n universal m√°s all√° del bien y el mal de Apple.  El art√≠culo ser√° √∫til para cualquier persona que integre servicios de terceros que sean una caja negra en sus aplicaciones: publicidad, transmisi√≥n, administraci√≥n de ubicaci√≥n, etc. Por lo general, tales integraciones son muy dif√≠ciles de probar, ya que no hay forma de configurar de manera flexible un servicio de terceros para probar la aplicaci√≥n. <br><br><img src="https://habrastorage.org/webt/fg/if/j3/fgifj3qfcwf_98iuebxjx-fxrka.jpeg"><br><a name="habracut"></a><br>  <i>Mi nombre es Victor Koronevich, soy ingeniero senior de automatizaci√≥n de pruebas en Badoo.</i>  <i>Comprometido en la automatizaci√≥n m√≥vil durante m√°s de diez a√±os.</i>  <i>Junto con mi colega Vladimir Solodov, hicimos este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informe</a> en la conferencia de Heisenbug.</i>  <i>Tambi√©n me ayud√≥ a preparar este texto.</i> <br><br>  En un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo</a> anterior <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">,</a> describimos qu√© m√©todos utiliza Badoo para probar la integraci√≥n con los proveedores de pagos, que tenemos m√°s de 70. En este art√≠culo hablaremos m√°s sobre c√≥mo logramos lograr una automatizaci√≥n estable y econ√≥mica de probar servicios pagos en una aplicaci√≥n iOS. <br><br>  Comencemos con una descripci√≥n general de nuestra investigaci√≥n: <br><br><ol><li>  Definici√≥n del problema <br></li><li>  Declaraci√≥n del problema. <br></li><li>  Soluci√≥n No. 1.  Sandbox de manzana <br></li><li>  Decisi√≥n n√∫mero 2.  M√©todo de simulaci√≥n de funciones y uso de un objeto falso <br></li><li>  Valoraci√≥n de la decisi√≥n: principales riesgos <br></li><li>  Resultado <br></li><li>  Conclusi√≥n <br></li></ol><br><h2>  Definici√≥n del problema </h2><br>  La automatizaci√≥n debe hacerse cuando surge una necesidad natural.  ¬øCu√°ndo lleg√≥ este momento con nosotros? <br><br>  Hay muchas funciones gratuitas en la aplicaci√≥n Badoo, pero las pagas le dan al usuario m√°s opciones.  Los obtienen de dos maneras: para pr√©stamos, la moneda interna de Badoo, o mediante la compra de una suscripci√≥n premium.  Para un cierto n√∫mero de cr√©ditos, puede elevar su perfil en los resultados de b√∫squeda al primer lugar, hacer un regalo a otro usuario y m√°s.  La suscripci√≥n premium es v√°lida por un cierto per√≠odo de tiempo y ofrece varias opciones a la vez: activar el modo de invisibilidad, ver a las personas que han mostrado simpat√≠a por usted, cancelar el resultado de su voto y otros. <br><br>  Estas caracter√≠sticas aparecieron en Badoo gradualmente.  Y hace un par de a√±os, probamos los servicios pagos en aplicaciones iOS solo manualmente.  Pero a medida que aparecen las funciones y las nuevas pantallas, las pruebas manuales tomaron m√°s y m√°s tiempo.  Los requisitos para los cambios en la aplicaci√≥n provienen de diferentes lados: desde los desarrolladores del lado del cliente, los desarrolladores del lado del servidor e incluso el propio proveedor de Apple.  Para un probador, una iteraci√≥n de prueba comenz√≥ a tomar alrededor de ocho horas.  Se hizo imposible obtener una respuesta r√°pida para un desarrollador en su sucursal en 30 minutos, lo que finalmente podr√≠a afectar negativamente la competitividad del producto. <br><br>  Quer√≠amos obtener los resultados de las pruebas lo m√°s r√°pido posible.  Y se encontraron con un problema: ¬øc√≥mo organizar las pruebas de regresi√≥n de los servicios pagos en nuestras aplicaciones iOS de forma econ√≥mica para obtener resultados r√°pidos y estables? <br><br><h2>  Declaraci√≥n del problema. </h2><br>  Entonces, teniendo en cuenta los detalles de nuestro proceso de entrega del producto final y el tama√±o del equipo, queremos: <br><br><ul><li>  Probar cualquier compra dentro de la aplicaci√≥n del cliente (pagos √∫nicos y suscripciones); <br></li></ul><br><ul><li>  repetir iteraciones de prueba 10‚Äì20 veces al d√≠a; <br></li><li>  Obtenga resultados de prueba ~ 150 scripts de prueba en menos de media hora; <br></li><li>  deshacerse del ruido; <br></li><li>  poder ejecutar pruebas en una rama espec√≠fica del c√≥digo de desarrollador, independientemente de los resultados de otras ejecuciones. <br></li></ul><br>  Ahora que hemos formulado la tarea, es hora de comenzar el viaje al maravilloso mundo de los ingenieros y sus soluciones. <br><br><h2>  Soluci√≥n No. 1.  Sandbox de manzana </h2><br>  En primer lugar, comenzamos a buscar informaci√≥n sobre la organizaci√≥n de pruebas autom√°ticas de servicios pagos en la documentaci√≥n de Apple.  Y no encontraron nada.  El soporte de automatizaci√≥n se ve muy escaso.  Si aparece algo, entonces la configuraci√≥n de la automatizaci√≥n con las herramientas propuestas es dif√≠cil (recordemos al menos la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">automatizaci√≥n UIA</a> , as√≠ como el momento en que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">apareci√≥</a> la primera utilidad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">xcrun simctl</a> para iOS Simulator) y hay que buscar soluciones de ingenier√≠a, incluso en el segmento de c√≥digo abierto. <br><br>  En la documentaci√≥n de Apple para probar servicios pagos, solo puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Apple Sandbox</a> .  No estaba claro c√≥mo vincular este entorno limitado a la automatizaci√≥n, pero decidimos investigar seriamente esta soluci√≥n.  El hecho de que el entorno limitado de Android fuera estable nos dio confianza, y para entonces ya hab√≠amos escrito con √©xito las pruebas en Android.  ¬øQuiz√°s el sandbox de Apple sea igual de bueno? <br><br>  Pero cuando implementamos las pruebas autom√°ticas usando este sandbox, bebimos por completo.  Repasemos r√°pidamente los principales problemas. <br><br><h3>  1. El grupo de usuarios de prueba </h3><br>  La principal limitaci√≥n para la automatizaci√≥n fueron las caracter√≠sticas del contenido en el grupo de usuarios de prueba, lo que deber√≠a garantizar la independencia del lanzamiento de las pruebas autom√°ticas. <br><br>  Para ejecutar solo una compra autom√°tica de una compra de suscripci√≥n, necesitamos: <br><br><ol><li>  tomar un nuevo usuario para autorizaci√≥n en el sandbox; <br></li><li>  cambiar en el simulador la ID de Apple vinculada actual; <br></li><li>  Inicie sesi√≥n en Badoo con Badoo <br></li><li>  ir a la pantalla de compra de suscripci√≥n y seleccionar un producto; <br></li><li>  Confirme la compra e inicie sesi√≥n con Apple ID; <br></li><li>  aseg√∫rese de que la compra haya sido exitosa; <br></li><li>  enviar usuario de Badoo para limpieza; <br></li><li>  borre al usuario del sandbox de las suscripciones. <br></li></ol><br>  Si intenta utilizar inmediatamente al mismo usuario en la pr√≥xima prueba, ser√° imposible comprar una segunda suscripci√≥n.  Debe esperar hasta que la primera suscripci√≥n "salga mal" o cancelar la suscripci√≥n en la configuraci√≥n.  Como dijimos en el primer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo</a> , el sandbox tiene un per√≠odo de validez de suscripci√≥n espec√≠fico.  Si compra una suscripci√≥n "por un mes", debe esperar cinco minutos para cerrarla autom√°ticamente.  El proceso de cancelaci√≥n de la suscripci√≥n tampoco es r√°pido. <br><br>  En consecuencia, para una nueva ejecuci√≥n de la misma prueba, tendremos que esperar hasta que finalice la suscripci√≥n o tomar otro usuario "limpio".  Si queremos ejecutar dos pruebas simult√°neamente independientemente una de la otra, entonces necesitamos tener al menos dos usuarios de sandbox en el grupo.  Por lo tanto, para ejecutar 100 pruebas autom√°ticas en paralelo en 100 hilos, necesitamos 100 usuarios diferentes. <br><br>  Y ahora imaginemos que estamos realizando una prueba de autoevaluaci√≥n en dos agentes, cada uno de los cuales puede ejecutarlos en 100 subprocesos.  ¬°En este caso, necesitamos al menos 200 usuarios! <br><br><h3>  2. Notificaciones "malas" </h3><br>  Bueno, ¬°qu√© demonios no es broma!  Organizamos un grupo de usuarios y comenzamos a observar c√≥mo se ejecutan las pruebas.  Cayeron por el camino, pero la mayor√≠a, por nuevas razones desconocidas para nosotros.  Comenzamos a comprender y nos dimos cuenta de que al autorizar, confirmar una compra y trabajar como usuario en el sandbox, la App Store env√≠a alertas: por ejemplo, solicita un nuevo nombre de usuario y contrase√±a, confirma la autorizaci√≥n haciendo clic en el bot√≥n "Aceptar", brinda informaci√≥n sobre un error interno con el bot√≥n "Aceptar" .  A veces aparecen, a veces no.  Y si aparecen, siempre en un orden diferente. <br><br><img src="https://habrastorage.org/webt/sq/tu/1j/sqtu1ja-altpboz3pcudwnz8flm.gif"><br><br>  ¬øC√≥mo es posible que un error sospechoso simplemente se ignore en una prueba autom√°tica?  Y si llega un error real, ¬øqu√© debo hacer?  Esta √°rea se convirti√≥ autom√°ticamente en una "zona ciega" para nosotros, y tuvimos que escribir controladores especiales para todas las alertas posibles que pudieran llegar desde la App Store. <br><br>  Todo esto hizo que las pruebas fueran m√°s lentas: <br><br><ul><li>  las alertas podr√≠an llegar a diferentes pasos del escenario de prueba, destruyendo la idea principal de la prueba: escenario de prueba predecible;  tuvimos que agregar un controlador de errores que esperaba que apareciera una posible serie de alertas ignoradas conocidas; <br></li><li>  a veces llegaron nuevas variaciones de alertas u ocurrieron otros errores, por lo que tuvimos que reiniciar las pruebas ca√≠das;  Esto aument√≥ el tiempo de ejecuci√≥n de todas las pruebas. <br></li></ul><br><h3>  3. ¬øHubo una prueba? </h3><br>  Por lo tanto, los usuarios del grupo se bloquean y luego se borran durante n minutos.  Realizamos pruebas en 120 subprocesos y ya hay muchos usuarios en el grupo, pero esto no es suficiente.  Creamos nuestro sistema de gesti√≥n de usuarios, creamos un controlador de alertas, y luego sucedi√≥ la TI.  El sandbox no estar√° disponible durante un par de d√≠as para cualquier usuario de prueba. <br><br>  Nadie esperaba esto.  Y esta fue la gota que colm√≥ el vaso de nuestra paciencia, que finalmente mat√≥ el amor de la caja de arena de Apple y nos hizo emprender el camino m√°s all√° del bien y el mal.  Nos dimos cuenta de que no necesit√°bamos tal automatizaci√≥n y que no quer√≠amos sufrir m√°s con esta peligrosa decisi√≥n. <br><br><h2>  Decisi√≥n n√∫mero 2.  M√©todo de simulaci√≥n de funciones y uso de un objeto falso </h2><br>  Entonces, bebimos problemas con la automatizaci√≥n en el sandbox de Apple.  Pero no pienses que en el mundo m√≥vil todo es completamente malo.  En Android, el sandbox es mucho m√°s estable: puede ejecutar pruebas autom√°ticas all√≠. <br><br>  Intentemos encontrar otra soluci√≥n para iOS.  ¬øPero c√≥mo mirar?  Donde mirar  Veamos la historia de las pruebas y el desarrollo de software: ¬øqu√© pas√≥ con el loco mundo de Apple?  ¬øQu√© dicen las personas que han escrito un mont√≥n de libros y se han ganado la autoridad en el mundo de la automatizaci√≥n y el desarrollo de software? <br><br>  Inmediatamente record√© el trabajo "Patrones de prueba xUnit: Refactoring Test Code", escrito por Gerard Mesaroche ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">revisi√≥n de</a> Martin Fowler), - en mi opini√≥n, uno de los mejores libros para cualquier probador que conozca al menos un lenguaje de programaci√≥n de alto nivel y quiera hacer la automatizaci√≥n .  Un par de cap√≠tulos de este libro dedicados a probar SUT en forma aislada de otros componentes de la aplicaci√≥n, que son nuestro "recuadro negro", pueden ayudarnos. <br><br><h3>  1. Introducci√≥n a mocha y falso </h3><br>  Cabe se√±alar que en el mundo de las pruebas autom√°ticas no existe un l√≠mite generalmente aceptado entre los conceptos de Dobles de prueba, Test Stub, Test Spy, Mock Object, Fake Object, Dummy Object.  Siempre debe considerar la terminolog√≠a del autor.  Solo necesitamos dos conceptos del gran mundo de Test Doubles: una funci√≥n simulada y un objeto falso.  Que es esto  ¬øY por qu√© necesitamos esto?  Damos una breve definici√≥n de estos conceptos para que no tengamos desacuerdos. <br><br>  Supongamos que tenemos una aplicaci√≥n y un componente integrado, que es para nosotros una "caja negra".  Dentro de la aplicaci√≥n, podemos llamar a las funciones accediendo a este componente y obtener los resultados de estas funciones.  Dependiendo del resultado, nuestra aplicaci√≥n reacciona de manera espec√≠fica.  A veces, el resultado de la ejecuci√≥n de la funci√≥n puede ser una entidad completa con un mont√≥n de campos que reflejan los datos reales del usuario. <br><br>  Sustituci√≥n de una funci√≥n por otra que devuelva el resultado deseado, llamemos simulacro de la funci√≥n, o simplemente simulacro.  Estas funciones pueden tener la misma firma, pero estas son dos funciones diferentes. <br><br>  Y la sustituci√≥n de la entidad obtenida como resultado de la funci√≥n de una entidad falsa (que contiene los datos necesarios en los campos, y a veces incluso datos corruptos) se llamar√° la implementaci√≥n de un objeto falso.  Puede leer m√°s sobre esto en el libro que mencion√© anteriormente, o en cualquier otro compendio para pruebas y desarrollo de software. <br><br>  Para terminar con esto, enfaticemos algunas caracter√≠sticas del uso de funciones simuladas y objetos falsos: <br><br><ol><li>  Para que las funciones se mojen, debe acceder al c√≥digo fuente y saber c√≥mo funciona la aplicaci√≥n con el componente desde el interior a nivel de desarrollador. <br></li><li>  Para implementar un objeto falso, necesita conocer la estructura del objeto real. <br></li><li>  El uso de la funci√≥n simulada permite una configuraci√≥n flexible de la aplicaci√≥n con el componente. <br></li><li>  El uso de un objeto falso le permite dotar a una entidad de cualquier propiedad. <br></li></ol><br>  El m√©todo de objetos falsos y moki es ideal para aislar el funcionamiento de un componente dentro de una aplicaci√≥n.  Veamos c√≥mo podemos aplicar este m√©todo para resolver nuestro problema, donde App Store ser√° el componente.  Debido a las peculiaridades del uso de este m√©todo, primero tenemos que pasar a estudiar la naturaleza del trabajo de nuestra aplicaci√≥n con el componente, y luego a la implementaci√≥n t√©cnica para hacer mokeys espec√≠ficos y objetos falsos. <br><br><h2>  2. ¬øC√≥mo sucede una compra real? </h2><br>  Antes de comenzar a describir la interacci√≥n de todas las partes del sistema, destaquemos los principales actores: <br><br><ul><li>  usuario de la aplicaci√≥n: cualquier actor que realiza acciones con la aplicaci√≥n, puede ser una persona o un gui√≥n que realiza las instrucciones necesarias; <br></li><li>  aplicaci√≥n (en nuestro caso, utilizamos la aplicaci√≥n Badoo iOS instalada en el simulador de iOS); <br></li><li>  servidor: un actor que procesa las solicitudes de la aplicaci√≥n y env√≠a respuestas o notificaciones asincr√≥nicas sin una solicitud del cliente (en este caso, nos referimos a un servidor Badoo abstracto para simplificar la estructura); <br></li><li>  La App Store es un actor que es una "caja negra" para nosotros: no sabemos c√≥mo est√° organizada en su interior, pero sabemos su interfaz p√∫blica para procesar compras dentro de la aplicaci√≥n ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">marco StoreKit</a> ), y tambi√©n sabemos c√≥mo verificar los datos en un servidor Apple. <br></li></ul><br>  Veamos c√≥mo ocurre la compra.  Todo el proceso se puede ver en el diagrama: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kw/1l/tg/kw1ltgj7slrlftse7zykm-hrlec.png" width="600"></div><br>  <i><font color="gray">Figura 1. Esquema de pago en App Store</font></i> <br><br>  Describiremos paso a paso las principales acciones de los actores. <br><br>  1. El punto de partida es el estado de todos los actores antes de abrir la pantalla con una lista de productos. <br><br>  ¬øQu√© es esta pantalla y c√≥mo llegamos a ella? <br><br>  Supongamos que un usuario encuentra a una persona interesante, abre su perfil, escribe un mensaje y desea enviar un regalo.  Enviar un regalo es un servicio pago.  El usuario puede desplazar el perfil a la secci√≥n para enviar regalos o seleccionar inmediatamente un regalo del chat. <br><br>  Si el usuario selecciona un regalo y no tiene dinero en la cuenta, ver√° una lista de diferentes paquetes de pr√©stamos (Asistente de pagos) para la compra.  El punto de partida en nuestro ejemplo es una lista de regalos.  En el diagrama, podemos considerar este punto en cualquier pantalla antes de mostrar la lista de productos para la compra de pr√©stamos o suscripci√≥n. <br><br>  2. Abrir una lista de productos. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hn/9y/e-/hn9ye-ipwd_pblpxfgbawcpebok.jpeg" width="500"></div><br>  Estamos en el punto de partida, por ejemplo, en la lista de regalos.  El usuario selecciona uno de los regalos en la aplicaci√≥n.  La aplicaci√≥n realiza una solicitud a nuestro servidor para obtener una lista de posibles paquetes de pr√©stamos de identificaci√≥n de producto (100, 550, 2000, 5000).  El servidor devuelve esta lista a la aplicaci√≥n. <br><br>  A continuaci√≥n, la aplicaci√≥n env√≠a la lista de ID de producto recibida para su verificaci√≥n al actor de App Store (marco iOS del sistema StoreKit que va al servidor de Apple).  Devuelve una lista de productos probados y, como resultado, la aplicaci√≥n muestra al usuario la lista final de paquetes de pr√©stamos con √≠conos y precios. <br><br>  3. Selecci√≥n de productos y generaci√≥n de recibos. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ua/3j/jd/ua3jjdi5ifqqc0n6fiaqmg3elvq.jpeg" width="500"></div><br>  El usuario selecciona un producto pagado.  La App Store requiere comprobante de compra y autorizaci√≥n a trav√©s de Apple ID.  Despu√©s de una autorizaci√≥n de usuario exitosa, el control se transfiere a la aplicaci√≥n.  La aplicaci√≥n est√° esperando que se genere un recibo dentro de su propio paquete.  El usuario en este momento ve el sol, que bloquea la pantalla.  Ese recibo generado se puede entender utilizando el m√©todo appStoreReceiptURL de la clase <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bundle</a> .  Una vez que App Store genera el cheque, la aplicaci√≥n selecciona el cheque de su paquete y env√≠a una solicitud con el cheque y los datos del usuario al servidor Badoo. <br><br>  4. Comprobaci√≥n de la comprobaci√≥n en el servidor Badoo. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qw/4l/ag/qw4laggdbnz4zswxh-b6eopdk-y.jpeg" width="500"></div><br>  Tan pronto como el servidor Badoo recibe la verificaci√≥n y los datos del usuario, los env√≠a de vuelta al lado del servidor Apple para llevar a cabo el primer ciclo de verificaci√≥n.  Esta es una de las recomendaciones de Apple.  Luego, en este primer ciclo de verificaci√≥n, el servidor recibe informaci√≥n sobre el estado actual de la suscripci√≥n. <br><br>  5. Env√≠o de notificaciones push (notificaci√≥n push) desde el servidor. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yq/ne/ou/yqneoujlb2271__24hinousfjz8.jpeg" width="500"></div><br>  El servidor Badoo procesa nuevamente la informaci√≥n recibida despu√©s de la verificaci√≥n por parte de Apple y env√≠a a la aplicaci√≥n una respuesta junto con una notificaci√≥n push. <br><br>  6. Notificaci√≥n de inserci√≥n en la aplicaci√≥n. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mw/mx/vq/mwmxvqn6zutjpg45rmcq6tibudc.jpeg" width="500"></div><br>  Si se trataba de una compra de pr√©stamos, inmediatamente cambiar√° el saldo del usuario en la aplicaci√≥n y ver√° el regalo enviado en el chat.  Si se trata de una compra por suscripci√≥n, el usuario debe esperar la notificaci√≥n push final de que la suscripci√≥n est√° activada. <br><br><h3>  3. Determinaci√≥n de dependencias y bucle de prueba. </h3><br><br>  Para una mayor discusi√≥n, presentamos dos conceptos m√°s: la dependencia externa y el circuito de prueba. <br><br><h4>  Dependencia externa </h4><br>  Por dependencias externas nos referimos a cualquier interacci√≥n con un componente, que es para nosotros un "recuadro negro".  En este caso, la App Store act√∫a como un componente en forma de un marco de sistema iOS (StoreKit), con el que funciona nuestra aplicaci√≥n iOS, y un servidor Apple, donde van las solicitudes de verificaci√≥n. <br><br>  La gesti√≥n de estas dependencias en condiciones reales es imposible, la aplicaci√≥n se ve obligada a responder a las se√±ales de salida del cuadro negro (ver Fig. 2). <br><br>  Tenemos tres dependencias externas: <br><br><ol><li>  Comprobaci√≥n de productos StoreKit. <br></li><li>  Recibir y reemplazar un recibo de compra. <br></li><li>  Comprobaci√≥n de una comprobaci√≥n en un servidor Badoo. <br></li></ol><br><img src="https://habrastorage.org/webt/ix/dd/mr/ixddmrcv7pwgene4fw12269cfeg.jpeg"><br>  <i><font color="gray">Figura 2. Dependencias externas</font></i> <br><br><h4>  Circuito de prueba </h4><br>  Circuito de prueba: estas son secciones de la ruta que recorreremos y verificaremos durante el proceso de prueba. <br><br><img src="https://habrastorage.org/webt/26/m3/_u/26m3_uxzsdcrewtozcmgqihwbyu.jpeg"><br>  <i><font color="gray">Figura 3. Bucle de prueba</font></i> <br><br>  El objetivo de nuestro trabajo para eliminar las dependencias es construir un circuito de prueba que est√© lo m√°s cerca posible de la ruta real y le permita excluir todas las dependencias externas y transferir el control a su lado. <br><br>  Consideramos cada dependencia en secuencia. <br><br><h3>  4. Aislamiento de dependencias: implementaci√≥n t√©cnica </h3><br>  En nuestra empresa, para la implementaci√≥n de los pagos, se tom√≥ un concepto de APP, que se basa en la interfaz del Proveedor de pagos.  Esta es la interfaz principal para interactuar con el actor de App Store (StoreKit) dentro de nuestra aplicaci√≥n, que tiene dos m√©todos principales: <br><br><ol><li>  preparar es el m√©todo responsable de verificar los productos; <br></li><li>  makePayment es un m√©todo que procesa una compra en la aplicaci√≥n. <br></li></ol><br>  Todos los pagos en iOS se refactorizaron de acuerdo con este concepto, lo que nos permiti√≥ obtener un proveedor de pagos simulados de clase simple y conveniente.  Esta es la interfaz principal para interactuar con una copia conveniente del comportamiento de StoreKit dentro de nuestra aplicaci√≥n.  ¬øQu√© significa "copia conveniente"?  Este proveedor tiene simulacros de los m√©todos prepare y makePayment que hacen lo que queremos.  Veamos un ejemplo de piezas de c√≥digo, c√≥mo logramos integrar moki. <br><br><h4>  Dependencia No. 1.  Comprobaci√≥n de productos StoreKit </h4><br>  Para verificar la lista de productos, use la funci√≥n de preparaci√≥n, que devuelve una lista de productos verificados.  Podemos utilizar el simulacro en el que apagamos el cheque y devolvemos la lista entrante de productos como totalmente verificada.  Por lo tanto, se eliminar√° la dependencia. <br><br><img src="https://habrastorage.org/webt/nr/nd/xj/nrndxjbquf5uuddom1zw4pcwkky.jpeg"><br>  <i><font color="gray">Figura 4. El primer esquema de eliminaci√≥n de dependencias</font></i> <br><br>  En la parte superior de la arquitectura en nuestra aplicaci√≥n est√° el Proveedor de pagos.  Refleja la interfaz de un posible proveedor en la aplicaci√≥n.  El c√≥digo para implementar mok se puede encontrar en la clase Mock Payment Provider. <br><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MockPaymentProvider</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PaymentProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> receipt: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> storeKitTransactionID: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(products: [BMProduct])</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">BMProduct</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> products } ... }</code> </pre> <br>  <i><font color="gray">Listado 1. Verificaci√≥n de cliente simulado</font></i> <br><br>  En el proveedor de pagos simulados, podemos ver la implementaci√≥n del m√©todo de preparaci√≥n.  La magia de moka resulta ser muy simple: el m√©todo omiti√≥ la comprobaci√≥n de productos en el lado de StoreKit y simplemente devuelve una lista entrante de productos.  La implementaci√≥n real de prepare se ve as√≠: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(products: [BMProduct])</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">BMProduct</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> validatedProducts = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.productsSource.validate(products: products) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> validatedProducts }</code> </pre><br>  <i><font color="gray">Listado 2. Proveedor de pago de la tienda real</font></i> <br><br><h3>  Dependencia No. 2.  Recibir y reemplazar un recibo de compra </h3><br>  La segunda dependencia es un poco m√°s complicada: primero debemos eliminar la autorizaci√≥n para no mantener el grupo de cuentas de usuario y, de alguna manera, obtener el cheque en s√≠.  Simplemente podemos eliminar el formulario de autorizaci√≥n: <br><br><img src="https://habrastorage.org/webt/ir/zr/ak/irzrakxn_kx2ylzcdaudvux5pv4.jpeg"><br>  <i><font color="gray">Figura 5. Eliminar un formulario de autorizaci√≥n al hacer un pago</font></i> <br><br>  No es tan simple con un cheque.  Hay muchas preguntas: <br><br><ol><li>  ¬øC√≥mo obtener un recibo por adelantado del producto correcto? <br></li><li>  Si recibimos el cheque, ¬øcu√°ndo y c√≥mo adjuntarlo dentro de la aplicaci√≥n? <br></li></ol><br>  Aqu√≠ el actor "Usuario" tiene un nuevo rol: control de calidad.  Cuando ejecutamos la prueba, no solo podemos hacer clic en los botones de la interfaz, sino tambi√©n llamar a los m√©todos API del marco de prueba (m√©todos que simulan acciones del usuario) y a los servicios REST API (m√©todos que pueden hacer magia desde el servicio interno de Badoo).  En Badoo utilizamos una herramienta API de control de calidad muy potente (puede encontrar todas sus capacidades en el enlace: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://vimeo.com/116931200</a> ).  Es √©l quien nos ayuda en las pruebas y realiza una comprobaci√≥n del producto correcto en el lado del servidor de Badoo.  El servidor Badoo es el mejor lugar para generar cheques: hay cifrado y descifrado del cheque, por lo que el servidor sabe todo acerca de esta estructura de datos. <br><br>  Despu√©s de recibir un cheque falso, podemos pasarlo por una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">puerta trasera</a> en el lado de la aplicaci√≥n.  A continuaci√≥n, la aplicaci√≥n enviar√° un cheque falso junto con los datos del usuario a nuestro servidor. <br><br><img src="https://habrastorage.org/webt/uu/h5/03/uuh503gnoqehjqguhzjhydujvs8.jpeg"><br>  <i><font color="gray">Figura 6. Esquema de recepci√≥n</font></i> <br><br>  ¬øC√≥mo se hizo esto t√©cnicamente posible? <br><br>  1. Para configurar un cheque falso en la aplicaci√≥n, pudimos usar una puerta trasera que guard√≥ el cheque falso en el campo de recibo MockPaymentProvider: <br><br><pre> <code class="swift hljs">#<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-type"><span class="hljs-type">BUILD_FOR_AUTOMATION</span></span> <span class="hljs-meta"><span class="hljs-meta">@objc</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BadooAppDelegate</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@objc</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMockPurchaseReceipt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> receipt: String?)</span></span></span></span> { <span class="hljs-type"><span class="hljs-type">PaymentProvidersFactory</span></span>.useMockPaymentProviderForITunesPayments = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-type"><span class="hljs-type">MockPaymentProvider</span></span>.receipt = receipt } ... } #endif</code> </pre> <br>  <i><font color="gray">Listado 3. Puerta trasera de verificaci√≥n falsa</font></i> <br><br>  2. La aplicaci√≥n pudo tomar nuestro cheque gracias a MockPaymentProvider, en el que utilizamos el simulacro makePayment y el cheque guardado en MockPaymentProvider.receipt: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MockPaymentProvider</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PaymentProvider</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makePayment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> transaction: BPDPaymentTransactionContext)</span></span></span></span> { ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> receiptData = <span class="hljs-type"><span class="hljs-type">MockPaymentProvider</span></span>.receipt?.data(using: .utf8) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">BPDPurchaseReceiptRequest</span></span>(...) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.networkService.send(request, completion: { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] (<span class="hljs-number"><span class="hljs-number">_</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sSelf = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> receipt = request.responsePayload() { sSelf.delegate?.paymentProvider(sSelf, didReceiveReceipt: receipt) } }) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.delegate?.paymentProvider(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didFailTransaction: transaction) } } }</code> </pre> <br>  <i><font color="gray">Listado 4. Llamar a un moka de procesamiento de compras con un cheque falso</font></i> <br><br>  3. Obtener un cheque falso <br><br>  Para obtener una verificaci√≥n falsa, utilizamos el m√©todo en el servidor (ver Listado 5).  Se necesita una matriz predeterminada con datos para generar datos de verificaci√≥n y agrega los datos necesarios para un producto en particular. <br><br><pre> <code class="php hljs">$new_receipt_model = array_replace_recursive( <span class="hljs-comment"><span class="hljs-comment">//       $this-&gt;getDefaultModel(), //       //,      $this-&gt;enrichModelUsingSubscription($nr), //        $this-&gt;enrichModelUsingInput($input) ); //  $new_receipt = $this-&gt;signReceipt( json_encode($new_receipt_model, true), $new_receipt_model );</span></span></code> </pre><br>  <i><font color="gray">Listado 5. Parte del servidor de la generaci√≥n de cheques</font></i> <br><br>  Para repetir la estructura de una verificaci√≥n real, la verificaci√≥n personalizada enviada por la aplicaci√≥n debe cifrarse con un certificado.  Utilizamos nuestro certificado de trabajo en lugar del certificado de Apple. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">signReceipt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($receipt, $response)</span></span></span><span class="hljs-function">  </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     base64 $receipt = 'Subject: ' . base64_encode(json_encode($response)) . PHP_EOL . PHP_EOL . $receipt; file_put_contents($receipt_file, $receipt); ... //    $sign_result = openssl_pkcs7_sign( $receipt_file, $signed_receipt_file, 'file://'.$path_cert, 'file://'.$path_key, [], PKCS7_BINARY); ... //  $signed_content_with_headers = file_get_contents($signed_receipt_file); list($headers, $signed_content) = explode(PHP_EOL . PHP_EOL, $signed_content_with_headers); //  return str_replace(["\r\n", "\r", "\n"], '', $signed_content); }</span></span></code> </pre><br>  <i><font color="gray">Listado 6. M√©todo para firmar un cheque con un certificado</font></i> <br><br>  4. Como resultado, en la prueba obtenemos: <br><br><pre> <code class="ruby hljs">(<span class="hljs-regexp"><span class="hljs-regexp">/       "((\d+) |  (\d+) ?/</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|service_type|</span></span> <span class="hljs-comment"><span class="hljs-comment">#    service_details = parse_options(service_type) #  QA API (  Badoo) receipt = QaApi::Billing.order_get_app_store_receipt(service_details) #   Backdoors.set_fake_receipt(receipt) end</span></span></code> </pre><br>  <i><font color="gray">Listado 7. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Paso de</a> prueba de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pepinillo</a> para el marco de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pepino</a></font></i> <br><br><h3>  Dependencia No. 3.  Comprobaci√≥n de una comprobaci√≥n en un servidor Badoo </h3><br>  Para eliminar la tercera dependencia, debe deshacerse de la verificaci√≥n de verificaci√≥n en el servidor.  Es importante recordar que la verificaci√≥n se realiza en dos etapas.  En la primera etapa, la verificaci√≥n se autentica en base a firmas y certificados.  En el segundo, el cheque se env√≠a a la App Store.  En caso de validaci√≥n exitosa en esta etapa, recibiremos un cheque descifrado que puede procesarse. <br><br><img src="https://habrastorage.org/webt/pd/9g/p_/pd9gp_uz1kjnsb9rsk9weczdngw.jpeg"><br>  <i><font color="gray">Figura 7. Eliminar la verificaci√≥n del servidor</font></i> <br><br>  Primero, el servidor realiza la verificaci√≥n inicial de la verificaci√≥n en el m√©todo generateReceiptByCert de la clase primaria.  Esto verifica la firma con el certificado de App Store.  En el caso de una verificaci√≥n falsa, esta verificaci√≥n fallar√° porque est√° firmada por nuestro certificado, y llamaremos al m√©todo para la verificaci√≥n con el certificado local verificarReceiptByLocalCert.  En este m√©todo, intentaremos descifrar la verificaci√≥n con un certificado local y, si tiene √©xito, colocaremos el resultado de descifrado en el campo interno local_receipt de la clase secundaria (m√©todo addLocallyVerifiedReceipt). <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EngineTest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Engine</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">verifyReceiptByCert</span></span></span><span class="hljs-class">($</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">receipt</span></span></span><span class="hljs-class">)  </span></span>{ $result = <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>::verifyReceiptByCert($receipt); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($result === <span class="hljs-number"><span class="hljs-number">-1</span></span> || <span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($result)) { $result = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;verifyReceiptByLocalCert($receipt); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verifyReceiptByLocalCert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($receipt)</span></span></span><span class="hljs-function"> </span></span>{ $receipt_file = tempnam(sys_get_temp_dir(), <span class="hljs-string"><span class="hljs-string">'rcp'</span></span>); file_put_contents($receipt_file, base64_decode($receipt)); $result = openssl_pkcs7_verify($receipt_file, PKCS7_BINARY, <span class="hljs-string"><span class="hljs-string">'/dev/null'</span></span>, [$DIR]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($result) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;addLocallyVerifiedReceipt($receipt, base64_decode($response)); } unlink($receipt_file); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $result; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Engine</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">verifyReceiptByCert</span></span></span><span class="hljs-class">($</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">receipt</span></span></span><span class="hljs-class">) </span></span>{ $receipt_file = tempnam(sys_get_temp_dir(), <span class="hljs-string"><span class="hljs-string">'rcp'</span></span>); file_put_contents($receipt_file, base64_decode($receipt)); $result = openssl_pkcs7_verify($receipt_file, PKCS7_BINARY, <span class="hljs-string"><span class="hljs-string">'/dev/null'</span></span>, [$DIR]); unlink($receipt_file); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $result; }</code> </pre><br>  <i><font color="gray">Listado 8. Verificaci√≥n inicial</font></i> <br><br>  Durante la verificaci√≥n secundaria (generateReceipt), obtenemos el valor del campo local_receipt de la clase secundaria getLocallyVerifiedReceipt.  Si no est√° vac√≠o, usamos su valor como resultado de la verificaci√≥n. <br><br>  Si el campo est√° vac√≠o, llamamos a la verificaci√≥n secundaria desde la clase <i>padre</i> ( <i>parent</i> :: verificarReceipt).  All√≠ hacemos una solicitud a la tienda de aplicaciones para su verificaci√≥n por su parte.  El resultado de la verificaci√≥n en ambos casos es una verificaci√≥n descifrada. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EngineTest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Engine</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">verifyReceipt</span></span></span><span class="hljs-class">($</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">receipt_encoded</span></span></span><span class="hljs-class">, $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared_secret</span></span></span><span class="hljs-class">, $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">env</span></span></span><span class="hljs-class">) </span></span>{ $response = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;getLocallyVerifiedReceipt($receipt_encoded); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($response)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> json_decode($response, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>::verifyReceipt($receipt_encoded, $shared_secret, $env); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Engine</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">verifyReceipt</span></span></span><span class="hljs-class">($</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">receipt_encoded</span></span></span><span class="hljs-class">, $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared_secret</span></span></span><span class="hljs-class">, $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">env</span></span></span><span class="hljs-class">) </span></span>{ $response = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_sendRequest($receipt_encoded, $shared_secret, $env); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $response; }</code> </pre> <br>  <i><font color="gray">Listado 9. Verificaci√≥n secundaria</font></i> <br><br><h3>  5. Prueba de video: compra de pr√©stamos y suscripciones </h3><br><h4>  Prueba n√∫mero 1.  Compra de suscripci√≥n </h4><br><div class="scrollable-table"><table><tbody><tr><td>  Cuando <br></td><td>  Me conecto a la aplicaci√≥n como un nuevo usuario con una foto <br></td></tr><tr><td>  Y <br></td><td>  Genero un nuevo cheque de facturaci√≥n de suscripci√≥n de un mes <br></td></tr><tr><td>  Y <br></td><td>  Voy a mi perfil <br></td></tr><tr><td>  Entonces <br></td><td>  Me aseguro de que la suscripci√≥n est√© deshabilitada <br></td></tr><tr><td>  Cuando <br></td><td>  Abro la lista de productos <br></td></tr><tr><td>  Y <br></td><td>  Compro un paquete de suscripci√≥n de un mes <br></td></tr><tr><td>  Entonces <br></td><td>  Verifico la notificaci√≥n de compra exitosa <br></td></tr><tr><td>  Y <br></td><td>  Me aseguro de que la suscripci√≥n est√© activada <br></td></tr></tbody></table></div><br>  Video de prueba: <br><br><img src="https://habrastorage.org/webt/xc/ut/ag/xcutagbl8qmu9wzgva0zop2xqg0.gif"><br><h4>  Prueba n√∫mero 2.  Comprar pr√©stamos y enviar un regalo </h4><br><div class="scrollable-table"><table><tbody><tr><td>  Cuando <br></td><td>  Me conecto a la aplicaci√≥n como un nuevo usuario con una foto <br></td></tr><tr><td>  Y <br></td><td>  Agrego diez cr√©ditos a mi perfil <br></td></tr><tr><td>  Y <br></td><td>  Genero una nueva verificaci√≥n de cr√©dito por 550 cr√©ditos <br></td></tr><tr><td>  Y <br></td><td>  Creo un nuevo usuario Leela <br></td></tr><tr><td>  Y <br></td><td>  Leela vot√≥ S√≠ por m√≠ <br></td></tr><tr><td>  Y <br></td><td>  Voy a personas cercanas y abro un perfil de Leela <br></td></tr><tr><td>  Y <br></td><td>  Yo voto "S√≠" por Leela <br></td></tr><tr><td>  Entonces <br></td><td>  Reviso la p√°gina del partido <br></td></tr><tr><td>  Cuando <br></td><td>  Elijo enviar un regalo regular <br></td></tr><tr><td>  Entonces <br></td><td>  Reviso la pantalla de pago con una lista de paquetes <br></td></tr><tr><td>  Cuando <br></td><td>  Elijo comprar 550 cr√©ditos <br></td></tr><tr><td>  Entonces <br></td><td>  Verifico la notificaci√≥n de compra exitosa <br></td></tr><tr><td>  Y <br></td><td>  Me aseguro de que Leela recibi√≥ un regalo de chat <br></td></tr></tbody></table></div><br><br>  Video de prueba: <br><br><img src="https://habrastorage.org/webt/jb/dl/oj/jbdlojncgj656usnr5bsylaese4.gif"><br><br><h2>  Valoraci√≥n de la decisi√≥n: principales riesgos </h2><br>  Eliminar las dependencias externas conlleva ciertos riesgos. <br><br>  1. Configuraci√≥n incorrecta. <br><br>  Como la verificaci√≥n no est√° de nuestro lado, podemos configurar nuestros productos incorrectamente en el lado de Apple.  Para protegernos del error, escribimos una prueba de unidad del lado del servidor separada, que verifica que todos los productos que comenzamos en el lado de Apple coinciden con los productos que tenemos en nuestra configuraci√≥n. <br><br>  2. Casos l√≠mite. <br><br>  Por ejemplo, cuando el pago se completa por completo, el usuario recibe una notificaci√≥n de que ha completado, pero nuestra aplicaci√≥n no puede encontrar el cheque que debe falsificarse como resultado de realizar este pago.  El riesgo radica en el hecho de que nosotros mismos adjuntamos el cheque con la ayuda de una puerta trasera, y naturalmente no podemos rastrear tal caso.  Para compensar de alguna manera este riesgo, realizamos controles de extremo a extremo utilizando la caja de arena o un pago real despu√©s del lanzamiento. <br><br>  3. Falso o fraude injusto. <br><br>  Despu√©s de leer este art√≠culo, puede pensar que, dado que Badoo usa cheques falsos, puede adjuntarnos algo falso y usar el servicio de forma gratuita.  Para que este riesgo no se materialice, firmamos todo con nuestro propio certificado y limitamos el uso de pruebas falsas y falsas a pruebas funcionales que se ejecutan solo en nuestro entorno de desarrollo. <br><br>  4. Cambie el formato del cheque. <br><br>  Este es el riesgo m√°s grave.  Es posible cambiar el formato de un cheque cuando Apple cambia algo sin avisarnos.  Tuvimos ese caso: al cambiar a iOS 11, el formato del cheque cambi√≥ por completo.  Generamos un cheque falso en nuestro servidor y lo usamos en la prueba.  Todo fue perfecto con nosotros: todos los campos est√°n en su lugar, todo es maravilloso, todo se est√° procesando.  Pero cuando cambiamos al sistema real, nada funcion√≥.  Los campos que fueron significativos en el cheque simplemente dejaron de existir. <br><br>  ¬øC√≥mo compensar este riesgo?  En primer lugar, no excluimos la posibilidad de realizar pruebas de extremo a extremo del sandbox antes del lanzamiento y el pago real despu√©s del lanzamiento.  Ahora estamos en la fase activa de un proyecto para verificar las notificaciones, cuando tratamos de clasificar todos los cheques que recibimos de la producci√≥n en funci√≥n de si entendemos qu√© es o no.  Si la respuesta es no, entonces comenzamos a procesar todo manualmente, ver qu√© ha cambiado, qu√© est√° mal, qu√© hay que cambiar en nuestro sistema. <br><div class="scrollable-table"><table><tbody><tr><td>  Riesgo <br></td><td>  Raz√≥n <br></td><td>  C√≥mo compensar <br></td></tr><tr><td>  configuraci√≥n incorrecta <br></td><td>  borrar cheque <br></td><td>  prueba unitaria en el servidor <br></td></tr><tr><td>  casos extremos <br>  (cheque no entregado) <br></td><td>  usar puerta trasera <br></td><td>  Cheques E2E (sandbox y pago real) <br></td></tr><tr><td>  fraude fraudulento, fraude <br></td><td>  notificaci√≥n y generaci√≥n de cheques en el servidor <br></td><td>  certificado propio <br></td></tr><tr><td>  cambiar formato de cheque <br></td><td>  notificaci√≥n y generaci√≥n de cheques en el servidor <br></td><td>  verificaci√≥n de notificaciones reales y verificaci√≥n del producto (nuevo proyecto), <br>  Cheques E2E (sandbox y pago real) <br></td></tr></tbody></table></div><br><h2>  Resultado </h2><br><br>  Considere las principales ventajas que pudimos obtener como resultado de aplicar el m√©todo moki y el objeto falso. <br><br><h4>  Automatizaci√≥n econ√≥mica, r√°pida y estable de servicios pagos en iOS </h4><br>  Junto con el equipo de prueba manual de iOS (agradecimiento especial a Colin Chan), pudimos escribir m√°s de 150 pruebas autom√°ticas para pagos.  Esta es una cantidad bastante grande de cobertura para un √°rea de la aplicaci√≥n. <br><br>  Gracias a la paralelizaci√≥n, podemos obtener el resultado en solo 15-20 minutos en cualquier rama del desarrollador del cliente iOS o desarrollador del servidor de facturaci√≥n.  Antes de la automatizaci√≥n, la prueba manual de esta √°rea por una persona tom√≥ ocho horas. <br><br>  Tambi√©n podemos probar la gran mayor√≠a de los casos de prueba configurando el proveedor de pagos simulados a trav√©s de moki de la manera que necesitamos.  Con la ayuda de mooks, aprendimos c√≥mo desactivar la verificaci√≥n del producto y simular casos cuando la verificaci√≥n se realiza parcialmente.  Por lo tanto, abrimos casos que antes no pod√≠amos probar en principio. <br><br><h4>  Regresi√≥n funcional en el desarrollo de nuevas caracter√≠sticas. </h4><br>  La automatizaci√≥n funcion√≥ muy bien en aquellos casos en que el desarrollador en el proceso de trabajar en una nueva caracter√≠stica afectaba la funcionalidad anterior.  Tuvimos un ejemplo cuando un desarrollador hizo una caracter√≠stica compleja con el almacenamiento en cach√© y ejecut√≥ nuestras pruebas autom√°ticas.  Algunos de ellos cayeron en error.  Lo vio y lo arregl√≥.  Luego reinici√≥ las pruebas autom√°ticas nuevamente, y nuevamente, algo cay√≥.  Como resultado, hizo una serie de iteraciones hasta el momento en que todo comenz√≥ a funcionar normalmente en el lado de la aplicaci√≥n. <br><br><h4>  Regresi√≥n funcional en refactorizaci√≥n de pagos </h4><br>  Quiz√°s la automatizaci√≥n m√°s exitosa y eficiente que sea posible ocurra en el campo de la refactorizaci√≥n de c√≥digo.  En este caso, solo cambia la implementaci√≥n interna; no es necesario cambiar el c√≥digo de la prueba autom√°tica.  La interfaz de usuario no cambia de ninguna manera, y las pruebas autom√°ticas se pueden conducir de manera eficiente. <br><br><h4>  Prueba de caracter√≠sticas experimentales de Apple: per√≠odo de gracia </h4><br>  Un sistema similar es completamente intercambiable cuando prueba nuevas integraciones que a√∫n no est√°n implementadas en el sandbox.  As√≠ fue con el per√≠odo de gracia.  Esta funcionalidad no est√° en el sandbox.  El per√≠odo de gracia en Apple a√∫n no est√° disponible para todos.  Este es un proyecto piloto que Badoo est√° implementando con Apple.  Para verificar con un per√≠odo de gracia, necesit√°bamos agregar aqu√≠ un fragmento de c√≥digo JSON: <br><br><pre> <code class="json hljs">pending_renewal_info:[ { expiration_intent: <span class="hljs-number"><span class="hljs-number">2</span></span> grace_period_expires_date: <span class="hljs-number"><span class="hljs-number">2019</span></span><span class="hljs-number"><span class="hljs-number">-04</span></span><span class="hljs-number"><span class="hljs-number">-25</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">50</span></span>:<span class="hljs-number"><span class="hljs-number">57</span></span> Etc/GMT auto_renew_product_id: badoo.productId original_transaction_id: <span class="hljs-number"><span class="hljs-number">560000361869085</span></span> is_in_billing_retry_period: <span class="hljs-number"><span class="hljs-number">1</span></span> grace_period_expires_date_pst: <span class="hljs-number"><span class="hljs-number">2019</span></span><span class="hljs-number"><span class="hljs-number">-04</span></span><span class="hljs-number"><span class="hljs-number">-25</span></span> <span class="hljs-number"><span class="hljs-number">08</span></span>:<span class="hljs-number"><span class="hljs-number">50</span></span>:<span class="hljs-number"><span class="hljs-number">57</span></span> America/Los_Angeles product_id: badoo.productId grace_period_expires_date_ms: <span class="hljs-number"><span class="hljs-number">1556207457000</span></span> auto_renew_status: <span class="hljs-number"><span class="hljs-number">1</span></span> }]</code> </pre><br>  <i><font color="gray">Listado 10. Per√≠odo de gracia para una suscripci√≥n</font></i> <br><br>  Lo hicimos muy f√°cilmente en solo unos segundos.  En nuestro sistema, pudimos probar nuestra reacci√≥n a una nueva caracter√≠stica.  Ahora estamos ejecutando esta funcionalidad en el producto. <br><br><h4>  Pruebas de calidad del producto en m√©todos de composici√≥n. </h4><br>  Como resultado de nuestra investigaci√≥n, pudimos describir un m√©todo que elimina el ruido de las dependencias externas.  Esto ayud√≥ a los desarrolladores de clientes en el proceso de desarrollo de caracter√≠sticas a encontrar errores en las primeras etapas. <br><br>  Pero no piense que pudimos probar todo con este m√©todo.  Para probar todo, es mejor usar una composici√≥n de m√©todos: probar con una tarjeta real en el producto, probar en el sandbox, el m√©todo de simulacros y objetos falsos, pruebas de unidad e integraci√≥n.  Recuerde el equilibrio de la pir√°mide de prueba y no intente resolver todos los problemas con un m√©todo.  Esto puede llevar a una automatizaci√≥n triste en el sandbox, a pruebas manuales tristes con una tarjeta real de todos los casos y muchos otros errores graves en el lugar exacto donde su apariencia es m√°s dolorosa. <br><br><h2>  Conclusi√≥n </h2><br>  Como resultado de nuestra investigaci√≥n, obtuvimos un m√©todo econ√≥mico, r√°pido y estable de probar no solo los servicios pagos en iOS, sino tambi√©n cualquier componente que est√© integrado en la aplicaci√≥n como un "recuadro negro".  Ahora en Badoo estamos implementando este m√©todo para probar en proveedores pagos de Android (Global Charge, Boku, Centili) que tienen entornos limitados inestables o cualquier otra restricci√≥n.  Tambi√©n utilizamos el m√©todo moki para probar publicidad, transmisi√≥n y geolocalizaci√≥n. <br><br>  Vale la pena decir que el proceso de introducci√≥n de un nuevo m√©todo no fue r√°pido.  Tuve que negociar con cuatro equipos: iOS QA, iOS Dev, Billing QA, Billing Dev.  No todos quer√≠an cambiar a un nuevo m√©todo, temiendo riesgos.  A veces era un seguimiento dogm√°tico: durante muchos a√±os probamos en el sandbox, y la fuerza principal que pod√≠a destruir el dogma era el deseo de los probadores de facturaci√≥n y la plataforma iOS para cambiar la situaci√≥n y deshacerse del tormento.  M√°s tarde, los desarrolladores se dieron cuenta de las ventajas de este m√©todo como diagn√≥sticos precisos (no pudimos encontrar errores en el sandbox, sino errores de nuestro cliente o servidor), flexibilidad en la configuraci√≥n del componente (pudimos probar f√°cilmente los casos negativos en el nivel de integraci√≥n) y, por supuesto, la respuesta fue 30 minutos en una rama con c√≥digo desarrollado. <br><br>  Muchas gracias a todos los que han le√≠do hasta el final.  Muchas gracias a todos los que ayudaron y participaron en este proyecto.  Un agradecimiento especial a estas personas: <br><br><ul><li>  Peter Kolpashchikov es un desarrollador de iOS que ayud√≥ a hacer moki en el lado del cliente y desarroll√≥ un concepto PPP; <br></li><li>  Vladimir Solodov - Facturaci√≥n de control de calidad, que ayud√≥ con la API de control de calidad para generar cheques falsos y pagar desde el servidor de facturaci√≥n; <br></li><li>  Maxim Filatov y Vasily Stepanov - Equipo de desarrollo de facturaci√≥n, que ayudaron con el c√≥digo del servidor de facturaci√≥n; <br></li><li>  iOS Dev Team: desarrolladores que pudieron refactorizar nuestros pagos en un nuevo concepto, haciendo posible el uso de mokas; <br></li><li>  iOS QA Team es un equipo de prueba incre√≠ble que escribi√≥ un mont√≥n de autotests; <br></li><li>  Equipo de control de calidad de facturaci√≥n: evaluadores que ayudaron a investigar problemas. <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/460667/">https://habr.com/ru/post/460667/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460651/index.html">Reuni√≥n de la Society of Anonymous Testers: TMS, monitoreo de monitoreo, evaluaci√≥n de calidad de b√∫squeda y pruebas nativas de iOS</a></li>
<li><a href="../460655/index.html">C√≥mo romp√≠ Telegram</a></li>
<li><a href="../460659/index.html">Usando tuber√≠as para pivotar</a></li>
<li><a href="../460661/index.html">Todo lo que necesitas saber sobre Node.js</a></li>
<li><a href="../460665/index.html">Preguntas frecuentes preliminares: ¬øPor qu√© los est√°ndares C ++ salen cada tres a√±os?</a></li>
<li><a href="../460669/index.html">C√≥mo garantizar la seguridad del desarrollo, ahorrando tiempo y nervios</a></li>
<li><a href="../460671/index.html">Propiedad y endeudamiento en D</a></li>
<li><a href="../460673/index.html">Exponer la magia de DiffUtil</a></li>
<li><a href="../460675/index.html">Extracci√≥n de datos de aprendizaje autom√°tico</a></li>
<li><a href="../460683/index.html">Laravel Event Projector y Event Generation Concept</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>