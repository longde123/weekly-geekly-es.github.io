<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐉 👩🏾‍🤝‍👩🏽 🧛🏿 Quando "Zoë"! == "Zoë", ou por que você precisa normalizar seqüências de caracteres Unicode 🤨 🤳🏽 ❔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Já ouviu falar da normalização Unicode? Você não está sozinho. Mas todo mundo precisa saber sobre isso. A normalização pode poupar muitos problemas. M...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Quando "Zoë"! == "Zoë", ou por que você precisa normalizar seqüências de caracteres Unicode</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/445274/">  Já ouviu falar da normalização Unicode?  Você não está sozinho.  Mas todo mundo precisa saber sobre isso.  A normalização pode poupar muitos problemas.  Mais cedo ou mais tarde, algo semelhante ao mostrado na figura a seguir acontece com qualquer desenvolvedor. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aed/667/54c/aed66754c254c8eb6c077d2a418f1db6.png"></div>  <i><font color="#999999">Zoë não é Zoë</font></i> <br><a name="habracut"></a><br>  E isso, a propósito, não é um exemplo de outro JavaScript <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">estranho</a> .  O autor do material, cuja tradução publicamos hoje, diz que pode mostrar como o mesmo problema se manifesta ao usar quase todas as linguagens de programação existentes.  Em particular, estamos falando sobre Python, Go e até scripts de shell.  Como lidar com isso? <br><br><h2>  <font color="#3AC1EF">Antecedentes</font> </h2><br>  Encontrei o problema Unicode pela primeira vez há muitos anos, quando escrevi um aplicativo (no Objective-C) que importava uma lista de contatos do catálogo de endereços do usuário e de suas redes sociais, após o que eliminei duplicatas.  Em certas situações, algumas pessoas estão na lista duas vezes.  Isso aconteceu devido ao fato de seus nomes, de acordo com o programa, não serem da mesma string. <br><br>  Embora no exemplo acima as duas linhas pareçam exatamente iguais, da maneira como são apresentadas no sistema, os bytes em que são armazenados no disco diferem.  No primeiro nome, <code>"Zoë"</code> o caractere ë (e com trema) representa um único ponto de código Unicode.  No segundo caso, estamos lidando com a decomposição, com a abordagem de representar caracteres usando vários caracteres.  Se você, no seu aplicativo, trabalha com seqüências de caracteres Unicode, precisa considerar o fato de que os mesmos caracteres podem ser representados de maneiras diferentes. <br><br><h2>  <font color="#3AC1EF">Como chegamos ao emoji: em poucas palavras sobre a codificação de caracteres</font> </h2><br>  Os computadores trabalham com bytes, que são apenas números.  Para poder processar textos em computadores, as pessoas concordaram com a correspondência de caracteres e números e chegaram a acordos sobre a aparência da representação visual dos caracteres. <br><br>  O primeiro desses acordos foi representado pela codificação ASCII (American Standard Code for Information Interchange).  Essa codificação usava 7 bits e poderia representar 128 caracteres, incluindo o alfabeto latino (letras maiúsculas e minúsculas), números e sinais de pontuação básicos.  O ASCII também incluiu muitos caracteres "não imprimíveis", como alimentação de linha, guias, retornos de carro e outros.  Por exemplo, em ASCII, a letra latina M (maiúscula m) é codificada como 77 (4D em notação hexadecimal). <br><br>  O problema com o ASCII é que, embora 128 caracteres possam ser suficientes para representar todos os caracteres que as pessoas que trabalham com textos em inglês costumam usar, esse número de caracteres não é suficiente para representar textos em outros idiomas e vários caracteres especiais, como emojis. <br><br>  A solução para esse problema foi a adoção do padrão Unicode, que visava a possibilidade de representar cada caractere usado em todos os textos modernos e antigos, incluindo caracteres como emojis.  Por exemplo, no padrão Unicode 12.0 mais recente, existem mais de 137.000 caracteres. <br><br>  O padrão Unicode pode ser implementado usando uma variedade de métodos de codificação de caracteres.  Os mais comuns são UTF-8 e UTF-16.  Note-se que no espaço da web o mais comum é o padrão para codificação de textos UTF-8. <br><br>  O padrão UTF-8 usa 1 a 4 bytes para representar caracteres.  UTF-8 é um superconjunto de ASCII, portanto, seus primeiros 128 caracteres correspondem aos caracteres representados na tabela de códigos ASCII.  O padrão UTF-16, por outro lado, usa 2 a 4 bytes para representar 1 caractere. <br><br>  Por que existem dois padrões?  O fato é que textos em idiomas ocidentais geralmente são codificados com mais eficiência usando o padrão UTF-8 (já que a maioria dos caracteres desses textos pode ser representada como códigos de tamanho de 1 byte).  Se falamos sobre idiomas orientais, podemos dizer que os arquivos que armazenam textos escritos nesses idiomas geralmente ficam menos quando se usa o UTF-16. <br><br><h2>  <font color="#3AC1EF">Pontos de código Unicode e codificação de caracteres</font> </h2><br>  Cada caractere no padrão Unicode recebe um número de identificação chamado de ponto de código.  Por exemplo, um emoji de ponto de código <img src="https://habrastorage.org/webt/j9/wk/dp/j9wkdpjar2e6a4ixmkb6oo4upii.png">  é <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">U + 1F436</a> . <br><br>  Ao codificar este ícone, ele pode ser representado como várias seqüências de bytes: <br><br><ul><li>  UTF-8: 4 bytes, <code>0xF0 0x9F 0x90 0xB6</code> </li><li>  UTF-16: 4 bytes, <code>0xD83D 0xDC36</code> </li></ul><br>  No código JavaScript abaixo, todos os três comandos imprimem o mesmo caractere no console do navegador. <br><br> <code>//         <br> console.log(' <img src="https://habrastorage.org/webt/j9/wk/dp/j9wkdpjar2e6a4ixmkb6oo4upii.png"> ') // =&gt; <img src="https://habrastorage.org/webt/j9/wk/dp/j9wkdpjar2e6a4ixmkb6oo4upii.png"> <br> //     Unicode (ES2015+) <br> console.log('\u{1F436}') // =&gt; <img src="https://habrastorage.org/webt/j9/wk/dp/j9wkdpjar2e6a4ixmkb6oo4upii.png"> <br> //        UTF-16 <br> //      ( 2  ) <br> console.log('\uD83D\uDC36') // =&gt; <img src="https://habrastorage.org/webt/j9/wk/dp/j9wkdpjar2e6a4ixmkb6oo4upii.png"></code> <br><br>  Os mecanismos internos da maioria dos intérpretes JavaScript (incluindo Node.js e navegadores modernos) usam UTF-16.  Isso significa que o ícone do cão que estamos considerando é armazenado usando duas unidades de código UTF-16 (16 bits cada).  Portanto, o que o seguinte código gera não deve parecer incompreensível para você: <br><br> <code>console.log(' <img src="https://habrastorage.org/webt/j9/wk/dp/j9wkdpjar2e6a4ixmkb6oo4upii.png"> '.length) // =&gt; 2</code> <br> <br><h2>  <font color="#3AC1EF">Combinação de caracteres</font> </h2><br>  Agora, voltemos ao ponto em que começamos, a saber, por que os símbolos que parecem iguais para uma pessoa têm uma representação interna diferente. <br><br>  Alguns caracteres Unicode foram projetados para modificar outros caracteres.  Eles são chamados de caracteres combinados.  Eles se aplicam aos caracteres base, por exemplo: <br><br><ul><li> <code>n + ˜ = ñ</code> </li> <li> <code>u + ¨ = ü</code> </li> <li> <code>e + ´ = é</code> </li> </ul><br>  Como você pode ver no exemplo anterior, caracteres combináveis ​​permitem adicionar diacríticos aos caracteres base.  Mas os recursos de transformação de caracteres do Unicode não se limitam a isso.  Por exemplo, algumas seqüências de caracteres podem ser representadas como ligaduras (para que ae possa se transformar em æ). <br><br>  O problema é que caracteres especiais podem ser representados de várias maneiras. <br><br>  Por exemplo, a letra é pode ser representada de duas maneiras: <br><br><ul><li>  Usando um único ponto de código <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">U + 00E9</a> . </li><li>  Usando uma combinação da letra e com o sinal agudo, ou seja, usando dois pontos de código - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">U + 0065</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">U + 0301</a> . </li></ul><br>  Os caracteres resultantes do uso de qualquer uma dessas maneiras de representar a letra é terão a mesma aparência, mas, quando comparados, acontece que os caracteres são diferentes.  As linhas que os contêm terão comprimentos diferentes.  Você pode verificar isso executando o seguinte código no console do navegador. <br><br><pre> <code class="plaintext hljs">console.log('\u00e9') // =&gt; é console.log('\u0065\u0301') // =&gt; é console.log('\u00e9' == '\u0065\u0301') // =&gt; false console.log('\u00e9'.length) // =&gt; 1 console.log('\u0065\u0301'.length) // =&gt; 2</code> </pre> <br>  Isso pode levar a erros inesperados.  Por exemplo, eles podem ser expressos no fato de que o programa, por razões desconhecidas, não é capaz de encontrar algumas entradas no banco de dados, em que o usuário, digitando a senha correta, não pode efetuar login no sistema. <br><br><h2>  <font color="#3AC1EF">Normalização de linha</font> </h2><br>  Os problemas acima têm uma solução simples, que consiste em normalizar as strings, trazendo-as para a "representação canônica". <br><br>  Existem quatro formas padrão (algoritmos) de normalização: <br><br><ul><li>  NFC: Normalização da composição canônica. </li><li>  NFD: Normalização do formulário Decomposição canônica. </li><li>  NFKC: composição de compatibilidade do formulário de normalização. </li><li>  NFKD: decomposição de compatibilidade do formulário de normalização. </li></ul><br>  A forma de normalização mais usada é a NFC.  Ao usar esse algoritmo, todos os caracteres são decompostos primeiro, após o que todas as seqüências combinadas são recompostas na ordem definida pelo padrão.  Para uso prático, você pode escolher qualquer forma.  O principal é aplicá-lo de forma consistente.  Como resultado, o recebimento dos mesmos dados na entrada do programa sempre levará ao mesmo resultado. <br><br>  No JavaScript, começando com o padrão ES2015 (ES6), existe um método <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">interno</a> para normalizar seqüências de caracteres - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">String.prototype.normalize ([form])</a> .  Você pode usá-lo no ambiente Node.js. e em quase todos os navegadores modernos.  O argumento do <code>form</code> desse método é o identificador de seqüência do formulário de normalização.  O padrão é o formulário NFC. <br><br>  Voltamos ao exemplo considerado anteriormente, aplicando a normalização desta vez: <br><br><pre> <code class="plaintext hljs">const str = '\u0065\u0301' console.log(str == '\u00e9') // =&gt; false const normalized = str.normalize('NFC') console.log(normalized == '\u00e9') // =&gt; true console.log(normalized.length) // =&gt; 1</code> </pre> <br><h2>  <font color="#3AC1EF">Sumário</font> </h2><br>  Se você estiver desenvolvendo um aplicativo Web e usando o que o usuário digita nele, sempre normalize os dados de texto recebidos.  Em JavaScript, você pode usar o método de sequência padrão <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">normalize ()</a> para executar a normalização. <br><br>  <b>Caros leitores!</b>  Você encontrou problemas com cadeias que podem ser resolvidas com a normalização? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt445274/">https://habr.com/ru/post/pt445274/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt445264/index.html">Pré-carregamento, pré-busca e outras tags</a></li>
<li><a href="../pt445266/index.html">GeekBrains e Rostelecom conduzirão IoT Hackathon</a></li>
<li><a href="../pt445268/index.html">Detalhes do GraphQL: O que, como e por que</a></li>
<li><a href="../pt445270/index.html">[marcador] Bash para iniciantes: 21 comandos úteis</a></li>
<li><a href="../pt445272/index.html">JavaScript é a melhor linguagem de programação para iniciantes. Então é ou não?</a></li>
<li><a href="../pt445276/index.html">Guia completo de UseEffect</a></li>
<li><a href="../pt445278/index.html">Como criar um jogo se você nunca é um artista</a></li>
<li><a href="../pt445280/index.html">Rentabilidade de sites e serviços</a></li>
<li><a href="../pt445284/index.html">Análise do produto ClickHouse</a></li>
<li><a href="../pt445286/index.html">Apoio para os pés para o cérebro: Hedera Hashgraph Distributed Registry Platform</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>