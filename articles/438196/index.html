<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游뛌游낗 游놓 游똀游낖 Si el proyecto es "Teatro", use actores ... 游볭 游쓇릞 游꾽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este art칤culo contar치 sobre la experiencia de usar el enfoque del actor en un proyecto interesante de un sistema de control automatizado para un teatr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Si el proyecto es "Teatro", use actores ...</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438196/"><p>  Este art칤culo contar치 sobre la experiencia de usar el enfoque del actor en un proyecto interesante de un sistema de control automatizado para un teatro.  Esta es exactamente la impresi칩n de uso, nada m치s. </p><a name="habracut"></a><br><p>  Recientemente, pude participar en una tarea muy interesante: la modernizaci칩n, pero de hecho, el desarrollo de un nuevo sistema de control automatizado para levantar bastidores para uno de los teatros. </p><br><p>  Un teatro moderno (si es grande) es una organizaci칩n bastante compleja.  Mucha gente, equipos y diversos sistemas est치n involucrados en ello.  Uno de esos sistemas es el sistema de control para "subir y bajar" el escenario en el escenario.  Las actuaciones modernas, y m치s 칩peras y ballets, se est치n saturando cada vez m치s de medios t칠cnicos cada a침o.  Utiliza muchos escenarios complejos y su movimiento durante la acci칩n.  El escenario se usa activamente en los planes de direcci칩n, ampliando el significado de lo que est치 sucediendo e incluso "desempe침ando su propio papel de apoyo").  En general, fue muy interesante familiarizarse con la vida detr치s del escenario del teatro y descubrir qu칠 sucede all칤 durante las actuaciones.  Despu칠s de todo, los espectadores comunes solo ven lo que sucede en el escenario. </p><br><p>  Pero este art칤culo sigue siendo t칠cnico y en 칠l quer칤a compartir la experiencia de usar el enfoque de actor para implementar la gesti칩n.  Y tambi칠n comparta la experiencia de usar uno de los pocos marcos de actores de C ++: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sobjectizer</a> . </p><br><p>  쯇or qu칠 exactamente 칠l?  Lo hemos estado observando por mucho tiempo.  Hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art칤culos</a> sobre un habr, tiene excelente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci칩n</a> detallada con ejemplos.  El proyecto es bastante maduro.  Un vistazo r치pido a los ejemplos mostr칩 que los desarrolladores operan con conceptos "familiares" (estados, temporizadores, eventos), es decir.  No se esperaban grandes problemas con la comprensi칩n y el dominio para su uso en nuestro proyecto.  Y s칤, lo m치s importante, los desarrolladores son adecuados y amigables, listos para ayudar con consejos <del>  (en ruso) </del>  .  Entonces decidimos probar ... </p><br><h2 id="a-chto-delaem">  Que estamos haciendo </h2><br><p>  Entonces, 쯖칩mo es nuestro "objeto de control"?  El sistema de ascensores shtanketovy - esto es 62 mantas (tubos de metal) en todo el ancho del escenario que cuelga sobre esta misma escena, aproximadamente cada 30 - 40 cm desde el borde del escenario en profundidad.  Las mangas est치n suspendidas en cuerdas y pueden elevarse o descender al escenario (movimiento vertical).  En cada actuaci칩n (u 칩pera o ballet), una parte de las estrofas se utiliza para la decoraci칩n.  El escenario se cuelga de ellos y se mueve (si el gui칩n lo requiere) durante la acci칩n.  El movimiento en s칤 se lleva a cabo bajo la orden de los operadores (tienen paneles de control especiales) utilizando el sistema "motor - cable - contrapeso" (casi lo mismo que los ascensores en las casas).  Los motores est치n ubicados en los bordes del escenario (en varios niveles), de modo que no son visibles para el espectador.  Todos los motores est치n divididos en 8 grupos y cada grupo tiene tres convertidores de frecuencia (IF).  En cada grupo, se pueden activar simult치neamente tres motores, cada uno conectado a su propio inversor.  En total, tenemos un sistema de 62 motores y 24 inversores, que debemos controlar. </p><br><p>  Nuestra tarea consist칤a en desarrollar una interfaz de operador para gestionar esta econom칤a, as칤 como implementar algoritmos de gesti칩n.  El sistema incluye tres puestos de control.  Dos postes de control est치n ubicados directamente sobre el escenario y un poste est치 ubicado en la sala de m치quinas (donde se encuentran los gabinetes de control) y est치 dise침ado para monitorear el trabajo de un electricista de servicio.  En los gabinetes de control hay controladores que ejecutan comandos, controlan PWM, suministran energ칤a a los motores y rastrean la posici칩n de los v치stagos.  En los dos controles remotos superiores hay monitores, una unidad del sistema donde los algoritmos de control y la bola de seguimiento giran como un "mouse".  Se utiliza una red Ethernet entre los paneles de control.  Cada gabinete de control tiene un canal RS485 (es decir, 8 canales) de cada uno de los dos paneles de control.  La gesti칩n puede llevarse a cabo simult치neamente desde ambos controles remotos (que est치n por encima del escenario), pero al mismo tiempo solo uno de los controles remotos (designado por el operador como operador principal) est치 intercambiando con los gabinetes, la segunda consola en este momento se considera una copia de seguridad y el intercambio est치 desactivado en ella. </p><br><h2 id="prichyom-tut-aktory">  Y aqui los actores </h2><br><p>  Desde el punto de vista de los algoritmos, todo el sistema se basa en eventos.  O estos son algunos cambios en los sensores, o las acciones del operador, o el inicio de alg칰n tiempo (temporizadores).  Y tales algoritmos est치n muy bien ubicados por el sistema de actores que procesan los eventos entrantes, forman alg칰n tipo de respuesta, y todo esto dependiendo de su estado.  En el sobjectizer, todos estos mecanismos salen de la caja.  Se pueden atribuir los principios principales en los que se basa dicho sistema: la interacci칩n entre los actores ocurre a trav칠s de mensajes, los actores pueden tener estados y moverse entre ellos, en cada estado el actor procesa solo aquellos mensajes que le interesan en este momento.  Curiosamente, en un sobjectizer, trabajar con actores est치 conceptualmente separado de trabajar con flujos de trabajo.  Es decir  Puede describir los actores que necesita, darse cuenta de su l칩gica, darse cuenta de su interacci칩n a trav칠s de mensajes.  Pero luego resuelva por separado el problema de asignar hilos (recursos) para su trabajo.  Esto est치 garantizado por los llamados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"despachadores"</a> que son responsables de una pol칤tica particular de trabajar con hilos.  Por ejemplo, hay un despachador que asigna un hilo separado para cada actor con el que trabajar, hay un despachador que proporciona un grupo de hilos (es decir, puede haber m치s actores que hilos) con la capacidad de establecer el n칰mero m치ximo de hilos, hay un despachador que asigna un hilo para todos.  La presencia de despachadores proporciona un mecanismo muy flexible para configurar un sistema de actores que se ajuste a sus necesidades.  Puede combinar grupos de actores para trabajar con uno de los despachadores, mientras cambia un tipo de despachador a otro, esto esencialmente cambia una l칤nea de c칩digo.  Seg칰n los autores del marco, escribir su propio despachador 칰nico tampoco es dif칤cil.  Esto no era necesario en nuestro proyecto, porque todo lo que necesit치bamos ya estaba en el sobjectizer. </p><br><p>  Otra caracter칤stica interesante es la presencia del concepto de "cooperaci칩n" de los actores.  La cooperaci칩n es un grupo de actores que pueden existir o destruirse (o no lanzarse) si al menos un actor de la cooperaci칩n no pudo comenzar a trabajar o completarlo.  Ni siquiera tengo miedo de dar semejante analog칤a ( <del>  a pesar de que es de otra "칩pera" </del>  ) que el concepto de "cooperaci칩n" es como el concepto de "hogares" en los Kubernetes ahora de moda, solo parece en el sobjetivo, surgi칩 antes ... </p><br><p>  En el momento de la creaci칩n, cada actor est치 incluido en la cooperaci칩n (la cooperaci칩n puede consistir en un actor), se une a uno u otro despachador y comienza a trabajar.  Al mismo tiempo, los actores (y la cooperaci칩n) pueden (f치cilmente) crearse din치micamente en grandes cantidades, y como prometen los desarrolladores, no es costoso.  Todos los actores intercambian entre ellos a trav칠s de " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">buzones</a> " (mbox).  Este tambi칠n es un concepto bastante interesante y fuerte en el sobjectizer.  Proporciona un mecanismo muy flexible para procesar mensajes entrantes.  En primer lugar, m치s de un destinatario puede estar escondido detr치s de una caja.  Es realmente muy conveniente.  Por ejemplo, se crea un cuadro en el que se reciben eventos de sensores externos y cada actor se suscribe a eventos que le interesan.  Esto proporciona un estilo de operaci칩n de "publicaci칩n / suscripci칩n".  En segundo lugar, los desarrolladores han brindado la oportunidad de crear con relativa facilidad su propia implementaci칩n de buzones de correo que pueden preprocesar los mensajes entrantes (por ejemplo, de alguna manera filtrarlos o distribuirlos de manera especial entre los consumidores).  Adem치s, cada actor tiene su propio buz칩n e incluso puede enviarle un "enlace" en mensajes a otros actores, por ejemplo, para que puedan enviar alg칰n tipo de notificaci칩n como respuesta de respuesta. </p><br><p>  En nuestro proyecto, para garantizar la independencia de los grupos de motores entre ellos, as칤 como para garantizar el funcionamiento "as칤ncrono" de los motores dentro del grupo, todos los objetos de control se dividieron en 8 grupos (seg칰n el n칰mero de armarios de control), cada uno de los cuales ten칤a tres trabajadores flujo (ya que no pueden funcionar m치s de tres motores en un grupo a la vez). <br>  Tambi칠n debe decirse que el sobjectizer (en la versi칩n actual 5.5) no contiene mecanismos de interacci칩n entre redes y entre procesos y deja esta parte a los desarrolladores.  Los autores hicieron esto de manera bastante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">deliberada</a> , para que el marco sea m치s "f치cil".  Adem치s, los mecanismos de interacci칩n de red "una vez" existieron en versiones anteriores, pero fueron excluidos.  Sin embargo, esto no causa ning칰n inconveniente, porque de hecho la interacci칩n de la red depende mucho de las tareas que se resuelven, los protocolos de intercambio utilizados, etc.  Aqu칤, una implementaci칩n universal no puede ser 칩ptima para todos los casos. </p><br><p>  En nuestro caso, para la red y la comunicaci칩n entre procesos, utilizamos uno de nuestros desarrollos de larga data: la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">libuniset2</a> .  Como resultado, la arquitectura de nuestro sistema se ve as칤: </p><br><ul><li>  libuniset proporciona comunicaci칩n de red y entre procesos (basada en sensores) </li><li>  sobjectizer proporciona la creaci칩n de un sistema de actores que interact칰an entre s칤 (en el mismo espacio de direcciones) implementando algoritmos de control. </li></ul><br><p>  Entonces, d칠jame recordarte que tenemos 62 motores.  Cada motor se puede conectar al inversor, al soporte correspondiente se le puede dar la coordenada a la que debe llegar y la velocidad con la que debe moverse.  Adem치s, el motor tiene las siguientes condiciones: </p><br><ul><li>  listo para ir </li><li>  conectado </li><li>  corriendo (girando) </li><li>  accidente </li><li>  conexi칩n (estado transitorio) </li><li>  apagado (estado transitorio) </li></ul><br><p>  Como resultado, cada "motor" est치 representado en el sistema por un actor que implementa la l칩gica de las transiciones entre estados, procesando eventos desde sensores y emitiendo comandos de control.  En sobjectizer, los actores se crean f치cilmente, simplemente herede su clase de la clase base so_5 :: agent_t.  Al mismo tiempo, el constructor debe tomar el llamado contexto :: so_5 :: context_t como primer argumento, los argumentos restantes est치n determinados por la necesidad del desarrollador. </p><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drive_A</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Drive_A( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx, ... ); ... }</code> </pre> <br><p>  Porque  Este art칤culo no es educativo, por lo que no proporcionar칠 aqu칤 los textos detallados de las descripciones de clases o m칠todos.  El art칤culo solo quer칤a mostrar lo f치cil que es (en pocas l칤neas) con la ayuda de sobjectizer todo esto est치 implementado.  Perm칤tame recordarle que el proyecto tiene una excelente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci칩n</a> detallada, con muchos ejemplos diferentes. </p><br><h2 id="a-chto-za-sostoyaniya-u-etih-aktorov-o-chyom-rech">  쯏 cu치les son los "estados" de estos actores?  De que estas hablando </h2><br><p>  El uso de estados y transiciones entre ellos para ACS es generalmente un tema nativo.  Este "concepto" encaja muy bien en el manejo de eventos.  En sobjectizer, este concepto es compatible a nivel API.  En una clase de actor, los estados se declaran con bastante facilidad. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drive_A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Drive_A( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx, ... ); <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Drive_A(); <span class="hljs-comment"><span class="hljs-comment">//  state_t st_base {this}; state_t st_disabled{ initial_substate_of{st_base}, "disabled" }; state_t st_preinit{ substate_of{st_base}, "preinit" }; state_t st_off{ substate_of{st_base}, "off" }; state_t st_connecting{ substate_of{st_base}, "connecting" }; state_t st_disconnecting{ substate_of{st_base}, "disconnecting" }; state_t st_connected{ substate_of{st_base}, "connected" }; ... }</span></span></code> </pre><br><p>  y adem치s, para cada estado, el desarrollador determina los controladores necesarios.  A menudo, se requieren algunas acciones al ingresar a un estado y al salir de 칠l.  Esto tambi칠n se proporciona en el sobjectizer, usted define f치cilmente sus controladores para estos eventos ("entrada de estado", "salida de estado"). <del>  Se cree que los desarrolladores en el pasado tienen una amplia experiencia ACS-shny </del>  ... </p><br><h3 id="obrabotchiki-sobytiy">  Controladores de eventos </h3><br><p>  Controladores de eventos, aqu칤 es donde se implementa la l칩gica de su aplicaci칩n.  Como se mencion칩 anteriormente, se realiza una suscripci칩n a un buz칩n espec칤fico y para un determinado estado del actor.  Si un actor no tiene estados declarados expl칤citamente en el c칩digo, entonces est치 impl칤citamente en el estado especial "default_state".  En diferentes estados, puede definir diferentes controladores para los mismos eventos.  Si no especific칩 el controlador de ning칰n evento en este buz칩n, simplemente se ignorar치 (es decir, simplemente no existir치 para el actor). </p><br><p>  La sintaxis para definir manejadores es muy simple.  Es suficiente para indicar su funci칩n.  No se requieren tipos ni argumentos de plantilla.  Todo se deduce autom치ticamente de la definici칩n de la funci칩n.  Por ejemplo: </p><br><pre> <code class="cpp hljs">so_subscribe(drv-&gt;so_mbox()) .in(st_base) .event( &amp;Drive_A::on_get_info ) .event( &amp;Drive_A::on_control ) .event( &amp;Drive_A::off_control );</code> </pre> <br><p>  Aqu칤 hay un ejemplo de suscripci칩n a eventos en un cuadro espec칤fico para el estado st_base.  Curiosamente, en este ejemplo, st_base es el estado base para otros estados y, en consecuencia, esta suscripci칩n ser치 v치lida para todos los estados que se "hereden" de st_base.  Este enfoque le permite deshacerse de "copiar y pegar" para determinar los mismos controladores para diferentes estados.  Al mismo tiempo, en un estado espec칤fico, puede anular el controlador especificado o "deshabilitarlo" (suprimir). </p><br><p>  Hay otra forma de definir manejadores.  Esta es una definici칩n directa de funciones lambda.  Esta es una forma muy conveniente, porque a menudo los controladores son funciones cortas en un par de acciones, enviar algo a alguien o cambiar el estado. </p><br><pre> <code class="cpp hljs">so_subscribe(drv-&gt;so_mbox()) .in(st_disconnecting) .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">msg_disconnected_t</span></span>&amp; m) { ... st_off.activate(); }) .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">msg_failure_t</span></span>&amp; m ) { ... st_protection.activate(); });</code> </pre> <br><p>  Al principio, esta sintaxis parece complicada.  Pero en solo unos pocos d칤as de desarrollo activo, te acostumbras e incluso te comienza a gustar.  Porque toda la l칩gica del trabajo del actor en un estado u otro puede caber en un c칩digo bastante corto y todo estar치 frente a tus ojos.  Por ejemplo, en el ejemplo que se muestra, en el estado desconectado (st_disconnecting), la transici칩n al estado desconectado (st_off.) O el estado de protecci칩n (st_protection) se produce si se produce un mensaje sobre alg칰n tipo de falla.  Tal c칩digo es bastante f치cil de leer. </p><br><p>  Por cierto, para casos simples cuando un evento solo necesita entrar en alg칰n estado, hay una sintaxis a칰n m치s corta: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> mbox = drv-&gt;so_mbox(); st_off .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_connected_t</span></span>&gt;(mbox, st_connected) .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_failure_t</span></span>&gt;(mbox, st_protection) .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_on_limit_t</span></span>&gt;(mbox, st_protection) .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_on_t</span></span>&gt;(mbox, st_on);</code> </pre><br><h2 id="upravlenie">  Gesti칩n </h2><br><p>  쮺칩mo funciona la gesti칩n de toda esta econom칤a?  Como se mencion칩 anteriormente, se proporcionan dos controles remotos para el control directo del movimiento de los shtankets.  En cada control remoto hay un monitor, un manipulador (trackball) y un marcado r치pido (adem치s de la "computadora" oculta en el control remoto en el que todo gira y un mont칩n de todo tipo de convertidores).  El sistema tiene varios modos de controlar el movimiento de los shtankets.  Manual y "modo script".  Sobre el "modo de escenario" se discutir치 m치s a fondo, y ahora un poco sobre el "modo manual".  En este modo, el operador selecciona el v치stago deseado, lo prepara para el movimiento (conecta el motor al inversor), establece la marca (posici칩n objetivo) para el v치stago y tan pronto como establece la velocidad mayor que cero, los v치stagos comienzan a moverse.  Para establecer la velocidad, se usa un ajustador f칤sico especial, en forma de un "potenci칩metro con una perilla", pero tambi칠n hay un "ajustador de pantalla" de velocidad.  Cuanto m치s "convertido", el <del>  mas fuerte </del>  va m치s r치pido  La velocidad m치xima est치 limitada a 1,5 m / s.  Perilla de velocidad: una para todos.  Es decir  En modo manual, todas las bandejas conectadas por el operador se mueven a la misma velocidad establecida.  Aunque pueden moverse en diferentes direcciones (depende de d칩nde los dirigi칩 el operador).  Por supuesto, es dif칤cil para una persona hacer un seguimiento de m치s de dos o tres canastas al mismo tiempo, por lo que generalmente no se mueven mucho en modo manual.  Desde dos estaciones, los operadores pueden gestionar simult치neamente cada uno de sus shtankets.  Adem치s, cada consola (operador) tiene su propio controlador de velocidad. </p><br><p>  Desde el punto de vista de la implementaci칩n, el modo manual no contiene ninguna l칩gica especial.  El comando para conectar el motor proviene de la interfaz gr치fica, se convierte en un mensaje para el actor correspondiente, que trabaja en 칠l.  Al pasar por los estados "apagado" -&gt; "conexi칩n" -&gt; "conectado".  Lo mismo con establecer la posici칩n para el movimiento del stunket y establecer la velocidad.  Todos estos eventos llegan al actor en forma de mensajes a los que reacciona.  A menos que se pueda observar que la interfaz gr치fica y el proceso de control en s칤 son procesos diferentes y entre ellos hay una interacci칩n "interproceso" a trav칠s de los "sensores" que usan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">libuniset2</a> . </p><br><h2 id="rezhim-ispolneniya-scenariya-opyat-eti-aktory">  Modo de ejecuci칩n de script (de nuevo, 쯘stos actores?) </h2><br><p>  De hecho, el modo de control manual se usa principalmente para pasar el rato durante los ensayos o en casos simples.  El modo principal en el que el control est치 en progreso es "modo de ejecuci칩n de script" o, brevemente, "modo de script".  En este modo, cada shtank se mueve a su punto con los par치metros especificados en el script (velocidad y marca de objetivo).  Para el operador, el control en este modo consta de dos comandos simples: </p><br><ul><li>  prep치rate (el grupo correcto de motores est치n conectados) </li><li>  vamos (el grupo comienza a moverse a las posiciones de destino establecidas para cada uno). </li></ul><br><p>  Todo el escenario se divide en las llamadas "agendas".  Una agenda es un movimiento de un grupo shtanket.  Es decir  cada agenda incluye un grupo de shtankets, con la velocidad objetivo y la marca a la que necesita llegar.  De hecho, el gui칩n se divide en actos, los actos se dividen en pinturas, las pinturas se dividen en citaciones y las citaciones ya consisten en "objetivos" para tiendas espec칤ficas.  Pero desde el punto de vista de la administraci칩n, esta divisi칩n no es importante, porque  Es en la agenda que los par치metros espec칤ficos de movimiento se indican al final. </p><br><p>  Para implementar este r칠gimen, el sistema de actores volvi칩 a surgir lo mejor posible.  Se desarroll칩 un "reproductor de guiones" que crea un grupo de actores especiales y los lanza.  Hemos desarrollado dos tipos de actores: actores-actores, dise침ados para realizar tareas para un shtanket espec칤fico, y un actor-coordinador, que distribuye las tareas entre los artistas.  Adem치s, los actores interpretativos se crean seg칰n sea necesario, si en el momento del pr칩ximo equipo no es gratuito.  El actor coordinador es responsable de crear y mantener el grupo de actores esc칠nicos.  Como resultado, la administraci칩n se ve as칤: </p><br><ul><li>  declaraci칩n carga el script </li><li>  Lo "voltea" a la agenda deseada (generalmente solo va en una fila). </li><li>  en el momento correcto, presiona el bot칩n "preparar", mediante el cual se env칤a un comando (mensaje) al actor coordinador para cada formulario incluido en la agenda actual con par치metros de movimiento. </li><li>  El coordinador de actores analiza su grupo de actores que act칰an libremente, toma uno libre (si no crea uno nuevo) y le asigna una tarea (n칰mero de mantillas y par치metros de movimiento). </li><li>  Cada actor-actor que ha recibido la tarea comienza a cumplir el comando "prepararse".  Es decir  conecta el motor y entra en el modo de espera del comando "ir". </li><li>  cuando llega el momento, el operador da el comando "vamos" </li><li>  el equipo "ir" viene al coordinador.  Se lo env칤a a todos sus artistas actualmente activos y comienzan la "ejecuci칩n". </li></ul><br><p>  Vale la pena se침alar que en la agenda hay par치metros adicionales.  Por ejemplo, inicie el movimiento con un retraso de N segundos o inicie el movimiento solo despu칠s de un comando de operador especial por separado.  Por lo tanto, la lista de estados para cada actor es bastante grande: "listo para ejecutar el siguiente comando", "listo para moverse", "movimiento retrasado", "esperando el comando del operador", "movimiento", "ejecuci칩n completada", "mal funcionamiento" . </p><br><p>  Despu칠s de que el v치stago alcanz칩 con 칠xito (o no) la marca especificada, el actor-int칠rprete notifica al coordinador la tarea completada.  El coordinador da la orden de apagar este motor (si ya no participa en la agenda actual) o emite nuevos par치metros de movimiento.  A su vez, el actor-int칠rprete recibi칩 una orden para apagar el motor, lo apaga y pasa a un estado de espera de nuevas 칩rdenes, o comienza a ejecutar una nueva orden. </p><br><p>  Debido al hecho de que el sobjectizer tiene una API bien pensada y conveniente para trabajar con estados, el c칩digo de implementaci칩n es bastante conciso.  Por ejemplo, el retraso en el movimiento se describe en una l칤nea: </p><br><pre> <code class="cpp hljs">st_delay.time_limit( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds{target-&gt;delay()}, st_moving ); st_delay.activate(); ...</code> </pre><br><p>  La funci칩n time_limit establece un l칤mite de tiempo sobre cu치nto se puede gastar en un estado dado y qu칠 estado se debe pasar despu칠s de un tiempo espec칤fico (st_moving). </p><br><h2 id="aktory-zaschity">  Actores de protecci칩n </h2><br><p>  Por supuesto, durante la operaci칩n, pueden ocurrir fallos de funcionamiento.  Se requiere el sistema para manejar estas situaciones.  Aqu칤, tambi칠n, hab칤a un lugar para el uso de actores.  Considere varias de estas protecciones: </p><br><ul><li>  sobre la protecci칩n actual </li><li>  protecci칩n de falla de medici칩n </li><li>  protecci칩n contra el movimiento en la direcci칩n opuesta (y esto puede ser, si algo est치 mal con el sensor o el medidor) </li><li>  protecci칩n contra movimiento sin comando </li><li>  control de la ejecuci칩n del equipo (control de que el shtanket comenz칩 a moverse) </li></ul><br><p>  Puede ver que todas estas protecciones son independientes (autosuficientes) desde el punto de vista de la implementaci칩n, y deber칤an funcionar "en paralelo".  Es decir  Cualquier condici칩n puede funcionar.  Al mismo tiempo, la l칩gica de verificar las condiciones de activaci칩n para cada una de las protecciones tiene la suya, a veces se requiere un retraso (temporizador) para la activaci칩n, a veces se requiere un procesamiento preliminar de varias mediciones anteriores, etc.  Por lo tanto, la implementaci칩n de cada tipo de protecci칩n como un peque침o actor separado result칩 ser muy conveniente.  Todos estos actores se lanzan adem치s (en cooperaci칩n) del actor principal que implementa la l칩gica de control.  Este enfoque hace que sea f치cil agregar tipos adicionales de defensas simplemente agregando otro actor al grupo.  Al mismo tiempo, la implementaci칩n de tal actor sigue siendo bastante f치cil y comprensible, porque  Implementa solo una funci칩n. </p><br><p>  Los actores de protecci칩n tambi칠n tienen varios estados.  B치sicamente se encienden (entran en el estado "encendido") solo cuando el motor est치 conectado o el v치stago est치 en movimiento.  Cuando se activan las condiciones de protecci칩n, publican una notificaci칩n sobre la protecci칩n que se est치 activando (con un c칩digo de seguridad y algunos detalles para el registro), el actor principal ya responde a esta notificaci칩n, que, si es necesario, apaga el motor y cambia al modo de protecci칩n. </p><br><h2 id="v-kachestve-vyvoda">  Como conclusi칩n ... </h2><br><p>  ... por supuesto, este art칤culo no es una especie de "descubrimiento".  El enfoque del actor se ha utilizado con 칠xito en muchos sistemas.  Pero para m칤 fue la primera experiencia de usar conscientemente el enfoque del actor para construir algoritmos de sistemas de control en un proyecto relativamente peque침o.  Y la experiencia fue bastante exitosa.  Espero haber podido demostrar que los actores est치n muy bien superpuestos a los algoritmos de control, encontraron un lugar literalmente en todas partes. </p><br><p>  Seg칰n la experiencia de proyectos anteriores, estaba claro que de una forma u otra est치bamos implementando "algo as칤" (estados, mensajes, control de flujo, etc.), pero este no era un enfoque unificado.  Usando el sobjectizer obtuvimos una herramienta de desarrollo concisa y liviana que tiene muchos problemas.  Ya no es necesario (expl칤cito) usar herramientas de sincronizaci칩n (mutexes, etc.), no hay trabajo expl칤cito con flujos, ni realizaciones de la m치quina de estados.  Todo esto est치 en el marco, l칩gicamente interconectado y presentado como una API conveniente, adem치s, sin perder el control sobre los detalles.  Entonces la experiencia fue interesante.  Para aquellos que a칰n dudan, recomiendo prestar atenci칩n al enfoque del actor y al marco del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sobjectizer</a> en particular.  Deja emociones positivas. </p><br><p>  춰Y el enfoque del actor realmente funciona!  Especialmente en el teatro. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/438196/">https://habr.com/ru/post/438196/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../438178/index.html">Creando su primera aplicaci칩n ARCore</a></li>
<li><a href="../438180/index.html">Registre una transacci칩n de bienes ra칤ces en l칤nea</a></li>
<li><a href="../438182/index.html">El estudio encontr칩 los beneficios de la pirater칤a moderada para los productores y distribuidores de contenido.</a></li>
<li><a href="../438188/index.html">Bill gates y reactor de sodio r치pido</a></li>
<li><a href="../438190/index.html">쮺u치les son los procedimientos de adquisici칩n (en palabras simples)</a></li>
<li><a href="../438198/index.html">Profundicemos en la historia: 쯗칩nde crecen las patas de los cuadric칩pteros?</a></li>
<li><a href="../438202/index.html">JavaScript: Campos de clase p칰blicos y privados</a></li>
<li><a href="../438204/index.html">Dispositivo compilador r치pido. Parte 1</a></li>
<li><a href="../438206/index.html">26 recomendaciones para usar el tipo var en Java</a></li>
<li><a href="../438210/index.html">Civilizaci칩n de Springs, 2/5</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>