<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚶🏽 👽 🙍🏼 Si el proyecto es "Teatro", use actores ... 🥗 🤲🏿 🎆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artículo contará sobre la experiencia de usar el enfoque del actor en un proyecto interesante de un sistema de control automatizado para un teatr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Si el proyecto es "Teatro", use actores ...</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438196/"><p>  Este artículo contará sobre la experiencia de usar el enfoque del actor en un proyecto interesante de un sistema de control automatizado para un teatro.  Esta es exactamente la impresión de uso, nada más. </p><a name="habracut"></a><br><p>  Recientemente, pude participar en una tarea muy interesante: la modernización, pero de hecho, el desarrollo de un nuevo sistema de control automatizado para levantar bastidores para uno de los teatros. </p><br><p>  Un teatro moderno (si es grande) es una organización bastante compleja.  Mucha gente, equipos y diversos sistemas están involucrados en ello.  Uno de esos sistemas es el sistema de control para "subir y bajar" el escenario en el escenario.  Las actuaciones modernas, y más óperas y ballets, se están saturando cada vez más de medios técnicos cada año.  Utiliza muchos escenarios complejos y su movimiento durante la acción.  El escenario se usa activamente en los planes de dirección, ampliando el significado de lo que está sucediendo e incluso "desempeñando su propio papel de apoyo").  En general, fue muy interesante familiarizarse con la vida detrás del escenario del teatro y descubrir qué sucede allí durante las actuaciones.  Después de todo, los espectadores comunes solo ven lo que sucede en el escenario. </p><br><p>  Pero este artículo sigue siendo técnico y en él quería compartir la experiencia de usar el enfoque de actor para implementar la gestión.  Y también comparta la experiencia de usar uno de los pocos marcos de actores de C ++: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sobjectizer</a> . </p><br><p>  ¿Por qué exactamente él?  Lo hemos estado observando por mucho tiempo.  Hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículos</a> sobre un habr, tiene excelente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación</a> detallada con ejemplos.  El proyecto es bastante maduro.  Un vistazo rápido a los ejemplos mostró que los desarrolladores operan con conceptos "familiares" (estados, temporizadores, eventos), es decir.  No se esperaban grandes problemas con la comprensión y el dominio para su uso en nuestro proyecto.  Y sí, lo más importante, los desarrolladores son adecuados y amigables, listos para ayudar con consejos <del>  (en ruso) </del>  .  Entonces decidimos probar ... </p><br><h2 id="a-chto-delaem">  Que estamos haciendo </h2><br><p>  Entonces, ¿cómo es nuestro "objeto de control"?  El sistema de ascensores shtanketovy - esto es 62 mantas (tubos de metal) en todo el ancho del escenario que cuelga sobre esta misma escena, aproximadamente cada 30 - 40 cm desde el borde del escenario en profundidad.  Las mangas están suspendidas en cuerdas y pueden elevarse o descender al escenario (movimiento vertical).  En cada actuación (u ópera o ballet), una parte de las estrofas se utiliza para la decoración.  El escenario se cuelga de ellos y se mueve (si el guión lo requiere) durante la acción.  El movimiento en sí se lleva a cabo bajo la orden de los operadores (tienen paneles de control especiales) utilizando el sistema "motor - cable - contrapeso" (casi lo mismo que los ascensores en las casas).  Los motores están ubicados en los bordes del escenario (en varios niveles), de modo que no son visibles para el espectador.  Todos los motores están divididos en 8 grupos y cada grupo tiene tres convertidores de frecuencia (IF).  En cada grupo, se pueden activar simultáneamente tres motores, cada uno conectado a su propio inversor.  En total, tenemos un sistema de 62 motores y 24 inversores, que debemos controlar. </p><br><p>  Nuestra tarea consistía en desarrollar una interfaz de operador para gestionar esta economía, así como implementar algoritmos de gestión.  El sistema incluye tres puestos de control.  Dos postes de control están ubicados directamente sobre el escenario y un poste está ubicado en la sala de máquinas (donde se encuentran los gabinetes de control) y está diseñado para monitorear el trabajo de un electricista de servicio.  En los gabinetes de control hay controladores que ejecutan comandos, controlan PWM, suministran energía a los motores y rastrean la posición de los vástagos.  En los dos controles remotos superiores hay monitores, una unidad del sistema donde los algoritmos de control y la bola de seguimiento giran como un "mouse".  Se utiliza una red Ethernet entre los paneles de control.  Cada gabinete de control tiene un canal RS485 (es decir, 8 canales) de cada uno de los dos paneles de control.  La gestión puede llevarse a cabo simultáneamente desde ambos controles remotos (que están por encima del escenario), pero al mismo tiempo solo uno de los controles remotos (designado por el operador como operador principal) está intercambiando con los gabinetes, la segunda consola en este momento se considera una copia de seguridad y el intercambio está desactivado en ella. </p><br><h2 id="prichyom-tut-aktory">  Y aqui los actores </h2><br><p>  Desde el punto de vista de los algoritmos, todo el sistema se basa en eventos.  O estos son algunos cambios en los sensores, o las acciones del operador, o el inicio de algún tiempo (temporizadores).  Y tales algoritmos están muy bien ubicados por el sistema de actores que procesan los eventos entrantes, forman algún tipo de respuesta, y todo esto dependiendo de su estado.  En el sobjectizer, todos estos mecanismos salen de la caja.  Se pueden atribuir los principios principales en los que se basa dicho sistema: la interacción entre los actores ocurre a través de mensajes, los actores pueden tener estados y moverse entre ellos, en cada estado el actor procesa solo aquellos mensajes que le interesan en este momento.  Curiosamente, en un sobjectizer, trabajar con actores está conceptualmente separado de trabajar con flujos de trabajo.  Es decir  Puede describir los actores que necesita, darse cuenta de su lógica, darse cuenta de su interacción a través de mensajes.  Pero luego resuelva por separado el problema de asignar hilos (recursos) para su trabajo.  Esto está garantizado por los llamados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"despachadores"</a> que son responsables de una política particular de trabajar con hilos.  Por ejemplo, hay un despachador que asigna un hilo separado para cada actor con el que trabajar, hay un despachador que proporciona un grupo de hilos (es decir, puede haber más actores que hilos) con la capacidad de establecer el número máximo de hilos, hay un despachador que asigna un hilo para todos.  La presencia de despachadores proporciona un mecanismo muy flexible para configurar un sistema de actores que se ajuste a sus necesidades.  Puede combinar grupos de actores para trabajar con uno de los despachadores, mientras cambia un tipo de despachador a otro, esto esencialmente cambia una línea de código.  Según los autores del marco, escribir su propio despachador único tampoco es difícil.  Esto no era necesario en nuestro proyecto, porque todo lo que necesitábamos ya estaba en el sobjectizer. </p><br><p>  Otra característica interesante es la presencia del concepto de "cooperación" de los actores.  La cooperación es un grupo de actores que pueden existir o destruirse (o no lanzarse) si al menos un actor de la cooperación no pudo comenzar a trabajar o completarlo.  Ni siquiera tengo miedo de dar semejante analogía ( <del>  a pesar de que es de otra "ópera" </del>  ) que el concepto de "cooperación" es como el concepto de "hogares" en los Kubernetes ahora de moda, solo parece en el sobjetivo, surgió antes ... </p><br><p>  En el momento de la creación, cada actor está incluido en la cooperación (la cooperación puede consistir en un actor), se une a uno u otro despachador y comienza a trabajar.  Al mismo tiempo, los actores (y la cooperación) pueden (fácilmente) crearse dinámicamente en grandes cantidades, y como prometen los desarrolladores, no es costoso.  Todos los actores intercambian entre ellos a través de " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">buzones</a> " (mbox).  Este también es un concepto bastante interesante y fuerte en el sobjectizer.  Proporciona un mecanismo muy flexible para procesar mensajes entrantes.  En primer lugar, más de un destinatario puede estar escondido detrás de una caja.  Es realmente muy conveniente.  Por ejemplo, se crea un cuadro en el que se reciben eventos de sensores externos y cada actor se suscribe a eventos que le interesan.  Esto proporciona un estilo de operación de "publicación / suscripción".  En segundo lugar, los desarrolladores han brindado la oportunidad de crear con relativa facilidad su propia implementación de buzones de correo que pueden preprocesar los mensajes entrantes (por ejemplo, de alguna manera filtrarlos o distribuirlos de manera especial entre los consumidores).  Además, cada actor tiene su propio buzón e incluso puede enviarle un "enlace" en mensajes a otros actores, por ejemplo, para que puedan enviar algún tipo de notificación como respuesta de respuesta. </p><br><p>  En nuestro proyecto, para garantizar la independencia de los grupos de motores entre ellos, así como para garantizar el funcionamiento "asíncrono" de los motores dentro del grupo, todos los objetos de control se dividieron en 8 grupos (según el número de armarios de control), cada uno de los cuales tenía tres trabajadores flujo (ya que no pueden funcionar más de tres motores en un grupo a la vez). <br>  También debe decirse que el sobjectizer (en la versión actual 5.5) no contiene mecanismos de interacción entre redes y entre procesos y deja esta parte a los desarrolladores.  Los autores hicieron esto de manera bastante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">deliberada</a> , para que el marco sea más "fácil".  Además, los mecanismos de interacción de red "una vez" existieron en versiones anteriores, pero fueron excluidos.  Sin embargo, esto no causa ningún inconveniente, porque de hecho la interacción de la red depende mucho de las tareas que se resuelven, los protocolos de intercambio utilizados, etc.  Aquí, una implementación universal no puede ser óptima para todos los casos. </p><br><p>  En nuestro caso, para la red y la comunicación entre procesos, utilizamos uno de nuestros desarrollos de larga data: la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">libuniset2</a> .  Como resultado, la arquitectura de nuestro sistema se ve así: </p><br><ul><li>  libuniset proporciona comunicación de red y entre procesos (basada en sensores) </li><li>  sobjectizer proporciona la creación de un sistema de actores que interactúan entre sí (en el mismo espacio de direcciones) implementando algoritmos de control. </li></ul><br><p>  Entonces, déjame recordarte que tenemos 62 motores.  Cada motor se puede conectar al inversor, al soporte correspondiente se le puede dar la coordenada a la que debe llegar y la velocidad con la que debe moverse.  Además, el motor tiene las siguientes condiciones: </p><br><ul><li>  listo para ir </li><li>  conectado </li><li>  corriendo (girando) </li><li>  accidente </li><li>  conexión (estado transitorio) </li><li>  apagado (estado transitorio) </li></ul><br><p>  Como resultado, cada "motor" está representado en el sistema por un actor que implementa la lógica de las transiciones entre estados, procesando eventos desde sensores y emitiendo comandos de control.  En sobjectizer, los actores se crean fácilmente, simplemente herede su clase de la clase base so_5 :: agent_t.  Al mismo tiempo, el constructor debe tomar el llamado contexto :: so_5 :: context_t como primer argumento, los argumentos restantes están determinados por la necesidad del desarrollador. </p><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drive_A</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Drive_A( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx, ... ); ... }</code> </pre> <br><p>  Porque  Este artículo no es educativo, por lo que no proporcionaré aquí los textos detallados de las descripciones de clases o métodos.  El artículo solo quería mostrar lo fácil que es (en pocas líneas) con la ayuda de sobjectizer todo esto está implementado.  Permítame recordarle que el proyecto tiene una excelente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación</a> detallada, con muchos ejemplos diferentes. </p><br><h2 id="a-chto-za-sostoyaniya-u-etih-aktorov-o-chyom-rech">  ¿Y cuáles son los "estados" de estos actores?  De que estas hablando </h2><br><p>  El uso de estados y transiciones entre ellos para ACS es generalmente un tema nativo.  Este "concepto" encaja muy bien en el manejo de eventos.  En sobjectizer, este concepto es compatible a nivel API.  En una clase de actor, los estados se declaran con bastante facilidad. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drive_A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Drive_A( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx, ... ); <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Drive_A(); <span class="hljs-comment"><span class="hljs-comment">//  state_t st_base {this}; state_t st_disabled{ initial_substate_of{st_base}, "disabled" }; state_t st_preinit{ substate_of{st_base}, "preinit" }; state_t st_off{ substate_of{st_base}, "off" }; state_t st_connecting{ substate_of{st_base}, "connecting" }; state_t st_disconnecting{ substate_of{st_base}, "disconnecting" }; state_t st_connected{ substate_of{st_base}, "connected" }; ... }</span></span></code> </pre><br><p>  y además, para cada estado, el desarrollador determina los controladores necesarios.  A menudo, se requieren algunas acciones al ingresar a un estado y al salir de él.  Esto también se proporciona en el sobjectizer, usted define fácilmente sus controladores para estos eventos ("entrada de estado", "salida de estado"). <del>  Se cree que los desarrolladores en el pasado tienen una amplia experiencia ACS-shny </del>  ... </p><br><h3 id="obrabotchiki-sobytiy">  Controladores de eventos </h3><br><p>  Controladores de eventos, aquí es donde se implementa la lógica de su aplicación.  Como se mencionó anteriormente, se realiza una suscripción a un buzón específico y para un determinado estado del actor.  Si un actor no tiene estados declarados explícitamente en el código, entonces está implícitamente en el estado especial "default_state".  En diferentes estados, puede definir diferentes controladores para los mismos eventos.  Si no especificó el controlador de ningún evento en este buzón, simplemente se ignorará (es decir, simplemente no existirá para el actor). </p><br><p>  La sintaxis para definir manejadores es muy simple.  Es suficiente para indicar su función.  No se requieren tipos ni argumentos de plantilla.  Todo se deduce automáticamente de la definición de la función.  Por ejemplo: </p><br><pre> <code class="cpp hljs">so_subscribe(drv-&gt;so_mbox()) .in(st_base) .event( &amp;Drive_A::on_get_info ) .event( &amp;Drive_A::on_control ) .event( &amp;Drive_A::off_control );</code> </pre> <br><p>  Aquí hay un ejemplo de suscripción a eventos en un cuadro específico para el estado st_base.  Curiosamente, en este ejemplo, st_base es el estado base para otros estados y, en consecuencia, esta suscripción será válida para todos los estados que se "hereden" de st_base.  Este enfoque le permite deshacerse de "copiar y pegar" para determinar los mismos controladores para diferentes estados.  Al mismo tiempo, en un estado específico, puede anular el controlador especificado o "deshabilitarlo" (suprimir). </p><br><p>  Hay otra forma de definir manejadores.  Esta es una definición directa de funciones lambda.  Esta es una forma muy conveniente, porque a menudo los controladores son funciones cortas en un par de acciones, enviar algo a alguien o cambiar el estado. </p><br><pre> <code class="cpp hljs">so_subscribe(drv-&gt;so_mbox()) .in(st_disconnecting) .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">msg_disconnected_t</span></span>&amp; m) { ... st_off.activate(); }) .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">msg_failure_t</span></span>&amp; m ) { ... st_protection.activate(); });</code> </pre> <br><p>  Al principio, esta sintaxis parece complicada.  Pero en solo unos pocos días de desarrollo activo, te acostumbras e incluso te comienza a gustar.  Porque toda la lógica del trabajo del actor en un estado u otro puede caber en un código bastante corto y todo estará frente a tus ojos.  Por ejemplo, en el ejemplo que se muestra, en el estado desconectado (st_disconnecting), la transición al estado desconectado (st_off.) O el estado de protección (st_protection) se produce si se produce un mensaje sobre algún tipo de falla.  Tal código es bastante fácil de leer. </p><br><p>  Por cierto, para casos simples cuando un evento solo necesita entrar en algún estado, hay una sintaxis aún más corta: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> mbox = drv-&gt;so_mbox(); st_off .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_connected_t</span></span>&gt;(mbox, st_connected) .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_failure_t</span></span>&gt;(mbox, st_protection) .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_on_limit_t</span></span>&gt;(mbox, st_protection) .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_on_t</span></span>&gt;(mbox, st_on);</code> </pre><br><h2 id="upravlenie">  Gestión </h2><br><p>  ¿Cómo funciona la gestión de toda esta economía?  Como se mencionó anteriormente, se proporcionan dos controles remotos para el control directo del movimiento de los shtankets.  En cada control remoto hay un monitor, un manipulador (trackball) y un marcado rápido (además de la "computadora" oculta en el control remoto en el que todo gira y un montón de todo tipo de convertidores).  El sistema tiene varios modos de controlar el movimiento de los shtankets.  Manual y "modo script".  Sobre el "modo de escenario" se discutirá más a fondo, y ahora un poco sobre el "modo manual".  En este modo, el operador selecciona el vástago deseado, lo prepara para el movimiento (conecta el motor al inversor), establece la marca (posición objetivo) para el vástago y tan pronto como establece la velocidad mayor que cero, los vástagos comienzan a moverse.  Para establecer la velocidad, se usa un ajustador físico especial, en forma de un "potenciómetro con una perilla", pero también hay un "ajustador de pantalla" de velocidad.  Cuanto más "convertido", el <del>  mas fuerte </del>  va más rápido  La velocidad máxima está limitada a 1,5 m / s.  Perilla de velocidad: una para todos.  Es decir  En modo manual, todas las bandejas conectadas por el operador se mueven a la misma velocidad establecida.  Aunque pueden moverse en diferentes direcciones (depende de dónde los dirigió el operador).  Por supuesto, es difícil para una persona hacer un seguimiento de más de dos o tres canastas al mismo tiempo, por lo que generalmente no se mueven mucho en modo manual.  Desde dos estaciones, los operadores pueden gestionar simultáneamente cada uno de sus shtankets.  Además, cada consola (operador) tiene su propio controlador de velocidad. </p><br><p>  Desde el punto de vista de la implementación, el modo manual no contiene ninguna lógica especial.  El comando para conectar el motor proviene de la interfaz gráfica, se convierte en un mensaje para el actor correspondiente, que trabaja en él.  Al pasar por los estados "apagado" -&gt; "conexión" -&gt; "conectado".  Lo mismo con establecer la posición para el movimiento del stunket y establecer la velocidad.  Todos estos eventos llegan al actor en forma de mensajes a los que reacciona.  A menos que se pueda observar que la interfaz gráfica y el proceso de control en sí son procesos diferentes y entre ellos hay una interacción "interproceso" a través de los "sensores" que usan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">libuniset2</a> . </p><br><h2 id="rezhim-ispolneniya-scenariya-opyat-eti-aktory">  Modo de ejecución de script (de nuevo, ¿estos actores?) </h2><br><p>  De hecho, el modo de control manual se usa principalmente para pasar el rato durante los ensayos o en casos simples.  El modo principal en el que el control está en progreso es "modo de ejecución de script" o, brevemente, "modo de script".  En este modo, cada shtank se mueve a su punto con los parámetros especificados en el script (velocidad y marca de objetivo).  Para el operador, el control en este modo consta de dos comandos simples: </p><br><ul><li>  prepárate (el grupo correcto de motores están conectados) </li><li>  vamos (el grupo comienza a moverse a las posiciones de destino establecidas para cada uno). </li></ul><br><p>  Todo el escenario se divide en las llamadas "agendas".  Una agenda es un movimiento de un grupo shtanket.  Es decir  cada agenda incluye un grupo de shtankets, con la velocidad objetivo y la marca a la que necesita llegar.  De hecho, el guión se divide en actos, los actos se dividen en pinturas, las pinturas se dividen en citaciones y las citaciones ya consisten en "objetivos" para tiendas específicas.  Pero desde el punto de vista de la administración, esta división no es importante, porque  Es en la agenda que los parámetros específicos de movimiento se indican al final. </p><br><p>  Para implementar este régimen, el sistema de actores volvió a surgir lo mejor posible.  Se desarrolló un "reproductor de guiones" que crea un grupo de actores especiales y los lanza.  Hemos desarrollado dos tipos de actores: actores-actores, diseñados para realizar tareas para un shtanket específico, y un actor-coordinador, que distribuye las tareas entre los artistas.  Además, los actores interpretativos se crean según sea necesario, si en el momento del próximo equipo no es gratuito.  El actor coordinador es responsable de crear y mantener el grupo de actores escénicos.  Como resultado, la administración se ve así: </p><br><ul><li>  declaración carga el script </li><li>  Lo "voltea" a la agenda deseada (generalmente solo va en una fila). </li><li>  en el momento correcto, presiona el botón "preparar", mediante el cual se envía un comando (mensaje) al actor coordinador para cada formulario incluido en la agenda actual con parámetros de movimiento. </li><li>  El coordinador de actores analiza su grupo de actores que actúan libremente, toma uno libre (si no crea uno nuevo) y le asigna una tarea (número de mantillas y parámetros de movimiento). </li><li>  Cada actor-actor que ha recibido la tarea comienza a cumplir el comando "prepararse".  Es decir  conecta el motor y entra en el modo de espera del comando "ir". </li><li>  cuando llega el momento, el operador da el comando "vamos" </li><li>  el equipo "ir" viene al coordinador.  Se lo envía a todos sus artistas actualmente activos y comienzan la "ejecución". </li></ul><br><p>  Vale la pena señalar que en la agenda hay parámetros adicionales.  Por ejemplo, inicie el movimiento con un retraso de N segundos o inicie el movimiento solo después de un comando de operador especial por separado.  Por lo tanto, la lista de estados para cada actor es bastante grande: "listo para ejecutar el siguiente comando", "listo para moverse", "movimiento retrasado", "esperando el comando del operador", "movimiento", "ejecución completada", "mal funcionamiento" . </p><br><p>  Después de que el vástago alcanzó con éxito (o no) la marca especificada, el actor-intérprete notifica al coordinador la tarea completada.  El coordinador da la orden de apagar este motor (si ya no participa en la agenda actual) o emite nuevos parámetros de movimiento.  A su vez, el actor-intérprete recibió una orden para apagar el motor, lo apaga y pasa a un estado de espera de nuevas órdenes, o comienza a ejecutar una nueva orden. </p><br><p>  Debido al hecho de que el sobjectizer tiene una API bien pensada y conveniente para trabajar con estados, el código de implementación es bastante conciso.  Por ejemplo, el retraso en el movimiento se describe en una línea: </p><br><pre> <code class="cpp hljs">st_delay.time_limit( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds{target-&gt;delay()}, st_moving ); st_delay.activate(); ...</code> </pre><br><p>  La función time_limit establece un límite de tiempo sobre cuánto se puede gastar en un estado dado y qué estado se debe pasar después de un tiempo específico (st_moving). </p><br><h2 id="aktory-zaschity">  Actores de protección </h2><br><p>  Por supuesto, durante la operación, pueden ocurrir fallos de funcionamiento.  Se requiere el sistema para manejar estas situaciones.  Aquí, también, había un lugar para el uso de actores.  Considere varias de estas protecciones: </p><br><ul><li>  sobre la protección actual </li><li>  protección de falla de medición </li><li>  protección contra el movimiento en la dirección opuesta (y esto puede ser, si algo está mal con el sensor o el medidor) </li><li>  protección contra movimiento sin comando </li><li>  control de la ejecución del equipo (control de que el shtanket comenzó a moverse) </li></ul><br><p>  Puede ver que todas estas protecciones son independientes (autosuficientes) desde el punto de vista de la implementación, y deberían funcionar "en paralelo".  Es decir  Cualquier condición puede funcionar.  Al mismo tiempo, la lógica de verificar las condiciones de activación para cada una de las protecciones tiene la suya, a veces se requiere un retraso (temporizador) para la activación, a veces se requiere un procesamiento preliminar de varias mediciones anteriores, etc.  Por lo tanto, la implementación de cada tipo de protección como un pequeño actor separado resultó ser muy conveniente.  Todos estos actores se lanzan además (en cooperación) del actor principal que implementa la lógica de control.  Este enfoque hace que sea fácil agregar tipos adicionales de defensas simplemente agregando otro actor al grupo.  Al mismo tiempo, la implementación de tal actor sigue siendo bastante fácil y comprensible, porque  Implementa solo una función. </p><br><p>  Los actores de protección también tienen varios estados.  Básicamente se encienden (entran en el estado "encendido") solo cuando el motor está conectado o el vástago está en movimiento.  Cuando se activan las condiciones de protección, publican una notificación sobre la protección que se está activando (con un código de seguridad y algunos detalles para el registro), el actor principal ya responde a esta notificación, que, si es necesario, apaga el motor y cambia al modo de protección. </p><br><h2 id="v-kachestve-vyvoda">  Como conclusión ... </h2><br><p>  ... por supuesto, este artículo no es una especie de "descubrimiento".  El enfoque del actor se ha utilizado con éxito en muchos sistemas.  Pero para mí fue la primera experiencia de usar conscientemente el enfoque del actor para construir algoritmos de sistemas de control en un proyecto relativamente pequeño.  Y la experiencia fue bastante exitosa.  Espero haber podido demostrar que los actores están muy bien superpuestos a los algoritmos de control, encontraron un lugar literalmente en todas partes. </p><br><p>  Según la experiencia de proyectos anteriores, estaba claro que de una forma u otra estábamos implementando "algo así" (estados, mensajes, control de flujo, etc.), pero este no era un enfoque unificado.  Usando el sobjectizer obtuvimos una herramienta de desarrollo concisa y liviana que tiene muchos problemas.  Ya no es necesario (explícito) usar herramientas de sincronización (mutexes, etc.), no hay trabajo explícito con flujos, ni realizaciones de la máquina de estados.  Todo esto está en el marco, lógicamente interconectado y presentado como una API conveniente, además, sin perder el control sobre los detalles.  Entonces la experiencia fue interesante.  Para aquellos que aún dudan, recomiendo prestar atención al enfoque del actor y al marco del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sobjectizer</a> en particular.  Deja emociones positivas. </p><br><p>  ¡Y el enfoque del actor realmente funciona!  Especialmente en el teatro. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/438196/">https://habr.com/ru/post/438196/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../438178/index.html">Creando su primera aplicación ARCore</a></li>
<li><a href="../438180/index.html">Registre una transacción de bienes raíces en línea</a></li>
<li><a href="../438182/index.html">El estudio encontró los beneficios de la piratería moderada para los productores y distribuidores de contenido.</a></li>
<li><a href="../438188/index.html">Bill gates y reactor de sodio rápido</a></li>
<li><a href="../438190/index.html">¿Cuáles son los procedimientos de adquisición (en palabras simples)</a></li>
<li><a href="../438198/index.html">Profundicemos en la historia: ¿dónde crecen las patas de los cuadricópteros?</a></li>
<li><a href="../438202/index.html">JavaScript: Campos de clase públicos y privados</a></li>
<li><a href="../438204/index.html">Dispositivo compilador rápido. Parte 1</a></li>
<li><a href="../438206/index.html">26 recomendaciones para usar el tipo var en Java</a></li>
<li><a href="../438210/index.html">Civilización de Springs, 2/5</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>