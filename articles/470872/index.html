<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüîß üßùüèª üë¶üèΩ M√©tricas de rendimiento para investigar aplicaciones web incre√≠blemente r√°pidas ü§üüèø ü§µüèø üö¥üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hay un dicho: "Lo que no puedes medir, no puedes mejorar". El autor del art√≠culo, cuya traducci√≥n publicamos hoy, trabaja para Superhuman . √âl dice qu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>M√©tricas de rendimiento para investigar aplicaciones web incre√≠blemente r√°pidas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/470872/">  Hay un dicho: "Lo que no puedes medir, no puedes mejorar".  El autor del art√≠culo, cuya traducci√≥n publicamos hoy, trabaja para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Superhuman</a> .  √âl dice que esta compa√±√≠a est√° desarrollando el cliente de correo electr√≥nico m√°s r√°pido del mundo.  Aqu√≠ hablaremos sobre lo que es "r√°pido" y c√≥mo crear herramientas para medir el rendimiento de aplicaciones web incre√≠blemente r√°pidas. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/q6/af/pp/q6afppxtd4rv6r-iqwvk9-6nyai.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Aplicaci√≥n de medici√≥n de velocidad</font> </h2><br>  En un esfuerzo por mejorar nuestro desarrollo, pasamos mucho tiempo midiendo su velocidad.  Y, como result√≥, las m√©tricas de rendimiento son indicadores que son sorprendentemente dif√≠ciles de entender y aplicar. <br><br>  Por un lado, es dif√≠cil dise√±ar m√©tricas que describan con precisi√≥n las sensaciones que experimenta el usuario mientras trabaja con el sistema.  Por otro lado, no es f√°cil crear m√©tricas que sean tan precisas que su an√°lisis le permita tomar decisiones informadas.  Como resultado, muchos equipos de desarrollo no pueden confiar en los datos que recopilan sobre el desempe√±o de sus proyectos. <br><br>  Incluso si los desarrolladores tienen m√©tricas confiables y precisas, usarlas no es f√°cil.  ¬øC√≥mo definir el t√©rmino "r√°pido"?  ¬øC√≥mo encontrar un equilibrio entre velocidad y consistencia?  ¬øC√≥mo aprender a detectar r√°pidamente la degradaci√≥n del rendimiento o aprender a evaluar el impacto de las optimizaciones en el sistema? <br><br>  Aqu√≠ queremos compartir algunas ideas sobre el desarrollo de herramientas de an√°lisis de rendimiento de aplicaciones web. <br><br><h2>  <font color="#3AC1EF">1. Usando el "reloj" correcto</font> </h2><br>  JavaScript tiene dos mecanismos para recuperar marcas de tiempo: <code>performance.now()</code> y <code>new Date()</code> . <br><br>  ¬øC√≥mo se diferencian?  Las siguientes dos diferencias son fundamentales para nosotros: <br><br><ul><li>  El m√©todo <code>performance.now()</code> es mucho m√°s preciso.  La precisi√≥n de la <code>new Date()</code> construcci√≥n <code>new Date()</code> es de ¬± 1 ms, mientras que la precisi√≥n de <code>performance.now()</code> ya es de ¬± 100 ¬µs (s√≠, ¬°se trata de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">microsegundos</a> !). </li><li>  Los valores devueltos por el m√©todo <code>performance.now()</code> siempre aumentan a una velocidad constante y son independientes de la hora del sistema.  Este m√©todo simplemente mide intervalos de tiempo sin enfocarse en el tiempo del sistema.  Y en la <code>new Date()</code> afecta la hora <code>new Date()</code> sistema.  Si reorganiza el reloj del sistema, tambi√©n cambiar√° lo que devuelve la <code>new Date ()</code> , y esto arruinar√° los datos de monitoreo del rendimiento. </li></ul><br>  Aunque los "relojes" representados por el m√©todo <code>performance.now()</code> obviamente son mucho m√°s adecuados para medir intervalos de tiempo, tampoco son ideales.  Tanto <code>performance.now()</code> como <code>new Date()</code> sufren el mismo problema, que se manifiesta en el caso de que el sistema est√© en estado de suspensi√≥n: las mediciones incluyen el momento en que la m√°quina ni siquiera estaba activa. <br><br><h2>  <font color="#3AC1EF">2. Comprobaci√≥n de la actividad de la aplicaci√≥n</font> </h2><br>  Si, midiendo el rendimiento de una aplicaci√≥n web, cambia de su pesta√±a a otra, esto interrumpir√° el proceso de recopilaci√≥n de datos.  Por qu√©  El hecho es que el navegador restringe las aplicaciones ubicadas en las pesta√±as de fondo. <br><br>  Hay dos situaciones en las que las m√©tricas pueden estar distorsionadas.  Como resultado, la aplicaci√≥n parecer√° mucho m√°s lenta de lo que realmente es. <br><br><ol><li>  La computadora entra en modo de suspensi√≥n. </li><li>  La aplicaci√≥n se ejecuta en la pesta√±a de fondo del navegador. </li></ol><br>  La ocurrencia de ambas situaciones no es infrecuente.  Afortunadamente, tenemos dos opciones para resolverlos. <br><br>  Primero, simplemente podemos ignorar las m√©tricas distorsionadas, descartando los resultados de medici√≥n que difieren demasiado de algunos valores razonables.  Por ejemplo, el c√≥digo que se llama cuando se presiona un bot√≥n simplemente no se puede ejecutar durante 15 minutos.  Quiz√°s esto es lo √∫nico que necesita para lidiar con los dos problemas descritos anteriormente. <br><br>  En segundo lugar, puede usar la propiedad <code>document.hidden</code> y el evento de cambio de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">visibilidad</a> .  El evento de cambio de <code>visibilitychange</code> se genera cuando el usuario cambia de la pesta√±a de inter√©s del navegador a otra pesta√±a o vuelve a la pesta√±a de inter√©s para nosotros.  Se llama cuando la ventana del navegador minimiza o maximiza cuando la computadora comienza a funcionar, saliendo del modo de suspensi√≥n.  En otras palabras, esto es exactamente lo que necesitamos.  Adem√°s, siempre que la pesta√±a est√© en segundo plano, la propiedad <code>document.hidden</code> es <code>true</code> . <br><br>  Aqu√≠ hay un ejemplo simple que demuestra el uso de la propiedad <code>document.hidden</code> y el evento de cambio de <code>visibilitychange</code> . <br><br><pre> <code class="plaintext hljs">let lastVisibilityChange = 0 window.addEventListener('visibilitychange', () =&gt; {  lastVisibilityChange = performance.now() }) //    ,      , //  ,   ,     if (metric.start &lt; lastVisibilityChange || document.hidden) return</code> </pre> <br>  Como puede ver, descartamos algunos datos, pero esto es bueno.  El hecho es que se trata de datos relacionados con esos per√≠odos del programa en los que no puede utilizar completamente los recursos del sistema. <br><br>  Ahora hablamos de indicadores que no nos interesan.  Pero hay muchas situaciones, los datos recopilados son muy interesantes para nosotros.  Veamos c√≥mo recopilar estos datos. <br><br><h2>  <font color="#3AC1EF">3. Busque el indicador que le permite capturar mejor la hora en que comenz√≥ el evento</font> </h2><br>  Una de las caracter√≠sticas m√°s controvertidas de JavaScript es que el bucle de eventos para este lenguaje es de un solo subproceso.  En cierto momento, solo una pieza de c√≥digo es capaz de ejecutarse, cuya ejecuci√≥n no puede ser interrumpida. <br><br>  Si el usuario presiona el bot√≥n mientras ejecuta un c√≥digo determinado, el programa no lo sabr√° hasta que se complete la ejecuci√≥n de este c√≥digo.  Por ejemplo, si la aplicaci√≥n pas√≥ 1000 ms en un ciclo continuo y el usuario presion√≥ el bot√≥n <code>Escape</code> 100 ms despu√©s del inicio del ciclo, el evento no se registrar√° durante otros 900 ms. <br><br>  Esto puede distorsionar severamente las m√©tricas.  Si necesitamos precisi√≥n para medir exactamente c√≥mo el usuario percibe trabajar con el programa, ¬°entonces este es un gran problema! <br><br>  Afortunadamente, resolver este problema no es tan dif√≠cil.  Si estamos hablando del evento actual, entonces podemos, en lugar de usar <code>performance.now()</code> (el momento en que vimos el evento), usar <code>window.event.timeStamp</code> (el momento en que se cre√≥ el evento). <br><br>  La marca de tiempo del evento se establece mediante el proceso del navegador principal.  Dado que este proceso no se bloquea cuando el bucle de eventos JS est√° bloqueado, <code>event.timeStamp</code> nos brinda informaci√≥n mucho m√°s valiosa sobre cu√°ndo se <code>event.timeStamp</code> el evento. <br><br>  Cabe se√±alar que este mecanismo no es ideal.  Entonces, entre el momento en que se presiona el bot√≥n f√≠sico y el momento en que el evento correspondiente llega a Chrome, transcurren entre 9 y 15 ms de tiempo no contabilizado ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠ hay un</a> excelente art√≠culo del que puede aprender por qu√© sucede esto). <br><br>  Sin embargo, incluso si podemos medir el tiempo que tarda el evento en llegar a Chrome, no deber√≠amos incluir este tiempo en nuestras m√©tricas.  Por qu√©  El hecho es que no podemos introducir tales optimizaciones en el c√≥digo que puedan afectar significativamente dichos retrasos.  No podemos mejorarlos de ninguna manera. <br><br>  Como resultado, si hablamos de encontrar la marca de tiempo para el inicio del evento, entonces el indicador <code>event.timeStamp</code> ve m√°s adecuado aqu√≠. <br><br>  ¬øCu√°l es la mejor estimaci√≥n de cu√°ndo termina el evento? <br><br><h2>  <font color="#3AC1EF">4. Apague el temporizador en requestAnimationFrame ()</font> </h2><br>  Una consecuencia m√°s se deduce de las caracter√≠sticas del dispositivo de bucle de eventos en JavaScript: algunos c√≥digos que no est√°n relacionados con su c√≥digo pueden ejecutarse despu√©s, pero antes de que el navegador muestre una versi√≥n actualizada de la p√°gina en la pantalla. <br><br>  Considere, por ejemplo, React.  Despu√©s de ejecutar su c√≥digo, React actualiza el DOM.  Si solo mide el tiempo en su c√≥digo, significa que no medir√° el tiempo que llev√≥ ejecutar el c√≥digo React. <br><br>  Para medir este tiempo extra, usamos <code>requestAnimationFrame()</code> para apagar el temporizador.  Esto se hace solo cuando el navegador est√° listo para generar el siguiente fotograma. <br><br><pre> <code class="plaintext hljs">requestAnimationFrame(() =&gt; { metric.finish(performance.now()) })</code> </pre> <br>  Aqu√≠ est√° el ciclo de vida del marco (el diagrama est√° tomado de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> maravilloso material bajo <code>requestAnimationFrame</code> ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/403/439/0d4/4034390d4dd3060d8653bf03d72d4ca2.png"></div><br>  <i><font color="#999999">Ciclo de vida del marco</font></i> <br><br>  Como puede ver en esta figura, se llama a <code>requestAnimationFrame()</code> despu√©s de completar el procesador, justo antes de que se muestre el marco.  Si apagamos el temporizador aqu√≠, significa que podemos estar absolutamente seguros de que todo lo que se tom√≥ el tiempo para actualizar la pantalla se incluye en los datos recopilados en el intervalo de tiempo. <br><br>  Hasta ahora todo bien, pero ahora la situaci√≥n se est√° volviendo bastante complicada ... <br><br><h2>  <font color="#3AC1EF">5. Ignorando el tiempo requerido para crear un dise√±o de p√°gina y su visualizaci√≥n.</font> </h2><br>  El diagrama anterior, que muestra el ciclo de vida de un marco, ilustra otro problema que encontramos.  Al final del ciclo de vida del marco, hay bloques de Dise√±o (formando un dise√±o de p√°gina) y Pintura (mostrando una p√°gina).  Si no tiene en cuenta el tiempo requerido para completar estas operaciones, el tiempo medido por nosotros ser√° inferior al tiempo que tardan en aparecer algunos datos actualizados en la pantalla. <br><br>  Afortunadamente, <code>requestAnimationFrame</code> tiene otro as bajo la manga.  Cuando <code>requestAnimationFrame</code> llama a la funci√≥n pasada por <code>requestAnimationFrame</code> , se pasa una marca de tiempo a esta funci√≥n, que indica el tiempo de inicio de la formaci√≥n del marco actual (es decir, el que se encuentra en la parte izquierda de nuestro diagrama).  Esta marca de tiempo suele estar muy cerca de la hora de finalizaci√≥n del fotograma anterior. <br><br>  Como resultado, el inconveniente anterior se puede corregir midiendo el tiempo total transcurrido desde el momento del <code>event.timeStamp</code> hasta el momento en que comienza la formaci√≥n del siguiente cuadro.  Tenga en cuenta el <code>requestAnimationFrame</code> anidado: <br><br><pre> <code class="plaintext hljs">requestAnimationFrame(() =&gt; {  requestAnimationFrame((timestamp) =&gt; { metric.finish(timestamp) }) })</code> </pre> <br>  Aunque lo que se muestra arriba parece una excelente soluci√≥n al problema, al final, decidimos no usar este dise√±o.  El hecho es que, aunque esta t√©cnica permite obtener datos m√°s confiables, la precisi√≥n de dichos datos se reduce.  Los marcos en Chrome se forman con una frecuencia de 16 ms.  Esto significa que la mayor precisi√≥n disponible para nosotros es de ¬± 16 ms.  Y si el navegador est√° sobrecargado y omite fotogramas, la precisi√≥n ser√° a√∫n menor y este deterioro ser√° impredecible. <br><br>  Si implementa esta soluci√≥n, una mejora importante en el rendimiento de su c√≥digo, como acelerar una tarea que se realiz√≥ anteriormente 32 ms, hasta 15 ms, puede no afectar los resultados de la medici√≥n del rendimiento. <br><br>  Sin tener en cuenta el tiempo requerido para crear un dise√±o de p√°gina y su salida, obtenemos m√©tricas mucho m√°s precisas (¬± 100 Œºs) para el c√≥digo que est√° bajo nuestro control.  Como resultado, podemos obtener una expresi√≥n num√©rica de cualquier mejora realizada en este c√≥digo. <br><br>  Tambi√©n exploramos una idea similar: <br><br><pre> <code class="plaintext hljs">requestAnimationFrame(() =&gt; {  setTimeout(() =&gt; { metric.finish(performance.now()) } })</code> </pre> <br>  Esto incluir√° el tiempo de renderizado, pero la precisi√≥n del indicador no se limitar√° a ¬± 16 ms.  Sin embargo, decidimos no usar este enfoque tampoco.  Si el sistema encuentra un evento de entrada largo, la llamada a qu√© <code>setTimeout</code> transmite puede retrasarse y ejecutarse significativamente despu√©s de actualizar la interfaz de usuario. <br><br><h2>  <font color="#3AC1EF">6. Aclaraci√≥n del "porcentaje de eventos que est√°n por debajo del objetivo"</font> </h2><br>  Estamos desarrollando un proyecto y centr√°ndonos en el alto rendimiento, tratando de optimizarlo de dos maneras: <br><br><ol><li>  Velocidad.  El tiempo de ejecuci√≥n de la tarea m√°s r√°pida debe ser lo m√°s cercano posible a 0 ms. </li><li>  Uniformidad  El tiempo de ejecuci√≥n de la tarea m√°s lenta debe ser lo m√°s cercano posible al tiempo de ejecuci√≥n de la tarea m√°s r√°pida. </li></ol><br>  Debido al hecho de que estos indicadores cambian con el tiempo, son dif√≠ciles de visualizar y no f√°ciles de discutir.  ¬øEs posible crear un sistema de visualizaci√≥n de tales indicadores que nos inspire a optimizar tanto la velocidad como la uniformidad? <br><br>  Un enfoque t√≠pico es medir el percentil 90 de retraso.  Este enfoque le permite dibujar un gr√°fico lineal a lo largo del eje Y del cual se guarda el tiempo en milisegundos.  Este gr√°fico le permite ver que el 90% de los eventos est√°n debajo del gr√°fico lineal, es decir, se ejecutan m√°s r√°pido que el tiempo que indica el gr√°fico lineal. <br><br>  Se sabe que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">100 ms</a> es el l√≠mite entre lo que se percibe como "r√°pido" y "lento". <br><br>  Pero, ¬øqu√© descubriremos acerca de c√≥mo se sienten los usuarios del trabajo si sabemos que el percentil 90 de retraso es de 103 ms?  No particularmente mucho.  ¬øQu√© indicadores proporcionar√°n a los usuarios usabilidad?  No hay forma de saber esto con seguridad. <br><br>  Pero, ¬øqu√© pasa si sabemos que el percentil 90 de retraso es de 93 ms?  Existe la sensaci√≥n de que 93 es mejor que 103, pero no podemos decir nada m√°s acerca de estos indicadores, as√≠ como de lo que significan en t√©rminos de percepci√≥n del usuario del proyecto.  Nuevamente, no hay una respuesta exacta a esta pregunta. <br><br>  Hemos encontrado una soluci√≥n a este problema.  Consiste en medir el porcentaje de eventos cuyo tiempo de ejecuci√≥n no supera los 100 ms.  Hay tres grandes ventajas de este enfoque: <br><br><ul><li>  La m√©trica est√° orientada al usuario.  Puede decirnos qu√© porcentaje de tiempo nuestra aplicaci√≥n es r√°pida y qu√© porcentaje de usuarios la perciben como r√°pida. </li><li>  Esta m√©trica nos permite devolver las mediciones a la precisi√≥n que se perdi√≥ debido al hecho de que no medimos el tiempo necesario para completar las tareas al final del marco (hablamos de esto en la secci√≥n No. 5).  Debido al hecho de que establecemos un indicador de objetivo que se ajusta en varios cuadros, los resultados de medici√≥n que est√°n cerca de este indicador resultan ser menores o mayores. </li><li>  Esta m√©trica es m√°s f√°cil de calcular.  Es suficiente calcular simplemente el n√∫mero de eventos cuyo tiempo de ejecuci√≥n est√° por debajo del indicador de destino, y despu√©s de eso, dividirlos por el n√∫mero total de eventos.  Los percentiles son mucho m√°s dif√≠ciles de contar.  Hay aproximaciones efectivas, pero para hacer todo bien, debe tener en cuenta cada dimensi√≥n. </li></ul><br>  Este enfoque tiene solo una desventaja: si los indicadores son peores que el objetivo, entonces no ser√° f√°cil notar su mejora. <br><br><h2>  <font color="#3AC1EF">7. El uso de varios valores umbral en el an√°lisis de indicadores.</font> </h2><br>  Para visualizar el resultado de la optimizaci√≥n del rendimiento, introdujimos varios valores de umbral adicionales en nuestro sistema, por encima de 100 ms y por debajo. <br><br>  Agrupamos los retrasos as√≠: <br><br><ul><li>  Menos de 50 ms (r√°pido). </li><li>  50 a 100 ms (bien). </li><li>  100 a 1000 ms (lento). </li><li>  M√°s de 1000 ms (terriblemente lento). </li></ul><br>  Los resultados "terriblemente lentos" nos permiten ver que nos hemos perdido mucho en alguna parte.  Por lo tanto, los resaltamos en rojo brillante. <br><br>  Lo que cabe en 50 ms es muy sensible a los cambios.  Aqu√≠, las mejoras de rendimiento a menudo son visibles mucho antes de que se puedan ver en un grupo que corresponde a 100 ms. <br><br>  Por ejemplo, el siguiente gr√°fico visualiza el rendimiento de la visualizaci√≥n de subprocesos en Superhuman. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb5/773/9e8/eb57739e82476e3b7a2c9212908ff5bf.png"></div><br>  <i><font color="#999999">Ver hilo</font></i> <br><br>  Muestra el per√≠odo de disminuci√≥n del rendimiento y, luego, los resultados de las mejoras.  Es dif√≠cil evaluar la ca√≠da del rendimiento si observa solo los indicadores correspondientes a 100 ms (las partes superiores de las columnas azules).  Al observar los resultados que se ajustan a 50 ms (las partes superiores de las columnas verdes), los problemas de rendimiento ya son visibles mucho m√°s claramente. <br><br>  Si utilizamos el enfoque tradicional para el estudio de las m√©tricas de rendimiento, probablemente no habr√≠amos notado un problema cuyo efecto en el sistema se muestra en la figura anterior.  Pero gracias a la forma en que tomamos medidas y la forma en que visualizamos nuestras m√©tricas, pudimos encontrar y resolver un problema muy r√°pidamente. <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  Result√≥ que era sorprendentemente dif√≠cil encontrar el enfoque correcto para trabajar con m√©tricas de rendimiento.  Logramos desarrollar una metodolog√≠a que nos permite crear herramientas de alta calidad para medir el rendimiento de las aplicaciones web.  A saber, estamos hablando de lo siguiente: <br><br><ol><li>  El tiempo de inicio de un evento se mide usando <code>event.timeStamp</code> . </li><li>  El tiempo de finalizaci√≥n del evento se mide usando <code>performance.now()</code> en la devoluci√≥n de llamada pasada a <code>requestAnimationFrame()</code> . </li><li>  Todo lo que sucede con la aplicaci√≥n mientras est√° en la pesta√±a inactiva del navegador se ignora. </li><li>  Los datos se agregan utilizando un indicador, que se puede describir como "el porcentaje de eventos que est√°n por debajo del objetivo". </li><li>  Los datos se visualizan con varios niveles de valores umbral. </li></ol><br>  Esta t√©cnica le brinda las herramientas para crear m√©tricas confiables y precisas.  Puede crear gr√°ficos que muestren claramente una ca√≠da en el rendimiento, puede visualizar los resultados de las optimizaciones.  Y lo m√°s importante: tiene la oportunidad de hacer proyectos r√°pidos a√∫n m√°s r√°pido. <br><br>  <b>Estimados lectores!</b>  ¬øC√≥mo analiza el rendimiento de sus aplicaciones web? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/470872/">https://habr.com/ru/post/470872/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../470856/index.html">Telegram GRAM Wallet: t√©rminos de servicio</a></li>
<li><a href="../470858/index.html">Antig√ºedades: punto de referencia del 386 ¬∞ procesador y de los elegantes noventa</a></li>
<li><a href="../470864/index.html">Sobre las delicias de cambiar al panel y no solo</a></li>
<li><a href="../470868/index.html">Tiempo para el primer byte: qu√© es y por qu√© es importante</a></li>
<li><a href="../470870/index.html">Precarga de fuentes</a></li>
<li><a href="../470874/index.html">Optimizando la carga de JavaScript en Wikipedia</a></li>
<li><a href="../470876/index.html">Cree construcciones de sintaxis JavaScript personalizadas con Babel. Parte 1</a></li>
<li><a href="../470878/index.html">Cree construcciones de sintaxis JavaScript personalizadas con Babel. Parte 2</a></li>
<li><a href="../470880/index.html">Mec√°nica del juego. Aventura, el concepto de terapia del habla cero y convincente</a></li>
<li><a href="../470882/index.html">¬øPor qu√© atrapaste mi mouse o un juego de mesa como modelo de interacci√≥n social?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>