<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçüöí üë©‚Äçüë©‚Äçüëß‚Äçüë¶ üìè Hitachi muriendo duro, golpe y tecno-necrofilia üë©üèø ü§î üßöüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Precauci√≥n: la soluci√≥n descrita en este art√≠culo no es profesional, puede haberse creado sobre la base de un malentendido de la estructura y los prin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hitachi muriendo duro, golpe y tecno-necrofilia</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481952/"><p>  Precauci√≥n: la soluci√≥n descrita en este art√≠culo no es profesional, puede haberse creado sobre la base de un malentendido de la estructura y los principios de funcionamiento de los discos duros.  La repetici√≥n de los pasos anteriores puede da√±ar el equipo. </p><br><p>  Recientemente me encontr√© con un <a href="https://habr.com/ru/post/443612/">art√≠culo</a> sobre el uso de discos duros viejos con bloques defectuosos y pens√© que mi experiencia tambi√©n podr√≠a ser interesante para alguien. </p><br><p>  Una vez, algunos conocidos me pidieron que ayudara a manejar una computadora port√°til en la que no pod√≠an reinstalar Windows.  La computadora port√°til, a juzgar por la apariencia, tuvo una vida dif√≠cil: grietas en el estuche, esquinas abolladas, bastidores rotos.  Est√° claro que el problema es el da√±o en el disco duro como resultado de numerosos golpes, lo que tambi√©n fue confirmado por smart: m√°s de 200 operaciones de sensores G, 500 recuentos de sectores reasignados y todav√≠a hay en curso pendiente.  Bueno, la gente, por supuesto, instal√© el SSD y copi√© la informaci√≥n de su tornillo en la imagen con el comando: </p><br><pre><code class="bash hljs">dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=/dev/sdb of=/media/hddimages/ht320.img bs=409600 conv=noerror,notrunc,sync</code> </pre> <br><p><a name="habracut"></a>  Los par√°metros "conv = noerror, notrunc, sync" son necesarios para que en caso de errores en la lectura de ciertos sectores, los ceros se escriban en estas direcciones en el archivo de salida, y los datos se escriban en su lugar sin sesgo. </p><br><p>  Sucede que cuando se lee en bloques grandes (400 kb), el disco no lee todo el bloque, y los m√°s peque√±os no leen solo 1 sector.  Los sectores aqu√≠ son de 4kb, as√≠ que despu√©s de la primera pasada de dd, si hubo errores de lectura, intento leer estas secciones nuevamente en bloques de 4kb: </p><br><pre> <code class="bash hljs">n=&lt;&gt;;dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=/dev/sdb of=/media/hddimages/ht320.img bs=4096 conv=noerror,notrunc,sync skip=<span class="hljs-variable"><span class="hljs-variable">$n</span></span> seek=<span class="hljs-variable"><span class="hljs-variable">$n</span></span> count=100</code> </pre> <br><p>  Los par√°metros de salto y b√∫squeda son necesarios para que la lectura y la escritura comiencen con la misma sangr√≠a desde el comienzo del disco.  La sangr√≠a en s√≠ se toma de la salida de la primera ejecuci√≥n dd, solo para que coincida con el tama√±o del bloque, multiplique el n√∫mero por 100. </p><br><p>  A veces, cuando se accede a sectores defectuosos, los discos se congelan durante mucho tiempo, tanto que solo la reconexi√≥n a la alimentaci√≥n el√©ctrica ayuda y hace unos 5 a√±os se cre√≥ un complejo de hardware y software (incluso con un microcontrolador) para automatizar la lectura de los discos duros defectuosos con reconexi√≥n autom√°tica de energ√≠a en caso de que tambi√©n Una larga falta de respuesta.  Fue interesante y permitido, al conectar el disco duro e ingresar el comando, despu√©s de 10 d√≠as para obtener la imagen m√°s completa.  Pero el h√©roe experimental del art√≠culo no se aferr√≥, por lo que no hubo necesidad de obtener la muleta pesada descrita. </p><br><p>  Por lo tanto, se consider√≥ el disco, mont√© todas las secciones de la imagen a trav√©s de la configuraci√≥n con desplazamiento del comienzo de las particiones desde fdisk, multiplicado por el tama√±o del bloque l√≥gico en mbr - 512 bytes, copio todos los datos a las personas en un nuevo SSD.  Si el disco no estuviera montado o no se pudieran leer muchos archivos, abrir√≠a la imagen con R-Studio y la restaurar√≠a a trav√©s de √©l, pero desde la imagen misma. </p><br><p>  Pero lo dif√≠cil, aunque es derrotado, es una pena tirarlo, as√≠ que decid√≠ reanimarlo de alguna manera.  Te√≥ricamente, el controlador de disco marca los sectores como da√±ados y reasigna los sectores de respaldo a sus direcciones en caso de repetidos intentos fallidos de escritura o errores de lectura irrecuperables (usando ECC). </p><br><p>  Primero trato de borrar el disco (dd if = / dev / zero ...) y leer despu√©s de eso: la velocidad tambi√©n es inestable, el disco se congela y a veces se produce un error de entrada / salida, pero en el sistema inteligente aumenta el n√∫mero de reenganches y pendientes.  Despu√©s de varios ciclos, el inteligente no cambi√≥ mucho, los pendientes no se reubicaron y los errores se cuelgan cada vez en los mismos lugares o muy cerca.  Intento reasignar a la fuerza manualmente con el comando "hdparm --make-bad-sector", pero esto no funciona en este modelo y me doy cuenta de que solo borrar-leer, as√≠ como escribir-leer, no podr√° mostrar todas las √°reas problem√°ticas.  De hecho, si un bit da√±ado, independientemente de lo que intentaron escribirle, es m√°s probable que se lea como "1", entonces, al escribirlo, "1", la lectura posterior tendr√° lugar sin errores, pero al escribir un patr√≥n diferente, puede existen suficientes inconsistencias para que el ECC falle y se produzca un error de lectura irreparable, y despu√©s de varios de estos casos, el sector recibi√≥ el estado de "Malo".  Por cierto, el valor registrado puede superponerse tanto en la distribuci√≥n de bits da√±ados que un valor incorrecto de lectura incluso satisfar√° el ECC.  Por lo tanto, para maximizar la identificaci√≥n de todos los sectores defectuosos, debe generar un patr√≥n relativamente aleatorio, escribirlo en el disco, leer y comparar el valor.  Tambi√©n hay sectores inestables, que cambian sus valores gradualmente con el tiempo o despu√©s de procesar a sus vecinos. </p><br><p>  Dado todo lo anterior, decid√≠ implementar la siguiente estrategia en un script bash: </p><br><ul><li>  generamos un patr√≥n aleatorio y consideramos la suma de comprobaci√≥n para ello; </li><li>  nosotros leemos de manera inteligente; </li><li>  escribe un disco en ceros; </li><li>  lee el disco; </li><li>  escribimos un disco en un patr√≥n aleatorio con la lectura del bloque reci√©n registrado y la comparaci√≥n de su suma de verificaci√≥n; </li><li>  leemos el disco despu√©s de la grabaci√≥n completa, verificando las sumas de verificaci√≥n de cada bloque; </li><li>  nosotros leemos de manera inteligente; </li><li>  autocomprobaci√≥n; </li><li>  ir a 1. </li></ul><br><p>  Continuamos de esta manera hasta que los sectores incorrectamente le√≠dos y los errores de E / S dejen de ocurrir o hasta que el tornillo est√© completamente cubierto.  Por cierto, no puedo imaginar c√≥mo funciona la autocomprobaci√≥n para este modelo de disco;  No s√© cu√°nto tiempo difiere de short'a (aunque probablemente el largo funciona con toda la superficie y breve, centr√°ndome en las estad√≠sticas recopiladas anteriormente, como con el formato: completo y r√°pido).  Espero que esto aliente al tornillo a tener en cuenta la experiencia reciente y reasignar los sectores defectuosos. </p><br><p>  Cuando termin√© de escribir el script bash, lo ejecut√© y verifiqu√© los resultados al d√≠a siguiente: vi que la verificaci√≥n es muy lenta, mientras que la carga del procesador no alcanza el 60% en ning√∫n n√∫cleo.  Esto me hizo jugar con el tama√±o del bloque, probar diferentes algoritmos hash para sumas de verificaci√≥n, probar la verificaci√≥n directa de diferencias y no comparar las sumas de verificaci√≥n, pero no pude alcanzar velocidades de procesamiento superiores a 12 megabytes por segundo.  Como resultado, me detuve al comparar bloques de 400 kb con diff, y calculo las sumas de verificaci√≥n solo si hay una falta de coincidencia solo para el an√°lisis posterior del registro. </p><br><div class="spoiler">  <b class="spoiler_title">El gui√≥n result√≥ as√≠:</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash #    hddtest.sh diskdev logfile [blocksize] diskdev="$1"; test_log="$2"; #"~/work/hdd/test.log" blsz="${409600:-$3}"; n="1"; sizebyte=`fdisk -l "$diskdev"|grep "Disk $diskdev:"|cut -d" " -f5`; let sizebl=$sizebyte/$blsz; #"781428" for 320GB while true;do echo "starting iteration $n"; dd if=/dev/urandom of=fil bs="$blsz" count=1; md5ok=`md5sum fil|cut -d" " -f1`; cp fil fil_"$n"; echo "random pattern md5sum $md5ok"&gt;&gt;"$test_log"; smartctl -A "$diskdev"&gt;&gt;"$test_log"; echo "filling disk with zeroes"&gt;&gt;"$test_log"; dd if=/dev/zero of="$diskdev" bs="$blsz"; #count="$sizebl"; echo "disk is wiped fully"&gt;&gt;"$test_log"; dd of=/dev/null if="$diskdev" bs="$blsz"; # count="$sizebl"; echo "writing disk with fil-pattern"&gt;&gt;"$test_log"; i="0"; while [ "$i" -le "$sizebl" ]; do #echo "writing fil: $i "&gt;&gt;"$test_log"; dd if=fil of="$diskdev" bs="$blsz" seek="$i"; dd if=/dev/null of=tst; dd if="$diskdev" bs="$blsz" of=tst skip="$i" count=1 conv=notrunc,noerror,sync; #md5tst=`md5sum tst|cut -d" " -f1`; verf=`diff -s fil tst|sed 's/.* //g'`; if [ "$verf" != "identical" ]; #if [ "$md5ok" != "$md5tst" ]; then md5tst=`md5sum tst|cut -d" " -f1`; echo "$i : md5 $md5tst is not ok"&gt;&gt;"$test_log"; cp tst tst_"$n"_"$i"; fi; let i="$i"+1; done; echo "test of full writed with fil-pattern disk"&gt;&gt;"$test_log"; i="0"; while [ "$i" -le "$sizebl" ]; do #echo "after writing test: $i"&gt;&gt;"$test_log"; dd if=/dev/null of=tst; dd if="$diskdev" bs="$blsz" of=tst skip="$i" count=1 conv=notrunc,noerror,sync; #md5tst=`md5sum tst|cut -d" " -f1`; verf=`diff -s fil tst|sed 's/.* //g'`; if [ "$verf" != "identical" ]; #if [ "$md5ok" != "$md5tst" ]; then md5tst=`md5sum tst|cut -d" " -f1`; echo "$i : md5 $md5tst is not ok"&gt;&gt;"$test_log"; cp tst tst_"$n"_"$i"; fi; let i="$i"+1; done; smartctl -A "$diskdev" &gt;&gt;"$test_log"; smartctl -t long "$diskdev"&gt;&gt;"$test_log"; sleep 5000; #smartctl -t short "$diskdev"&gt;&gt;"$test_log"; #sleep 240; let n="$n"+1; done</span></span></code> </pre></div></div><br><p>  Como mostraron los registros despu√©s de la ejecuci√≥n repetida del gui√≥n, todos los sectores defectuosos estaban en los primeros 13 GB del disco, hubo varios "focos" de derrota (probablemente, cuando la cabeza golpe√≥, la superficie estaba rayada y rayada).  Durante las √∫ltimas 15 ejecuciones, el disco no ha visto ning√∫n sector pendiente, todo ya fue reasignado, pero en alg√∫n lugar en el medio del 13 Gigabyte, un bloque o bloques no muy lejos de √©l se leyeron incorrectamente a diferentes direcciones.  Adem√°s, un bloque podr√≠a considerarse incorrecto durante 2 ciclos seguidos, luego 2 veces correctamente y nuevamente incorrectamente.  As√≠ que atrapar los √∫ltimos 10 sectores defectuosos fue una operaci√≥n larga.  ¬°Un total de 1268 sectores fueron reasignados!  Y al final, me esperaba una sorpresa: cuando todo ya funcionaba de manera estable, despu√©s de la siguiente autocomprobaci√≥n, el par√°metro Recuento de sector reasignado se convirti√≥ en "0" y solo el Recuento de eventos reasignado y los registros de los √∫ltimos 5 errores (con direcci√≥n y hora de comenzar a trabajar) almacenado en el diario. </p><br><p>  A pesar de la operaci√≥n estable, decid√≠ minimizar la interacci√≥n con el √°rea da√±ada para no da√±ar la cabeza por posibles irregularidades en lugares con superficie da√±ada de las placas, y no quer√≠a confiar en los sectores locales a largo plazo.  Simplemente retroced√≠ un poco con un margen y cre√© una partici√≥n comenzando con el 15 Gigabyte.  Y, como lo ha demostrado el tiempo, el disco se siente bastante bien y ha estado funcionando de manera estable en una computadora port√°til port√°til durante 10 meses. </p><br><p>  Aunque es imposible confiar plenamente en el disco restaurado y la viabilidad econ√≥mica de la empresa es dudosa, a veces el resultado es solo una adici√≥n agradable a la buena manera. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/481952/">https://habr.com/ru/post/481952/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../481942/index.html">Regreso al futuro: qu√© juegos modernos se presentaron en 2010</a></li>
<li><a href="../481944/index.html">¬øQu√© determina la posici√≥n del sitio en la p√°gina de b√∫squeda?</a></li>
<li><a href="../481946/index.html">M√©todos de comunicaci√≥n en equipos de Microsoft: Canales VS Chats</a></li>
<li><a href="../481948/index.html">¬øC√≥mo crear un robot virtual?</a></li>
<li><a href="../481950/index.html">Tutorial: arranque de resorte reactivo</a></li>
<li><a href="../481954/index.html">¬øC√≥mo y por qu√© puedo hackear VR?</a></li>
<li><a href="../481956/index.html">En busca del programador desaparecido. B√∫squeda de a√±o nuevo</a></li>
<li><a href="../481958/index.html">¬øCu√°ndo es un firmante en mail.ru o c√≥mo cruzar un tanque T-34 con una interfaz de correo?</a></li>
<li><a href="../481960/index.html">2. Pila el√°stica: an√°lisis de registros de seguridad. Logstash</a></li>
<li><a href="../481964/index.html">C√≥mo organizar un lanzamiento</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>