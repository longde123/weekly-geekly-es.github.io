<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>   Seguridad m贸vil OAuth 2.0   </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! Soy Nikita Stupin, especialista en seguridad de la informaci贸n, Mail.Ru Mail. No hace mucho tiempo, realic茅 una investigaci贸n de vulnera...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Seguridad m贸vil OAuth 2.0</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/417031/"><img src="https://habrastorage.org/getpro/habr/post_images/205/605/cd5/205605cd5b166f65aa8085fe1606779f.jpg"><br><br>  Hola a todos!  Soy Nikita Stupin, especialista en seguridad de la informaci贸n, Mail.Ru Mail.  No hace mucho tiempo, realic茅 una investigaci贸n de vulnerabilidad en dispositivos m贸viles OAuth 2.0.  Para crear un esquema m贸vil seguro de OAuth 2.0, no es suficiente implementar el est谩ndar en su forma pura y verificar redirect_uri.  Es necesario tener en cuenta los detalles de las aplicaciones m贸viles y aplicar mecanismos de protecci贸n adicionales. <br><br>  En este art铆culo, quiero compartir con ustedes conocimientos sobre ataques en dispositivos m贸viles OAuth 2.0, sobre m茅todos de protecci贸n y la implementaci贸n segura de este protocolo.  Todos los componentes de protecci贸n necesarios, que analizar茅 a continuaci贸n, se implementan en el 煤ltimo SDK para los clientes m贸viles Mail.Ru Mail. <br><a name="habracut"></a><br><h1>  La naturaleza y la funci贸n de OAuth 2.0 </h1><br>  OAuth 2.0 es un protocolo de autorizaci贸n que describe c贸mo es seguro para un servicio de cliente acceder a los recursos del usuario en un proveedor de servicios.  Al mismo tiempo, OAuth 2.0 evita que el usuario tenga que ingresar una contrase帽a fuera del proveedor de servicios: todo el proceso se reduce a hacer clic en el bot贸n "Acepto otorgar acceso a ...". <br><br>  Un proveedor en t茅rminos de OAuth 2.0 es un servicio que posee los datos del usuario y, con el permiso del usuario, proporciona servicios de terceros (clientes) con acceso seguro a estos datos.  Un cliente es una aplicaci贸n que desea recibir datos de usuario de un proveedor. <br><br>  Alg煤n tiempo despu茅s del lanzamiento del protocolo OAuth 2.0, los desarrolladores comunes lo adaptaron para la autenticaci贸n, aunque originalmente no estaba destinado a esto.  La autenticaci贸n cambia el vector de ataque de los datos del usuario que se almacenan en el proveedor de servicios a las cuentas de usuario del servicio del usuario. <br><br>  No se limit贸 solo a la autenticaci贸n.  En la era de las aplicaciones m贸viles y la exaltaci贸n de la conversi贸n, ingresar a la aplicaci贸n con un solo bot贸n se ha vuelto muy tentador.  Los desarrolladores pusieron OAuth 2.0 en rieles m贸viles.  Naturalmente, pocas personas pensaban en la seguridad y las caracter铆sticas espec铆ficas de las aplicaciones m贸viles: una y otra vez, y en producci贸n.  Sin embargo, OAuth 2.0 generalmente no funciona bien fuera de las aplicaciones web: se observan los mismos problemas tanto en aplicaciones m贸viles como de escritorio. <br><br>  Veamos c贸mo hacer un OAuth 2.0 m贸vil seguro. <br><br><h1>  Como funciona </h1><br>  Recuerde que en los dispositivos m贸viles, el cliente puede no ser un navegador, sino una aplicaci贸n m贸vil sin backend.  Por lo tanto, nos enfrentamos a dos problemas de seguridad principales para OAuth 2.0 m贸vil: <br><br><ol><li>  El cliente no es de confianza. </li><li>  El comportamiento de una redirecci贸n desde un navegador a una aplicaci贸n m贸vil depende de la configuraci贸n y las aplicaciones que el usuario haya instalado. </li></ol><br><h4>  La aplicaci贸n m贸vil es un cliente p煤blico. </h4><br>  Para comprender la ra铆z del primer problema, veamos c贸mo funciona OAuth 2.0 en caso de interacci贸n de servidor a servidor, y luego comp谩relo con OAuth 2.0 en caso de interacci贸n de cliente a servidor. <br><br>  En ambos casos, todo comienza con el hecho de que el cliente del servicio se registra con el proveedor del servicio y recibe <code>client_id</code> y, en algunos casos, <code>client_secret</code> .  El valor <code>client_id</code> es p煤blico y es necesario para identificar el servicio del cliente, a diferencia de <code>client_secret</code> , cuyo valor es privado.  El proceso de registro se describe con m谩s detalle en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RFC 7591</a> . <br><br>  El siguiente diagrama muestra el funcionamiento de OAuth 2.0 en la comunicaci贸n de servidor a servidor. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f06/279/e8a/f06279e8ac68f2fe664362caec6fa063.png"><br>  <i>Imagen tomada de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc6749#section-1.2</a></i> <br><br>  Hay 3 etapas principales del protocolo OAuth 2.0: <br><br><ol><li>  [Pasos de CA] Obtenga el c贸digo de autorizaci贸n (en adelante, simplemente <code>code</code> ). </li><li>  [Pasos DE] <code>code</code> intercambio para <code>access_token</code> . </li><li>  Acceda al recurso utilizando <code>access_token</code> . </li></ol><br>  Examinemos el recibo del c贸digo con m谩s detalle: <br><br><ol><li>  [Paso A] El cliente del servicio redirige al usuario al proveedor del servicio. </li><li>  [Paso B] El proveedor de servicios solicita permiso al usuario para proporcionar datos al servicio del cliente (flecha B hacia arriba).  El usuario proporciona acceso a los datos (flecha B a la derecha). </li><li>  [Paso C] El proveedor de servicios devuelve el <code>code</code> al navegador del usuario, que redirige el <code>code</code> servicio del cliente. </li></ol><br>  Veamos <code>access_token</code> obtener <code>access_token</code> m谩s detalle: <br><br><ol><li>  [Paso D] El servidor del cliente env铆a una solicitud de <code>access_token</code> .  La solicitud incluye: <code>code</code> , <code>client_secret</code> y <code>redirect_uri</code> . </li><li>  [Paso E] En el caso de <code>code</code> v谩lido, <code>client_secret</code> y <code>redirect_uri</code> , <code>client_secret</code> proporciona <code>client_secret</code> . </li></ol><br>  La solicitud de <code>access_token</code> a <code>access_token</code> se realiza de acuerdo con el esquema de servidor a servidor, por lo tanto, en general, para robar <code>client_secret</code> atacante debe piratear el servidor servidor-cliente o el servidor del proveedor de servicios. <br><br>  Ahora veamos c贸mo se ve el esquema OAuth 2.0 en un dispositivo m贸vil sin backend (interacci贸n de cliente a servidor). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7cb/9fb/b7d/7cb9fbb7dcc35c74e921f18d22584254.png"><br>  <i>Imagen tomada de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc8252#section-4.1</a></i> <br><br>  El esquema general se divide en los mismos 3 pasos principales: <br><br><ol><li>  [pasos 1-4 en la imagen] Obtenga el <code>code</code> . </li><li>  [pasos 5-6 en la imagen] <code>code</code> intercambio para <code>access_token</code> . </li><li>  Acceda al recurso utilizando <code>access_token</code> . </li></ol><br>  Sin embargo, en este caso, la aplicaci贸n m贸vil tambi茅n act煤a como un servidor, lo que significa que <code>client_secret</code> estar谩 <code>client_secret</code> dentro de la aplicaci贸n.  Esto lleva al hecho de que en dispositivos m贸viles es imposible mantener el secreto <code>lient_secret</code> de un atacante.  <code>client_secret</code> dos formas de <code>client_secret</code> a la aplicaci贸n: filtrar el tr谩fico de la aplicaci贸n al servidor o aplicar ingenier铆a inversa a la aplicaci贸n.  Ambos m茅todos son f谩ciles de implementar, por lo que <code>client_secret</code> in煤til en dispositivos m贸viles. <br><br>  Con respecto al esquema de cliente a servidor, es posible que tenga una pregunta: "驴por qu茅 no obtener <code>access_token</code> inmediatamente?".  Parecer铆a, 驴por qu茅 necesitamos un paso adicional?  Adem谩s, hay un esquema de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">concesi贸n impl铆cita</a> en el que el cliente recibe inmediatamente un <code>access_token</code> .  Aunque puede usarse en algunos casos, veremos a continuaci贸n que la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Subvenci贸n impl铆cita</a> no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">es</a> adecuada para OAuth 2.0 m贸vil seguro. <br><br><h4>  Redireccionar en dispositivos m贸viles </h4><br>  En general, para una redirecci贸n desde un navegador a una aplicaci贸n en dispositivos m贸viles, se utilizan el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esquema URI personalizado</a> y los mecanismos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AppLink</a> .  Ninguno de estos mecanismos en su forma pura es tan confiable como una redirecci贸n de navegador. <br><br>  El esquema URI personalizado (o enlace profundo) se utiliza de la siguiente manera: el desarrollador define el esquema de la aplicaci贸n antes del ensamblaje.  El esquema puede ser arbitrario, mientras que en el mismo dispositivo se pueden instalar varias aplicaciones con el mismo esquema.  Todo es bastante simple cuando cada aplicaci贸n en el dispositivo corresponde a una aplicaci贸n.  Pero, 驴qu茅 pasa si dos aplicaciones registraron el mismo circuito en el mismo dispositivo?  驴C贸mo puede determinar el sistema operativo cu谩l de las dos aplicaciones se abrir谩 al acceder al esquema URI personalizado?  Android mostrar谩 una ventana con la elecci贸n de la aplicaci贸n en la que desea abrir un enlace.  En iOS, el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comportamiento no est谩 definido</a> , lo que significa que cualquiera de las dos aplicaciones se puede abrir.  En ambos casos, un atacante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">puede interceptar c贸digo o access_token</a> . <br><br>  AppLink, en contraste con el esquema URI personalizado, est谩 garantizado para abrir la aplicaci贸n correcta, pero este mecanismo tiene varias desventajas: <br><br><ol><li>  Cada cliente de servicio debe pasar independientemente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el procedimiento de verificaci贸n</a> . </li><li>  Los usuarios de Android pueden desactivar AppLink para una aplicaci贸n espec铆fica en la configuraci贸n. </li><li>  Android por debajo de 6.0 e iOS por debajo de 9.0 no son compatibles con AppLink. </li></ol><br>  Las desventajas anteriores de AppLink, en primer lugar, aumentan el umbral de entrada para posibles servicios de cliente y, en segundo lugar, pueden llevar al hecho de que, en determinadas circunstancias, el usuario no trabajar谩 con OAuth 2.0.  Esto hace que AppLink no sea adecuado para reemplazar los redireccionamientos del navegador en el protocolo OAuth 2.0. <br><br><h1>  驴A qu茅 atacar? </h1><br>  Los problemas de OAuth 2.0 m贸vil tambi茅n dieron lugar a ataques espec铆ficos.  Veamos qu茅 son y c贸mo funcionan. <br><br><a name="1"></a><h4>  Ataque de intercepci贸n del c贸digo de autorizaci贸n </h4><br>  Datos iniciales: una aplicaci贸n leg铆tima (cliente OAuth 2.0) y una aplicaci贸n maliciosa que registr贸 el mismo esquema que el leg铆timo se instalan en el dispositivo del usuario.  La siguiente figura muestra el esquema de ataque. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a87/336/d4c/a87336d4c0d73c89a62bb448cb12d49b.png"><br>  <i>Imagen tomada de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc7636#section-1</a></i> <br><br>  Aqu铆 est谩 el problema: en el paso 4, el navegador devuelve el <code>code</code> a la aplicaci贸n a trav茅s del Esquema de URI personalizado, por lo que el <code>code</code> puede ser interceptado por el malware (porque registr贸 el mismo esquema que la aplicaci贸n leg铆tima).  Despu茅s de eso, el malware cambia el <code>code</code> a <code>access_token</code> y obtiene acceso a los datos del usuario. <br><br>  驴C贸mo protegerte?  En algunos casos, se pueden utilizar mecanismos de comunicaci贸n entre procesos; hablaremos de ellos a continuaci贸n.  En el caso general, debe aplicar un esquema llamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Clave de prueba para el intercambio de c贸digo</a> .  Su esencia se refleja en el siguiente diagrama. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/123/67e/349/12367e3497cbbd54d007a18a678bfc0d.png"><br>  <i>Imagen tomada de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc7636#section-1.1</a></i> <br><br>  En las solicitudes del cliente, hay varios par谩metros adicionales: <code>code_verifier</code> , <code>code_challenge</code> (en el <code>t(code_verifier)</code> ) y <code>code_challenge_method</code> (en el diagrama <code>t_m</code> ). <br><br>  <code>Code_verifier</code> es un n煤mero aleatorio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de al menos 256 bits de longitud</a> que se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">usa solo una vez</a> .  Es decir, para <b>cada</b> solicitud de <code>code</code> cliente debe generar un nuevo <code>code_verifier</code> . <br><br>  <code>Code_challenge_method</code> es el nombre de una funci贸n de conversi贸n, con mayor frecuencia SHA-256. <br><br>  <code>Code_challenge</code> es un <code>code_verifier</code> al que se ha <code>code_challenge_method</code> y codificado la conversi贸n <code>code_challenge_method</code> en la URL Safe Base64. <br><br>  La conversi贸n de <code>code_verifier</code> a <code>code_challenge</code> necesaria para proteger contra los vectores de ataque basados en la intercepci贸n de <code>code_verifier</code> (por ejemplo, desde los registros del sistema del dispositivo) cuando se solicita el <code>code</code> . <br><br>  Si el dispositivo del usuario <b>no admite</b> SHA-256, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se permite</a> una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">degradaci贸n hasta que falte la conversi贸n code_verifier</a> .  En todos los dem谩s casos, debe usar SHA-256. <br><br>  El esquema funciona de la siguiente manera: <br><br><ol><li>  El cliente genera un <code>code_verifier</code> y lo recuerda. </li><li>  El cliente selecciona <code>code_challenge_method</code> y obtiene <code>code_challenge</code> de <code>code_verifier</code> . </li><li>  [Paso A] El cliente solicita el <code>code</code> , con <code>code_challenge</code> y <code>code_challenge_method</code> agregado a la solicitud. </li><li>  [Paso B] El proveedor recuerda el <code>code_challenge</code> y <code>code_challenge_method</code> en el servidor y devuelve el <code>code</code> cliente. </li><li>  [Paso C] El cliente solicita <code>access_token</code> , y se agrega <code>access_token</code> a la <code>code_verifier</code> . </li><li>  El proveedor recibe el <code>code_challenge</code> del <code>code_challenge</code> entrante, y luego lo <code>code_challenge</code> el <code>code_challenge</code> , que recordaba. </li><li>  [Paso D] Si los valores coinciden, el proveedor emite un <code>access_token</code> cliente. </li></ol><br>  Veamos por qu茅 <code>code_challenge</code> permite protegerte de un ataque de intercepci贸n de c贸digo.  Para hacer esto, pasaremos por las etapas de obtener <code>access_token</code> . <br><br><ol><li>  Primero, una aplicaci贸n leg铆tima solicita el <code>code</code> ( <code>code_challenge</code> y <code>code_challenge_method</code> env铆an junto con la <b>solicitud</b> ). </li><li>  El malware intercepta el <code>code</code> (pero no <code>code_challenge</code> , porque no hay <code>code_challenge</code> <b>en la respuesta</b> ). </li><li>  El malware solicita <code>access_token</code> (con <code>code</code> v谩lido, pero <b>sin</b> <code>code_verifier</code> v谩lido). </li><li>  El servidor nota la <code>code_challenge</code> coincidencia <code>code_challenge</code> y arroja un error. </li></ol><br>  Tenga en cuenta que el atacante no tiene la capacidad de adivinar el <code>code_verifier</code> (al azar 256 bits!) O encontrarlo en alg煤n lugar de los registros ( <code>code_verifier</code> se transmite una vez). <br><br>  Si todo esto se reduce a una frase, <code>code_challenge</code> permite al proveedor de servicios responder la pregunta: " <code>access_token</code> solicita <code>access_token</code> por la misma aplicaci贸n cliente que solicit贸 el <code>code</code> o por otra?" <br><br><h4>  OAuth 2.0 CSRF </h4><br>  En dispositivos m贸viles, OAuth 2.0 a menudo se usa como mecanismo de autenticaci贸n.  Como recordamos, la autenticaci贸n a trav茅s de OAuth 2.0 difiere de la autorizaci贸n en que las vulnerabilidades de OAuth 2.0 afectan los datos del usuario del lado del cliente del servicio y no del proveedor del servicio.  Como resultado, el ataque CSRF en OAuth 2.0 le permite robar la cuenta de otra persona. <br><br>  Considere un ataque CSRF contra OAuth 2.0 utilizando el ejemplo de la aplicaci贸n cliente de taxi y el proveedor provider.com.  Primero, un atacante inicia sesi贸n en attacker@provider.com en su dispositivo y recibe un <code>code</code> para el taxi.  Despu茅s de eso, el atacante interrumpe el proceso OAuth 2.0 y genera un enlace: <br><br> <code>com.taxi.app://oauth? <br> code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4 <br></code> <br>  Luego, el atacante env铆a un enlace a la v铆ctima, por ejemplo, bajo la apariencia de una carta o SMS de la administraci贸n del taxi.  La v铆ctima <code>access_token</code> enlace, se abre una aplicaci贸n de taxi en su tel茅fono, que recibe <code>access_token</code> , y como resultado, la v铆ctima termina en la cuenta de taxi del <b>atacante</b> .  Sin darse cuenta de la captura, la v铆ctima usa esta cuenta: hace viajes, ingresa sus datos, etc. <br><br>  Ahora, un atacante puede iniciar sesi贸n en la cuenta de taxi de la v铆ctima en cualquier momento porque est谩 vinculado a <code>attacker@provider.com</code> .  El ataque CSRF al iniciar sesi贸n le permiti贸 robar una cuenta. <br><br>  Los ataques CSRF generalmente est谩n protegidos con un token CSRF (tambi茅n llamado <code>state</code> ), y OAuth 2.0 no es una excepci贸n.  C贸mo usar el token CSRF: <br><br><ol><li>  La aplicaci贸n cliente genera y almacena el token CSRF en el dispositivo m贸vil del usuario. </li><li>  La aplicaci贸n cliente incluye el token CSRF en la solicitud de <code>code</code> . </li><li>  El servidor devuelve el mismo token CSRF en la respuesta junto con el c贸digo. </li><li>  La aplicaci贸n cliente compara el token CSRF entrante y almacenado.  Si los valores coinciden, entonces el proceso contin煤a. </li></ol><br>  Requisitos del token CSRF: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nonce de</a> al menos 256 bits de largo, obtenido de una buena fuente de secuencias pseudoaleatorias. <br><br>  En resumen, el token CSRF permite que la aplicaci贸n cliente responda la pregunta: "驴Estaba empezando a obtener <code>access_token</code> , o alguien est谩 tratando de enga帽arme?" <br><br><h4>  Malware que finge ser un cliente leg铆timo </h4><br>  Algunos programas maliciosos pueden imitar aplicaciones leg铆timas y generar una pantalla de consentimiento en su nombre (la pantalla de consentimiento es una pantalla en la que el usuario ve: "Acepto otorgar acceso a ...").  El usuario desatento puede hacer clic en "permitir" y, como resultado, el malware obtiene acceso a los datos del usuario. <br><br>  Android e iOS proporcionan mecanismos para la verificaci贸n mutua de aplicaciones.  La aplicaci贸n del proveedor puede verificar la legitimidad de la aplicaci贸n del cliente y viceversa. <br><br>  Desafortunadamente, si el mecanismo OAuth 2.0 usa una transmisi贸n a trav茅s de un navegador, entonces no puede defenderse contra este ataque. <br><br><h4>  Otros ataques </h4><br>  Examinamos los ataques que son exclusivos de OAuth 2.0 m贸vil.  Sin embargo, no te olvides de los ataques en OAuth 2.0 regular: <code>redirect_uri</code> , intercepci贸n de tr谩fico a trav茅s de una conexi贸n insegura, etc.  Puedes leer m谩s sobre ellos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu铆</a> . <br><br><h1>  Que hacer </h1><br>  Aprendimos c贸mo funciona el protocolo OAuth 2.0 y descubrimos qu茅 vulnerabilidades existen en las implementaciones de este protocolo en dispositivos m贸viles.  Ahora, creemos un esquema seguro de OAuth 2.0 m贸vil a partir de piezas individuales. <br><br><h4>  Bueno, malo OAuth 2.0 </h4><br>  Comencemos con c贸mo elevar correctamente la pantalla de consentimiento.  En dispositivos m贸viles, hay dos formas de abrir una p谩gina web desde una aplicaci贸n nativa (ejemplos de aplicaciones nativas: Mail.Ru Mail, VK, Facebook). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ee/bd1/d02/7eebd1d02b5fa11a820fe37abbd1c552.png"><br><br>  El primer m茅todo se llama la pesta帽a personalizada del navegador (en la imagen de la izquierda).  <b>Nota</b> : La pesta帽a personalizada del navegador en Android se denomina pesta帽a personalizada de Chrome y en iOS SafariViewController.  De hecho, esta es una pesta帽a normal del navegador, que se muestra directamente en la aplicaci贸n, es decir  No hay cambio visual entre aplicaciones. <br><br>  El segundo m茅todo se llama "raise WebView" (en la imagen de la derecha), en relaci贸n con OAuth 2.0 m贸vil, considero que es malo. <br><br>  WebView es un navegador independiente para una aplicaci贸n nativa. <br><br>  <i>Un</i> " <i>navegador</i> independiente" significa que WebView no permite el acceso a cookies, almacenamiento, cach茅, historial y otros datos de los navegadores Safari y Chrome.  Lo contrario tambi茅n es cierto: Safari y Chrome no pueden acceder a los datos de WebView. <br><br>  " <i>Navegador para una aplicaci贸n nativa</i> " significa que la aplicaci贸n nativa que gener贸 WebView tiene acceso <b>completo</b> a cookies, almacenamiento, cach茅, historial y otros datos de WebView. <br><br>  Ahora imagine: el usuario presiona el bot贸n "iniciar sesi贸n usando ..." y el WebView de la aplicaci贸n maliciosa le pide su nombre de usuario y contrase帽a al proveedor de servicios. <br><br>  Fracaso a la vez en todos los frentes: <br><br><ol><li>  El usuario ingresa el nombre de usuario y la contrase帽a de la cuenta del proveedor de servicios en la aplicaci贸n, que puede robar f谩cilmente estos datos. </li><li>  OAuth 2.0 se desarroll贸 originalmente para <i>no ingresar un nombre de usuario y contrase帽a</i> de un proveedor de servicios. </li><li>  El usuario se acostumbra a ingresar el nombre de usuario y la contrase帽a en cualquier lugar, la probabilidad de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">phishing</a> aumenta. <br></li></ol><br>  Dado que todos los argumentos est谩n en contra de WebView, la conclusi贸n se sugiere a s铆 misma: abrir la pesta帽a personalizada del navegador para la pantalla de consentimiento. <br><br>  Si alguno de ustedes tiene argumentos a favor de WebView en lugar de la pesta帽a personalizada del navegador, escr铆balo en los comentarios, lo agradecer茅. <br><br><h4>  Esquema seguro de Mobile OAuth 2.0 </h4><br>  Utilizaremos el esquema de concesi贸n de c贸digo de autorizaci贸n porque nos permite agregar un <code>code_challenge</code> y protegernos de un ataque de intercepci贸n de c贸digo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7cb/9fb/b7d/7cb9fbb7dcc35c74e921f18d22584254.png"><br>  <i>Imagen tomada de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc8252#section-4.1</a></i> <br><br>  La solicitud de c贸digo (pasos 1-2) se ver谩 as铆: <br><br> <code>https://o2.mail.ru/code? <br> redirect_uri=com.mail.cloud.app%3A%2F%2Foauth&amp; <br> anti_csrf=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24&amp; code_challenge=ZjYxNzQ4ZjI4YjdkNWRmZjg4MWQ1N2FkZjQzNGVkODE1YTRhNjViNjJjMGY5MGJjNzdiOGEzMDU2ZjE3NGFiYw%3D%3D&amp; <br> code_challenge_method=S256&amp; <br> scope=email%2Cid&amp; <br> response_type=code&amp; <br> client_id=984a644ec3b56d32b0404777e1eb73390c <br></code> <br>  En el paso 3, el navegador recibe una respuesta redirigida: <br><br> <code>com.mail.cloud.app://outh? <br> code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4&amp; <br> anti_csrf=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24</code> <br> <br>  En el paso 4, el navegador abre el esquema URI personalizado y pasa el <code>code</code> y el token CSRF a la aplicaci贸n cliente. <br><br>  Solicitud de <code>access_token</code> (paso 5): <br><br> <code>https://o2.mail.ru/token? <br> code_verifier=e61748f28b7d5daf881d571df434ed815a4a65b62c0f90bc77b8a3056f174abc&amp; <br> code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4&amp; <br> client_id=984a644ec3b56d32b0404777e1eb73390c <br></code> <br>  El 煤ltimo paso devuelve una respuesta con <code>access_token</code> . <br><br>  En general, el esquema anterior es seguro, pero tambi茅n hay casos especiales en los que OAuth 2.0 puede hacerse m谩s simple y un poco m谩s seguro. <br><br><h4>  Android IPC </h4><br>  Android tiene un mecanismo para el intercambio de datos bidireccional entre procesos: IPC (comunicaci贸n entre procesos).  Se prefiere IPC sobre el esquema URI personalizado por dos razones: <br><br><ol><li>  Una aplicaci贸n que abre un canal IPC puede verificar la autenticidad de una aplicaci贸n abierta mediante su certificado.  Lo contrario tambi茅n es cierto: una aplicaci贸n abierta puede verificar la autenticidad de la aplicaci贸n que la abri贸. </li><li>  Al enviar una solicitud a trav茅s de un canal IPC, el remitente puede recibir una respuesta a trav茅s del mismo canal.  Junto con la verificaci贸n mutua (elemento 1), esto significa que ning煤n proceso de terceros puede interceptar <code>access_token</code> . </li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/693/84d/6f6/69384d6f63788694137f8d559d6469fa.png"><br><br>  Por lo tanto, podemos usar la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Subvenci贸n impl铆cita</a> y simplificar enormemente el esquema m贸vil OAuth 2.0.  Sin <code>code_challenge</code> y tokens CSRF.  Adem谩s, podremos protegernos del malware que imita a clientes leg铆timos para robar cuentas de usuario. <br><br><h4>  SDK del cliente </h4><br>  Adem谩s de implementar el esquema seguro de OAuth 2.0 m贸vil descrito anteriormente, el proveedor debe desarrollar un SDK para sus clientes.  Esto facilitar谩 la implementaci贸n de OAuth 2.0 en el lado del cliente y al mismo tiempo reducir谩 la cantidad de errores y vulnerabilidades. <br><br><h1>  Sacar conclusiones </h1><br>  Para los proveedores de OAuth 2.0, compil茅 la "Lista de verificaci贸n de Secure Mobile OAuth 2.0": <br><br><ol><li>  Una base s贸lida es vital.  En el caso de OAuth 2.0 m贸vil, la base es el esquema o protocolo que elegimos implementar.  Al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">implementar su propio esquema OAuth 2.0,</a> es f谩cil cometer un error.  Otros ya han llenado los baches y han llegado a conclusiones, no hay nada de malo en aprender de sus errores e inmediatamente hacer una implementaci贸n segura.  En general, el esquema OAuth 2.0 m贸vil m谩s seguro es el de la secci贸n 驴Qu茅 hacer? </li><li>  <code>Access_token</code> y otros datos confidenciales: en iOS, en Llavero, en Android, en Almacenamiento interno.  Estos repositorios est谩n dise帽ados espec铆ficamente para tales fines.  Si es necesario, puede usar el proveedor de contenido en Android, pero debe configurarse de manera segura. </li><li>  <code>Code</code> debe ser de una sola vez, con un tiempo de vida corto. </li><li>  Para protegerse contra la intercepci贸n de c贸digo, use <code>code_challenge</code> . </li><li>  Para protegerse contra un ataque CSRF en el inicio de sesi贸n, use tokens CSRF. </li><li>  No use WebView para la pantalla de consentimiento, use la pesta帽a personalizada del navegador. </li><li>  <code>Client_secret</code> <b>in煤til</b> si no est谩 almacenado en el backend.  No se lo d茅 a clientes p煤blicos. </li><li>  Use HTTPS en <b>todas partes</b> , con la prohibici贸n de rebajar a HTTP. </li><li>  Siga las recomendaciones de criptograf铆a (selecci贸n de cifrado, longitud del token, etc.) <b>de los est谩ndares</b> .  Puede copiar los datos y descubrir por qu茅 se hizo de esa manera, pero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no puede hacer su criptograf铆a</a> . </li><li>  Desde la aplicaci贸n del cliente, verifique a qui茅n abre para OAuth 2.0, y desde la aplicaci贸n del proveedor, verifique qui茅n lo abre para OAuth 2.0. </li><li>  Tenga en cuenta las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">vulnerabilidades habituales de OAuth 2.0</a> .  Mobile OAuth 2.0 ampl铆a y complementa el normal, por lo que nadie cancel贸 la verificaci贸n de <code>redirect_uri</code> para ver las coincidencias exactas y otras recomendaciones para OAuth 2.0 regular. </li><li>  Aseg煤rese de proporcionar SDK a los clientes.  El cliente tendr谩 menos errores y vulnerabilidades en el c贸digo, y ser谩 m谩s f谩cil para 茅l implementar su OAuth 2.0. </li></ol><br><h1>  Que leer </h1><br><ol><li>  [RFC] OAuth 2.0 para aplicaciones nativas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc8252</a> </li><li>  Google OAuth 2.0 para aplicaciones m贸viles y de escritorio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://developers.google.com/identity/protocols/OAuth2InstalledApp</a> </li><li>  [RFC] Clave de prueba para el intercambio de c贸digo por parte de clientes p煤blicos de OAuth <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc7636</a> </li><li>  Condici贸n de carrera OAuth 2.0 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://hackerone.com/reports/55140</a> </li><li>  [RFC] Modelo de amenaza OAuth 2.0 y consideraciones de seguridad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc6819</a> </li><li>  Ataques en OAuth 2.0 normal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://sakurity.com/oauth</a> </li><li>  [RFC] Protocolo de registro de cliente din谩mico OAuth 2.0 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc7591</a> </li></ol><br><h1>  Agradecimientos </h1><br>  Gracias a todos los que ayudaron a escribir este art铆culo, especialmente Sergey Belov, Andrey Sumin, Andrey Labunts ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@isciurus</a> ) y Daria Yakovleva. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es417031/">https://habr.com/ru/post/es417031/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es417015/index.html">Entendemos qu茅 registros y qu茅 no registra la aplicaci贸n Burger King</a></li>
<li><a href="../es417017/index.html">C贸mo un experimento nuclear fallido gener贸 accidentalmente astronom铆a de neutrinos</a></li>
<li><a href="../es417023/index.html">Experiencia del Grupo Rambler: c贸mo comenzamos a controlar completamente la formaci贸n y el comportamiento de los componentes de React front-end</a></li>
<li><a href="../es417027/index.html">驴C贸mo escrib铆 la biblioteca est谩ndar de C ++ 11 o por qu茅 boost es tan aterrador? Introduccion</a></li>
<li><a href="../es417029/index.html">Perfilado de c贸digo con LLVM</a></li>
<li><a href="../es417033/index.html">QIWI Kitchen el 7 de junio: video de los discursos de nuestros oradores</a></li>
<li><a href="../es417035/index.html">UnnyWorld: post mortem</a></li>
<li><a href="../es417037/index.html">BRAZADORES DE CERVEZA. Control de luz. Vixen Lights 3. Inicio r谩pido (1/4)</a></li>
<li><a href="../es417039/index.html">Aprenda wordpress (y m谩s) para reproducir reproductores de YouTube r谩pidamente</a></li>
<li><a href="../es417041/index.html">eslint-scope v3.7.2 roba tokens NPM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>