<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐂 🏢 🏈 Seguridad móvil OAuth 2.0 🌚 🐋 👒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! Soy Nikita Stupin, especialista en seguridad de la información, Mail.Ru Mail. No hace mucho tiempo, realicé una investigación de vulnera...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Seguridad móvil OAuth 2.0</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/417031/"><img src="https://habrastorage.org/getpro/habr/post_images/205/605/cd5/205605cd5b166f65aa8085fe1606779f.jpg"><br><br>  Hola a todos!  Soy Nikita Stupin, especialista en seguridad de la información, Mail.Ru Mail.  No hace mucho tiempo, realicé una investigación de vulnerabilidad en dispositivos móviles OAuth 2.0.  Para crear un esquema móvil seguro de OAuth 2.0, no es suficiente implementar el estándar en su forma pura y verificar redirect_uri.  Es necesario tener en cuenta los detalles de las aplicaciones móviles y aplicar mecanismos de protección adicionales. <br><br>  En este artículo, quiero compartir con ustedes conocimientos sobre ataques en dispositivos móviles OAuth 2.0, sobre métodos de protección y la implementación segura de este protocolo.  Todos los componentes de protección necesarios, que analizaré a continuación, se implementan en el último SDK para los clientes móviles Mail.Ru Mail. <br><a name="habracut"></a><br><h1>  La naturaleza y la función de OAuth 2.0 </h1><br>  OAuth 2.0 es un protocolo de autorización que describe cómo es seguro para un servicio de cliente acceder a los recursos del usuario en un proveedor de servicios.  Al mismo tiempo, OAuth 2.0 evita que el usuario tenga que ingresar una contraseña fuera del proveedor de servicios: todo el proceso se reduce a hacer clic en el botón "Acepto otorgar acceso a ...". <br><br>  Un proveedor en términos de OAuth 2.0 es un servicio que posee los datos del usuario y, con el permiso del usuario, proporciona servicios de terceros (clientes) con acceso seguro a estos datos.  Un cliente es una aplicación que desea recibir datos de usuario de un proveedor. <br><br>  Algún tiempo después del lanzamiento del protocolo OAuth 2.0, los desarrolladores comunes lo adaptaron para la autenticación, aunque originalmente no estaba destinado a esto.  La autenticación cambia el vector de ataque de los datos del usuario que se almacenan en el proveedor de servicios a las cuentas de usuario del servicio del usuario. <br><br>  No se limitó solo a la autenticación.  En la era de las aplicaciones móviles y la exaltación de la conversión, ingresar a la aplicación con un solo botón se ha vuelto muy tentador.  Los desarrolladores pusieron OAuth 2.0 en rieles móviles.  Naturalmente, pocas personas pensaban en la seguridad y las características específicas de las aplicaciones móviles: una y otra vez, y en producción.  Sin embargo, OAuth 2.0 generalmente no funciona bien fuera de las aplicaciones web: se observan los mismos problemas tanto en aplicaciones móviles como de escritorio. <br><br>  Veamos cómo hacer un OAuth 2.0 móvil seguro. <br><br><h1>  Como funciona </h1><br>  Recuerde que en los dispositivos móviles, el cliente puede no ser un navegador, sino una aplicación móvil sin backend.  Por lo tanto, nos enfrentamos a dos problemas de seguridad principales para OAuth 2.0 móvil: <br><br><ol><li>  El cliente no es de confianza. </li><li>  El comportamiento de una redirección desde un navegador a una aplicación móvil depende de la configuración y las aplicaciones que el usuario haya instalado. </li></ol><br><h4>  La aplicación móvil es un cliente público. </h4><br>  Para comprender la raíz del primer problema, veamos cómo funciona OAuth 2.0 en caso de interacción de servidor a servidor, y luego compárelo con OAuth 2.0 en caso de interacción de cliente a servidor. <br><br>  En ambos casos, todo comienza con el hecho de que el cliente del servicio se registra con el proveedor del servicio y recibe <code>client_id</code> y, en algunos casos, <code>client_secret</code> .  El valor <code>client_id</code> es público y es necesario para identificar el servicio del cliente, a diferencia de <code>client_secret</code> , cuyo valor es privado.  El proceso de registro se describe con más detalle en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RFC 7591</a> . <br><br>  El siguiente diagrama muestra el funcionamiento de OAuth 2.0 en la comunicación de servidor a servidor. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f06/279/e8a/f06279e8ac68f2fe664362caec6fa063.png"><br>  <i>Imagen tomada de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc6749#section-1.2</a></i> <br><br>  Hay 3 etapas principales del protocolo OAuth 2.0: <br><br><ol><li>  [Pasos de CA] Obtenga el código de autorización (en adelante, simplemente <code>code</code> ). </li><li>  [Pasos DE] <code>code</code> intercambio para <code>access_token</code> . </li><li>  Acceda al recurso utilizando <code>access_token</code> . </li></ol><br>  Examinemos el recibo del código con más detalle: <br><br><ol><li>  [Paso A] El cliente del servicio redirige al usuario al proveedor del servicio. </li><li>  [Paso B] El proveedor de servicios solicita permiso al usuario para proporcionar datos al servicio del cliente (flecha B hacia arriba).  El usuario proporciona acceso a los datos (flecha B a la derecha). </li><li>  [Paso C] El proveedor de servicios devuelve el <code>code</code> al navegador del usuario, que redirige el <code>code</code> servicio del cliente. </li></ol><br>  Veamos <code>access_token</code> obtener <code>access_token</code> más detalle: <br><br><ol><li>  [Paso D] El servidor del cliente envía una solicitud de <code>access_token</code> .  La solicitud incluye: <code>code</code> , <code>client_secret</code> y <code>redirect_uri</code> . </li><li>  [Paso E] En el caso de <code>code</code> válido, <code>client_secret</code> y <code>redirect_uri</code> , <code>client_secret</code> proporciona <code>client_secret</code> . </li></ol><br>  La solicitud de <code>access_token</code> a <code>access_token</code> se realiza de acuerdo con el esquema de servidor a servidor, por lo tanto, en general, para robar <code>client_secret</code> atacante debe piratear el servidor servidor-cliente o el servidor del proveedor de servicios. <br><br>  Ahora veamos cómo se ve el esquema OAuth 2.0 en un dispositivo móvil sin backend (interacción de cliente a servidor). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7cb/9fb/b7d/7cb9fbb7dcc35c74e921f18d22584254.png"><br>  <i>Imagen tomada de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc8252#section-4.1</a></i> <br><br>  El esquema general se divide en los mismos 3 pasos principales: <br><br><ol><li>  [pasos 1-4 en la imagen] Obtenga el <code>code</code> . </li><li>  [pasos 5-6 en la imagen] <code>code</code> intercambio para <code>access_token</code> . </li><li>  Acceda al recurso utilizando <code>access_token</code> . </li></ol><br>  Sin embargo, en este caso, la aplicación móvil también actúa como un servidor, lo que significa que <code>client_secret</code> estará <code>client_secret</code> dentro de la aplicación.  Esto lleva al hecho de que en dispositivos móviles es imposible mantener el secreto <code>lient_secret</code> de un atacante.  <code>client_secret</code> dos formas de <code>client_secret</code> a la aplicación: filtrar el tráfico de la aplicación al servidor o aplicar ingeniería inversa a la aplicación.  Ambos métodos son fáciles de implementar, por lo que <code>client_secret</code> inútil en dispositivos móviles. <br><br>  Con respecto al esquema de cliente a servidor, es posible que tenga una pregunta: "¿por qué no obtener <code>access_token</code> inmediatamente?".  Parecería, ¿por qué necesitamos un paso adicional?  Además, hay un esquema de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">concesión implícita</a> en el que el cliente recibe inmediatamente un <code>access_token</code> .  Aunque puede usarse en algunos casos, veremos a continuación que la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Subvención implícita</a> no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">es</a> adecuada para OAuth 2.0 móvil seguro. <br><br><h4>  Redireccionar en dispositivos móviles </h4><br>  En general, para una redirección desde un navegador a una aplicación en dispositivos móviles, se utilizan el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esquema URI personalizado</a> y los mecanismos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AppLink</a> .  Ninguno de estos mecanismos en su forma pura es tan confiable como una redirección de navegador. <br><br>  El esquema URI personalizado (o enlace profundo) se utiliza de la siguiente manera: el desarrollador define el esquema de la aplicación antes del ensamblaje.  El esquema puede ser arbitrario, mientras que en el mismo dispositivo se pueden instalar varias aplicaciones con el mismo esquema.  Todo es bastante simple cuando cada aplicación en el dispositivo corresponde a una aplicación.  Pero, ¿qué pasa si dos aplicaciones registraron el mismo circuito en el mismo dispositivo?  ¿Cómo puede determinar el sistema operativo cuál de las dos aplicaciones se abrirá al acceder al esquema URI personalizado?  Android mostrará una ventana con la elección de la aplicación en la que desea abrir un enlace.  En iOS, el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comportamiento no está definido</a> , lo que significa que cualquiera de las dos aplicaciones se puede abrir.  En ambos casos, un atacante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">puede interceptar código o access_token</a> . <br><br>  AppLink, en contraste con el esquema URI personalizado, está garantizado para abrir la aplicación correcta, pero este mecanismo tiene varias desventajas: <br><br><ol><li>  Cada cliente de servicio debe pasar independientemente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el procedimiento de verificación</a> . </li><li>  Los usuarios de Android pueden desactivar AppLink para una aplicación específica en la configuración. </li><li>  Android por debajo de 6.0 e iOS por debajo de 9.0 no son compatibles con AppLink. </li></ol><br>  Las desventajas anteriores de AppLink, en primer lugar, aumentan el umbral de entrada para posibles servicios de cliente y, en segundo lugar, pueden llevar al hecho de que, en determinadas circunstancias, el usuario no trabajará con OAuth 2.0.  Esto hace que AppLink no sea adecuado para reemplazar los redireccionamientos del navegador en el protocolo OAuth 2.0. <br><br><h1>  ¿A qué atacar? </h1><br>  Los problemas de OAuth 2.0 móvil también dieron lugar a ataques específicos.  Veamos qué son y cómo funcionan. <br><br><a name="1"></a><h4>  Ataque de intercepción del código de autorización </h4><br>  Datos iniciales: una aplicación legítima (cliente OAuth 2.0) y una aplicación maliciosa que registró el mismo esquema que el legítimo se instalan en el dispositivo del usuario.  La siguiente figura muestra el esquema de ataque. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a87/336/d4c/a87336d4c0d73c89a62bb448cb12d49b.png"><br>  <i>Imagen tomada de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc7636#section-1</a></i> <br><br>  Aquí está el problema: en el paso 4, el navegador devuelve el <code>code</code> a la aplicación a través del Esquema de URI personalizado, por lo que el <code>code</code> puede ser interceptado por el malware (porque registró el mismo esquema que la aplicación legítima).  Después de eso, el malware cambia el <code>code</code> a <code>access_token</code> y obtiene acceso a los datos del usuario. <br><br>  ¿Cómo protegerte?  En algunos casos, se pueden utilizar mecanismos de comunicación entre procesos; hablaremos de ellos a continuación.  En el caso general, debe aplicar un esquema llamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Clave de prueba para el intercambio de código</a> .  Su esencia se refleja en el siguiente diagrama. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/123/67e/349/12367e3497cbbd54d007a18a678bfc0d.png"><br>  <i>Imagen tomada de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc7636#section-1.1</a></i> <br><br>  En las solicitudes del cliente, hay varios parámetros adicionales: <code>code_verifier</code> , <code>code_challenge</code> (en el <code>t(code_verifier)</code> ) y <code>code_challenge_method</code> (en el diagrama <code>t_m</code> ). <br><br>  <code>Code_verifier</code> es un número aleatorio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de al menos 256 bits de longitud</a> que se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">usa solo una vez</a> .  Es decir, para <b>cada</b> solicitud de <code>code</code> cliente debe generar un nuevo <code>code_verifier</code> . <br><br>  <code>Code_challenge_method</code> es el nombre de una función de conversión, con mayor frecuencia SHA-256. <br><br>  <code>Code_challenge</code> es un <code>code_verifier</code> al que se ha <code>code_challenge_method</code> y codificado la conversión <code>code_challenge_method</code> en la URL Safe Base64. <br><br>  La conversión de <code>code_verifier</code> a <code>code_challenge</code> necesaria para proteger contra los vectores de ataque basados ​​en la intercepción de <code>code_verifier</code> (por ejemplo, desde los registros del sistema del dispositivo) cuando se solicita el <code>code</code> . <br><br>  Si el dispositivo del usuario <b>no admite</b> SHA-256, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se permite</a> una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">degradación hasta que falte la conversión code_verifier</a> .  En todos los demás casos, debe usar SHA-256. <br><br>  El esquema funciona de la siguiente manera: <br><br><ol><li>  El cliente genera un <code>code_verifier</code> y lo recuerda. </li><li>  El cliente selecciona <code>code_challenge_method</code> y obtiene <code>code_challenge</code> de <code>code_verifier</code> . </li><li>  [Paso A] El cliente solicita el <code>code</code> , con <code>code_challenge</code> y <code>code_challenge_method</code> agregado a la solicitud. </li><li>  [Paso B] El proveedor recuerda el <code>code_challenge</code> y <code>code_challenge_method</code> en el servidor y devuelve el <code>code</code> cliente. </li><li>  [Paso C] El cliente solicita <code>access_token</code> , y se agrega <code>access_token</code> a la <code>code_verifier</code> . </li><li>  El proveedor recibe el <code>code_challenge</code> del <code>code_challenge</code> entrante, y luego lo <code>code_challenge</code> el <code>code_challenge</code> , que recordaba. </li><li>  [Paso D] Si los valores coinciden, el proveedor emite un <code>access_token</code> cliente. </li></ol><br>  Veamos por qué <code>code_challenge</code> permite protegerte de un ataque de intercepción de código.  Para hacer esto, pasaremos por las etapas de obtener <code>access_token</code> . <br><br><ol><li>  Primero, una aplicación legítima solicita el <code>code</code> ( <code>code_challenge</code> y <code>code_challenge_method</code> envían junto con la <b>solicitud</b> ). </li><li>  El malware intercepta el <code>code</code> (pero no <code>code_challenge</code> , porque no hay <code>code_challenge</code> <b>en la respuesta</b> ). </li><li>  El malware solicita <code>access_token</code> (con <code>code</code> válido, pero <b>sin</b> <code>code_verifier</code> válido). </li><li>  El servidor nota la <code>code_challenge</code> coincidencia <code>code_challenge</code> y arroja un error. </li></ol><br>  Tenga en cuenta que el atacante no tiene la capacidad de adivinar el <code>code_verifier</code> (al azar 256 bits!) O encontrarlo en algún lugar de los registros ( <code>code_verifier</code> se transmite una vez). <br><br>  Si todo esto se reduce a una frase, <code>code_challenge</code> permite al proveedor de servicios responder la pregunta: " <code>access_token</code> solicita <code>access_token</code> por la misma aplicación cliente que solicitó el <code>code</code> o por otra?" <br><br><h4>  OAuth 2.0 CSRF </h4><br>  En dispositivos móviles, OAuth 2.0 a menudo se usa como mecanismo de autenticación.  Como recordamos, la autenticación a través de OAuth 2.0 difiere de la autorización en que las vulnerabilidades de OAuth 2.0 afectan los datos del usuario del lado del cliente del servicio y no del proveedor del servicio.  Como resultado, el ataque CSRF en OAuth 2.0 le permite robar la cuenta de otra persona. <br><br>  Considere un ataque CSRF contra OAuth 2.0 utilizando el ejemplo de la aplicación cliente de taxi y el proveedor provider.com.  Primero, un atacante inicia sesión en attacker@provider.com en su dispositivo y recibe un <code>code</code> para el taxi.  Después de eso, el atacante interrumpe el proceso OAuth 2.0 y genera un enlace: <br><br> <code>com.taxi.app://oauth? <br> code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4 <br></code> <br>  Luego, el atacante envía un enlace a la víctima, por ejemplo, bajo la apariencia de una carta o SMS de la administración del taxi.  La víctima <code>access_token</code> enlace, se abre una aplicación de taxi en su teléfono, que recibe <code>access_token</code> , y como resultado, la víctima termina en la cuenta de taxi del <b>atacante</b> .  Sin darse cuenta de la captura, la víctima usa esta cuenta: hace viajes, ingresa sus datos, etc. <br><br>  Ahora, un atacante puede iniciar sesión en la cuenta de taxi de la víctima en cualquier momento porque está vinculado a <code>attacker@provider.com</code> .  El ataque CSRF al iniciar sesión le permitió robar una cuenta. <br><br>  Los ataques CSRF generalmente están protegidos con un token CSRF (también llamado <code>state</code> ), y OAuth 2.0 no es una excepción.  Cómo usar el token CSRF: <br><br><ol><li>  La aplicación cliente genera y almacena el token CSRF en el dispositivo móvil del usuario. </li><li>  La aplicación cliente incluye el token CSRF en la solicitud de <code>code</code> . </li><li>  El servidor devuelve el mismo token CSRF en la respuesta junto con el código. </li><li>  La aplicación cliente compara el token CSRF entrante y almacenado.  Si los valores coinciden, entonces el proceso continúa. </li></ol><br>  Requisitos del token CSRF: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nonce de</a> al menos 256 bits de largo, obtenido de una buena fuente de secuencias pseudoaleatorias. <br><br>  En resumen, el token CSRF permite que la aplicación cliente responda la pregunta: "¿Estaba empezando a obtener <code>access_token</code> , o alguien está tratando de engañarme?" <br><br><h4>  Malware que finge ser un cliente legítimo </h4><br>  Algunos programas maliciosos pueden imitar aplicaciones legítimas y generar una pantalla de consentimiento en su nombre (la pantalla de consentimiento es una pantalla en la que el usuario ve: "Acepto otorgar acceso a ...").  El usuario desatento puede hacer clic en "permitir" y, como resultado, el malware obtiene acceso a los datos del usuario. <br><br>  Android e iOS proporcionan mecanismos para la verificación mutua de aplicaciones.  La aplicación del proveedor puede verificar la legitimidad de la aplicación del cliente y viceversa. <br><br>  Desafortunadamente, si el mecanismo OAuth 2.0 usa una transmisión a través de un navegador, entonces no puede defenderse contra este ataque. <br><br><h4>  Otros ataques </h4><br>  Examinamos los ataques que son exclusivos de OAuth 2.0 móvil.  Sin embargo, no te olvides de los ataques en OAuth 2.0 regular: <code>redirect_uri</code> , intercepción de tráfico a través de una conexión insegura, etc.  Puedes leer más sobre ellos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br><h1>  Que hacer </h1><br>  Aprendimos cómo funciona el protocolo OAuth 2.0 y descubrimos qué vulnerabilidades existen en las implementaciones de este protocolo en dispositivos móviles.  Ahora, creemos un esquema seguro de OAuth 2.0 móvil a partir de piezas individuales. <br><br><h4>  Bueno, malo OAuth 2.0 </h4><br>  Comencemos con cómo elevar correctamente la pantalla de consentimiento.  En dispositivos móviles, hay dos formas de abrir una página web desde una aplicación nativa (ejemplos de aplicaciones nativas: Mail.Ru Mail, VK, Facebook). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ee/bd1/d02/7eebd1d02b5fa11a820fe37abbd1c552.png"><br><br>  El primer método se llama la pestaña personalizada del navegador (en la imagen de la izquierda).  <b>Nota</b> : La pestaña personalizada del navegador en Android se denomina pestaña personalizada de Chrome y en iOS SafariViewController.  De hecho, esta es una pestaña normal del navegador, que se muestra directamente en la aplicación, es decir  No hay cambio visual entre aplicaciones. <br><br>  El segundo método se llama "raise WebView" (en la imagen de la derecha), en relación con OAuth 2.0 móvil, considero que es malo. <br><br>  WebView es un navegador independiente para una aplicación nativa. <br><br>  <i>Un</i> " <i>navegador</i> independiente" significa que WebView no permite el acceso a cookies, almacenamiento, caché, historial y otros datos de los navegadores Safari y Chrome.  Lo contrario también es cierto: Safari y Chrome no pueden acceder a los datos de WebView. <br><br>  " <i>Navegador para una aplicación nativa</i> " significa que la aplicación nativa que generó WebView tiene acceso <b>completo</b> a cookies, almacenamiento, caché, historial y otros datos de WebView. <br><br>  Ahora imagine: el usuario presiona el botón "iniciar sesión usando ..." y el WebView de la aplicación maliciosa le pide su nombre de usuario y contraseña al proveedor de servicios. <br><br>  Fracaso a la vez en todos los frentes: <br><br><ol><li>  El usuario ingresa el nombre de usuario y la contraseña de la cuenta del proveedor de servicios en la aplicación, que puede robar fácilmente estos datos. </li><li>  OAuth 2.0 se desarrolló originalmente para <i>no ingresar un nombre de usuario y contraseña</i> de un proveedor de servicios. </li><li>  El usuario se acostumbra a ingresar el nombre de usuario y la contraseña en cualquier lugar, la probabilidad de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">phishing</a> aumenta. <br></li></ol><br>  Dado que todos los argumentos están en contra de WebView, la conclusión se sugiere a sí misma: abrir la pestaña personalizada del navegador para la pantalla de consentimiento. <br><br>  Si alguno de ustedes tiene argumentos a favor de WebView en lugar de la pestaña personalizada del navegador, escríbalo en los comentarios, lo agradeceré. <br><br><h4>  Esquema seguro de Mobile OAuth 2.0 </h4><br>  Utilizaremos el esquema de concesión de código de autorización porque nos permite agregar un <code>code_challenge</code> y protegernos de un ataque de intercepción de código. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7cb/9fb/b7d/7cb9fbb7dcc35c74e921f18d22584254.png"><br>  <i>Imagen tomada de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc8252#section-4.1</a></i> <br><br>  La solicitud de código (pasos 1-2) se verá así: <br><br> <code>https://o2.mail.ru/code? <br> redirect_uri=com.mail.cloud.app%3A%2F%2Foauth&amp; <br> anti_csrf=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24&amp; code_challenge=ZjYxNzQ4ZjI4YjdkNWRmZjg4MWQ1N2FkZjQzNGVkODE1YTRhNjViNjJjMGY5MGJjNzdiOGEzMDU2ZjE3NGFiYw%3D%3D&amp; <br> code_challenge_method=S256&amp; <br> scope=email%2Cid&amp; <br> response_type=code&amp; <br> client_id=984a644ec3b56d32b0404777e1eb73390c <br></code> <br>  En el paso 3, el navegador recibe una respuesta redirigida: <br><br> <code>com.mail.cloud.app://outh? <br> code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4&amp; <br> anti_csrf=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24</code> <br> <br>  En el paso 4, el navegador abre el esquema URI personalizado y pasa el <code>code</code> y el token CSRF a la aplicación cliente. <br><br>  Solicitud de <code>access_token</code> (paso 5): <br><br> <code>https://o2.mail.ru/token? <br> code_verifier=e61748f28b7d5daf881d571df434ed815a4a65b62c0f90bc77b8a3056f174abc&amp; <br> code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4&amp; <br> client_id=984a644ec3b56d32b0404777e1eb73390c <br></code> <br>  El último paso devuelve una respuesta con <code>access_token</code> . <br><br>  En general, el esquema anterior es seguro, pero también hay casos especiales en los que OAuth 2.0 puede hacerse más simple y un poco más seguro. <br><br><h4>  Android IPC </h4><br>  Android tiene un mecanismo para el intercambio de datos bidireccional entre procesos: IPC (comunicación entre procesos).  Se prefiere IPC sobre el esquema URI personalizado por dos razones: <br><br><ol><li>  Una aplicación que abre un canal IPC puede verificar la autenticidad de una aplicación abierta mediante su certificado.  Lo contrario también es cierto: una aplicación abierta puede verificar la autenticidad de la aplicación que la abrió. </li><li>  Al enviar una solicitud a través de un canal IPC, el remitente puede recibir una respuesta a través del mismo canal.  Junto con la verificación mutua (elemento 1), esto significa que ningún proceso de terceros puede interceptar <code>access_token</code> . </li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/693/84d/6f6/69384d6f63788694137f8d559d6469fa.png"><br><br>  Por lo tanto, podemos usar la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Subvención implícita</a> y simplificar enormemente el esquema móvil OAuth 2.0.  Sin <code>code_challenge</code> y tokens CSRF.  Además, podremos protegernos del malware que imita a clientes legítimos para robar cuentas de usuario. <br><br><h4>  SDK del cliente </h4><br>  Además de implementar el esquema seguro de OAuth 2.0 móvil descrito anteriormente, el proveedor debe desarrollar un SDK para sus clientes.  Esto facilitará la implementación de OAuth 2.0 en el lado del cliente y al mismo tiempo reducirá la cantidad de errores y vulnerabilidades. <br><br><h1>  Sacar conclusiones </h1><br>  Para los proveedores de OAuth 2.0, compilé la "Lista de verificación de Secure Mobile OAuth 2.0": <br><br><ol><li>  Una base sólida es vital.  En el caso de OAuth 2.0 móvil, la base es el esquema o protocolo que elegimos implementar.  Al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">implementar su propio esquema OAuth 2.0,</a> es fácil cometer un error.  Otros ya han llenado los baches y han llegado a conclusiones, no hay nada de malo en aprender de sus errores e inmediatamente hacer una implementación segura.  En general, el esquema OAuth 2.0 móvil más seguro es el de la sección ¿Qué hacer? </li><li>  <code>Access_token</code> y otros datos confidenciales: en iOS, en Llavero, en Android, en Almacenamiento interno.  Estos repositorios están diseñados específicamente para tales fines.  Si es necesario, puede usar el proveedor de contenido en Android, pero debe configurarse de manera segura. </li><li>  <code>Code</code> debe ser de una sola vez, con un tiempo de vida corto. </li><li>  Para protegerse contra la intercepción de código, use <code>code_challenge</code> . </li><li>  Para protegerse contra un ataque CSRF en el inicio de sesión, use tokens CSRF. </li><li>  No use WebView para la pantalla de consentimiento, use la pestaña personalizada del navegador. </li><li>  <code>Client_secret</code> <b>inútil</b> si no está almacenado en el backend.  No se lo dé a clientes públicos. </li><li>  Use HTTPS en <b>todas partes</b> , con la prohibición de rebajar a HTTP. </li><li>  Siga las recomendaciones de criptografía (selección de cifrado, longitud del token, etc.) <b>de los estándares</b> .  Puede copiar los datos y descubrir por qué se hizo de esa manera, pero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no puede hacer su criptografía</a> . </li><li>  Desde la aplicación del cliente, verifique a quién abre para OAuth 2.0, y desde la aplicación del proveedor, verifique quién lo abre para OAuth 2.0. </li><li>  Tenga en cuenta las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">vulnerabilidades habituales de OAuth 2.0</a> .  Mobile OAuth 2.0 amplía y complementa el normal, por lo que nadie canceló la verificación de <code>redirect_uri</code> para ver las coincidencias exactas y otras recomendaciones para OAuth 2.0 regular. </li><li>  Asegúrese de proporcionar SDK a los clientes.  El cliente tendrá menos errores y vulnerabilidades en el código, y será más fácil para él implementar su OAuth 2.0. </li></ol><br><h1>  Que leer </h1><br><ol><li>  [RFC] OAuth 2.0 para aplicaciones nativas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc8252</a> </li><li>  Google OAuth 2.0 para aplicaciones móviles y de escritorio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://developers.google.com/identity/protocols/OAuth2InstalledApp</a> </li><li>  [RFC] Clave de prueba para el intercambio de código por parte de clientes públicos de OAuth <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc7636</a> </li><li>  Condición de carrera OAuth 2.0 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://hackerone.com/reports/55140</a> </li><li>  [RFC] Modelo de amenaza OAuth 2.0 y consideraciones de seguridad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc6819</a> </li><li>  Ataques en OAuth 2.0 normal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://sakurity.com/oauth</a> </li><li>  [RFC] Protocolo de registro de cliente dinámico OAuth 2.0 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://tools.ietf.org/html/rfc7591</a> </li></ol><br><h1>  Agradecimientos </h1><br>  Gracias a todos los que ayudaron a escribir este artículo, especialmente Sergey Belov, Andrey Sumin, Andrey Labunts ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@isciurus</a> ) y Daria Yakovleva. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es417031/">https://habr.com/ru/post/es417031/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es417015/index.html">Entendemos qué registros y qué no registra la aplicación Burger King</a></li>
<li><a href="../es417017/index.html">Cómo un experimento nuclear fallido generó accidentalmente astronomía de neutrinos</a></li>
<li><a href="../es417023/index.html">Experiencia del Grupo Rambler: cómo comenzamos a controlar completamente la formación y el comportamiento de los componentes de React front-end</a></li>
<li><a href="../es417027/index.html">¿Cómo escribí la biblioteca estándar de C ++ 11 o por qué boost es tan aterrador? Introduccion</a></li>
<li><a href="../es417029/index.html">Perfilado de código con LLVM</a></li>
<li><a href="../es417033/index.html">QIWI Kitchen el 7 de junio: video de los discursos de nuestros oradores</a></li>
<li><a href="../es417035/index.html">UnnyWorld: post mortem</a></li>
<li><a href="../es417037/index.html">BRAZADORES DE CERVEZA. Control de luz. Vixen Lights 3. Inicio rápido (1/4)</a></li>
<li><a href="../es417039/index.html">Aprenda wordpress (y más) para reproducir reproductores de YouTube rápidamente</a></li>
<li><a href="../es417041/index.html">eslint-scope v3.7.2 roba tokens NPM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>