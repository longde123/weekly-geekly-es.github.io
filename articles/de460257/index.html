<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛀🏼 👨🏽‍🔧 👕 Hallo Welt! Tiefes Eintauchen in Terminals 🧑 🌀 🤴🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich wurde inspiriert, diesen Artikel durch einen Artikel über die Analyse von Sishny printf zu schreiben. Es wurde jedoch ein Moment verpasst, in welc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hallo Welt! Tiefes Eintauchen in Terminals</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460257/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ha/5f/0v/ha5f0vjiijc9c92bnnt56z7jcpg.jpeg"></a> </p><br><p>  Ich wurde inspiriert, diesen Artikel durch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Artikel über die Analyse von Sishny printf</a> zu schreiben.  Es wurde jedoch ein Moment verpasst, in welche Richtung die Daten gehen, nachdem sie in das Endgerät eingegeben wurden.  In diesem Artikel möchte ich diesen Fehler beheben und den Datenpfad im Terminal analysieren.  Wir werden auch verstehen, wie sich Terminal von Shell unterscheidet, was Pseudoterminal ist, wie Terminalemulatoren funktionieren und vieles mehr. </p><a name="habracut"></a><br><h2 id="osnovy">  Die Grundlagen </h2><br><p>  Lassen Sie uns zunächst verstehen, was Terminal, Shell, Konsole ist, wie sich der Terminal-Emulator vom normalen Terminal unterscheidet und warum er so benannt ist.  Es wurden bereits viele Informationen darüber geschrieben, so dass Sie hier nichts Neues hören werden.  Fast alle Informationen hier stammen aus dem Internet, ich werde am Ende des Artikels Links bereitstellen.  Wer bereits weiß, was all diese Dinge bedeuten, kann diesen Abschnitt sicher überspringen. </p><br><hr><br><h3 id="terminal">  Terminal </h3><br><p>  <strong>Ein Terminal</strong> ist eine Kombination aus einem Display und einer Tastatur, dh einem physischen Gerät.  Bevor die Terminals zu dieser speziellen Kombination wurden, waren sie eine Art Gerät namens Fernschreiber (Teletyp, Teletypewriter oder kurz TTY), dh eine Kombination aus einem Drucker und einer Tastatur.  In der Regel sind mehrere Terminals an denselben Computer angeschlossen.  Somit war es möglich, für mehrere Benutzer am selben Computer zu arbeiten, und jeder hatte seine eigene Sitzung, unabhängig von den anderen.  Das Terminal wurde so benannt, weil es sich am Ende des Terminalkabels befand. </p><br><p>  Dies ist <strong>Teletyp</strong> : </p><br><img src="https://habrastorage.org/webt/m3/_3/yt/m3_3ytmmoofzwgpr3dpu78w8m7i.jpeg" alt="Teletype" title="Teletyp" width="430" height="370"><br><br><p>  Und das ist <strong>Terminal</strong> : </p><br><img src="https://habrastorage.org/webt/pz/lj/eu/pzljeumccjvqmrunt-pqolnyx-c.jpeg" alt="Terminal" title="Terminal" width="430" height="370"><br><br><hr><br><h3 id="console">  Konsole </h3><br><p>  <strong>Konsole (Konsole)</strong> - ein Terminal, das direkt mit dem Computer verbunden ist.  Tatsache ist, dass die meisten Terminals implizit verbunden waren, aber mindestens eines direkt mit dem Computer verbunden war.  Die Konsole durfte einen genau definierten Personenkreis verwenden, da Sie den Computer konfigurieren konnten. </p><br><hr><br><h3 id="shell">  Shell </h3><br><p>  Wenn es sich bei den beiden vorherigen Geräten um physische Geräte handelt, bezieht sich diese Definition ausschließlich auf Software. </p><br><p>  <strong>Shell</strong> ist ein Befehlszeileninterpreter.  Der Hauptzweck besteht darin, andere Programme auszuführen.  Es gibt eine große Anzahl verschiedener Muscheln.  Am gebräuchlichsten ist Bash (aus der englischen Bourne Again SHell, die, wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia</a> vorschlägt, ein Wortspiel für "Born again" Shell ist, dh eine "wiederbelebte" Shell).  Andere Beispiele: Dash (eine leichte Shell, verfügbar, wenn Sie die Binärdatei unter / bin / sh ausführen), Zsh. </p><br><hr><br><p>  Natürlich konnten sowohl Terminals als auch Konsolen in der Neuzeit ihr Spiegelbild finden.  Daher werden wir weiter Dinge wie <em>Terminal Emulator</em> und <em>Virtual Console betrachten</em> . </p><br><h3 id="terminal-emulator">  Terminalemulator </h3><br><p>  <strong>Terminal Emulator</strong> - ein Emulator des guten alten Terminals.  Für Programme, die nicht direkt mit dem X Window System interagieren können, ist ein Terminalemulator erforderlich - Bash, Vim und andere. </p><br><p>  Lassen Sie uns zunächst die Verantwortlichkeiten des Terminals festlegen: </p><br><ol><li>  Übertragen Sie Benutzereingaben auf einen Computer </li><li>  Lieferung der Computerausgabe an das Display </li></ol><br><p>  Unser Terminal-Emulator macht also genau das Gleiche: Er liefert Benutzereingaben an das laufende Programm und zeigt auch die Ausgabe des Programms auf dem Display an.  In jedem Fall bleibt die Bedeutung erhalten - zwischen dem Benutzer und dem laufenden Programm gibt es eine Art Schicht, die für die Eingabe / Ausgabe verantwortlich ist.  Beispiele für Terminal Emulator: gnome-terminal, xterm, konsole. </p><br><p>  <strong>Bitte verwechseln Sie Shell und Terminal Emulator nicht!</strong> <br>  Terminal Emulator ist eine GUI-Anwendung, dh ein Fenster im X Window System.  Shell ist ein Befehlszeileninterpreter, dh nur ein Befehlsausführender, der keine grafische Shell hat.  Wenn Sie ganz richtig sprechen, <strong>starten Sie Bash nicht</strong> , <strong>sondern</strong> <strong>führen den Terminal Emulator aus, der Bash in sich selbst startet</strong> .  Terminal Emulator und Bash sind absolut zwei verschiedene Programme.  Der erste ist allein für die Eingabe / Ausgabe verantwortlich, der zweite für die Verarbeitung von Befehlen. </p><br><p>  Weiter im Artikel beziehen sich alle Verweise auf das Terminal auf den Terminalemulator. </p><br><hr><br><h3 id="virtual-console-virtual-terminal">  Virtuelle Konsole (virtuelles Terminal) </h3><br><p>  Drücken Sie Strg + Alt + FN, wobei N normalerweise Werte von 1 bis 6 hat. Was Sie gerade gesehen haben, heißt Virtuelle Konsole (virtuelle Konsole) oder Virtuelles Terminal (virtuelles Terminal).  Erinnerst du dich, was ich früher über Terminals gesagt habe?  Viele Terminals waren an einen Computer angeschlossen, und jedes Terminal war eine separate Sitzung, unabhängig von den anderen.  Virtual Console wiederholt diese Idee: Es können mehrere unabhängige Sitzungen in Ihrem Computer vorhanden sein (die Computerressourcen werden jedoch offensichtlich immer noch gemeinsam genutzt). </p><br><p>  Sie können diese Entität sowohl als virtuelle Konsole als auch als virtuelles Terminal bezeichnen, da eine Konsole per Definition ein Terminal ist, das direkt mit einem Computer verbunden ist, aber alle virtuellen Terminals gewissermaßen direkt mit einem Computer verbunden sind. </p><br><hr><br><h3 id="tty-ustroystva">  TTY-Geräte </h3><br><p>  Jedem Terminal ist ein eigenes <em>TTY-Gerät</em> (Terminal Device) zugeordnet, das die Konsole bereitstellt.  Es ist zwar unwahrscheinlich, dass Sie Teletypen finden, aber die Verringerung der TTY hat bis heute überlebt. </p><br><p>  Ein TTY-Gerät besteht aus zwei grundlegenden Komponenten: </p><br><ol><li>  <strong>Gerätetreiber</strong>  Er ist verantwortlich für die Übermittlung der Tastatureingabe an das Programm und für die Anzeige der Programmausgabe auf dem Bildschirm. </li><li>  <strong>TTY Line Discipline</strong> (Russisch - Liniendisziplin).  Leitungsdisziplin ist die Treiberzugriffsschnittstelle, die dem TTY-Gerät jedoch viel Logik verleiht.  Wir können sagen, dass Leitungsdisziplin-Proxies den Fahrer anrufen.  Welchen Verantwortungsbereich diese Komponente hat, erfahren Sie im Artikel. </li></ol><br><p>  TTY-Gerät erstellen: </p><br><p><img src="https://habrastorage.org/webt/zn/zw/dy/znzwdyjadyeidyogqoap8kfvgng.jpeg" title="Sehen Sie ein TTY-Gerät"></p><br><p>  Es gibt 3 Arten von TTY-Geräten: </p><br><ol><li>  <em>Konsolengerät</em> - Ermöglicht den Betrieb der virtuellen Konsole.  Die Ein- und Ausgabe dieses Geräts wird vollständig vom Kernel gesteuert. </li><li>  <em>PTY-Gerät</em> (Pseudo-Terminal) - Bereitstellung des Terminalbetriebs in der Fensterschnittstelle.  Die Ein- und Ausgabe dieses Geräts wird von einem Terminalemulator gesteuert, der im Benutzerbereich arbeitet. </li><li>  <em>Serielles Gerät</em> - kommuniziert direkt mit der Hardware.  Es wird normalerweise nicht direkt verwendet, sondern ist die unterste Ebene in der Organisation der Architektur eines Endgeräts. </li></ol><br><p>  In diesem Artikel werden wir speziell auf den zweiten Typ von TTY-Geräten eingehen - Pseudo-Terminals. </p><br><hr><br><h2 id="tty-line-discipline">  TTY Line Disziplin </h2><br><p>  Wir beginnen, die Disziplin der TTY-Gerätelinie zu untersuchen. </p><br><p>  Das erste wichtige Merkmal einer Liniendisziplin ist, dass sie für die Verarbeitung von E / A verantwortlich ist.  Dies umfasst beispielsweise die Verarbeitung von Steuerzeichen (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Steuerzeichen">Steuerzeichen</a> ) und die Formatierung der Ausgabe.  Zum Beispiel geben Sie einen beliebigen Text ein, aber plötzlich stellen Sie fest, dass Sie sich beim Schreiben von etwas geirrt haben und es löschen möchten - hier kommt die Liniendisziplin ins Spiel. </p><br><p>  Wir werden im Detail analysieren, was genau passiert, wenn wir in Bash arbeiten und im Terminal laufen.  Standardmäßig arbeitet ein TTY-Gerät im kanonischen Modus mit <em>aktiviertem Echo</em> .  Ein Echo ist eine Anzeige der Zeichen, die Sie auf dem Bildschirm eingegeben haben. </p><br><p> Wenn wir zum Beispiel das Zeichen <code>a</code> eingeben, wird dieses Zeichen an das TTY-Gerät gesendet, aber von der Disziplin der TTY-Zeile des Geräts abgefangen.  Sie liest ein Zeichen in ihren internen Puffer ein, sieht, dass der <code>echo</code> aktiviert ist, und zeigt das Zeichen auf dem Bildschirm an.  Derzeit ist noch nichts zum Lesen des Programms verfügbar, an das das Endgerät angeschlossen ist.  Lassen Sie uns die <code>backspace</code> auf der Tastatur drücken.  Symbol <code>^?</code>  erneut von der Zeilendisziplin abgefangen, und letztere erkennt, dass der Benutzer das zuletzt eingegebene Zeichen löschen möchte, entfernt dieses Zeichen aus seinem internen Puffer und löscht dieses Zeichen auch vom Bildschirm.  Wenn wir nun die Eingabetaste drücken, sendet die TTY-Leitungsdisziplin schließlich alles, was zuvor in den internen Puffer der Disziplin geschrieben wurde, einschließlich LF, an den Lesepuffer des Endgeräts.  Gleichzeitig werden die Zeichen CR und LF auf dem Bildschirm angezeigt, um den Cursor auf eine neue Zeile zu bewegen - dies ist die Formatierung der Ausgabe. </p><br><p>  So funktioniert der kanonische Modus: Er überträgt alle eingegebenen Zeichen erst nach Drücken der <code>Enter</code> auf das Gerät, verarbeitet die Steuerzeichen und formatiert die Ausgabe. </p><br><h3 id="tty-line-editing">  TTY-Zeilenbearbeitung </h3><br><p>  <strong>TTY Line Editing</strong> ist die Komponente, die für die Verarbeitung von Eingaben in der Zeilendisziplin verantwortlich ist.  Es sollte gesagt werden, dass die <em>Zeilenbearbeitung</em> ein allgemeines Konzept ist und sich auf die Eingabeverarbeitung bezieht.  Zum Beispiel haben Bash und Vim ihre eigene Zeilenbearbeitung. </p><br><p>  Mit dem Programm <strong>stty</strong> können wir die Disziplineinstellungen der Leitung des aktuellen TTY-Geräts <strong>steuern</strong> .  Lass uns ein bisschen experimentieren. </p><br><p>  Öffnen Sie Bash oder eine andere Shell und geben Sie Folgendes ein: </p><br><pre> <code class="plaintext hljs">stty icanon -echo</code> </pre> <br><p>  Versuchen Sie nun, etwas einzugeben, und Sie werden Ihre Eingabe nicht sehen (keine Sorge, Sie können die Eingabe trotzdem an das Programm übergeben).  Sie haben gerade das Echo deaktiviert, dh die Anzeige der eingegebenen Zeichen auf dem Bildschirm.  Geben Sie nun Folgendes ein: </p><br><pre> <code class="plaintext hljs">stty raw echo</code> </pre> <br><p>  Versuchen Sie etwas zu tippen.  Sie sehen, wie die Schlussfolgerung gebrochen ist.  Aber für mehr Effekt gehen wir zu Dash - geben Sie <code>/bin/sh</code> .  Versuchen Sie nun, Sonderzeichen einzugeben ( <code>Ctrl</code> + ein beliebiges Zeichen auf der Tastatur) oder drücken <code>Enter</code> einfach die <code>Enter</code> .  Sie sind ratlos - was sind diese seltsamen Zeichen auf dem Bildschirm?  Tatsache ist, dass wir, nachdem wir die einfachste Shell eingegeben haben, zusätzlich zur Linienbearbeitung der Disziplin selbst auch den Linienbearbeitungs-Bash deaktiviert haben und nun mit Macht und Hauptwirkung den Effekt der Einbeziehung des <em>rohen</em> Disziplinierungsmodus der Linie beobachten können.  Dieser Modus verarbeitet Eingaben überhaupt nicht und formatiert keine Ausgaben.  Warum wird der Raw-Modus benötigt?  Zum Beispiel für <em>Vim</em> : Es öffnet sich in das gesamte Terminalfenster und verarbeitet die Eingabe selbst, zumindest damit sich spezielle Symbole der Liniendisziplin nicht mit speziellen Symbolen von Vim selbst überschneiden. </p><br><p>  Schauen wir uns zum noch besseren Verständnis das Anpassen von Steuerzeichen an.  Der <code>stty &lt;control-character&gt; &lt;string&gt;</code> hilft uns dabei. <br>  Geben Sie in Bash ein: </p><br><pre> <code class="bash hljs">stty erase 0</code> </pre> <br><p>  Jetzt wird das <code>erase</code> dem Zeichen <code>0</code> zugewiesen.  Die <code>backspace</code> normalerweise wichtig <code>^?</code>  , aber jetzt wird dieses Sonderzeichen buchstäblich an den PTS-Lesepuffer gesendet - probieren Sie es selbst aus.  Jetzt können Sie Zeichen mit der Taste <code>0</code> auf der Tastatur löschen, da Sie selbst die Zeilendisziplin gebeten haben, das eingegebene Zeichen als Löschsteuerzeichen zu erkennen.  Sie können die Einstellung mit dem Befehl <code>stty erase ^\?</code>  oder einfach das Terminal schließen, weil wir nur das aktuelle tty-Gerät betroffen haben. </p><br><p>  Weitere Informationen finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Mann stty">man stty</a> . </p><br><hr><br><h2 id="terminal-emulator-i-pseudoterminal">  Terminal Emulator und Pseudoterminal </h2><br><p>  Jedes Mal, wenn wir ein neues Terminal im X Window System öffnen, erzeugt der GNOME Terminal Server einen neuen Prozess und startet das Standardprogramm darin.  Normalerweise ist dies eine Art Shell (zum Beispiel Bash). </p><br><p>  Die Kommunikation mit dem laufenden Programm erfolgt über das sogenannte <strong>Pseudoterminal</strong> (Pseudo-Terminal, PTY).  Das Pseudo-Terminal selbst existiert im Kernel, empfängt jedoch Eingaben aus dem Benutzerbereich - vom Terminal-Emulator. </p><br><p>  Das Pseudo-Terminal besteht aus den folgenden zwei <em>virtuellen TTY-Geräten</em> : <br>  1) <strong>PTY-Master (PTM)</strong> - der führende Teil des Pseudo-Terminals.  Wird vom GNOME-Terminalserver verwendet, um Tastatureingaben an ein im Terminal ausgeführtes Programm zu übertragen sowie Programmausgaben und Anzeigeausgaben zu lesen.  Der GNOME-Terminalserver kommuniziert wiederum über das X-Protokoll mit dem X Window System. <br>  2) <strong>PTY-Slave (PTS)</strong> - Slave-Teil des Pseudo-Terminals.  Wird von einem Programm verwendet, das im Terminal ausgeführt wird, um Tastatureingaben zu lesen und Ausgaben auf dem Bildschirm anzuzeigen.  Zumindest das Programm selbst glaubt das (ich werde etwas weiter erklären, was dies bedeutet). </p><br><p>  Alle im PTS-Gerät aufgezeichneten Daten sind der Eingang des PTM-Geräts, dh sie werden auf dem PTM-Gerät lesbar.  Und umgekehrt: Alle im PTM-Gerät aufgezeichneten Daten sind der Eingang des PTS-Geräts.  Auf diese Weise kommunizieren der GNOME-Terminalserver und das im Terminal ausgeführte Programm.  Jedes PTM-Gerät ist einem eigenen PTS-Gerät zugeordnet. </p><br><p>  Der Start eines neuen Terminals sieht ungefähr so ​​aus: <br>  1) GNOME Terminal Server erstellt Master- und Slave-Geräte durch Aufrufen der Funktion open () auf einem speziellen Gerät <strong>/ dev / ptmx</strong> .  Der Aufruf open () gibt den Dateideskriptor des erstellten PTM-Geräts zurück - <em>master_fd</em> . <br>  2) GNOME Terminal Server erstellt einen neuen Prozess durch Aufrufen von <code>fork()</code> .  Dieser Prozess wird das neue Terminal sein. <br>  3) Im PTS-Terminal wird das Gerät in den Dateideskriptoren 0, 1, 2 (stdin, stdout bzw. stderr) geöffnet.  Jetzt fließen Standard-Terminal-E / A zu diesem Gerät. <br>  4) Das gewünschte Programm wird im Terminal durch Aufrufen der Funktion <code>exec()</code> gestartet.  Einige Shell starten normalerweise (zum Beispiel Bash).  Jedes Programm, das anschließend von Bash aus gestartet wird, hat dieselben Dateideskriptoren wie Bash selbst, dh die Programmabläufe werden an das PTS-Gerät geleitet. </p><br><p>  Mit dem <code>ls -la /proc/self/fd</code> können Sie selbst sehen, wohin die Standard-Terminal-Ausgangsflüsse geleitet werden: <br><img src="https://habrastorage.org/webt/nr/dx/97/nrdx97wllflvapnt76p3qqki3fw.jpeg"></p><br><p>  Das PTS-Gerät befindet sich im Pfad <strong>/ dev / pts / N</strong> , und der Pfad zum PTM-Gerät interessiert uns überhaupt nicht.  Tatsache ist, dass der GNOME-Terminalserver bereits über einen Dateideskriptor für das geöffnete PTM-Gerät verfügt und keinen Pfad dazu benötigt. Im untergeordneten Prozess müssen wir das PTS-Gerät jedoch in Standardausgabestreams <code>open()</code> indem wir die Funktion <code>open()</code> aufrufen, für die der Pfad zur Datei erforderlich ist. </p><br><p>  Denken Sie daran, ich sagte, dass ein Programm, das ein PTS-Gerät verwendet, nur denkt, dass es direkt mit dem Terminal kommuniziert?  Tatsache ist, dass das PTS auch ein <em>Endgerät</em> (TTY-Gerät) ist, aber der Unterschied zwischen dem PTS-Gerät und dem tatsächlichen TTY-Gerät besteht darin, dass das PTS-Gerät Eingaben nicht von der Tastatur, sondern vom Master-Gerät empfängt und die Ausgabe nicht an das Display, sondern an geht Master-Gerät.  Deshalb heißt das Pseudo-Terminal so - das Pseudo-Terminal ahmt nur (wieder ??) das Terminal nach.  Der Unterschied zwischen dem Terminalemulator und dem Pseudo-Terminal besteht darin, dass der Terminal-Emulator nur ein grafisches Programm ist, mit dem Sie das Terminal direkt in der Fensterschnittstelle ausführen können. Diese Funktion wird jedoch mithilfe des Pseudo-Terminals implementiert. </p><br><p>  Die Tatsache, dass das <em>PTS-Gerät ein TTY-Gerät</em> ist <em>,</em> ist sehr wichtig.  Deshalb: </p><br><ol><li>  Das Programm, an das das Endgerät angeschlossen ist, verfügt über alle Funktionen eines herkömmlichen Terminals.  Zum Beispiel: Echo deaktivieren, kanonische Ansicht deaktivieren / aktivieren. </li><li>  Das Programm kann interaktiv arbeiten und den Benutzer um Eingabe bitten, da es weiß, dass ein Endgerät daran angeschlossen ist (es wird gesagt, dass das Programm über ein Steuerterminal verfügt).  Fragen Sie beispielsweise nach einem Benutzernamen und einem Passwort. </li><li>  Es gibt auch eine TTY-Zeilendisziplin, sodass wir Steuerzeichen verarbeiten können, bevor sie das Programm erreichen, und die Ausgabe des Programms formatieren können. </li></ol><br><p>  Das PTM-Gerät ist ebenfalls ein TTY-Gerät, spielt jedoch keine Rolle, da es nicht als Steuerterminal verwendet wird.  Darüber hinaus ist die Leitungsdisziplin des PTM-Geräts auf den Rohmodus eingestellt, weshalb beim Übertragen von Daten vom PTS zum PTM-Gerät keine Verarbeitung durchgeführt wird.  Aufrufe zum <code>read()</code> und <code>write()</code> aus dem Benutzerbereich werden jedoch immer noch zuerst von der Leitungsdisziplin auf beiden Geräten bedient.  Dieser Moment wird eine noch größere Rolle spielen, wie wir später sehen werden. </p><br><p>  Der Kommunikationsprozess zwischen dem GNOME-Terminalserver und dem im Terminal ausgeführten Programm ist wie folgt: </p><br><p><img src="https://habrastorage.org/webt/jz/y0/sg/jzy0sg0zjcceaflg6wyg7d5lkti.jpeg" title="Der Prozess der Kommunikation von GNOME Terminalserver und ein Programm, das im Terminal wird wird"></p><br><p>  Es lohnt sich, die Rolle der Liniendisziplin bei der Kommunikation zwischen beiden Teilen eines Pseudo-Terminals genauer zu untersuchen.  Hier ist die Leitungsdisziplin für die Verarbeitung von Daten verantwortlich, <em>die vom PTM zum PTS-Gerät übertragen werden</em> , sowie für die Lieferung von Daten von einem Teil des Pseudo-Terminals zu einem anderen.  Wenn wir uns im PTS-Gerätetreiber befinden, wenden wir die Leitungsdisziplin des PTM-Geräts an und umgekehrt. </p><br><hr><br><h2 id="virtualnye-ustroystva">  Virtuelle Geräte </h2><br><p>  Sie hätten wahrscheinlich gedacht, Sie könnten die Datei entlang des Pfads <em>/ dev / pts / N</em> öffnen und Daten daraus schreiben oder lesen, wie aus einer normalen Textdatei?  Ja, alle Geräte auf Unix-ähnlichen Systemen sind Dateien, dank des Grundprinzips von Unix, das besagt, dass alles eine Datei ist.  Keine speziellen Gerätedateien (Englisch - Gerätedatei) sind jedoch Textdateien.  Solche Geräte werden als <strong>virtuelle Geräte</strong> bezeichnet, dh sie befinden sich ausschließlich im Speicher und nicht auf der Festplatte. </p><br><p>  Versuchen Sie nicht, diese Dateien als normale Textdateien zu öffnen.  Sie können diese Geräte jedoch über <code>write()</code> und <code>read()</code> -Operationen verwenden, deren Aufruf vom Gerätetreiber bedient wird.  Lass es uns versuchen. </p><br><p>  Öffnen Sie zwei Terminalfenster und geben Sie in jeden Befehl <code>tty</code> ein.  Dieser Befehl zeigt an, welches TTY-Gerät das aktuell aktive Terminal bedient.  Geben Sie nun das <code>echo "Hello, World!" &gt; /dev/pts/N</code>  <code>echo "Hello, World!" &gt; /dev/pts/N</code> im ersten Terminalfenster, wobei N der PTS-Index des zweiten Fenstergeräts ist, wechseln Sie zum zweiten Fenster und Sie sehen Ihre Eingabe aus dem ersten Fenster.  Jetzt haben Sie die Daten auf das PTS-Gerät des zweiten Fensters geschrieben, <em>als ob sie von einem Programm ausgeführt würden, das in diesem Terminal ausgeführt wird</em> . </p><br><p><img src="https://habrastorage.org/webt/nj/3s/rp/nj3srpuzyahyvukzicfr0b5wnja.png"></p><br><hr><br><h2 id="ustroystvo-psevdoterminala">  Pseudo-Endgerät </h2><br><p>  Wir nähern uns immer mehr dem letzten Teil des Artikels, aber vorher werfen wir einen Blick unter die Haube von Linux - betrachten Sie das Gerät des Pseudo-Terminals auf Kernel-Ebene.  Es wird viel Code geben, aber ich werde versuchen, jeden gegebenen Codeblock so detailliert wie möglich zu erklären, unwichtige Details zu reduzieren und nacheinander vorzugehen. </p><br><p>  Bevor Sie beginnen, stellen wir Ihnen den sogenannten "Komponentenkorb" vor.  Während wir uns entlang des Kerns bewegen, werden wir ihm immer mehr Komponenten hinzufügen und eine Verbindung zwischen ihnen finden.  Ich hoffe, dies hilft Ihnen dabei, das Pseudo-Endgerät besser zu verstehen.  Fangen wir an. </p><br><p>  Beim Start von Linux werden die erforderlichen Gerätetreiber geladen.  Unser Pseudo-Terminal hat auch einen solchen Treiber.  Die Registrierung beginnt mit einem Aufruf dieser Funktion: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __init pty_init(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { legacy_pty_init(); unix98_pty_init(); <span class="hljs-comment"><span class="hljs-comment">// &lt;- ,    return 0; } device_initcall(pty_init); // ,      </span></span></code> </pre> <br><p>  Für alle modernen Systeme wird die Funktion <code>unix98_pty_init()</code> aufgerufen: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __init unix98_pty_init(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { ptm_driver = tty_alloc_driver(NR_UNIX98_PTY_MAX, TTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV | TTY_DRIVER_DEVPTS_MEM | TTY_DRIVER_DYNAMIC_ALLOC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(ptm_driver)) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't allocate Unix98 ptm driver"</span></span>); pts_driver = tty_alloc_driver(NR_UNIX98_PTY_MAX, TTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV | TTY_DRIVER_DEVPTS_MEM | TTY_DRIVER_DYNAMIC_ALLOC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(pts_driver)) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't allocate Unix98 pts driver"</span></span>); ptm_driver-&gt;driver_name = <span class="hljs-string"><span class="hljs-string">"pty_master"</span></span>; ptm_driver-&gt;name = <span class="hljs-string"><span class="hljs-string">"ptm"</span></span>; ptm_driver-&gt;major = UNIX98_PTY_MASTER_MAJOR; ptm_driver-&gt;minor_start = <span class="hljs-number"><span class="hljs-number">0</span></span>; ptm_driver-&gt;type = TTY_DRIVER_TYPE_PTY; ptm_driver-&gt;subtype = PTY_TYPE_MASTER; ptm_driver-&gt;init_termios = tty_std_termios; ptm_driver-&gt;init_termios.c_iflag = <span class="hljs-number"><span class="hljs-number">0</span></span>; ptm_driver-&gt;init_termios.c_oflag = <span class="hljs-number"><span class="hljs-number">0</span></span>; ptm_driver-&gt;init_termios.c_cflag = B38400 | CS8 | CREAD; ptm_driver-&gt;init_termios.c_lflag = <span class="hljs-number"><span class="hljs-number">0</span></span>; ptm_driver-&gt;init_termios.c_ispeed = <span class="hljs-number"><span class="hljs-number">38400</span></span>; ptm_driver-&gt;init_termios.c_ospeed = <span class="hljs-number"><span class="hljs-number">38400</span></span>; ptm_driver-&gt;other = pts_driver; tty_set_operations(ptm_driver, &amp;ptm_unix98_ops); pts_driver-&gt;driver_name = <span class="hljs-string"><span class="hljs-string">"pty_slave"</span></span>; pts_driver-&gt;name = <span class="hljs-string"><span class="hljs-string">"pts"</span></span>; pts_driver-&gt;major = UNIX98_PTY_SLAVE_MAJOR; pts_driver-&gt;minor_start = <span class="hljs-number"><span class="hljs-number">0</span></span>; pts_driver-&gt;type = TTY_DRIVER_TYPE_PTY; pts_driver-&gt;subtype = PTY_TYPE_SLAVE; pts_driver-&gt;init_termios = tty_std_termios; pts_driver-&gt;init_termios.c_cflag = B38400 | CS8 | CREAD; pts_driver-&gt;init_termios.c_ispeed = <span class="hljs-number"><span class="hljs-number">38400</span></span>; pts_driver-&gt;init_termios.c_ospeed = <span class="hljs-number"><span class="hljs-number">38400</span></span>; pts_driver-&gt;other = ptm_driver; tty_set_operations(pts_driver, &amp;pty_unix98_ops); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tty_register_driver(ptm_driver)) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't register Unix98 ptm driver"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tty_register_driver(pts_driver)) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't register Unix98 pts driver"</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* Now create the /dev/ptmx special device */</span></span> tty_default_fops(&amp;ptmx_fops); ptmx_fops.open = ptmx_open; cdev_init(&amp;ptmx_cdev, &amp;ptmx_fops); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cdev_add(&amp;ptmx_cdev, <span class="hljs-built_in"><span class="hljs-built_in">MKDEV</span></span>(TTYAUX_MAJOR, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>) || register_chrdev_region(<span class="hljs-built_in"><span class="hljs-built_in">MKDEV</span></span>(TTYAUX_MAJOR, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"/dev/ptmx"</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't register /dev/ptmx driver"</span></span>); device_create(tty_class, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">MKDEV</span></span>(TTYAUX_MAJOR, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">"ptmx"</span></span>);</code> </pre> <br><p>  Hier interessieren uns 3 Dinge: </p><br><ol><li>  <code>tty_set_operatons</code> für den pty-Mastertreiber und die pty-Slave-Geräte auf. </li><li>  Die Funktion <code>ptmx_open</code> , die beim Öffnen des Spezialgeräts <em>/ dev / ptmx</em> für die Erstellung beider Teile des Pseudo-Terminals <em>verantwortlich ist</em> .  Wichtig: / dev / ptmx ist kein PTM-Gerät, sondern nur eine Schnittstelle zum Erstellen eines neuen Pseudo-Terminals. </li><li>  Registrieren Sie PTM- und PTS-Gerätetreiber. </li></ol><br><p>  Lass uns in der richtigen Reihenfolge gehen: </p><br><h4 id="1-tty_set_operations">  1. tty_set_operations </h4><br><p>  Die Funktion <strong>tty_set_operations () erstellt</strong> lediglich eine Funktionstabelle für den aktuellen Treiber: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> tty_set_operations(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_operations *op) { driver-&gt;ops = op; };</code> </pre> <br><p>  Die Struktur <strong>tty_operations</strong> ist eine Funktionstabelle, mit der auf die TTY-Treiberfunktionen des Geräts <strong>zugegriffen</strong> wird. </p><br><p>  Ich werde das Wichtigste in den Strukturen <code>pty_unix98_ops</code> und <code>ptm_unix98_ops</code> , die die Funktionstabelle für die entsprechenden Teile des Pseudo-Terminals sind: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_operations ptm_unix98_ops = { .install = pty_unix98_install, .remove = pty_unix98_remove, .open = pty_open, .close = pty_close, .write = pty_write, <span class="hljs-comment"><span class="hljs-comment">// ... }; static const struct tty_operations pty_unix98_ops = { .install = pty_unix98_install, .remove = pty_unix98_remove, .open = pty_open, .close = pty_close, .write = pty_write, // ... };</span></span></code> </pre> <br><p>  Hier können Sie die Funktion pty_write beobachten, <code>pty_write</code> bereits aus dem Artikel über Sishny printf bekannt ist - wir werden etwas später darauf zurückkommen. </p><br><p>  Fügen wir diese Struktur unserem Komponentenkorb hinzu: <br><img src="https://habrastorage.org/webt/o8/e-/kc/o8e-kcpqestn7f481gcx38qmzuo.jpeg"></p><br><p>  Wie Sie sehen können, unterscheiden sich die Hauptmethoden beider Treiber überhaupt nicht.  <code>pty_read()</code> übrigens, dass es keine Funktion für die Operation read () gibt - es gibt nichts <code>pty_read()</code> wie <code>pty_read()</code> .  Tatsache ist, dass das Lesen ausschließlich durch Zeilendisziplin bedient wird.  So lernen wir das zweite wichtige Merkmal der Leitungsdisziplin kennen - das Lesen von Daten von einem TTY-Gerät. </p><br><hr><br><h4 id="2-ptmx_open">  2. ptmx_open </h4><br><p>  <strong>Fahren</strong> wir nun mit <strong>ptmx_open () fort</strong> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ptmx_open(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> inode *inode, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file *filp) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty; <span class="hljs-comment"><span class="hljs-comment">//    -   ! fsi = devpts_acquire(filp); //     devpts index = devpts_new_index(fsi); //       /dev/pts // ... tty = tty_init_dev(ptm_driver, index); // ... devpts_pty_new(fsi, index, tty-&gt;link); //     /dev/pts retval = ptm_driver-&gt;ops-&gt;open(tty, filp); //  PTM ,   }</span></span></code> </pre> <br><p>  Wir interessieren uns für die Funktion <code>tty_init_dev()</code> , wobei das erste Argument der PTM-Gerätetreiber und das zweite der Geräteindex ist.  Hier verlassen wir die Verantwortungszone des PTY-Treibers und gehen zu der Datei, die nur für die allgemeinen TTY-Geräte verantwortlich ist und nichts über unser Pseudo-Terminal weiß. </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty_init_dev(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty; tty = alloc_tty_struct(driver, idx); retval = tty_driver_install_tty(driver, tty); <span class="hljs-comment"><span class="hljs-comment">/* * Structures all installed ... call the ldisc open routines. */</span></span> retval = tty_ldisc_setup(tty, tty-&gt;link); <span class="hljs-comment"><span class="hljs-comment">//  ,       return tty; }</span></span></code> </pre> <br><p>  Zuerst <code>alloc_tty_struct()</code> wir <code>alloc_tty_struct()</code> Funktion <code>alloc_tty_struct()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *alloc_tty_struct(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty; tty = kzalloc(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*tty), GFP_KERNEL); <span class="hljs-comment"><span class="hljs-comment">//  tty_struct tty_ldisc_init(tty) //      tty_struct tty-&gt;driver = driver; //       tty_struct tty-&gt;ops = driver-&gt;ops; //        tty_struct.     tty-&gt;index = idx; //   tty  return tty; }</span></span></code> </pre> <br><p>  Das einzige, was uns hier interessiert, ist die Funktion <code>tty_ldisc_init()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tty_ldisc_init(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc *ld = tty_ldisc_get(tty, N_TTY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(ld)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PTR_ERR(ld); tty-&gt;ldisc = ld; <span class="hljs-comment"><span class="hljs-comment">//        tty_struct return 0; }</span></span></code> </pre> <br><p>  Was <code>tty_ldisc_get()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc *tty_ldisc_get(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> disc) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc *ld; <span class="hljs-comment"><span class="hljs-comment">//    struct tty_ldisc_ops *ldops; //     ldops = get_ldops(disc); //      .   ,       .   - N_TTY ld = kmalloc(sizeof(struct tty_ldisc), GFP_KERNEL | __GFP_NOFAIL); ld-&gt;ops = ldops; //       ld-&gt;tty = tty; //    tty_struct   .          return ld; }</span></span></code> </pre> <br><p>  Daher haben wir den Aufruf der Funktion <code>alloc_tty_struct()</code> , mit der die Struktur <em>tty_struct</em> zusammen mit der Liniendisziplin - der Struktur <em>tty_ldisc</em> - <em>erstellt</em> wird.  Beide Strukturen sind miteinander verbunden.  Schauen wir uns diese Strukturen genauer an. </p><br><ul><li>  <strong>tty_struct</strong> ist eine Struktur für den Zugriff auf den TTY-Gerätetreiber und einige andere Felder.  Es sieht so aus: </li></ul><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver; <span class="hljs-comment"><span class="hljs-comment">//  TTY  const struct tty_operations *ops; //  .    ,   driver-&gt;ops,       int index; //   struct tty_ldisc *ldisc; //     struct tty_struct *link; //     PTY // ... }</span></span></code> </pre> <br><ul><li>  <strong>tty_ldisc</strong> ist die Struktur für die Disziplin der TTY-Linie des Geräts.  Es besteht nur aus zwei Feldern und sieht wie folgt aus: </li></ul><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc_ops *ops; <span class="hljs-comment"><span class="hljs-comment">//    struct tty_struct *tty; //   tty_struct  .       };</span></span></code> </pre> <br><p>  Es scheint nichts kompliziertes zu sein?  Fügen wir alle bis zu diesem Punkt berücksichtigten Strukturen unserem Warenkorb hinzu und verknüpfen sie auf dieselbe Weise, wie sie im Code verbunden sind: <br><img src="https://habrastorage.org/webt/1d/bt/n4/1dbtn4m_6c6i4n7oaohoguci2m0.jpeg" alt="Erstellen Sie tty_struct" title="Sehen Sie tty_struct"></p><br><p>  Wir haben tty_struct jedoch nur für das PTM-Gerät erstellt.  Was ist mit dem PTS-Gerät?  Dazu kehren wir zur Funktion <code>tty_init_dev()</code> und erinnern uns, dass wir dann die Funktion <code>tty_driver_install_tty()</code> aufrufen <code>tty_driver_install_tty()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/** * This method is responsible * for ensuring any need additional structures are allocated and configured. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tty_driver_install_tty(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> driver-&gt;ops-&gt;install ? driver-&gt;ops-&gt;install(driver, tty) : tty_standard_install(driver, tty); }</code> </pre> <br><p>  Der Kommentar sagt uns, dass diese Methode für die Erstellung verschiedener zusätzlicher Strukturen verantwortlich ist.  PTS-Gerät und wird unsere zusätzliche Struktur sein.  Ich gebe zu, es war äußerst überraschend für mich, denn es ist verdammt noch mal das ganze Gerät und nicht nur eine Art zusätzliche Struktur!  Aber wir alle verstehen, dass alle Geräte nur eine Art Struktur sind, also fahren Sie fort.  Ok, was ist <em>Treiber-&gt; Ops-&gt; hier installieren</em> ?  Schauen Sie sich dazu noch einmal die Funktionstabelle für den PTM-Treiber an: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_operations ptm_unix98_ops = { .install = pty_unix98_install, <span class="hljs-comment"><span class="hljs-comment">// ...</span></span></code> </pre> <br><p>  Und wir verstehen, dass wir an der Funktion <code>pty_unix98_install()</code> interessiert sind: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pty_unix98_install(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pty_common_install(driver, tty, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><p>  Welches ruft die Funktion <code>pty_common_install()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pty_common_install(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> legacy) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *o_tty; <span class="hljs-comment"><span class="hljs-comment">// tty_struct    PTY -    PTS  //    ,       install.   ,   PTM     tty_struct,        if (driver-&gt;subtype != PTY_TYPE_MASTER) return -EIO; o_tty = alloc_tty_struct(driver-&gt;other, idx); tty-&gt;link = o_tty; o_tty-&gt;link = tty; }</span></span></code> </pre> <br><p>  ,   PTS       <em>tty_struct</em>   ,       PTS .           .  tty_struct  PTS    . </p><br><hr><br><h4 id="registraciya-drayvera">   </h4><br><p>        ,           TTY  (   -         ?). <br>  —  ,       PTM,   PTS : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file_operations tty_fops = { .llseek = no_llseek, .read = tty_read, .write = tty_write, .poll = tty_poll, .unlocked_ioctl = tty_ioctl, .compat_ioctl = tty_compat_ioctl, .open = tty_open, .release = tty_release, .fasync = tty_fasync, .show_fdinfo = tty_show_fdinfo, };</code> </pre> <br><p>         ,                  TTY . </p><br><hr><br><p>  Fertig.      ,       <em>/dev/ptmx</em> .  ,   PTS ,      ,   PTM ,      : </p><br><p><img src="https://habrastorage.org/webt/5w/aw/rg/5wawrgbqqw1_llmi1r8g2kbwrzc.jpeg" title="PTY erstellen"></p><br><hr><br><h2 id="hello-world">  Hallo Welt! </h2><br><p>        .          "Hello, World!",        . </p><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><span class="hljs-meta"> void main() { printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Hello, World!\n"</span></span></span><span class="hljs-meta">); }</span></span></code> </pre> <br><p> ,   "Hello, World!"    .   ,    ,  ,       .    ,    .  stdout  <em>/dev/null</em> —       .          ,       Linux. </p><br><p>      Unix        <em>write()</em> , <em>read()</em> , <em>close()</em>  ,    write()  /dev/pts/0         <code>__vfs_write()</code> : </p><br><pre> <code class="objectivec hljs">ssize_t __vfs_write(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file *file, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __user *buf, size_t count, loff_t *pos) { ssize_t ret; <span class="hljs-comment"><span class="hljs-comment">//... ret = file-&gt;f_op-&gt;write(file, buf, count, pos); //... return ret; }</span></span></code> </pre> <br><p>     write()      .   ,            : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file_operations tty_fops = { <span class="hljs-comment"><span class="hljs-comment">// ... .write = tty_write, // ...</span></span></code> </pre> <br><p>  <code>tty_write()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ssize_t tty_write(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file *file, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __user *buf, size_t count, loff_t *ppos) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty = file_tty(file); <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc *ld; ssize_t ret; ld = tty_ldisc_ref_wait(tty); ret = do_tty_write(ld-&gt;ops-&gt;write, tty, file, buf, count); tty_ldisc_deref(ld); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre> <br><p>     <em>tty_struct</em>    TTY ,           write()  .       : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc_ops n_tty_ops = { .write = n_tty_write, <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>    <code>n_tty_write()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/** * n_tty_write - write function for tty * @tty: tty device * @file: file object * @buf: userspace buffer pointer * @nr: size of I/O */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ssize_t n_tty_write(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file *file, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buf, size_t nr) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *b = buf; <span class="hljs-comment"><span class="hljs-comment">// b - ,       "Hello, World!".          int c; //    //     PTS ,  write()    0,  ,     while (nr &gt; 0) { c = tty-&gt;ops-&gt;write(tty, b, nr); //  write()       TTY  if (!c) break; b += c; //     nr -= c; //      :  -  -  -  } }</span></span></code> </pre> <br><p> ,  "Hello, World!"    write()   PTS .       : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_operations pty_unix98_ops = { .write = pty_write, <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  <code>pty_write()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pty_write(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buf, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *to = tty-&gt;link; <span class="hljs-comment"><span class="hljs-comment">//      PTY.    -  PTM  if (c &gt; 0) { //    PTM  c = tty_insert_flip_string(to-&gt;port, buf, c); //     ,       if (c) { tty_flip_buffer_push(to-&gt;port); tty_wakeup(tty); } } return c; }</span></span></code> </pre> <br><p>          : </p><br><pre> <code class="objectivec hljs"> __vfs_write() -&gt; <span class="hljs-comment"><span class="hljs-comment">// 1- :   tty_write() -&gt; do_tty_write() -&gt; n_tty_write() -&gt; // 2- :   pty_write() // 3- : </span></span></code> </pre> <br><p>     . ,       PTM . ,    . </p><br><p>  ,          <em>flip buffer</em> . <strong>Flip buffer</strong> —   ,    .  tty driver   ,      .   ,              .      ,        ,       .     ,      ,            .  -        flip buffer —       (,    -  ,         flip). </p><br><p>          ,       .  <code>tty_insert_flip_string()</code>         <code>tty_insert_flip_string_fixed_flag()</code> ,           PTM : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tty_insert_flip_string_fixed_flag(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port *port, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *chars, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> flag, size_t size) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> copied = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> goal = min_t(size_t, size - copied, TTY_BUFFER_PAGE); <span class="hljs-comment"><span class="hljs-comment">//      int space = __tty_buffer_request_room(port, goal, flags); //     struct tty_buffer *tb = port-&gt;buf.tail; //       if (unlikely(space == 0)) break; memcpy(char_buf_ptr(tb, tb-&gt;used), chars, space); //      tb-&gt;used += space; copied += space; chars += space; /* There is a small chance that we need to split the data over several buffers. If this is the case we must loop */ } while (unlikely(size &gt; copied)); return copied; }</span></span></code> </pre> <br><p>   , flip buffer        ,       ,         .        ,   —        PTM ,             . </p><br><p> ,   "Hello, World!"   PTM .    GNOME Terminal Server    <em>poll()</em> (  I/O)        master .  ,         ?  Egal wie.      ,     ,      —        . </p><br><p>            <code>tty_flip_buffer_push()</code> (   pty_write): </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/** * tty_flip_buffer_push - terminal * @port: tty port to push * * Queue a push of the terminal flip buffers to the line discipline. * Can be called from IRQ/atomic context. * * In the event of the queue being busy for flipping the work will be * held off and retried later. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> tty_flip_buffer_push(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port *port) { tty_schedule_flip(port); }</code> </pre> <br><p>  <code>tty_schedule_flip()</code> ,   ,        : </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/** * tty_schedule_flip - push characters to ldisc * @port: tty port to push from * * Takes any pending buffers and transfers their ownership to the * ldisc side of the queue. It then schedules those characters for * processing by the line discipline. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> tty_schedule_flip(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port *port) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_bufhead *buf = &amp;port-&gt;buf; <span class="hljs-comment"><span class="hljs-comment">/* paired w/ acquire in flush_to_ldisc(); ensures * flush_to_ldisc() sees buffer data. */</span></span> smp_store_release(&amp;buf-&gt;tail-&gt;commit, buf-&gt;tail-&gt;used); queue_work(system_unbound_wq, &amp;buf-&gt;work); }</code> </pre> <br><p>   ,     <em>work</em> (,   -       )       ,      —    ,    <code>flush_to_ldisc()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> flush_to_ldisc(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> work_struct *work) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port *port = container_of(work, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port, buf.work); <span class="hljs-comment"><span class="hljs-comment">//   tty_port PTM . tty_port -       TTY  struct tty_bufhead *buf = &amp;port-&gt;buf; struct tty_buffer *head = buf-&gt;head; // ... receive_buf(port, head); // ... }</span></span></code> </pre> <br><p>  <code>receive_buf()</code>          <code>__receive_buf()</code> ,      : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __receive_buf(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *cp, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *fp, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> n_tty_data *ldata = tty-&gt;disc_data; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> preops = I_ISTRIP(tty) || (I_IUCLC(tty) &amp;&amp; L_IEXTEN(tty)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ldata-&gt;real_raw) n_tty_receive_buf_real_raw(tty, cp, fp, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ldata-&gt;raw || (L_EXTPROC(tty) &amp;&amp; !preops)) n_tty_receive_buf_raw(tty, cp, fp, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tty-&gt;closing &amp;&amp; !L_EXTPROC(tty)) n_tty_receive_buf_closing(tty, cp, fp, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ldata-&gt;lnext) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> flag = TTY_NORMAL; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fp) flag = *fp++; n_tty_receive_char_lnext(tty, *cp++, flag); count--; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!preops &amp;&amp; !I_PARMRK(tty)) n_tty_receive_buf_fast(tty, cp, fp, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> n_tty_receive_buf_standard(tty, cp, fp, count); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (read_cnt(ldata)) { kill_fasync(&amp;tty-&gt;fasync, SIGIO, POLL_IN); wake_up_interruptible_poll(&amp;tty-&gt;read_wait, EPOLLIN); } }</code> </pre> <br><p>  ,   <em>n_tty_receive_buf</em> ( ,    _raw)           <strong>read_buf</strong> ,         TTY .      PTM    raw ,           read_buf. ,        PTM  PTS ,     . </p><br><p>       ,   : </p><br><pre> <code class="objectivec hljs"> ... pty_write() -&gt; <span class="hljs-comment"><span class="hljs-comment">// 3- :  PTS  tty_insert_flip_string + tty_flip_buffer_push() -&gt; tty_schedule_flip() -&gt; --- //    PTM  flush_to_ldisc() -&gt; // 2- :   PTM  receive_buf() -&gt; n_tty_receive_buf -&gt; n_tty_receive_buf_common -&gt; __receive_buf()</span></span></code> </pre> <br><p> ,   PTM        —         PTS . </p><br><p>  :       PTM .  GNOME Terminal Server      "Hello, World!",  read()  PTM .  read()    write()    —  <code>n_tty_read()</code> .      ,  ,          — <em>read_buf</em> —   .  GNOME Terminal Server    X Server,     . </p><br><p>  ,   "Hello, World!"   : </p><br><pre> <code class="plaintext hljs"> -&gt; PTY slave -&gt; PTY master -&gt; GNOME-TERMINAl-SERVER -&gt; X Server -&gt; -&gt; </code> </pre> <br><hr><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  .     : </p><br><ol><li>     </li><li>     </li><li>   TTY  </li><li>    </li><li>    ,         </li></ol><br><p>   ,   !     -  —     ,   ! </p><br><h3 id="istochniki">  Quellen </h3><br><ul><li> Linux man pages </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://unix.stackexchange.com/q/96694/346664</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://unix.stackexchange.com/q/93531/346664</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://unix.stackexchange.com/q/117981/346664</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://askubuntu.com/q/506510</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.linusakesson.net/programming/tty/</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://spin0r.wordpress.com/2012/12/28/terminally-confused-part-seven/</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://habr.com/ru/company/neobit/blog/330764/</a> </li><li>  Advanced Programming in the UNIX Environment, 3rd Edition </li></ul><cut></cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460257/">https://habr.com/ru/post/de460257/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460247/index.html">Rezepte für ELFs</a></li>
<li><a href="../de460249/index.html">Lösung der Aufgabe mit pwnable.kr 07 - Eingabe. Pwntools verstehen</a></li>
<li><a href="../de460251/index.html">Künstliche Dummheit: Ein Bot, der mir nicht geholfen hat</a></li>
<li><a href="../de460253/index.html">10 Gründe, Ihre Fähigkeiten als Sprachassistent zu verbessern</a></li>
<li><a href="../de460255/index.html">Backdoor auf Node.js: warum, warum und wie es funktioniert</a></li>
<li><a href="../de460259/index.html">Was ist UI- und UX-Design? Was ist gemeinsam und anders?</a></li>
<li><a href="../de460261/index.html">Amazon: 25 Jahre E-Commerce-Erfolg</a></li>
<li><a href="../de460263/index.html">Eine wirklich intelligente Suche durchführen: Schritt-für-Schritt-Anleitung</a></li>
<li><a href="../de460265/index.html">Erstellen Sie eine Xcode-Projektvorlage</a></li>
<li><a href="../de460273/index.html">Autorisierung in Apple Pay für die Kleinsten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>