<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõÄüèº üë®üèΩ‚Äçüîß üëï Hallo Welt! Tiefes Eintauchen in Terminals üßë üåÄ ü§¥üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich wurde inspiriert, diesen Artikel durch einen Artikel √ºber die Analyse von Sishny printf zu schreiben. Es wurde jedoch ein Moment verpasst, in welc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hallo Welt! Tiefes Eintauchen in Terminals</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460257/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ha/5f/0v/ha5f0vjiijc9c92bnnt56z7jcpg.jpeg"></a> </p><br><p>  Ich wurde inspiriert, diesen Artikel durch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Artikel √ºber die Analyse von Sishny printf</a> zu schreiben.  Es wurde jedoch ein Moment verpasst, in welche Richtung die Daten gehen, nachdem sie in das Endger√§t eingegeben wurden.  In diesem Artikel m√∂chte ich diesen Fehler beheben und den Datenpfad im Terminal analysieren.  Wir werden auch verstehen, wie sich Terminal von Shell unterscheidet, was Pseudoterminal ist, wie Terminalemulatoren funktionieren und vieles mehr. </p><a name="habracut"></a><br><h2 id="osnovy">  Die Grundlagen </h2><br><p>  Lassen Sie uns zun√§chst verstehen, was Terminal, Shell, Konsole ist, wie sich der Terminal-Emulator vom normalen Terminal unterscheidet und warum er so benannt ist.  Es wurden bereits viele Informationen dar√ºber geschrieben, so dass Sie hier nichts Neues h√∂ren werden.  Fast alle Informationen hier stammen aus dem Internet, ich werde am Ende des Artikels Links bereitstellen.  Wer bereits wei√ü, was all diese Dinge bedeuten, kann diesen Abschnitt sicher √ºberspringen. </p><br><hr><br><h3 id="terminal">  Terminal </h3><br><p>  <strong>Ein Terminal</strong> ist eine Kombination aus einem Display und einer Tastatur, dh einem physischen Ger√§t.  Bevor die Terminals zu dieser speziellen Kombination wurden, waren sie eine Art Ger√§t namens Fernschreiber (Teletyp, Teletypewriter oder kurz TTY), dh eine Kombination aus einem Drucker und einer Tastatur.  In der Regel sind mehrere Terminals an denselben Computer angeschlossen.  Somit war es m√∂glich, f√ºr mehrere Benutzer am selben Computer zu arbeiten, und jeder hatte seine eigene Sitzung, unabh√§ngig von den anderen.  Das Terminal wurde so benannt, weil es sich am Ende des Terminalkabels befand. </p><br><p>  Dies ist <strong>Teletyp</strong> : </p><br><img src="https://habrastorage.org/webt/m3/_3/yt/m3_3ytmmoofzwgpr3dpu78w8m7i.jpeg" alt="Teletype" title="Teletyp" width="430" height="370"><br><br><p>  Und das ist <strong>Terminal</strong> : </p><br><img src="https://habrastorage.org/webt/pz/lj/eu/pzljeumccjvqmrunt-pqolnyx-c.jpeg" alt="Terminal" title="Terminal" width="430" height="370"><br><br><hr><br><h3 id="console">  Konsole </h3><br><p>  <strong>Konsole (Konsole)</strong> - ein Terminal, das direkt mit dem Computer verbunden ist.  Tatsache ist, dass die meisten Terminals implizit verbunden waren, aber mindestens eines direkt mit dem Computer verbunden war.  Die Konsole durfte einen genau definierten Personenkreis verwenden, da Sie den Computer konfigurieren konnten. </p><br><hr><br><h3 id="shell">  Shell </h3><br><p>  Wenn es sich bei den beiden vorherigen Ger√§ten um physische Ger√§te handelt, bezieht sich diese Definition ausschlie√ülich auf Software. </p><br><p>  <strong>Shell</strong> ist ein Befehlszeileninterpreter.  Der Hauptzweck besteht darin, andere Programme auszuf√ºhren.  Es gibt eine gro√üe Anzahl verschiedener Muscheln.  Am gebr√§uchlichsten ist Bash (aus der englischen Bourne Again SHell, die, wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia</a> vorschl√§gt, ein Wortspiel f√ºr "Born again" Shell ist, dh eine "wiederbelebte" Shell).  Andere Beispiele: Dash (eine leichte Shell, verf√ºgbar, wenn Sie die Bin√§rdatei unter / bin / sh ausf√ºhren), Zsh. </p><br><hr><br><p>  Nat√ºrlich konnten sowohl Terminals als auch Konsolen in der Neuzeit ihr Spiegelbild finden.  Daher werden wir weiter Dinge wie <em>Terminal Emulator</em> und <em>Virtual Console betrachten</em> . </p><br><h3 id="terminal-emulator">  Terminalemulator </h3><br><p>  <strong>Terminal Emulator</strong> - ein Emulator des guten alten Terminals.  F√ºr Programme, die nicht direkt mit dem X Window System interagieren k√∂nnen, ist ein Terminalemulator erforderlich - Bash, Vim und andere. </p><br><p>  Lassen Sie uns zun√§chst die Verantwortlichkeiten des Terminals festlegen: </p><br><ol><li>  √úbertragen Sie Benutzereingaben auf einen Computer </li><li>  Lieferung der Computerausgabe an das Display </li></ol><br><p>  Unser Terminal-Emulator macht also genau das Gleiche: Er liefert Benutzereingaben an das laufende Programm und zeigt auch die Ausgabe des Programms auf dem Display an.  In jedem Fall bleibt die Bedeutung erhalten - zwischen dem Benutzer und dem laufenden Programm gibt es eine Art Schicht, die f√ºr die Eingabe / Ausgabe verantwortlich ist.  Beispiele f√ºr Terminal Emulator: gnome-terminal, xterm, konsole. </p><br><p>  <strong>Bitte verwechseln Sie Shell und Terminal Emulator nicht!</strong> <br>  Terminal Emulator ist eine GUI-Anwendung, dh ein Fenster im X Window System.  Shell ist ein Befehlszeileninterpreter, dh nur ein Befehlsausf√ºhrender, der keine grafische Shell hat.  Wenn Sie ganz richtig sprechen, <strong>starten Sie Bash nicht</strong> , <strong>sondern</strong> <strong>f√ºhren den Terminal Emulator aus, der Bash in sich selbst startet</strong> .  Terminal Emulator und Bash sind absolut zwei verschiedene Programme.  Der erste ist allein f√ºr die Eingabe / Ausgabe verantwortlich, der zweite f√ºr die Verarbeitung von Befehlen. </p><br><p>  Weiter im Artikel beziehen sich alle Verweise auf das Terminal auf den Terminalemulator. </p><br><hr><br><h3 id="virtual-console-virtual-terminal">  Virtuelle Konsole (virtuelles Terminal) </h3><br><p>  Dr√ºcken Sie Strg + Alt + FN, wobei N normalerweise Werte von 1 bis 6 hat. Was Sie gerade gesehen haben, hei√üt Virtuelle Konsole (virtuelle Konsole) oder Virtuelles Terminal (virtuelles Terminal).  Erinnerst du dich, was ich fr√ºher √ºber Terminals gesagt habe?  Viele Terminals waren an einen Computer angeschlossen, und jedes Terminal war eine separate Sitzung, unabh√§ngig von den anderen.  Virtual Console wiederholt diese Idee: Es k√∂nnen mehrere unabh√§ngige Sitzungen in Ihrem Computer vorhanden sein (die Computerressourcen werden jedoch offensichtlich immer noch gemeinsam genutzt). </p><br><p>  Sie k√∂nnen diese Entit√§t sowohl als virtuelle Konsole als auch als virtuelles Terminal bezeichnen, da eine Konsole per Definition ein Terminal ist, das direkt mit einem Computer verbunden ist, aber alle virtuellen Terminals gewisserma√üen direkt mit einem Computer verbunden sind. </p><br><hr><br><h3 id="tty-ustroystva">  TTY-Ger√§te </h3><br><p>  Jedem Terminal ist ein eigenes <em>TTY-Ger√§t</em> (Terminal Device) zugeordnet, das die Konsole bereitstellt.  Es ist zwar unwahrscheinlich, dass Sie Teletypen finden, aber die Verringerung der TTY hat bis heute √ºberlebt. </p><br><p>  Ein TTY-Ger√§t besteht aus zwei grundlegenden Komponenten: </p><br><ol><li>  <strong>Ger√§tetreiber</strong>  Er ist verantwortlich f√ºr die √úbermittlung der Tastatureingabe an das Programm und f√ºr die Anzeige der Programmausgabe auf dem Bildschirm. </li><li>  <strong>TTY Line Discipline</strong> (Russisch - Liniendisziplin).  Leitungsdisziplin ist die Treiberzugriffsschnittstelle, die dem TTY-Ger√§t jedoch viel Logik verleiht.  Wir k√∂nnen sagen, dass Leitungsdisziplin-Proxies den Fahrer anrufen.  Welchen Verantwortungsbereich diese Komponente hat, erfahren Sie im Artikel. </li></ol><br><p>  TTY-Ger√§t erstellen: </p><br><p><img src="https://habrastorage.org/webt/zn/zw/dy/znzwdyjadyeidyogqoap8kfvgng.jpeg" title="Sehen Sie ein TTY-Ger√§t"></p><br><p>  Es gibt 3 Arten von TTY-Ger√§ten: </p><br><ol><li>  <em>Konsolenger√§t</em> - Erm√∂glicht den Betrieb der virtuellen Konsole.  Die Ein- und Ausgabe dieses Ger√§ts wird vollst√§ndig vom Kernel gesteuert. </li><li>  <em>PTY-Ger√§t</em> (Pseudo-Terminal) - Bereitstellung des Terminalbetriebs in der Fensterschnittstelle.  Die Ein- und Ausgabe dieses Ger√§ts wird von einem Terminalemulator gesteuert, der im Benutzerbereich arbeitet. </li><li>  <em>Serielles Ger√§t</em> - kommuniziert direkt mit der Hardware.  Es wird normalerweise nicht direkt verwendet, sondern ist die unterste Ebene in der Organisation der Architektur eines Endger√§ts. </li></ol><br><p>  In diesem Artikel werden wir speziell auf den zweiten Typ von TTY-Ger√§ten eingehen - Pseudo-Terminals. </p><br><hr><br><h2 id="tty-line-discipline">  TTY Line Disziplin </h2><br><p>  Wir beginnen, die Disziplin der TTY-Ger√§telinie zu untersuchen. </p><br><p>  Das erste wichtige Merkmal einer Liniendisziplin ist, dass sie f√ºr die Verarbeitung von E / A verantwortlich ist.  Dies umfasst beispielsweise die Verarbeitung von Steuerzeichen (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Steuerzeichen">Steuerzeichen</a> ) und die Formatierung der Ausgabe.  Zum Beispiel geben Sie einen beliebigen Text ein, aber pl√∂tzlich stellen Sie fest, dass Sie sich beim Schreiben von etwas geirrt haben und es l√∂schen m√∂chten - hier kommt die Liniendisziplin ins Spiel. </p><br><p>  Wir werden im Detail analysieren, was genau passiert, wenn wir in Bash arbeiten und im Terminal laufen.  Standardm√§√üig arbeitet ein TTY-Ger√§t im kanonischen Modus mit <em>aktiviertem Echo</em> .  Ein Echo ist eine Anzeige der Zeichen, die Sie auf dem Bildschirm eingegeben haben. </p><br><p> Wenn wir zum Beispiel das Zeichen <code>a</code> eingeben, wird dieses Zeichen an das TTY-Ger√§t gesendet, aber von der Disziplin der TTY-Zeile des Ger√§ts abgefangen.  Sie liest ein Zeichen in ihren internen Puffer ein, sieht, dass der <code>echo</code> aktiviert ist, und zeigt das Zeichen auf dem Bildschirm an.  Derzeit ist noch nichts zum Lesen des Programms verf√ºgbar, an das das Endger√§t angeschlossen ist.  Lassen Sie uns die <code>backspace</code> auf der Tastatur dr√ºcken.  Symbol <code>^?</code>  erneut von der Zeilendisziplin abgefangen, und letztere erkennt, dass der Benutzer das zuletzt eingegebene Zeichen l√∂schen m√∂chte, entfernt dieses Zeichen aus seinem internen Puffer und l√∂scht dieses Zeichen auch vom Bildschirm.  Wenn wir nun die Eingabetaste dr√ºcken, sendet die TTY-Leitungsdisziplin schlie√ülich alles, was zuvor in den internen Puffer der Disziplin geschrieben wurde, einschlie√ülich LF, an den Lesepuffer des Endger√§ts.  Gleichzeitig werden die Zeichen CR und LF auf dem Bildschirm angezeigt, um den Cursor auf eine neue Zeile zu bewegen - dies ist die Formatierung der Ausgabe. </p><br><p>  So funktioniert der kanonische Modus: Er √ºbertr√§gt alle eingegebenen Zeichen erst nach Dr√ºcken der <code>Enter</code> auf das Ger√§t, verarbeitet die Steuerzeichen und formatiert die Ausgabe. </p><br><h3 id="tty-line-editing">  TTY-Zeilenbearbeitung </h3><br><p>  <strong>TTY Line Editing</strong> ist die Komponente, die f√ºr die Verarbeitung von Eingaben in der Zeilendisziplin verantwortlich ist.  Es sollte gesagt werden, dass die <em>Zeilenbearbeitung</em> ein allgemeines Konzept ist und sich auf die Eingabeverarbeitung bezieht.  Zum Beispiel haben Bash und Vim ihre eigene Zeilenbearbeitung. </p><br><p>  Mit dem Programm <strong>stty</strong> k√∂nnen wir die Disziplineinstellungen der Leitung des aktuellen TTY-Ger√§ts <strong>steuern</strong> .  Lass uns ein bisschen experimentieren. </p><br><p>  √ñffnen Sie Bash oder eine andere Shell und geben Sie Folgendes ein: </p><br><pre> <code class="plaintext hljs">stty icanon -echo</code> </pre> <br><p>  Versuchen Sie nun, etwas einzugeben, und Sie werden Ihre Eingabe nicht sehen (keine Sorge, Sie k√∂nnen die Eingabe trotzdem an das Programm √ºbergeben).  Sie haben gerade das Echo deaktiviert, dh die Anzeige der eingegebenen Zeichen auf dem Bildschirm.  Geben Sie nun Folgendes ein: </p><br><pre> <code class="plaintext hljs">stty raw echo</code> </pre> <br><p>  Versuchen Sie etwas zu tippen.  Sie sehen, wie die Schlussfolgerung gebrochen ist.  Aber f√ºr mehr Effekt gehen wir zu Dash - geben Sie <code>/bin/sh</code> .  Versuchen Sie nun, Sonderzeichen einzugeben ( <code>Ctrl</code> + ein beliebiges Zeichen auf der Tastatur) oder dr√ºcken <code>Enter</code> einfach die <code>Enter</code> .  Sie sind ratlos - was sind diese seltsamen Zeichen auf dem Bildschirm?  Tatsache ist, dass wir, nachdem wir die einfachste Shell eingegeben haben, zus√§tzlich zur Linienbearbeitung der Disziplin selbst auch den Linienbearbeitungs-Bash deaktiviert haben und nun mit Macht und Hauptwirkung den Effekt der Einbeziehung des <em>rohen</em> Disziplinierungsmodus der Linie beobachten k√∂nnen.  Dieser Modus verarbeitet Eingaben √ºberhaupt nicht und formatiert keine Ausgaben.  Warum wird der Raw-Modus ben√∂tigt?  Zum Beispiel f√ºr <em>Vim</em> : Es √∂ffnet sich in das gesamte Terminalfenster und verarbeitet die Eingabe selbst, zumindest damit sich spezielle Symbole der Liniendisziplin nicht mit speziellen Symbolen von Vim selbst √ºberschneiden. </p><br><p>  Schauen wir uns zum noch besseren Verst√§ndnis das Anpassen von Steuerzeichen an.  Der <code>stty &lt;control-character&gt; &lt;string&gt;</code> hilft uns dabei. <br>  Geben Sie in Bash ein: </p><br><pre> <code class="bash hljs">stty erase 0</code> </pre> <br><p>  Jetzt wird das <code>erase</code> dem Zeichen <code>0</code> zugewiesen.  Die <code>backspace</code> normalerweise wichtig <code>^?</code>  , aber jetzt wird dieses Sonderzeichen buchst√§blich an den PTS-Lesepuffer gesendet - probieren Sie es selbst aus.  Jetzt k√∂nnen Sie Zeichen mit der Taste <code>0</code> auf der Tastatur l√∂schen, da Sie selbst die Zeilendisziplin gebeten haben, das eingegebene Zeichen als L√∂schsteuerzeichen zu erkennen.  Sie k√∂nnen die Einstellung mit dem Befehl <code>stty erase ^\?</code>  oder einfach das Terminal schlie√üen, weil wir nur das aktuelle tty-Ger√§t betroffen haben. </p><br><p>  Weitere Informationen finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Mann stty">man stty</a> . </p><br><hr><br><h2 id="terminal-emulator-i-pseudoterminal">  Terminal Emulator und Pseudoterminal </h2><br><p>  Jedes Mal, wenn wir ein neues Terminal im X Window System √∂ffnen, erzeugt der GNOME Terminal Server einen neuen Prozess und startet das Standardprogramm darin.  Normalerweise ist dies eine Art Shell (zum Beispiel Bash). </p><br><p>  Die Kommunikation mit dem laufenden Programm erfolgt √ºber das sogenannte <strong>Pseudoterminal</strong> (Pseudo-Terminal, PTY).  Das Pseudo-Terminal selbst existiert im Kernel, empf√§ngt jedoch Eingaben aus dem Benutzerbereich - vom Terminal-Emulator. </p><br><p>  Das Pseudo-Terminal besteht aus den folgenden zwei <em>virtuellen TTY-Ger√§ten</em> : <br>  1) <strong>PTY-Master (PTM)</strong> - der f√ºhrende Teil des Pseudo-Terminals.  Wird vom GNOME-Terminalserver verwendet, um Tastatureingaben an ein im Terminal ausgef√ºhrtes Programm zu √ºbertragen sowie Programmausgaben und Anzeigeausgaben zu lesen.  Der GNOME-Terminalserver kommuniziert wiederum √ºber das X-Protokoll mit dem X Window System. <br>  2) <strong>PTY-Slave (PTS)</strong> - Slave-Teil des Pseudo-Terminals.  Wird von einem Programm verwendet, das im Terminal ausgef√ºhrt wird, um Tastatureingaben zu lesen und Ausgaben auf dem Bildschirm anzuzeigen.  Zumindest das Programm selbst glaubt das (ich werde etwas weiter erkl√§ren, was dies bedeutet). </p><br><p>  Alle im PTS-Ger√§t aufgezeichneten Daten sind der Eingang des PTM-Ger√§ts, dh sie werden auf dem PTM-Ger√§t lesbar.  Und umgekehrt: Alle im PTM-Ger√§t aufgezeichneten Daten sind der Eingang des PTS-Ger√§ts.  Auf diese Weise kommunizieren der GNOME-Terminalserver und das im Terminal ausgef√ºhrte Programm.  Jedes PTM-Ger√§t ist einem eigenen PTS-Ger√§t zugeordnet. </p><br><p>  Der Start eines neuen Terminals sieht ungef√§hr so ‚Äã‚Äãaus: <br>  1) GNOME Terminal Server erstellt Master- und Slave-Ger√§te durch Aufrufen der Funktion open () auf einem speziellen Ger√§t <strong>/ dev / ptmx</strong> .  Der Aufruf open () gibt den Dateideskriptor des erstellten PTM-Ger√§ts zur√ºck - <em>master_fd</em> . <br>  2) GNOME Terminal Server erstellt einen neuen Prozess durch Aufrufen von <code>fork()</code> .  Dieser Prozess wird das neue Terminal sein. <br>  3) Im PTS-Terminal wird das Ger√§t in den Dateideskriptoren 0, 1, 2 (stdin, stdout bzw. stderr) ge√∂ffnet.  Jetzt flie√üen Standard-Terminal-E / A zu diesem Ger√§t. <br>  4) Das gew√ºnschte Programm wird im Terminal durch Aufrufen der Funktion <code>exec()</code> gestartet.  Einige Shell starten normalerweise (zum Beispiel Bash).  Jedes Programm, das anschlie√üend von Bash aus gestartet wird, hat dieselben Dateideskriptoren wie Bash selbst, dh die Programmabl√§ufe werden an das PTS-Ger√§t geleitet. </p><br><p>  Mit dem <code>ls -la /proc/self/fd</code> k√∂nnen Sie selbst sehen, wohin die Standard-Terminal-Ausgangsfl√ºsse geleitet werden: <br><img src="https://habrastorage.org/webt/nr/dx/97/nrdx97wllflvapnt76p3qqki3fw.jpeg"></p><br><p>  Das PTS-Ger√§t befindet sich im Pfad <strong>/ dev / pts / N</strong> , und der Pfad zum PTM-Ger√§t interessiert uns √ºberhaupt nicht.  Tatsache ist, dass der GNOME-Terminalserver bereits √ºber einen Dateideskriptor f√ºr das ge√∂ffnete PTM-Ger√§t verf√ºgt und keinen Pfad dazu ben√∂tigt. Im untergeordneten Prozess m√ºssen wir das PTS-Ger√§t jedoch in Standardausgabestreams <code>open()</code> indem wir die Funktion <code>open()</code> aufrufen, f√ºr die der Pfad zur Datei erforderlich ist. </p><br><p>  Denken Sie daran, ich sagte, dass ein Programm, das ein PTS-Ger√§t verwendet, nur denkt, dass es direkt mit dem Terminal kommuniziert?  Tatsache ist, dass das PTS auch ein <em>Endger√§t</em> (TTY-Ger√§t) ist, aber der Unterschied zwischen dem PTS-Ger√§t und dem tats√§chlichen TTY-Ger√§t besteht darin, dass das PTS-Ger√§t Eingaben nicht von der Tastatur, sondern vom Master-Ger√§t empf√§ngt und die Ausgabe nicht an das Display, sondern an geht Master-Ger√§t.  Deshalb hei√üt das Pseudo-Terminal so - das Pseudo-Terminal ahmt nur (wieder ??) das Terminal nach.  Der Unterschied zwischen dem Terminalemulator und dem Pseudo-Terminal besteht darin, dass der Terminal-Emulator nur ein grafisches Programm ist, mit dem Sie das Terminal direkt in der Fensterschnittstelle ausf√ºhren k√∂nnen. Diese Funktion wird jedoch mithilfe des Pseudo-Terminals implementiert. </p><br><p>  Die Tatsache, dass das <em>PTS-Ger√§t ein TTY-Ger√§t</em> ist <em>,</em> ist sehr wichtig.  Deshalb: </p><br><ol><li>  Das Programm, an das das Endger√§t angeschlossen ist, verf√ºgt √ºber alle Funktionen eines herk√∂mmlichen Terminals.  Zum Beispiel: Echo deaktivieren, kanonische Ansicht deaktivieren / aktivieren. </li><li>  Das Programm kann interaktiv arbeiten und den Benutzer um Eingabe bitten, da es wei√ü, dass ein Endger√§t daran angeschlossen ist (es wird gesagt, dass das Programm √ºber ein Steuerterminal verf√ºgt).  Fragen Sie beispielsweise nach einem Benutzernamen und einem Passwort. </li><li>  Es gibt auch eine TTY-Zeilendisziplin, sodass wir Steuerzeichen verarbeiten k√∂nnen, bevor sie das Programm erreichen, und die Ausgabe des Programms formatieren k√∂nnen. </li></ol><br><p>  Das PTM-Ger√§t ist ebenfalls ein TTY-Ger√§t, spielt jedoch keine Rolle, da es nicht als Steuerterminal verwendet wird.  Dar√ºber hinaus ist die Leitungsdisziplin des PTM-Ger√§ts auf den Rohmodus eingestellt, weshalb beim √úbertragen von Daten vom PTS zum PTM-Ger√§t keine Verarbeitung durchgef√ºhrt wird.  Aufrufe zum <code>read()</code> und <code>write()</code> aus dem Benutzerbereich werden jedoch immer noch zuerst von der Leitungsdisziplin auf beiden Ger√§ten bedient.  Dieser Moment wird eine noch gr√∂√üere Rolle spielen, wie wir sp√§ter sehen werden. </p><br><p>  Der Kommunikationsprozess zwischen dem GNOME-Terminalserver und dem im Terminal ausgef√ºhrten Programm ist wie folgt: </p><br><p><img src="https://habrastorage.org/webt/jz/y0/sg/jzy0sg0zjcceaflg6wyg7d5lkti.jpeg" title="Der Prozess der Kommunikation von GNOME Terminalserver und ein Programm, das im Terminal wird wird"></p><br><p>  Es lohnt sich, die Rolle der Liniendisziplin bei der Kommunikation zwischen beiden Teilen eines Pseudo-Terminals genauer zu untersuchen.  Hier ist die Leitungsdisziplin f√ºr die Verarbeitung von Daten verantwortlich, <em>die vom PTM zum PTS-Ger√§t √ºbertragen werden</em> , sowie f√ºr die Lieferung von Daten von einem Teil des Pseudo-Terminals zu einem anderen.  Wenn wir uns im PTS-Ger√§tetreiber befinden, wenden wir die Leitungsdisziplin des PTM-Ger√§ts an und umgekehrt. </p><br><hr><br><h2 id="virtualnye-ustroystva">  Virtuelle Ger√§te </h2><br><p>  Sie h√§tten wahrscheinlich gedacht, Sie k√∂nnten die Datei entlang des Pfads <em>/ dev / pts / N</em> √∂ffnen und Daten daraus schreiben oder lesen, wie aus einer normalen Textdatei?  Ja, alle Ger√§te auf Unix-√§hnlichen Systemen sind Dateien, dank des Grundprinzips von Unix, das besagt, dass alles eine Datei ist.  Keine speziellen Ger√§tedateien (Englisch - Ger√§tedatei) sind jedoch Textdateien.  Solche Ger√§te werden als <strong>virtuelle Ger√§te</strong> bezeichnet, dh sie befinden sich ausschlie√ülich im Speicher und nicht auf der Festplatte. </p><br><p>  Versuchen Sie nicht, diese Dateien als normale Textdateien zu √∂ffnen.  Sie k√∂nnen diese Ger√§te jedoch √ºber <code>write()</code> und <code>read()</code> -Operationen verwenden, deren Aufruf vom Ger√§tetreiber bedient wird.  Lass es uns versuchen. </p><br><p>  √ñffnen Sie zwei Terminalfenster und geben Sie in jeden Befehl <code>tty</code> ein.  Dieser Befehl zeigt an, welches TTY-Ger√§t das aktuell aktive Terminal bedient.  Geben Sie nun das <code>echo "Hello, World!" &gt; /dev/pts/N</code>  <code>echo "Hello, World!" &gt; /dev/pts/N</code> im ersten Terminalfenster, wobei N der PTS-Index des zweiten Fensterger√§ts ist, wechseln Sie zum zweiten Fenster und Sie sehen Ihre Eingabe aus dem ersten Fenster.  Jetzt haben Sie die Daten auf das PTS-Ger√§t des zweiten Fensters geschrieben, <em>als ob sie von einem Programm ausgef√ºhrt w√ºrden, das in diesem Terminal ausgef√ºhrt wird</em> . </p><br><p><img src="https://habrastorage.org/webt/nj/3s/rp/nj3srpuzyahyvukzicfr0b5wnja.png"></p><br><hr><br><h2 id="ustroystvo-psevdoterminala">  Pseudo-Endger√§t </h2><br><p>  Wir n√§hern uns immer mehr dem letzten Teil des Artikels, aber vorher werfen wir einen Blick unter die Haube von Linux - betrachten Sie das Ger√§t des Pseudo-Terminals auf Kernel-Ebene.  Es wird viel Code geben, aber ich werde versuchen, jeden gegebenen Codeblock so detailliert wie m√∂glich zu erkl√§ren, unwichtige Details zu reduzieren und nacheinander vorzugehen. </p><br><p>  Bevor Sie beginnen, stellen wir Ihnen den sogenannten "Komponentenkorb" vor.  W√§hrend wir uns entlang des Kerns bewegen, werden wir ihm immer mehr Komponenten hinzuf√ºgen und eine Verbindung zwischen ihnen finden.  Ich hoffe, dies hilft Ihnen dabei, das Pseudo-Endger√§t besser zu verstehen.  Fangen wir an. </p><br><p>  Beim Start von Linux werden die erforderlichen Ger√§tetreiber geladen.  Unser Pseudo-Terminal hat auch einen solchen Treiber.  Die Registrierung beginnt mit einem Aufruf dieser Funktion: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __init pty_init(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { legacy_pty_init(); unix98_pty_init(); <span class="hljs-comment"><span class="hljs-comment">// &lt;- ,    return 0; } device_initcall(pty_init); // ,      </span></span></code> </pre> <br><p>  F√ºr alle modernen Systeme wird die Funktion <code>unix98_pty_init()</code> aufgerufen: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __init unix98_pty_init(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { ptm_driver = tty_alloc_driver(NR_UNIX98_PTY_MAX, TTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV | TTY_DRIVER_DEVPTS_MEM | TTY_DRIVER_DYNAMIC_ALLOC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(ptm_driver)) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't allocate Unix98 ptm driver"</span></span>); pts_driver = tty_alloc_driver(NR_UNIX98_PTY_MAX, TTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV | TTY_DRIVER_DEVPTS_MEM | TTY_DRIVER_DYNAMIC_ALLOC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(pts_driver)) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't allocate Unix98 pts driver"</span></span>); ptm_driver-&gt;driver_name = <span class="hljs-string"><span class="hljs-string">"pty_master"</span></span>; ptm_driver-&gt;name = <span class="hljs-string"><span class="hljs-string">"ptm"</span></span>; ptm_driver-&gt;major = UNIX98_PTY_MASTER_MAJOR; ptm_driver-&gt;minor_start = <span class="hljs-number"><span class="hljs-number">0</span></span>; ptm_driver-&gt;type = TTY_DRIVER_TYPE_PTY; ptm_driver-&gt;subtype = PTY_TYPE_MASTER; ptm_driver-&gt;init_termios = tty_std_termios; ptm_driver-&gt;init_termios.c_iflag = <span class="hljs-number"><span class="hljs-number">0</span></span>; ptm_driver-&gt;init_termios.c_oflag = <span class="hljs-number"><span class="hljs-number">0</span></span>; ptm_driver-&gt;init_termios.c_cflag = B38400 | CS8 | CREAD; ptm_driver-&gt;init_termios.c_lflag = <span class="hljs-number"><span class="hljs-number">0</span></span>; ptm_driver-&gt;init_termios.c_ispeed = <span class="hljs-number"><span class="hljs-number">38400</span></span>; ptm_driver-&gt;init_termios.c_ospeed = <span class="hljs-number"><span class="hljs-number">38400</span></span>; ptm_driver-&gt;other = pts_driver; tty_set_operations(ptm_driver, &amp;ptm_unix98_ops); pts_driver-&gt;driver_name = <span class="hljs-string"><span class="hljs-string">"pty_slave"</span></span>; pts_driver-&gt;name = <span class="hljs-string"><span class="hljs-string">"pts"</span></span>; pts_driver-&gt;major = UNIX98_PTY_SLAVE_MAJOR; pts_driver-&gt;minor_start = <span class="hljs-number"><span class="hljs-number">0</span></span>; pts_driver-&gt;type = TTY_DRIVER_TYPE_PTY; pts_driver-&gt;subtype = PTY_TYPE_SLAVE; pts_driver-&gt;init_termios = tty_std_termios; pts_driver-&gt;init_termios.c_cflag = B38400 | CS8 | CREAD; pts_driver-&gt;init_termios.c_ispeed = <span class="hljs-number"><span class="hljs-number">38400</span></span>; pts_driver-&gt;init_termios.c_ospeed = <span class="hljs-number"><span class="hljs-number">38400</span></span>; pts_driver-&gt;other = ptm_driver; tty_set_operations(pts_driver, &amp;pty_unix98_ops); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tty_register_driver(ptm_driver)) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't register Unix98 ptm driver"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tty_register_driver(pts_driver)) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't register Unix98 pts driver"</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* Now create the /dev/ptmx special device */</span></span> tty_default_fops(&amp;ptmx_fops); ptmx_fops.open = ptmx_open; cdev_init(&amp;ptmx_cdev, &amp;ptmx_fops); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cdev_add(&amp;ptmx_cdev, <span class="hljs-built_in"><span class="hljs-built_in">MKDEV</span></span>(TTYAUX_MAJOR, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>) || register_chrdev_region(<span class="hljs-built_in"><span class="hljs-built_in">MKDEV</span></span>(TTYAUX_MAJOR, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"/dev/ptmx"</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) panic(<span class="hljs-string"><span class="hljs-string">"Couldn't register /dev/ptmx driver"</span></span>); device_create(tty_class, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">MKDEV</span></span>(TTYAUX_MAJOR, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">"ptmx"</span></span>);</code> </pre> <br><p>  Hier interessieren uns 3 Dinge: </p><br><ol><li>  <code>tty_set_operatons</code> f√ºr den pty-Mastertreiber und die pty-Slave-Ger√§te auf. </li><li>  Die Funktion <code>ptmx_open</code> , die beim √ñffnen des Spezialger√§ts <em>/ dev / ptmx</em> f√ºr die Erstellung beider Teile des Pseudo-Terminals <em>verantwortlich ist</em> .  Wichtig: / dev / ptmx ist kein PTM-Ger√§t, sondern nur eine Schnittstelle zum Erstellen eines neuen Pseudo-Terminals. </li><li>  Registrieren Sie PTM- und PTS-Ger√§tetreiber. </li></ol><br><p>  Lass uns in der richtigen Reihenfolge gehen: </p><br><h4 id="1-tty_set_operations">  1. tty_set_operations </h4><br><p>  Die Funktion <strong>tty_set_operations () erstellt</strong> lediglich eine Funktionstabelle f√ºr den aktuellen Treiber: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> tty_set_operations(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_operations *op) { driver-&gt;ops = op; };</code> </pre> <br><p>  Die Struktur <strong>tty_operations</strong> ist eine Funktionstabelle, mit der auf die TTY-Treiberfunktionen des Ger√§ts <strong>zugegriffen</strong> wird. </p><br><p>  Ich werde das Wichtigste in den Strukturen <code>pty_unix98_ops</code> und <code>ptm_unix98_ops</code> , die die Funktionstabelle f√ºr die entsprechenden Teile des Pseudo-Terminals sind: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_operations ptm_unix98_ops = { .install = pty_unix98_install, .remove = pty_unix98_remove, .open = pty_open, .close = pty_close, .write = pty_write, <span class="hljs-comment"><span class="hljs-comment">// ... }; static const struct tty_operations pty_unix98_ops = { .install = pty_unix98_install, .remove = pty_unix98_remove, .open = pty_open, .close = pty_close, .write = pty_write, // ... };</span></span></code> </pre> <br><p>  Hier k√∂nnen Sie die Funktion pty_write beobachten, <code>pty_write</code> bereits aus dem Artikel √ºber Sishny printf bekannt ist - wir werden etwas sp√§ter darauf zur√ºckkommen. </p><br><p>  F√ºgen wir diese Struktur unserem Komponentenkorb hinzu: <br><img src="https://habrastorage.org/webt/o8/e-/kc/o8e-kcpqestn7f481gcx38qmzuo.jpeg"></p><br><p>  Wie Sie sehen k√∂nnen, unterscheiden sich die Hauptmethoden beider Treiber √ºberhaupt nicht.  <code>pty_read()</code> √ºbrigens, dass es keine Funktion f√ºr die Operation read () gibt - es gibt nichts <code>pty_read()</code> wie <code>pty_read()</code> .  Tatsache ist, dass das Lesen ausschlie√ülich durch Zeilendisziplin bedient wird.  So lernen wir das zweite wichtige Merkmal der Leitungsdisziplin kennen - das Lesen von Daten von einem TTY-Ger√§t. </p><br><hr><br><h4 id="2-ptmx_open">  2. ptmx_open </h4><br><p>  <strong>Fahren</strong> wir nun mit <strong>ptmx_open () fort</strong> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ptmx_open(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> inode *inode, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file *filp) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty; <span class="hljs-comment"><span class="hljs-comment">//    -   ! fsi = devpts_acquire(filp); //     devpts index = devpts_new_index(fsi); //       /dev/pts // ... tty = tty_init_dev(ptm_driver, index); // ... devpts_pty_new(fsi, index, tty-&gt;link); //     /dev/pts retval = ptm_driver-&gt;ops-&gt;open(tty, filp); //  PTM ,   }</span></span></code> </pre> <br><p>  Wir interessieren uns f√ºr die Funktion <code>tty_init_dev()</code> , wobei das erste Argument der PTM-Ger√§tetreiber und das zweite der Ger√§teindex ist.  Hier verlassen wir die Verantwortungszone des PTY-Treibers und gehen zu der Datei, die nur f√ºr die allgemeinen TTY-Ger√§te verantwortlich ist und nichts √ºber unser Pseudo-Terminal wei√ü. </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty_init_dev(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty; tty = alloc_tty_struct(driver, idx); retval = tty_driver_install_tty(driver, tty); <span class="hljs-comment"><span class="hljs-comment">/* * Structures all installed ... call the ldisc open routines. */</span></span> retval = tty_ldisc_setup(tty, tty-&gt;link); <span class="hljs-comment"><span class="hljs-comment">//  ,       return tty; }</span></span></code> </pre> <br><p>  Zuerst <code>alloc_tty_struct()</code> wir <code>alloc_tty_struct()</code> Funktion <code>alloc_tty_struct()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *alloc_tty_struct(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty; tty = kzalloc(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*tty), GFP_KERNEL); <span class="hljs-comment"><span class="hljs-comment">//  tty_struct tty_ldisc_init(tty) //      tty_struct tty-&gt;driver = driver; //       tty_struct tty-&gt;ops = driver-&gt;ops; //        tty_struct.     tty-&gt;index = idx; //   tty  return tty; }</span></span></code> </pre> <br><p>  Das einzige, was uns hier interessiert, ist die Funktion <code>tty_ldisc_init()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tty_ldisc_init(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc *ld = tty_ldisc_get(tty, N_TTY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(ld)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PTR_ERR(ld); tty-&gt;ldisc = ld; <span class="hljs-comment"><span class="hljs-comment">//        tty_struct return 0; }</span></span></code> </pre> <br><p>  Was <code>tty_ldisc_get()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc *tty_ldisc_get(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> disc) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc *ld; <span class="hljs-comment"><span class="hljs-comment">//    struct tty_ldisc_ops *ldops; //     ldops = get_ldops(disc); //      .   ,       .   - N_TTY ld = kmalloc(sizeof(struct tty_ldisc), GFP_KERNEL | __GFP_NOFAIL); ld-&gt;ops = ldops; //       ld-&gt;tty = tty; //    tty_struct   .          return ld; }</span></span></code> </pre> <br><p>  Daher haben wir den Aufruf der Funktion <code>alloc_tty_struct()</code> , mit der die Struktur <em>tty_struct</em> zusammen mit der Liniendisziplin - der Struktur <em>tty_ldisc</em> - <em>erstellt</em> wird.  Beide Strukturen sind miteinander verbunden.  Schauen wir uns diese Strukturen genauer an. </p><br><ul><li>  <strong>tty_struct</strong> ist eine Struktur f√ºr den Zugriff auf den TTY-Ger√§tetreiber und einige andere Felder.  Es sieht so aus: </li></ul><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver; <span class="hljs-comment"><span class="hljs-comment">//  TTY  const struct tty_operations *ops; //  .    ,   driver-&gt;ops,       int index; //   struct tty_ldisc *ldisc; //     struct tty_struct *link; //     PTY // ... }</span></span></code> </pre> <br><ul><li>  <strong>tty_ldisc</strong> ist die Struktur f√ºr die Disziplin der TTY-Linie des Ger√§ts.  Es besteht nur aus zwei Feldern und sieht wie folgt aus: </li></ul><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc_ops *ops; <span class="hljs-comment"><span class="hljs-comment">//    struct tty_struct *tty; //   tty_struct  .       };</span></span></code> </pre> <br><p>  Es scheint nichts kompliziertes zu sein?  F√ºgen wir alle bis zu diesem Punkt ber√ºcksichtigten Strukturen unserem Warenkorb hinzu und verkn√ºpfen sie auf dieselbe Weise, wie sie im Code verbunden sind: <br><img src="https://habrastorage.org/webt/1d/bt/n4/1dbtn4m_6c6i4n7oaohoguci2m0.jpeg" alt="Erstellen Sie tty_struct" title="Sehen Sie tty_struct"></p><br><p>  Wir haben tty_struct jedoch nur f√ºr das PTM-Ger√§t erstellt.  Was ist mit dem PTS-Ger√§t?  Dazu kehren wir zur Funktion <code>tty_init_dev()</code> und erinnern uns, dass wir dann die Funktion <code>tty_driver_install_tty()</code> aufrufen <code>tty_driver_install_tty()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/** * This method is responsible * for ensuring any need additional structures are allocated and configured. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tty_driver_install_tty(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> driver-&gt;ops-&gt;install ? driver-&gt;ops-&gt;install(driver, tty) : tty_standard_install(driver, tty); }</code> </pre> <br><p>  Der Kommentar sagt uns, dass diese Methode f√ºr die Erstellung verschiedener zus√§tzlicher Strukturen verantwortlich ist.  PTS-Ger√§t und wird unsere zus√§tzliche Struktur sein.  Ich gebe zu, es war √§u√üerst √ºberraschend f√ºr mich, denn es ist verdammt noch mal das ganze Ger√§t und nicht nur eine Art zus√§tzliche Struktur!  Aber wir alle verstehen, dass alle Ger√§te nur eine Art Struktur sind, also fahren Sie fort.  Ok, was ist <em>Treiber-&gt; Ops-&gt; hier installieren</em> ?  Schauen Sie sich dazu noch einmal die Funktionstabelle f√ºr den PTM-Treiber an: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_operations ptm_unix98_ops = { .install = pty_unix98_install, <span class="hljs-comment"><span class="hljs-comment">// ...</span></span></code> </pre> <br><p>  Und wir verstehen, dass wir an der Funktion <code>pty_unix98_install()</code> interessiert sind: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pty_unix98_install(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pty_common_install(driver, tty, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><p>  Welches ruft die Funktion <code>pty_common_install()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pty_common_install(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_driver *driver, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> legacy) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *o_tty; <span class="hljs-comment"><span class="hljs-comment">// tty_struct    PTY -    PTS  //    ,       install.   ,   PTM     tty_struct,        if (driver-&gt;subtype != PTY_TYPE_MASTER) return -EIO; o_tty = alloc_tty_struct(driver-&gt;other, idx); tty-&gt;link = o_tty; o_tty-&gt;link = tty; }</span></span></code> </pre> <br><p>  ,   PTS       <em>tty_struct</em>   ,       PTS .           .  tty_struct  PTS    . </p><br><hr><br><h4 id="registraciya-drayvera">   </h4><br><p>        ,           TTY  (   -         ?). <br>  ‚Äî  ,       PTM,   PTS : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file_operations tty_fops = { .llseek = no_llseek, .read = tty_read, .write = tty_write, .poll = tty_poll, .unlocked_ioctl = tty_ioctl, .compat_ioctl = tty_compat_ioctl, .open = tty_open, .release = tty_release, .fasync = tty_fasync, .show_fdinfo = tty_show_fdinfo, };</code> </pre> <br><p>         ,                  TTY . </p><br><hr><br><p>  Fertig.      ,       <em>/dev/ptmx</em> .  ,   PTS ,      ,   PTM ,      : </p><br><p><img src="https://habrastorage.org/webt/5w/aw/rg/5wawrgbqqw1_llmi1r8g2kbwrzc.jpeg" title="PTY erstellen"></p><br><hr><br><h2 id="hello-world">  Hallo Welt! </h2><br><p>        .          "Hello, World!",        . </p><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><span class="hljs-meta"> void main() { printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Hello, World!\n"</span></span></span><span class="hljs-meta">); }</span></span></code> </pre> <br><p> ,   "Hello, World!"    .   ,    ,  ,       .    ,    .  stdout  <em>/dev/null</em> ‚Äî       .          ,       Linux. </p><br><p>      Unix        <em>write()</em> , <em>read()</em> , <em>close()</em>  ,    write()  /dev/pts/0         <code>__vfs_write()</code> : </p><br><pre> <code class="objectivec hljs">ssize_t __vfs_write(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file *file, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __user *buf, size_t count, loff_t *pos) { ssize_t ret; <span class="hljs-comment"><span class="hljs-comment">//... ret = file-&gt;f_op-&gt;write(file, buf, count, pos); //... return ret; }</span></span></code> </pre> <br><p>     write()      .   ,            : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file_operations tty_fops = { <span class="hljs-comment"><span class="hljs-comment">// ... .write = tty_write, // ...</span></span></code> </pre> <br><p>  <code>tty_write()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ssize_t tty_write(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file *file, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __user *buf, size_t count, loff_t *ppos) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty = file_tty(file); <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc *ld; ssize_t ret; ld = tty_ldisc_ref_wait(tty); ret = do_tty_write(ld-&gt;ops-&gt;write, tty, file, buf, count); tty_ldisc_deref(ld); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre> <br><p>     <em>tty_struct</em>    TTY ,           write()  .       : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_ldisc_ops n_tty_ops = { .write = n_tty_write, <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>    <code>n_tty_write()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/** * n_tty_write - write function for tty * @tty: tty device * @file: file object * @buf: userspace buffer pointer * @nr: size of I/O */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ssize_t n_tty_write(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file *file, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buf, size_t nr) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *b = buf; <span class="hljs-comment"><span class="hljs-comment">// b - ,       "Hello, World!".          int c; //    //     PTS ,  write()    0,  ,     while (nr &gt; 0) { c = tty-&gt;ops-&gt;write(tty, b, nr); //  write()       TTY  if (!c) break; b += c; //     nr -= c; //      :  -  -  -  } }</span></span></code> </pre> <br><p> ,  "Hello, World!"    write()   PTS .       : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_operations pty_unix98_ops = { .write = pty_write, <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  <code>pty_write()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pty_write(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buf, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *to = tty-&gt;link; <span class="hljs-comment"><span class="hljs-comment">//      PTY.    -  PTM  if (c &gt; 0) { //    PTM  c = tty_insert_flip_string(to-&gt;port, buf, c); //     ,       if (c) { tty_flip_buffer_push(to-&gt;port); tty_wakeup(tty); } } return c; }</span></span></code> </pre> <br><p>          : </p><br><pre> <code class="objectivec hljs"> __vfs_write() -&gt; <span class="hljs-comment"><span class="hljs-comment">// 1- :   tty_write() -&gt; do_tty_write() -&gt; n_tty_write() -&gt; // 2- :   pty_write() // 3- : </span></span></code> </pre> <br><p>     . ,       PTM . ,    . </p><br><p>  ,          <em>flip buffer</em> . <strong>Flip buffer</strong> ‚Äî   ,    .  tty driver   ,      .   ,              .      ,        ,       .     ,      ,            .  -        flip buffer ‚Äî       (,    -  ,         flip). </p><br><p>          ,       .  <code>tty_insert_flip_string()</code>         <code>tty_insert_flip_string_fixed_flag()</code> ,           PTM : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tty_insert_flip_string_fixed_flag(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port *port, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *chars, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> flag, size_t size) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> copied = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> goal = min_t(size_t, size - copied, TTY_BUFFER_PAGE); <span class="hljs-comment"><span class="hljs-comment">//      int space = __tty_buffer_request_room(port, goal, flags); //     struct tty_buffer *tb = port-&gt;buf.tail; //       if (unlikely(space == 0)) break; memcpy(char_buf_ptr(tb, tb-&gt;used), chars, space); //      tb-&gt;used += space; copied += space; chars += space; /* There is a small chance that we need to split the data over several buffers. If this is the case we must loop */ } while (unlikely(size &gt; copied)); return copied; }</span></span></code> </pre> <br><p>   , flip buffer        ,       ,         .        ,   ‚Äî        PTM ,             . </p><br><p> ,   "Hello, World!"   PTM .    GNOME Terminal Server    <em>poll()</em> (  I/O)        master .  ,         ?  Egal wie.      ,     ,      ‚Äî        . </p><br><p>            <code>tty_flip_buffer_push()</code> (   pty_write): </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/** * tty_flip_buffer_push - terminal * @port: tty port to push * * Queue a push of the terminal flip buffers to the line discipline. * Can be called from IRQ/atomic context. * * In the event of the queue being busy for flipping the work will be * held off and retried later. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> tty_flip_buffer_push(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port *port) { tty_schedule_flip(port); }</code> </pre> <br><p>  <code>tty_schedule_flip()</code> ,   ,        : </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/** * tty_schedule_flip - push characters to ldisc * @port: tty port to push from * * Takes any pending buffers and transfers their ownership to the * ldisc side of the queue. It then schedules those characters for * processing by the line discipline. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> tty_schedule_flip(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port *port) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_bufhead *buf = &amp;port-&gt;buf; <span class="hljs-comment"><span class="hljs-comment">/* paired w/ acquire in flush_to_ldisc(); ensures * flush_to_ldisc() sees buffer data. */</span></span> smp_store_release(&amp;buf-&gt;tail-&gt;commit, buf-&gt;tail-&gt;used); queue_work(system_unbound_wq, &amp;buf-&gt;work); }</code> </pre> <br><p>   ,     <em>work</em> (,   -       )       ,      ‚Äî    ,    <code>flush_to_ldisc()</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> flush_to_ldisc(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> work_struct *work) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port *port = container_of(work, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_port, buf.work); <span class="hljs-comment"><span class="hljs-comment">//   tty_port PTM . tty_port -       TTY  struct tty_bufhead *buf = &amp;port-&gt;buf; struct tty_buffer *head = buf-&gt;head; // ... receive_buf(port, head); // ... }</span></span></code> </pre> <br><p>  <code>receive_buf()</code>          <code>__receive_buf()</code> ,      : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __receive_buf(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> tty_struct *tty, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *cp, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *fp, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> n_tty_data *ldata = tty-&gt;disc_data; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> preops = I_ISTRIP(tty) || (I_IUCLC(tty) &amp;&amp; L_IEXTEN(tty)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ldata-&gt;real_raw) n_tty_receive_buf_real_raw(tty, cp, fp, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ldata-&gt;raw || (L_EXTPROC(tty) &amp;&amp; !preops)) n_tty_receive_buf_raw(tty, cp, fp, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tty-&gt;closing &amp;&amp; !L_EXTPROC(tty)) n_tty_receive_buf_closing(tty, cp, fp, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ldata-&gt;lnext) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> flag = TTY_NORMAL; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fp) flag = *fp++; n_tty_receive_char_lnext(tty, *cp++, flag); count--; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!preops &amp;&amp; !I_PARMRK(tty)) n_tty_receive_buf_fast(tty, cp, fp, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> n_tty_receive_buf_standard(tty, cp, fp, count); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (read_cnt(ldata)) { kill_fasync(&amp;tty-&gt;fasync, SIGIO, POLL_IN); wake_up_interruptible_poll(&amp;tty-&gt;read_wait, EPOLLIN); } }</code> </pre> <br><p>  ,   <em>n_tty_receive_buf</em> ( ,    _raw)           <strong>read_buf</strong> ,         TTY .      PTM    raw ,           read_buf. ,        PTM  PTS ,     . </p><br><p>       ,   : </p><br><pre> <code class="objectivec hljs"> ... pty_write() -&gt; <span class="hljs-comment"><span class="hljs-comment">// 3- :  PTS  tty_insert_flip_string + tty_flip_buffer_push() -&gt; tty_schedule_flip() -&gt; --- //    PTM  flush_to_ldisc() -&gt; // 2- :   PTM  receive_buf() -&gt; n_tty_receive_buf -&gt; n_tty_receive_buf_common -&gt; __receive_buf()</span></span></code> </pre> <br><p> ,   PTM        ‚Äî         PTS . </p><br><p>  :       PTM .  GNOME Terminal Server      "Hello, World!",  read()  PTM .  read()    write()    ‚Äî  <code>n_tty_read()</code> .      ,  ,          ‚Äî <em>read_buf</em> ‚Äî   .  GNOME Terminal Server    X Server,     . </p><br><p>  ,   "Hello, World!"   : </p><br><pre> <code class="plaintext hljs"> -&gt; PTY slave -&gt; PTY master -&gt; GNOME-TERMINAl-SERVER -&gt; X Server -&gt; -&gt; </code> </pre> <br><hr><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  .     : </p><br><ol><li>     </li><li>     </li><li>   TTY  </li><li>    </li><li>    ,         </li></ol><br><p>   ,   !     -  ‚Äî     ,   ! </p><br><h3 id="istochniki">  Quellen </h3><br><ul><li> Linux man pages </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://unix.stackexchange.com/q/96694/346664</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://unix.stackexchange.com/q/93531/346664</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://unix.stackexchange.com/q/117981/346664</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://askubuntu.com/q/506510</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.linusakesson.net/programming/tty/</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://spin0r.wordpress.com/2012/12/28/terminally-confused-part-seven/</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://habr.com/ru/company/neobit/blog/330764/</a> </li><li>  Advanced Programming in the UNIX Environment, 3rd Edition </li></ul><cut></cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460257/">https://habr.com/ru/post/de460257/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460247/index.html">Rezepte f√ºr ELFs</a></li>
<li><a href="../de460249/index.html">L√∂sung der Aufgabe mit pwnable.kr 07 - Eingabe. Pwntools verstehen</a></li>
<li><a href="../de460251/index.html">K√ºnstliche Dummheit: Ein Bot, der mir nicht geholfen hat</a></li>
<li><a href="../de460253/index.html">10 Gr√ºnde, Ihre F√§higkeiten als Sprachassistent zu verbessern</a></li>
<li><a href="../de460255/index.html">Backdoor auf Node.js: warum, warum und wie es funktioniert</a></li>
<li><a href="../de460259/index.html">Was ist UI- und UX-Design? Was ist gemeinsam und anders?</a></li>
<li><a href="../de460261/index.html">Amazon: 25 Jahre E-Commerce-Erfolg</a></li>
<li><a href="../de460263/index.html">Eine wirklich intelligente Suche durchf√ºhren: Schritt-f√ºr-Schritt-Anleitung</a></li>
<li><a href="../de460265/index.html">Erstellen Sie eine Xcode-Projektvorlage</a></li>
<li><a href="../de460273/index.html">Autorisierung in Apple Pay f√ºr die Kleinsten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>