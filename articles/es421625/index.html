<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüéì üë™ ü§¥üèæ Python as√≠ncrono: varias formas de competencia üìá üëêüèæ üòù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Con el advenimiento de Python 3, hay bastante ruido sobre el "asincronismo" y la "concurrencia", podemos suponer que Python introdujo recientemente es...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python as√≠ncrono: varias formas de competencia</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421625/">  Con el advenimiento de Python 3, hay bastante ruido sobre el "asincronismo" y la "concurrencia", podemos suponer que Python introdujo recientemente estas caracter√≠sticas / conceptos.  Pero esto no es as√≠.  Hemos usado estas operaciones muchas veces.  Adem√°s, los principiantes podr√≠an pensar que asyncio es la √∫nica o la mejor manera de recrear y usar operaciones asincr√≥nicas / paralelas.  En este art√≠culo, veremos varias formas de lograr paralelismo, sus ventajas y desventajas. <br><a name="habracut"></a><br><h4>  Definici√≥n de t√©rminos: </h4><br>  Antes de profundizar en los aspectos t√©cnicos, es importante tener una comprensi√≥n b√°sica de los t√©rminos que se usan a menudo en este contexto. <br><br>  <b>Sincr√≥nico y asincr√≥nico:</b> <br><br>  En operaciones <b>sincr√≥nicas</b> , las tareas se realizan una tras otra.  En <b>las</b> tareas <b>asincr√≥nicas</b> se pueden iniciar y completar independientemente uno del otro.  Una tarea asincr√≥nica puede comenzar y continuar ejecut√°ndose mientras la ejecuci√≥n se mueve a una nueva tarea.  Las tareas asincr√≥nicas <b>no</b> bloquean (no fuercen a esperar a que se complete la tarea) operaciones y generalmente se realizan en segundo plano. <br><br>  Por ejemplo, debe comunicarse con una agencia de viajes para planificar sus pr√≥ximas vacaciones.  Debe enviar una carta a su supervisor antes de volar.  En modo s√≠ncrono, primero debe llamar a la agencia de viajes y, si se le pide que espere, esperar√° hasta que le respondan.  Entonces comenzar√° a escribir una carta al l√≠der.  Por lo tanto, completa las tareas una tras otra.  <i>[ejecuci√≥n s√≠ncrona, aprox.</i>  <i>traductor]</i> Pero, si eres inteligente, te han pedido que esperes <i>[cuelga el tel√©fono, aprox.</i>  <i>traductor]</i> comenzar√° a escribir un correo electr√≥nico y cuando vuelva a hablar pausar√° la escritura, hablar√° y luego agregar√° la carta.  Tambi√©n puede pedirle a un amigo que llame a la agencia y que escriba una carta usted mismo.  Esto es asincron√≠a, las tareas no se bloquean entre s√≠. <br><br>  <b>Competitividad y concurrencia:</b> <br><br>  La competitividad implica que dos tareas se realizan <u>conjuntamente</u> .  En nuestro ejemplo anterior, cuando consideramos el ejemplo asincr√≥nico, progresamos gradualmente al escribir una carta y luego en una conversaci√≥n con un recorrido.  agencia.  Esto es <b>competitividad</b> . <br><br>  Cuando pedimos llamar a un amigo y escribimos una carta nosotros mismos, las tareas se llevaron a cabo <b>en paralelo</b> . <br><br>  La concurrencia es esencialmente una forma de competencia.  Pero la concurrencia depende del hardware.  Por ejemplo, si la CPU tiene solo un n√∫cleo, entonces dos tareas no se pueden ejecutar en paralelo.  Simplemente comparten el tiempo del procesador entre ellos.  Entonces esto es competencia, pero no concurrencia.  Pero cuando tenemos varios n√∫cleos <i>[como amigo en el ejemplo anterior, que es el segundo n√∫cleo, aprox.</i>  <i>traductor]</i> podemos realizar varias operaciones (dependiendo del n√∫mero de n√∫cleos) al mismo tiempo. <br><br>  Para resumir: <br><br><ul><li>  Sincronizaci√≥n: bloquea operaciones (bloqueo) </li><li>  Asincron√≠a: no bloquea operaciones (sin bloqueo) </li><li>  Competitividad: progreso conjunto (conjunto) </li><li>  Concurrencia: progreso paralelo (paralelo) </li></ul><br>  La concurrencia implica competencia.  Pero la competencia no siempre implica concurrencia. <br><br><h4>  Hilos y procesos </h4><br>  Python ha estado soportando hilos por mucho tiempo.  Los hilos le permiten realizar operaciones competitivamente.  Pero hay un problema con <b>Global Interpreter Lock (GIL)</b> debido a que los hilos no pueden proporcionar una verdadera concurrencia.  Y, sin embargo, con el advenimiento del <b>multiprocesamiento,</b> puede usar m√∫ltiples n√∫cleos con Python. <br><br>  <b>Hilos</b> <br><br>  Considere un peque√±o ejemplo.  En el siguiente c√≥digo, la funci√≥n de <i>trabajo</i> se ejecutar√° en varios subprocesos de forma asincr√≥nica y simult√°nea. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> threading <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">worker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(number)</span></span></span><span class="hljs-function">:</span></span> sleep = random.randrange(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) time.sleep(sleep) print(<span class="hljs-string"><span class="hljs-string">"I am Worker {}, I slept for {} seconds"</span></span>.format(number, sleep)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>): t = threading.Thread(target=worker, args=(i,)) t.start() print(<span class="hljs-string"><span class="hljs-string">"All Threads are queued, let's see when they finish!"</span></span>)</code> </pre> <br>  Y aqu√≠ hay un ejemplo de salida: <br><br><pre> <code class="python hljs">$ python thread_test.py All Threads are queued, let<span class="hljs-string"><span class="hljs-string">'s see when they finish! I am Worker 1, I slept for 1 seconds I am Worker 3, I slept for 4 seconds I am Worker 4, I slept for 5 seconds I am Worker 2, I slept for 7 seconds I am Worker 0, I slept for 9 seconds</span></span></code> </pre><br>  Por lo tanto, comenzamos 5 hilos para la colaboraci√≥n y despu√©s de que comiencen (es decir, despu√©s de ejecutar la funci√≥n de trabajo), la operaci√≥n <b>no espera</b> a que se completen los hilos antes de pasar a la siguiente declaraci√≥n de impresi√≥n.  Esta es una operaci√≥n asincr√≥nica. <br><br>  En nuestro ejemplo, pasamos la funci√≥n al constructor Thread.  Si quisi√©ramos, podr√≠amos implementar una subclase con un m√©todo (estilo OOP). <br><br>  <u>Lectura adicional:</u> <br><br>  Para obtener m√°s informaci√≥n sobre las transmisiones, utilice el siguiente enlace: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pymotw.com/3/threading/index.html</a> </li></ul><br>  <b>Bloqueo global de int√©rpretes (GIL)</b> <br><br>  GIL se introdujo para facilitar el manejo de la memoria de CPython y proporcionar la mejor integraci√≥n con C (por ejemplo, con extensiones).  GIL es un mecanismo de bloqueo cuando el int√©rprete de Python solo ejecuta un hilo a la vez.  Es decir  solo se puede ejecutar un hilo en Python bytecode a la vez.  GIL asegura que m√∫ltiples hilos no se ejecutan <b>en paralelo</b> . <br><br>  Detalles r√°pidos de GIL: <br><br><ul><li>  Un hilo puede ejecutarse a la vez. </li><li>  El int√©rprete de Python cambia entre hilos para lograr competitividad. </li><li>  GIL es aplicable a CPython (implementaci√≥n est√°ndar).  Pero como, por ejemplo, Jython y IronPython no tienen GIL. </li><li>  GIL hace que los programas de un solo subproceso sean r√°pidos. </li><li>  GIL generalmente no interfiere con las E / S. </li><li>  GIL facilita la integraci√≥n de bibliotecas seguras para subprocesos en C, gracias a GIL tenemos muchas extensiones / m√≥dulos de alto rendimiento escritos en C. </li><li>  Para tareas dependientes de la CPU, el int√©rprete verifica cada N ticks y cambia los hilos.  Por lo tanto, un hilo no bloquea los otros. </li></ul><br>  Muchos ven a GIL como debilidad.  Considero esto como una bendici√≥n, porque se crearon bibliotecas como NumPy, SciPy, que ocupan una posici√≥n especial y √∫nica en la comunidad cient√≠fica. <br><br>  <u>Lectura adicional:</u> <br><br>  Estos recursos le permitir√°n profundizar en el GIL: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">www.dabeaz.com/python/UnderstandingGIL.pdf</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El art√≠culo est√° en ruso.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i>[aprox.</i></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i>traductor</i></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Un poco m√°s sobre GIL.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i>[aprox.</i></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i>traductor</i></a> </li></ul><br>  <b>Procesos</b> <br><br>  Para lograr la simultaneidad en Python, se ha agregado un m√≥dulo de <b>multiprocesamiento</b> que proporciona una API y se ve muy similar si utiliz√≥ <b>subprocesos</b> antes. <br><br>  Vamos a cambiar el ejemplo anterior.  Ahora la versi√≥n modificada usa el <b>Proceso en</b> lugar de la <b>Corriente</b> . <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> multiprocessing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">worker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(number)</span></span></span><span class="hljs-function">:</span></span> sleep = random.randrange(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) time.sleep(sleep) print(<span class="hljs-string"><span class="hljs-string">"I am Worker {}, I slept for {} seconds"</span></span>.format(number, sleep)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>): t = multiprocessing.Process(target=worker, args=(i,)) t.start() print(<span class="hljs-string"><span class="hljs-string">"All Processes are queued, let's see when they finish!"</span></span>)</code> </pre><br>  ¬øQu√© ha cambiado?  Acabo de importar el m√≥dulo de <b>multiprocesamiento en</b> lugar de <b>subprocesos</b> .  Y luego, en lugar de un hilo, utilic√© un proceso.  Eso es todo!  Ahora, en lugar de muchos subprocesos, utilizamos procesos que se ejecutan en diferentes n√∫cleos de CPU (a menos, por supuesto, que su procesador tenga varios n√∫cleos). <br><br>  Usando la clase Pool, tambi√©n podemos distribuir la ejecuci√≥n de una funci√≥n entre varios procesos para diferentes valores de entrada.  Un ejemplo de los documentos oficiales: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> multiprocessing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Pool <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x*x <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: p = Pool(<span class="hljs-number"><span class="hljs-number">5</span></span>) print(p.map(f, [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]))</code> </pre><br>  Aqu√≠, en lugar de iterar sobre la lista de valores y llamar a la funci√≥n f de uno en uno, en realidad ejecutamos la funci√≥n en diferentes procesos.  Un proceso hace f (1), el otro f (2) y el otro f (3).  Finalmente, los resultados se combinan nuevamente en una lista.  Esto nos permite dividir los c√°lculos pesados ‚Äã‚Äãen partes m√°s peque√±as y ejecutarlos en paralelo para un c√°lculo m√°s r√°pido. <br><br>  <u>Lectura adicional:</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pymotw.com/3/multiprocessing/index.html</a> </li></ul><br>  <b>Concurrent.futures module</b> <br><br>  El m√≥dulo concurrent.futures es grande y hace que escribir c√≥digo asincr√≥nico sea muy f√°cil.  Mis favoritos son <b>ThreadPoolExecutor</b> y <b>ProcessPoolExecutor</b> .  Estos artistas admiten un grupo de hilos o procesos.  Enviamos nuestras tareas al grupo y ejecuta las tareas en un hilo / proceso accesible.  Se devuelve un objeto <b>Futuro</b> que se puede utilizar para consultar y recuperar el resultado cuando finaliza la tarea. <br><br>  Y aqu√≠ hay un ejemplo de ThreadPoolExecutor: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> concurrent.futures <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ThreadPoolExecutor <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sleep <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return_after_5_secs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message)</span></span></span><span class="hljs-function">:</span></span> sleep(<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> message pool = ThreadPoolExecutor(<span class="hljs-number"><span class="hljs-number">3</span></span>) future = pool.submit(return_after_5_secs, (<span class="hljs-string"><span class="hljs-string">"hello"</span></span>)) print(future.done()) sleep(<span class="hljs-number"><span class="hljs-number">5</span></span>) print(future.done()) print(future.result())</code> </pre><br>  Tengo un art√≠culo sobre concurrent.futures <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">masnun.com/2016/03/29/python-a-quick-introduction-to-the-concurrent-futures-module.html</a> .  Puede ser √∫til para un estudio m√°s profundo de este m√≥dulo. <br><br>  <u>Lectura adicional:</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pymotw.com/3/concurrent.futures</a> </li></ul><br><h4>  Asyncio: ¬øqu√©, c√≥mo y por qu√©? </h4><br>  Probablemente tenga una pregunta que muchas personas en la comunidad de Python tienen: ¬øqu√© trae asyncio nuevo?  ¬øPor qu√© hab√≠a otra forma de usar E / S as√≠ncrona?  ¬øNo ten√≠amos ya hilos y procesos?  A ver! <br><br>  <b>¬øPor qu√© necesitamos asyncio?</b> <br><br>  Los procesos son muy caros <i>[en t√©rminos de consumo de recursos, aprox.</i>  <i>traductor]</i> para crear.  Por lo tanto, para las operaciones de E / S, los hilos se seleccionan principalmente.  Sabemos que la E / S depende de elementos externos: las unidades lentas o los retrasos desagradables de la red hacen que la E / S a menudo sea impredecible.  Ahora supongamos que usamos hilos para E / S.  3 hilos realizan varias tareas de E / S.  El int√©rprete tendr√≠a que cambiar entre flujos competitivos y darles a cada uno algo de tiempo.  Llame a los flujos T1, T2 y T3.  Tres hilos comenzaron su operaci√≥n de E / S.  T3 lo completa primero.  T2 y T1 siguen esperando E / S.  El int√©rprete de Python est√° cambiando a T1, pero todav√≠a est√° esperando.  Bueno, el int√©rprete se mueve a T2, y el int√©rprete todav√≠a est√° esperando, y luego se mueve a T3, que est√° listo y ejecuta el c√≥digo.  ¬øVes esto como un problema? <br><br>  T3 estaba listo, pero el int√©rprete primero cambi√≥ entre T2 y T1; esto incurri√≥ en costos de cambio, lo que podr√≠amos haber evitado si el int√©rprete hubiera cambiado primero a T3, ¬øverdad? <br><br>  <b>¬øQu√© es asynio?</b> <br><br>  Asyncio nos proporciona un ciclo de eventos junto con otras cosas interesantes.  El bucle de eventos supervisa los eventos de E / S y cambia las tareas que est√°n listas y esperando las operaciones de E / S <i>[el bucle de eventos es una construcci√≥n de software que espera la llegada y env√≠a eventos o mensajes en el programa, aprox.</i>  <i>traductor]</i> . <br><br>  La idea es muy simple.  Hay un bucle de eventos.  Y tenemos funciones que realizan E / S as√≠ncronas.  Transferimos nuestras funciones al bucle de eventos y le pedimos que las ejecute por nosotros.  El bucle de eventos nos devuelve un objeto Futuro, como una promesa de que en el futuro obtendremos algo.  Nos aferramos a una promesa, verificamos de vez en cuando si es importante (realmente no podemos esperar), y finalmente, cuando se recibe el valor, lo usamos en otras operaciones <i>[es decir</i>  <i>enviamos una solicitud, inmediatamente nos dieron un boleto y nos dijeron que esperemos hasta que llegue el resultado.</i>  <i>Verificamos peri√≥dicamente el resultado y tan pronto como se recibe, tomamos un boleto y obtenemos un valor, aprox.</i>  <i>traductor]</i> . <br><br>  Asyncio usa generadores y corutinas para detener y reanudar tareas.  Puedes leer los detalles aqu√≠: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">masnun.com/2015/11/20/python-asyncio-future-task-and-the-event-loop.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">masnun.com/2015/11/13/python-generators-coroutines-native-coroutines-and-async-await.html</a> </li></ul><br>  <b>¬øC√≥mo usar asyncio?</b> <br><br>  Antes de comenzar, veamos un ejemplo: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_sleep_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(random.randint(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">display_date</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num, loop)</span></span></span><span class="hljs-function">:</span></span> end_time = loop.time() + <span class="hljs-number"><span class="hljs-number">50.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Loop: {} Time: {}"</span></span>.format(num, datetime.datetime.now())) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (loop.time() + <span class="hljs-number"><span class="hljs-number">1.0</span></span>) &gt;= end_time: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> my_sleep_func() loop = asyncio.get_event_loop() asyncio.ensure_future(display_date(<span class="hljs-number"><span class="hljs-number">1</span></span>, loop)) asyncio.ensure_future(display_date(<span class="hljs-number"><span class="hljs-number">2</span></span>, loop)) loop.run_forever()</code> </pre><br>  Tenga en cuenta que la sintaxis async / await es solo para Python 3.5 y versiones posteriores.  Veamos el c√≥digo: <br><br><ul><li>  Tenemos una funci√≥n asincr√≥nica display_date que toma un n√∫mero (como identificador) y un bucle de eventos como par√°metros. </li><li>  La funci√≥n tiene un bucle infinito, que se interrumpe despu√©s de 50 segundos.  Pero durante este per√≠odo, ella imprime repetidamente el tiempo y hace una pausa.  La funci√≥n de espera puede esperar a que se completen otras funciones asincr√≥nicas (de rutina). </li><li>  Pasamos la funci√≥n al bucle de eventos (usando el m√©todo allow_future). </li><li>  Comenzamos un ciclo de eventos. </li></ul><br>  Cada vez que se llama a esperar, asyncio se da cuenta de que la funci√≥n probablemente llevar√° alg√∫n tiempo.  Por lo tanto, detiene la ejecuci√≥n, comienza a monitorear cualquier evento de E / S asociado y le permite ejecutar tareas.  Cuando asyncio se da cuenta de que la E / S de la funci√≥n en pausa est√° lista, reanuda la funci√≥n. <br><br><h4>  Haciendo la elecci√≥n correcta. </h4><br>  Acabamos de pasar por las formas m√°s populares de competitividad.  Pero la pregunta sigue siendo: ¬øqu√© se debe elegir?  Depende de los casos de uso.  Desde mi experiencia, tiendo a seguir este pseudoc√≥digo: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> io_bound: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> io_very_slow: print(<span class="hljs-string"><span class="hljs-string">"Use Asyncio"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Use Threads"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Multi Processing"</span></span>)</code> </pre><br><ul><li>  CPU enlazada =&gt; Procesamiento m√∫ltiple </li><li>  E / S enlazada, E / S r√°pida, n√∫mero limitado de conexiones =&gt; Multi Threading </li><li>  I / O Bound, I / O lenta, muchas conexiones =&gt; Asyncio </li></ul><br>  <i>[Nota</i>  <i>traductor</i> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conferencia (presentaci√≥n) en ruso sobre multihilo y GIL.</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es421625/">https://habr.com/ru/post/es421625/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es421607/index.html">"Ni siquiera intentamos ejecutar el c√≥digo antiguo, no tenemos esa tarea en principio" - Roman Elizarov sobre el desarrollo de Kotlin</a></li>
<li><a href="../es421611/index.html">C√≥mo se cre√≥ World of Warcraft: una mirada interna a 20 a√±os de desarrollo</a></li>
<li><a href="../es421613/index.html">C√≥mo escribimos art√≠culos sobre Habr: experiencia de los desarrolladores de EastBanc Technologies</a></li>
<li><a href="../es421615/index.html">La soluci√≥n a la falta de prevProps en getDerivedStateFromProps</a></li>
<li><a href="../es421619/index.html">Sistemas aut√≥nomos del futuro. Clasificaci√≥n, caracter√≠sticas y requisitos.</a></li>
<li><a href="../es421629/index.html">¬øLos robots tomar√°n mi trabajo? (¬øY si soy humanista?)</a></li>
<li><a href="../es421631/index.html">Analice el port√°til Lenovo ThinkPad X1 Carbon (2018): ligero, c√≥modo y potente</a></li>
<li><a href="../es421633/index.html">C√≥mo hacer un est√°ndar en 10 d√≠as</a></li>
<li><a href="../es421637/index.html">Reloj para ni√±os con GPS antes del 1 de septiembre: a qu√© puede prestar atenci√≥n</a></li>
<li><a href="../es421639/index.html">Laptop Jumper EZBook X4 chino: teclado retroiluminado y la nueva plataforma Gemini Lake</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>