<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé∞ üèâ ü¶ñ Was beim Feature Freeze 2019 eingefroren wurde. Teil I. JSONPath üíÑ üßú üî¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nach dem Committeefit 2019-03 fand ein Feature Freeze statt. Wir haben hier eine fast traditionelle Kolumne: Wir haben bereits √ºber das Einfrieren im ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Was beim Feature Freeze 2019 eingefroren wurde. Teil I. JSONPath</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/448612/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/yl/kw/ra/ylkwraooftas8s1ft0ik4pgn5tc.jpeg"></div><br>  Nach dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Committeefit 2019-03</b></a> fand ein Feature Freeze statt.  Wir haben hier eine fast traditionelle Kolumne: Wir haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bereits</a> √ºber das Einfrieren im letzten Jahr geschrieben.  Nun werden die Ergebnisse von 2019: Welche der neuen werden in PostgreSQL 12 enthalten sein? In diesem Teil der √úberpr√ºfung, die JSONPath gewidmet ist, werden Beispiele und Fragmente aus dem Bericht "Postgres 12 in Etudes" verwendet, den Oleg Bartunov am 9. April dieses Jahres bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Saint Highload ++</a> in St. Petersburg gelesen hat. <br><a name="habracut"></a><br><h2>  Jsonpath </h2><br>  Alles, was mit JSON (B) zu tun hat, ist weltweit und in Russland gefragt, und dies ist einer der wichtigsten Entwicklungsbereiche bei Postgres Professional.  Der jsonb-Typ, die Funktionen und Operatoren f√ºr die Arbeit mit JSON / JSONB wurden in PostgreSQL Version 9.4 ver√∂ffentlicht. Sie wurden von einem Team unter der Leitung von Oleg Bartunov erstellt. <br><br>  Der SQL / 2016-Standard sieht die Arbeit mit JSON vor: JSONPath wird dort erw√§hnt - eine Reihe von Datenadressierungswerkzeugen in JSON;  JSONTABLE - Mittel zum Konvertieren von JSON in regul√§re Tabellen;  Eine gro√üe Familie von Funktionen und Operatoren.  Trotz der Tatsache, dass JSON in Postgres seit langem unterst√ºtzt wird, haben Oleg Bartunov und seine Kollegen 2017 begonnen, an der Unterst√ºtzung des Standards zu arbeiten.  Die Einhaltung des Standards ist immer gut.  Von allem, was im Standard beschrieben ist, ist JSONPath in Version 12 nur ein, aber der wichtigste Patch, also werden wir zuerst dar√ºber sprechen. <br><br>  In der Antike wurde JSON verwendet und in Textfeldern gespeichert.  In 9.3 wurde ein spezieller Datentyp f√ºr JSON angezeigt, die damit verbundene Funktionalit√§t war jedoch nicht umfangreich, und Anforderungen mit diesem Typ arbeiteten aufgrund der Zeit, die f√ºr das Parsen der Textdarstellung von JSON aufgewendet wurde, nur langsam.  Dies stoppte viele potenzielle Postgres-Benutzer, die NoSQL-Datenbanken bevorzugten.  Die Produktivit√§t von Postgres stieg auf 9,4, als Postgres dank O. Bartunov, A. Korotkov und F. Sigaev eine bin√§re Version von JSON einf√ºhrte - den jsonb-Typ. <br>  jsonb muss nicht jedes Mal analysiert werden, daher ist die Arbeit damit viel schneller.  Von den neuen Funktionen und Operatoren, die gleichzeitig entstanden sind, arbeiten einige nur mit einem neuen Bin√§rtyp, z. B. dem wichtigen Operator des Auftretens <b>@&gt;</b> , der pr√ºft, ob ein Element oder Array in einem bestimmten JSONB enthalten ist: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'[1, 2, 3]'</span></span>::jsonb @&gt; <span class="hljs-string"><span class="hljs-string">'[1, 3]'</span></span>::jsonb;</code> </pre> <br>  gibt TRUE, da das Array auf der rechten Seite in das Array auf der linken Seite eintritt.  Aber <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'[1, 2, [1, 3]]'</span></span>::jsonb @&gt; <span class="hljs-string"><span class="hljs-string">'[1, 3]'</span></span>::jsonb;</code> </pre> <br>  gibt FALSE, da die Verschachtelungsebene unterschiedlich ist, muss sie explizit festgelegt werden.  Wird der Existenzoperator f√ºr den Typ jsonb eingef√ºhrt <b>?</b>  (ein Fragezeichen), das pr√ºft, ob eine Zeichenfolge ein Objektschl√ºssel oder ein Element eines Arrays auf der obersten Ebene der JSONB-Werte ist, sowie zwei weitere √§hnliche Operatoren (Details <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ).  Sie werden von GIN-Indizes mit zwei Klassen von GIN-Operatoren unterst√ºtzt.  Mit dem Operator <b>-&gt;</b> (Pfeil) k√∂nnen Sie durch JSONB "navigieren". Er gibt einen Wert nach Schl√ºssel oder, wenn es sich um ein Array handelt, nach Index zur√ºck.  Es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gibt mehrere weitere</a> Bediener zum Verschieben.  Es gibt jedoch keine M√∂glichkeit, Filter zu organisieren, die √§hnlich wie WHERE funktionieren.  Es war ein Durchbruch: Dank jsonb wurde Postgres als RDBMS mit NoSQL-Funktionen immer beliebter. <br><br>  2014 entwickelten A. Korotkov, O. Bartunov und F. Sigaev die Erweiterung jsquery, die als Ergebnis in Postgres Pro Standard 9.5 (und in sp√§teren Versionen von Standard und Enterprise) enthalten war.  Es bietet zus√§tzliche, sehr umfassende Funktionen f√ºr die Arbeit mit json (b).  Diese Erweiterung definiert die Abfragesprache zum Extrahieren von Daten aus json (b) und Indizes, um diese Abfragen zu beschleunigen.  Diese Funktionalit√§t wurde von den Benutzern ben√∂tigt, sie waren nicht bereit, auf den Standard und die Aufnahme neuer Funktionen in die Vanille-Version zu warten.  Der praktische Wert wird auch durch die Tatsache belegt, dass die Entwicklung von Wargaming.net gesponsert wurde.  Die Erweiterung implementiert einen speziellen Typ - jsquery. <br><br>  Eine Abfrage in dieser Sprache ist kompakt und sieht beispielsweise folgenderma√üen aus: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'{"apt":[{"no": 1, "rooms":2}, {"no": 2, "rooms":3}, {"no": 3, "rooms":2}]}'</span></span>::jsonb @@ <span class="hljs-string"><span class="hljs-string">'apt.#.rooms=3'</span></span>::jsquery;</code> </pre> <br>  Wir fragen hier, ob es im Wohnhaus ‚Äûdrei Rubel‚Äú gibt.  Der Typ jsquery muss angegeben werden, da sich der Operator @@ jetzt auch im Typ jsonb befindet.  Die Beschreibung ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und die Pr√§sentation mit vielen Beispielen ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Insgesamt: Postgres hatte bereits alles f√ºr die Arbeit mit JSON, und dann erschien der SQL: 2016-Standard.  Es stellte sich heraus, dass sich seine Semantik nicht so sehr von unserer in der jsquery-Erweiterung unterscheidet.  Es ist m√∂glich, dass die Autoren des Standards sogar einen Blick auf jsquery geworfen haben und JSONPath erfunden haben.  Unser Team musste das, was wir bereits hatten, etwas anders umsetzen und nat√ºrlich auch viele neue Dinge. <br><br>  Vor mehr als einem Jahr, beim Commitfest im M√§rz, wurden der Community die Fr√ºchte unserer Programmierbem√ºhungen in Form von drei gro√üen Patches mit Unterst√ºtzung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SQL: 2016-</a> Standards angeboten: <br><br>  SQL / JSON: JSONPath; <br>  SQL / JSON: Funktionen; <br>  SQL / JSON: JSON_TABLE. <br><br>  Die Entwicklung eines Patches ist jedoch nicht das ganze Gesch√§ft. Die Bewerbung ist auch nicht einfach, insbesondere wenn die Patches gro√ü sind und viele Module betreffen.  Es sind viele Iterationen der Revision erforderlich. Der Patch muss wie bei kommerziellen Unternehmen beworben werden und viele Ressourcen (Arbeitsstunden) investieren.  Der Chefarchitekt von Postgres Professional, Alexander Korotkov, nahm es auf sich (da er jetzt den Status eines Committers hat) und erreichte die √úbernahme des JSONPath-Patches - des Haupt-Patches in dieser Reihe von Patches.  Die zweite und dritte befinden sich jetzt im Status der Bedarfs√ºberpr√ºfung.  Mit dem fokussierten JSONPath k√∂nnen Sie mit der JSON (B) -Struktur arbeiten und sind flexibel genug, um ihre Fragmente hervorzuheben.  Von den 15 im Standard vorgeschriebenen Punkten sind 14 implementiert, und dies ist mehr als in Oracle, MySQL und MS SQL. <br><br>  Die JSONPath-Notation unterscheidet sich von den Postgres-Anweisungen f√ºr die Arbeit mit der JSON- und JSQuery-Notation.  Die Hierarchie wird durch Punkte angezeigt: <br><br>  $ .abc (in der Postgres 11-Notation m√ºsste ich 'a' -&gt; 'b' -&gt; 'c' schreiben); <br>  $ - der aktuelle Kontext des Elements - tats√§chlich definiert der Ausdruck mit $ die json (b) -Region, die verarbeitet werden soll, einschlie√ülich der im Filter, der Rest davon ist nicht f√ºr die Arbeit verf√ºgbar; <br>  @ - der aktuelle Kontext im Filterausdruck - iteriert mit $ √ºber die im Ausdruck verf√ºgbaren Pfade; <br>  [*] - ein Array; <br>  * - Platzhalter bedeutet im Ausdruck mit $ oder @ einen beliebigen Wert des Pfadsegments, jedoch unter Ber√ºcksichtigung der Hierarchie; <br>  ** - als Teil des Ausdrucks mit $ oder @ kann jeder Wert des Pfadsegments ohne Ber√ºcksichtigung der Hierarchie bedeuten - es ist praktisch, ihn zu verwenden, wenn Sie die Verschachtelungsebene von Elementen nicht kennen; <br>  Betreiber "?"  Mit dieser Option k√∂nnen Sie einen Filter √§hnlich dem von WHERE organisieren: <br>  $ .abc?  (@ .x&gt; 10); <br>  $ .abcxtype () sowie size (), double (), decken (), floor (), abs (), datetime (), keyvalue () sind Methoden. <br>  Eine Abfrage mit der Funktion jsonb_path_query (zu den folgenden Funktionen) k√∂nnte folgenderma√üen aussehen: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query_array(<span class="hljs-string"><span class="hljs-string">'[1,2,3,4,5]'</span></span>, <span class="hljs-string"><span class="hljs-string">'$[*] ? (@ &gt; 3)'</span></span>); jsonb_path_query_array <span class="hljs-comment"><span class="hljs-comment">------------------------ [4, 5] (1 row)</span></span></code> </pre> <br>  Obwohl ein spezieller Patch mit Funktionen nicht festgeschrieben ist, verf√ºgt der JSONPath-Patch bereits √ºber Schl√ºsselfunktionen f√ºr die Arbeit mit JSON (B): <br><br><br><pre> <code class="sql hljs">jsonb_path_exists('{"a": 1}', '$.a')  true (  "?") jsonb_path_exists('{"a": 1}', '$.b')  false jsonb_path_match('{"a": 1}', '$.a == 1')  true (  "@&gt;") jsonb_path_match('{"a": 1}', '$.a &gt;= 2')  false jsonb_path_query('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 2)')  3, 4, 5 jsonb_path_query('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 5)')  0  jsonb_path_query_array('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 2)')  [3, 4, 5] jsonb_path_query_array('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 5)')  [] jsonb_path_query_first('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 2)')  3 jsonb_path_query_first('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 5)')  NULL</code> </pre> <br>  Beachten Sie, dass die Gleichheit in JSONPath-Ausdr√ºcken ein einzelnes "=" ist, w√§hrend sie in jsquery doppelt ist: "==". <br><br>  F√ºr elegantere Illustrationen generieren wir JSONB in ‚Äã‚Äãeiner einspaltigen Hausplatte: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> house(js jsonb); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> house <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'{ "address": { "city":"Moscow", "street": "Ulyanova, 7A" }, "lift": false, "floor": [ { "level": 1, "apt": [ {"no": 1, "area": 40, "rooms": 1}, {"no": 2, "area": 80, "rooms": 3}, {"no": 3, "area": 50, "rooms": 2} ] }, { "level": 2, "apt": [ {"no": 4, "area": 100, "rooms": 3}, {"no": 5, "area": 60, "rooms": 2} ] } ] }'</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/u6/ob/nb/u6obnbokethtz5gatlcbdtvhjyi.png"><br>  <i>Abb. 1 Geh√§use des JSON-Baums mit zugewiesenen Blattwohnungen.</i> <br><br>  Dies ist ein seltsamer JSON: Es hat eine verwirrte Hierarchie, aber es ist aus dem Leben genommen, und im Leben ist es oft notwendig, mit dem zu arbeiten, was ist, und nicht mit dem, was sein sollte.  Ausgestattet mit den Funktionen der neuen Version finden wir Wohnungen im 1. und 2. Stock, aber nicht die erste in der Liste der Bodenwohnungen (auf dem Baum sind sie gr√ºn hervorgehoben): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query_array(js, <span class="hljs-string"><span class="hljs-string">'$.floor[0, 1].apt[1 to last]'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house; <span class="hljs-comment"><span class="hljs-comment">--------------------- [{"no": 2, "area": 80, "rooms": 3}, {"no": 3, "area": 50, "rooms": 2}, {"no": 5, "area": 60, "rooms": 2}]</span></span></code> </pre><br>  In PostgreSQL 11 m√ºssen Sie Folgendes fragen: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_agg(apt) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> apt-&gt;generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, jsonb_array_length(apt) - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> js-&gt;<span class="hljs-string"><span class="hljs-string">'floor'</span></span>-&gt;<span class="hljs-keyword"><span class="hljs-keyword">unnest</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>])-&gt;<span class="hljs-string"><span class="hljs-string">'apt'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house ) apts(apt) ) apts(apt);</code> </pre> <br>  Nun eine sehr einfache Frage: Gibt es Zeilen, die (irgendwo) den Wert ‚ÄûMoskau‚Äú enthalten?  Ganz einfach: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_exists(js, <span class="hljs-string"><span class="hljs-string">'$.** ? (@ == "Moscow")'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house;</code> </pre> <br>  In Version 11 m√ºssten Sie ein riesiges Skript schreiben: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RECURSIVE</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> ALL ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COALESCE</span></span>(kv.value, e.value) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> LATERAL jsonb_each ( <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> jsonb_typeof(t.value) = <span class="hljs-string"><span class="hljs-string">'object'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> t.value <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> ) kv <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> LATERAL jsonb_array_elements ( <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> jsonb_typeof(t.value) = <span class="hljs-string"><span class="hljs-string">'array'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> t.value <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> ) e <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> kv.value <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> e.value <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-string"><span class="hljs-string">'"Moscow"'</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/1k/uv/go/1kuvgo4f2bnjj_aylnvej76gltc.png"><br>  <i>Abb. 2 Wohnungsbaum JSON, Moskau wurde gefunden!</i> <br><br>  Wir suchen eine Wohnung auf jeder Etage mit einer Fl√§che von 40 bis 90 qm: <br><br><pre> <code class="plaintext hljs">select jsonb_path_query(js, '$.floor[*].apt[*] ? (@.area &gt; 40 &amp;&amp; @.area &lt; 90)') FROM house; jsonb_path_query ----------------------------------- {"no": 2, "area": 80, "rooms": 3} {"no": 3, "area": 50, "rooms": 2} {"no": 5, "area": 60, "rooms": 2} (3 rows)</code> </pre><br>  Wir suchen Wohnungen mit Zimmern nach dem 3. mit unserem Housing Jason: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(js, <span class="hljs-string"><span class="hljs-string">'$.floor.apt.no ? (@&gt;3)'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house; jsonb_path_query <span class="hljs-comment"><span class="hljs-comment">------------------ 4 5 (2 rows)</span></span></code> </pre> <br>  Und so funktioniert jsonb_path_query_first: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query_first(js, <span class="hljs-string"><span class="hljs-string">'$.floor.apt.no ? (@&gt;3)'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house; jsonb_path_query_first <span class="hljs-comment"><span class="hljs-comment">------------------------ 4 (1 row)</span></span></code> </pre> <br>  Wir sehen, dass nur der erste Wert ausgew√§hlt wird, der die Filterbedingung erf√ºllt. <br><br>  Der boolesche JSONPath-Operator f√ºr JSONB @@ wird als Matching-Operator bezeichnet.  Es berechnet das JSONPath-Pr√§dikat durch Aufrufen der Funktion jsonb_path_match_opr. <br><br>  Ein anderer boolescher Operator ist @?  - Dies ist ein Test der Existenz, beantwortet die Frage, ob der JSONPath-Ausdruck SQL / JSON-Objekte zur√ºckgibt, und ruft die Funktion jsonb_path_exists_opr auf: <br><br><pre> <code class="sql hljs"> '[1,2,3]' @@ '$[*] == 3'  true;  '[1,2,3]' @? '$[*] @? (@ == 3)' -  true</code> </pre> <br>  Das gleiche Ergebnis kann mit verschiedenen Operatoren erzielt werden: <br><br><pre> <code class="sql hljs">js @? '$.a'  js @@ 'exists($.a)' js @@ '$.a == 1'  js @? '$ ? ($.a == 1)'</code> </pre> <br>  Das Sch√∂ne an JSONPath Boolean-Operatoren ist, dass sie unterst√ºtzt und durch GIN-Indizes beschleunigt werden.  jsonb_ops und jsonb_path_ops sind die entsprechenden Operatorklassen.  In diesem Beispiel deaktivieren wir SEQSCAN, da wir eine Mikrotabelle haben. In gro√üen Tabellen w√§hlt der Optimierer selbst den Bitmap-Index aus: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> ENABLE_SEQSCAN <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> house <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> gin (js); <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (COSTS <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> js @? <span class="hljs-string"><span class="hljs-string">'$.floor[*].apt[*] ? (@.rooms == 3)'</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------------------------- Bitmap Heap Scan on house Recheck Cond: (js @? '$."floor"[*]."apt"[*]?(@."rooms" == 3)'::jsonpath) -&gt; Bitmap Index Scan on house_js_idx Index Cond: (js @? '$."floor"[*]."apt"[*]?(@."rooms" == 3)'::jsonpath) (4 rows)</span></span></code> </pre> <br>  Alle Funktionen der Form jsonb_path_xxx () haben dieselbe Signatur: <br><br><pre> <code class="sql hljs">jsonb_path_xxx( js jsonb, jsp jsonpath, vars jsonb DEFAULT '{}', silent boolean DEFAULT false )</code> </pre> <br>  vars ist ein JSONB-Objekt zum √úbergeben von JSONPath-Variablen: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query_array(<span class="hljs-string"><span class="hljs-string">'[1,2,3,4,5]'</span></span>, <span class="hljs-string"><span class="hljs-string">'$[*] ? (@ &gt; $x)'</span></span>, vars =&gt; <span class="hljs-string"><span class="hljs-string">'{"x": 2}'</span></span>); jsonb_path_query_array <span class="hljs-comment"><span class="hljs-comment">------------------------ [3, 4, 5]</span></span></code> </pre> <br>  Es ist schwierig, auf vars zu verzichten, wenn wir einen Join mit einem Feld vom Typ jsonb in einer der Tabellen erstellen.  Angenommen, wir stellen einen Antrag, der nach geeigneten Wohnungen f√ºr Mitarbeiter in diesem Haus sucht, die ihre Anforderungen f√ºr die Mindestfl√§che im Fragebogen notiert haben: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> demands(<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">position</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">demand</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> demands <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-number"><span class="hljs-number">85</span></span>), (<span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">45</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(js, <span class="hljs-string"><span class="hljs-string">'$.floor[*].apt[*] ? (@.area &gt;= $min)'</span></span>, vars =&gt; jsonb_build_object(<span class="hljs-string"><span class="hljs-string">'min'</span></span>, demands.demand)) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house, demands <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span>; -[ RECORD 1 ]<span class="hljs-comment"><span class="hljs-comment">----+----------------------------------- jsonb_path_query | {"no": 2, "area": 80, "rooms": 3} -[ RECORD 2 ]----+----------------------------------- jsonb_path_query | {"no": 3, "area": 50, "rooms": 2} -[ RECORD 3 ]----+----------------------------------- jsonb_path_query | {"no": 4, "area": 100, "rooms": 3} -[ RECORD 4 ]----+----------------------------------- jsonb_path_query | {"no": 5, "area": 60, "rooms": 2}</span></span></code> </pre> <br>  Lucky Pasha kann aus 4 Apartments w√§hlen.  Es lohnt sich jedoch, 1 Buchstaben in der Anfrage zu √§ndern - von "P" in "C", und es wird keine Wahl geben!  Nur 1 Wohnung reicht aus. <br><br><br>  Ein weiteres Schl√ºsselwort bleibt: Silent ist ein Flag, das die Fehlerbehandlung unterdr√ºckt, und sie liegen im Gewissen des Programmierers. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(<span class="hljs-string"><span class="hljs-string">'[]'</span></span>, <span class="hljs-string"><span class="hljs-string">'strict $.a'</span></span>); ERROR: SQL/JSON member not found DETAIL: jsonpath member accessor can only be applied to an object</code> </pre> <br>  Der Fehler.  Dies wird jedoch kein Fehler sein: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(<span class="hljs-string"><span class="hljs-string">'[]'</span></span>, <span class="hljs-string"><span class="hljs-string">'strict $.a'</span></span>, silent =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span>); jsonb_path_query <span class="hljs-comment"><span class="hljs-comment">------------------ (0 rows)</span></span></code> </pre> <br>  √úbrigens √ºber Fehler: Gem√§√ü dem Standard geben arithmetische Fehler in Ausdr√ºcken keine Fehlermeldungen aus, sie liegen im Gewissen des Programmierers: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(<span class="hljs-string"><span class="hljs-string">'[1,0,2]'</span></span>, <span class="hljs-string"><span class="hljs-string">'$[*] ? (1/ @ &gt;= 1)'</span></span>); jsonb_path_query <span class="hljs-comment"><span class="hljs-comment">------------------ 1 (1 row)</span></span></code> </pre> <br>  Bei der Berechnung des Ausdrucks im Filter werden die Array-Werte durchsucht, darunter 0, aber das Teilen durch 0 erzeugt keinen Fehler. <br><br>  Die Funktionen funktionieren je nach ausgew√§hltem Modus unterschiedlich: Streng oder Lax (in der √úbersetzung ‚Äûnicht streng‚Äú oder sogar ‚Äûlocker‚Äú ist sie standardm√§√üig ausgew√§hlt).  Angenommen, wir suchen in JSON nach einem Schl√ºssel im Lax-Modus, wo dies offensichtlich nicht der Fall ist: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb <span class="hljs-string"><span class="hljs-string">'{"a":1}'</span></span> @? <span class="hljs-string"><span class="hljs-string">'lax $.b ? (@ &gt; 1)'</span></span>; ?column? <span class="hljs-comment"><span class="hljs-comment">---------- f (1 row)</span></span></code> </pre> <br>  Jetzt im strengen Modus: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb <span class="hljs-string"><span class="hljs-string">'{"a":1}'</span></span> @? <span class="hljs-string"><span class="hljs-string">'strict $.b ? (@ &gt; 1)'</span></span>; ?column? <span class="hljs-comment"><span class="hljs-comment">---------- (null) (1 row)</span></span></code> </pre> <br>  Das hei√üt, wo wir im liberalen Modus FALSE erhalten haben, haben wir mit strikt NULL erhalten. <br><br>  Im Lax-Modus wird ein Array mit einer komplexen Hierarchie [1,2, [3,4,5]] immer auf [1,2,3,4,5] erweitert: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb <span class="hljs-string"><span class="hljs-string">'[1,2,[3,4,5]]'</span></span> @? <span class="hljs-string"><span class="hljs-string">'lax $[*] ? (@ == 5)'</span></span>; ?column? <span class="hljs-comment"><span class="hljs-comment">---------- t (1 row)</span></span></code> </pre> <br>  Im strengen Modus wird die Zahl ‚Äû5‚Äú nicht gefunden, da sie sich nicht am Ende der Hierarchie befindet.  Um es zu finden, m√ºssen Sie die Abfrage √§ndern und "@" durch "@ [*]" ersetzen: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb <span class="hljs-string"><span class="hljs-string">'[1,2,[3,4,5]]'</span></span> @? <span class="hljs-string"><span class="hljs-string">'strict $[*] ? (@[*] == 5)'</span></span>; ?column? <span class="hljs-comment"><span class="hljs-comment">---------- t (1 row)</span></span></code> </pre> <br>  In PostgreSQL 12 ist JSONPath ein Datentyp.  Der Standard sagt nichts √ºber die Notwendigkeit eines neuen Typs aus, er ist eine Eigenschaft der Implementierung.  Mit dem neuen Typ erhalten wir eine vollst√§ndige Arbeit mit jsonpath mithilfe von Operatoren und Indizes, die ihre Arbeit beschleunigen und bereits f√ºr JSONB existieren.  Andernfalls m√ºsste JSONPath auf der Ebene des Executor- und Optimizer-Codes integriert werden. <br><br>  Hier k√∂nnen Sie beispielsweise Informationen zur SQL / JSON-Syntax lesen. <br><br>  In Oleg Bartunovs Blogbeitrag geht es um die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Konformit√§t</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SQL / JSON-Standard 2016</a> f√ºr PostgreSQL, Oracle, SQL Server und MySQL. <br><br>  Hier ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pr√§sentation</a> zu SQL / JSON. <br><br>  Und hier ist eine <a href="">Einf√ºhrung</a> in SQL / JSON. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448612/">https://habr.com/ru/post/de448612/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448602/index.html">Ist die √úberwachung tot? - Es lebe die √úberwachung</a></li>
<li><a href="../de448604/index.html">Gameboy in C #</a></li>
<li><a href="../de448606/index.html">Sidorin: Bei KnowledgeConf geht es darum, wie Wissen mit einer durchschnittlichen Arbeitsdauer an einem Ort in 2-3 Jahren aufrechterhalten werden kann</a></li>
<li><a href="../de448608/index.html">Wie mache ich die ersten Schritte in der Robotik?</a></li>
<li><a href="../de448610/index.html">DIY: Wie wir einen Live-Zeitplan f√ºr Codefest X erstellt haben</a></li>
<li><a href="../de448618/index.html">Douglas-Pecker-Algorithmus</a></li>
<li><a href="../de448622/index.html">PHP GR8: Verbessert JIT die Leistung von PHP 8</a></li>
<li><a href="../de448624/index.html">Daten anzeigen? Nein. Also ich sehe nicht, aber sie sind. Wir zerst√∂ren Daten auf SSD-Laufwerken und stellen sogar die Geschwindigkeit wieder her</a></li>
<li><a href="../de448626/index.html">DDoS hilft: wie wir Stress und Stresstests durchf√ºhren</a></li>
<li><a href="../de448628/index.html">Sowjetische technische √Ñsthetik und Technologie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>