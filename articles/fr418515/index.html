<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì≥ üè≥Ô∏è‚Äçüåà üßëüèΩ‚Äçü§ù‚Äçüßëüèº Remplacer Equals et GetHashCode. Mais est-ce n√©cessaire? üë®üèæ‚Äçüéì üòá üë®‚Äçüë®‚Äçüëß‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Si vous connaissez C #, vous savez tr√®s probablement que vous devez toujours remplacer Equals , ainsi que GetHashCode , pour √©viter une GetHashCode pe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Remplacer Equals et GetHashCode. Mais est-ce n√©cessaire?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/418515/"> Si vous connaissez C #, vous savez tr√®s probablement que vous devez toujours remplacer <code>Equals</code> , ainsi que <code>GetHashCode</code> , pour √©viter une <code>GetHashCode</code> performances.  Mais que se passera-t-il si cela n'est pas fait?  Aujourd'hui, nous comparons les performances avec deux options de r√©glage et envisageons des outils pour √©viter les erreurs. <br><br><img src="https://habrastorage.org/webt/w9/iq/7g/w9iq7gen1fjdvh3j6jcxai470ec.jpeg"><a name="habracut"></a><br><br><h2>  Quelle est la gravit√© de ce probl√®me? </h2><br>  Tous les probl√®mes de performances potentiels n'affectent pas l'ex√©cution des applications.  La m√©thode <code>Enum.HasFlag</code> pas tr√®s efficace (*), mais si vous ne l'utilisez pas sur un morceau de code gourmand en ressources, il n'y aura pas de probl√®mes graves dans le projet.  C'est √©galement le cas avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les copies prot√©g√©es</a> cr√©√©es par des types de structure non en lecture seule dans le contexte en lecture seule.  Le probl√®me existe, mais il est peu probable qu'il soit perceptible dans les applications ordinaires. <br><br>  <i>(*) Corrig√© dans .NET Core 2.1, et, comme je l'ai mentionn√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans une publication pr√©c√©dente</a> , maintenant les cons√©quences peuvent √™tre att√©nu√©es en utilisant le HasFlag auto-configur√© pour les anciennes versions.</i> <br><br>  Mais le probl√®me dont nous allons parler aujourd'hui est particulier.  Si les m√©thodes <code>Equals</code> et <code>GetHashCode</code> ne sont pas cr√©√©es dans la structure, leurs versions standard de <code>System.ValueType</code> .  Et ils peuvent r√©duire consid√©rablement les performances de l'application finale. <br><br><h2>  Pourquoi les versions standard sont-elles lentes? </h2><br>  Les auteurs du CLR ont fait de leur mieux pour rendre les versions standard d'Equals et GetHashCode aussi efficaces que possible pour les types de valeur.  Mais il y a plusieurs raisons pour lesquelles ces m√©thodes perdent en efficacit√© de la version utilisateur, √©crite pour un certain type manuellement (ou g√©n√©r√©e par le compilateur). <br><br>  1. Distribution de la conversion des emballages.  Le CLR est con√ßu de telle mani√®re que chaque appel √† un √©l√©ment d√©fini dans les types <code>System.ValueType</code> ou <code>System.Enum</code> d√©clenche une transformation d'habillage (**). <br><br>  <i>(**) Si la m√©thode ne prend pas en charge la compilation JIT.</i>  <i>Par exemple, dans Core CLR 2.1, le compilateur JIT reconna√Æt la m√©thode <code>Enum.HasFlag</code> et g√©n√®re un code appropri√© qui ne d√©marre pas le wrapping.</i> <br><br>  2. Conflits potentiels dans la version standard de la m√©thode <code>GetHashCode</code> .  Lors de la mise en ≈ìuvre d'une fonction de hachage, nous sommes confront√©s √† un dilemme: rendre la distribution de la fonction de hachage bonne ou rapide.  Dans certains cas, vous pouvez faire les deux, mais dans le type <code>ValueType.GetHashCode</code> , cela est g√©n√©ralement difficile. <br><br>  Une fonction de hachage traditionnelle de type struct "combine" les codes de hachage de tous les champs.  Mais la seule fa√ßon d'obtenir le code de hachage de champ dans la m√©thode <code>ValueType</code> est d'utiliser la r√©flexion.  C'est pourquoi les auteurs du CLR ont d√©cid√© de sacrifier la vitesse √† des fins de distribution, et la version standard de <code>GetHashCode</code> ne renvoie que le code de hachage du premier champ non nul et le <a href="">¬´g√¢te¬ª avec un identifiant de type</a> (***) (pour plus de d√©tails, voir <code>RegularGetValueTypeHashCode</code> dans le repo de coreclr sur github). <br><br>  <i>(***) √Ä en juger par les commentaires dans le r√©f√©rentiel CoreCLR, la situation pourrait changer √† l'avenir.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Location { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Path { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Location</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position</span></span></span><span class="hljs-function">)</span></span> =&gt; (Path, Position) = (path, position); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(path: <span class="hljs-string"><span class="hljs-string">""</span></span>, position: <span class="hljs-number"><span class="hljs-number">42</span></span>).GetHashCode(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(path: <span class="hljs-string"><span class="hljs-string">""</span></span>, position: <span class="hljs-number"><span class="hljs-number">1</span></span>).GetHashCode(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(path: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, position: <span class="hljs-number"><span class="hljs-number">42</span></span>).GetHashCode(); <span class="hljs-comment"><span class="hljs-comment">// hash1 and hash2 are the same and hash1 is different from hash3</span></span></code> </pre> <br>  Il s'agit d'un algorithme raisonnable jusqu'√† ce que quelque chose se passe mal.  Mais si vous n'avez pas de chance et que la valeur du premier champ de votre type de structure est la m√™me dans la plupart des cas, la fonction de hachage produira toujours le m√™me r√©sultat.  Comme vous l'avez peut-√™tre devin√©, si vous enregistrez ces instances dans un ensemble de hachage ou une table de hachage, les performances chuteront. <br><br>  3. La vitesse de mise en ≈ìuvre bas√©e sur la r√©flexion est faible.  Tr√®s faible.  La r√©flexion est un outil puissant s'il est utilis√© correctement.  Mais les cons√©quences seront terribles si vous l'ex√©cutez sur un morceau de code gourmand en ressources. <br><br>  Voyons comment une fonction de hachage d√©faillante, qui peut r√©sulter de (2) et d'une impl√©mentation bas√©e sur la r√©flexion, affecte les performances: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Location1 { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Path { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Location1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position</span></span></span><span class="hljs-function">)</span></span> =&gt; (Path, Position) = (path, position); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Location2 { <span class="hljs-comment"><span class="hljs-comment">// The order matters! // The default GetHashCode version will get a hashcode of the first field public int Position { get; } public string Path { get; } public Location2(string path, int position) =&gt; (Path, Position) = (path, position); } public readonly struct Location3 : IEquatable&lt;Location3&gt; { public string Path { get; } public int Position { get; } public Location3(string path, int position) =&gt; (Path, Position) = (path, position); public override int GetHashCode() =&gt; (Path, Position).GetHashCode(); public override bool Equals(object other) =&gt; other is Location3 l &amp;&amp; Equals(l); public bool Equals(Location3 other) =&gt; Path == other.Path &amp;&amp; Position == other.Position; } private HashSet&lt;Location1&gt; _locations1; private HashSet&lt;Location2&gt; _locations2; private HashSet&lt;Location3&gt; _locations3; [Params(1, 10, 1000)] public int NumberOfElements { get; set; } [GlobalSetup] public void Init() { _locations1 = new HashSet&lt;Location1&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location1("", n))); _locations2 = new HashSet&lt;Location2&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location2("", n))); _locations3 = new HashSet&lt;Location3&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location3("", n))); _locations4 = new HashSet&lt;Location4&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location4("", n))); } [Benchmark] public bool Path_Position_DefaultEquality() { var first = new Location1("", 0); return _locations1.Contains(first); } [Benchmark] public bool Position_Path_DefaultEquality() { var first = new Location2("", 0); return _locations2.Contains(first); } [Benchmark] public bool Path_Position_OverridenEquality() { var first = new Location3("", 0); return _locations3.Contains(first); }</span></span></code> </pre> <br><br><pre> <code class="cs hljs"> Method | NumOfElements | Mean | Gen <span class="hljs-number"><span class="hljs-number">0</span></span> | Allocated | -------------------------------- |------ |--------------:|--------:|----------:| Path_Position_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1</span></span> | <span class="hljs-number"><span class="hljs-number">885.63</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0286</span></span> | <span class="hljs-number"><span class="hljs-number">92</span></span> B | Position_Path_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1</span></span> | <span class="hljs-number"><span class="hljs-number">127.80</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0050</span></span> | <span class="hljs-number"><span class="hljs-number">16</span></span> B | Path_Position_OverridenEquality | <span class="hljs-number"><span class="hljs-number">1</span></span> | <span class="hljs-number"><span class="hljs-number">47.99</span></span> ns | - | <span class="hljs-number"><span class="hljs-number">0</span></span> B | Path_Position_DefaultEquality | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">214.02</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.2441</span></span> | <span class="hljs-number"><span class="hljs-number">776</span></span> B | Position_Path_DefaultEquality | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">130.04</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0050</span></span> | <span class="hljs-number"><span class="hljs-number">16</span></span> B | Path_Position_OverridenEquality | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">47.67</span></span> ns | - | <span class="hljs-number"><span class="hljs-number">0</span></span> B | Path_Position_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1000</span></span> | <span class="hljs-number"><span class="hljs-number">589</span></span>,<span class="hljs-number"><span class="hljs-number">014.52</span></span> ns | <span class="hljs-number"><span class="hljs-number">23.4375</span></span> | <span class="hljs-number"><span class="hljs-number">76025</span></span> B | Position_Path_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1000</span></span> | <span class="hljs-number"><span class="hljs-number">133.74</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0050</span></span> | <span class="hljs-number"><span class="hljs-number">16</span></span> B | Path_Position_OverridenEquality | <span class="hljs-number"><span class="hljs-number">1000</span></span> | <span class="hljs-number"><span class="hljs-number">48.51</span></span> ns | - | <span class="hljs-number"><span class="hljs-number">0</span></span> B |</code> </pre> <br>  Si la valeur du premier champ est toujours la m√™me, la fonction de hachage renvoie par d√©faut une valeur √©gale pour tous les √©l√©ments et l'ensemble de hachage est effectivement converti en une liste li√©e avec des op√©rations d'insertion et de recherche O (N).  Le nombre d'op√©rations pour remplir la collection devient O (N ^ 2) (o√π N est le nombre d'inserts de complexit√© O (N) pour chaque insert).  Cela signifie que l'insertion dans un ensemble de 1 000 √©l√©ments g√©n√©rera pr√®s de 500 000 appels √† <code>ValueType.Equals</code> .  Voici les cons√©quences d'une m√©thode utilisant la r√©flexion! <br><br>  Comme le montre le test, les performances seront acceptables si vous √™tes chanceux et que le premier √©l√©ment de la structure est unique (dans le cas de <code>Position_Path_DefaultEquality</code> ).  Mais si ce n'est pas le cas, la productivit√© sera extr√™mement faible. <br><br><h2>  Vrai probl√®me </h2><br>  Je pense que vous pouvez maintenant deviner quel probl√®me j'ai rencontr√© r√©cemment.  Il y a quelques semaines, j'ai re√ßu un message d'erreur: le temps d'ex√©cution de l'application sur laquelle je travaille est pass√© de 10 √† 60 secondes.  Heureusement, le rapport √©tait tr√®s d√©taill√© et contenait une trace des √©v√©nements Windows, donc le probl√®me a √©t√© d√©couvert rapidement - <code>ValueType.Equals</code> charg√© 50 secondes. <br><br>  Apr√®s un rapide coup d'≈ìil au code, il est devenu clair quel √©tait le probl√®me: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HashSet&lt;(ErrorLocation, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)&gt; _locationsWithHitCount; <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ErrorLocation { <span class="hljs-comment"><span class="hljs-comment">// Empty almost all the time public string OptionalDescription { get; } public string Path { get; } public int Position { get; } }</span></span></code> </pre> <br>  J'ai utilis√© un tuple qui contenait un type de structure personnalis√© avec la version standard d' <code>Equals</code> .  Et malheureusement, il avait un premier champ facultatif, qui √©galait presque toujours <code>String.equals</code> .  La productivit√© est rest√©e √©lev√©e jusqu'√† ce que le nombre d'√©l√©ments de l'ensemble augmente de mani√®re significative.  En quelques minutes, une collection de dizaines de milliers d'√©l√©ments a √©t√© initialis√©e. <br><br><h2>  L'impl√©mentation <code>ValueType.Equals/GetHashCode</code> par d√©faut s'ex√©cute-t-elle toujours lentement? </h2><br>  <code>ValueType.Equals</code> et <code>ValueType.GetHashCode</code> ont des m√©thodes d'optimisation sp√©ciales.  Si le type n'a pas de ¬´pointeurs¬ª et qu'il est correctement compress√© (je vais montrer un exemple dans une minute), alors des versions optimis√©es sont utilis√©es: les it√©rations <code>GetHashCode</code> sont effectu√©es sur des blocs d'instance, XOR de 4 octets est utilis√©, la m√©thode <code>Equals</code> compare deux instances √† l'aide de <code>memcmp</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Optimized ValueType.GetHashCode implementation static INT32 FastGetValueTypeHashCodeHelper(MethodTable *mt, void *pObjRef) { INT32 hashCode = 0; INT32 *pObj = (INT32*)pObjRef; // this is a struct with no refs and no "strange" offsets, just go through the obj and xor the bits INT32 size = mt-&gt;GetNumInstanceFieldBytes(); for (INT32 i = 0; i &lt; (INT32)(size / sizeof(INT32)); i++) hashCode ^= *pObj++; return hashCode; } // Optimized ValueType.Equals implementation FCIMPL2(FC_BOOL_RET, ValueTypeHelper::FastEqualsCheck, Object* obj1, Object* obj2) { TypeHandle pTh = obj1-&gt;GetTypeHandle(); FC_RETURN_BOOL(memcmp(obj1-&gt;GetData(), obj2-&gt;GetData(), pTh.GetSize()) == 0); }</span></span></code> </pre> <br>  La v√©rification elle-m√™me est effectu√©e dans <code>ValueTypeHelper::CanCompareBits</code> , elle est appel√©e √† la fois √† partir de l'it√©ration de <code>ValueType.Equals</code> et √† partir de l'it√©ration de <code>ValueType.GetHashCode</code> . <br><br>  Mais l'optimisation est une chose tr√®s insidieuse. <br><br>  Premi√®rement, il est difficile de comprendre quand il est allum√©;  m√™me des modifications mineures du code peuvent l'activer et le d√©sactiver: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Case1 { <span class="hljs-comment"><span class="hljs-comment">// Optimization is "on", because the struct is properly "packed" public int X { get; } public byte Y { get; } } public struct Case2 { // Optimization is "off", because struct has a padding between byte and int public byte Y { get; } public int X { get; } }</span></span></code> </pre> <br>  Pour plus d'informations sur la structure de la m√©moire, consultez mon blog, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´√âl√©ments internes d'un objet g√©r√©, partie 4. Structure de champ¬ª</a> . <br><br>  Deuxi√®mement, comparer la m√©moire ne vous donne pas n√©cessairement le bon r√©sultat.  Voici un exemple simple: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> MyDouble { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyDouble</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> =&gt; Value = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d1 = <span class="hljs-number"><span class="hljs-number">-0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d2 = +<span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// True bool b1 = d1.Equals(d2); // False! bool b2 = new MyDouble(d1).Equals(new MyDouble(d2));</span></span></code> </pre> <br>  <code>+0,0</code> et <code>+0,0</code> sont √©gaux, mais ont des repr√©sentations binaires diff√©rentes.  Cela signifie que <code>Double.Equals</code> est vrai et <code>MyDouble.Equals</code> est faux.  Dans la plupart des cas, la diff√©rence n'est pas significative, mais imaginez combien d'heures vous passerez √† r√©soudre le probl√®me caus√© par cette diff√©rence. <br><br><h2>  Comment √©viter un probl√®me similaire? </h2><br>  Pouvez-vous me demander comment cela peut se produire dans une situation r√©elle?  Une fa√ßon √©vidente d'ex√©cuter les m√©thodes <code>Equals</code> et <code>GetHashCode</code> dans les types de structure consiste √† utiliser la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√®gle</a> FxCop <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CA1815</a> .  Mais il y a un probl√®me: c'est une approche trop stricte. <br><br>  Une application pour laquelle les performances sont critiques peut avoir des centaines de types de structures qui ne sont pas n√©cessairement utilis√©s dans les ensembles de hachage ou les dictionnaires.  Par cons√©quent, les d√©veloppeurs d'applications peuvent d√©sactiver la r√®gle, ce qui entra√Ænera des cons√©quences d√©sagr√©ables si le type de structure utilise des fonctions modifi√©es. <br><br>  Une approche plus correcte consiste √† avertir le d√©veloppeur si la structure de type ¬´inappropri√©¬ª avec des valeurs par d√©faut √©gales d'√©l√©ments (d√©finies dans l'application ou une biblioth√®que tierce) est stock√©e dans un ensemble de hachage.  Bien s√ªr, je parle d' <a href="">ErrorProne.NET</a> et de la r√®gle que j'ai ajout√©e l√†-bas d√®s que j'ai rencontr√© ce probl√®me: <br><br><img src="https://habrastorage.org/webt/fx/dp/2u/fxdp2u0isbov-7e2vh0stw70x2m.png"><br><br>  La version ErrorProne.NET n'est pas parfaite et ¬´bl√¢mera¬ª le code correct si un r√©solveur d'√©galit√© personnalis√© est utilis√© dans le constructeur: <br><br><img src="https://habrastorage.org/webt/9b/16/0p/9b160peycjwrjmiblktkuroajk0.png"><br><br>  Mais je pense toujours qu'il vaut la peine d'√™tre averti si une structure avec des √©l√©ments √©gaux par d√©faut n'est pas utilis√©e lors de sa production.  Par exemple, lorsque j'ai v√©rifi√© ma r√®gle, j'ai r√©alis√© que la structure <code>System.Collections.Generic.KeyValuePair &lt;TKey, TValue&gt;</code> d√©finie dans mscorlib ne remplace pas <code>Equals</code> et <code>GetHashCode</code> .  Il est peu probable que quiconque d√©finisse une variable comme <code>HashSet &lt;KeyValuePair&lt;string, int&gt;&gt;</code> aujourd'hui, mais je pense que m√™me BCL peut enfreindre la r√®gle.  Par cons√©quent, il est utile de le d√©couvrir avant qu'il ne soit trop tard. <br><br><h2>  Conclusion </h2><br><ul><li>  L'impl√©mentation de l'√©galit√© par d√©faut pour les types de structure peut avoir de graves cons√©quences pour votre application.  Il s'agit d'un probl√®me r√©el et non th√©orique. </li><li>  Les √©l√©ments d'√©galit√© par d√©faut pour les types de valeur sont bas√©s sur la r√©flexion. </li><li>  La distribution effectu√©e par la version standard de <code>GetHashCode</code> sera tr√®s mauvaise si le premier champ de nombreuses instances a la m√™me valeur. </li><li>  Il existe des versions optimis√©es pour les m√©thodes standard <code>Equals</code> et <code>GetHashCode</code> , mais vous ne devez pas vous fier √† elles, car m√™me une petite modification de code peut les d√©sactiver. </li><li>  Utilisez la r√®gle FxCop pour vous assurer que chaque type de structure remplace les √©l√©ments d'√©galit√©.  Cependant, il est pr√©f√©rable d'√©viter le probl√®me avec l'analyseur si la structure ¬´inappropri√©e¬ª est stock√©e dans un ensemble de hachage ou dans une table de hachage. </li></ul><br><h2>  Ressources suppl√©mentaires </h2><br><ul><li>  <a href="">ErrorProne.NET sur github</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Structures ErrorProne.NET dans le magasin</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr418515/">https://habr.com/ru/post/fr418515/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr418503/index.html">Apr√®s 2020, le Royaume-Uni acquerra le premier port spatial - en √âcosse</a></li>
<li><a href="../fr418505/index.html">Pr√©sentation et comparaison des plates-formes logicielles Quantum au niveau de la porte</a></li>
<li><a href="../fr418507/index.html">Qu'est-ce que la cosmonautique nous a apport√©?</a></li>
<li><a href="../fr418509/index.html">Amazon Rekognition reconna√Æt 28 membres du Congr√®s am√©ricain comme des criminels</a></li>
<li><a href="../fr418513/index.html">Comment √©crire uniquement du bon code</a></li>
<li><a href="../fr418517/index.html">Couverture du code: comment am√©liorer la qualit√© des tests</a></li>
<li><a href="../fr418519/index.html">Que trouve-t-on dans le code de quelqu'un d'autre? Une s√©lection de mat√©riaux utiles pour .NET</a></li>
<li><a href="../fr418521/index.html">Le voile du secret sur le lancement depuis l'Alaska</a></li>
<li><a href="../fr418523/index.html">Pourquoi les d√©taillants ¬´√©coutent¬ª leurs employ√©s et pourquoi utilisent-ils toujours la technologie audio</a></li>
<li><a href="../fr418525/index.html">Opera est devenu public</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>