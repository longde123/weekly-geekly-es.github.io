<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📳 🏳️‍🌈 🧑🏽‍🤝‍🧑🏼 Remplacer Equals et GetHashCode. Mais est-ce nécessaire? 👨🏾‍🎓 😇 👨‍👨‍👧‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Si vous connaissez C #, vous savez très probablement que vous devez toujours remplacer Equals , ainsi que GetHashCode , pour éviter une GetHashCode pe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Remplacer Equals et GetHashCode. Mais est-ce nécessaire?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/418515/"> Si vous connaissez C #, vous savez très probablement que vous devez toujours remplacer <code>Equals</code> , ainsi que <code>GetHashCode</code> , pour éviter une <code>GetHashCode</code> performances.  Mais que se passera-t-il si cela n'est pas fait?  Aujourd'hui, nous comparons les performances avec deux options de réglage et envisageons des outils pour éviter les erreurs. <br><br><img src="https://habrastorage.org/webt/w9/iq/7g/w9iq7gen1fjdvh3j6jcxai470ec.jpeg"><a name="habracut"></a><br><br><h2>  Quelle est la gravité de ce problème? </h2><br>  Tous les problèmes de performances potentiels n'affectent pas l'exécution des applications.  La méthode <code>Enum.HasFlag</code> pas très efficace (*), mais si vous ne l'utilisez pas sur un morceau de code gourmand en ressources, il n'y aura pas de problèmes graves dans le projet.  C'est également le cas avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les copies protégées</a> créées par des types de structure non en lecture seule dans le contexte en lecture seule.  Le problème existe, mais il est peu probable qu'il soit perceptible dans les applications ordinaires. <br><br>  <i>(*) Corrigé dans .NET Core 2.1, et, comme je l'ai mentionné <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans une publication précédente</a> , maintenant les conséquences peuvent être atténuées en utilisant le HasFlag auto-configuré pour les anciennes versions.</i> <br><br>  Mais le problème dont nous allons parler aujourd'hui est particulier.  Si les méthodes <code>Equals</code> et <code>GetHashCode</code> ne sont pas créées dans la structure, leurs versions standard de <code>System.ValueType</code> .  Et ils peuvent réduire considérablement les performances de l'application finale. <br><br><h2>  Pourquoi les versions standard sont-elles lentes? </h2><br>  Les auteurs du CLR ont fait de leur mieux pour rendre les versions standard d'Equals et GetHashCode aussi efficaces que possible pour les types de valeur.  Mais il y a plusieurs raisons pour lesquelles ces méthodes perdent en efficacité de la version utilisateur, écrite pour un certain type manuellement (ou générée par le compilateur). <br><br>  1. Distribution de la conversion des emballages.  Le CLR est conçu de telle manière que chaque appel à un élément défini dans les types <code>System.ValueType</code> ou <code>System.Enum</code> déclenche une transformation d'habillage (**). <br><br>  <i>(**) Si la méthode ne prend pas en charge la compilation JIT.</i>  <i>Par exemple, dans Core CLR 2.1, le compilateur JIT reconnaît la méthode <code>Enum.HasFlag</code> et génère un code approprié qui ne démarre pas le wrapping.</i> <br><br>  2. Conflits potentiels dans la version standard de la méthode <code>GetHashCode</code> .  Lors de la mise en œuvre d'une fonction de hachage, nous sommes confrontés à un dilemme: rendre la distribution de la fonction de hachage bonne ou rapide.  Dans certains cas, vous pouvez faire les deux, mais dans le type <code>ValueType.GetHashCode</code> , cela est généralement difficile. <br><br>  Une fonction de hachage traditionnelle de type struct "combine" les codes de hachage de tous les champs.  Mais la seule façon d'obtenir le code de hachage de champ dans la méthode <code>ValueType</code> est d'utiliser la réflexion.  C'est pourquoi les auteurs du CLR ont décidé de sacrifier la vitesse à des fins de distribution, et la version standard de <code>GetHashCode</code> ne renvoie que le code de hachage du premier champ non nul et le <a href="">«gâte» avec un identifiant de type</a> (***) (pour plus de détails, voir <code>RegularGetValueTypeHashCode</code> dans le repo de coreclr sur github). <br><br>  <i>(***) À en juger par les commentaires dans le référentiel CoreCLR, la situation pourrait changer à l'avenir.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Location { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Path { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Location</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position</span></span></span><span class="hljs-function">)</span></span> =&gt; (Path, Position) = (path, position); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(path: <span class="hljs-string"><span class="hljs-string">""</span></span>, position: <span class="hljs-number"><span class="hljs-number">42</span></span>).GetHashCode(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(path: <span class="hljs-string"><span class="hljs-string">""</span></span>, position: <span class="hljs-number"><span class="hljs-number">1</span></span>).GetHashCode(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(path: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, position: <span class="hljs-number"><span class="hljs-number">42</span></span>).GetHashCode(); <span class="hljs-comment"><span class="hljs-comment">// hash1 and hash2 are the same and hash1 is different from hash3</span></span></code> </pre> <br>  Il s'agit d'un algorithme raisonnable jusqu'à ce que quelque chose se passe mal.  Mais si vous n'avez pas de chance et que la valeur du premier champ de votre type de structure est la même dans la plupart des cas, la fonction de hachage produira toujours le même résultat.  Comme vous l'avez peut-être deviné, si vous enregistrez ces instances dans un ensemble de hachage ou une table de hachage, les performances chuteront. <br><br>  3. La vitesse de mise en œuvre basée sur la réflexion est faible.  Très faible.  La réflexion est un outil puissant s'il est utilisé correctement.  Mais les conséquences seront terribles si vous l'exécutez sur un morceau de code gourmand en ressources. <br><br>  Voyons comment une fonction de hachage défaillante, qui peut résulter de (2) et d'une implémentation basée sur la réflexion, affecte les performances: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Location1 { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Path { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Location1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position</span></span></span><span class="hljs-function">)</span></span> =&gt; (Path, Position) = (path, position); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Location2 { <span class="hljs-comment"><span class="hljs-comment">// The order matters! // The default GetHashCode version will get a hashcode of the first field public int Position { get; } public string Path { get; } public Location2(string path, int position) =&gt; (Path, Position) = (path, position); } public readonly struct Location3 : IEquatable&lt;Location3&gt; { public string Path { get; } public int Position { get; } public Location3(string path, int position) =&gt; (Path, Position) = (path, position); public override int GetHashCode() =&gt; (Path, Position).GetHashCode(); public override bool Equals(object other) =&gt; other is Location3 l &amp;&amp; Equals(l); public bool Equals(Location3 other) =&gt; Path == other.Path &amp;&amp; Position == other.Position; } private HashSet&lt;Location1&gt; _locations1; private HashSet&lt;Location2&gt; _locations2; private HashSet&lt;Location3&gt; _locations3; [Params(1, 10, 1000)] public int NumberOfElements { get; set; } [GlobalSetup] public void Init() { _locations1 = new HashSet&lt;Location1&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location1("", n))); _locations2 = new HashSet&lt;Location2&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location2("", n))); _locations3 = new HashSet&lt;Location3&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location3("", n))); _locations4 = new HashSet&lt;Location4&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location4("", n))); } [Benchmark] public bool Path_Position_DefaultEquality() { var first = new Location1("", 0); return _locations1.Contains(first); } [Benchmark] public bool Position_Path_DefaultEquality() { var first = new Location2("", 0); return _locations2.Contains(first); } [Benchmark] public bool Path_Position_OverridenEquality() { var first = new Location3("", 0); return _locations3.Contains(first); }</span></span></code> </pre> <br><br><pre> <code class="cs hljs"> Method | NumOfElements | Mean | Gen <span class="hljs-number"><span class="hljs-number">0</span></span> | Allocated | -------------------------------- |------ |--------------:|--------:|----------:| Path_Position_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1</span></span> | <span class="hljs-number"><span class="hljs-number">885.63</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0286</span></span> | <span class="hljs-number"><span class="hljs-number">92</span></span> B | Position_Path_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1</span></span> | <span class="hljs-number"><span class="hljs-number">127.80</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0050</span></span> | <span class="hljs-number"><span class="hljs-number">16</span></span> B | Path_Position_OverridenEquality | <span class="hljs-number"><span class="hljs-number">1</span></span> | <span class="hljs-number"><span class="hljs-number">47.99</span></span> ns | - | <span class="hljs-number"><span class="hljs-number">0</span></span> B | Path_Position_DefaultEquality | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">214.02</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.2441</span></span> | <span class="hljs-number"><span class="hljs-number">776</span></span> B | Position_Path_DefaultEquality | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">130.04</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0050</span></span> | <span class="hljs-number"><span class="hljs-number">16</span></span> B | Path_Position_OverridenEquality | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">47.67</span></span> ns | - | <span class="hljs-number"><span class="hljs-number">0</span></span> B | Path_Position_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1000</span></span> | <span class="hljs-number"><span class="hljs-number">589</span></span>,<span class="hljs-number"><span class="hljs-number">014.52</span></span> ns | <span class="hljs-number"><span class="hljs-number">23.4375</span></span> | <span class="hljs-number"><span class="hljs-number">76025</span></span> B | Position_Path_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1000</span></span> | <span class="hljs-number"><span class="hljs-number">133.74</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0050</span></span> | <span class="hljs-number"><span class="hljs-number">16</span></span> B | Path_Position_OverridenEquality | <span class="hljs-number"><span class="hljs-number">1000</span></span> | <span class="hljs-number"><span class="hljs-number">48.51</span></span> ns | - | <span class="hljs-number"><span class="hljs-number">0</span></span> B |</code> </pre> <br>  Si la valeur du premier champ est toujours la même, la fonction de hachage renvoie par défaut une valeur égale pour tous les éléments et l'ensemble de hachage est effectivement converti en une liste liée avec des opérations d'insertion et de recherche O (N).  Le nombre d'opérations pour remplir la collection devient O (N ^ 2) (où N est le nombre d'inserts de complexité O (N) pour chaque insert).  Cela signifie que l'insertion dans un ensemble de 1 000 éléments générera près de 500 000 appels à <code>ValueType.Equals</code> .  Voici les conséquences d'une méthode utilisant la réflexion! <br><br>  Comme le montre le test, les performances seront acceptables si vous êtes chanceux et que le premier élément de la structure est unique (dans le cas de <code>Position_Path_DefaultEquality</code> ).  Mais si ce n'est pas le cas, la productivité sera extrêmement faible. <br><br><h2>  Vrai problème </h2><br>  Je pense que vous pouvez maintenant deviner quel problème j'ai rencontré récemment.  Il y a quelques semaines, j'ai reçu un message d'erreur: le temps d'exécution de l'application sur laquelle je travaille est passé de 10 à 60 secondes.  Heureusement, le rapport était très détaillé et contenait une trace des événements Windows, donc le problème a été découvert rapidement - <code>ValueType.Equals</code> chargé 50 secondes. <br><br>  Après un rapide coup d'œil au code, il est devenu clair quel était le problème: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HashSet&lt;(ErrorLocation, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)&gt; _locationsWithHitCount; <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ErrorLocation { <span class="hljs-comment"><span class="hljs-comment">// Empty almost all the time public string OptionalDescription { get; } public string Path { get; } public int Position { get; } }</span></span></code> </pre> <br>  J'ai utilisé un tuple qui contenait un type de structure personnalisé avec la version standard d' <code>Equals</code> .  Et malheureusement, il avait un premier champ facultatif, qui égalait presque toujours <code>String.equals</code> .  La productivité est restée élevée jusqu'à ce que le nombre d'éléments de l'ensemble augmente de manière significative.  En quelques minutes, une collection de dizaines de milliers d'éléments a été initialisée. <br><br><h2>  L'implémentation <code>ValueType.Equals/GetHashCode</code> par défaut s'exécute-t-elle toujours lentement? </h2><br>  <code>ValueType.Equals</code> et <code>ValueType.GetHashCode</code> ont des méthodes d'optimisation spéciales.  Si le type n'a pas de «pointeurs» et qu'il est correctement compressé (je vais montrer un exemple dans une minute), alors des versions optimisées sont utilisées: les itérations <code>GetHashCode</code> sont effectuées sur des blocs d'instance, XOR de 4 octets est utilisé, la méthode <code>Equals</code> compare deux instances à l'aide de <code>memcmp</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Optimized ValueType.GetHashCode implementation static INT32 FastGetValueTypeHashCodeHelper(MethodTable *mt, void *pObjRef) { INT32 hashCode = 0; INT32 *pObj = (INT32*)pObjRef; // this is a struct with no refs and no "strange" offsets, just go through the obj and xor the bits INT32 size = mt-&gt;GetNumInstanceFieldBytes(); for (INT32 i = 0; i &lt; (INT32)(size / sizeof(INT32)); i++) hashCode ^= *pObj++; return hashCode; } // Optimized ValueType.Equals implementation FCIMPL2(FC_BOOL_RET, ValueTypeHelper::FastEqualsCheck, Object* obj1, Object* obj2) { TypeHandle pTh = obj1-&gt;GetTypeHandle(); FC_RETURN_BOOL(memcmp(obj1-&gt;GetData(), obj2-&gt;GetData(), pTh.GetSize()) == 0); }</span></span></code> </pre> <br>  La vérification elle-même est effectuée dans <code>ValueTypeHelper::CanCompareBits</code> , elle est appelée à la fois à partir de l'itération de <code>ValueType.Equals</code> et à partir de l'itération de <code>ValueType.GetHashCode</code> . <br><br>  Mais l'optimisation est une chose très insidieuse. <br><br>  Premièrement, il est difficile de comprendre quand il est allumé;  même des modifications mineures du code peuvent l'activer et le désactiver: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Case1 { <span class="hljs-comment"><span class="hljs-comment">// Optimization is "on", because the struct is properly "packed" public int X { get; } public byte Y { get; } } public struct Case2 { // Optimization is "off", because struct has a padding between byte and int public byte Y { get; } public int X { get; } }</span></span></code> </pre> <br>  Pour plus d'informations sur la structure de la mémoire, consultez mon blog, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Éléments internes d'un objet géré, partie 4. Structure de champ»</a> . <br><br>  Deuxièmement, comparer la mémoire ne vous donne pas nécessairement le bon résultat.  Voici un exemple simple: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> MyDouble { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyDouble</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> =&gt; Value = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d1 = <span class="hljs-number"><span class="hljs-number">-0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d2 = +<span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// True bool b1 = d1.Equals(d2); // False! bool b2 = new MyDouble(d1).Equals(new MyDouble(d2));</span></span></code> </pre> <br>  <code>+0,0</code> et <code>+0,0</code> sont égaux, mais ont des représentations binaires différentes.  Cela signifie que <code>Double.Equals</code> est vrai et <code>MyDouble.Equals</code> est faux.  Dans la plupart des cas, la différence n'est pas significative, mais imaginez combien d'heures vous passerez à résoudre le problème causé par cette différence. <br><br><h2>  Comment éviter un problème similaire? </h2><br>  Pouvez-vous me demander comment cela peut se produire dans une situation réelle?  Une façon évidente d'exécuter les méthodes <code>Equals</code> et <code>GetHashCode</code> dans les types de structure consiste à utiliser la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">règle</a> FxCop <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CA1815</a> .  Mais il y a un problème: c'est une approche trop stricte. <br><br>  Une application pour laquelle les performances sont critiques peut avoir des centaines de types de structures qui ne sont pas nécessairement utilisés dans les ensembles de hachage ou les dictionnaires.  Par conséquent, les développeurs d'applications peuvent désactiver la règle, ce qui entraînera des conséquences désagréables si le type de structure utilise des fonctions modifiées. <br><br>  Une approche plus correcte consiste à avertir le développeur si la structure de type «inapproprié» avec des valeurs par défaut égales d'éléments (définies dans l'application ou une bibliothèque tierce) est stockée dans un ensemble de hachage.  Bien sûr, je parle d' <a href="">ErrorProne.NET</a> et de la règle que j'ai ajoutée là-bas dès que j'ai rencontré ce problème: <br><br><img src="https://habrastorage.org/webt/fx/dp/2u/fxdp2u0isbov-7e2vh0stw70x2m.png"><br><br>  La version ErrorProne.NET n'est pas parfaite et «blâmera» le code correct si un résolveur d'égalité personnalisé est utilisé dans le constructeur: <br><br><img src="https://habrastorage.org/webt/9b/16/0p/9b160peycjwrjmiblktkuroajk0.png"><br><br>  Mais je pense toujours qu'il vaut la peine d'être averti si une structure avec des éléments égaux par défaut n'est pas utilisée lors de sa production.  Par exemple, lorsque j'ai vérifié ma règle, j'ai réalisé que la structure <code>System.Collections.Generic.KeyValuePair &lt;TKey, TValue&gt;</code> définie dans mscorlib ne remplace pas <code>Equals</code> et <code>GetHashCode</code> .  Il est peu probable que quiconque définisse une variable comme <code>HashSet &lt;KeyValuePair&lt;string, int&gt;&gt;</code> aujourd'hui, mais je pense que même BCL peut enfreindre la règle.  Par conséquent, il est utile de le découvrir avant qu'il ne soit trop tard. <br><br><h2>  Conclusion </h2><br><ul><li>  L'implémentation de l'égalité par défaut pour les types de structure peut avoir de graves conséquences pour votre application.  Il s'agit d'un problème réel et non théorique. </li><li>  Les éléments d'égalité par défaut pour les types de valeur sont basés sur la réflexion. </li><li>  La distribution effectuée par la version standard de <code>GetHashCode</code> sera très mauvaise si le premier champ de nombreuses instances a la même valeur. </li><li>  Il existe des versions optimisées pour les méthodes standard <code>Equals</code> et <code>GetHashCode</code> , mais vous ne devez pas vous fier à elles, car même une petite modification de code peut les désactiver. </li><li>  Utilisez la règle FxCop pour vous assurer que chaque type de structure remplace les éléments d'égalité.  Cependant, il est préférable d'éviter le problème avec l'analyseur si la structure «inappropriée» est stockée dans un ensemble de hachage ou dans une table de hachage. </li></ul><br><h2>  Ressources supplémentaires </h2><br><ul><li>  <a href="">ErrorProne.NET sur github</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Structures ErrorProne.NET dans le magasin</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr418515/">https://habr.com/ru/post/fr418515/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr418503/index.html">Après 2020, le Royaume-Uni acquerra le premier port spatial - en Écosse</a></li>
<li><a href="../fr418505/index.html">Présentation et comparaison des plates-formes logicielles Quantum au niveau de la porte</a></li>
<li><a href="../fr418507/index.html">Qu'est-ce que la cosmonautique nous a apporté?</a></li>
<li><a href="../fr418509/index.html">Amazon Rekognition reconnaît 28 membres du Congrès américain comme des criminels</a></li>
<li><a href="../fr418513/index.html">Comment écrire uniquement du bon code</a></li>
<li><a href="../fr418517/index.html">Couverture du code: comment améliorer la qualité des tests</a></li>
<li><a href="../fr418519/index.html">Que trouve-t-on dans le code de quelqu'un d'autre? Une sélection de matériaux utiles pour .NET</a></li>
<li><a href="../fr418521/index.html">Le voile du secret sur le lancement depuis l'Alaska</a></li>
<li><a href="../fr418523/index.html">Pourquoi les détaillants «écoutent» leurs employés et pourquoi utilisent-ils toujours la technologie audio</a></li>
<li><a href="../fr418525/index.html">Opera est devenu public</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>