<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî≠ üë©üèæ‚Äç‚öïÔ∏è üåò Primeros pasos STM32: ¬øQu√© son los registros? ¬øC√≥mo trabajar con ellos? üèûÔ∏è üî± ü§πüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Consideraci√≥n continua de cuestiones b√°sicas 
 En la lecci√≥n anterior, examinamos el trabajo con operaciones de bits y n√∫meros binarios, sentando as√≠ ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Primeros pasos STM32: ¬øQu√© son los registros? ¬øC√≥mo trabajar con ellos?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/407083/"><h3>  Consideraci√≥n continua de cuestiones b√°sicas </h3><br>  En la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lecci√≥n anterior,</a> examinamos el trabajo con operaciones de bits y n√∫meros binarios, sentando as√≠ las bases para considerar un nuevo tema.  En esta lecci√≥n, consideraremos otra pregunta: <b>¬øqu√© son los registros y c√≥mo trabajar con ellos</b> ? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/75/59cf75a313ee4945548871.png"></div><br><a name="habracut"></a><br><br>  Lista de art√≠culos: <br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Comenzar a estudiar STM32 o administrar la luz de forma inteligente</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Procedimientos iniciales STM32: operaciones de bits</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Primeros pasos STM32: ¬øQu√© son los registros?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬øC√≥mo trabajar con ellos?</a> </li></ol><br><br><h3>  Memoria y registros </h3><br>  Una de las habilidades m√°s importantes necesarias cuando se trabaja con microcontroladores es la capacidad de interactuar con los registros.  Vamos a descubrir por nosotros mismos <b>qu√© es</b> ? <br><br>  En general, un registro es un tipo especial de memoria dentro de un microcontrolador que se utiliza para controlar el procesador y los perif√©ricos.  Cada registro en la arquitectura ARM es una celda de memoria y tiene una longitud de 32 bits, donde cada bit se puede representar como un peque√±o interruptor con la ayuda de cu√°l u otro par√°metro del microcontrolador se controla. <br><br>  Cada uno de los registros tiene su propio n√∫mero de serie: direcci√≥n.  La direcci√≥n de registro se indica mediante un n√∫mero de 32 bits representado en notaci√≥n hexadecimal.  Al escribir en la direcci√≥n de registro una cierta combinaci√≥n de unos y ceros, que generalmente se presentan en hexadecimal, se realiza la configuraci√≥n y el control de uno u otro nodo en MK.  Recuerde que en un programa para trabajar con operaciones de bits, podr√≠amos representar un conjunto arbitrario de unos y ceros como un n√∫mero hexadecimal.  En general, vale la pena se√±alar que hay dos tipos de registros: registros de prop√≥sito general y registros especiales.  Los primeros se encuentran dentro del n√∫cleo MK, y los segundos son parte de la memoria RAM. <br><br>  Tambi√©n vale la pena se√±alar que el <b>Manual de referencia</b> , que descargamos en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera lecci√≥n</a> , es un gran directorio de registros contenidos en el microcontrolador de destino, y la biblioteca CMSIS nos permite operar con nombres de registros simb√≥licos en lugar de direcciones num√©ricas.  Por ejemplo, podemos acceder al registro <b>0x40011018</b> simplemente usando el nombre simb√≥lico <b>GPIOC_BSSR</b> .  Consideraremos ejemplos espec√≠ficos de configuraci√≥n durante el an√°lisis de nuestro programa desde la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera lecci√≥n</a> . <br><br>  Entonces, por lo general, la estructura del registro se describe en forma de una peque√±a tabla que indica: <br><br><ol><li>  Registrar nombres y descripciones de su finalidad. </li><li>  Registrar direcciones o compensar desde la direcci√≥n base </li><li>  Valores predeterminados despu√©s de restablecer </li><li>  Tipo de acceso a las celdas de registro (lectura, escritura, lectura / escritura) </li><li>  Valores y descripciones de los par√°metros de los bits grabados. </li></ol><br>  Veamos un ejemplo de trabajo con registros en una situaci√≥n espec√≠fica para tener una idea general de los principios de ajuste del microcontrolador. <br><br><h3>  Analizando el c√≥digo de la primera lecci√≥n </h3><br>  Entonces, recordemos el problema que resolvimos en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera lecci√≥n</a> usando un c√≥digo de ejemplo listo: necesit√°bamos escribir un programa que asegurara la inclusi√≥n alternativa de dos LED en la placa Discovery (tal vez no dos si tienes una versi√≥n diferente de la placa Discovery) con un intervalo de tiempo . <br><br>  Echemos otro vistazo al c√≥digo del programa que utilizamos para hacer que nuestro MK salte con dos patas en las que se encuentran nuestros LED: <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo main.c</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f0xx.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*    */</span></span></span><span class="hljs-meta"> int main(void) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*     GPIO */</span></span></span><span class="hljs-meta"> RCC-&gt;AHBENR |= RCC_AHBENR_GPIOCEN; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*     PC8  PC9  Output*/</span></span></span><span class="hljs-meta"> GPIOC -&gt;MODER = 0x50000; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*  Output type   Push-Pull */</span></span></span><span class="hljs-meta"> GPIOC-&gt;OTYPER = 0; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*      Low */</span></span></span><span class="hljs-meta"> GPIOC-&gt;OSPEEDR = 0; while(1) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   PC8,  PC9 */</span></span></span><span class="hljs-meta"> GPIOC-&gt;ODR = 0x100; for (int i=0; i</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;500000; i++){} //   /*   PC9,  PC8 */ GPIOC-&gt;ODR = 0x200; for (int i=0; i&lt;500000; i++){} //   } }</span></span></span></span></code> </pre> <br></div></div><br>  En primer lugar, cuando se trabaja con STM32, incluso para una tarea tan simple como encender y apagar el LED, primero debemos responder una serie de preguntas: <br><br><ol><li>  ¬øD√≥nde est√°n conectados nuestros LED?  ¬øCu√°l es la conclusi√≥n del microcontrolador? </li><li>  ¬øC√≥mo habilitar la sincronizaci√≥n en el puerto GPIO deseado? </li><li>  ¬øC√≥mo configurar los pines del puerto GPIO que necesitamos para poder encender el LED? </li><li>  ¬øC√≥mo encender y apagar el LED? </li></ol><br>  Les responderemos en orden. <br><br><h3>  ¬øD√≥nde est√°n conectados nuestros LED?  ¬øCu√°l es la conclusi√≥n del microcontrolador? </h3><br>  Para ver d√≥nde est√° ubicado en la placa Discovery, y en particular, los LED que necesitamos, debe abrir el archivo Esquema, ya sea el que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">descargamos del sitio web de ST</a> o directamente de Keil: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/114/10d/8d0/11410d8d0dca40668773bfcf8df359a1.png"></div><br>  Al abrir Schematic, veremos un diagrama de todo lo que est√° en el tablero: un diagrama ST-Link, un enlace de toda la periferia y mucho m√°s.  Por el momento, estamos interesados ‚Äã‚Äãen dos LED, estamos buscando su designaci√≥n: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/d29/1bb/fdf/d291bbfdf0b84397b47bd5e870588205.png"></div><br>  Como podemos ver, nuestros LED est√°n conectados al puerto GPIOC en 8 y 9 pines. <br><br><h3>  ¬øC√≥mo habilitar la sincronizaci√≥n en el puerto GPIO deseado? </h3><br>  En general, cualquier trabajo con perif√©ricos en microcontroladores STM32 se reduce a una secuencia est√°ndar de acciones: <br><br><ol><li>  Habilitaci√≥n del reloj del correspondiente m√≥dulo perif√©rico.  Esto se realiza a trav√©s del registro RCC aplicando una se√±al de reloj directamente desde el bus en el que se encuentra este m√≥dulo.  Por defecto, el reloj de todos los perif√©ricos est√° deshabilitado para minimizar el consumo de energ√≠a. </li><li>  Configuraci√≥n a trav√©s de registros de control, cambiando los par√°metros espec√≠ficos de un dispositivo perif√©rico espec√≠fico </li><li>  Inicio directo y uso de los resultados de operaci√≥n del m√≥dulo </li></ol><br>  Es decir, para comenzar, necesitamos ejecutar el reloj en el puerto GPIOC.  Esto se hace directamente accediendo al registro RCC responsable de marcar todo y todo y encender la se√±al del reloj desde el bus al que est√° conectado nuestro puerto GPIO. <br><br>  <b><i>Atencion</i></b>  <b><i>La pregunta sobre el sistema de reloj, su configuraci√≥n y uso se discutir√° en detalle en un art√≠culo separado.</i></b> <br><br>  Encuentre a qu√© bus est√° conectado nuestro puerto GPIOC en la Hoja de datos de nuestro MK en la secci√≥n Asignaci√≥n de memoria en la Tabla 16. Direcciones de l√≠mite de registro perif√©rico STM32F051xx. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/76e/b23/ba7/76eb23ba707340ec877e6f9184d646cc.png"></div><br>  Como ya not√≥, el autob√∫s que necesitamos se conoce como AHB2.  Para familiarizarse con el registro en el que se activa el marcado al puerto GPIO en el bus AHB que necesitamos, debe ir a la secci√≥n correspondiente en el Manual de referencia.  Por el nombre de los registros, podemos determinar el que necesitamos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/7a/59cf7aad507f5548915177.png"></div><br>  Llegamos a este punto y vemos nuestro registro de 32 bits, su direcci√≥n de desplazamiento, valor predeterminado, la forma de acceder al registro y enumerar de qu√© es responsable cada bit en el registro. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/7a/59cf7add48ab9584741618.png"></div><br>  Observamos la tabla y vemos algo que recuerda la opci√≥n de habilitar la sincronizaci√≥n en los puertos GPIO.  Vaya a la descripci√≥n y encuentre la opci√≥n que necesitamos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/7a/59cf7aeecd38a192347824.png"></div><br>  En consecuencia, si establecemos 19 bits en el valor "1", esto garantizar√° que el reloj est√© habilitado en el puerto I / OC, es decir, en nuestro GPIOC.  Adem√°s, necesitamos habilitar por separado un bit del grupo, sin afectar el resto porque  No debemos interferir o cambiar otras configuraciones innecesariamente. <br><br>  Seg√∫n los materiales de la √∫ltima lecci√≥n, sabemos que para establecer un bit espec√≠fico, debe usar la operaci√≥n l√≥gica "OR" para agregar el valor actual del registro con una m√°scara que contiene esos bits que deben activarse.  Por ejemplo, agreguemos el valor predeterminado del registro RCC-&gt; AHBENR, es decir  0x14 y el n√∫mero 0x80000 habilitan el reloj GPIOC configurando 19 bits: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/a6/59cfa6b0e049a913888413.png"></div><br><br>  ¬øC√≥mo podemos hacer esto desde un programa?  Todo es bastante simple.  En este caso, tenemos dos opciones: <br><br><ol><li>  Escribir directamente en el registro el valor num√©rico del registro directamente a trav√©s de su direcci√≥n. </li><li>  Configuraci√≥n usando la biblioteca CMSIS </li></ol><br>  No hay problemas particulares directamente al escribir un valor en el registro, pero hay un par de inconvenientes importantes.  En primer lugar, dicho c√≥digo se vuelve ilegible y, en segundo lugar, no podemos determinar de inmediato a qu√© registro se refiere esta o aquella direcci√≥n en la memoria. <br><br>  Es decir, podr√≠amos direccionar las direcciones de los registros directamente en la direcci√≥n y escribir esto: <br><br><pre> <code class="cpp hljs">__IO <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> * register_address = (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *) <span class="hljs-number"><span class="hljs-number">0x40021014</span></span>U; <span class="hljs-comment"><span class="hljs-comment">//      *(__IO uint32_t *)register_address |= 0x80000; //  19    </span></span></code> </pre><br>  La segunda opci√≥n me parece la m√°s atractiva, porque  La biblioteca CMSIS est√° organizada de tal manera que se puede acceder al registro utilizando solo su nombre.  Durante el preprocesamiento del texto del programa, el preprocesador sustituir√° autom√°ticamente todos los valores digitales de la direcci√≥n de registro antes de la compilaci√≥n.  Miremos esta pregunta con m√°s detalle. <br><br>  Sugiero abrir nuestro proyecto, lo que hicimos en la primera lecci√≥n, o descargar el previamente preparado <a href="">desde aqu√≠</a> y eliminar todo el contenido del programa, dejando solo el archivo de encabezado conectado, la funci√≥n main () y las instrucciones para activar el reloj (lo necesitaremos para un an√°lisis detallado del c√≥digo). <br><br>  Nuestro c√≥digo se ver√° as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f0xx.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*    */</span></span></span><span class="hljs-meta"> int main(void) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*     GPIO */</span></span></span><span class="hljs-meta"> RCC-&gt;AHBENR|=RCC_AHBENR_GPIOCEN; }</span></span></code> </pre><br>  Profundicemos en la biblioteca CMSIS para familiarizarse. <br><br>  Para ir r√°pidamente al lugar donde se declara esta o aquella constante o variable, se implementa una funci√≥n conveniente en Keil.  Haga clic derecho en la constante que necesitamos, por ejemplo, en RCC: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/7b/59cf7b95d3c96942859803.png"></div><br>  Y somos transportados a las profundidades de la biblioteca CMSIS, en la que veremos que todos los registros disponibles para el control program√°tico tienen la forma de estructuras TypeDef, incluido nuestro RCC: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/80/59cf80e8c73ff245649066.png"></div><br>  Al haber fallado de manera similar en RCC_TypeDef, veremos una estructura en la que se describen todos los campos de nuestro registro: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/7c/59cf7c6846eae845513998.png"></div><br>  En consecuencia, podemos acceder de forma segura al registro que necesitamos con un registro del formulario <b>PERIPH_MODULE-&gt; REGISTER</b> y asignarle un valor espec√≠fico. <br><br>  Adem√°s de la designaci√≥n mnem√≥nica de registros, tambi√©n hay designaciones de bits espec√≠ficos.  Si no declaramos el par√°metro <b>RCC_AHBENR_GPIOCEN</b> de nuestro programa, tambi√©n veremos la declaraci√≥n de todos los par√°metros: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/8d/59cf8dd1d23df635371335.png"></div><br>  Por lo tanto, al usar la biblioteca CMSIS, obtenemos un registro conciso y legible del par√°metro que necesitamos en el registro, a trav√©s de la instalaci√≥n de la cual comenzamos el cronometraje en el puerto que necesitamos: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*     GPIO */</span></span> RCC-&gt;AHBENR|=RCC_AHBENR_GPIOCEN;</code> </pre><br>  <b><i>Como tarea:</i></b> determinar, utilizando las capacidades de Keil, c√≥mo se obtuvo la direcci√≥n del registro RCC-&gt; AHBENR como 0x40021014. <br><br><h3>  ¬øC√≥mo configurar los pines GPIO que necesitamos para que podamos encender el LED? </h3><br>  Entonces, sabemos que los LED que necesitamos est√°n conectados al puerto GPIOC a los pines PC8 y PC9.  Necesitamos configurarlos de tal manera que el LED se ilumine.  Me gustar√≠a hacer una reserva de inmediato para que veamos los puertos GPIO con m√°s detalle en otro art√≠culo y aqu√≠ nos concentraremos espec√≠ficamente en trabajar con registros. <br><br>  En primer lugar, necesitamos poner los pines PC8 y PC9 en modo de Salida.  Se pueden dejar otros par√°metros de puerto por defecto.  Vaya al Manual de referencia en la secci√≥n <b><i>9. E / S de prop√≥sito general (GPIO)</i></b> y abra el elemento responsable del modo de funcionamiento de los pines del puerto GPIO y compruebe que el registro MODER es responsable de este par√°metro: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/b6/59cfb6cddbae1280161305.png"></div><br>  A juzgar por la descripci√≥n, para establecer los pines PC8 y PC9 en modo Salida, debemos escribir 01 en los campos correspondientes del registro GPIOC. <br><br>  Esto se puede hacer a trav√©s de la instalaci√≥n directa utilizando valores num√©ricos: <br><br><ol><li>  Formamos un n√∫mero para escribir: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/b9/59cfb9393c701766083772.png"></div></li><li>  Asignamos este valor a nuestro registro: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*     PC8  PC9  Output*/</span></span> GPIOC-&gt;MODER |= <span class="hljs-number"><span class="hljs-number">0x50000</span></span>;</code> </pre><br></li></ol><br>  O mediante el uso de definiciones de la biblioteca: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*     GPIO */</span></span> GPIOC-&gt;MODER |= GPIO_MODER_MODER8_0 | GPIO_MODER_MODER9_0;</code> </pre><br>  Despu√©s de estas instrucciones, nuestros pines PC8 y PC9 pasar√°n al modo de Salida. <br><br><h3>  ¬øC√≥mo encender el LED? </h3><br>  Si prestamos atenci√≥n a la lista de registros disponibles para controlar el puerto GPIO, podemos ver el registro ODR: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/be/59cfbea6c1617634943312.png"></div><br>  Cada uno de los bits correspondientes es responsable de uno de los pines del puerto.  Puedes ver su estructura a continuaci√≥n: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/bf/59cfbf1d26664276913966.png"></div><br>  Para proporcionar un cambio alternativo de los estados del LED, es necesario activar / desactivar 8 y 9 bits con un cierto intervalo de tiempo.  Es decir, asigne alternativamente el valor 0x100 y 0x200 al registro. <br><br>  Podemos hacer esto asignando directamente valores al registro: <br><br><pre> <code class="cpp hljs">GPIOC-&gt;ODR = <span class="hljs-number"><span class="hljs-number">0x100</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  PC8,  PC9 GPIOC-&gt;ODR = 0x200; //  PC9,  PC8</span></span></code> </pre><br>  A trav√©s del uso de definiciones de la biblioteca podemos: <br><br><pre> <code class="cpp hljs">GPIOC-&gt;ODR = GPIO_ODR_8; <span class="hljs-comment"><span class="hljs-comment">//  PC8,  PC9 GPIOC-&gt;ODR = GPIO_ODR_9; //  PC9,  PC8</span></span></code> </pre><br>  Pero dado que el microcontrolador funciona muy r√°pido, no notaremos el cambio en el estado de los LED y visualmente parecer√° que ambos se iluminan constantemente.  Para que realmente parpadeen alternativamente, introduciremos un retraso artificial en forma de un ciclo que llevar√° a MK a c√°lculos in√∫tiles por un tiempo.  El siguiente c√≥digo resultar√°: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*   PC8,  PC9 */</span></span> GPIOC-&gt;ODR = GPIO_ODR_8; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">500000</span></span>; i++){} <span class="hljs-comment"><span class="hljs-comment">//   /*   PC9,  PC8 */ GPIOC-&gt;ODR = GPIO_ODR_9; for (int i=0; i&lt;500000; i++){} //  </span></span></code> </pre><br>  Con esto, podemos terminar el conocimiento inicial de los registros y los m√©todos para trabajar con ellos. <br><br><h3>  Verificando los resultados de nuestro c√≥digo </h3><br>  Una peque√±a adici√≥n agradable al final del art√≠culo: Keil tiene una excelente herramienta de depuraci√≥n con la que podemos ejecutar nuestro programa paso a paso y ver el estado actual de cualquier bloque perif√©rico.  Para hacer esto, despu√©s de descargar el firmware despu√©s de la compilaci√≥n, podemos hacer clic en el bot√≥n Iniciar sesi√≥n de depuraci√≥n: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/d3/59cfd317272f6379966087.png"></div><br>  El espacio de trabajo de Keil cambiar√° al modo de depuraci√≥n.  Podemos controlar el progreso del programa usando estos botones: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/d3/59cfd38913bf1809956510.png"></div><br>  Y hay otra funci√≥n conveniente para trabajar con perif√©ricos en modo de depuraci√≥n, le permite ver el estado actual de los registros y cambiar su estado con un simple clic del mouse. <br><br>  Para usarlo, debe ir a la unidad perif√©rica correspondiente y se abrir√° una ventana a la derecha con los registros y su valor. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/d3/59cfd3ca68b84248376432.png"></div><br>  Si hace clic en uno de los elementos de este men√∫, ver√° la direcci√≥n del registro y su breve descripci√≥n.  Tambi√©n puede ver la descripci√≥n de cada par√°metro de registro individual: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/d4/59cfd44d011de223116939.png"></div><br>  Intente ejecutar el programa de forma independiente paso a paso, encienda / apague los LED que no usan el programa, sino que usan este modo de operaci√≥n con el microcontrolador.  El alcance de la imaginaci√≥n es enorme.  Tambi√©n intente jugar con la duraci√≥n de los retrasos, realice el parpadeo simult√°neo de ambos LED.  En general, ¬°experimenta!  ) <br><br>  ¬°Nos vemos en los siguientes art√≠culos! <br>  Lista de art√≠culos: <br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Comenzar a estudiar STM32 o administrar la luz de forma inteligente</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Procedimientos iniciales STM32: operaciones de bits</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Primeros pasos STM32: ¬øQu√© son los registros?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬øC√≥mo trabajar con ellos?</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es407083/">https://habr.com/ru/post/es407083/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es407071/index.html">Los trabajadores no deben temer al robococalipsis</a></li>
<li><a href="../es407073/index.html">Preg√∫ntele a Ethan: ¬øes posible la gravedad cero?</a></li>
<li><a href="../es407075/index.html">En Rusia, todas las compras en l√≠nea son m√°s caras que ‚Ç¨ 20</a></li>
<li><a href="../es407079/index.html">¬øC√≥mo equipamos la blockchain?</a></li>
<li><a href="../es407081/index.html">Retrato del fen√≥meno: impulso nost√°lgico: casetes y grabadoras</a></li>
<li><a href="../es407085/index.html">Los cient√≠ficos est√°n librando una guerra contra el envejecimiento. Pero entonces que?</a></li>
<li><a href="../es407087/index.html">Conductores de Tesla y 2.5 millones de toneladas de CO2</a></li>
<li><a href="../es407093/index.html">1 de octubre - D√≠a Internacional de las Personas de Edad</a></li>
<li><a href="../es407095/index.html">Amor loco de inicio</a></li>
<li><a href="../es407097/index.html">Los radioaficionados se quejan de las falsas tiendas en l√≠nea con equipos de radio: tenga cuidado</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>