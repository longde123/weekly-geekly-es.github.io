<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔭 👩🏾‍⚕️ 🌘 Primeros pasos STM32: ¿Qué son los registros? ¿Cómo trabajar con ellos? 🏞️ 🔱 🤹🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Consideración continua de cuestiones básicas 
 En la lección anterior, examinamos el trabajo con operaciones de bits y números binarios, sentando así ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Primeros pasos STM32: ¿Qué son los registros? ¿Cómo trabajar con ellos?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/407083/"><h3>  Consideración continua de cuestiones básicas </h3><br>  En la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lección anterior,</a> examinamos el trabajo con operaciones de bits y números binarios, sentando así las bases para considerar un nuevo tema.  En esta lección, consideraremos otra pregunta: <b>¿qué son los registros y cómo trabajar con ellos</b> ? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/75/59cf75a313ee4945548871.png"></div><br><a name="habracut"></a><br><br>  Lista de artículos: <br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Comenzar a estudiar STM32 o administrar la luz de forma inteligente</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Procedimientos iniciales STM32: operaciones de bits</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Primeros pasos STM32: ¿Qué son los registros?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¿Cómo trabajar con ellos?</a> </li></ol><br><br><h3>  Memoria y registros </h3><br>  Una de las habilidades más importantes necesarias cuando se trabaja con microcontroladores es la capacidad de interactuar con los registros.  Vamos a descubrir por nosotros mismos <b>qué es</b> ? <br><br>  En general, un registro es un tipo especial de memoria dentro de un microcontrolador que se utiliza para controlar el procesador y los periféricos.  Cada registro en la arquitectura ARM es una celda de memoria y tiene una longitud de 32 bits, donde cada bit se puede representar como un pequeño interruptor con la ayuda de cuál u otro parámetro del microcontrolador se controla. <br><br>  Cada uno de los registros tiene su propio número de serie: dirección.  La dirección de registro se indica mediante un número de 32 bits representado en notación hexadecimal.  Al escribir en la dirección de registro una cierta combinación de unos y ceros, que generalmente se presentan en hexadecimal, se realiza la configuración y el control de uno u otro nodo en MK.  Recuerde que en un programa para trabajar con operaciones de bits, podríamos representar un conjunto arbitrario de unos y ceros como un número hexadecimal.  En general, vale la pena señalar que hay dos tipos de registros: registros de propósito general y registros especiales.  Los primeros se encuentran dentro del núcleo MK, y los segundos son parte de la memoria RAM. <br><br>  También vale la pena señalar que el <b>Manual de referencia</b> , que descargamos en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera lección</a> , es un gran directorio de registros contenidos en el microcontrolador de destino, y la biblioteca CMSIS nos permite operar con nombres de registros simbólicos en lugar de direcciones numéricas.  Por ejemplo, podemos acceder al registro <b>0x40011018</b> simplemente usando el nombre simbólico <b>GPIOC_BSSR</b> .  Consideraremos ejemplos específicos de configuración durante el análisis de nuestro programa desde la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera lección</a> . <br><br>  Entonces, por lo general, la estructura del registro se describe en forma de una pequeña tabla que indica: <br><br><ol><li>  Registrar nombres y descripciones de su finalidad. </li><li>  Registrar direcciones o compensar desde la dirección base </li><li>  Valores predeterminados después de restablecer </li><li>  Tipo de acceso a las celdas de registro (lectura, escritura, lectura / escritura) </li><li>  Valores y descripciones de los parámetros de los bits grabados. </li></ol><br>  Veamos un ejemplo de trabajo con registros en una situación específica para tener una idea general de los principios de ajuste del microcontrolador. <br><br><h3>  Analizando el código de la primera lección </h3><br>  Entonces, recordemos el problema que resolvimos en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera lección</a> usando un código de ejemplo listo: necesitábamos escribir un programa que asegurara la inclusión alternativa de dos LED en la placa Discovery (tal vez no dos si tienes una versión diferente de la placa Discovery) con un intervalo de tiempo . <br><br>  Echemos otro vistazo al código del programa que utilizamos para hacer que nuestro MK salte con dos patas en las que se encuentran nuestros LED: <br><br><div class="spoiler">  <b class="spoiler_title">Código main.c</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f0xx.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*    */</span></span></span><span class="hljs-meta"> int main(void) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*     GPIO */</span></span></span><span class="hljs-meta"> RCC-&gt;AHBENR |= RCC_AHBENR_GPIOCEN; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*     PC8  PC9  Output*/</span></span></span><span class="hljs-meta"> GPIOC -&gt;MODER = 0x50000; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*  Output type   Push-Pull */</span></span></span><span class="hljs-meta"> GPIOC-&gt;OTYPER = 0; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*      Low */</span></span></span><span class="hljs-meta"> GPIOC-&gt;OSPEEDR = 0; while(1) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   PC8,  PC9 */</span></span></span><span class="hljs-meta"> GPIOC-&gt;ODR = 0x100; for (int i=0; i</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;500000; i++){} //   /*   PC9,  PC8 */ GPIOC-&gt;ODR = 0x200; for (int i=0; i&lt;500000; i++){} //   } }</span></span></span></span></code> </pre> <br></div></div><br>  En primer lugar, cuando se trabaja con STM32, incluso para una tarea tan simple como encender y apagar el LED, primero debemos responder una serie de preguntas: <br><br><ol><li>  ¿Dónde están conectados nuestros LED?  ¿Cuál es la conclusión del microcontrolador? </li><li>  ¿Cómo habilitar la sincronización en el puerto GPIO deseado? </li><li>  ¿Cómo configurar los pines del puerto GPIO que necesitamos para poder encender el LED? </li><li>  ¿Cómo encender y apagar el LED? </li></ol><br>  Les responderemos en orden. <br><br><h3>  ¿Dónde están conectados nuestros LED?  ¿Cuál es la conclusión del microcontrolador? </h3><br>  Para ver dónde está ubicado en la placa Discovery, y en particular, los LED que necesitamos, debe abrir el archivo Esquema, ya sea el que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">descargamos del sitio web de ST</a> o directamente de Keil: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/114/10d/8d0/11410d8d0dca40668773bfcf8df359a1.png"></div><br>  Al abrir Schematic, veremos un diagrama de todo lo que está en el tablero: un diagrama ST-Link, un enlace de toda la periferia y mucho más.  Por el momento, estamos interesados ​​en dos LED, estamos buscando su designación: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/d29/1bb/fdf/d291bbfdf0b84397b47bd5e870588205.png"></div><br>  Como podemos ver, nuestros LED están conectados al puerto GPIOC en 8 y 9 pines. <br><br><h3>  ¿Cómo habilitar la sincronización en el puerto GPIO deseado? </h3><br>  En general, cualquier trabajo con periféricos en microcontroladores STM32 se reduce a una secuencia estándar de acciones: <br><br><ol><li>  Habilitación del reloj del correspondiente módulo periférico.  Esto se realiza a través del registro RCC aplicando una señal de reloj directamente desde el bus en el que se encuentra este módulo.  Por defecto, el reloj de todos los periféricos está deshabilitado para minimizar el consumo de energía. </li><li>  Configuración a través de registros de control, cambiando los parámetros específicos de un dispositivo periférico específico </li><li>  Inicio directo y uso de los resultados de operación del módulo </li></ol><br>  Es decir, para comenzar, necesitamos ejecutar el reloj en el puerto GPIOC.  Esto se hace directamente accediendo al registro RCC responsable de marcar todo y todo y encender la señal del reloj desde el bus al que está conectado nuestro puerto GPIO. <br><br>  <b><i>Atencion</i></b>  <b><i>La pregunta sobre el sistema de reloj, su configuración y uso se discutirá en detalle en un artículo separado.</i></b> <br><br>  Encuentre a qué bus está conectado nuestro puerto GPIOC en la Hoja de datos de nuestro MK en la sección Asignación de memoria en la Tabla 16. Direcciones de límite de registro periférico STM32F051xx. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/76e/b23/ba7/76eb23ba707340ec877e6f9184d646cc.png"></div><br>  Como ya notó, el autobús que necesitamos se conoce como AHB2.  Para familiarizarse con el registro en el que se activa el marcado al puerto GPIO en el bus AHB que necesitamos, debe ir a la sección correspondiente en el Manual de referencia.  Por el nombre de los registros, podemos determinar el que necesitamos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/7a/59cf7aad507f5548915177.png"></div><br>  Llegamos a este punto y vemos nuestro registro de 32 bits, su dirección de desplazamiento, valor predeterminado, la forma de acceder al registro y enumerar de qué es responsable cada bit en el registro. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/7a/59cf7add48ab9584741618.png"></div><br>  Observamos la tabla y vemos algo que recuerda la opción de habilitar la sincronización en los puertos GPIO.  Vaya a la descripción y encuentre la opción que necesitamos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/7a/59cf7aeecd38a192347824.png"></div><br>  En consecuencia, si establecemos 19 bits en el valor "1", esto garantizará que el reloj esté habilitado en el puerto I / OC, es decir, en nuestro GPIOC.  Además, necesitamos habilitar por separado un bit del grupo, sin afectar el resto porque  No debemos interferir o cambiar otras configuraciones innecesariamente. <br><br>  Según los materiales de la última lección, sabemos que para establecer un bit específico, debe usar la operación lógica "OR" para agregar el valor actual del registro con una máscara que contiene esos bits que deben activarse.  Por ejemplo, agreguemos el valor predeterminado del registro RCC-&gt; AHBENR, es decir  0x14 y el número 0x80000 habilitan el reloj GPIOC configurando 19 bits: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/a6/59cfa6b0e049a913888413.png"></div><br><br>  ¿Cómo podemos hacer esto desde un programa?  Todo es bastante simple.  En este caso, tenemos dos opciones: <br><br><ol><li>  Escribir directamente en el registro el valor numérico del registro directamente a través de su dirección. </li><li>  Configuración usando la biblioteca CMSIS </li></ol><br>  No hay problemas particulares directamente al escribir un valor en el registro, pero hay un par de inconvenientes importantes.  En primer lugar, dicho código se vuelve ilegible y, en segundo lugar, no podemos determinar de inmediato a qué registro se refiere esta o aquella dirección en la memoria. <br><br>  Es decir, podríamos direccionar las direcciones de los registros directamente en la dirección y escribir esto: <br><br><pre> <code class="cpp hljs">__IO <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> * register_address = (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *) <span class="hljs-number"><span class="hljs-number">0x40021014</span></span>U; <span class="hljs-comment"><span class="hljs-comment">//      *(__IO uint32_t *)register_address |= 0x80000; //  19    </span></span></code> </pre><br>  La segunda opción me parece la más atractiva, porque  La biblioteca CMSIS está organizada de tal manera que se puede acceder al registro utilizando solo su nombre.  Durante el preprocesamiento del texto del programa, el preprocesador sustituirá automáticamente todos los valores digitales de la dirección de registro antes de la compilación.  Miremos esta pregunta con más detalle. <br><br>  Sugiero abrir nuestro proyecto, lo que hicimos en la primera lección, o descargar el previamente preparado <a href="">desde aquí</a> y eliminar todo el contenido del programa, dejando solo el archivo de encabezado conectado, la función main () y las instrucciones para activar el reloj (lo necesitaremos para un análisis detallado del código). <br><br>  Nuestro código se verá así: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f0xx.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*    */</span></span></span><span class="hljs-meta"> int main(void) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*     GPIO */</span></span></span><span class="hljs-meta"> RCC-&gt;AHBENR|=RCC_AHBENR_GPIOCEN; }</span></span></code> </pre><br>  Profundicemos en la biblioteca CMSIS para familiarizarse. <br><br>  Para ir rápidamente al lugar donde se declara esta o aquella constante o variable, se implementa una función conveniente en Keil.  Haga clic derecho en la constante que necesitamos, por ejemplo, en RCC: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/7b/59cf7b95d3c96942859803.png"></div><br>  Y somos transportados a las profundidades de la biblioteca CMSIS, en la que veremos que todos los registros disponibles para el control programático tienen la forma de estructuras TypeDef, incluido nuestro RCC: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/80/59cf80e8c73ff245649066.png"></div><br>  Al haber fallado de manera similar en RCC_TypeDef, veremos una estructura en la que se describen todos los campos de nuestro registro: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/7c/59cf7c6846eae845513998.png"></div><br>  En consecuencia, podemos acceder de forma segura al registro que necesitamos con un registro del formulario <b>PERIPH_MODULE-&gt; REGISTER</b> y asignarle un valor específico. <br><br>  Además de la designación mnemónica de registros, también hay designaciones de bits específicos.  Si no declaramos el parámetro <b>RCC_AHBENR_GPIOCEN</b> de nuestro programa, también veremos la declaración de todos los parámetros: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/8d/59cf8dd1d23df635371335.png"></div><br>  Por lo tanto, al usar la biblioteca CMSIS, obtenemos un registro conciso y legible del parámetro que necesitamos en el registro, a través de la instalación de la cual comenzamos el cronometraje en el puerto que necesitamos: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*     GPIO */</span></span> RCC-&gt;AHBENR|=RCC_AHBENR_GPIOCEN;</code> </pre><br>  <b><i>Como tarea:</i></b> determinar, utilizando las capacidades de Keil, cómo se obtuvo la dirección del registro RCC-&gt; AHBENR como 0x40021014. <br><br><h3>  ¿Cómo configurar los pines GPIO que necesitamos para que podamos encender el LED? </h3><br>  Entonces, sabemos que los LED que necesitamos están conectados al puerto GPIOC a los pines PC8 y PC9.  Necesitamos configurarlos de tal manera que el LED se ilumine.  Me gustaría hacer una reserva de inmediato para que veamos los puertos GPIO con más detalle en otro artículo y aquí nos concentraremos específicamente en trabajar con registros. <br><br>  En primer lugar, necesitamos poner los pines PC8 y PC9 en modo de Salida.  Se pueden dejar otros parámetros de puerto por defecto.  Vaya al Manual de referencia en la sección <b><i>9. E / S de propósito general (GPIO)</i></b> y abra el elemento responsable del modo de funcionamiento de los pines del puerto GPIO y compruebe que el registro MODER es responsable de este parámetro: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/b6/59cfb6cddbae1280161305.png"></div><br>  A juzgar por la descripción, para establecer los pines PC8 y PC9 en modo Salida, debemos escribir 01 en los campos correspondientes del registro GPIOC. <br><br>  Esto se puede hacer a través de la instalación directa utilizando valores numéricos: <br><br><ol><li>  Formamos un número para escribir: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/b9/59cfb9393c701766083772.png"></div></li><li>  Asignamos este valor a nuestro registro: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*     PC8  PC9  Output*/</span></span> GPIOC-&gt;MODER |= <span class="hljs-number"><span class="hljs-number">0x50000</span></span>;</code> </pre><br></li></ol><br>  O mediante el uso de definiciones de la biblioteca: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*     GPIO */</span></span> GPIOC-&gt;MODER |= GPIO_MODER_MODER8_0 | GPIO_MODER_MODER9_0;</code> </pre><br>  Después de estas instrucciones, nuestros pines PC8 y PC9 pasarán al modo de Salida. <br><br><h3>  ¿Cómo encender el LED? </h3><br>  Si prestamos atención a la lista de registros disponibles para controlar el puerto GPIO, podemos ver el registro ODR: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/be/59cfbea6c1617634943312.png"></div><br>  Cada uno de los bits correspondientes es responsable de uno de los pines del puerto.  Puedes ver su estructura a continuación: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/bf/59cfbf1d26664276913966.png"></div><br>  Para proporcionar un cambio alternativo de los estados del LED, es necesario activar / desactivar 8 y 9 bits con un cierto intervalo de tiempo.  Es decir, asigne alternativamente el valor 0x100 y 0x200 al registro. <br><br>  Podemos hacer esto asignando directamente valores al registro: <br><br><pre> <code class="cpp hljs">GPIOC-&gt;ODR = <span class="hljs-number"><span class="hljs-number">0x100</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  PC8,  PC9 GPIOC-&gt;ODR = 0x200; //  PC9,  PC8</span></span></code> </pre><br>  A través del uso de definiciones de la biblioteca podemos: <br><br><pre> <code class="cpp hljs">GPIOC-&gt;ODR = GPIO_ODR_8; <span class="hljs-comment"><span class="hljs-comment">//  PC8,  PC9 GPIOC-&gt;ODR = GPIO_ODR_9; //  PC9,  PC8</span></span></code> </pre><br>  Pero dado que el microcontrolador funciona muy rápido, no notaremos el cambio en el estado de los LED y visualmente parecerá que ambos se iluminan constantemente.  Para que realmente parpadeen alternativamente, introduciremos un retraso artificial en forma de un ciclo que llevará a MK a cálculos inútiles por un tiempo.  El siguiente código resultará: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*   PC8,  PC9 */</span></span> GPIOC-&gt;ODR = GPIO_ODR_8; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">500000</span></span>; i++){} <span class="hljs-comment"><span class="hljs-comment">//   /*   PC9,  PC8 */ GPIOC-&gt;ODR = GPIO_ODR_9; for (int i=0; i&lt;500000; i++){} //  </span></span></code> </pre><br>  Con esto, podemos terminar el conocimiento inicial de los registros y los métodos para trabajar con ellos. <br><br><h3>  Verificando los resultados de nuestro código </h3><br>  Una pequeña adición agradable al final del artículo: Keil tiene una excelente herramienta de depuración con la que podemos ejecutar nuestro programa paso a paso y ver el estado actual de cualquier bloque periférico.  Para hacer esto, después de descargar el firmware después de la compilación, podemos hacer clic en el botón Iniciar sesión de depuración: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/d3/59cfd317272f6379966087.png"></div><br>  El espacio de trabajo de Keil cambiará al modo de depuración.  Podemos controlar el progreso del programa usando estos botones: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/d3/59cfd38913bf1809956510.png"></div><br>  Y hay otra función conveniente para trabajar con periféricos en modo de depuración, le permite ver el estado actual de los registros y cambiar su estado con un simple clic del mouse. <br><br>  Para usarlo, debe ir a la unidad periférica correspondiente y se abrirá una ventana a la derecha con los registros y su valor. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/d3/59cfd3ca68b84248376432.png"></div><br>  Si hace clic en uno de los elementos de este menú, verá la dirección del registro y su breve descripción.  También puede ver la descripción de cada parámetro de registro individual: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/cf/d4/59cfd44d011de223116939.png"></div><br>  Intente ejecutar el programa de forma independiente paso a paso, encienda / apague los LED que no usan el programa, sino que usan este modo de operación con el microcontrolador.  El alcance de la imaginación es enorme.  También intente jugar con la duración de los retrasos, realice el parpadeo simultáneo de ambos LED.  En general, ¡experimenta!  ) <br><br>  ¡Nos vemos en los siguientes artículos! <br>  Lista de artículos: <br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Comenzar a estudiar STM32 o administrar la luz de forma inteligente</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Procedimientos iniciales STM32: operaciones de bits</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Primeros pasos STM32: ¿Qué son los registros?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¿Cómo trabajar con ellos?</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es407083/">https://habr.com/ru/post/es407083/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es407071/index.html">Los trabajadores no deben temer al robococalipsis</a></li>
<li><a href="../es407073/index.html">Pregúntele a Ethan: ¿es posible la gravedad cero?</a></li>
<li><a href="../es407075/index.html">En Rusia, todas las compras en línea son más caras que € 20</a></li>
<li><a href="../es407079/index.html">¿Cómo equipamos la blockchain?</a></li>
<li><a href="../es407081/index.html">Retrato del fenómeno: impulso nostálgico: casetes y grabadoras</a></li>
<li><a href="../es407085/index.html">Los científicos están librando una guerra contra el envejecimiento. Pero entonces que?</a></li>
<li><a href="../es407087/index.html">Conductores de Tesla y 2.5 millones de toneladas de CO2</a></li>
<li><a href="../es407093/index.html">1 de octubre - Día Internacional de las Personas de Edad</a></li>
<li><a href="../es407095/index.html">Amor loco de inicio</a></li>
<li><a href="../es407097/index.html">Los radioaficionados se quejan de las falsas tiendas en línea con equipos de radio: tenga cuidado</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>