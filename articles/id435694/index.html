<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨â€âš–ï¸ ğŸ™‡ğŸ» ğŸ‘¨â€ğŸ‘§â€ğŸ‘¦ Bagaimana dan mengapa kami mengoptimalkan algoritma untuk membersihkan cache SLAB di kernel Linux ğŸ’…ğŸ» ğŸ…ğŸ½ ğŸ¤µğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Meningkatnya popularitas kontainer dan penggunaannya bersama dengan kelompok kontrol mengungkapkan masalah skalabilitas yang serius, yang mengarah pad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana dan mengapa kami mengoptimalkan algoritma untuk membersihkan cache SLAB di kernel Linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/virtuozzo/blog/435694/">  Meningkatnya popularitas kontainer dan penggunaannya bersama dengan kelompok kontrol mengungkapkan masalah skalabilitas yang serius, yang mengarah pada penurunan kinerja yang signifikan pada alat berat besar.  Masalahnya adalah bahwa waktu pintas dari cache SLAB tergantung secara kuadrat pada jumlah kontainer, dan konsumsi aktif sejumlah besar memori dalam waktu singkat dapat menyebabkan sistem masuk ke loop sibuk, menghabiskan 100% dari waktu prosesor.  Hari ini saya ingin memberitahu Anda bagaimana kami memecahkan masalah ini dengan mengubah algoritma akuntansi untuk menggunakan grup kontrol memcg untuk menggunakan objek cache SLAB dan mengoptimalkan fungsi shrink_slab (). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/99b/7f3/83b/99b7f383beadeec2c814a6792e507b6c.jpg" alt="Pembersihan memori"><br><a name="habracut"></a><br>  Mengapa pertanyaan tentang optimasi proses di kernel muncul?  Semuanya berawal dari fakta bahwa salah satu pelanggan kami, yang secara aktif menggunakan wadah dan kelompok kontrol memori (memcg), menarik perhatian pada puncak aneh konsumsi sumber daya prosesor yang terjadi dari waktu ke waktu.  Beban sistem normal adalah sekitar 50%, dan pada waktu puncak 100% dari waktu prosesor diambil, dan hampir semuanya dikonsumsi oleh kernel (waktu sistem). <br>  Node itu sendiri multi-pengguna, dan sekitar 200 kontainer OpenVZ diluncurkan di sana.  Analisis menunjukkan bahwa sejumlah besar pengguna membuat wadah Docker bersarang dan hierarki multi-level grup kontrol memori.  Setiap wadah tingkat atas tingkat pengguna berisi sekitar 20 titik pemasangan dan 20 kelompok memori kontrol (memcg) yang dibuat oleh systemd.  Selain itu, ada mount poin dan grup kontrol yang dibuat oleh Docker tersebut.  Sederhananya, node itu sangat dimuat, dan beban di atasnya jauh lebih kuat daripada rata-rata untuk semua pelanggan kami yang lain.  Kami tertarik untuk menemukan alasan munculnya puncak ini, karena masalah yang sama dapat muncul pada mesin yang kurang sibuk, di mana itu hampir tidak terlihat (misalnya, memberikan puncak pada waktu sistem 5%, yang menurunkan kinerja). <br><br>  Dengan memanipulasi perf, saya berhasil menangkap puncak dan menghapus jejak.  Ternyata sebagian besar waktu prosesor dihabiskan untuk membersihkan cache SLAB, yaitu cache super block: <br><br><pre><code class="markdown hljs"><span class="hljs-bullet"><span class="hljs-bullet">- </span></span>100,00% 0,00% kswapd0 [kernel.vmlinux] [k] kthread - 99,31% balance<span class="hljs-emphasis"><span class="hljs-emphasis">_pgdat - 82,11% shrink_</span></span>zone - 61,69% shrink<span class="hljs-emphasis"><span class="hljs-emphasis">_slab - 58,29% super_</span></span>cache<span class="hljs-emphasis"><span class="hljs-emphasis">_count + 54,56% list_</span></span>lru<span class="hljs-emphasis"><span class="hljs-emphasis">_count_</span></span>one</code> </pre> <br><br>  Di sini ada baiknya membuat penjelasan dan membahas masalah ini secara lebih rinci.  Semua orang tahu bahwa kernel melakukan cache data yang tidak digunakan untuk sementara waktu sebelum akhirnya membebaskan memori.  Kernel menggunakan prinsip ini secara ekstensif.  Misalnya, halaman cache berisi halaman-halaman data yang berkaitan dengan file, yang sangat mempercepat akses berulang ketika membaca (karena Anda tidak perlu mengakses disk lagi).  Dalam kasus kami, masalah muncul dengan cache metadata superblok yang terkandung dalam dua daftar LRU: s_dentry_lru dan s_inode_lru. <br><br>  <b>LRU (Setidaknya Terakhir Digunakan)</b> <b><br></b> <br>  struct lru_list menunjuk ke array daftar yang ditautkan, dan setiap memcg aktif sesuai dengan satu elemen (list_lru_one) dalam array ini.  Ketika objek SLAB tertentu tidak lagi digunakan oleh kernel, kernel menambahkannya ke salah satu daftar array terkait (tergantung pada memcg mana objek milik, atau, secara kasar, yang memcg proses yang digunakan ketika itu menciptakan objek ini).  Array itu sendiri dijelaskan sebagai berikut (lru_list :: node :: memcg_lrus): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_lru_memcg</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rcu_head</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rcu</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* array of per cgroup lists, indexed by memcg_cache_id */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_lru_one</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lru</span></span></span><span class="hljs-class">[0];</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_lru_one</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_head</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* may become negative during memcg reparenting */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> nr_items; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> };</code> </pre><br>  lru [0] menunjukkan daftar objek yang terkait dengan memcg dengan ID 0; <br>  lru [1] menunjukkan daftar objek yang terkait dengan memcg dengan ID 1; <br>  ... <br>  lru [n] menunjukkan daftar objek yang terkait dengan memcg dengan ID n; <br><br>  LRU mendaftar s_dentry_lru dan s_inode_lru muncul di masalah kita, dan, seperti namanya, mereka berisi objek sistem berkas dentry dan inode yang tidak digunakan. <br>  Di masa depan, jika tidak ada cukup memori dalam sistem atau memcg tertentu, beberapa item daftar akhirnya dibebaskan, dan mekanisme khusus yang disebut shrinker melakukan ini. <br><br>  <b>Penyusut</b> <b><br></b> <br>  Ketika kernel perlu mengalokasikan halaman memori, tetapi tidak ada memori bebas pada NUMA node atau dalam sistem, mekanisme untuk membersihkannya dimulai.  Dia mencoba untuk membuang atau membuang sejumlah disk: 1) halaman isi file dari cache halaman;  2) halaman yang terkait dengan memori anonim dalam swap, dan 3) cache objek SLAB (masalah yang kami temui terkait dengan mereka). <br><br>  Membuang bagian dari objek SLAB yang di-cache tidak secara langsung mempengaruhi rilis halaman: ukurannya, secara umum, lebih kecil dari ukuran halaman, dan satu halaman berisi ratusan objek.  Ketika bagian dari objek dibebaskan, celah memori kosong muncul di halaman SLAB, yang dapat digunakan untuk membuat objek SLAB lainnya.  Algoritma ini diterima di kernel dengan sengaja: sederhana dan cukup efisien.  Pembaca yang tertarik dapat melihat rumus untuk memilih bagian dari objek untuk dibersihkan di fungsi do_shrink_slab (). <br><br>  Fungsi ini melakukan pembersihan sebenarnya dari beberapa objek, dipandu oleh deskripsi yang diteruskan ke dalam shrink shrink struct: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_shrink_slab</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct shrink_control *shrinkctl, struct shrinker *shrinker, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> priority)</span></span></span><span class="hljs-function"> </span></span>{ â€¦ <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> freeable = shrinker-&gt;count_objects(shrinker, shrinkctl); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (freeable == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; total_scan = _(freeable); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (total_scan &gt;= batch_size) { <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ret = shrinker-&gt;scan_objects(shrinker, shrinkctl); total_scan -= shrinkctl-&gt;nr_scanned; } ... }</code> </pre> <br>  Sehubungan dengan superblock shrinker, fungsi-fungsi ini diimplementasikan sebagai berikut.  Setiap superblock menyimpan daftar s_dentry_lru dan s_inode_lru miliknya dari objek yang tidak terpakai yang terkait dengannya: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">super_block</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shrinker</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s_shrink</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* per-sb shrinker handle */</span></span> ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_lru</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s_dentry_lru</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_lru</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s_inode_lru</span></span></span><span class="hljs-class">;</span></span> â€¦ };</code> </pre> <br><br>  Metode .count_objects mengembalikan jumlah objek: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">super_cache_count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct shrinker *shrink, struct shrink_control *sc)</span></span></span><span class="hljs-function"> </span></span>{ total_objects += list_lru_shrink_count(&amp;sb-&gt;s_dentry_lru, sc); total_objects += list_lru_shrink_count(&amp;sb-&gt;s_inode_lru, sc); <span class="hljs-comment"><span class="hljs-comment">/*     ) */</span></span> total_objects = vfs_pressure_ratio(total_objects); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total_objects; }</code> </pre> <br><br>  Metode .scan_objects sebenarnya membebaskan objek: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">super_cache_scan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct shrinker *shrink, struct shrink_control *sc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*     s_dentry_lru */</span></span> prune_dcache_sb(sb, sc); <span class="hljs-comment"><span class="hljs-comment">/*     s_inode_lru */</span></span> prune_icache_sb(sb, sc); }</code> </pre> <br>  Jumlah objek yang akan dibebaskan dilewatkan dalam parameter sc.  Juga, memcg ditunjukkan di sana, objek yang harus dibuang dari LRU: <br><br><pre> <b><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shrink_control</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nid; <span class="hljs-comment"><span class="hljs-comment">/* ID NUMA  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> nr_to_scan; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem_cgroup</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">memcg</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* memcg */</span></span> };</code></b> </pre><br>  Jadi, prune_dcache_sb () memilih daftar yang ditautkan dari array struct list_lru_memcg :: lru [] dan bekerja dengannya.  Prune_icache_sb () melakukan hal yang sama. <br><br>  <b>Algoritma pintas penyusutan lama</b> <b><br></b> <br>  Dengan pendekatan standar, "mengeluarkan" objek dari SLAB tanpa memori di <br>  sc-&gt; target_mem_cgroup terjadi sebagai berikut: <br><br><pre> <code class="cpp hljs">shrink_node() { â€¦ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem_cgroup</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">root</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sc</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">target_mem_cgroup</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      sc-&gt;target_mem_cgroup  */</span></span> memcg = mem_cgroup_iter(root, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;reclaim); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { â€¦ shrink_slab(memcg, ...); â€¦ } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((memcg = mem_cgroup_iter(root, memcg, &amp;reclaim))); ... }</code> </pre><br>  Kami melewati semua memcg anak dan memanggil shrink_slab () untuk masing-masing.  Selanjutnya, dalam fungsi shrink_slab (), kita melewati semua shrinker dan masing-masing memanggil do_shrink_slab (): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shrink_slab</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">gfp_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> gfp_mask, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nid, struct mem_cgroup *memcg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> priority)</span></span></span><span class="hljs-function"> </span></span>{ list_for_each_entry(shrinker, &amp;shrinker_list, <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shrink_control</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sc</span></span></span><span class="hljs-class"> = {</span></span> .nid = nid, .memcg = memcg, }; ret = do_shrink_slab(&amp;sc, shrinker, ...); } }</code> </pre><br>  Ingatlah bahwa untuk setiap superblok, penyusutnya sendiri ditambahkan ke daftar ini.  Mari kita hitung berapa kali do_shrink_slab () akan dipanggil untuk kasing dengan 200 kontainer berisi 20 memcg dan 20 mount poin di masing-masing.  Secara total, kami memiliki 200 * 20 titik pemasangan dan 200 * 20 grup kontrol.  Jika tidak ada cukup memori di memcg paling atas, kami akan dipaksa untuk mem-bypass semua memcg anaknya (mis., Semuanya secara umum), dan untuk masing-masing dari mereka memanggil masing-masing penyusutan dari shrinker_list.  Dengan demikian, kernel akan membuat 200 * 20 * 200 * 20 = 16000000 panggilan ke fungsi do_shrink_slab (). <br><br>  Selain itu, banyaknya panggilan ke fungsi ini tidak akan berguna: wadah biasanya terisolasi di antara mereka sendiri, dan kemungkinan bahwa CT1 akan menggunakan super_block2 yang dibuat dalam CT2 umumnya rendah.  Atau, apa yang sama, jika memcg1 adalah grup kontrol dari CT1, maka elemen yang sesuai dari super_block2-&gt; s_dentry_lru-&gt; node-&gt; memcg_lrus-&gt; lru [memcg1_id] akan menjadi daftar kosong, dan tidak ada gunanya memanggil do_shrink_slab () untuk itu. <br><br>  Masalah ini dapat dimodelkan menggunakan skrip bash sederhana (data dari patchset, yang kemudian diteruskan ke kernel, digunakan di sini): <br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$echo</span></span> 1 &gt; /sys/fs/cgroup/memory/memory.use_hierarchy <span class="hljs-variable"><span class="hljs-variable">$mkdir</span></span> /sys/fs/cgroup/memory/ct <span class="hljs-variable"><span class="hljs-variable">$echo</span></span> 4000M &gt; /sys/fs/cgroup/memory/ct/memory.kmem.limit_in_bytes <span class="hljs-variable"><span class="hljs-variable">$for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> `seq 0 4000`; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> mkdir /sys/fs/cgroup/memory/ct/<span class="hljs-variable"><span class="hljs-variable">$i</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $$ &gt; /sys/fs/cgroup/memory/ct/<span class="hljs-variable"><span class="hljs-variable">$i</span></span>/cgroup.procs; mkdir -ps/<span class="hljs-variable"><span class="hljs-variable">$i</span></span>; mount -t tmpfs <span class="hljs-variable"><span class="hljs-variable">$is</span></span>/<span class="hljs-variable"><span class="hljs-variable">$i</span></span>; touch s/<span class="hljs-variable"><span class="hljs-variable">$i</span></span>/file; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre><br>  Mari kita lihat apa yang terjadi jika Anda memanggil prosedur reset cache 5 kali berturut-turut: <br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$time</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 3 &gt; /proc/sys/vm/drop_caches</code> </pre> <br>  Iterasi pertama berlangsung 14 detik, karena objek yang di-cache benar-benar ada di memori: <i>0,00 pengguna 13,78 sistem <b>0: 13,78 berlalu</b> CPU 99%.</i> <br>  Iterasi kedua membutuhkan waktu 5 detik, meskipun tidak ada objek lagi: <i>0.00user 5.59sistem <b>0: 05.60menghapus</b> 99% CPU.</i> <br>  Iterasi ketiga membutuhkan waktu 5 detik: <i>0,00 pengguna 5,48 sistem <b>0: 05,48 menghapus</b> CPU 99%</i> <br>  Iterasi keempat membutuhkan waktu 8 detik: <i>0,00 pengguna 8.35sistem <b>0: 08.35melepaskan</b> 99% CPU</i> <br>  Iterasi kelima membutuhkan waktu 8 detik: <i>0,00 pengguna 8,34sistem <b>0: 08,35melepaskan</b> 99% CPU</i> <br><br>  Menjadi jelas bahwa algoritma bypass shrinker yang digunakan oleh core vanilla tidak optimal, dan kita perlu mengubahnya menjadi lebih baik dalam hal skalabilitas. <br><br>  <b>Algoritma pintas penyusutan baru</b> <b><br></b> <br>  Dari algoritma baru saya ingin mencapai yang berikut: <br><br><ol><li>  membebaskannya dari kelemahan yang lama dan </li><li>  Jangan tambahkan kunci baru.  Panggil do_shrink_slab () hanya ketika masuk akal (yaitu, daftar tertaut terkait dari array s_dentry_lru atau dari array s_inode_lru tidak kosong), tetapi jangan langsung mengakses memori daftar yang ditautkan. </li></ol><br>  Sudah jelas bahwa ini hanya dapat disediakan oleh struktur data baru di atas heterogen heterogen (ada penyusutan tidak hanya superblok, tetapi juga objek data lain yang tidak dijelaskan dalam artikel ini. Pembaca dapat membiasakan diri dengan mereka dengan mencari kata kunci prealloc_shrinker () dalam kode kernel).  Struktur data baru harus memungkinkan pengkodean dua negara: "masuk akal untuk memanggil do_shrink_slab ()" dan "tidak masuk akal untuk memanggil do_shrink_slab ()". <br><br>  Struktur data tipe IDA ditolak karena  mereka menggunakan kunci di dalam diri mereka.  Struktur data dari bidang bit sepenuhnya cocok untuk peran ini: memungkinkan modifikasi atom dari masing-masing bit, dan dalam kombinasi dengan hambatan memori memungkinkan Anda untuk membangun algoritma yang efisien tanpa menggunakan kunci. <br><br>  Setiap shrinker mendapatkan id uniknya sendiri (shrinker :: id), dan setiap memcg mendapat bitmap yang mampu berisi id terbesar dari yang saat ini terdaftar.  Ketika elemen pertama ditambahkan ke daftar s_dentry_lru-&gt; node-&gt; memcg_lrus-&gt; lru [memcg_id], bitmap memcg yang bersangkutan diatur ke 1 bit dengan nomor shrinker-&gt; id.  Hal yang sama dengan s_inode_id. <br><br>  Sekarang loop di shrink_slab () dapat dioptimalkan untuk mem-bypass hanya shrinker yang diperlukan: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shrink_slab</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ â€¦ for_each_set_bit(i, <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>, shrinker_nr_max) { â€¦ shrinker = idr_find(&amp;shrinker_idr, i); â€¦ do_shrink_slab(&amp;sc, shrinker, priority); â€¦ } }</code> </pre><br>  (Pembersihan bit juga diterapkan ketika shrinker memasuki kondisi "tidak masuk akal untuk memanggil do_shrink_slab (). Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komitmen</a> Github untuk detail lebih lanjut. <br><br>  Jika Anda mengulangi tes reset cache, kemudian menggunakan algoritma baru itu menunjukkan hasil yang jauh lebih baik: <br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$time</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 3 &gt; /proc/sys/vm/drop_caches</code> </pre> <br>  Iterasi pertama: <i>0,00 pengguna 1.10sistem <b>0: 01.10 mengeluarkan</b> 99% CPU</i> <i><br></i>  Iterasi kedua: <i>0,00 pengguna 0,00 sistem <b>0: 00,01 menggunakan</b> CPU 64%</i> <i><br></i>  Iterasi ketiga: <i>0,00 pengguna 0,01 sistem <b>0: 00,01 mengeluarkan</b> CPU 82%</i> <i><br></i>  Iterasi keempat: <i>0,00 pengguna 0,00 sistem <b>0: 00,01 menggunakan</b> CPU 64%</i> <i><br></i>  Iterasi kelima: <i>0,00 pengguna 0,01 sistem <b>0: 00,01 mengeluarkan</b> CPU 82%</i> <br>  Durasi iterasi kedua hingga kelima adalah 0,01 detik, <b>548 kali lebih cepat dari sebelumnya.</b> <br><br>  Karena tindakan serupa untuk mengatur ulang cache terjadi dengan setiap kekurangan memori pada mesin, optimisasi ini secara signifikan meningkatkan operasi mesin dengan sejumlah besar wadah dan grup kontrol memori.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Seperangkat tambalan</a> (17 buah) telah diterima ke dalam inti vanila, dan Anda dapat menemukannya di sana mulai dari versi 4.19. <br><br>  Dalam proses meninjau tambalan, seorang karyawan Google muncul, dan ternyata mereka memiliki masalah yang sama.  Oleh karena itu, tambalan diuji lebih lanjut pada jenis beban yang berbeda. <br>  Akibatnya, patchset diadopsi dari iterasi ke-9;  dan masuknya ke dalam inti vanila memakan waktu sekitar 4 bulan.  Juga hari ini, patchset termasuk dalam kernel Virtuozzo 7 kita sendiri, dimulai dengan versi vz7.71.9 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435694/">https://habr.com/ru/post/id435694/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435684/index.html">Oak Ridge National Laboratory telah memecahkan masalah utama pengembang perangkat luar angkasa: kekurangan plutonium-238</a></li>
<li><a href="../id435686/index.html">Pavel Durov melikuidasi Telegram Messenger LLP</a></li>
<li><a href="../id435688/index.html">Contoh Aplikasi Server Klien Berkibar</a></li>
<li><a href="../id435690/index.html">[Apa yang salah dengan GraphQL] ... Dan cara menghadapinya</a></li>
<li><a href="../id435692/index.html">Y Combinator: "Pada awalnya, beberapa perusahaan teknologi terbesar terlihat seperti mainan"</a></li>
<li><a href="../id435696/index.html">Antiquities: 1997 Computer Advertising</a></li>
<li><a href="../id435698/index.html">Menulis manajer memori Anda sendiri yang baik</a></li>
<li><a href="../id435700/index.html">8 Pertanyaan Wawancara Vue.js Terburuk</a></li>
<li><a href="../id435702/index.html">Troll paten mulai dan menang: bagaimana saya dibiarkan tanpa permainan</a></li>
<li><a href="../id435704/index.html">Solusi arsitektur untuk gim seluler. Bagian 2: Perintah dan antriannya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>