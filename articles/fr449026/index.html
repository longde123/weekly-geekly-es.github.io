<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úâÔ∏è üé¨ üê® Syst√®mes d'exploitation: trois pi√®ces faciles. Partie 4: Introduction √† l'ordonnanceur (traduction) üöá ‚òÅÔ∏è ü•¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction aux syst√®mes d'exploitation 
 Bonjour, Habr! Je veux attirer votre attention sur une s√©rie d'articles-traductions d'une litt√©rature int√©r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Syst√®mes d'exploitation: trois pi√®ces faciles. Partie 4: Introduction √† l'ordonnanceur (traduction)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449026/"><h1>  Introduction aux syst√®mes d'exploitation </h1><br>  Bonjour, Habr!  Je veux attirer votre attention sur une s√©rie d'articles-traductions d'une litt√©rature int√©ressante √† mon avis - OSTEP.  Cet article d√©crit assez en profondeur le travail des syst√®mes d'exploitation de type Unix, √† savoir le travail avec les processus, les diff√©rents planificateurs, la m√©moire et d'autres composants similaires qui composent le syst√®me d'exploitation moderne.  L'original de tous les mat√©riaux que vous pouvez voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Veuillez noter que la traduction a √©t√© effectu√©e de mani√®re non professionnelle (assez librement), mais j'esp√®re avoir conserv√© le sens g√©n√©ral. <br><br>  Les travaux de laboratoire sur ce sujet peuvent √™tre trouv√©s ici: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'original</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'original</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mon adaptation personnelle</a> </li></ul><br>  Autres parties: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1: Intro</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2: Abstraction: le processus</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3: Introduction √† l'API Process</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 4: Introduction au planificateur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 5: Planificateur MLFQ</a> </li></ul><br>  Et vous pouvez regarder ma cha√Æne en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">t√©l√©gramme</a> =) <br><a name="habracut"></a><br><h2>  Pr√©sentation du planificateur </h2><br>  <u>L'essence du probl√®me: comment √©laborer une politique de planification</u> <u><br></u>  <u>Comment d√©velopper les cadres de politique de base du planificateur?</u>  <u>Quelles devraient √™tre les hypoth√®ses cl√©s?</u>  <u>Quels param√®tres sont importants?</u>  <u>Quelles techniques de base ont √©t√© utilis√©es dans les premiers calculs?</u> <br><br><h3>  Hypoth√®ses de charge de travail </h3><br>  Avant de discuter des politiques possibles, pour commencer, nous allons faire quelques digressions simplificatrices sur les processus en cours d'ex√©cution dans le syst√®me, appel√©s collectivement la <b>charge de travail</b> .  En d√©finissant une charge de travail en tant que partie critique de l'√©laboration de politiques et plus vous en savez sur la charge de travail, meilleure est la politique que vous pouvez √©crire. <br><br>  Nous faisons les hypoth√®ses suivantes sur les processus en cours d'ex√©cution dans le syst√®me, parfois √©galement appel√©s <b>travaux</b> (t√¢ches).  Presque toutes ces hypoth√®ses ne sont pas r√©alistes, mais n√©cessaires au d√©veloppement de la pens√©e. <br><br><ol><li>  Chaque t√¢che s'ex√©cute le m√™me temps, </li><li>  Toutes les t√¢ches sont d√©finies en m√™me temps, </li><li>  La t√¢che √† accomplir jusqu'√† son ach√®vement, </li><li>  Toutes les t√¢ches utilisent uniquement le CPU, </li><li>  Le temps d'ex√©cution de chaque t√¢che est connu. </li></ol><br><h3>  Mesures du planificateur </h3><br>  En plus de certaines hypoth√®ses sur la charge, il existe toujours un besoin d'un outil pour comparer diverses politiques de planification: les mesures du planificateur.  Une m√©trique n'est qu'une mesure de quelque chose.  Il existe un certain nombre de m√©triques qui peuvent √™tre utilis√©es pour comparer les planificateurs. <br><br>  Par exemple, nous utiliserons une m√©trique appel√©e d√©lai d'ex√©cution.  Le d√©lai d'ex√©cution d'une t√¢che est d√©fini comme la diff√©rence entre le temps qu'il faut pour terminer la t√¢che et le moment o√π la t√¢che entre dans le syst√®me. <br><br>  <u>Tturnaround = Tcompletion - Tarrival</u> <br><br>  Puisque nous avons suppos√© que toutes les t√¢ches arrivaient en m√™me temps, alors Ta = 0 et donc Tt = Tc.  Cette valeur changera naturellement lorsque nous changerons les hypoth√®ses ci-dessus. <br><br>  Une autre mesure est l' <b>√©quit√©</b> (√©quit√©, honn√™tet√©).  La productivit√© et l'honn√™tet√© sont souvent des caract√©ristiques oppos√©es dans la planification.  Par exemple, un planificateur peut optimiser les performances, mais au prix d'attendre que d'autres t√¢ches s'ex√©cutent, r√©duisant ainsi l'int√©grit√©. <br><br><h3>  PREMIER EN PREMIER SORTI (FIFO) </h3><br>  L'algorithme le plus √©l√©mentaire que nous pouvons impl√©menter est appel√© FIFO ou <b>premier arriv√© (premier entr√©, premier servi)</b> .  Cet algorithme pr√©sente plusieurs avantages: il est tr√®s simple √† mettre en ≈ìuvre et il correspond √† toutes nos hypoth√®ses, faisant assez bien le travail. <br><br>  Prenons un exemple simple.  Supposons que 3 t√¢ches ont √©t√© d√©finies en m√™me temps.  Mais supposons que la t√¢che A soit arriv√©e un peu plus t√¥t que tout le monde, elle sera donc sur la liste d'ex√©cution avant les autres, tout comme B par rapport √† C. Supposons que chacune d'entre elles prenne 10 secondes.  Quel sera le temps moyen pour terminer ces t√¢ches? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1b4/a43/acd/1b4a43acd8a0f18c24bbdd831529bbda.jpg" alt="image"><br><br>  En comptant les valeurs - 10 + 20 + 30 et en divisant par 3, nous obtenons le temps d'ex√©cution moyen du programme √©gal √† 20 secondes. <br><br>  Essayons maintenant de changer nos hypoth√®ses.  En particulier, l'hypoth√®se 1, et donc nous ne supposerons plus que chaque t√¢che prend le m√™me temps.  Comment le FIFO se montrera-t-il cette fois? <br><br>  Il s'av√®re que diff√©rents temps d'ex√©cution des t√¢ches ont un impact extr√™mement n√©gatif sur la productivit√© de l'algorithme FIFO.  Supposons que la t√¢che A sera ex√©cut√©e pendant 100 secondes, tandis que B et C seront toujours de 10 chacun. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a7a/bee/3fe/a7abee3fefd7a0cf481d0322f40e732f.jpg" alt="image"><br><br>  Comme le montre la figure, le temps moyen pour le syst√®me est (100 + 110 + 120) / 3 = 110.  Cet effet est appel√© <b>effet de convoi</b> , lorsque certains consommateurs √† court terme d'une ressource seront en ligne apr√®s un gros consommateur.  Cela ressemble √† une ligne d'√©picerie lorsqu'un client avec un chariot plein est devant vous.  La meilleure solution au probl√®me est d'essayer de changer de caissi√®re ou de vous d√©tendre et de respirer profond√©ment. <br><br><h3>  L'emploi le plus court en premier </h3><br>  Est-il possible de r√©soudre d'une mani√®re ou d'une autre une situation similaire avec des processus lourds?  Bien s√ªr.  Un autre type de planification est appel√© <b>Shortest Job First</b> (SJF).  Son algorithme est √©galement assez primitif - comme son nom l'indique, les t√¢ches les plus courtes seront lanc√©es les unes apr√®s les autres. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/778/feb/207/778feb20723fa2d019620b97d27f2830.jpg" alt="image"><br><br>  Dans cet exemple, le r√©sultat du d√©marrage des m√™mes processus sera une am√©lioration du d√©lai d'ex√©cution moyen des programmes et il sera de <b>50 au lieu de 110</b> , ce qui est presque 2 fois meilleur. <br><br>  Ainsi, pour l'hypoth√®se donn√©e que toutes les t√¢ches arrivent en m√™me temps, l'algorithme SJF semble √™tre l'algorithme le plus optimal.  Cependant, nos hypoth√®ses ne semblent toujours pas r√©alistes.  Cette fois, nous changeons l'hypoth√®se 2 et cette fois, imaginons que les t√¢ches peuvent rester √† tout moment, et pas toutes en m√™me temps.  √Ä quels probl√®mes cela peut-il conduire? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/484/6df/332/4846df332de36b42bf891e167ef3f751.jpg" alt="image"><br><br>  Imaginez que la t√¢che A (100s) arrive en premier et commence √† √™tre ex√©cut√©e.  Au temps t = 10, les t√¢ches B, C arrivent, chacune prenant 10 secondes.  Ainsi, le temps d'ex√©cution moyen est (100+ (110-10) + (120-10)) \ 3 = 103. Que pourrait faire le planificateur pour am√©liorer la situation? <br><br><h3>  D√©lai le plus court en premier (STCF) </h3><br>  Afin d'am√©liorer la situation, nous omettons l'hypoth√®se 3 que le programme est op√©rationnel jusqu'√† la fin.  De plus, nous aurons besoin d'un support mat√©riel, et comme vous l'avez peut-√™tre devin√©, nous utiliserons une <b>minuterie</b> pour interrompre une t√¢che de travail et <b>changer de contexte</b> .  Ainsi, le planificateur peut faire quelque chose au moment o√π les t√¢ches B et C arrivent - arr√™ter l'ex√©cution de la t√¢che A et mettre les t√¢ches B et C en traitement et, une fois qu'elles ont termin√©, continuer le processus A. Ce planificateur est appel√© <b>STCF</b> ou <b>Preemptive Job First</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0eb/900/a1f/0eb900a1f8b96a0952061727037faf4f.jpg" alt="image"><br><br>  Le r√©sultat de ce planificateur sera le r√©sultat suivant: ((120-0) + (20-10) + (30-10)) / 3 = 50.  Ainsi, un tel ordonnanceur devient encore plus optimal pour nos t√¢ches. <br><br><h3>  Temps de r√©ponse m√©trique </h3><br>  Ainsi, si nous connaissons le temps d'ex√©cution des t√¢ches et que ces t√¢ches n'utilisent que le CPU, STCF sera la meilleure solution.  Et une fois au d√©but, ces algorithmes fonctionnaient et fonctionnaient assez bien.  Cependant, l'utilisateur passe maintenant la plupart du temps au terminal et attend de lui une interaction interactive productive.  Ainsi, une nouvelle m√©trique est n√©e - le <b>temps de</b> r√©ponse (r√©ponse). <br><br>  Le temps de r√©ponse est calcul√© comme suit: <br><br>  <u>Tresponse = Tfirstrun - Tarrival</u> <br><br>  Ainsi, pour l'exemple pr√©c√©dent, le temps de r√©ponse sera le suivant: A = 0, B = 0, B = 10 (abg = 3,33). <br><br>  Et il s'av√®re que l'algorithme STCF n'est pas si bon dans une situation o√π 3 t√¢ches arrivent en m√™me temps - il faudra attendre que les petites t√¢ches soient compl√®tement termin√©es.  Ainsi, l'algorithme est bon pour la m√©trique de d√©lai d'ex√©cution, mais mauvais pour la m√©trique d'interactivit√©.  Imaginez-vous assis au terminal pour tenter de taper des caract√®res dans l'√©diteur, vous devrez attendre plus de 10 secondes, car une autre t√¢che est occup√©e par le processeur.  Ce n'est pas tr√®s agr√©able. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bed/aed/2e2/bedaed2e2491a426eb3fe137ed5b467e.jpg" alt="image"><br><br>  Nous sommes donc confront√©s √† un autre probl√®me - comment pouvons-nous construire un planificateur sensible au temps de r√©ponse? <br><br><h3>  Tournoi √† la ronde </h3><br>  Pour r√©soudre ce probl√®me, l'algorithme <b>Round Robin</b> (RR) a √©t√© d√©velopp√©.  L'id√©e de base est assez simple: au lieu de commencer les t√¢ches jusqu'√† leur ach√®vement, nous allons commencer la t√¢che pendant une certaine p√©riode de temps (appel√©e quantum de temps), puis passer √† une autre t√¢che de la file d'attente.  L'algorithme r√©p√®te son travail jusqu'√† ce que toutes les t√¢ches soient termin√©es.  Dans ce cas, le temps d'ex√©cution du programme doit √™tre un multiple du temps apr√®s lequel le temporisateur interrompt le processus.  Par exemple, si le temporisateur interrompt le processus toutes les x = 10 ms, la taille de la fen√™tre d'ex√©cution du processus doit √™tre un multiple de 10 et √™tre 10,20 ou x * 10. <br><br>  Regardons un exemple: les t√¢ches d'ABV arrivent simultan√©ment dans le syst√®me et chacune veut travailler pendant 5 secondes.  L'algorithme SJF terminera chaque t√¢che jusqu'√† la fin avant d'en d√©marrer une autre.  En revanche, l'algorithme RR avec la fen√™tre de lancement = 1 passera par les t√¢ches comme suit (Fig. 4.3): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bed/aed/2e2/bedaed2e2491a426eb3fe137ed5b467e.jpg" alt="image"><br>  <i>(SJF √† nouveau (mauvais pour le temps de r√©ponse)</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e40/351/12e/e4035112ea5d27958b0e099ed19a6c41.jpg" alt="image"><br>  <i>(Round Robin (bon pour le temps de r√©ponse)</i> <br><br>  Le temps de r√©ponse moyen pour l'algorithme est RR (0 + 1 + 2) / 3 = 1, tandis que pour SJF (0 + 5 + 10) / 3 = 5. <br><br>  Il est logique de supposer que la fen√™tre temporelle est un param√®tre tr√®s important pour RR, plus elle est petite, plus le temps de r√©ponse est √©lev√©.  Cependant, vous ne pouvez pas le rendre trop petit, car le temps de changement de contexte jouera √©galement un r√¥le dans les performances globales.  Ainsi, le timing de la fen√™tre d'ex√©cution est d√©fini par l'architecte du syst√®me d'exploitation et d√©pend des t√¢ches qui doivent y √™tre ex√©cut√©es.  Changer de contexte n'est pas la seule op√©ration de service qui passe du temps - le programme en cours d'ex√©cution fonctionne avec beaucoup plus, par exemple, divers caches, et chaque fois qu'il est n√©cessaire de sauvegarder et de restaurer cet environnement, ce qui peut √©galement prendre beaucoup de temps. <br><br>  RR est un excellent planificateur s'il ne s'agissait que d'une m√©trique de temps de r√©ponse.  Mais comment la m√©trique du d√©lai d'ex√©cution de la t√¢che se comportera-t-elle avec cet algorithme?  Consid√©rons l'exemple ci-dessus, lorsque le temps de fonctionnement A, B, C = 5s et arrivent en m√™me temps.  La t√¢che A se terminera √† 13, B √† 14, C √† 15 s et le d√©lai d'ex√©cution moyen sera de 14 s.  Ainsi, RR est le pire algorithme pour les m√©triques de chiffre d'affaires. <br><br>  Plus g√©n√©ralement, tout algorithme tel que RR est honn√™te, il r√©partit le temps pass√© sur le CPU √©galement entre tous les processus.  Et donc, ces mesures sont constamment en conflit les unes avec les autres. <br><br>  Ainsi, nous avons plusieurs algorithmes oppos√©s et en m√™me temps plusieurs hypoth√®ses demeurent - que l'heure de la t√¢che est connue et que la t√¢che utilise uniquement le CPU. <br><br><h3>  Mixage avec E / S </h3><br>  Tout d'abord, nous supprimons l'hypoth√®se 4 selon laquelle le processus utilise uniquement le CPU, bien s√ªr que ce n'est pas le cas, et les processus peuvent se tourner vers d'autres √©quipements. <br><br>  Au moment o√π un processus demande une op√©ration d'E / S, le processus passe dans un √©tat bloqu√©, en attendant la fin des E / S.  Si des E / S sont envoy√©es au disque dur, une telle op√©ration peut prendre plusieurs ms ou plus et le processeur sera inactif √† ce moment.  √Ä ce moment, le planificateur peut prendre le contr√¥le du processeur par tout autre processus.  La prochaine d√©cision que l'ordonnanceur devra prendre est lorsque le processus termine ses E / S.  Lorsque cela se produit, une interruption se produit et le syst√®me d'exploitation met le processus d'appel d'E / S √† l'√©tat pr√™t. <br><br>  Prenons un exemple de plusieurs t√¢ches.  Chacun d'eux a besoin de 50 ms de temps processeur.  Cependant, le premier acc√©dera aux E / S toutes les 10 ms (qui seront √©galement ex√©cut√©es pendant 10 ms).  Et le processus B utilise simplement un processeur de 50 ms sans E / S. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/50a/488/cae/50a488cae4476f65002df9ea966f9ef7.jpg" alt="image"><br><br>  Dans cet exemple, nous utiliserons le planificateur STCF.  Comment se comporte l'ordonnanceur si vous ex√©cutez un processus comme A dessus?  Il proc√©dera comme suit - d'abord traiter enti√®rement A, puis traiter B. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/151/f5e/326/151f5e326437859d65d29541dbe0e94f.jpg" alt="image"><br><br>  L'approche traditionnelle pour r√©soudre ce probl√®me consiste √† interpr√©ter chaque sous-t√¢che de 10 ms du processus A comme une t√¢che distincte.  Ainsi, lors du d√©marrage avec l'algorithme STJF, le choix entre une t√¢che de 50 ms et une t√¢che de 10 ms est √©vident.  Ensuite, une fois la sous-t√¢che A termin√©e, le processus B et les E / S seront d√©marr√©s.  Une fois les E / S termin√©es, il sera habituel de red√©marrer le processus A de 10 ms au lieu du processus B. Ainsi, il est possible de r√©aliser un chevauchement lorsque le CPU est utilis√© par un autre processus tandis que le premier attend les E / S.  Et en cons√©quence, le syst√®me est mieux utilis√© - au moment o√π les processus interactifs attendent des E / S, d'autres processus peuvent √™tre ex√©cut√©s sur le processeur. <br><br><h3>  Oracle n'est plus </h3><br>  Essayons maintenant de nous d√©barrasser de l'hypoth√®se que l'heure de la t√¢che est connue.  C'est g√©n√©ralement l'hypoth√®se la plus mauvaise et la plus irr√©aliste de toute la liste.  En fait, dans les syst√®mes d'exploitation standard moyens, le syst√®me d'exploitation lui-m√™me conna√Æt g√©n√©ralement tr√®s peu de temps pour terminer les t√¢ches, alors comment pouvez-vous cr√©er un planificateur sans savoir combien de temps la t√¢che prendra?  Peut-√™tre pourrions-nous utiliser certains des principes de RR pour r√©soudre ce probl√®me? <br><br><h3>  R√©sum√© </h3><br>  Nous avons examin√© les id√©es de base de la planification des t√¢ches et examin√© 2 familles de planificateurs.  La premi√®re commence la t√¢che la plus courte au d√©but et augmente ainsi le temps d'ex√©cution, la seconde est partag√©e entre toutes les t√¢ches de mani√®re √©gale, augmentant le temps de r√©ponse.  Les deux algorithmes sont mauvais l√† o√π les autres algorithmes de la famille sont bons.  Nous avons √©galement examin√© comment l'utilisation parall√®le du processeur et des E / S peut am√©liorer les performances, mais nous n'avons pas r√©solu le probl√®me de voyance du syst√®me d'exploitation.  Et dans la prochaine le√ßon, nous consid√©rerons un planificateur qui se penche sur le pass√© proche et essaie de pr√©dire l'avenir.  Et cela s'appelle une file d'attente de r√©troaction √† plusieurs niveaux. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr449026/">https://habr.com/ru/post/fr449026/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr449014/index.html">Advance Ethereum DAPP</a></li>
<li><a href="../fr449016/index.html">St√©ganographie dans le syst√®me de fichiers √† disque optique</a></li>
<li><a href="../fr449020/index.html">Analyse du code de la plateforme CUBA avec PVS-Studio</a></li>
<li><a href="../fr449022/index.html">Analyse du code de la plateforme CUBA √† l'aide de PVS-Studio</a></li>
<li><a href="../fr449024/index.html">"Le secret de la troisi√®me plan√®te" avec des graphismes de r√©seaux de neurones am√©lior√©s</a></li>
<li><a href="../fr449028/index.html">Col√®re, n√©gociation et d√©pression lorsque vous travaillez avec InfluxDB</a></li>
<li><a href="../fr449032/index.html">Nous concevons un syst√®me d'extinction d'incendie par aspersion</a></li>
<li><a href="../fr449034/index.html">Citymobil - un manuel pour am√©liorer la disponibilit√© au milieu de la croissance des entreprises pour les startups. Partie 1</a></li>
<li><a href="../fr449036/index.html">Et encore le loup d√©guis√© en mouton</a></li>
<li><a href="../fr449038/index.html">Gestion des conteneurs Docker dans Go</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>