<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèΩ‚Äçü§ù‚ÄçüßëüèΩ üëåüèª üßù Nous apprenons √† un cochon sur les mono√Ødes √† croire en lui et √† voler üçã üëà üôé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans l' un des articles pr√©c√©dents, j'ai expliqu√© comment cr√©er un ex√©cuteur de programme pour une machine √† pile virtuelle √† l'aide d'approches de pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous apprenons √† un cochon sur les mono√Ødes √† croire en lui et √† voler</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430956/"><p> Dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un</a> des articles pr√©c√©dents, j'ai expliqu√© comment cr√©er un ex√©cuteur de programme pour une machine √† pile virtuelle √† l'aide d'approches de programmation fonctionnelles et orient√©es langage.  La structure math√©matique du langage a sugg√©r√© la structure de base pour la mise en ≈ìuvre de son traducteur, bas√©e sur le concept de semi-groupes et de mono√Ødes.  Cette approche m'a permis de construire une impl√©mentation magnifique et extensible et de briser les applaudissements, mais la premi√®re question du public m'a fait descendre de la tribune et remonter dans Emacs. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n2/ln/ne/n2lnneohm_d4rsc-qkw_n4cguyw.png" width="80%"></div><br><p>  J'ai effectu√© un test simple et je me suis assur√© que sur des t√¢ches simples qui n'utilisent que la pile, la machine virtuelle fonctionne intelligemment et lorsque vous utilisez la "m√©moire" - un tableau √† acc√®s al√©atoire - de gros probl√®mes commencent.  La fa√ßon dont nous avons r√©ussi √† les r√©soudre sans changer les principes de base de l'architecture du programme et √† atteindre une acc√©l√©ration de mille fois le programme sera discut√©e dans l'article qui est port√© √† votre attention. </p><a name="habracut"></a><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mo>&amp;#x2217;</mo><mtext>&amp;#xA0;</mtext><mo>&amp;#x2217;</mo><mtext>&amp;#xA0;</mtext><mo>&amp;#x2217;</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.681ex" height="1.335ex" viewBox="0 -520.7 2445.9 574.6" role="img" focusable="false" style="vertical-align: -0.125ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMAIN-2217" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMAIN-2217" x="972" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMAIN-2217" x="1945" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>‚àó</mo><mtext>&nbsp;</mtext><mo>‚àó</mo><mtext>&nbsp;</mtext><mo>‚àó</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> * \ * \ * </script></p><br><p>  Haskell est une langue particuli√®re avec une niche sp√©ciale.  L'objectif principal de sa cr√©ation et de son d√©veloppement √©tait la n√©cessit√© pour la lingua franca d'exprimer et de tester des id√©es de programmation fonctionnelle.  Cela justifie ses caract√©ristiques les plus frappantes: la paresse, l'extr√™me puret√©, l'accent mis sur les types et les manipulations avec eux.  Il n'a pas √©t√© con√ßu pour le d√©veloppement quotidien, ni pour la programmation industrielle, ni pour une utilisation g√©n√©ralis√©e.  Le fait qu'il soit vraiment utilis√© pour cr√©er des projets √† grande √©chelle dans l'industrie des r√©seaux et dans le traitement des donn√©es est la bonne volont√© des d√©veloppeurs, preuve de concept, si vous voulez.  Mais jusqu'√† pr√©sent, le produit le plus important, largement utilis√© et incroyablement puissant √©crit en Haskell est ... le compilateur ghc.  Et cela est parfaitement justifi√© du point de vue de sa finalit√© - √™tre un outil de recherche dans le domaine de l'informatique.  Le principe proclam√© par Simon Payton-Johnson: ¬´Eviter le succ√®s √† tout prix¬ª est n√©cessaire pour que la langue reste un tel instrument.  Haskell est comme une chambre st√©rile dans le laboratoire d'un centre de recherche d√©veloppant des technologies semi-conductrices ou des nanomat√©riaux.  Il est terriblement g√™nant de travailler, et pour la pratique quotidienne, il restreint √©galement la libert√© d'action, mais sans ces inconv√©nients, sans une adh√©sion sans compromis aux restrictions, il ne sera pas possible d'observer et d'√©tudier les effets subtils qui deviendront plus tard la base des d√©veloppements industriels.  Dans le m√™me temps, dans l'industrie, la st√©rilit√© ne sera n√©cessaire que dans le volume le plus n√©cessaire, et les r√©sultats de ces exp√©riences appara√Ætront dans nos poches sous forme de gadgets.  Nous √©tudions les √©toiles et les galaxies non pas parce que nous nous attendons √† en tirer des avantages directs, mais parce qu'√† l'√©chelle de ces objets impraticables, les effets quantiques et relativistes deviennent observables et √©tudi√©s, √† tel point que plus tard nous pourrons utiliser ces connaissances pour d√©velopper quelque chose de tr√®s utilitaire.  Donc, Haskell avec ses "fausses" lignes, la paresse impraticable des calculs, la rigidit√© de certains algorithmes d'inf√©rence de type, avec une courbe d'entr√©e extr√™mement raide, ne vous permet finalement pas de cr√©er facilement une application intelligente sur le genou ou un syst√®me d'exploitation.  Cependant, les lentilles, les monades, l'analyse syntaxique combinatoire, l'utilisation g√©n√©ralis√©e des mono√Ødes, les m√©thodes de d√©monstration automatique des th√©or√®mes, les gestionnaires de paquets fonctionnels d√©claratifs, les types lin√©aires et d√©pendants approchent du monde pratique.  Cela trouve une application dans des conditions moins st√©riles dans les langages Python, Scala, Kotlin, F #, Rust et bien d'autres.  Mais je n'utiliserais aucun de ces merveilleux langages pour enseigner les principes de la programmation fonctionnelle: j'emm√®nerais l'√©l√®ve au laboratoire, montrerais comment cela fonctionne dans des exemples clairs et nets, et ensuite vous pouvez voir ces principes en action dans l'usine une machine grande et incompr√©hensible, mais tr√®s rapide.  √âviter le succ√®s √† tout prix est une protection contre les tentatives de placer une cafeti√®re dans un microscope √©lectronique afin de la populariser.  Et dans les comp√©titions o√π la langue est plus cool, Haskell sera toujours en dehors des nominations habituelles. </p><br><p>  Cependant, la personne est faible et un d√©mon vit √©galement en moi, ce qui me donne envie de comparer, d'√©valuer et de d√©fendre ¬´ma langue pr√©f√©r√©e¬ª devant les autres.  Donc, apr√®s avoir √©crit une impl√©mentation √©l√©gante d'une machine empil√©e, bas√©e sur une composition mono√Ødale, dans le seul but de voir si cette id√©e fonctionne pour moi, j'ai imm√©diatement √©t√© boulevers√© de constater que l'impl√©mentation fonctionnait brillamment, mais terriblement inefficacement!  C‚Äôest comme si j‚Äôallais vraiment l‚Äôutiliser pour des t√¢ches s√©rieuses, ou pour vendre ma machine empil√©e sur le m√™me march√© o√π les machines virtuelles Python ou Java sont propos√©es.  Mais bon sang, l'article sur le porcelet avec lequel toute cette conversation a commenc√© donne des chiffres aussi savoureux: des centaines de millisecondes pour le porcelet, des secondes pour Python ... et mon beau mono√Øde ne peut pas faire face √† la m√™me t√¢che en une heure!  Je dois r√©ussir!  Mon microscope pr√©parera un expresso pas pire qu'une machine √† caf√© dans le couloir de l'institut!  Le Crystal Palace peut √™tre dispers√© et lanc√© dans l'espace! </p><br><p>  Mais qu'√™tes-vous pr√™t √† abandonner, me demande l'ange math√©maticien?  La puret√© et la transparence de l'architecture du palais?  La flexibilit√© et l'extensibilit√© que les homomorphismes des programmes vers d'autres solutions offrent?  Le d√©mon et l'ange sont tous deux t√™tus, et le sage tao√Øste, que je me permets √©galement de vivre, a propos√© de prendre le chemin qui leur convient et de le suivre le plus longtemps possible.  Cependant, non dans le but d'identifier le vainqueur, mais afin de conna√Ætre le chemin lui-m√™me, de savoir jusqu'o√π il m√®ne et d'acqu√©rir une nouvelle exp√©rience.  Et j'ai donc connu la tristesse et la joie vaines de l'optimisation. </p><br><p> Avant de commencer, nous ajoutons que les comparaisons de <em>langues</em> en termes d'efficacit√© sont inutiles.  Vous devez comparer les traducteurs (interpr√®tes ou compilateurs) ou les performances d'un programmeur qui utilise la langue.  Au final, l'affirmation selon laquelle les programmes C sont les plus rapides est facile √† r√©futer en √©crivant un interpr√©teur C complet en BASIC, par exemple.  Donc, nous ne comparons pas Haskell et javascript, mais les performances des programmes ex√©cut√©s par un traducteur compil√© par <code>ghc</code> et des programmes ex√©cut√©s, disons, dans un navigateur particulier.  Toute la terminologie porcine provient d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> inspirant sur les machines empil√©es.  Tout le code Haskell accompagnant l'article peut √™tre √©tudi√© dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©f√©rentiel</a> . </p><br><h3 id="vyhodim-iz-zony-komforta">  Nous quittons la zone de confort </h3><br><p>  La position de d√©part sera la mise en ≈ìuvre d'une machine de pile mono√Ødale sous la forme d' <abbr title="Langage orient√© domaine int√©gr√©">EDSL</abbr> - un petit langage simple qui permet de combiner deux douzaines de primitives pour rendre les programmes d'une machine de pile virtuelle.  D√®s qu'il est entr√© dans le deuxi√®me article, nous lui donnons le nom <code>monopig</code> .  Il est bas√© sur le fait que les langages pour les machines empil√©es forment un <em>mono√Øde</em> avec une op√©ration de concat√©nation et une op√©ration vide en tant qu'unit√©.  En cons√©quence, il a lui-m√™me √©t√© construit sous la forme d'une transformation mono√Øde de l'√©tat de la machine.  L'√©tat comprend une pile, une m√©moire sous forme de vecteur (une structure fournissant un acc√®s al√©atoire aux √©l√©ments), un indicateur d'arr√™t d'urgence et une batterie mono√Ødale pour accumuler des informations de d√©bogage.  Toute cette structure est transmise le long d'une cha√Æne d'endomorphismes d'une op√©ration √† l'autre, r√©alisant un processus de calcul.  Une structure isomorphe <em>de codes de</em> programme a √©t√© construite √† partir de la structure que les programmes forment, et √† partir de celle-ci des homomorphismes en d'autres structures utiles repr√©sentant les exigences du programme en termes de nombre d'arguments et de m√©moire.  La derni√®re √©tape de la construction a √©t√© la cr√©ation de mono√Ødes de transformation dans la cat√©gorie Claysley, qui vous permettent d'immerger les calculs dans une monade arbitraire.  La machine a donc les capacit√©s d'entr√©es-sorties et de calculs ambigus.  Nous allons commencer par cette impl√©mentation.  Son code se trouve <a href="">ici</a> . </p><br><p>  Nous testerons l'efficacit√© du programme sur l'impl√©mentation na√Øve du tamis d'Eratosth√®ne, qui remplit la m√©moire (tableau) de z√©ros et de uns, d√©notant les nombres premiers par z√©ro.  Nous donnons le code proc√©dural de l'algorithme en <code>javascript</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> memSize = <span class="hljs-number"><span class="hljs-number">65536</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; memSize; i++) arr.push(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sieve</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n*n &lt; memSize) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!arr[n]) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k = n; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (k &lt; memSize) { k+=n; arr[k] = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } n++; } }</code> </pre> <br><p>  L'algorithme est imm√©diatement l√©g√®rement optimis√©.  Il √©limine la mauvaise marche √† travers les cellules m√©moire d√©j√† remplies.  Mon ange math√©maticien n'a pas accept√© une version <em>vraiment</em> na√Øve d'un exemple du projet <code>PorosenokVM</code> , car cette optimisation ne co√ªte que cinq instructions du langage de pile.  Voici comment l'algorithme se traduit par <code>monopig</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">sieve</span></span> = push <span class="hljs-number"><span class="hljs-number">2</span></span> &lt;&gt; while (dup &lt;&gt; dup &lt;&gt; mul &lt;&gt; push memSize &lt;&gt; lt) (dup &lt;&gt; get &lt;&gt; branch mempty fill &lt;&gt; inc) &lt;&gt; pop fill = dup &lt;&gt; dup &lt;&gt; add &lt;&gt; while (dup &lt;&gt; push memSize &lt;&gt; lt) (dup &lt;&gt; push <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&gt; swap &lt;&gt; put &lt;&gt; exch &lt;&gt; add) &lt;&gt; pop</code> </pre> <br><p>  Et voici comment vous pouvez √©crire une impl√©mentation √©quivalente de cet algorithme sur le Haskell idiomatique, en utilisant les m√™mes types que dans <code>monopig</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">sieve'</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> sieve' km | k*k &lt; memSize = sieve' (k+<span class="hljs-number"><span class="hljs-number">1</span></span>) $ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m ! k == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> fill' k (<span class="hljs-number"><span class="hljs-number">2</span></span>*k) m <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> m | otherwise = m fill' :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> fill' knm | n &lt; memSize = fill' k (n+k) $ m // [(n,<span class="hljs-number"><span class="hljs-number">1</span></span>)] | otherwise = m</code> </pre> <br><p>  Il utilise le type <code>Data.Vector</code> et des outils pour travailler avec, qui ne sont pas trop courants pour le travail quotidien dans Haskell.  Expression <code>m ! k</code>  <code>m ! k</code> renvoie le <code>m ! k</code> -√®me √©l√©ment du vecteur <code>m</code> et <code>m // [(n,1)]</code> - d√©finit l'√©l√©ment avec le nombre <code>n</code> √† 1. J'√©cris ceci ici parce que je devais leur demander de l'aide, m√™me si je travaille √† Haskell presque tous les jours.  Le fait est que les structures √† acc√®s al√©atoire dans une impl√©mentation fonctionnelle sont inefficaces et pour cette raison mal aim√©es. </p><br><p>  Selon les conditions de comp√©tition sp√©cifi√©es dans l'article sur le porcelet, l'algorithme est ex√©cut√© 100 fois.  Et pour se d√©barrasser d'un ordinateur sp√©cifique, comparons les vitesses d'ex√©cution de ces trois programmes, en les r√©f√©rant aux performances du programme <code>javascript</code> qui a √©t√© ex√©cut√© dans Chrome. </p><br><p><img src="https://habrastorage.org/webt/ir/hi/mj/irhimjjtdgec7vw1vduvivmzonm.png"></p><br><p>  Horreur horreur !!!  Non seulement <code>monopig</code> ralentit impie, mais la version native n'est pas beaucoup mieux!  Haskell, bien s√ªr, est cool, mais pas tellement inf√©rieur √† un programme fonctionnant dans un navigateur?!  Comme nous l‚Äôenseignent les entra√Æneurs, vous ne pouvez pas vivre comme √ßa, il est temps de quitter la zone de confort que Haskell nous offre! </p><br><h3 id="preodolevaem-len">  Surmonter la paresse </h3><br><p>  Faisons les choses correctement.  Pour ce faire, compilez un programme sur <code>monopig</code> avec l'indicateur <code>-rtsopts</code> pour garder une <code>-rtsopts</code> statistiques d'ex√©cution et voir ce dont nous avons besoin pour ex√©cuter le tamis Eratosthenes une fois: </p><br><pre> <code class="plaintext hljs">$ ghc -O -rtsopts ./Monopig4.hs [1 of 1] Compiling Main ( Monopig4.hs, Monopig4.o ) Linking Monopig4 ... $ ./Monopig4 -RTS -sstderr "Ok" 68,243,040,608 bytes allocated in the heap 6,471,530,040 bytes copied during GC 2,950,952 bytes maximum residency (30667 sample(s)) 42,264 bytes maximum slop 15 MB total memory in use (7 MB lost due to fragmentation) Tot time (elapsed) Avg pause Max pause Gen 0 99408 colls, 0 par 2.758s 2.718s 0.0000s 0.0015s Gen 1 30667 colls, 0 par 57.654s 57.777s 0.0019s 0.0133s INIT time 0.000s ( 0.000s elapsed) MUT time 29.008s ( 29.111s elapsed) GC time 60.411s ( 60.495s elapsed) &lt;--   ! EXIT time 0.000s ( 0.000s elapsed) Total time 89.423s ( 89.607s elapsed) %GC time 67.6% (67.5% elapsed) Alloc rate 2,352,591,525 bytes per MUT second Productivity 32.4% of total user, 32.4% of total elapsed</code> </pre> <br><p>  La derni√®re ligne nous indique que le programme n'√©tait engag√© dans l'informatique productive qu'un tiers du temps.  Pour le reste du temps, le garbage collector a couru de la m√©moire et nettoy√© pour les calculs paresseux.  Combien de fois nous a-t-on dit dans l'enfance que la paresse n'est pas bonne!  Ici, la principale caract√©ristique de Haskell nous a rendu un mauvais service, essayant de cr√©er plusieurs milliards de transformations vectorielles et empil√©es diff√©r√©es. </p><br><p>  √Ä ce stade, un ange math√©maticien l√®ve le doigt et parle avec bonheur du fait que depuis l'√©poque d'Alonzo Church, il existe un th√©or√®me selon lequel la strat√©gie de calcul n'affecte pas leur r√©sultat, ce qui signifie que nous sommes libres de le choisir pour des raisons d'efficacit√©.  Changer les calculs en strict n'est pas difficile du tout - mettez un signe <code>!</code>  dans la d√©claration du type de pile et de m√©moire, et ainsi rendre ces champs stricts. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Stack</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">status</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">memory</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Memory</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">journal</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  Nous ne changerons rien d'autre et v√©rifierons imm√©diatement le r√©sultat: </p><br><pre> <code class="plaintext hljs">$ ./Monopig41 +RTS -sstderr "Ok" 68,244,819,008 bytes allocated in the heap 7,386,896 bytes copied during GC 528,088 bytes maximum residency (2 sample(s)) 25,248 bytes maximum slop 16 MB total memory in use (14 MB lost due to fragmentation) Tot time (elapsed) Avg pause Max pause Gen 0 129923 colls, 0 par 0.666s 0.654s 0.0000s 0.0001s Gen 1 2 colls, 0 par 0.001s 0.001s 0.0006s 0.0007s INIT time 0.000s ( 0.000s elapsed) MUT time 13.029s ( 13.048s elapsed) GC time 0.667s ( 0.655s elapsed) EXIT time 0.001s ( 0.001s elapsed) Total time 13.700s ( 13.704s elapsed) %GC time 4.9% (4.8% elapsed) Alloc rate 5,238,049,412 bytes per MUT second Productivity 95.1% of total user, 95.1% of total elapsed</code> </pre> <br><p>  La productivit√© a consid√©rablement augment√©.  Le co√ªt total de la m√©moire est rest√© impressionnant en raison de l'immuabilit√© des donn√©es, mais surtout, maintenant que nous avons limit√© la paresse des donn√©es, le garbage collector a la possibilit√© d'√™tre paresseux, seulement 5% du travail reste dessus.  Entrez une nouvelle entr√©e dans la note. </p><br><p><img src="https://habrastorage.org/webt/6z/z4/6j/6zz46jgmso3w95efydonusy8pok.png"></p><br><p>  Eh bien, des calculs rigoureux nous ont rapproch√©s de la vitesse du code natif Haskell, qui ralentit honteusement sans aucune machine virtuelle.  Cela signifie que les frais g√©n√©raux li√©s √† l'utilisation d'un vecteur immuable d√©passent <em>consid√©rablement</em> le co√ªt de maintenance d'une machine empil√©e.  Et cela signifie qu'il est temps de dire au revoir √† l'immuabilit√© de la m√©moire. </p><br><h3 id="vpuskaem-izmeneniya-v-zhizn">  Laisser les changements prendre vie </h3><br><p>  Le type <code>Data.Vector</code> bon, mais en l'utilisant, nous passons beaucoup de temps √† copier, au nom de la pr√©servation de la puret√© du processus informatique.  En le rempla√ßant par le type <code>Data.Vector.Unpacked</code> nous √©conomisons au moins sur l'emballage de la structure, mais cela ne change pas fondamentalement l'image.  La bonne solution serait de supprimer la m√©moire de l'√©tat de la machine et de donner acc√®s au vecteur externe en utilisant la cat√©gorie Kleisley.  En m√™me temps, avec des vecteurs purs, vous pouvez utiliser les vecteurs dits mutables (mutables) <code>Data.Vector.Mutable</code> . </p><br><p>  Nous allons connecter les modules appropri√©s et r√©fl√©chir √† la fa√ßon de traiter les donn√©es mutables dans un programme fonctionnel propre. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad.Primitive <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Vector.Unboxed <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> V <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Vector.Unboxed.Mutable <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> M</code> </pre> <br><p>  Ces types sales sont cens√©s √™tre isol√©s du pur public.  Ils sont contenus dans les monades de la classe <code>PrimMonad</code> (celles-ci incluent <code>ST</code> ou <code>IO</code> ), o√π des programmes propres ins√®rent soigneusement des instructions pour des actions √©crites dans un langage fonctionnel cristallin sur un parchemin pr√©cieux.  Ainsi, le comportement de ces animaux impurs est d√©termin√© par des sc√©narios strictement orthodoxes et n'est pas dangereux.  Tous les programmes de notre machine n'utilisent pas de m√©moire, il n'est donc pas n√©cessaire de condamner toute l'architecture √† l'immersion dans la monade <code>IO</code> .  Parall√®lement √† un sous-ensemble propre du langage <code>monopig</code> nous cr√©erons quatre instructions qui donnent acc√®s √† la m√©moire, et seules elles auront acc√®s au territoire dangereux. </p><br><p>  Le type de machine propre se raccourcit: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Stack</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">status</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">journal</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  Les concepteurs de programmes et les programmes eux-m√™mes ne remarqueront gu√®re ce changement, mais leurs types changeront.  De plus, il est logique de d√©finir plusieurs types de synonymes pour simplifier les signatures. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Memory</span></span></span><span class="hljs-class"> m = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">M</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MVector</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PrimState</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Logger</span></span></span><span class="hljs-class"> ma = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Memory</span></span></span><span class="hljs-class"> m -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Code</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> a -&gt; m (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program'</span></span></span><span class="hljs-class"> ma = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Logger</span></span></span><span class="hljs-class"> ma -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Memory</span></span></span><span class="hljs-class"> m -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program</span></span></span><span class="hljs-class"> ma</span></span></code> </pre> <br><p>  Les constructeurs auront un autre argument repr√©sentant l'acc√®s √† la m√©moire.  Les ex√©cuteurs changeront consid√©rablement, en particulier ceux qui conservent un journal de calcul, car ils doivent maintenant demander l'√©tat du vecteur variable pour cela.  Le <a href="">code</a> complet peut √™tre vu et √©tudi√© dans le r√©f√©rentiel, mais ici je donnerai le plus int√©ressant: l'impl√©mentation des composants de base pour travailler avec la m√©moire pour montrer comment cela est fait. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">geti</span></span> :: <span class="hljs-type"><span class="hljs-type">PrimMonad</span></span> m =&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Program'</span></span> ma geti i = programM (<span class="hljs-type"><span class="hljs-type">GETI</span></span> i) $ \mem -&gt; \s -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= i &amp;&amp; i &lt; memSize) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x &lt;- <span class="hljs-type"><span class="hljs-type">M</span></span>.unsafeRead mem i setStack (x:s) vm <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> err <span class="hljs-string"><span class="hljs-string">"index out of range"</span></span> puti :: <span class="hljs-type"><span class="hljs-type">PrimMonad</span></span> m =&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Program'</span></span> ma puti i = programM (<span class="hljs-type"><span class="hljs-type">PUTI</span></span> i) $ \mem -&gt; \<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (x:s) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= i &amp;&amp; i &lt; memSize) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>.unsafeWrite mem ix setStack s vm <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> err <span class="hljs-string"><span class="hljs-string">"index out of range"</span></span> _ -&gt; err <span class="hljs-string"><span class="hljs-string">"expected an element"</span></span> get :: <span class="hljs-type"><span class="hljs-type">PrimMonad</span></span> m =&gt; <span class="hljs-type"><span class="hljs-type">Program'</span></span> ma get = programM (<span class="hljs-type"><span class="hljs-type">GET</span></span>) $ \m -&gt; \<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (i:s) -&gt; \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x &lt;- <span class="hljs-type"><span class="hljs-type">M</span></span>.read mi setStack (x:s) vm _ -&gt; err <span class="hljs-string"><span class="hljs-string">"expected an element"</span></span> put :: <span class="hljs-type"><span class="hljs-type">PrimMonad</span></span> m =&gt; <span class="hljs-type"><span class="hljs-type">Program'</span></span> ma put = programM (<span class="hljs-type"><span class="hljs-type">PUT</span></span>) $ \m -&gt; \<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (i:x:s) -&gt; \vm -&gt; <span class="hljs-type"><span class="hljs-type">M</span></span>.write mix &gt;&gt; setStack s vm _ -&gt; err <span class="hljs-string"><span class="hljs-string">"expected two elemets"</span></span></code> </pre> <br><p>  Le d√©mon optimiseur a imm√©diatement propos√© d'√©conomiser un peu plus sur la v√©rification des valeurs d'index autoris√©es en m√©moire, car pour les <code>geti</code> <code>puti</code> et <code>geti</code> indices sont connus au stade de la cr√©ation du programme et les valeurs incorrectes peuvent √™tre √©limin√©es √† l'avance.  Les index d√©finis dynamiquement pour les commandes <code>put</code> et <code>get</code> ne garantissent pas la s√©curit√©, et l'ange math√©maticien n'a pas permis de leur faire des appels dangereux. </p><br><p>  Tout ce tapage avec la mise en m√©moire dans un argument s√©par√© semble compliqu√©.  Mais cela montre tr√®s clairement que les donn√©es doivent √™tre modifi√©es √† leur place - <em>elles devraient √™tre √† l'ext√©rieur</em> .  Je vous rappelle que nous essayons d'amener un livreur de pizza dans un laboratoire st√©rile.  Les fonctions pures savent quoi en faire, mais ces objets ne deviendront jamais des citoyens de premi√®re classe, et cela ne vaut pas la peine de pr√©parer une pizza directement dans le laboratoire. </p><br><p>  V√©rifions ce que nous avons achet√© avec ces changements: </p><br><pre> <code class="plaintext hljs">$ ./Monopig5 +RTS -sstderr "Ok" 9,169,192,928 bytes allocated in the heap 2,006,680 bytes copied during GC 529,608 bytes maximum residency (2 sample(s)) 25,248 bytes maximum slop 2 MB total memory in use (0 MB lost due to fragmentation) Tot time (elapsed) Avg pause Max pause Gen 0 17693 colls, 0 par 0.094s 0.093s 0.0000s 0.0001s Gen 1 2 colls, 0 par 0.000s 0.000s 0.0002s 0.0003s INIT time 0.000s ( 0.000s elapsed) MUT time 7.228s ( 7.232s elapsed) GC time 0.094s ( 0.093s elapsed) EXIT time 0.000s ( 0.000s elapsed) Total time 7.325s ( 7.326s elapsed) %GC time 1.3% (1.3% elapsed) Alloc rate 1,268,570,828 bytes per MUT second Productivity 98.7% of total user, 98.7% of total elapsed</code> </pre> <br><p>  C'est d√©j√† du progr√®s!  L'utilisation de la m√©moire a √©t√© r√©duite huit fois, la vitesse d'ex√©cution du programme a augment√© de 180 fois et le garbage collector est rest√© presque compl√®tement sans travail. </p><br><p><img src="https://habrastorage.org/webt/o7/cw/f8/o7cwf8ptddtz8x1gdy0lunionis.png"></p><br><p>  La solution est apparue <em>monopig st.</em>  <em>mut.</em>  , qui est dix fois plus lent que la solution native sur <code>js</code> , mais √† part cela, la solution native sur Haskell, en utilisant des vecteurs mutables.  Voici son code: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fill'</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Memory</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> (<span class="hljs-type"><span class="hljs-type">Memory</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span>) fill' knm | n &gt; memSize-k = return m | otherwise = <span class="hljs-type"><span class="hljs-type">M</span></span>.unsafeWrite mn <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt; fill' k (n+k) m sieve' :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Memory</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> (<span class="hljs-type"><span class="hljs-type">Memory</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span>) sieve' km | k*k &lt; memSize = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x &lt;- <span class="hljs-type"><span class="hljs-type">M</span></span>.unsafeRead mk <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> fill' k (<span class="hljs-number"><span class="hljs-number">2</span></span>*k) m &gt;&gt;= sieve' (k+<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sieve' (k+<span class="hljs-number"><span class="hljs-number">1</span></span>) m | otherwise = return m</code> </pre> <br><p>  Cela commence comme suit </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> m &lt;- <span class="hljs-type"><span class="hljs-type">M</span></span>.replicate memSize <span class="hljs-number"><span class="hljs-number">0</span></span> stimes <span class="hljs-number"><span class="hljs-number">100</span></span> (sieve' <span class="hljs-number"><span class="hljs-number">2</span></span> m &gt;&gt; return ()) print <span class="hljs-string"><span class="hljs-string">"Ok"</span></span></code> </pre> <br><p>  Et maintenant, Haskell montre enfin qu'il n'est pas un langage jouet.  Vous avez juste besoin de l'utiliser √† bon escient.  Par ailleurs, le code ci-dessus utilise le fait que le type <code>IO ()</code> forme un semi-groupe avec l'op√©ration d'ex√©cution s√©quentielle des programmes <code>(&gt;&gt;)</code> , et √† l'aide de <code>stimes</code> nous avons r√©p√©t√© 100 fois le calcul du probl√®me de test. </p><br><p>  Maintenant, il est clair pourquoi il y a une telle aversion pour les tableaux fonctionnels et pourquoi personne ne se souvient comment travailler avec eux: d√®s qu'un programmeur Haskell a vraiment besoin de structures d'acc√®s al√©atoire, il se recentre sur les donn√©es mutables et travaille dans les monades ST ou IO. </p><br><p>  Mettre une partie des commandes dans une zone sp√©ciale remet en cause la l√©galit√© de l'isomorphisme <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="20.072ex" height="2.419ex" viewBox="0 -780.1 8642 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMATHI-6C" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMATHI-6F" x="548" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMATHI-6E" x="1034" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMATHI-67" x="1634" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMATHI-6C" x="2115" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMATHI-65" x="2413" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMATHI-66" x="2880" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMATHI-74" x="3430" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMATHI-72" x="3792" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMATHI-69" x="4243" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMATHI-67" x="4589" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMATHI-68" x="5069" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMATHI-74" x="5646" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMATHI-61" x="6007" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMATHI-72" x="6537" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMATHI-72" x="6988" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMATHI-6F" x="7440" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMATHI-77" x="7925" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math></span></span><script type="math/tex" id="MathJax-Element-2"> \ longleftrightarrow </script>  <em>le programme</em> .  Apr√®s tout, nous ne pouvons pas simultan√©ment transformer le code en programmes purs et monadiques, cela ne permet pas au syst√®me de type de le faire.  Cependant, les classes de types sont suffisamment flexibles pour que cet isomorphisme existe.  <em>Code d'</em> homomorphisme <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="16.177ex" height="2.419ex" viewBox="0 -780.1 6965 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMATHI-6C" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMATHI-6F" x="548" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMATHI-6E" x="1034" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMATHI-67" x="1634" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMATHI-72" x="2115" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMATHI-69" x="2566" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMATHI-67" x="2912" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMATHI-68" x="3392" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMATHI-74" x="3969" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMATHI-61" x="4330" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMATHI-72" x="4860" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMATHI-72" x="5311" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMATHI-6F" x="5763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMATHI-77" x="6248" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math></span></span><script type="math/tex" id="MathJax-Element-3"> \ longrightarrow </script>  <em>le programme est</em> maintenant divis√© en plusieurs homomorphismes pour diff√©rents sous-ensembles de la langue.  Comment exactement cela est fait peut √™tre vu dans le [code] () complet du programme. </p><br><h3 id="ne-ostanavlivaysya-na-dostignutom">  Ne vous arr√™tez pas l√† </h3><br><p>  L'√©limination des appels de fonction inutiles et l'int√©gration directe de leur code √† l'aide du pragma <code>{-# INLINE #-}</code> aideront √† modifier l√©g√®rement la productivit√© du programme.  Cette m√©thode ne convient pas aux fonctions r√©cursives, mais est id√©ale pour les composants de base et les fonctions de d√©finition.  Il r√©duit le temps d'ex√©cution du programme de test de 25% <a href="">suppl√©mentaires</a> (voir <a href="">Monopig51.hs</a> ). </p><br><p><img src="https://habrastorage.org/webt/0k/-l/hu/0k-lhu49_zsiihqoom7c5g0ize8.png"></p><br><p>  La prochaine √©tape raisonnable sera de se d√©barrasser des outils de journalisation lorsqu'ils ne sont pas n√©cessaires.  Au stade de la formation de l'endomorphisme repr√©sentant le programme, nous utilisons un argument externe, que nous d√©terminons au d√©marrage.  Le <code>program</code> constructeurs intelligents et <code>programM</code> peuvent √™tre avertis qu'il peut n'y avoir aucun enregistreur d'arguments.  Dans ce cas, le code convertisseur ne contient rien de superflu: uniquement la fonctionnalit√© et la v√©rification de l'√©tat de la machine. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">program</span></span> code f = programM code (const f) programM code f (<span class="hljs-type"><span class="hljs-type">Just</span></span> logger) mem = <span class="hljs-type"><span class="hljs-type">Program</span></span> . ([code],) . <span class="hljs-type"><span class="hljs-type">ActionM</span></span> $ \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> status vm <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; logger mem code =&lt;&lt; f mem (stack vm) vm _ -&gt; return vm programM code f _ mem = <span class="hljs-type"><span class="hljs-type">Program</span></span> . ([code],) . <span class="hljs-type"><span class="hljs-type">ActionM</span></span> $ \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> status vm <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; f mem (stack vm) vm _ -&gt; return vm</code> </pre> <br><p>  D√©sormais, l'ex√©cution des fonctions doit indiquer explicitement la pr√©sence ou l'absence de journalisation non pas en utilisant le stub <code>none</code> , mais en utilisant le type <code>Maybe (Logger ma)</code> .  Pourquoi cela devrait-il fonctionner, car s'il y a une journalisation ou non, les composants du programme le sauront "au dernier moment", avant l'ex√©cution?  Le code inutile ne serait-il pas cousu au stade de la composition de la programmation?  Haskell est une langue paresseuse et ici elle joue entre nos mains.  C'est avant l'ex√©cution que le code final est optimis√© pour une t√¢che sp√©cifique.  Cette optimisation a r√©duit le temps d'ex√©cution du programme de 40% <a href="">suppl√©mentaires</a> (voir <a href="">Monopig52.hs</a> ). </p><br><p><img src="https://habrastorage.org/webt/co/gd/vy/cogdvyw-zsyliuiwsmhxs5gadhe.png"></p><br><p>  Avec cela, nous terminerons les travaux sur l'acc√©l√©ration du porcelet mono√Øde.  Il court d√©j√† assez vite pour que l'ange et le d√©mon puissent se calmer.  Bien s√ªr, ce n'est pas C, nous utilisons toujours une liste propre comme pile, mais le remplacer par un tableau entra√Ænera une fouille approfondie du code et le refus d'utiliser des mod√®les √©l√©gants dans les d√©finitions des commandes de base.  Je voulais m'en sortir avec un minimum de changements, et principalement au niveau des types. </p><br><p>  Certains probl√®mes persistent avec la journalisation.  Un simple d√©compte du nombre d'√©tapes ou de l'utilisation de la pile fonctionne bien (nous avons rendu le champ de journal strict), mais leur association commence d√©j√† √† consommer de la m√©moire, vous devez jouer avec les coups de pied en utilisant <code>seq</code> , ce qui est d√©j√† assez ennuyeux.  Mais dites-moi, qui enregistrera les 14 milliards d'√©tapes, si vous pouvez d√©boguer la t√¢che dans les premi√®res centaines?  Je ne passerai donc pas mon temps √† acc√©l√©rer pour acc√©l√©rer. </p><br><p>  Il ne reste plus qu'√† ajouter que dans l'article sur le porcelet, comme l'une des m√©thodes d'optimisation des calculs, le tra√ßage est donn√©: l'allocation des sections lin√©aires de code, les <em>traces √† l'</em> int√©rieur desquelles les calculs peuvent √™tre effectu√©s en contournant le cycle de r√©partition des commandes principales (bloc de <code>switch</code> ).  Dans notre cas, la composition mono√Ødale des composants du programme cr√©e de telles traces soit lors de la formation du programme √† partir des composants EDSL, soit lors du fonctionnement de l'homomorphisme <code>fromCode</code> .  Cette m√©thode d'optimisation nous est gratuite, pour ainsi dire, par construction. </p><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mo>&amp;#x2217;</mo><mtext>&amp;#xA0;</mtext><mo>&amp;#x2217;</mo><mtext>&amp;#xA0;</mtext><mo>&amp;#x2217;</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.681ex" height="1.335ex" viewBox="0 -520.7 2445.9 574.6" role="img" focusable="false" style="vertical-align: -0.125ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMAIN-2217" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMAIN-2217" x="972" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiHdeaG5Yq2QLDDBltLoVzy5coSRQ#MJMAIN-2217" x="1945" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>‚àó</mo><mtext>&nbsp;</mtext><mo>‚àó</mo><mtext>&nbsp;</mtext><mo>‚àó</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-4"> * \ * \ * </script></p><br><p>  Il existe de nombreuses solutions <code>Conduits</code> et rapides dans l'√©cosyst√®me Haskell, telles que les flux de <code>Conduits</code> ou de <code>Pipes</code> , il existe d'excellents remplacements de <code>String</code> et des cr√©ateurs XML agiles tels que blaze-html, et l'analyseur <code>attoparsec</code> est une norme pour l'analyse combinatoire des grammaires LL (‚àû).  Tout cela est n√©cessaire pour un fonctionnement normal.  Mais la recherche menant √† ces d√©cisions est encore plus n√©cessaire.  Haskell a √©t√© et demeure un outil de recherche qui r√©pond √† des exigences sp√©cifiques dont le grand public n'a pas besoin.  J'ai vu au Kamchatka comment les as d'un h√©licopt√®re Mi-4 ont ferm√© les bo√Ætes d'allumettes lors d'une dispute, poussant le train d'atterrissage avec une roue tout en √©tant suspendu en l'air.  Cela peut √™tre fait, et c'est cool, mais pas n√©cessaire. </p><br><p>  Mais, n√©anmoins, c'est cool !! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430956/">https://habr.com/ru/post/fr430956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430944/index.html">La NASA a choisi les participants pour sa comp√©tition de mini-moon rover</a></li>
<li><a href="../fr430948/index.html">Le minist√®re des Communications propose de renforcer le contr√¥le des donn√©es personnelles</a></li>
<li><a href="../fr430950/index.html">Faire une construction moderne</a></li>
<li><a href="../fr430952/index.html">Les voitures √©lectriques et les voitures hybrides devront √©mettre des sons suppl√©mentaires: pourquoi est-ce n√©cessaire</a></li>
<li><a href="../fr430954/index.html">Qt Everywhere: WebAssembly et WebGL Streaming</a></li>
<li><a href="../fr430958/index.html">Nous lan√ßons le conteneur avec des tests unitaires dans Azure DevOps (VSTS)</a></li>
<li><a href="../fr430960/index.html">√Ä propos de gamedev √† partir d'une exposition sur ordinateur</a></li>
<li><a href="../fr430962/index.html">Prise en charge de Razor dans Visual Studio Code</a></li>
<li><a href="../fr430964/index.html">Pens√©e d√©clarative</a></li>
<li><a href="../fr430966/index.html">Sprints g√©n√©raux chez Atlassian Jira Software</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>