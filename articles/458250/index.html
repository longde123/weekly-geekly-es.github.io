<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úçüèæ üë∑üèª üï∂Ô∏è BTRFS para los m√°s peque√±os üíØ üë©‚Äçüöí üÜò</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Buen d√≠a, Khabravchane. Trabajo en Veeam Software y soy uno de los desarrolladores de nuestra soluci√≥n de respaldo de Linux. Por ocupaci√≥n, me encontr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>BTRFS para los m√°s peque√±os</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/veeam/blog/458250/"> Buen d√≠a, Khabravchane.  Trabajo en Veeam Software y soy uno de los desarrolladores de nuestra soluci√≥n de respaldo de Linux.  Por ocupaci√≥n, me encontr√© con BTRFS.  M√°s recientemente, pas√≥ del estado de "a√∫n no adecuado" al estado de "estable".  Y mientras sus primeros usuarios en la red discut√≠an √°reas problem√°ticas y problemas de estabilidad, en Veeam lo empujamos con una varita e intentamos hacer una copia de seguridad.  Result√≥, por decirlo suavemente, no mucho: es demasiado diferente, no como los sistemas de archivos tradicionales.  Tuve que estudiar muchos aspectos y recolectar muchos rastrillos antes de aprender a trabajar con ellos.  En el proceso de aprendizaje, BTRFS logr√≥ impresionarme, tanto en el buen sentido como no tanto.  Estoy seguro de que no dejar√° indiferente a ning√∫n especialista en TI del mundo Linux: algunos escupir√°n, otros elogiar√°n. <br><br>  Si has o√≠do hablar de este sistema de archivos, pero no sabes por qu√©, si est√°s interesado en los detalles o est√°s buscando d√≥nde empezar a conocerlo, te invito a que te contacte. <br><a name="habracut"></a><br><h1>  Introduccion </h1><br>  BTRFS (B-Tree Filesystem): sistema de archivos para sistemas operativos tipo Unix, basado en la t√©cnica Copy on Write (CoW), dise√±ado para facilitar la escala del sistema de archivos, un alto grado de confiabilidad y seguridad de los datos, flexibilidad de configuraci√≥n y facilidad de administraci√≥n, mientras se mantiene Al mismo tiempo de alta velocidad.  Al menos eso es lo que dice la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">p√°gina wiki principal</a> . <br><br>  Para cumplir con las formalidades, enumeramos las caracter√≠sticas principales de btrfs: <br><br><ul><li>  Tama√±o m√°ximo de archivo 2 ^ 64 bytes <br></li><li>  Mesa din√°mica de inodo <br></li><li>  Deduplicaci√≥n de datos <br></li><li>  Almacenamiento efectivo de archivos de tama√±os muy peque√±os y muy grandes <br></li><li>  Crear subwolums e instant√°neas <br></li><li>  Cuotas de subvolumen <br></li><li>  Sumas de verificaci√≥n para datos y metadatos <br></li><li>  La capacidad de combinar m√∫ltiples unidades en un solo sistema de archivos <br></li><li>  Crear una configuraci√≥n RAID a nivel del sistema de archivos <br></li><li>  Compresi√≥n de datos <br></li><li>  Desfragmentar datos sobre la marcha <br></li></ul><br>  Quiero advertirle de inmediato que BTRFS se est√° desarrollando activamente, y algunos puntos pueden diferir de una versi√≥n a otra.  El enlace: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://btrfs.wiki.kernel.org/index.php/Changelog,</a> puede averiguar cu√°ndo se agreg√≥, modific√≥ o arregl√≥ la funcionalidad. <br><br>  S√≠, BTRFS es un sistema de archivos joven y moderno que resuelve una amplia gama de tareas, pero no sin sus inconvenientes: <br><br><ul><li>  Su desarrollo activo conduce a un cambio en cualquier punto clave en el que las utilidades de terceros puedan confiar al trabajar con √©l. <br></li><li>  A pesar de las garant√≠as de los desarrolladores sobre la estabilidad de BTRFS, los usuarios regularmente encuentran problemas que pueden conducir a la p√©rdida de datos.  Como regla, son de naturaleza "flotante", por lo que a√∫n no han sido estudiados y corregidos. <br></li><li>  Alta susceptibilidad a la fragmentaci√≥n. <br></li><li>  Documentaci√≥n escasa ya veces desactualizada. <br></li></ul><br>  Una p√°gina completa est√° dedicada a los problemas del sistema de archivos en diferentes versiones de los n√∫cleos: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://btrfs.wiki.kernel.org/index.php/Gotchas</a> .  Le recomiendo encarecidamente que mire all√≠: resulta muy interesante y no obvio. <br><br><h1>  Estructura BTRFS </h1><br>  El dispositivo BTRFS simplificado se puede dividir en los siguientes niveles: <br><br><img src="https://habrastorage.org/webt/zz/n8/zj/zzn8zjyt0dai6ge9rifhgcdwg0q.png"><br><br>  Los dispositivos de bloque est√°n ubicados en el nivel m√°s bajo, representando uno o m√°s espacios de direcciones f√≠sicas separados (el mismo "f√≠sico" que los dispositivos de bloque, pero estos ya son detalles).  A trav√©s de estructuras especiales, los bloques asignados de memoria f√≠sica se combinan en un solo espacio de direcci√≥n virtual. <br><br>  Las estructuras y bloques de metadatos con datos de usuario (extensiones) ya se abordan a nivel l√≥gico.  Como resultado, los datos ubicados secuencialmente a un nivel l√≥gico pueden residir f√≠sicamente en diferentes dispositivos de bloque. <br><br>  Las estructuras de metadatos se pueden dividir en niveles.  Por supuesto, no los clasificar√©, hay muchos de ellos, y esos detalles de bajo nivel son el tema de un art√≠culo separado.  Es importante aqu√≠ que algunas estructuras en la jerarqu√≠a resulten ser de mayor nivel que otras, y en la parte superior habr√° una estructura que es un subvolumen. <br><br>  Subvolumen es un tipo de punto de entrada, o m√°s bien, los elementos ra√≠z del sistema de archivos.  Forman una capa separada de representaci√≥n de datos, que encapsula el trabajo de las capas inferiores, presentando los datos del usuario en la forma habitual: directorios y archivos.  Adem√°s, los sublobos son un elemento clave del mecanismo CoW en BTRFS.  Los mismos archivos en dos subvol√∫menes pueden resultar ser el mismo conjunto de datos en los niveles inferiores. <br><br>  La √∫ltima capa es la capa de datos.  Como el usuario los ve.  Estos son archivos y directorios ubicados en subvolumen. <br><br>  Pero suficiente teor√≠a.  ¬°Es hora de pasar a practicar! <br><br><h1>  Btrfs-progs </h1><br>  Este es un conjunto est√°ndar de utilidades para administrar BTRFS.  Dependiendo del paquete de distribuci√≥n, el paquete con estas utilidades en el repositorio puede tener diferentes nombres: <b>btrfsprogs</b> , <b>btrfs-progs</b> , <b>btrfs-tools</b> , etc.  Si su repositorio no ten√≠a nada similar, siempre puede compilarlo manualmente, las fuentes no est√°n muy lejos: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/kdave/btrfs-progs</a> . <br>  Las utilidades m√°s importantes en este paquete son <b>btrfs</b> y <b>mkfs.btrfs</b> .  Desde el segundo, creo, todo est√° muy claro: es necesario crear BTRFS en un dispositivo de bloque.  Primero, <b>btrfs</b> es la utilidad principal que te permite hacer el resto.  Una especie de "cuchillo suizo". <br><br>  En este art√≠culo, utilic√© la versi√≥n v4.15.1.  La utilidad se est√° desarrollando de manera muy activa y existen diferencias notables de una versi√≥n a otra.  Entonces, si no ten√≠a el comando necesario, verifique la versi√≥n de la utilidad <b>btrfs</b> , es posible que ya no est√© actualizada. <br><br>  Adem√°s, lo m√°s probable es que las utilidades <b>btrfsck</b> y <b>btrfstune</b> se encuentren en el paquete. <br><br><ul><li>  El primero de ellos sirve para verificar el sistema de archivos en busca de errores y para correcciones posteriores, sin embargo, no recomiendo usarlo: est√° en estado <i>obsoleto</i> , su funcionalidad se ha movido al comando de <b>verificaci√≥n btrfs</b> . </li><li>  El segundo le permite realizar algunas operaciones √∫tiles en btrfs, por ejemplo, cambiar el identificador √∫nico del sistema de archivos (FS UUID) o habilitar cierta funcionalidad del sistema de archivos. </li></ul><br>  Adem√°s de las utilidades enumeradas anteriormente, hay varias utilidades m√°s en el paquete, pero son principalmente necesarias para depurar btrfs y no nos ser√°n √∫tiles en este art√≠culo. <br><br><h1>  Formatear un disco en BTRFS </h1><br>  En la pr√°ctica, todo es m√°s simple.  Comencemos con una unidad. <br>  El formateo de un solo disco en btrfs se produce con el comando habitual: <br><br><pre><code class="bash hljs">mkfs.btrfs /dev/sdc -L single_drive</code> </pre> <br>  En respuesta, la utilidad generar√° los par√°metros del sistema de archivos creado en la consola: <br><br><pre> <code class="bash hljs">btrfs-progs v4.15.1 See http://btrfs.wiki.kernel.org <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> more information. Label:       single_drive UUID:        59307d69-6d2f-4d2e-aae2-a5189ad3c256 Node size:     16384 Sector size:    4096 Filesystem size:  1.00GiB Block group profiles: Data:       single 8.00MiB Metadata:     DUP 51.19MiB System:      DUP 8.00MiB SSD detected:    no Incompat features: extref, skinny-metadata Number of devices: 1 Devices:  ID    SIZE PATH   1   1.00GiB /dev/sdc</code> </pre><br>  Veamos los par√°metros presentados. <br><br><ul><li>  <b>Etiqueta</b> : una etiqueta o nombre del sistema de archivos.  Se especifica mediante el <code>-L</code> y es un par√°metro opcional. </li><li>  <b>UUID</b> es un identificador √∫nico que hace que el n√∫cleo btrfs diferencie las instancias entre s√≠. </li><li>  <b>Tama√±o de nodo</b> : el tama√±o de los elementos del √°rbol B en el que se almacenan los metadatos.  Se puede configurar usando <code>-n | --nodesize</code>  <code>-n | --nodesize</code> , y debe ser un m√∫ltiplo del tama√±o del <b>Sector</b> .  El peque√±o tama√±o del nodo conduce a un aumento en la altura del √°rbol B (un aumento en el n√∫mero de nodos) y, como resultado, a una disminuci√≥n en la competencia por bloquear un nodo individual.  Por otro lado, el peque√±o tama√±o del nodo hace que la instancia del sistema de archivos sea m√°s propensa a la fragmentaci√≥n.  Los nodos grandes, por otro lado, contribuyen a un mejor empaquetado de metadatos en el disco, lo que reduce la fragmentaci√≥n. <br>  La desventaja es un mayor tiempo de acceso a datos para actualizar el mismo nodo mediante m√∫ltiples hilos.  En los n√∫cleos anteriores a 3.11, de forma predeterminada, el tama√±o del nodo es 16384 bytes o el tama√±o de la p√°gina de memoria del sistema operativo (el mayor de estos dos valores). </li><li>  <b>Tama√±o del sector</b> : la cantidad de espacio que es m√∫ltiplos de los cuales se asigna y libera en el nivel f√≠sico.  Es igual al tama√±o de p√°gina de la memoria virtual del sistema operativo, a menos que se especifique lo contrario con el <code>-s</code> . </li><li>  <b>Tama√±o del sistema de archivos</b> : la capacidad total del sistema de archivos (datos m√°s metadatos).  Establecido manualmente con el <code>-b</code> .  Por defecto, todo el volumen del dispositivo de bloque est√° ocupado. </li><li>  <b>Funciones incompatibles</b> : una lista de funciones incluidas en los btrfs creados que rompen la compatibilidad con versiones anteriores del kernel.  Si es necesaria la compatibilidad con versiones anteriores, puede deshabilitar: <br><br><pre> <code class="bash hljs">--features ^extref,^skinny-metadata.</code> </pre> <br>  Por cierto, puede verificar qu√© caracter√≠sticas admite el n√∫cleo actual mediante la siguiente llamada: <br><br><pre> <code class="bash hljs">mkfs.btrfs --features list-all</code> </pre> </li><li>  <b>N√∫mero de dispositivos y dispositivos</b> : cu√°ntos dispositivos de bloque est√°n involucrados en la instancia btrfs creada y una lista de todos los dispositivos, respectivamente. </li><li>  Tambi√©n deber√≠amos hablar sobre el par√°metro <b>Perfiles de grupo de bloques</b> .  Indica el perfil de registro aplicable para cada uno de los tres tipos de datos: Datos, Metadatos y Sistema.  Volviendo a la estructura generalizada de btrfs, podemos decir que: <br><br><ul><li>  Los datos son datos del usuario; </li><li>  Los metadatos son una combinaci√≥n de una capa de subvolumen y una capa de metadatos y extensiones; </li><li>  Los sistemas son estructuras para mapear el espacio de direcciones de la memoria f√≠sica en un espacio continuo de direcciones l√≥gicas. </li></ul><br>  Un perfil de grabaci√≥n es una forma de almacenar datos a nivel f√≠sico: <br><br><ul><li>  Single: almacenamiento de datos en una sola copia; </li><li>  DUP: duplicaci√≥n de datos en un medio; </li><li>  RAIDX es una de las configuraciones de RAID0, RAID1, RAID10, RAID5 y RAID6. </li></ul><br></li></ul><br>  Al marcar un dispositivo de bloque, por defecto btrfs aplicar√° duplicaci√≥n a los metadatos y datos del sistema, y ‚Äã‚Äãlos datos del usuario permanecer√°n en los medios en una sola copia.  La creaci√≥n de btrfs en varios discos a la vez aplicar√° el perfil "RAID0" a los datos del usuario de forma predeterminada, y "RAID1" a los metadatos. <br>  Este grupo de par√°metros se controla mediante dos teclas: <code>-d</code> para datos y <code>-m</code> para metadatos y datos del sistema. <br><br>  Pero hay un matiz ... Las cosas son diferentes con los SSD.  El hecho es que si estuvi√©ramos marcando una unidad SSD (o unidad flash), entonces, por defecto, el sistema de archivos no duplicar√≠a los metadatos.  Los SSD pueden extender la deduplicaci√≥n de datos para extender la vida √∫til de los elementos de memoria.  Es decir  teniendo dos copias l√≥gicas de los datos, de hecho solo se grabar√° una en el medio.  Como resultado, cuando falla un segmento de memoria, se da√±ar√°n "ambas copias" de los datos.  Adem√°s, al escribir datos dos veces, el recurso SSD simplemente se consume m√°s r√°pido. <br><br>  Para determinar el tipo de medio, btrfs verifica el contenido del archivo <i>/ sys / block / DEV / queue / rotational</i> , donde "DEV" es el nombre del dispositivo de bloque a verificar. <br>  Por supuesto, incluso en el caso de un SSD, se puede forzar el perfil de almacenamiento. <br><br>  Para crear una instancia de btrfs en varios dispositivos, solo especif√≠quelos con un espacio: <br><br><pre> <code class="bash hljs">sudo mkfs.btrfs /dev/sdc /dev/sdd -L double_drive</code> </pre> <br>  o con perfiles: <br><br><pre> <code class="bash hljs">sudo mkfs.btrfs /dev/sdc /dev/sdd -d raid1 -m raid1 -L raid1_drive</code> </pre> <br>  Cabe se√±alar que los medios no tienen que ser del mismo tama√±o, incluso si se utiliza la duplicaci√≥n completa.  Sin embargo, tan pronto como no haya suficiente espacio en la unidad m√°s peque√±a para asignar memoria, el sistema de archivos mostrar√° un mensaje que indica que no hay espacio libre, aunque f√≠sicamente todav√≠a puede haber espacio libre en otros medios. <br><br><h1>  Montaje </h1><br>  El primer montaje de btrfs reci√©n creados no es diferente de otros sistemas de archivos: <br><br><pre> <code class="bash hljs">mount /dev/sdc /mnt</code> </pre> <br>  Si el sistema de archivos est√° ubicado en varios discos, entonces para el montaje es suficiente especificar cualquiera de ellos. <br><br>  En general, montar btrfs siempre implica montar uno o m√°s de sus subvol√∫menes.  Si el comando de montaje no se especifica qu√© subvolumen se debe montar, entonces btrfs leer√° del registro especial la ID del subvolumen, que se debe montar de forma predeterminada.  Esta entrada se puede cambiar m√°s tarde con el <code>btrfs set-default</code> , pero cuando la monta por primera vez en btrfs, solo hay un subvolumen: el ra√≠z.  Se especifica por defecto para el montaje. <br><br>  El submundo ra√≠z en btrfs siempre est√° presente.  Aparece junto con el sistema de archivos y no est√° sujeto a ning√∫n cambio en el futuro. <br><br>  Hay dos formas de montar cualquier subvolumen que no sea el predeterminado: <br>  especifique la ruta desde el subvolumen ra√≠z btrfs: <br><br><pre> <code class="bash hljs">mount -o subvol=/path/to/subvol /dev/sdc /mnt</code> </pre> <br>  especifique la ID del subvolumen: <br><br><pre> <code class="bash hljs">mount -o subvolid=257 /dev/sdc /mnt</code> </pre> <br>  Como ya se mencion√≥, uno de los subvol√∫menes btrfs se especifica como montado de forma predeterminada.  Descubra cu√°l es posible haciendo: <br><br><pre> <code class="bash hljs">btrfs subvolume get-default /path/to/any/subvolume</code> </pre> <br>  Para instalar el submontaje predeterminado, puede usar el comando: <br><br><pre> <code class="bash hljs">btrfs subvolume <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-default 258 /path/to/any/subvolume</code> </pre> <br>  La ruta al subvolumen en este caso solo es necesaria para indicar la instancia espec√≠fica de btrfs a la que se aplica el comando.  Por cierto, esto no tiene que ser un submundo; la ruta a cualquier directorio tambi√©n es adecuada. <br><br>  El comando <code>mount</code> acepta una gran cantidad de opciones para controlar las capacidades de btrfs: desfragmentaci√≥n, vaciado de cach√©, compresi√≥n, vaca, registro, equilibrio, soporte de SSD y muchas otras cosas espec√≠ficas de btrfs.  No los considerar√© en el marco de este art√≠culo, porque  son necesarios para ajustar el sistema de archivos, y en la gran mayor√≠a de los casos puede prescindir de ellos. <br><br><h1>  Subvolumen es </h1><br>  Un subvolumen es un elemento clave de btrfs que realiza varias funciones: <br><br><ul><li>  almacenamiento de datos de usuario y otros subvol√∫menes, <br></li><li>  proporcionar acceso a datos (montaje), <br></li><li>  Mecanismo de vaca <br></li><li>  creando instant√°neas. <br></li></ul><br>  En una primera aproximaci√≥n, el subvolumen es un directorio normal.  Puede cambiarles el nombre / moverlos, ver su contenido, colocar y modificar archivos dentro de ellos.  No se requieren utilidades especiales. <br><br>  La creaci√≥n y eliminaci√≥n de un subvolumen se realiza en btrfs montados utilizando comandos especiales: <br><br><pre> <code class="bash hljs">btrfs subvolume create /mnt/subvolume_name btrfs subvolume delete /mnt/subvolume_name</code> </pre> <br>  Observo que si intenta eliminar el subvolumen utilizando el administrador de archivos o la utilidad <b>rm</b> , la operaci√≥n finalizar√° con un error de <i>operaci√≥n no permitida</i> (la operaci√≥n no est√° permitida). <br><br>  <b>UPD: a</b> partir de la versi√≥n 4.18.0 del kernel, las subvol√∫menes se pueden eliminar mediante la utilidad <b>rm</b> o las herramientas del administrador de archivos.  Aparentemente, fue un error, no una caracter√≠stica.  Gracias a Prototik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">habravchanin</a> por la aclaraci√≥n. <br><br>  Despu√©s de crear un subvolumen, puede ver sus propiedades: <br><br><pre> <code class="bash hljs">btrfs subvolume show /mnt/subvolume_name Name:          subx UUID:          09af45e8-d2b2-b342-8a92-fa270ac82d0a Parent UUID:      - Received UUID:     - Creation time:     2019-03-23 17:59:28 +0100 Subvolume ID:      268 Generation:       39 Gen at creation:    35 Parent ID:       260 Top level ID:      260 Flags:         - Snapshot(s):</code> </pre> <br>  Veamos las principales propiedades del subwolume: <br><br><ul><li>  <b>Nombre</b> : el nombre del subvolumen <br></li><li>  <b>UUID</b> es un identificador √∫nico universal que sirve principalmente para determinar las relaciones de subwoofer-instant√°nea, <br></li><li>  <b>UUID principal</b> : identificador del antecesor de subvolumen del que se deriva el actual, <br></li><li>  <b>UUID recibido</b> : identificador del ancestro de subvolumen enviado a trav√©s de <i>btrfs send</i> , <br></li><li>  <b>ID de subvolumen</b> : un identificador √∫nico para la colocaci√≥n en el √°rbol B, <br></li><li>  <b>Generaci√≥n</b> : n√∫mero de transacci√≥n en la √∫ltima actualizaci√≥n de los metadatos de subvolumen, <br></li><li>  <b>Gen en la creaci√≥n</b> : n√∫mero de transacci√≥n en el momento en que se cre√≥ el subvolumen, <br></li><li>  <b>ID principal</b> : identificador del subvolumen en el que est√° incrustado el actual, <br></li><li>  <b>La ID de nivel superior</b> es exactamente la misma que la ID principal, <br></li><li>  <b>Banderas</b> : banderas (de hecho, solo 1 bandera es de <i>solo lectura</i> ), <br></li><li>  <b>Instant√°neas</b> : una lista de instant√°neas tomadas de este subvolumen. <br></li></ul><br>  El subvolumen tiene un par√°metro m√°s: esta es su ruta desde el elemento ra√≠z btrfs.  La ruta se muestra al enumerar el subvolumen: <br><br><pre> <code class="plaintext hljs">btrfs subvolume list /path/to/any/btrfs/mountpoint</code> </pre> <br>  Pero aqu√≠ todo es simple y claro: ni siquiera tiene sentido traer el resultado del comando. <br>  Al igual que con los comandos <code>get-default</code> y <code>set-default</code> , aqu√≠ puede especificar la ruta a cualquier subvolumen, el resultado de esto no cambiar√°.  Esta ruta se utiliza para encontrar el subbolum ra√≠z btrfs.  Despu√©s de lo cual se lee todo el √°rbol subwolum. <br><br>  Si intenta copiar el subvolumen, por ejemplo, con la utilidad <b>cp</b> , la operaci√≥n de copia tendr√° √©xito, pero como resultado, no se crear√° el subvolumen, sino el directorio habitual.  Sin embargo, btrfs proporciona una herramienta mucho m√°s flexible para crear tales copias: instant√°neas. <br><br><h1>  Instant√°nea es </h1><br>  Instant√°nea tambi√©n es un submundo, solo que tiene propiedades avanzadas. <br><br>  Su principal diferencia es que la instant√°nea tiene registros de qu√© subwolum se produjo.  Estos son los campos <b>UUID principal</b> y <b>UUID recibido</b> .  En el subwoofer, estos campos tambi√©n est√°n presentes, pero siempre est√°n vac√≠os.  Entonces, de hecho, una instant√°nea y un subvolumen son lo mismo. <br>  Al crear, puede bloquear la instant√°nea para cambios utilizando el modificador <code>-r</code> . <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot -r /path/to/subvol /path/to/snapshot</code> </pre> <br>  En este caso, se garantiza que los archivos permanecer√°n en el estado en que se encontraban en el momento en que se cre√≥ la instant√°nea. <br><br>  El indicador de solo lectura tambi√©n se puede controlar manualmente, esto funciona para cualquier subvolumen: <br><br><pre> <code class="plaintext hljs">btrfs property get /path/to/subvol ro btrfs property set /path/to/subvol ro true</code> </pre> <br>  Si ahora miramos las propiedades de la instant√°nea, veremos el campo <b>UUID principal</b> lleno: <br><br><pre> <code class="plaintext hljs">btrfs subvolume show /path/to/snapshot Name:          subx UUID:          d08612d8-596a-11e9-8647-d663bd873d93 Parent UUID:      09af45e8-d2b2-b342-8a92-fa270ac82d0a Received UUID:     - Creation time:     2019-03-23 17:59:28 +0100 Subvolume ID:      269 Generation:       39 Gen at creation:    35 Parent ID:       260 Top level ID:      260 Flags:         - Snapshot(s):</code> </pre> <br>  Una caracter√≠stica importante de la operaci√≥n de instant√°nea es que no es recursiva.  En lugar de subvolumen anidado, se crear√°n directorios vac√≠os en la instant√°nea. <br><br>  Pasemos al siguiente ejemplo. <br><br>  En el sistema de archivos hay un subwoofer "sub0", dentro del cual hay un subwoofer <i>subA</i> y un directorio <i>dirB</i> .  Dentro de cada uno de ellos est√°n el <i>archivo A</i> y el <i>archivo</i> <i>B,</i> respectivamente. <br><br>  Eliminar instant√°nea: <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot sub0 snap0</code> </pre> <br><img src="https://habrastorage.org/webt/cf/or/w-/cforw-vhzoma9iub2hcyejkbh84.png"><br><br>  La instant√°nea <i>snap0 creada</i> heredar√° todos los archivos y directorios de su padre, sin embargo, el <i>subwoofer</i> subA no aparecer√° dentro de la instant√°nea.  En cambio, solo aparecer√° un directorio vac√≠o en la instant√°nea, es decir  el contenido del subvolumen <i>subA</i> no se heredar√°. <br><br>  Por un lado, esto es bueno: eliminamos la instant√°nea de un subvolumen espec√≠fico, y todos los anidados no nos interesan.  Por otro lado, si se requiere una instant√°nea recursiva, btrfs no tiene una soluci√≥n para este problema.  Tendremos que buscar rondas de trabajo. <br><br>  La primera soluci√≥n se basa en el hecho de que la instant√°nea se elimin√≥ sin un indicador de solo lectura, lo que le permite solucionar la situaci√≥n de manera bastante simple: <br><br><ul><li>  eliminar directorio adicional de la instant√°nea <br><br><pre> <code class="plaintext hljs">rmdir snap0/subA</code> </pre> <br></li><li>  eliminar la instant√°nea de un subvolumen anidado <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot sub0/subA snap0/subA</code> </pre> <br></li></ul><br><img src="https://habrastorage.org/webt/ja/u3/fy/jau3fyzmzjxzxweajh-tmjld-iw.png"><br><br>  Si la instant√°nea se elimin√≥ con el indicador de solo lectura, la opci√≥n anterior no funcionar√°, porque  en <i>snap0</i> no puede eliminar el directorio ni colocar una instant√°nea.  Solo hay una opci√≥n: colocar instant√°neas en alg√∫n lugar cerca del <i>subwoofer</i> snap0: <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot sub0/subA snapA</code> </pre> <br>  y luego monte <i>snapA</i> dentro de la instant√°nea <i>snap0</i> , el directorio para esto ya est√° all√≠: <br><br><pre> <code class="plaintext hljs">mount -o subvol=snapA snap0/subA</code> </pre> <br><img src="https://habrastorage.org/webt/mu/-w/nn/mu-wnnj0jiyyinnxokz08nuipag.png"><br><br>  En cualquier caso, es importante comprender que las instant√°neas recursivas se tomar√°n en diferentes operaciones, en diferentes momentos.  No se puede hablar de ninguna eliminaci√≥n at√≥mica de una instant√°nea de varios subvol√∫menes. <br><br><h1>  Copia en escritura </h1><br>  Un poco sobre subvolumen y enfoque CoW.  Imagine que hay un subvolumen en el sistema de archivos y que se encuentra un archivo en √©l (tome el caso ideal: el archivo no est√° fragmentado).  A continuaci√≥n, se elimina una instant√°nea del subwolly. <br><br><img src="https://habrastorage.org/webt/hg/yo/sl/hgyoslduv5eeenpopaqu3dk7qyw.png"><br><br>  Aparecer√° un nuevo subvolumen (instant√°nea) en el sistema de archivos con exactamente el mismo contenido que el subvolumen original.  El proceso de creaci√≥n de una instant√°nea es casi instant√°neo: los datos del archivo en s√≠ no se copian.  En su lugar, se crean metadatos adicionales y una instant√°nea junto con el subvolumen principal se convierte en el propietario del archivo.  De hecho, solo hab√≠a un archivo en el disco, pero ahora pertenece tanto al subvolumen como a la instant√°nea. <br>  Si ahora cambia el archivo en el subvolumen, los cambios no afectar√°n el archivo en la instant√°nea.  Si el indicador de solo lectura no se configur√≥ al crear la instant√°nea, entonces el archivo en la instant√°nea tambi√©n se puede modificar. <br><br><img src="https://habrastorage.org/webt/7n/1e/0t/7n1e0tkdlxsuqkpjmtinix0yiys.png"><br><br>  T√©cnicamente, cuando se cambia un archivo, solo se registran estos cambios.  Por lo tanto, el archivo fuente se almacenar√° en el disco m√°s alg√∫n delta que distinga el archivo original del modificado.  Si elimina uno de los subvol√∫menes (por el segundo me refiero a una instant√°nea), el exceso de datos que ya no es utilizado por nadie se borrar√° del disco, y solo la versi√≥n actual del archivo permanecer√° en el disco (desde el punto de vista del subvolumen restante). <br><br>  <i>Una breve nota</i> : al extraerlo, el subwoofer desaparecer√° de los ojos del usuario al instante y la utilidad devolver√° el control al terminal; sin embargo, el proceso en segundo plano limpiar√° los datos del disco durante un tiempo.  Es decir, a diferencia de la eliminaci√≥n de un directorio normal, no es necesario esperar a que finalice la operaci√≥n de eliminaci√≥n.  Si necesita sincronizarse con este proceso y esperar a que se complete, puede especificar el interruptor <code>--commit-after</code> llamar al <b>eliminar</b> .  El <b>comando btrfs subvolume list</b> , <b>invocado</b> con el <b>modificador</b> <code>-d</code> , muestra una lista de subvol√∫menes que el usuario ha eliminado y que actualmente se encuentran en proceso de eliminaci√≥n del disco. <br><br>  Adem√°s, btrfs le permite clonar archivos en el sistema de archivos sin recurrir a instant√°neas.  Esto se hace copiando regularmente con la <code>--reflink</code> : <br><br><pre> <code class="plaintext hljs">cp -ax --reflink=always /original/file /copied/file</code> </pre> <br>  La clave <code>reflink=always</code> le dice al sistema de archivos que queremos usar el mecanismo CoW al copiar.  Despu√©s de copiar, los archivos se pueden cambiar independientemente uno del otro, para que tengamos el mismo comportamiento que despu√©s de crear una instant√°nea.  Entonces, ¬øpor qu√© necesitamos subbolums? <br><br>  Los subtolums en btrfs desempe√±an el papel de una herramienta de control de alto nivel para conjuntos de datos completos: en primer lugar, es la eliminaci√≥n de instant√°neas at√≥micas de todos los datos de un subvolumen (en el caso de - la atomicidad de enlace solo est√° en el nivel de archivo), y en segundo lugar es posible ver de qui√©n se hereda o "revierta" r√°pidamente el conjunto de datos a una versi√≥n anterior, etc. <br>  Por lo tanto, btrfs proporciona la capacidad de capturar estados de archivos en los puntos de tiempo deseados, utilizando subvol√∫menes como un medio de alto nivel para administrar estos estados. <br><br><h1>  Recuperaci√≥n de subvolumen </h1><br>  En las vastas extensiones, a menudo surge la pregunta: "Tengo un subwoofer, tengo una instant√°nea, ¬øc√≥mo hacer un reverso?"  Este enfoque no es aplicable a btrfs, porque  no hay oportunidad de "hacer retroceder el subwolly".  En cambio, btrfs ofrece una estrategia para reemplazar el subwolly con su instant√°nea.  De hecho, por qu√© revertir algo, si la instant√°nea en s√≠ es este objeto que queremos obtener con revertir. <br><br>  Imagine este escenario: en btrfs hay un subvolumen en el que se encuentran los archivos de una base de datos (bueno, u otros datos importantes).  Las instant√°neas se eliminan peri√≥dicamente de este subvolumen y, en alg√∫n momento, es necesario revertir los datos.  En este caso, simplemente nos deshacemos del subwolum y, en su lugar, comenzamos a usar la instant√°nea tomada de √©l o, si no queremos estropear tambi√©n estos datos, eliminamos otra instant√°nea de la instant√°nea.  Si el submundo original no se mont√≥ y se us√≥ como un directorio normal, entonces se debe eliminar o mover / renombrar, y se debe colocar una instant√°nea en su lugar. <br><br><img src="https://habrastorage.org/webt/sn/os/od/snosodoezxac3a-2s7xzmpqa-js.png"><br><br>  En la consola, podr√≠a verse as√≠: <br><br><ul><li>  renombrar el subwolly <br><br><pre> <code class="plaintext hljs">mv the_subvolume the_subvol.old</code> </pre> </li><li>  poner su instant√°nea en lugar del subvolumen <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot the_snapshot the_subvolume</code> </pre> </li></ul><br>  Si el subvolumen se mont√≥ y us√≥ a trav√©s del punto de montaje, entonces es suficiente desmontar el subvolumen y montar una instant√°nea en su lugar. <br><br><img src="https://habrastorage.org/webt/4z/mi/sw/4zmisws4w5keyk7mhsr6eaav-ri.png"><br><br><ul><li>  Desmontar el subwoofer <br><br><pre> <code class="plaintext hljs">umount /mnt/</code> </pre> </li><li>  Puede crear una instant√°nea de una instant√°nea para no estropear los √∫ltimos datos sobrevivientes: <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot /path/to/snapshot /path/to/snapshot_copy</code> </pre> </li><li>  instant√°nea de montaje: <br><br><pre> <code class="plaintext hljs">mount -o subvol=path/to/snapshot_copy /mnt</code> </pre> </li></ul><br>  Para completar, lo intentar√© de nuevo y un poco diferente.  El subvolumen en el que ocurren los cambios es la rama <i>principal</i> . <br><br><img src="https://habrastorage.org/webt/gh/pt/m7/ghptm7ykmordfcur4bdddehng6c.jpeg"><br><br>  Al crear una instant√°nea, el estado de los archivos en el disco es fijo.  De ahora en adelante, una instant√°nea es un brunch de la rama <i>principal</i> .  Todos los cambios posteriores a <i>main</i> no afectar√°n la instant√°nea de ninguna manera.  Volver a la instant√°nea significa detener el uso de la rama <i>principal</i> y cambiar completamente al brunch.  La rama <i>principal</i> se puede eliminar como innecesaria.  Por lo tanto, btrfs es pr√°cticamente un sistema de control de versiones, pero sin la capacidad de fusionar las ramas. <br><br><h1>  √Årbol del sistema de archivos </h1><br>  Uno de los puntos no obvios asociados con el uso de btrfs es c√≥mo dividir los datos del sistema en subvol√∫menes.  Por supuesto, no existe un enfoque "correcto" para este problema.  Pero hay 3 formas de organizar la estructura del subvolumen: una estructura plana, anidada y mixta. <br><br>  Una estructura plana significa que el subvolumen se coloca en una lista plana en el subvolumen ra√≠z.  Por ejemplo, puede seleccionar la ra√≠z del sistema de archivos (llam√©mosla <i>ra√≠z</i> ), el directorio de <i>inicio</i> del usuario, el directorio con el sitio <i>/ var / www</i> y la base de datos ubicada, por ejemplo, en <i>/ var / database</i> como subvol√∫menes separados. <br><br><img src="https://habrastorage.org/webt/ga/yp/ma/gaypma96_mzvjtlwjyh3atw5qgm.png"><br><br>  Por conveniencia, se puede colocar alg√∫n subvolumen en directorios, como, por ejemplo, en el caso del subvolumen <i>var / www</i> . <br><br>  Con este enfoque, todos los subvol√∫menes deben montarse.  La <i>ra√≠z ra√≠z</i> debe tener un punto de montaje /, y en su interior debe contener los directorios <i>home</i> y <i>var</i> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de montar la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ra√≠z</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ home</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> debe estar instalado sabvolyum </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">casa</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y en el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">directorio / var / www</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ var / databas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> un e - sabvolyumy </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">var / www</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base de datos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , respectivamente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, el √°rbol de btrfs-subvolume se puede mostrar arbitrariamente en el sistema de archivos virtual del sistema operativo, y ya hay suficiente para eso.</font></font><br><br>  Pros: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> el usuario solo ve subvolumen montado, </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es f√°cil reemplazar el subwoofer (desmontar uno, montar el otro), </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Subwoofer f√°cil de quitar. </font></font><br></li></ul><br>  Contras: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es f√°cil confundirse sobre d√≥nde instalarlo, </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para cada subvolumen debe haber una entrada en fstab, y si hay "retrocesos" en las instant√°neas, entonces las entradas correspondientes en fstab tambi√©n deben actualizarse. </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La estructura anidada del subvolumen sugiere un uso simple del subvolumen en lugar de algunos directorios. </font></font><br><br><img src="https://habrastorage.org/webt/v2/41/e5/v241e5bwrguy3_f76frc2k3ygwk.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este caso, adem√°s del subvolumen ra√≠z, no se requiere nada m√°s para ser montado.</font></font><br><br>  Pros: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> todos los subvol√∫menes son visibles, la estructura es f√°cil de percibir, </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no necesita volver a montar nada, todo es como un sistema de archivos "normal". </font></font><br></li></ul><br>  Contras: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> todos los subvol√∫menes son visibles, tal vez a algunos les gustar√≠a esconderse del usuario, </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es dif√≠cil eliminar / reemplazar el subwolum (la raz√≥n de esto es subwolves anidados). </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bueno, el tercer enfoque es mixto. </font><font style="vertical-align: inherit;">Implica una combinaci√≥n de los dos primeros para maximizar los beneficios de ambos. </font><font style="vertical-align: inherit;">Sin embargo, es posible que este enfoque en particular conduzca a una estructura compleja, dif√≠cil de cambiar y confusa con una gran cantidad de entradas en fstab. </font><font style="vertical-align: inherit;">Todo depende de la </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sobriedad</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> del administrador del sistema.</font></font><br><br><img src="https://habrastorage.org/webt/bv/qw/zv/bvqwzvl0wqspgvlaknnd3l9eyqo.png"><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agregar / quitar disco, saldo </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> btrfs cuenta con una excelente funcionalidad: la capacidad de "agregar dispositivos de bloqueo activos" directamente durante el funcionamiento del sistema de archivos: </font></font><br><br><pre> <code class="plaintext hljs">btrfs device add /path/to/device /path/to/btrfs</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O eliminar: </font></font><br><br><pre> <code class="plaintext hljs">btrfs device remove /path/to/device /path/to/btrfs</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por cierto, en una llamada de agregar / eliminar puede especificar varios discos. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuevamente, la ruta especificada es la ruta a cualquier subvolumen de ese btrfs al que se aplicar√° el comando. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Veamos cu√°ntos y qu√© dispositivos de bloque est√°n bajo control de btrfs:</font></font><br><br><pre> <code class="plaintext hljs">btrfs filesystem show /path/to/btrfs Label: none uuid: 52961dda-df84-4e2d-9727-e93e7738df81       Total devices 2 FS bytes used 192.00KiB       devid  1 size 20.00GiB used 132.00MiB path /dev/sdc       devid  2 size 50.00GiB used 0.00B path /dev/sdd</code> </pre><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.00B</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en el campo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usado</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nos dice que el disco agregado est√° vac√≠o. </font><font style="vertical-align: inherit;">Para llenarlo con datos de acuerdo con el perfil de grabaci√≥n, debe equilibrar:</font></font><br><br><pre> <code class="plaintext hljs">btrfs balance start /path/to/btrfs</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El comando </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">balance</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> redistribuye los datos en los discos de acuerdo con el perfil de grabaci√≥n seleccionado. Por ejemplo, en el caso de RAID1, el saldo conducir√° a la clonaci√≥n de datos del dispositivo original, en el caso de RAID0, conducir√° a una distribuci√≥n m√°s uniforme de los datos en dos discos, etc. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado del balance, si antes hab√≠a vac√≠os en el disco, entonces los datos en el disco se escribir√°n de una manera m√°s densa, es decir. La desfragmentaci√≥n resultar√°. Sin embargo, es importante entender que esto no es exactamente "esa" desfragmentaci√≥n. En este caso, el comando de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">equilibrio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no mira el contenido l√≥gico, sino que opera solo en bloques de datos. Ella no presta atenci√≥n al hecho de que cualquier archivo est√° extendido en el disco. En cambio, el </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saldo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> transfiere bloques de datos de un lugar a otro.</font></font> Es decir<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un archivo fragmentado para equilibrar permanecer√° fragmentado despu√©s de √©l. Pero! La fragmentaci√≥n a nivel de bloques de datos seguir√° disminuyendo, y esto se puede usar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para evitar confusiones, digamos esto: la operaci√≥n de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">equilibrio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> reduce la fragmentaci√≥n a nivel de bloques de datos, pero no afecta la fragmentaci√≥n de archivos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s, el comando de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">equilibrio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> proporciona la capacidad de cambiar el perfil de grabaci√≥n. Por ejemplo, el perfil DUP se utiliz√≥ en el disco y, despu√©s de agregar el disco, decidieron crear RAID1 completo. Para hacer esto, use el filtro </font></font><code>convert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="plaintext hljs">btrfs balance start -dconvert=raid1 -mconvert=raid1 /path/to/btrfs</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando las opciones </font></font><code>-dconvert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y, </font></font><code>-mconvert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se configuran nuevos perfiles de registro para datos y metadatos, respectivamente. </font><font style="vertical-align: inherit;">Tambi√©n existe la opci√≥n -sconvert, que est√° dise√±ada para cambiar el perfil de escritura de datos del sistema, sin embargo, tambi√©n deber√° agregar el modificador -f (--force) para forzar la operaci√≥n.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En general, el objetivo principal de los filtros es establecer las reglas para la operaci√≥n de equilibrio: qu√© bloques procesar y cu√°les no tocar. </font><font style="vertical-align: inherit;">Entonces, por ejemplo, puede afectar solo los bloques grabados con un perfil de grabaci√≥n espec√≠fico (perfiles de filtro), o bloques ocupados por encima de un cierto porcentaje (filtro de uso), o afectar solo a grupos de bloques relacionados con un disco espec√≠fico (filtro devid), etc. </font><font style="vertical-align: inherit;">Por cierto, todav√≠a se pueden combinar. </font><font style="vertical-align: inherit;">En general, las capacidades de los filtros son muy amplias y son principalmente necesarias para realizar un balance selectivo de datos.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fragmentaci√≥n </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desafortunadamente, btrfs, debido a su arquitectura, es extremadamente susceptible a un fen√≥meno como la fragmentaci√≥n. </font><font style="vertical-align: inherit;">El hecho es que los datos siempre se escriben en una nueva ubicaci√≥n en el disco. </font><font style="vertical-align: inherit;">Incluso si lee el archivo, no haga nada con los datos y vuelva a escribirlos en el mismo archivo, los datos ir√°n a una nueva √°rea en el disco. </font><font style="vertical-align: inherit;">Lo mismo sucede si actualiza los datos en el archivo solo parcialmente: los cambios se escriben en una nueva √°rea del disco. </font><font style="vertical-align: inherit;">Por lo tanto, los cambios frecuentes fragmentan los archivos con mucha fuerza, lo que aumenta la "dispersi√≥n" de los fragmentos, en el caso general, en varios discos. </font><font style="vertical-align: inherit;">Esto conduce a una mayor carga en la CPU y al consumo innecesario de memoria. </font><font style="vertical-align: inherit;">Las m√°s fragmentadas son las bases de datos y las im√°genes de m√°quinas virtuales. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede evaluar la fragmentaci√≥n de archivos con la utilidad </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">filefrag</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (no incluido en btrfs-progs). </font></font><br><br><pre> <code class="plaintext hljs">filefrag /path/to/your/file</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muestra la cantidad de extensiones utilizadas para almacenar el archivo. </font><font style="vertical-align: inherit;">En pocas palabras: cuanto menos implicados, menos fragmentado est√° el archivo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay dos m√©todos para combatir la fragmentaci√≥n en btrfs: la desfragmentaci√≥n y la bandera </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La desfragmentaci√≥n se puede aplicar a un solo archivo o a un subvolumen / directorio, incluso de forma recursiva. </font><font style="vertical-align: inherit;">El comando es el siguiente:</font></font><br><br><pre> <code class="plaintext hljs">btrfs filesystem defragment /path/to/file/or/dir</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debo decir que este equipo no siempre conduce a los resultados esperados. </font><font style="vertical-align: inherit;">Los archivos peque√±os y ligeramente fragmentados (10-20 extensiones) despu√©s de la desfragmentaci√≥n se pueden dividir en m√°s partes. </font><font style="vertical-align: inherit;">Adem√°s, la desfragmentaci√≥n de btrfs en algunas versiones del n√∫cleo interrumpe la deduplicaci√≥n de archivos, convirti√©ndolos en copias f√≠sicas reales.</font></font> Es decir<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">las instant√°neas a nivel f√≠sico se convertir√°n en copias completas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La segunda forma de combatir la fragmentaci√≥n es con un atributo de archivo </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="plaintext hljs">chattr +C /path/to/file</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El atributo </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solo se puede establecer en un archivo nuevo o vac√≠o. </font><font style="vertical-align: inherit;">Deshabilita el mecanismo de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">copia en escritura</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , por lo que btrfs siempre funcionar√° con un √°rea de disco fija al actualizar el contenido de un archivo, escribiendo datos sobre los existentes (a nivel f√≠sico). </font><font style="vertical-align: inherit;">De los inconvenientes de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nocow</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tambi√©n deshabilita la comprobaci√≥n de la suma de comprobaci√≥n para este archivo. </font><font style="vertical-align: inherit;">En otras palabras, no hay vaca, no hay suma de control. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, establezca manualmente el atributo</font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada archivo es una tarea ingrata. Si se establece este indicador del directorio / subvolumen, todos los archivos nuevos creados en √©l heredar√°n el indicador autom√°ticamente. Lo mismo se aplica a los directorios anidados creados. Si en el momento en que se activ√≥ el atributo, los datos ya estaban en el directorio, esto no los afectar√° de ninguna manera; el atributo </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solo se puede establecer en un archivo nuevo o vac√≠o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y otra forma de configurar el indicador autom√°ticamente </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es montar el sistema de archivos con la opci√≥n </font></font><code>nodatacow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="plaintext hljs">mount -o subvol=path/to/subvol,nodatacow /dev/sdXX /path/to/mountpoint</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta opci√≥n har√° que la opci√≥n se conecte autom√°ticamente </font></font><code>nodatasum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, de modo que para los archivos reci√©n creados, no se calcular√°n las sumas de verificaci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como de costumbre, hay un matiz: no puede montar solo un subwoofer con una opci√≥n </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. O todos los subvol√∫menes tendr√°n una opci√≥n </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o ninguna. Todo se decide por el primer subvolumen montado: si ten√≠a una opci√≥n especificada </font></font><code>nodatacow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, todos los montajes posteriores ir√°n con esta opci√≥n autom√°ticamente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un momento no obvio surge si coloca una bandera en un archivo </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y elimina la instant√°nea del subvolumen en el que se encuentra este archivo. En este caso, btrfs ignora el indicador </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si m√°s de un subvolumen se refiere al bloque de datos actualizado. Por lo tanto, a pesar de la bandera</font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(por cierto, el archivo tambi√©n lo heredar√° en la instant√°nea), los cambios en cualquiera de los archivos ir√°n a una nueva √°rea en el disco y el archivo nuevamente se fragmentar√°. </font><font style="vertical-align: inherit;">Si el bloque de datos en el archivo se actualiza varias veces, entonces la primera vez caer√° en una nueva √°rea en el disco, y con las entradas posteriores se actualizar√° en esta nueva √°rea "en su lugar".</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Trucos y Fallos </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cuando use btrfs-progs, puede omitir el nombre completo del comando: </font></font><br><br><pre> <code class="plaintext hljs">btrfs sub cre = btrfs subvolume create</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es suficiente solo la coincidencia de los primeros caracteres, que determinan de manera √∫nica el comando: </font></font><br><br><pre> <code class="plaintext hljs">su = subvolume, fi = filesystem, ba = balance, de = device;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creo que el principio es claro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por desgracia, btrfs no puede crear una instant√°nea del directorio, pero hay una soluci√≥n alternativa:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> crear un subvolumen </font></font><br><br><pre> <code class="plaintext hljs">btrfs subvolume create ./subvol</code> </pre> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> copiar archivos del directorio al subvolumen: </font></font><br><br><pre> <code class="plaintext hljs">cp -ax --reflink=always your/dir/. ./subvol</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la clave </font></font><code>reflink=always</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usar√° el mecanismo CoW, es decir </font><font style="vertical-align: inherit;">los datos no se copiar√°n, pero los enlaces se crear√°n en btrfs de bajo nivel.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora el submundo contiene todos los archivos que estaban en el directorio, y puede eliminar la instant√°nea del mismo. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede establecer el </font><font style="vertical-align: inherit;">atributo en un </font><font style="vertical-align: inherit;">archivo de datos existente. </font><font style="vertical-align: inherit;">Sin embargo, puede seguir el siguiente camino:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> crear archivo vac√≠o </font></font><br><br><pre> <code class="plaintext hljs">touch nocowfile</code> </pre> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ponle una bandera </font></font><code>nocow</code> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> asignar espacio en disco para un nuevo archivo </font></font><br><br><pre> <code class="plaintext hljs">fallocate -l10g nocowfile</code> </pre> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> copiar el contenido de un archivo existente a </font></font><br><br><pre> <code class="plaintext hljs">cp -v oldcowfile nocowfile</code> </pre> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si btrfs se queda sin espacio, incluso eliminar un archivo puede causar un error </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"No queda espacio en el dispositivo"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Para la soluci√≥n, se recomienda conectar una unidad temporal con tama√±os de preferiblemente al menos 1 GB a btrfs. </font><font style="vertical-align: inherit;">Luego limpie los datos. </font><font style="vertical-align: inherit;">Luego retire la unidad temporal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La operaci√≥n de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">equilibrio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , invocada sin especificar perfiles de escritura, los cambia impl√≠citamente de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dup</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">raid1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Lo que, por cierto, est√° escrito en la p√°gina de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gotchas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Esto sucede despu√©s de agregar el disco a btrfs, que usa el perfil de escritura </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dup</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Recuerde que formatear una sola unidad en btrfs usa el perfil </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dup</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> predeterminado para metadatos y datos del sistema.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quiz√°s lo m√°s importante </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evite crear clones de bajo nivel de dispositivos de bloque con btrfs. Al ser un sistema de archivos "inteligente", para algunas operaciones (la mayor√≠a de las veces, durante el montaje) btrfs vuelve a leer los datos del sistema en dispositivos de bloque para encontrar todas las partes del sistema de archivos. Si se encuentran dos dispositivos de bloque con los mismos UUID en el proceso de b√∫squeda, btrfs los aceptar√° como parte de la misma instancia. Si al mismo tiempo estos dos dispositivos resultan ser el original y su clon, luego de montar el controlador solo sabr√° c√≥mo funcionar√° el sistema de archivos, pero est√° claro que esto no terminar√° con nada bueno. En el peor de los casos, provocar√° una corrupci√≥n irreversible de los datos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si realmente desea clonar discos con btrfs de una manera de bajo nivel, debe tener mucho cuidado. </font><font style="vertical-align: inherit;">En general, un clon no debe ser visible para el n√∫cleo del sistema operativo como un dispositivo de bloque mientras el original est√° presente en el sistema, y ‚Äã‚Äãviceversa. </font><font style="vertical-align: inherit;">Proporcionando esta condici√≥n, puede cambiar el UUID del clon (bueno, o el original, aqu√≠ opcional). </font><font style="vertical-align: inherit;">La utilidad </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">btrfstune</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que viene con el paquete </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">btrfs-progs ayudar√° a</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="plaintext hljs">btrfstune -u /path/to/device</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y de nuevo: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">btrfstune</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , al ser una utilidad "inteligente", cambiar√° el UUID no solo en el disco, sino en todo el sistema de archivos. </font><font style="vertical-align: inherit;">Esto significa que cuando se le llame, leer√° todos los dispositivos de bloque para reemplazar el UUID en todos los dispositivos relacionados con el sistema de archivos.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En lugar de una conclusi√≥n </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si en este momento no comprende nada, esto es normal. Btrfs no es trivial y puede no sucumbir de inmediato. Cada vez que me parec√≠a que ahora la entend√≠a, ella lanzaba una sorpresa y la hac√≠a repensar las cosas existentes. No puedo decir que entend√≠ todo en el momento actual: en el proceso de escritura encontr√© algo nuevo, aunque ya escrib√≠ sobre la base de mi experiencia. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparar√≠a el proceso de dominar btrfs con la transici√≥n de un estilo de programaci√≥n procesal a uno orientado a objetos. La primera impresi√≥n es "wow, qu√© asombroso", pero luego contin√∫as persistentemente escribiendo c√≥digo procesal envuelto en clases.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el art√≠culo, intent√© no verter agua, escribir todo sobre el caso. </font><font style="vertical-align: inherit;">A pesar de esto, result√≥ bastante voluminoso. </font><font style="vertical-align: inherit;">Pero lejos de todo era posible decir: a√∫n puede escribir y escribir sobre btrfs. </font><font style="vertical-align: inherit;">Este art√≠culo es solo la punta del iceberg. </font><font style="vertical-align: inherit;">El principio es entender su filosof√≠a y comenzar a usarla. </font><font style="vertical-align: inherit;">Y ahora es tiempo de terminar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gracias por leer hasta el final. </font><font style="vertical-align: inherit;">Espero no estar cansado. </font><font style="vertical-align: inherit;">Escriba en los comentarios sobre qu√© m√°s le interesar√≠a saber. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haga copias de seguridad, caballeros. </font><font style="vertical-align: inherit;">Y que nunca sean √∫tiles.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/458250/">https://habr.com/ru/post/458250/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458230/index.html">C√≥mo la IA, los drones y las c√°maras mantienen nuestras carreteras y puentes seguros</a></li>
<li><a href="../458240/index.html">C√≥mo la inteligencia artificial, los drones y las c√°maras garantizan la seguridad de carreteras y puentes</a></li>
<li><a href="../458244/index.html">Una lista interminable y rid√≠cula de lo que necesita saber para usar de forma segura las redes Wi-Fi p√∫blicas</a></li>
<li><a href="../458246/index.html">Coincidencias aleatorias en la vida, o c√≥mo result√≥ que te presentaron un pastel en una f√°brica de tractores</a></li>
<li><a href="../458248/index.html">Simplifique su c√≥digo con Rocket Science: operador de nave espacial de C ++ 20</a></li>
<li><a href="../458252/index.html">Modelo matem√°tico de un radiotelescopio superlargo</a></li>
<li><a href="../458256/index.html">¬øNo es hora de lavar el cerebro?</a></li>
<li><a href="../458260/index.html">Otra forma de optimizar las im√°genes de Docker para aplicaciones Java</a></li>
<li><a href="../458262/index.html">Dise√±ador en l√≠nea de la sala de reuniones: selecci√≥n de la soluci√≥n √≥ptima para la videoconferencia</a></li>
<li><a href="../458264/index.html">10 principios del c√≥digo autodocumentado</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>