<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≥üèΩ üë©üèº‚Äçüíº üçñ Unity, ECS, Actors: So erh√∂hen Sie die FPS in Ihrem Spiel zehnmal, wenn Sie nichts zu optimieren haben [mit √Ñnderungen] üëéüèæ üëì üßöüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚Üí Was ist ECS? 
 ‚Üí Was ist Schauspieler 

 Ich habe oft geh√∂rt, wie gut die ECS- Vorlage ist und dass Jobs und Burst aus der Unity- Bibliothek die L√∂s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unity, ECS, Actors: So erh√∂hen Sie die FPS in Ihrem Spiel zehnmal, wenn Sie nichts zu optimieren haben [mit √Ñnderungen]</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/478824/">  ‚Üí <a href="https://habr.com/ru/post/358108/">Was ist ECS?</a> <br>  ‚Üí <a href="https://github.com/dimmpixeye/actors" rel="nofollow">Was ist Schauspieler</a> <br><br>  Ich habe oft geh√∂rt, wie gut die <b>ECS-</b> Vorlage ist und dass <b>Jobs</b> und <b>Burst</b> aus der <b>Unity-</b> Bibliothek die L√∂sung f√ºr alle Leistungsprobleme sind.  Um nicht jedes Mal das Wort "wahrscheinlich" und "vielleicht" hinzuzuf√ºgen und die Geschwindigkeit des Codes zu besprechen, habe ich beschlossen, alles pers√∂nlich zu √ºberpr√ºfen. <br><br>  Mein Ziel war es, offen zu machen, wie schnell dieses Entwicklungswerkzeug ist und ob Parallelisierung f√ºr Berechnungen verwendet werden soll.  Und wenn <b>ja</b> , ist es besser, <b>Unity.Jobs</b> oder <b>System.Threading zu verwenden</b> ?  Gleichzeitig habe ich herausgefunden, wie man <b>ECS</b> in realen Aufgaben einsetzt. <br><a name="habracut"></a><br><br>  <i>Testbedingungen (in der N√§he von echten Spielaufgaben):</i> <br><br><ul><li>  <i>Der i5 2500 Prozessor (4 Kerne ohne Hyper-Trading) und Unity2019.3.0f1</i> </li><li>  <i>Jedes GameObject jeden Frame ...</i> <i><br><br></i>  <i>A) bewegt sich 10 Minuten lang entlang einer quadratischen B√©zier-Kurve vom Startpunkt bis zum Ende.</i> <i><br><br></i>  <i>B) berechnet seinen quadratischen Kollider (K√§stchen 10f10f), der math.sincos, math.asin, math.sqrt verwendet (die gleichen, recht komplizierten Berechnungen f√ºr alle Tests).</i> <i><br></i> </li><li>  <i>Objekte vor FPS-Messungen werden an zuf√§lligen Positionen innerhalb der 720fx1280f-Zone festgelegt und an einen zuf√§lligen Punkt in dieser Zone verschoben.</i> </li><li>  <i>Alles ist in Release in IL2CPP auf PC getestet</i> </li><li>  <i>Die Tests werden einige Sekunden nach dem Start aufgezeichnet, sodass alle anf√§nglichen vorl√§ufigen Berechnungen und die Einbeziehung von Unity-Systemen den FPS nicht beeinflussen.</i>  <i>Aus den gleichen Gr√ºnden wird nur der Aktualisierungscode jedes Frames angezeigt.</i> </li><li>  <i>Objekte werden in der Version nicht visuell angezeigt, sodass das Rendern keine Auswirkungen auf FPS hat.</i> </li></ul><br><h4>  Positionen testen und Code aktualisieren </h4><br><ol><li>  <b>MonoBehaviour sequentiell</b> (bedingte Markierung). <br>  Das MonoBehaviour-Skript ist an dem Objekt "aufgeh√§ngt", bei dessen Aktualisierung die Position, der Collider berechnet und das Selbst bewegt wird. <br><br><div class="spoiler">  <b class="spoiler_title">Code aktualisieren</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    var velocityToOneFrame = velocityToOneSecond * Time.deltaTime; observedDistance += velocityToOneFrame; var t = observedDistance / distanceFull; if (t &gt; 1f) t = 1f; var newPos = t.CalculateBesierPos(posToMove.c0, posToMove.c2,posToMove.c1); //   obj.properties.c0 = newPos; var posAndSize = new float2x2 { c0 = newPos, c1 = obj.collBox.posAndSize.c1 }; obj.collBox = obj.entity.NewCollBox(posAndSize, new float2(10f, 10f), obj.rotation.ToEulerAnglesZ()); //     tr.position = new Vector3(newPos.x, newPos.y); #if UNITY_EDITOR DebugDrowBox(obj.collBox, Color.blue, Time.deltaTime); #endif }</span></span></code> </pre> <br></div></div></li><li>  Auf Komponentenklassen <b>sequentielle Akteure</b> ohne Parallelisierung. <br><br><div class="spoiler">  <b class="spoiler_title">Code aktualisieren</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Tick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (ent entity <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> groupMoveBezier) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cMoveBezier = entity.ComponentMoveBezier_noJob(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cObject = entity.ComponentObject(); <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> cObject.obj; <span class="hljs-comment"><span class="hljs-comment">//    var velocityToOneFrame = cMoveBezier.velocityToOneSecond * delta; cMoveBezier.observedDistance += velocityToOneFrame; var t = cMoveBezier.observedDistance / cMoveBezier.distanceFull; if (t &gt; 1f) t = 1f; var newPos = t.CalculateBesierPos(cMoveBezier.posToMove.c0, cMoveBezier.posToMove.c2,cMoveBezier.posToMove.c1); //   obj.properties.c0 = newPos; var posAndSize = new float2x2 { c0 = newPos, c1 = obj.collBox.posAndSize.c1 }; obj.collBox = obj.entity.NewCollBox(posAndSize, new float2(10f, 10f), obj.rotation.ToEulerAnglesZ()); //     cObject.tr.position = new Vector3(newPos.x, newPos.y, 0); #if UNITY_EDITOR DebugDrowBox(obj.collBox, Color.blue, Time.deltaTime); #endif } }</span></span></code> </pre><br></div></div></li><li>  <b>Schauspieler + Jobs + Burst</b> <br><br>  Berechnung und Bewegung in Jobs aus Unity.Jobs 0.1.1-, Unity.Burst 1.1.2-Bibliotheken. <br>  Sicherheitschecks - aus <br>  Editor Anh√§ngen - aus <br>  JobsDebbuger - aus <br>  F√ºr den normalen Betrieb von IJobParallelForTransform verf√ºgen alle sich bewegenden Objekte √ºber ein √ºbergeordnetes Objekt (bis zu 255 Objekte in jedem √ºbergeordneten Objekt gem√§√ü der Empfehlung f√ºr maximale Leistung). <br><div class="spoiler">  <b class="spoiler_title">Code aktualisieren</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Tick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; handlePositionUpdate.Complete(); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> UNITY_EDITOR for (var i = 0; i &lt; index; i++) { var obj = nObj[i]; DebugDrowBox(obj.collBox, Color.blue, Time.deltaTime); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> jobPositionUpdate.nSetMove = nSetMove; jobPositionUpdate.nObj = nObj; jobPositionUpdate.deltaTime = delta; handlePositionUpdate = jobPositionUpdate.Schedule(transformsAccessArray); } } [BurstCompile] struct JobPositionUpdate : IJobParallelForTransform { public NativeArray&lt;SetMove&gt; nSetMove; public NativeArray&lt;Obj&gt; nObj; [Unity.Collections.ReadOnly] public float deltaTime; public void Execute(int index, TransformAccess transform) { var setMove = nSetMove[index]; var velocityToOneFrame = nSetMove[index].velocityToOneSecond * deltaTime; //    setMove.observedDistance += velocityToOneFrame; var t = setMove.observedDistance / setMove.distanceFull; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (t &gt; 1f) t = 1f; var newPos = t.CalculateBesierPos(setMove.posToMove.c0, setMove.posToMove.c2,setMove.posToMove.c1); nSetMove[index] = setMove; //   var obj = nObj[index]; obj.properties.c0 = newPos; var posAndSize = new float2x2 { c0 = newPos, c1 = obj.collBox.posAndSize.c1 }; obj.collBox = obj.entity.NewCollBox(posAndSize, new float2(10f, 10f), obj.rotation.ToEulerAnglesZ()); nObj[index] = obj; //     transform.position = (Vector2) newPos; } } public struct SetMove { public float2x3 posToMove; public float distanceFull; public float velocityToOneSecond; public float observedDistance; }</span></span></code> </pre></div></div></li><li>  <b>Schauspieler + Parallel</b> <br><br>  Anstelle der √ºblichen For-Schleife durch eine Gruppe sich bewegender Entit√§ten wird Parallel.For aus der System.Threading.Tasks-Bibliothek verwendet.  Es berechnet die neue Position und den Collider in parallelen Fl√ºssen.  Das Verschieben eines Objekts erfolgt in einer Nachbargruppe. <br><br><div class="spoiler">  <b class="spoiler_title">Code aktualisieren</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Tick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { Parallel.For(<span class="hljs-number"><span class="hljs-number">0</span></span>, groupMoveBezier.length, i =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> entity = <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> groupMoveBezier[i]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cMoveBezier = entity.ComponentMoveBezier_actorsParallel(); <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> entity.ComponentObject().obj; <span class="hljs-comment"><span class="hljs-comment">//    var velocityToOneFrame = cMoveBezier.velocityToOneSecond * delta; cMoveBezier.observedDistance += velocityToOneFrame; var t = cMoveBezier.observedDistance / cMoveBezier.distanceFull; if (t &gt; 1f) t = 1f; var newPos = t.CalculateBesierPos(cMoveBezier.posToMove.c0, cMoveBezier.posToMove.c2,cMoveBezier.posToMove.c1); //   obj.properties.c0 = newPos; var posAndSize = new float2x2 { c0 = newPos, c1 = obj.collBox1.posAndSize.c1 }; obj.collBox1 = obj.entity.NewCollBox(posAndSize, new float2(10f, 10f), obj.rotation.ToEulerAnglesZ()); }); //     foreach (ent entity1 in groupMoveBezier) { var cObject = entity1.ComponentObject(); cObject.tr.position = new Vector3(cObject.obj.properties.c0.x, cObject.obj.properties.c0.y, 0); #if UNITY_EDITOR DebugDrowBox(cObject.obj.collBox1, Color.blue, Time.deltaTime); #endif } }</span></span></code> </pre></div></div></li></ol><br><h3>  Testen mit dem Bewegen [1]: </h3><br><h4>  500 Objekte </h4><br><img src="https://habrastorage.org/webt/is/wq/_i/iswq_iqqpuheiv-vct58_6tipbs.gif"><br>  <i>(ein Bild aus dem Editor neben dem Text mit FPS, um zu zeigen, was dort visuell passiert)</i> <br><br><ol><li>  MonoBehaviour sequentiell: <br><br><img src="https://habrastorage.org/webt/0g/-a/uu/0g-auupzwzbmbwx68ozuwki3xpy.gif"></li><li>  Schauspieler nacheinander: <br><br><img src="https://habrastorage.org/webt/pn/st/on/pnstonrsw1zudeca6blkuhyaqji.gif"></li><li>  Schauspieler + Jobs + Burst: <br><br><img src="https://habrastorage.org/webt/f0/fg/gx/f0fggxzvfwrikw3kxx2e57p8m8c.gif"></li><li>  Schauspieler + Parallel. F√ºr: <br><br><img src="https://habrastorage.org/webt/rx/uy/7g/rxuy7gz1rrlho4wuikfyvb5iksa.gif"></li></ol><br><h4>  5000 Objekte </h4><br><img src="https://habrastorage.org/webt/8p/kk/ab/8pkkabfbfwvb_vhboiglblfjpxg.gif"><br><br><ol><li>  MonoBehaviour sequentiell: <br><br><img src="https://habrastorage.org/webt/s1/zt/us/s1ztusdaavnfpvjal2znusyd-gu.gif"></li><li>  Schauspieler nacheinander: <br><br><img src="https://habrastorage.org/webt/z3/z0/kt/z3z0ktt2gi9xykgi7q1vlklnse8.gif"></li><li>  Schauspieler + Jobs + Burst: <br><br><img src="https://habrastorage.org/webt/kj/xi/fy/kjxifyr7uelbmjajmssk7bvaarq.gif"></li><li>  Schauspieler + Parallel. F√ºr: <br><br><img src="https://habrastorage.org/webt/bk/oh/by/bkohbymh6bp0dhfzzja-o6zip6u.gif"></li></ol><br><br><h4>  50.000 Objekte </h4><br><img src="https://habrastorage.org/webt/3i/py/-o/3ipy-ohfhvyq0g8r4rwxylctjcw.gif"><br><ol><li>  MonoBehaviour sequentiell: <br><br><img src="https://habrastorage.org/webt/wc/lh/4s/wclh4sedli0fh0imvj0ooqa1om0.gif"></li><li>  Schauspieler nacheinander: <br><br><img src="https://habrastorage.org/webt/gm/yf/xo/gmyfxozvsk5pfgn6txu52enaiwq.gif"></li><li>  Schauspieler + Jobs + Burst: <br><br><img src="https://habrastorage.org/webt/j3/6t/wp/j36twp2pgdqzmkfp4mxbzmscboe.gif"></li><li>  Schauspieler + Parallel. F√ºr: <br><br><img src="https://habrastorage.org/webt/t_/ef/3c/t_ef3c6v9nwpu2utxjq8lgsjvta.gif"></li></ol><br><h4>  Actors + Threaded (integrierte Actors-Parallelisierung in System.Threading) </h4><br>  Schauspieler haben die F√§higkeit, alle Komponenten des Spiels in Strukturen anstatt in Klassen zu halten.  Dies sind H√§morrhoiden im Hinblick auf das Schreiben von Code, aber unter solchen Bedingungen arbeitet das Programm eher mit dem Stapel als mit dem verwalteten Haufen, was die Geschwindigkeit seiner Arbeit erheblich beeinflusst. <br><br><div class="spoiler">  <b class="spoiler_title">Code aktualisieren</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Tick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { groupMoveBezier.Execute(delta); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; groupMoveBezier.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cObject = <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> groupMoveBezier.entities[i].ComponentObject(); cObject.tr.position = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(cObject.obj.properties.c0.x, cObject.obj.properties.c0.y, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> UNITY_EDITOR DebugDrowBox(cObject.obj.collBox, Color.blue, Time.deltaTime); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> } } static void HandleCalculation(SegmentGroup segment) { for (int i = segment.indexFrom; i &lt; segment.indexTo; i++) { ref var entity = ref segment.source.entities[i]; ref var cMoveBezier = ref entity.ComponentMoveBezier(); ref var cObject = ref entity.ComponentObject(); ref var obj = ref cObject.obj; //    var velocityToOneFrame = cMoveBezier.velocityToOneSecond * segment.delta; cMoveBezier.observedDistance += velocityToOneFrame; var t = cMoveBezier.observedDistance / cMoveBezier.distanceFull; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (t &gt; 1f) t = 1f; var newPos = t.CalculateBesierPos(cMoveBezier.posToMove.c0, cMoveBezier.posToMove.c2, cMoveBezier.posToMove.c1); //   obj.properties.c0 = newPos; var posAndSize = new float2x2 { c0 = newPos, c1 = obj.collBox.posAndSize.c1 }; obj.collBox = obj.entity.NewCollBox(posAndSize, new float2(10f, 10f), obj.rotation.ToEulerAnglesZ()); } }</span></span></code> </pre><br></div></div><br>  auf Klassenkomponenten <br><img src="https://habrastorage.org/webt/m9/ag/e9/m9age9d6hsrwcwf5hhbjrh3_tis.gif"><br>  auf Strukturkomponenten <br><img src="https://habrastorage.org/webt/eq/a1/j4/eqa1j4-lg8v_ydiqjnoknb2ufde.gif"><br>  In diesem Fall erhalten wir + 10% FPS, aber im Beispiel gibt es nur zwei Komponentenstrukturen und nicht zehn, wie es im Endprodukt sein sollte.  Hier ist ein nichtlineares Wachstum von FPS m√∂glich, da die Komponenten des <i>Referenztypenprogramms</i> durch <i>Werttypen ersetzt werden</i> . <br><br><h3>  Fazit </h3><br><ul><li>  In allen F√§llen erh√∂ht sich die FPS in Actors without Parallel.For um etwa das Zweifache und damit - im Vergleich zu MonoBehavior sequentiell - um das Dreifache.  Mit der Zunahme der mathematischen Berechnungen bleiben diese Anteile erhalten. </li><li>  F√ºr mich ist ein zus√§tzlicher Vorteil von ECS Actors gegen√ºber MonoBehaviour Sequential, dass die Parallelisierung von Berechnungen, die zur Geschwindigkeit beitr√§gt, elementar hinzugef√ºgt wird. </li><li>  Die Verwendung von Actors + Jobs + Burst erh√∂ht die FPS um etwa das Zehnfache im Vergleich zu MonoBehaviour Sequential </li><li>  Zugegebenerma√üen ist eine solche Erh√∂hung der FPS gr√∂√ütenteils auf Burst zur√ºckzuf√ºhren.  Nat√ºrlich m√ºssen Sie f√ºr den normalen Betrieb Datentypen von Unity.Mathematics verwenden (ersetzen Sie z. B. Vector3 durch float3). <br>  <b>Und es ist sehr wichtig:</b> auf meinem Prozessor mit 50.000 Objekten auf dem Bildschirm, mit denen sich die FPS erh√∂hen lassen <img src="https://habrastorage.org/webt/is/8k/7f/is8k7fneqehd2avyvlkzahu0vvc.gif">  vorher <img src="https://habrastorage.org/webt/j3/6t/wp/j36twp2pgdqzmkfp4mxbzmscboe.gif">  ! <br>  Folgende Punkte sind zu beachten: <br>  1) Wenn Sie in den Berechnungen auf eine Bibliothek verzichten k√∂nnen, ist es besser, sie nicht zu verwenden (rote Markierung - schlecht, gr√ºn - gut) <br><img src="https://habrastorage.org/webt/gq/o4/k8/gqo4k8ngoxlspj_1219mwvvoive.png"><br>  2) Sie k√∂nnen die Mathf-Bibliothek nicht verwenden - nur Mathe, sonst kann Burst die Daten nicht vektorisieren und verarbeiten. <br><img src="https://habrastorage.org/webt/4j/ig/wx/4jigwxpyzyen5inij1vzpaqdedo.png"><br></li><li>  Nach mehreren Tests von Drittanbietern zeigt MonoBehavior Sequential mit 50.000 Objekten √ºberall die gleichen ~ 50 fps.  Aber die Arbeit an Actors + Jobs oder Threaded ist sehr unterschiedlich. <br>  Je moderner der Prozessor ist, desto n√ºtzlicher ist es, die Arbeit in mehrere in der Warteschlange stehende Jobs aufzuteilen: Positionsberechnung, Kollidierung, Anfahren einer Position. <br>  Sie k√∂nnen ein Testprogramm herunterladen und die Arbeit von Actors + Jobs + Burst [ein Job] mit Actors + Jobs + Burst [vier Jobs] vergleichen.  (Auf meinem 4-Core-Prozessor ohne Hyper-Trading ist der erste Test mit 50.000 Objekten -0,2 ms schneller) </li><li>  Die Wirksamkeit von ECS h√§ngt von der Anzahl der zus√§tzlichen Elemente ab (Render, Unity-Physik usw.). </li></ul><br>  <i>[1] Ich wei√ü nicht, wie die Leistung in anderen ECS-Frameworks in ECS-Unity / DOTS-Systemen ist.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Testquelle</b> <div class="spoiler_text">  ‚Üí <a href="https://github.com/Geobrain/Test-Actors" rel="nofollow">Repository</a> <br><img src="https://habrastorage.org/webt/aw/gu/ag/awguagisv_moemln21i52zyrfe0.png"><br></div></div><br>  Vielen Dank an Oleg Morozov (BenjaminMoore) f√ºr die Bearbeitung von Jobs, das Hinzuf√ºgen von SceneSelector und eines neuen FPS-Z√§hlers. <br>  Dank an iurii zakipnyi f√ºr die Anweisungen, √úberarbeitungen und den zus√§tzlichen Test Actors + Jobs + Burst [vier Job] </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de478824/">https://habr.com/ru/post/de478824/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de478812/index.html">Entwickeln Sie Hexapod von Grund auf neu (Teil 6) - √úbergang zum 3D-Druck</a></li>
<li><a href="../de478814/index.html">Wie Marketing es schneller macht, Ihre Smartphones aufzuladen</a></li>
<li><a href="../de478816/index.html">Testen von Android-Anwendungen mit Selenoid. Suchen Sie den Ort in einer mobilen App mit Appium</a></li>
<li><a href="../de478820/index.html">Vivaldi f√ºr Android: Eine Beta ist gut und die zweite ist besser</a></li>
<li><a href="../de478822/index.html">KI-Robotisierung mit InterSystems IRIS Data Platform</a></li>
<li><a href="../de478826/index.html">Reflexionen √ºber OOP und den Zustand von Objekten</a></li>
<li><a href="../de478830/index.html">Plesk, cPanel oder ISPmanager: Was soll man w√§hlen?</a></li>
<li><a href="../de478832/index.html">Verkehrsknotenpunkt: Von den Anf√§ngen bis zur Schaffung eines eigenen IX</a></li>
<li><a href="../de478834/index.html">Warum wir vor Angst wie bet√§ubt sind: Die Wirkung von Serotonin auf die Fortbewegung</a></li>
<li><a href="../de478836/index.html">Was ist √ºblich zwischen einem Revolver, Unterlegscheiben und einem autonomen Roboter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>