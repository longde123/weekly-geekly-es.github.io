<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôéüèø üö≥ üë©üèæ‚Äçü§ù‚Äçüë®üèª Combinando campos de distancia firmados en 2D üßö üèà üë©üèº‚Äçüç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En el tutorial anterior, aprendimos c√≥mo crear y mover formas simples usando funciones de distancia con signo. En este art√≠culo, aprenderemos c√≥mo com...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Combinando campos de distancia firmados en 2D</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438954/">  En el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tutorial anterior,</a> aprendimos c√≥mo crear y mover formas simples usando funciones de distancia con signo.  En este art√≠culo, aprenderemos c√≥mo combinar varias formas para crear campos de distancia m√°s complejos.  La mayor√≠a de las t√©cnicas descritas aqu√≠ las aprend√≠ de la biblioteca de funciones de distancia con el signo glsl, que se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  Tambi√©n hay varias formas de combinar formas, que no discuto aqu√≠. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n2/xg/4h/n2xg4h0rwnyo-k6s8f6yrkhihps.gif"></div><br><h2>  Preparaci√≥n </h2><br>  Para la visualizaci√≥n de campos de distancia con signo (campos de distancia con signo, SDF), utilizaremos una configuraci√≥n simple y luego le aplicaremos los operadores.  Para mostrar los campos de distancia, utilizar√° la visualizaci√≥n de las l√≠neas de distancia del primer tutorial.  En aras de la simplicidad, estableceremos todos los par√°metros, excepto los par√°metros de visualizaci√≥n en el c√≥digo, pero puede reemplazar cualquier valor con una propiedad para que sea personalizable. <br><a name="habracut"></a><br>  El sombreador principal con el que comenzaremos se ve as√≠: <br><br><pre><code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/035_2D_SDF_Combinations/Champfer Union"</span></span>{ Properties{ _InsideColor(<span class="hljs-string"><span class="hljs-string">"Inside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _OutsideColor(<span class="hljs-string"><span class="hljs-string">"Outside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _LineDistance(<span class="hljs-string"><span class="hljs-string">"Mayor Line Distance"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) = <span class="hljs-number"><span class="hljs-number">1</span></span> _LineThickness(<span class="hljs-string"><span class="hljs-string">"Mayor Line Thickness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.05</span></span> [IntRange]_SubLines(<span class="hljs-string"><span class="hljs-string">"Lines between major lines"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)) = <span class="hljs-number"><span class="hljs-number">4</span></span> _SubLineThickness(<span class="hljs-string"><span class="hljs-string">"Thickness of inbetween lines"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.05</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.01</span></span> } SubShader{ <span class="hljs-comment"><span class="hljs-comment">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #include "2D_SDF.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { const float PI = 3.14159; float2 squarePosition = position; squarePosition = translate(squarePosition, float2(1, 0)); squarePosition = rotate(squarePosition, .125); float squareShape = rectangle(squarePosition, float2(2, 2)); float2 circlePosition = position; circlePosition = translate(circlePosition, float2(-1.5, 0)); float circleShape = circle(circlePosition, 2.5); float combination = combination_function(circleShape, squareShape); return combination; } float4 _InsideColor; float4 _OutsideColor; float _LineDistance; float _LineThickness; float _SubLines; float _SubLineThickness; fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); fixed4 col = lerp(_InsideColor, _OutsideColor, step(0, dist)); float distanceChange = fwidth(dist) * 0.5; float majorLineDistance = abs(frac(dist / _LineDistance + 0.5) - 0.5) * _LineDistance; float majorLines = smoothstep(_LineThickness - distanceChange, _LineThickness + distanceChange, majorLineDistance); float distanceBetweenSubLines = _LineDistance / _SubLines; float subLineDistance = abs(frac(dist / distanceBetweenSubLines + 0.5) - 0.5) * distanceBetweenSubLines; float subLines = smoothstep(_SubLineThickness - distanceChange, _SubLineThickness + distanceChange, subLineDistance); return col * majorLines * subLines; } ENDCG } } FallBack "Standard" //fallback adds a shadow pass so we get shadows on other objects }</span></span></code> </pre> <br>  Y la funci√≥n 2D_SDF.cginc en la misma carpeta con el sombreador, que expandiremos, al principio se ve as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SDF_2D #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDF_2D </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//transforms float2 rotate(float2 samplePosition, float rotation){ const float PI = 3.14159; float angle = rotation * PI * 2 * -1; float sine, cosine; sincos(angle, sine, cosine); return float2(cosine * samplePosition.x + sine * samplePosition.y, cosine * samplePosition.y - sine * samplePosition.x); } float2 translate(float2 samplePosition, float2 offset){ //move samplepoint in the opposite direction that we want to move shapes in return samplePosition - offset; } float2 scale(float2 samplePosition, float scale){ return samplePosition / scale; } //shapes float circle(float2 samplePosition, float radius){ //get distance from center and grow it according to radius return length(samplePosition) - radius; } float rectangle(float2 samplePosition, float2 halfSize){ float2 componentWiseEdgeDistance = abs(samplePosition) - halfSize; float outsideDistance = length(max(componentWiseEdgeDistance, 0)); float insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 0); return outsideDistance + insideDistance; } #endif</span></span></span></span></code> </pre> <br><h2>  Combinaciones simples </h2><br>  Comenzaremos con algunas formas simples de combinar dos formas para crear una forma grande, conjugaciones, intersecciones y sustracciones, as√≠ como una forma de transformar una forma en otra. <br><br><h3>  Emparejamiento </h3><br>  El operador m√°s simple es el emparejamiento.  Con √©l, podemos juntar las dos figuras y obtener la distancia con el signo de la figura conectada.  Cuando tenemos una distancia con el signo de dos figuras, podemos combinarlas tomando la menor de las dos usando la funci√≥n <code>min</code> . <br><br>  Debido a la elecci√≥n del menor de los dos valores, la cifra final estar√° por debajo de 0 (visible) donde una de las dos figuras entrantes tiene una distancia al borde inferior a 0;  Lo mismo se aplica a todos los dem√°s valores de distancia, mostrando una combinaci√≥n de dos figuras. <br><br>  Aqu√≠ nombrar√© la funci√≥n para crear la conjugaci√≥n "fusionar", en parte porque las estamos fusionando, en parte porque la palabra clave de uni√≥n en hlsl est√° reservada, por lo que no se puede usar como el nombre de la funci√≥n. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc include file float merge(float shape1, float shape2){ return min(shape1, shape2); }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in scene function in shader float combination = merge(circleShape, squareShape);</span></span></code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/66d/888/a58/66d888a586750b51cede307c21d61a40.png"></div><br><br><h3>  Intersecci√≥n </h3><br>  Otra forma com√∫n de conectar formas es usar √°reas en las que se superponen dos formas.  Para hacer esto, tomamos el valor m√°ximo de las distancias de las dos figuras que queremos combinar.  Cuando usamos el mayor de los dos valores, obtenemos un valor mayor que 0 (fuera de la figura), cuando cualquiera de las distancias a las dos figuras est√° fuera de la figura, y otras distancias tambi√©n se alinean de manera similar. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc include file float intersect(float shape1, float shape2){ return max(shape1, shape2); }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in scene function in shader float combination = intersect(circleShape, squareShape);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f64/2be/6c0/f642be6c047b740e74f062cec23c3040.png"></div><br><h3>  Resta </h3><br>  Sin embargo, a menudo no queremos procesar ambas formas de la misma manera, y necesitamos restar la otra de una forma.  Esto es bastante f√°cil de hacer intersectando entre la forma que queremos cambiar y todo menos la forma que queremos restar.  Obtenemos los valores opuestos para las partes interna y externa de la figura, invirtiendo la distancia con el signo.  Lo que era 1 unidad fuera de la figura ahora es 1 unidad dentro. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc include file float subtract(float base, float subtraction){ return intersect(base, -subtraction); }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in scene function in shader float combination = subtract(squareShape, circleShape);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/495/7b2/258/4957b2258a8b8f8724e7daf8ba503d64.png"></div><br><h3>  Interpolaci√≥n </h3><br>  Una forma no obvia de combinar dos figuras es interpolar entre ellas.  Tambi√©n es posible hasta cierto punto para mallas poligonales con formas de mezcla, pero es mucho m√°s limitado que lo que podemos hacer con campos de distancia con signo.  Por simple interpolaci√≥n entre las distancias de dos figuras, logramos un flujo suave de una a la otra.  Para la interpolaci√≥n, simplemente puede usar el m√©todo <code>lerp</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc include file float interpolate(float shape1, float shape2, float amount){ return lerp(shape1, shape2, amount); }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in scene function in shader float pulse = sin(_Time.y) * 0.5 + 0.5; float combination = interpolate(circleShape, pulse);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b06/3cf/2ec/b063cf2ece8b291553e941acc487f478.gif"></div><br><h2>  Otros compuestos </h2><br>  Habiendo recibido conexiones simples, ya tenemos todo lo necesario para una combinaci√≥n simple de figuras, pero la sorprendente propiedad de los campos de signos de distancia es que no podemos limitarnos a esto, hay muchas formas diferentes de combinar figuras y realizar acciones interesantes en los lugares de su conexi√≥n.  Aqu√≠ explicar√© solo algunas de estas t√©cnicas nuevamente, pero puede encontrar muchas otras en la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://mercury.sexy/hg_sdf</a> (escr√≠bame si conoce otras bibliotecas SDF √∫tiles). <br><br><h3>  Redondeo </h3><br>  Podemos interpretar la superficie de dos figuras combinadas como el eje xy el eje y de la posici√≥n en el sistema de coordenadas, y luego calcular la distancia al origen de coordenadas de esta posici√≥n.  Si hacemos esto, obtendremos una figura muy extra√±a, pero si limitamos el eje a valores inferiores a 0, obtendremos algo que se asemeja a la conjugaci√≥n suave de las distancias internas de dos figuras. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">round_merge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius)</span></span></span></span>{ float2 intersectionSpace = float2(shape1, shape2); intersectionSpace = min(intersectionSpace, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length(intersectionSpace); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f76/a37/693/f76a37693bd0ac5aa8b7d41b784931a6.png"></div><br>  Esto es hermoso, pero no podemos usar esto para cambiar la l√≠nea donde la distancia es 0, por lo que esta operaci√≥n no es m√°s valiosa que el emparejamiento ordinario.  Pero antes de conectar las dos figuras, podemos aumentarlas un poco.  De la misma manera que creamos un c√≠rculo, para agrandar una figura, la restamos de su distancia para empujar una l√≠nea m√°s hacia afuera, en la cual la distancia con un signo es 0. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> radius = max(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(_Time.y * <span class="hljs-number"><span class="hljs-number">5</span></span>) * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> combination = round_intersect(squareShape, circleShape, radius);</code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">round_merge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius)</span></span></span></span>{ float2 intersectionSpace = float2(shape1 - radius, shape2 - radius); intersectionSpace = min(intersectionSpace, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length(intersectionSpace); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5f/507/a6d/e5f507a6dd0fb29da209c760889497fa.gif"></div><br>  Simplemente ampl√≠a la figura y garantiza transiciones suaves en el interior, pero no queremos aumentar las figuras, solo necesitamos una transici√≥n suave.  La soluci√≥n es restar el radio nuevamente despu√©s de calcular la longitud.  La mayor√≠a de las partes se ver√°n igual que antes, excepto por la transici√≥n entre las figuras, que se suaviza maravillosamente de acuerdo con el radio.  Ignoraremos la parte exterior de la figura por ahora. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">round_merge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius)</span></span></span></span>{ float2 intersectionSpace = float2(shape1 - radius, shape2 - radius); intersectionSpace = min(intersectionSpace, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length(intersectionSpace) - radius; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4b/09d/0d5/b4b09d0d5e0d0dd92a8c120225dbe73a.gif"></div><br>  La √∫ltima etapa es la correcci√≥n de la parte externa de la figura.  Adem√°s, mientras que el interior de la figura es verde, y usamos este color para el exterior.  El primer paso es intercambiar las partes externas e internas, simplemente invirtiendo su distancia con un signo.  Luego reemplazamos la parte donde se resta el radio.  Primero lo cambiamos de la resta a la suma.  Esto es necesario, porque antes de combinar con el radio, dibujamos la distancia del vector, por lo tanto, de acuerdo con esto, debemos invertir la operaci√≥n matem√°tica utilizada.  Luego, reemplazaremos el radio con el mate habitual, lo que nos dar√° los valores correctos fuera de la figura, pero no cerca de los bordes y dentro de la figura.  Para evitar esto, tomamos un m√°ximo entre el valor y el radio, obteniendo as√≠ un valor positivo de los valores correctos fuera de la figura, as√≠ como la suma del radio que necesitamos dentro de la figura. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">round_merge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius)</span></span></span></span>{ float2 intersectionSpace = float2(shape1 - radius, shape2 - radius); intersectionSpace = min(intersectionSpace, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> insideDistance = -length(intersectionSpace); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> simpleUnion = merge(shape1, shape2); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> outsideDistance = max(simpleUnion, radius); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> insideDistance + outsideDistance; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5e/079/968/b5e079968ff81efdccdde19d7a07aeeb.gif"></div><br>  Para crear una intersecci√≥n, necesitamos hacer lo contrario: reducir las figuras por el radio, asegurarnos de que todos los componentes del vector sean mayores que 0, tomar la longitud y no cambiar su signo.  Entonces crearemos la parte exterior de la figura.  Luego, para crear la parte interna, tomamos la intersecci√≥n habitual y nos aseguramos de que no sea menor que menos el radio.  Luego, como antes, agregamos los valores internos y externos. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">round_intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius)</span></span></span></span>{ float2 intersectionSpace = float2(shape1 + radius, shape2 + radius); intersectionSpace = max(intersectionSpace, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> outsideDistance = length(intersectionSpace); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> simpleIntersection = intersect(shape1, shape2); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> insideDistance = min(simpleIntersection, -radius); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> outsideDistance + insideDistance; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/326/08f/268/32608f2685455f44a602a2c5ad12babf.gif"></div><br>  Y como √∫ltimo punto, la resta se puede describir nuevamente como la intersecci√≥n entre la figura base y todo excepto la figura que estamos restando. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">round_subtract</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> base, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> subtraction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius)</span></span></span></span>{ round_intersect(base, -subtraction, radius); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/888/6b6/ea9/8886b6ea90411b4cffdf901160498de5.gif"></div><br>  Aqu√≠, y especialmente al restar, puede ver artefactos derivados de la suposici√≥n de que podemos usar dos figuras como coordenadas, pero para la mayor√≠a de las aplicaciones, los campos de distancia siguen siendo lo suficientemente buenos. <br><br><h3>  Bisel </h3><br>  Tambi√©n podemos cortar la transici√≥n para darle un √°ngulo como un chafl√°n.  Para lograr este efecto, primero creamos una nueva forma agregando las dos existentes.  Si asumimos nuevamente que el punto en el que se encuentran las dos figuras es ortogonal, entonces esta operaci√≥n nos dar√° una l√≠nea diagonal que pasa por el punto de encuentro de las dos superficies. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab0/fa1/e52/ab0fa1e525ecc833f006cb23fc9c1748.png"></div><br>  Como simplemente agregamos los dos componentes, la distancia con el signo de esta nueva l√≠nea tiene una escala incorrecta, pero podemos corregirla dividi√©ndola por la diagonal de una unidad cuadrada, es decir, la ra√≠z cuadrada de 2. La divisi√≥n por la ra√≠z de 2 es igual a multiplicando por la ra√≠z cuadrada de 0.5, y simplemente podemos escribir este valor en el c√≥digo para no calcular la misma ra√≠z cada vez. <br><br>  Ahora que tenemos una forma que tiene la forma de un bisel deseado, la expandiremos para que el bisel se extienda m√°s all√° de los l√≠mites de la figura.  De la misma manera que antes, restamos el valor que necesitamos para aumentar la cifra.  Luego combinamos la forma de bisel con la salida de la fusi√≥n habitual, lo que resulta en una transici√≥n biselada. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> champferSize = <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(_Time.y * <span class="hljs-number"><span class="hljs-number">5</span></span>) * <span class="hljs-number"><span class="hljs-number">0.3</span></span> + <span class="hljs-number"><span class="hljs-number">0.3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> combination = champfer_merge(circleShape, squareShape, champferSize);</code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">champfer_merge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> champferSize)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SQRT_05 = <span class="hljs-number"><span class="hljs-number">0.70710678118</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> simpleMerge = merge(shape1, shape2); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> champfer = (shape1 + shape2) * SQRT_05; champfer = champfer - champferSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> merge(simpleMerge, champfer); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4fc/103/174/4fc103174057617093fc3b3511f734b1.gif"></div><br>  Para obtener un bisel cruzado, nosotros, como antes, agregamos dos figuras, pero luego reducimos la figura agregando el bisel e intersectamos con la figura cruzada habitual. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">champfer_intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> champferSize)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SQRT_05 = <span class="hljs-number"><span class="hljs-number">0.70710678118</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> simpleIntersect = intersect(shape1, shape2); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> champfer = (shape1 + shape2) * SQRT_05; champfer = champfer + champferSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> intersect(simpleIntersect, champfer); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ca/36f/b07/1ca36fb07d7b3943b6ebfbab12fe098a.gif"></div><br>  Y de manera similar a las restas anteriores, tambi√©n podemos realizar la intersecci√≥n con la segunda figura invertida aqu√≠. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">champfer_subtract</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> base, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> subtraction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> champferSize)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> champfer_intersect(base, -subtraction, champferSize); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28e/63a/5ca/28e63a5ca39ac18b239b8101df781410.gif"></div><br><h3>  Intersecci√≥n redondeada </h3><br>  Hasta ahora, hemos utilizado solo operadores booleanos (excepto la interpolaci√≥n).  Pero podemos combinar las formas de otras formas, por ejemplo, creando nuevas formas redondeadas en los lugares donde se superponen los bordes de las dos formas. <br><br>  Para hacer esto, nuevamente necesitamos interpretar las dos figuras como el eje xy el eje y del punto.  Luego simplemente calculamos la distancia de este punto al origen.  Cuando los l√≠mites de las dos figuras se superponen, la distancia a ambas figuras ser√° 0, lo que nos da una distancia de 0 al punto de origen de nuestro sistema de coordenadas imaginario.  Luego, si tenemos una distancia al origen, podemos realizar las mismas operaciones con √©l que para los c√≠rculos y restar el radio. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">round_border</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius)</span></span></span></span>{ float2 position = float2(shape1, shape2); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distanceFromBorderIntersection = length(position); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distanceFromBorderIntersection - radius; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf6/64b/ad1/bf664bad1818151d8736cbf686aec0bd.png"></div><br><h3>  Muesca de borde </h3><br>  Lo √∫ltimo que explicar√© es la forma de crear una muesca en una forma en la posici√≥n del borde de otra forma. <br><br>  Comenzamos calculando la forma del l√≠mite del c√≠rculo.  Esto se puede hacer obteniendo el valor absoluto de la distancia de la primera figura, mientras que las partes interna y externa se considerar√°n la parte interna de la figura, pero el borde a√∫n tiene el valor 0. Si aumentamos esta figura restando el ancho de la muesca, obtendremos la figura a lo largo del borde de la figura anterior. . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> depth = max(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(_Time.y * <span class="hljs-number"><span class="hljs-number">5</span></span>) * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> combination = groove_border(squareShape, circleShape, <span class="hljs-number"><span class="hljs-number">.3</span></span>, depth);</code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groove_border</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> base, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> groove, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> depth)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> circleBorder = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(groove) - width; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> circleBorder; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a87/d6d/f27/a87d6df2778599af9e321a4f09beb019.png"></div><br>  Ahora necesitamos que el borde del c√≠rculo sea m√°s profundo solo por el valor que especificamos.  Para hacer esto, restamos una versi√≥n reducida de la figura base.  La cantidad de reducci√≥n en la forma de la base es la profundidad de la muesca. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groove_border</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> base, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> groove, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> depth)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> circleBorder = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(groove) - width; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> grooveShape = subtract(circleBorder, base + depth); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grooveShape; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/259/175/81d/25917581df8a9f60193af32c6972f8b9.gif"></div><br>  El √∫ltimo paso es restar la muesca de la forma de la base y devolver el resultado. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groove_border</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> base, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> groove, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> depth)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> circleBorder = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(groove) - width; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> grooveShape = subtract(circleBorder, base + depth); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> subtract(base, grooveShape); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbf/569/f3b/bbf569f3b98efc61fa60228940a4b593.gif"></div><br><h2>  C√≥digo fuente </h2><br><h3>  La biblioteca </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/035_SDF_combining_repeating/Fancy/2D_SDF.cginc</a> </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SDF_2D #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDF_2D </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//transforms float2 rotate(float2 samplePosition, float rotation){ const float PI = 3.14159; float angle = rotation * PI * 2 * -1; float sine, cosine; sincos(angle, sine, cosine); return float2(cosine * samplePosition.x + sine * samplePosition.y, cosine * samplePosition.y - sine * samplePosition.x); } float2 translate(float2 samplePosition, float2 offset){ //move samplepoint in the opposite direction that we want to move shapes in return samplePosition - offset; } float2 scale(float2 samplePosition, float scale){ return samplePosition / scale; } //combinations ///basic float merge(float shape1, float shape2){ return min(shape1, shape2); } float intersect(float shape1, float shape2){ return max(shape1, shape2); } float subtract(float base, float subtraction){ return intersect(base, -subtraction); } float interpolate(float shape1, float shape2, float amount){ return lerp(shape1, shape2, amount); } /// round float round_merge(float shape1, float shape2, float radius){ float2 intersectionSpace = float2(shape1 - radius, shape2 - radius); intersectionSpace = min(intersectionSpace, 0); float insideDistance = -length(intersectionSpace); float simpleUnion = merge(shape1, shape2); float outsideDistance = max(simpleUnion, radius); return insideDistance + outsideDistance; } float round_intersect(float shape1, float shape2, float radius){ float2 intersectionSpace = float2(shape1 + radius, shape2 + radius); intersectionSpace = max(intersectionSpace, 0); float outsideDistance = length(intersectionSpace); float simpleIntersection = intersect(shape1, shape2); float insideDistance = min(simpleIntersection, -radius); return outsideDistance + insideDistance; } float round_subtract(float base, float subtraction, float radius){ return round_intersect(base, -subtraction, radius); } ///champfer float champfer_merge(float shape1, float shape2, float champferSize){ const float SQRT_05 = 0.70710678118; float simpleMerge = merge(shape1, shape2); float champfer = (shape1 + shape2) * SQRT_05; champfer = champfer - champferSize; return merge(simpleMerge, champfer); } float champfer_intersect(float shape1, float shape2, float champferSize){ const float SQRT_05 = 0.70710678118; float simpleIntersect = intersect(shape1, shape2); float champfer = (shape1 + shape2) * SQRT_05; champfer = champfer + champferSize; return intersect(simpleIntersect, champfer); } float champfer_subtract(float base, float subtraction, float champferSize){ return champfer_intersect(base, -subtraction, champferSize); } /// round border intersection float round_border(float shape1, float shape2, float radius){ float2 position = float2(shape1, shape2); float distanceFromBorderIntersection = length(position); return distanceFromBorderIntersection - radius; } float groove_border(float base, float groove, float width, float depth){ float circleBorder = abs(groove) - width; float grooveShape = subtract(circleBorder, base + depth); return subtract(base, grooveShape); } //shapes float circle(float2 samplePosition, float radius){ //get distance from center and grow it according to radius return length(samplePosition) - radius; } float rectangle(float2 samplePosition, float2 halfSize){ float2 componentWiseEdgeDistance = abs(samplePosition) - halfSize; float outsideDistance = length(max(componentWiseEdgeDistance, 0)); float insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 0); return outsideDistance + insideDistance; } #endif</span></span></span></span></code> </pre> <br><h3>  Base de sombreador </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/035_SDF_combining_repeating/Simple/sdf_union.shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/035_SDF_combining_repeating/Simple/sdf_intersect.shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/035_SDF_combining_repeating/Simple/sdf_subtract.shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/035_SDF_combining_repeating/Simple/sdf_interpolate.shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/035_SDF_combining_repeating/Fancy/sdf_round.shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/035_SDF_combining_repeating/Fancy/sdf_champfer.shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/035_SDF_combining_repeating/Fancy/sdf_border_intersection.shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/035_SDF_combining_repeating/Fancy/sdf_groove.shader</a> </li></ul><br><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/035_2D_SDF_Combinations/Round"</span></span>{ Properties{ _InsideColor(<span class="hljs-string"><span class="hljs-string">"Inside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _OutsideColor(<span class="hljs-string"><span class="hljs-string">"Outside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _LineDistance(<span class="hljs-string"><span class="hljs-string">"Mayor Line Distance"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) = <span class="hljs-number"><span class="hljs-number">1</span></span> _LineThickness(<span class="hljs-string"><span class="hljs-string">"Mayor Line Thickness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.05</span></span> [IntRange]_SubLines(<span class="hljs-string"><span class="hljs-string">"Lines between major lines"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)) = <span class="hljs-number"><span class="hljs-number">4</span></span> _SubLineThickness(<span class="hljs-string"><span class="hljs-string">"Thickness of inbetween lines"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.05</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.01</span></span> } SubShader{ <span class="hljs-comment"><span class="hljs-comment">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #include "2D_SDF.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { const float PI = 3.14159; float2 squarePosition = position; squarePosition = translate(squarePosition, float2(1, 0)); squarePosition = rotate(squarePosition, .125); float squareShape = rectangle(squarePosition, float2(2, 2)); float2 circlePosition = position; circlePosition = translate(circlePosition, float2(-1.5, 0)); float circleShape = circle(circlePosition, 2.5); float combination = /* combination calculation here */; return combination; } float4 _InsideColor; float4 _OutsideColor; float _LineDistance; float _LineThickness; float _SubLines; float _SubLineThickness; fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); fixed4 col = lerp(_InsideColor, _OutsideColor, step(0, dist)); float distanceChange = fwidth(dist) * 0.5; float majorLineDistance = abs(frac(dist / _LineDistance + 0.5) - 0.5) * _LineDistance; float majorLines = smoothstep(_LineThickness - distanceChange, _LineThickness + distanceChange, majorLineDistance); float distanceBetweenSubLines = _LineDistance / _SubLines; float subLineDistance = abs(frac(dist / distanceBetweenSubLines + 0.5) - 0.5) * distanceBetweenSubLines; float subLines = smoothstep(_SubLineThickness - distanceChange, _SubLineThickness + distanceChange, subLineDistance); return col * majorLines * subLines; } ENDCG } } FallBack "Standard" //fallback adds a shadow pass so we get shadows on other objects }</span></span></code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/438954/">https://habr.com/ru/post/438954/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../438942/index.html">Sombras 2D en campos de distancia firmados</a></li>
<li><a href="../438946/index.html">DateTimeOffset (Strict)</a></li>
<li><a href="../438948/index.html">¬øPor qu√© necesitamos una optimizaci√≥n de bajo nivel en Elbrus o c√≥mo acelerar el sistema de reconocimiento una vez y media</a></li>
<li><a href="../438950/index.html">El Banco Central lanz√≥ un robot para buscar esquemas de ingresos en Internet</a></li>
<li><a href="../438952/index.html">Lo que puedes aprender al desarrollar un reproductor de audio para diferentes navegadores</a></li>
<li><a href="../438956/index.html">Magnetitis en los dientes: secuenciaci√≥n de transcriptomos del tejido de la c√°scara de molusco radula</a></li>
<li><a href="../438958/index.html">ILV confirm√≥ la existencia de su "estaci√≥n espacial"</a></li>
<li><a href="../438960/index.html">C√≥mo renunci√© a Ruby a favor de Python mientras trabajaba en un backend</a></li>
<li><a href="../438962/index.html">En su mayor parte, una perspectiva positiva para el futuro de los chips.</a></li>
<li><a href="../438964/index.html">¬øQui√©n est√° realmente detr√°s de las populares VPN gratuitas?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>