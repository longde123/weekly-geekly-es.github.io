<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💂 🧕🏿 👏🏿 Zoo afl 📂 👆🏻 🕶️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werden wir nicht über die klassische AFL selbst sprechen, sondern über Dienstprogramme, die für sie entwickelt wurden, und ihre Modi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zoo afl</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/449134/"><img src="https://habrastorage.org/webt/l4/vc/qr/l4vcqrdnz0vgsseyssmztrfrvdg.jpeg" alt="Bild"><br><br>  In diesem Artikel werden wir nicht über die klassische AFL selbst sprechen, sondern über Dienstprogramme, die für sie entwickelt wurden, und ihre Modifikationen, die unserer Ansicht nach die Qualität des Fuzzing erheblich verbessern können.  Wenn Sie wissen möchten, wie Sie die AFL steigern und mehr Schwachstellen schneller finden können, lesen Sie weiter! <br><a name="habracut"></a><br><h1>  Was ist AFL und wofür ist es gut? </h1><br>  AFL ist ein deckungsgesteuerter oder rückkopplungsbasierter Fuzzer.  Weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen zu</a> diesen Konzepten finden Sie in einem coolen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel mit dem Titel „Fuzzing: Art, Science and Engineering“</a> .  Lassen Sie uns allgemeine Informationen zu AFL zusammenfassen: <br><br><ul><li>  Es ändert die ausführbare Datei, um herauszufinden, wie sie die Abdeckung beeinflusst. </li><li>  Mutiert Eingabedaten, um die Abdeckung zu maximieren. </li><li>  Wiederholt den vorherigen Schritt, um herauszufinden, wo das Programm abstürzt. <ul><li>  Es ist sehr effektiv, was durch die Praxis bewiesen wird. <ul><li>  Es ist sehr einfach zu bedienen. </li></ul></li></ul></li></ul><br><br>  Hier ist eine grafische Darstellung: <br><br><img src="https://habrastorage.org/webt/iq/5z/au/iq5zaub6qftefx3x_q5te6d6guo.png" alt="Bild"><br><br>  Wenn Sie nicht wissen, was AFL ist, finden Sie hier eine Liste hilfreicher Ressourcen, mit denen Sie beginnen können: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die offizielle Seite des Projekts</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">afl-training</a> - eine kurze Einführung in AFL. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">afl-demo</a> - eine einfache Demo zum Fuzzing von C ++ - Programmen mit AFL. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">afl-cve</a> - eine Sammlung der mit AFL gefundenen Schwachstellen (wurde seit 2017 nicht aktualisiert). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier können</a> Sie lesen, was AFL einem Programm während seiner Erstellung hinzufügt. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einige</a> nützliche Tipps zum Fuzzing von Netzwerkanwendungen. </li></ol><br>  Zum Zeitpunkt der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erstellung</a> dieses Artikels war die neueste Version von AFL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.52b</a> .  Der Fuzzer befindet sich in der aktiven Entwicklung, und mit der Zeit werden einige Nebenentwicklungen in den Hauptzweig der AFL integriert und werden irrelevant.  Heute können wir einige nützliche Zubehörwerkzeuge nennen, die im folgenden Kapitel aufgeführt sind. <br><br><div class="spoiler">  <b class="spoiler_title">Rode0day Wettbewerb</b> <div class="spoiler_text">  Erwähnenswert ist auch der monatliche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rode0day-</a> Wettbewerb - ein Ereignis, bei dem Fuzzers versuchen, die größte Anzahl von Fehlern mit weniger Zeit als ihre Gegner in vorgefertigten Korpora mit und ohne Zugriff auf den Quellcode zu finden.  Rode0day ist seiner Natur nach ein Kampf zwischen verschiedenen Modifikationen und Gabeln von AFL. <br></div></div><br>  Einige AFL-Benutzer stellten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fest,</a> dass sein Autor, Michal Zalewski, das Projekt offenbar seit dem letzten Änderungsdatum bis zum 5. November 2017 aufgegeben hatte. Dies könnte damit zusammenhängen, dass er Google verlässt und an einigen neuen Projekten arbeitet.  Daher haben Benutzer begonnen, selbst neue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Patches</a> für die letzte aktuelle Version 2.52b zu erstellen. <br><br><img src="https://habrastorage.org/webt/fy/00/xa/fy00xat3cumh3iq9a5biou30czi.png" alt="Bild"><br><br>  Es gibt auch verschiedene Variationen und Ableitungen von AFL, mit denen Python, Go, Rust, OCaml, GCJ Java, Kernel-Systemaufrufe oder sogar ganze VMs verwirrt werden können. <br><br><div class="spoiler">  <b class="spoiler_title">AFL für andere Programmiersprachen</b> <div class="spoiler_text"><br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">python-afl</a> - für Python. <br>  - <a href="">afl.rs</a> - für Fuzzing-Programme, die auf Rust geschrieben wurden. <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">afl-fuzz-js</a> - afl-fuzz für Javascript. <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">java-afl</a> - AFL-Fuzzing für Java. <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kelinci</a> - ein weiterer Fuzzer für Java (ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> zum Thema). <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Javan-Warzenschwein</a> - AFL-ähnlicher Fuzzer für JVM. <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">afl-swift</a> - für Fuzzing-Programme, die auf Swift geschrieben wurden. <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ocamlopt-afl</a> - für OCaml. <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sharpfuzz</a> - fuzzer basierend auf afl für .net. <br></div></div><br><h1>  Zubehörwerkzeuge </h1><br>  In diesem Kapitel haben wir verschiedene Skripte und Tools für AFL gesammelt und in mehrere Kategorien unterteilt: <br><br>  <u>Crash-Verarbeitung</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">afl-utils</a> - eine Reihe von Dienstprogrammen zur automatischen Verarbeitung / Analyse von Abstürzen und zur Reduzierung der Anzahl von Testfällen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">afl-Crash-Analyzer</a> - ein weiterer Crash-Analyzer für AFL. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fuzzer-utils</a> - eine Reihe von Skripten zur Analyse der Ergebnisse. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">atriage</a> - ein einfaches Triage-Tool. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">afl-kit</a> - afl-cmin auf Python. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AFLize</a> - ein Tool, das automatisch Builds von Debian-Paketen generiert, die für AFL geeignet sind. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">afl-fid</a> - eine Reihe von Tools zum Arbeiten mit Eingabedaten. </li></ul><br>  <u>Arbeiten Sie mit Codeabdeckung</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">afl-cov</a> - liefert menschenfreundliche Daten zur Abdeckung. </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">count-afl-calls</a> - Verhältnisbewertung.  Das Skript zählt die Anzahl der Instrumentierungsblöcke in der Binärdatei. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">afl-sancov</a> - ist wie afl-cov, verwendet jedoch ein klirrendes Desinfektionsmittel. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">covnavi</a> - ein Skript zur Abdeckung von Code und Analyse durch die Cisco Talos Group. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LAF LLVM Passes</a> - so etwas wie eine Sammlung von Patches für AFL, die den Code ändern, um dem Fuzzer das Auffinden von Zweigen zu erleichtern. </li></ul><br>  <u>Einige Skripte zur Minimierung von Testfällen</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">afl-pytmin</a> - ein Wrapper für afl-tmin, der versucht, den Prozess der Minimierung von Testfällen durch Verwendung vieler CPU-Kerne zu beschleunigen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">afl-ddmin-mod</a> - eine Variation von afl-tmin basierend auf dem ddmin-Algorithmus. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">halfempty</a> - ist ein schnelles Dienstprogramm zur Minimierung von Testfällen von Tavis Ormandy basierend auf Parallelisierung. </li></ul><br>  <u>Verteilte Ausführung</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">disfuzz-afl</a> - verteiltes Fuzzing für AFL. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AFLDFF</a> - AFL verteiltes Fuzzing-Framework. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">afl-launch</a> - ein Tool zur Ausführung vieler AFL-Instanzen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">afl-Mothership</a> - Verwaltung und Ausführung vieler synchronisierter AFL-Fuzzers in der AWS Cloud. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">afl-in-the-cloud</a> - ein weiteres Skript zum Ausführen von AFL in AWS. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VU_BSc_project</a> - Fuzzing-Test der Open Source-Bibliotheken mit libFuzzer und AFL. </li></ul><br>  Kürzlich wurde ein sehr guter Artikel mit dem Titel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Skalieren von AFL auf eine 256-Thread-Maschine" veröffentlicht</a> . <br><br>  <u>Bereitstellung, Verwaltung, Überwachung, Berichterstellung</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">afl-other-arch</a> - ist eine Reihe von Patches und Skripten zum einfachen Hinzufügen von Unterstützung für verschiedene Nicht-x86-Architekturen für AFL. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">afl-trivia</a> - ein paar kleine Skripte zur Vereinfachung der Verwaltung von AFL. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">afl-monitor</a> - ein Skript zur Überwachung der AFL. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">afl-manager</a> - ein Webserver unter Python zum Verwalten von Multi-AFL. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">afl-tools</a> - ein Bild eines Dockers mit afl-latest, afl-dyninst und Triforce-afl. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">afl-remote</a> - ein Webserver für die Remoteverwaltung von AFL-Instanzen. </li></ul><br><h1>  AFL-Änderungen </h1><br>  AFL hatte einen sehr starken Einfluss auf die Community der Vulnerabilitätsforscher und das Fuzzing selbst.  Es ist überhaupt nicht überraschend, dass die Leute nach einiger Zeit anfingen, Modifikationen vorzunehmen, die von der ursprünglichen AFL inspiriert waren.  Schauen wir sie uns an.  In verschiedenen Situationen hat jede dieser Modifikationen ihre eigenen Vor- und Nachteile im Vergleich zur ursprünglichen AFL. <br><br>  Fast alle Mods finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hub.docker.com</a> <br><br>  Wofür? <br><br><ul><li>  Erhöhen Sie die Geschwindigkeit und / oder die Codeabdeckung <br><ul><li>  Algorithmen </li><li>  Umwelt <br><ul><li>  Betriebssystem </li><li>  Hardware </li></ul></li></ul><br></li><li>  Arbeiten ohne Quellcode <br><ul><li>  Code-Emulation </li><li>  Code-Instrumentierung <br><ul><li>  Statisch </li><li>  Dynamisch </li></ul></li></ul></li></ul><br>  <u>Standardmodi des AFL-Betriebs</u> <br><br>  Bevor wir verschiedene Modifikationen und Gabeln von AFL untersuchen, müssen wir über zwei wichtige Modi sprechen, die ebenfalls Modifikationen in der Vergangenheit waren, aber schließlich aufgenommen wurden.  Sie sind Syzygy und Qemu. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Syzygy-</a> Modus - ist der Arbeitsmodus in instrument.exe <pre><code class="bash hljs">instrument.exe --mode=afl --input-image=test.exe --output-image=test.instr.exe</code> </pre>  Syzygy ermöglicht das statische Umschreiben von PE32-Binärdateien mit AFL, erfordert jedoch Symbole und einen zusätzlichen Entwickler, um den WinAFL-Kernel darauf aufmerksam zu machen. <br><br>  Qemu-Modus - Die Funktionsweise unter QEMU finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Interna of AFL Fuzzer - QEMU Instrumentation“</a> .  Die Unterstützung für die Arbeit mit Binärdateien mit QEMU wurde der vorgelagerten AFL in Version 1.31b hinzugefügt.  Der AFL QEMU-Modus arbeitet mit der zusätzlichen Funktionalität der binären Instrumentierung in der binären Übersetzungs-Engine qemu tcg (einem winzigen Codegenerator).  Zu diesem Zweck verfügt AFL über ein Build-Skript qemu, das die Quellen einer bestimmten Version von qemu (2.10.0) extrahiert, sie auf mehrere kleine Patches legt und für eine definierte Architektur erstellt.  Dann wird eine Datei namens afl-qemu-trace erstellt, die tatsächlich eine Datei der Benutzermodus-Emulation von (Emulation nur ausführbarer ELF-Dateien) qemu- ist.  Somit ist es möglich, Fuzzing mit Feedback zu Elf-Binärdateien für viele verschiedene von qemu unterstützte Architekturen zu verwenden.  Außerdem erhalten Sie alle coolen AFL-Tools, vom Monitor mit Informationen zur aktuellen Sitzung bis hin zu fortgeschrittenen Dingen wie afl-analyse.  Sie erhalten aber auch die Einschränkungen von Qemu.  Wenn eine Datei mit einer Toolchain unter Verwendung von Hardware-SoC-Funktionen erstellt wird, die die Binärdatei startet und von qemu nicht unterstützt wird, wird das Fuzzing unterbrochen, sobald eine bestimmte Anweisung vorliegt oder ein bestimmtes MMIO verwendet wird. <br><br>  Hier ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">weitere interessante Gabelung</a> des Qemu-Modus, bei der die Geschwindigkeit mit TCG-Code-Instrumentierung und Einlösung um das 3-4-fache erhöht wurde. <br><br>  <u>Gabeln</u> <br><br>  Das Auftreten von AFL-Gabeln hängt in erster Linie mit den Änderungen und Verbesserungen der Algorithmen der klassischen AFL zusammen. <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pe-afl</a> - Eine Modifikation zum Fuzzing von PE-Dateien, die keinen Quellcode im Windows-Betriebssystem haben.  Für den Betrieb analysiert der Fuzzer ein Zielprogramm mit IDA Pro und generiert die Informationen für die folgenden statischen Instrumente.  Eine instrumentierte Version wird dann mit AFL fuzzed. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">afl-cygwin</a> - ist ein Versuch, die klassische AFL mit Cygwin auf Windows zu portieren.  Leider hat es viele Fehler, es ist sehr langsam und die Entwicklung von wurde aufgegeben. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AFLFast</a> (erweitert AFL um Power Schedules) - eine der ersten AFL-Gabeln.  Es wurden Heuristiken hinzugefügt, die es ihm ermöglichen, in kurzer Zeit mehr Pfade zu durchlaufen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FairFuzz</a> - eine Erweiterung für AFL, die auf seltene Branchen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">abzielt</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AFLGo</a> - ist eine Erweiterung für AFL, mit der bestimmte Teile des Codes anstelle der vollständigen Programmabdeckung aufgerufen werden können.  Es kann zum Testen von Patches oder neu hinzugefügten Codefragmenten verwendet werden. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PerfFuzz</a> - eine Erweiterung für AFL, die nach Testfällen sucht, die das Programm erheblich verlangsamen könnten. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pythia</a> - ist eine Erweiterung für AFL, die vorhersagen soll, wie schwierig es ist, neue Pfade zu finden. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Angora</a> - ist einer der neuesten Fuzzers, geschrieben auf Rost.  Es verwendet neue Strategien zur Mutation und zur Erhöhung der Abdeckung. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Neuzz</a> - Fuzzing mit neuronalen Netwoks. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UnTracer-AFL</a> - Integration von AFl in UnTracer zur effektiven Rückverfolgung. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Qsym</a> - Praktische Concolic Execution Engine, zugeschnitten auf Hybrid-Fuzzing.  Im Wesentlichen handelt es sich um eine symbolische Ausführungs-Engine (grundlegende Komponenten werden als Plugin für Intel Pin realisiert), die zusammen mit AFL Hybrid-Fuzzing ausführt.  Dies ist eine Phase in der Entwicklung des Feedback-basierten Fuzzing und erfordert eine separate Diskussion.  Sein Hauptvorteil ist, dass die konkolische Ausführung relativ schnell erfolgen kann.  Dies ist auf die native Ausführung von Befehlen ohne Zwischendarstellung von Code, Snapshots und einigen Heuristiken zurückzuführen.  Es verwendet den alten Intel-Pin (aufgrund von Unterstützungsproblemen zwischen libz3 und anderen DBTs) und kann derzeit mit elf x86- und x86_64-Architekturen arbeiten. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Superion</a> - Greybox Fuzzer, ein offensichtlicher Vorteil davon ist, dass er zusammen mit einem instrumentierten Programm auch die Spezifikation von Eingabedaten unter Verwendung der ANTLR-Grammatik erhält und anschließend mithilfe dieser Grammatik Mutationen durchführt. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AFLSmart</a> - Ein weiterer Graybox-Fuzzer.  Als Eingabe erhält es eine Spezifikation der Eingabedaten in dem vom Peach Fuzzer verwendeten Format. </li></ul><br>  Es gibt viele Forschungsarbeiten, die sich mit der Implementierung der neuen Ansätze und Fuzzing-Techniken befassen, bei denen AFL modifiziert wird.  Es sind nur White Papers verfügbar, daher haben wir uns nicht einmal die Mühe gemacht, diese zu erwähnen.  Sie können sie googeln, wenn Sie möchten.  Einige der neuesten sind beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CollAFL: Path Sensitive Fuzzing</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EnFuzz</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Effizienter Ansatz zum Fuzzing von Interpreten"</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ML</a> für AFL. <br><br>  <u>Änderungen basierend auf Qemu</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TriforceAFL</a> - AFL / QEMU-Fuzzing mit vollständiger Emulation eines Systems.  Eine Gabel von nccgroup.  Ermöglicht das Fuzzing des gesamten Betriebssystems im QEMU-Modus.  Dies wird mit einer speziellen Anweisung (aflCall (0f 24)) realisiert, die in der QEMU x64-CPU hinzugefügt wurde.  Leider wird es nicht mehr unterstützt.  Die letzte Version von AFL ist 2.06b. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TriforceLinuxSyscallFuzzer</a> - das Fuzzing von Linux-Systemaufrufen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">afl-qai</a> - ein kleines Demo-Projekt mit QEMU Augmented Instrumentation (qai). </li></ul><br>  <u>Eine Modifikation basierend auf KLEE</u> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kleefl</a> - zum Generieren von Testfällen mittels symbolischer Ausführung (bei großen Programmen sehr langsam). <br><br>  <u>Eine Modifikation basierend auf Unicorn</u> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">afl-</a> unicorn - Ermöglicht das Fuzzing von Codefragmenten durch Emulieren in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unicorn Engine</a> .  Wir haben diese Variante von AFL in unserer Praxis erfolgreich in den Bereichen des Codes eines bestimmten RTOS verwendet, der auf SOC ausgeführt wurde, sodass wir den QEMU-Modus nicht verwenden konnten.  Die Verwendung dieser Änderung ist gerechtfertigt, wenn wir keine Quellen haben (wir können keine eigenständige Binärdatei für die Analyse des Parsers erstellen) und das Programm keine Eingabedaten direkt nimmt (z. B. Daten) ist verschlüsselt oder ist ein Signalbeispiel wie in einer CGC-Binärdatei), dann können wir die vermeintlichen Ortsfunktionen umkehren und finden, bei denen die Daten in einem für den Fuzzer geeigneten Format verarbeitet werden.  Dies ist die allgemeinste / universellste Modifikation von AFL, d. H. Sie ermöglicht das Fuzzing von allem.  Es ist unabhängig von Architektur, Quellen, Eingabedatenformat und Binärformat (das auffälligste Beispiel für Bare-Metal - nur Codefragmente aus dem Speicher des Controllers).  Der Forscher untersucht zuerst diese Binärdatei und schreibt einen Fuzzer, der den Status am Eingang der Parser-Prozedur emuliert.  Im Gegensatz zu AFL erfordert dies natürlich eine gewisse Prüfung der Binärdatei.  Bei Bare-Metal-Firmware wie Wi-FI oder Basisband gibt es bestimmte Nachteile, die Sie beachten müssen: <br><br><ol><li>  Wir müssen die Prüfung der Kontrollsumme lokalisieren. </li><li>  Beachten Sie, dass der Status des Fuzzers ein Speicherstatus ist, der im Speicherauszug gespeichert wurde, wodurch verhindert werden kann, dass der Fuzzer zu bestimmten Pfaden gelangt. </li><li>  Es gibt keine Bereinigung von Aufrufen des dynamischen Speichers, aber es kann manuell realisiert werden und hängt von RTOS ab (muss untersucht werden). </li><li>  Die Intertask-RTOS-Interaktion wird nicht emuliert, wodurch auch das Auffinden bestimmter Pfade verhindert werden kann. </li></ol><br>  Ein Beispiel für die Arbeit mit dieser Modifikation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"afl-Einhorn: Fuzzing Arbitrary Binary Code"</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"afl-Einhorn: Teil 2 - Fuzzing the 'Unfuzzable'"</a> . <br><br>  Bevor wir zu den Änderungen übergehen, die auf den Frameworks der dynamischen binären Instrumentierung (DBI) basieren, dürfen wir nicht vergessen, dass DynamoRIO, Dynlnst und schließlich PIN die höchste Geschwindigkeit dieser Frameworks anzeigen. <br><br>  <u>PIN-basierte Änderungen</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aflpin</a> - AFL mit Intel PIN-Instrumentierung. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">afl_pin_mode</a> - eine weitere AFL-Instrumentierung, die über die Intel-PIN realisiert wird. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">afl-pin</a> - AFL mit PINtool. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NaFl</a> - Ein Klon (des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grundkerns</a> ) von AFL Fuzzer. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PinAFL</a> - Der Autor dieses Tools hat versucht, AFL auf Windows zu portieren, um bereits kompilierte Binärdateien zu verwischen.  Scheint, als wäre es über Nacht nur zum Spaß gemacht worden;  Das Projekt ist nie weiter gegangen.  Das Repository verfügt nicht über Quellen, sondern nur über kompilierte Binärdateien und Startanweisungen.  Wir wissen nicht, auf welcher AFL-Version es basiert, und es werden nur 32-Bit-Anwendungen unterstützt. </li></ul><br>  Wie Sie sehen können, gibt es viele verschiedene Modifikationen, die jedoch im wirklichen Leben nicht sehr nützlich sind. <br><br>  <u>Dyninst-basierte Modifikationen</u> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">afl-dyninst</a> - Amerikanischer Fuzzy Lop + Dyninst == AFL Balckbox Fuzzing.  Das Merkmal dieser Version ist, dass zuerst ein recherchiertes Programm (ohne den Quellcode) statisch (statische binäre Instrumentierung, statisches binäres Umschreiben) mit Duninst instrumentiert wird und dann mit der klassischen AFL verwirrt wird, die denkt, dass das Programm mit afl- erstellt wird. gcc / afl-g ++ / afl-as;) Infolgedessen kann ohne den Quellcode mit einer sehr guten Produktivität gearbeitet werden. Früher war die Geschwindigkeit im Vergleich zu einer nativen Kompilierung 0,25-fach.  Es hat einen signifikanten Vorteil gegenüber QEMU: Es ermöglicht die Instrumentierung dynamisch verknüpfter Bibliotheken, während QEMU nur die statische Basisdatei instrumentieren kann, die statisch mit Bibliotheken verknüpft ist.  Leider ist es jetzt nur für Linux relevant.  Für die Windows-Unterstützung sind Änderungen an Dyninst selbst erforderlich, die gerade <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">durchgeführt werden</a> . <br><br>  Es gibt noch eine weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gabel</a> mit verbesserter Geschwindigkeit und bestimmten Funktionen (Unterstützung von AARCH64- und PPC-Architekturen). <br><br>  <u>Änderungen basierend auf DynamoRIO</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">drAFL</a> - AFl + DynamoRIO - Fuzzing ohne Quellen unter Linux. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">afl-dr</a> - eine weitere Implementierung basierend auf DynamoRIO, die auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Habr</a> sehr gut beschrieben wurde. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">afl-dynamorio</a> - eine Modifikation von vanhauser-thc.  Dazu sagt er Folgendes: "Führen Sie AFL mit DynamoRIO aus, wenn der normale afl-Dyninst die Binärdatei zum Absturz bringt und der QEMU-Modus -Q keine Option ist."  Es unterstützt ARM und AARCH64.  In Bezug auf die Produktivität: DynamoRIO ist ungefähr 10 Mal langsamer als Qemu, 25 Mal langsamer als Dyninst, aber ungefähr 10 Mal schneller als Pintool. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WinAFL</a> - das bekannteste AFL- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gabelfenster</a> .  (DynamoRIO, auch Syzygy-Modus).  Es war nur eine Frage der Zeit, bis dieser Mod erschien, da viele AFL unter Windows ausprobieren und auf Apps ohne Quellen anwenden wollten.  Derzeit wird dieses Tool aktiv verbessert. Unabhängig von einer relativ veralteten Codebasis von AFL (2.43b, wenn dieser Artikel geschrieben wird) hat es geholfen, mehrere Schwachstellen zu finden (CVE-2016-7212, CVE-2017-0073, CVE- 2017-0190, CVE-2017-11816).  Die Spezialisten des Google Zero Project-Teams und des MSRC Vulnerabilities and Mitigations-Teams arbeiten an diesem Projekt, sodass wir auf die weitere Entwicklung hoffen können.  Anstelle der Instrumentierung zur Kompilierungszeit verwendeten die Entwickler eine dynamische Instrumentierung (basierend auf DynamoRIO), die die Ausführung der analysierten Software erheblich verlangsamte. Der daraus resultierende Overhead (verdoppelt) ist jedoch mit dem der klassischen AFL im Binärmodus vergleichbar.  Sie lösten auch das Problem des schnellen Prozessstarts, indem sie es als dauerhaften Fuzzing-Modus bezeichneten.  Sie wählen die zu fusselnde Funktion (nach dem Versatz in der Datei oder nach dem Namen der in der Exporttabelle vorhandenen Funktion) und instrumentieren sie so, dass sie im Zyklus aufgerufen werden kann, wodurch mehrere Eingabedatenbeispiele gestartet werden, ohne den Prozess neu zu starten.  Kürzlich erschien ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> , in dem beschrieben wurde, wie die Autoren mit WinAFL in etwa 50 Tagen rund 50 Sicherheitslücken gefunden haben.  Kurz vor der Veröffentlichung wurde WinAFL um den Intel PT-Modus erweitert.  Detalis finden Sie <a href="">hier</a> . </li></ul><br>  Ein fortgeschrittener Leser könnte feststellen, dass es mit allen gängigen Instrumentierungs-Frameworks außer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Frida</a> Modifikationen gibt.  Die einzige Erwähnung der Verwendung von Frida mit AFL fand sich in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Chizpurfle: Ein Gray-Box-Android-Fuzzer für die Anpassung von Anbieterservices".</a>  Eine Version von AFL mit Frida ist sehr nützlich, da Frida mehrere RISC-Architekturen unterstützt. <br><br>  Viele Forscher freuen sich auch auf die Veröffentlichung des DBI Scopio-Frameworks durch den Schöpfer von Capstone, Unicorn und Keystone.  Basierend auf diesem Framework haben die Autoren bereits einen Fuzzer (Darko) erstellt und verwenden ihn demnach erfolgreich, um eingebettete Geräte zu fuzzeln.  Weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen</a> hierzu finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Tief graben: 0 Tage in eingebetteten Systemen mit Code Coverage Guided Fuzzing finden".</a> <br><br>  <u>Änderungen basierend auf den Hardwarefunktionen des Prozessors</u> <br><br>  Wenn es um AFL-Modifikationen mit Unterstützung von Prozessorhardwarefunktionen geht, ermöglicht dies zum einen das Fuzzing von Kernel-Code und zum anderen das Fuzzing von Apps ohne Quellcode. <br><br>  Und natürlich sind wir in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bezug auf</a> Prozessorhardwarefunktionen vor allem an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intel PT</a> (Processor Tracing) interessiert.  Es ist ab der 6. Generation von Prozessoren verfügbar (ungefähr seit 2015).  Um die unten aufgeführten Fuzzers verwenden zu können, benötigen Sie einen Prozessor, der Intel PT unterstützt. <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WinAFL-IntelPT</a> - eine WinAFL-Modifikation eines Drittanbieters, die Intel PT anstelle von DynamoRIO verwendet. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kAFL</a> - ist ein akademisches Projekt zur Lösung des abdeckungsgesteuerten Problems für das OS-unabhängige Fuzzing des Kernels.  Das Problem wird mithilfe eines Hypervisors und Intel PT gelöst.  Weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen</a> finden Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Whitepaper "kAFL: Hardware-Assisted Feedback Fuzzing für OS-Kernel"</a> . </li></ul><br><h1>  Fazit </h1><br>  Wie Sie sehen können, entwickelt sich der Bereich der AFL-Modifikationen aktiv weiter.  Dennoch gibt es Raum für Experimente und kreative Lösungen;  Sie können eine nützliche und interessante neue Modifikation erstellen. <br><br>  Danke fürs Lesen und viel Glück beim Fuzzing! <br><br>  <b>Co-Autor:</b> Nikita Knyzhov <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Presler</a> <br><br>  <i>PS Dank an das Team des Forschungszentrums, ohne das dieser Artikel nicht möglich wäre.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de449134/">https://habr.com/ru/post/de449134/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de449120/index.html">Mit Bart, in dunkler Brille und im Profil: schwierige Situationen für Computer Vision</a></li>
<li><a href="../de449122/index.html">Bedauern, dass in C ++ keine vollwertige statische Aufladung vorhanden ist, wenn oder ...</a></li>
<li><a href="../de449124/index.html">So schwer zu finden, leicht zu übersehen und unmöglich auszugeben</a></li>
<li><a href="../de449128/index.html">Top-Spieleentwicklungsunternehmen der Welt</a></li>
<li><a href="../de449132/index.html">Top 17 Plugins für Android Studio</a></li>
<li><a href="../de449138/index.html">5 Gründe für Crypto-Hat Warum IT-Leute Bitcoin nicht mögen</a></li>
<li><a href="../de449140/index.html">Hinterlassen Sie eine Anfrage und wir werden Ihnen innerhalb von 1 Minute online antworten. Oder wie wir uns von OTRS entfernt haben</a></li>
<li><a href="../de449142/index.html">Microbiota. Welche Bakterien leben im Darm der Russen?</a></li>
<li><a href="../de449144/index.html">Grundlagen der JavaScript-Engine: Prototypoptimierung. Teil 2</a></li>
<li><a href="../de449146/index.html">Aber winken wir nicht der optischen Kommunikation zu? Laser, Weltraum, CubeSat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>