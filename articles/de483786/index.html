<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¶üèΩ üî¥ ‚õ©Ô∏è Hybrides Sortieren üßíüèº ü•† ‚òîÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wie jeder wei√ü, kann das Sortieren auf Austauschen, Einf√ºgen, Ausw√§hlen, Zusammenf√ºhren und Verteilen basieren. 

 Wenn jedoch verschiedene Methoden i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hybrides Sortieren</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/483786/"> <a href="https://habr.com/ru/company/edison/blog/483786/"><img width="694" height="321" src="https://habrastorage.org/webt/ql/cs/2p/qlcs2psim6ksv4hbrwrndioyifi.png"></a> <br><br>  Wie jeder wei√ü, kann das Sortieren auf Austauschen, Einf√ºgen, Ausw√§hlen, Zusammenf√ºhren und Verteilen basieren. <br><br>  Wenn jedoch verschiedene Methoden im Algorithmus kombiniert werden, geh√∂rt er zur Klasse der Hybridsorten. <a name="habracut"></a><habracut text=""></habracut><blockquote> <a href="https://www.edsd.ru/" title="EDISON Software - Webentwicklung"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISON Software - Webentwicklung"></a> <br clear="right">  Dieser Artikel wurde mit der Unterst√ºtzung von EDISON verfasst. <br><br>  Wir <a href="https://www.edsd.ru/ru/o_kompanii/novosti/dorabotka-i-soprovozhdenie-sajta-na-1s-bitriks">k√ºmmern</a> uns um die <a href="https://www.edsd.ru/ru/o_kompanii/novosti/dorabotka-i-soprovozhdenie-sajta-na-1s-bitriks">Fertigstellung und Wartung von Websites auf 1C-Bitrix</a> sowie um die <a href="https://www.edsd.ru/ru/proekty/mobilnye_prilozhenija">Entwicklung von mobilen Anwendungen f√ºr Android und iOS</a> . <br><br>  Wir lieben die Theorie der Algorithmen!  ;-) </blockquote>  Erinnern wir uns schnell daran, welche Klassen Sortieralgorithmen haben und welche Merkmale sie haben. <br><br><h4>  Sortierungen austauschen </h4><img align="right" width="350" height="132" src="https://habrastorage.org/webt/ay/2k/km/ay2kkmr3ipze-pdbcmxfjgdp-le.png"><br>  Die Elemente des Arrays werden paarweise miteinander verglichen und es erfolgt ein Austausch gegen ungeordnete Paare. <br><br>  Der effektivste Vertreter dieser Klasse ist die legend√§re <b>schnelle Sorte</b> . <br><br><h4>  Einf√ºgesortierung </h4><img align="right" width="398" height="102" src="https://habrastorage.org/webt/tm/hd/35/tmhd35egnxxtisoa_zd8d_ucggi.png"><br>  Elemente aus dem unsortierten Teil des Arrays werden an ihren Stellen im sortierten Bereich eingef√ºgt. <br><br>  In dieser Klasse <b>wird</b> am h√§ufigsten <b>nach einfachen Einf√ºgungen sortiert</b> .  Obwohl dieser Algorithmus eine durchschnittliche Komplexit√§t von O ( <b>n <sup>2</sup></b> ) aufweist, funktioniert diese Sortierung bei fast geordneten Arrays sehr schnell - auf diesen erreicht die Komplexit√§t O ( <b>n</b> ).  Dar√ºber hinaus ist diese Sortierung eine der besten Optionen f√ºr die Verarbeitung kleiner Arrays. <br><br>  Zu dieser Klasse geh√∂rt auch das <b>Sortieren nach dem bin√§ren Suchbaum</b> . <br><br><h4>  Nach Auswahl sortieren </h4><img align="right" width="300" height="100" src="https://habrastorage.org/webt/gp/bh/ho/gpbhhomuobutgbg6l-r9basjzlg.png"><br>  Im ungeordneten Bereich wird das Minimum / Maximum-Element ausgew√§hlt, das an das Ende / den Anfang des unsortierten Teils des Arrays √ºbertragen wird. <br><br>  Das Sortieren mit einer einfachen Auswahl funktioniert sehr langsam (im Durchschnitt O ( <b>n <sup>2</sup></b> )), aber in dieser Klasse gibt es eine schwierige <b>Sortierung nach einem Haufen</b> (auch als <b>pyramidenf√∂rmige Sortierung bezeichnet</b> ), die eine zeitliche Komplexit√§t von O ( <b>n</b> log <b>n</b> ) aufweist - und die sehr wertvoll ist. Es gibt keine entarteten F√§lle dieser Sortierung, unabh√§ngig von den eingehenden Daten.  √úbrigens hat diese Sortierung auch nicht die besten F√§lle f√ºr eingehende Daten. <br><br><h4>  Sortierungen zusammenf√ºhren </h4><br>  Die sortierten Bereiche werden in das Array aufgenommen und zusammengef√ºhrt, dh die kleineren sortierten Subarrays werden zu einem gr√∂√üeren sortierten Subarray zusammengefasst. <br><br><div style="text-align:center;"><img width="677" height="50" src="https://habrastorage.org/webt/qm/mh/vn/qmmhvnkmevjb34akg2dxjquef90.png"></div><br><br>  Wenn zwei Subarrays sortiert sind, ist das Kombinieren eine einfach zu implementierende und schnell durchzuf√ºhrende Operation.  Die Kehrseite der Medaille ist, dass das Zusammenf√ºhren fast immer die Kosten f√ºr zus√§tzlichen O ( <b>n</b> ) -Speicher erfordert - obwohl eine √§u√üerst kleine Anzahl besonders ausgefeilter Sortieroptionen f√ºr das Zusammenf√ºhren bekannt ist, bei denen die Speicherkosten O (1) betragen. <br><br><h4>  Nach Verteilung sortieren </h4><br>  Die Elemente des Arrays werden verteilt und in Klassen umverteilt, bis das Array einen sortierten Zustand annimmt. <br><br>  Elemente werden entweder abh√§ngig von ihrem Wert (den sogenannten <b>Z√§hlsortierungen</b> ) oder abh√§ngig vom Wert einzelner Ziffern (dies sind bereits <b>bitweise Sortierungen</b> ) in Gruppen gestreut. <br><br><div style="text-align:center;"><img width="657" height="219" src="https://habrastorage.org/webt/42/ch/6z/42ch6zg2eg2zfkqbmgxmte9arii.png"></div><br><br>  Zu dieser Klasse geh√∂rt auch die Eimersortierung. <br><br>  Ein Merkmal der Sortierung nach Verteilung ist, dass sie entweder keine paarweisen Vergleiche von Elementen untereinander verwenden oder solche Vergleiche in geringem Umfang vorliegen.  Daher ist die Sortierung nach Verteilung oft schneller als die Geschwindigkeit, beispielsweise die schnelle Sortierung.  Andererseits erfordert das Sortieren nach Verteilung h√§ufig viel zus√§tzlichen Speicher, da Gruppen von st√§ndig neu verteilten Elementen irgendwo gespeichert werden m√ºssen. <br><br><hr><hr><hr><hr><hr><br>  Auseinandersetzungen dar√ºber, welche Sortierung <i>die beste ist,</i> sind sehr h√§ufig, aber Tatsache ist, dass es keinen idealen Algorithmus f√ºr alle Gelegenheiten gibt und nicht geben kann.  Zum Beispiel ist das schnelle Sortieren in den meisten Situationen sehr schnell (aber nicht am schnellsten), es st√∂√üt jedoch auch auf entartete F√§lle, in denen ein Absturz auftritt.  Das Sortieren nach einfachen Einf√ºgungen ist langsam, aber bei fast geordneten Arrays werden andere Algorithmen leicht umgangen.  Die Heap-Sortierung funktioniert bei eingehenden Daten recht schnell, ist jedoch unter bestimmten Bedingungen nicht so schnell wie andere Sortierungen, und es gibt keine M√∂glichkeit, die Pyramide zu beschleunigen.  Das Sortieren durch Zusammenf√ºhren ist langsamer als das schnelle Sortieren. Wenn das Array jedoch sortierte Unterfelder enth√§lt, ist das Zusammenf√ºhren schneller als das Sortieren durch schnelles Sortieren.  Wenn das Array viele sich wiederholende Elemente enth√§lt oder wir die Zeilen sortieren, ist die Sortierung nach Verteilung am wahrscheinlichsten.  Jede Methode ist in ihrer g√ºnstigsten Situation besonders gut. <br><br>  Dennoch erfinden Programmierer weiterhin die schnellsten Sortierungen der Welt und synthetisieren die effektivsten Methoden aus verschiedenen Klassen.  Mal sehen, wie erfolgreich es f√ºr sie ist. <br><br>  Da im Artikel viele nicht-triviale Algorithmen erw√§hnt werden, beschreibe ich nur kurz die Grundlagen ihrer Arbeit, ohne den Artikel mit Animationen und detaillierten Erkl√§rungen zu √ºberladen.  In Zukunft wird es separate Artikel geben, in denen es Cartoons f√ºr jeden Algorithmus und detaillierte, subtile Nuancen geben wird. <br><br><hr><hr><hr><hr><hr><br><h2>  Einf√ºgen + Zusammenf√ºhren </h2><br>  Eine rein empirische Schlussfolgerung ist, dass Fusion und / oder Insertion in Hybriden am h√§ufigsten verwendet werden.  In den meisten Sortierungen wird die eine oder die andere Methode gefunden oder beides zusammen.  Und daf√ºr gibt es eine logische Erkl√§rung. <br><br>  Sortiererfinder bem√ºhen sich h√§ufig, parallele Algorithmen zu erstellen, die gleichzeitig verschiedene Teile eines Arrays anordnen.  Der beste Weg, um mit mehreren sortierten Subarrays umzugehen, besteht darin, sie zusammenzuf√ºhren - dies ist der schnellste Weg. <br><br>  Moderne Algorithmen verwenden h√§ufig die Rekursion.  W√§hrend eines rekursiven Abstiegs wird das Array normalerweise in zwei Teile geteilt, auf der untersten Ebene wird das Array geordnet.  Bei der R√ºckkehr zu h√∂heren Rekursionsebenen stellt sich die Frage, ob auf niedrigeren Ebenen sortierte Subarrays kombiniert werden sollen. <br><br>  Was die Einf√ºgungen betrifft, so werden in hybriden Algorithmen in bestimmten Stadien oft ungef√§hr geordnete Unteranordnungen erhalten, die am besten mit Hilfe von Einf√ºgungen zur endg√ºltigen Anordnung gef√ºhrt werden. <br><br>  Diese Gruppe enth√§lt Hybridsorten, bei denen eine Zusammenf√ºhrung und Einf√ºgung erfolgt, und diese Methoden werden sehr unterschiedlich verwendet. <br><br><h3>  Sortieren nach Zusammenf√ºhrungseinf√ºgung <br>  Ford-Johnson-Algorithmus :: Ford-Johnson-Algorithmus </h3><br><h4>  <i>Zusammenf√ºhren + Einf√ºgen</i> </h4><img align="right" width="200" height="285" src="https://habrastorage.org/webt/pr/io/c-/prioc-ed14huk3as3gadpjccxks.jpeg"><br clear="left">  Ein sehr alter Weg, schon 1959.  Es wird ausf√ºhrlich in der unsterblichen Arbeit von Donald Knuth, "Die Kunst des Programmierens", Band 3, "Sortieren und Suchen", Kapitel 5, "Sortieren", Abschnitt 5.3, "Optimale Sortierung", Unterabschnitt "Sortieren mit einer minimalen Anzahl von Vergleichen" und Abschnitt "Sortieren nach Einf√ºgungen und Zusammenf√ºhren" beschrieben. . <br><br>  Sortieren hat jetzt keinen praktischen Wert, ist aber f√ºr diejenigen interessant, die die Theorie der Algorithmen lieben.  Das Problem, einen Weg zu finden, um <b>n</b> Elemente mit der geringsten Anzahl von Vergleichen zu sortieren, wird in Betracht gezogen.  Eine nicht triviale heuristische Modifikation wird f√ºr die Einf√ºgungssortierung (eine solche Einf√ºgung finden Sie sonst nirgendwo) unter Verwendung von <a href="https://ru.wikipedia.org/wiki/%25D0%25A7%25D0%25B8%25D1%2581%25D0%25BB%25D0%25B0_%25D0%25AF%25D0%25BA%25D0%25BE%25D0%25B1%25D1%2581%25D1%2582%25D0%25B0%25D0%25BB%25D1%258F">Jacobstal-Zahlen</a> vorgeschlagen, um die Anzahl der Vergleiche zu minimieren.  Bisher ist auch bekannt, dass dies nicht die beste Option ist und Sie noch geschickter ausweichen und noch weniger Vergleiche erhalten k√∂nnen.  Im Allgemeinen ist die akademische Standardsortierung nicht von praktischem Nutzen, aber f√ºr Kenner des Genres ist es ein Vergn√ºgen, solche Tricks mit einer algebraischen Tendenz zu disassemblieren. <br><br><h3>  Tim Sort :: Timsort </h3><br><h4>  <i>Einf√ºgen + Zusammenf√ºhren</i> </h4><img align="right" width="530" height="192" src="https://habrastorage.org/webt/cu/mf/fu/cumfful_rsg9ipz1yryimfpldxi.jpeg"><br clear="left">  <i>Gepostet von Tim Peters vor 15 Jahren und jetzt</i> <br><br>  Diese Sortierung auf Habr√© wird sehr oft erinnert. <br>  These: In einem Array werden fast geordnete kleine Subarrays gesucht, f√ºr die die Einf√ºgesortierung verwendet wird.  Diese Subarrays werden dann mit Merge zusammengef√ºhrt. <br><br>  Die Zusammenf√ºhrung in TimSort ist der interessanteste Teil: Die klassische Zusammenf√ºhrung nach oben wird f√ºr verschiedene Situationen weiter optimiert.  Beispielsweise ist es bekannt, dass das Zusammenf√ºhren effizienter ist, wenn die verbundenen Unteranordnungen ungef√§hr dieselbe Gr√∂√üe haben.  Wenn die Gr√∂√üen in TimSort sehr unterschiedlich sind, erfolgt nach zus√§tzlichen Aktionen eine Anpassung (wir k√∂nnen sagen, dass einige der Elemente vom gr√∂√üeren Subarray zu einem kleineren "flie√üen", wonach der Zusammenschluss im Standardmodus fortgesetzt wird).  Es gibt auch verschiedene heimt√ºckische Situationen - zum Beispiel, wenn in einem Subarray alle Elemente kleiner sind als in einem anderen.  In diesem Fall ist der Vergleich von Elementen aus beiden Unterfeldern inaktiv.  Das modifizierte Fusionsverfahren wird eine solche unerw√ºnschte Entwicklung von Ereignissen rechtzeitig ‚Äûbemerken‚Äú und, wenn es von einer pessimistischen Option unter Verwendung der bin√§ren Suche ‚Äû√ºberzeugt‚Äú ist, zu einer optimaleren Verarbeitungsoption wechseln. <br><br>  Im Durchschnitt arbeitet diese Sortierung etwas langsamer als QuickSort. Wenn das eingehende Array jedoch eine ausreichende Anzahl von geordneten Teilsequenzen von Elementen enth√§lt, erh√∂ht sich die Geschwindigkeit erheblich und TimSort √ºbertrifft den Rest. <br><br><h3>  Block Merge Sort :: Block Merge Sort <br>  Wiki-Sortierung :: Wiki-Sortierung <br>  Heilige Gralsorte :: Grailsort </h3><br><h4>  <i>F√ºgt + Merge + Buckets ein</i> </h4><img align="right" width="343" height="240" src="https://habrastorage.org/webt/bz/ev/g6/bzevg6rsbv563fjqzz-hsqpfeso.gif"><br clear="left">  <i>Blockieren Sie die Animation zum Sortieren von Zusammenf√ºhrungen aus Wikipedia.</i> <br><br>  Dies ist ein sehr frischer (2008) und gleichzeitig sehr vielversprechender Algorithmus.  Tatsache ist, dass das relativ bedeutende Problem des Zusammenf√ºhrens die Kosten f√ºr zus√§tzlichen Speicher sind.  In der Regel ist dort, wo das Zusammenf√ºhren stattfindet, auch die Komplexit√§t von O ( <b>n</b> ) Speicher vorhanden. <br><br>  WikiSort ist jedoch so konzipiert, dass das Zusammenf√ºhren ohne die Verwendung von zus√§tzlichem Speicher erfolgt - unter Zusammenf√ºhrungsarten ist dies in dieser Hinsicht eine sehr seltene Instanz.  Au√üerdem ist der Algorithmus stabil.  Nun, wenn die konventionelle Sortierung der Zusammenf√ºhrung die beste algorithmische Geschwindigkeit O ( <b>n</b> log <b>n</b> ) hat, dann ist dieser Indikator in der Wiki-Sortierung O ( <b>n</b> ).  Bis vor kurzem glaubte man, dass das Zusammenf√ºhren von Sortierungen mit solchen Merkmalen prinzipiell unm√∂glich sei, aber chinesische Programmierer √ºberraschten alle. <br><br>  Der Algorithmus ist sehr kompliziert in ein paar S√§tzen zu erkl√§ren.  Aber eines Tages werde ich einen separaten Habrast √ºber ihn schreiben. <br><br>  Anfangs hie√ü der Algorithmus namenlos Block Merge Sort, doch mit der leichten Hand von Tim Peters, der die Sortierung im Detail studierte (um festzustellen, ob einige seiner Ideen auf TimSort √ºbertragen werden sollten), blieb der Name WikiSort dabei. <br><br>  Der fr√ºhzeitig <a href="https://habr.com/ru/users/mrrl/" class="user_link">verstorbene</a> Habruiser <a href="https://habr.com/ru/users/mrrl/" class="user_link">Mrrl</a> arbeitete mehrere Jahre selbst√§ndig an der Zusammenf√ºhrungssortierung, die gleichzeitig mit allen eingehenden Daten schnell, sparsam im Speicher und stabil sein w√ºrde.  <a href="https://habr.com/ru/post/205290/">Seine kreativen Suchen waren erfolgreich</a> und er nannte den entwickelten Algorithmus sp√§ter eine Sortierung des Heiligen Grals (da er alle hohen Anforderungen an eine ‚Äûperfekte Sortierung‚Äú erf√ºllt).  Die meisten Ideen dieses Algorithmus √§hneln denen, die in WikiSort implementiert sind, obwohl diese Arten nicht identisch sind und unabh√§ngig voneinander entwickelt werden. <br><br><h3>  Hash-Tabellensortierung :: Hash-Tabellensortierung </h3><br><h4>  <i>Verteilung + Einf√ºgen + Zusammenf√ºhren</i> </h4><br>  Das Array wird rekursiv in zwei H√§lften geteilt, bis die Anzahl der Elemente in den resultierenden Subarrays einen bestimmten Schwellenwert erreicht.  Bei der niedrigsten Rekursionsebene erfolgt eine ungef√§hre Verteilung (unter Verwendung einer Hash-Tabelle), und das Subarray wird nach Einf√ºgungen sortiert.  Dann erfolgt eine rekursive R√ºckkehr zu h√∂heren Ebenen, die sortierten H√§lften werden durch Zusammenf√ºhren kombiniert. <br><br>  Ich <a href="https://habr.com/ru/post/478654/">habe vor</a> einem <a href="https://habr.com/ru/post/478654/">Monat ein</a> bisschen mehr √ºber diesen Algorithmus gesprochen. <br><br><hr><hr><hr><hr><hr><br><h2>  Schnelle Sortierung als prim√§re </h2><br>  Nach dem Zusammenf√ºhren und Einf√ºgen wird der dritte Platz in der Hybrid-Hit-Parade von allen bevorzugten schnellen Sorten festgehalten. <br><br>  Dies ist ein sehr effizienter Algorithmus, aber es gibt auch entartete F√§lle daf√ºr.  Einige Erfinder versuchen, QuickSort f√ºr fehlerhafte eingehende Daten v√∂llig unempfindlich zu machen, und schlagen vor, es durch √ºberzeugende Ideen anderer Sorten zu erg√§nzen. <br><br><h3>  Introspektive Sortierung :: Introsort, Introspektive Sortierung, std :: sort </h3><br><h4>  <i>Schnelle + Haufen + Einf√ºgungen</i> </h4><img align="right" width="395" height="470" src="https://habrastorage.org/webt/kq/om/vq/kqomvqs3ugrvl1xdnrw0vm54jnu.png"><br clear="left">  Die Heap-Sortierung ist etwas langsamer als die schnelle Sortierung, weist jedoch im Gegensatz zu QuickSort keine entarteten F√§lle auf - die durchschnittliche, beste und schlechteste algorithmische Zeitkomplexit√§t betr√§gt O ( <b>n</b> log <b>n</b> ). <br><br>  David Musser schlug daher vor, beim schnellen Sortieren auf Nummer sicher zu gehen - wenn zu viel verschachtelt ist, wird dies als Angriff auf das System angesehen, das ein "schlechtes" Array verloren hat.  Das Umschalten auf das Sortieren nach einem Heap erfolgt, was nicht Megabyte ist, sondern auch nicht langsam, um <nobr><i>mit</i></nobr> eingehenden Daten umzugehen. <br><br>  C ++ hat einen Algorithmus namens std :: sort, der eine Implementierung der introspektiven Sortierung ist.  Ein kleiner Zusatz - Wenn auf der n√§chsten Rekursionsstufe die <nobr>Anzahl der Elemente des Subarrays ‚â§ 16</nobr> ist, wird die Einf√ºgesortierung auf das Subarray angewendet. <br><br><h3>  Multikey sort :: Multikey sort <br>  Bitweises schnelles Sortieren :: Radix-schnelles Sortieren </h3><br><h4>  <i>Schnell + R√§nge</i> </h4><br>  Schnelle Sortierung, nur die Werte der Elemente des Arrays werden miteinander verglichen, aber ihre einzelnen Ziffern (zuerst ordnen wir die h√∂heren Ziffern auf diese Weise an, wir bewegen uns von den j√ºngeren zu ihnen). <br><br>  Oder so - dies ist eine bitweise Sortierung nach hoher Ordnung, die Sortierung innerhalb des n√§chsten Bits wird nach dem schnellen Sortieralgorithmus ausgef√ºhrt. <br><br><h3>  Scatter Sort :: Spreadsort </h3><br><h4>  <i>Schnelle + Zusammenf√ºhrung + Eimer + Entladungen</i> </h4><br>  Gestalt aus QuickSort, Merge Sort, Bucket Sort und Bitwise Sort. <br><br>  In aller K√ºrze nicht erkl√§ren.  Wir werden diesen Algorithmus in einem der folgenden Artikel detailliert analysieren. <br><br><hr><hr><hr><hr><hr><br><h2>  Andere Hybriden </h2><br><h3>  Baumz√§hlende Sorte </h3><br><h4>  <i>Z√§hlen + Baum</i> </h4><br>  Der <a href="https://habr.com/ru/post/418355/">vom</a> Benutzer <a href="https://habr.com/ru/users/alexanderusatov/" class="user_link">AlexanderUsatov</a> <a href="https://habr.com/ru/post/418355/">vorgeschlagene</a> Algorithmus.  Z√§hlsortierung, die Anzahl der gez√§hlten Schl√ºssel wird in einem ausgeglichenen Baum gespeichert. <br><br><h3>  J-Sortierung :: J-Sortierung </h3><br><h4>  <i>Haufen + Eins√§tze</i> </h4><br>  √úber diese Sortierung habe ich <a href="https://habr.com/ru/post/221095/">schon vor 5 Jahren geschrieben</a> .  Alles ist ganz einfach: Zuerst m√ºssen Sie im Array einmal einen nicht zunehmenden Heap erstellen und dann genau das Gegenteil tun - einmal einen nicht abnehmenden Heap erstellen.  Infolge der ersten Operation befindet sich das Minimum an erster Stelle des Arrays, und kleine Elemente als Ganzes r√ºcken erheblich an den Anfang.  Im zweiten Fall befindet sich das Maximum an letzter Stelle und gro√üe Elemente wandern gegen Ende des Arrays.  Im Allgemeinen erhalten wir ein fast sortiertes Array, mit dem wir was machen?  Das ist richtig - sortiere die Beilagen aus. <br><br><div style="text-align:center;"><img width="646" height="304" src="https://habrastorage.org/webt/uv/ed/ud/uvedudkaitwonk4bfuy2alkkvwk.gif"></div><br><br><hr><hr><hr><hr><hr><br><h2>  Referenzen </h2><br><img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png">  <a href="https://en.wikipedia.org/wiki/Merge-insertion_sort">Merge-Insertion</a> , <a href="https://en.wikipedia.org/wiki/Block_sort">Block-Merge</a> , <a href="https://en.wikipedia.org/wiki/Timsort">Tim</a> , <a href="https://en.wikipedia.org/wiki/Introsort">Introspective</a> , <a href="https://en.wikipedia.org/wiki/Spreadsort">Spread</a> , <a href="https://en.wikipedia.org/wiki/Multi-key_quicksort">Multikey</a> <br><br><img width="30" height="30" src="https://habrastorage.org/webt/fn/cd/py/fncdpynfktllvkdjtmpif0kd1zc.png">  <a href="https://github.com/Mrrl/GrailSort">Gral</a> <br><br><img width="30" height="30" src="https://habrastorage.org/webt/jw/w-/qu/jww-queszzqnwmoa2hm-kfwu-9o.png">  <a href="https://habr.com/ru/post/205290/">Gral</a> , <a href="https://habr.com/ru/post/203032/">Hash-Tabelle</a> , <a href="https://habr.com/ru/post/418355/">Graf / Baum</a> , <a href="https://habr.com/ru/post/221095/">J</a> <br><br><h3>  Serienartikel: </h3><br><ul><li>  <a href="https://habr.com/post/414447/">Excel-Anwendung AlgoLab.xlsm</a> </li><li>  <a href="https://habr.com/post/414653/">Sortierungen austauschen</a> </li><li>  <a href="https://habr.com/post/415935/">Einf√ºgesortierung</a> </li><li>  <a href="https://habr.com/post/422085/">Nach Auswahl sortieren</a> </li><li>  <a href="https://habr.com/ru/post/431964/">Sortierungen zusammenf√ºhren</a> </li><li>  <a href="https://habr.com/ru/post/472466/">Nach Verteilung sortieren</a> </li><li>  <strong>Hybrides Sortieren</strong> <br><ul><li>  Mergesort einf√ºgen </li><li>  Tim Sort </li><li>  Wiki Sort </li><li>  Streusortierung </li></ul><br></li></ul>  Von allen hier vorgestellten Sortierungen ist derzeit in der AlgoLab-Excel-Anwendung nur f√ºr Jsort-Animation implementiert. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de483786/">https://habr.com/ru/post/de483786/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de483774/index.html">Die Zusammenfassung der Ereignisse f√ºr Personalfachleute in der IT f√ºr Januar 2020</a></li>
<li><a href="../de483776/index.html">Einf√ºhrung in die semantische Differentialmethode in 5 Minuten</a></li>
<li><a href="../de483778/index.html">Sicherheitswoche 03: Verantwortungsvolle Fehlerberichte</a></li>
<li><a href="../de483780/index.html">Was ist Slack und wie funktioniert es?</a></li>
<li><a href="../de483784/index.html">So erstellen Sie eine mandantenf√§hige Anwendung aus einer nicht mandantenf√§higen Anwendung</a></li>
<li><a href="../de483788/index.html">Winzige Inselnation verdient dank Twitch</a></li>
<li><a href="../de483790/index.html">Hinweise des IoT-Anbieters. Technologie und Wirtschaft LoRaWAN in der Stadtbeleuchtung</a></li>
<li><a href="../de483794/index.html">Los geht's: warum solltest du nicht kontroffer nehmen</a></li>
<li><a href="../de483796/index.html">Optionale Parameter in Spring-Datenrepositorys</a></li>
<li><a href="../de483798/index.html">So automatisieren Sie das Erstellen von Anzeigen in Google Ads</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>