<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò≥ ü§∑üèΩ üëÆ Apa yang ada di bawah kap optimasi pengoptimalan GraalVM? üì∂ üîì üç¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami terus berurusan dengan karya GraalVM, dan kali ini kami memiliki terjemahan artikel oleh Aleksandar Prokopec "Di bawah tenda optimalisasi JIT Gra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apa yang ada di bawah kap optimasi pengoptimalan GraalVM?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/485024/"><p>  Kami terus berurusan dengan karya GraalVM, dan kali ini kami memiliki terjemahan artikel oleh Aleksandar Prokopec "Di bawah tenda optimalisasi JIT GraalVM", awalnya diterbitkan di <a href="https://medium.com/graalvm/under-the-hood-of-graalvm-jit-optimizations-d6e931394797">blog di Medium</a> .  Artikel ini memiliki beberapa tautan yang menarik, kemudian kami akan mencoba menerjemahkan artikel-artikel ini juga. </p><br><p><img src="https://habrastorage.org/webt/k-/0k/fz/k-0kfzbwnfrk_hswloa6dyyftjc.jpeg"></p><br><hr><br><p>  <a href="https://medium.com/graalvm/stream-api-performance-with-graalvm-be6cfe7fbb52">Terakhir kali di Medium,</a> kami melihat masalah kinerja Java Streams API di GraalVM dibandingkan dengan Java HotSpot VM.  <a href="https://www.graalvm.org/">GraalVM</a> dicirikan oleh kinerja tinggi, dan dalam percobaan tersebut kami mencapai akselerasi dari 1,7 menjadi 5 kali.  Tentu saja, nilai spesifik kenaikan kinerja akan selalu bergantung pada kode yang dijalankan dan memuat data, jadi sebelum Anda membuat kesimpulan, Anda harus mencoba menjalankan kode Anda sendiri di GraalVM. </p><br><p>  Pada artikel ini, kita akan masuk lebih dalam ke bagian dalam GraalVM dan melihat bagaimana kompilasi JIT terjadi. </p><br><a name="habracut"></a><br><h2>  <font color="#D93740">Optimalisasi JIT di GraalVM</font> </h2><br><p>  Mari kita lihat sejumlah optimasi tingkat tinggi yang digunakan kompilator GraalVM.  Dalam artikel ini kami hanya akan menyentuh pada optimasi yang paling menarik bersama dengan contoh spesifik dari pekerjaan mereka.  Jika Anda ingin menggali lebih dalam, tinjauan umum yang baik tentang optimisasi kompiler GraalVM ada dalam sebuah karya berjudul <a href="https://www.researchgate.net/publication/320359502_Making_collection_operations_optimal_with_aggressive_JIT_compilation">‚ÄúMembuat operasi pengumpulan optimal dengan kompilasi JIT agresif‚Äù</a> . </p><br><h2>  <font color="#D93740">Sebaris</font> </h2><br><p>  Jika Anda tidak menyentuh perakitan sebelumnya, maka sebagian besar kompiler JIT di mesin virtual modern melakukan analisis internal.  Ini berarti bahwa pada setiap momen tertentu ada analisis dari satu metode.  Untuk alasan ini, analisis intraprosedural jauh lebih cepat daripada analisis antarproedural seluruh program, yang biasanya tidak punya waktu untuk menyelesaikan waktu yang diberikan untuk pekerjaan kompiler JIT.  Dalam kompiler yang menggunakan optimasi intra-prosedural (misalnya, mengoptimalkan satu metode pada satu waktu), salah satu optimasi mendasar yang paling penting adalah inlining.  Inlining penting karena secara efektif meningkatkan metode, yang berarti bahwa kompiler dapat melihat lebih banyak peluang untuk mengoptimalkan secara bersamaan beberapa potong kode yang digunakan dalam metode yang tampaknya tidak terkait. </p><br><p> Ambil, misalnya, metode <code>volleyballStars</code> dari artikel sebelumnya: </p><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volleyballStars</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Arrays.stream(people) .map(p -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(p.hair, p.age + <span class="hljs-number"><span class="hljs-number">1</span></span>, p.height)) .filter(p -&gt; p.height &gt; <span class="hljs-number"><span class="hljs-number">198</span></span>) .filter(p -&gt; p.age &gt;= <span class="hljs-number"><span class="hljs-number">18</span></span> &amp;&amp; p.age &lt;= <span class="hljs-number"><span class="hljs-number">21</span></span>) .mapToInt(p -&gt; p.age) .average().getAsDouble(); }</code> </pre> <br><p>  Dalam diagram ini, kita melihat bagian representasi perantara (IR) dari metode ini di GraalVM, saat ini segera setelah penguraian bytecode Java yang sesuai. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1cb/b4f/fd1/1cbb4ffd15a4c171de823accd8830071.png"></p><br><p>  Anda dapat menganggap IR ini sebagai semacam <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">sintaksis abstrak</a> tentang steroid - berkat itu, beberapa optimasi lebih mudah dilakukan.  Tidak masalah bagaimana IR ini bekerja, tetapi jika Anda ingin memahami topik ini lebih dalam, Anda dapat melihat pada dokumen yang disebut <a href="http://citeseerx.ist.psu.edu/viewdoc/download%3Fdoi%3D10.1.1.726.5496%26amp%3Brep%3Drep1%26amp%3Btype%3Dpdf">"Graal IR: Representasi Antara Deklaratif yang Dapat Diperpanjang"</a> . </p><br><p>  Kesimpulan utama di sini adalah bahwa aliran kontrol metode yang ditunjukkan oleh simpul kuning grafik dan garis merah secara berurutan mengeksekusi metode antarmuka <code>Stream</code> : <code>Stream.filter</code> , <code>Stream.mapToInt</code> , <code>IntStream.average</code> .  Kurangnya pengetahuan yang akurat tentang apa yang ada dalam kode metode ini, kompiler tidak dapat menyederhanakan metode - dan di sini inlining datang untuk menyelamatkan! </p><br><p>  Transformasi yang disebut inlining adalah hal yang sangat dimengerti: ia hanya mencari tempat untuk memanggil metode dan menggantikannya dengan badan metode inline yang sesuai, menanamkannya di dalam.  Mari kita lihat IR metode <code>volleyballStars</code> setelah inlining bagian dari metode.  Hanya bagian yang mengikuti panggilan <code>IntStream.average</code> : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d5a/717/c71/d5a717c711a64a653ae7784f5557a2e5.png"></p><br><p>  Diagram menunjukkan bahwa panggilan untuk <code>getAsDouble</code> (nomor simpul 71) telah menghilang dari IR.  Perhatikan bahwa metode <code>getAsDouble</code> objek <code>getAsDouble</code> dikembalikan dari <code>IntStream.average</code> (panggilan terakhir dalam metode <code>volleyballStars</code> ) didefinisikan dalam JDK sebagai berikut: </p><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAsDouble</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isPresent) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NoSuchElementException(<span class="hljs-string"><span class="hljs-string">"No value present"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; }</code> </pre> <br><p>  Di sini kita dapat menemukan pemuatan <code>isPresent</code> bidang (nomor simpul 190, <code>LoadField</code> ) dan membaca bidang <code>value</code> .  Namun, tidak ada jejak yang tersisa dari pengecualian <code>NoSuchElementException</code> , dan tidak ada lagi kode yang melemparnya. </p><br><p>  Ini karena kompiler GraalVM menebak: metode <code>volleyballStars</code> tidak akan pernah memberikan pengecualian.  Pengetahuan ini biasanya tidak tersedia selama kompilasi <code>getAsDouble</code> - dapat dipanggil dari berbagai tempat dalam program, dan dalam beberapa kasus lain pengecualian masih akan berfungsi.  Namun, dalam metode <code>volleyballStars</code> tertentu, pengecualian tidak mungkin terjadi karena kumpulan bintang bola voli potensial tidak pernah kosong.  Untuk alasan ini, GraalVM menghapus cabang dan menyisipkan <code>FixedGuard</code> - sebuah simpul yang tidak mengoptimalkan kode jika terjadi pelanggaran asumsi kami.  Ini adalah contoh yang cukup minimalis, dan dalam kehidupan nyata ada banyak kasus yang lebih rumit tentang bagaimana inlining membantu optimasi lainnya. </p><br><p>  Kita tahu bahwa pohon program panggilan biasanya sangat dalam atau bahkan tidak ada habisnya.  Jadi, sebaris pada beberapa titik perlu dihentikan - ia memiliki batasan yang sangat spesifik pada waktu operasi dan ukuran memori.  Mengetahui hal ini, menjadi jelas: untuk menentukan apa dan kapan harus berbaris sangat sulit. </p><br><h2>  <font color="#D93740">Inlining polimorfik</font> </h2><br><p>  Inlining hanya berfungsi jika kompilator dapat menentukan metode spesifik yang ditujukan untuk operasi pemanggilan metode.  Tetapi di Jawa, biasanya ada banyak panggilan tidak langsung untuk metode yang implementasinya tidak diketahui dalam statika, yang dicari dalam runtime menggunakan pengiriman virtual. </p><br><p>  Misalnya, ambil metode <code>IntStream.average</code> .  Implementasinya yang khas terlihat seperti ini: </p><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> OptionalDouble </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">average</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>[] avg = collect( () -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>], (ll, i) -&gt; { ll[<span class="hljs-number"><span class="hljs-number">0</span></span>]++; ll[<span class="hljs-number"><span class="hljs-number">1</span></span>] += i; }, (ll, rr) -&gt; { ll[<span class="hljs-number"><span class="hljs-number">0</span></span>] += rr[<span class="hljs-number"><span class="hljs-number">0</span></span>]; ll[<span class="hljs-number"><span class="hljs-number">1</span></span>] += rr[<span class="hljs-number"><span class="hljs-number">1</span></span>]; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> avg[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? OptionalDouble.of((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) avg[<span class="hljs-number"><span class="hljs-number">1</span></span>] / avg[<span class="hljs-number"><span class="hljs-number">0</span></span>]) : OptionalDouble.empty(); }</code> </pre> <br><p>  Jangan biarkan kesederhanaan nyata dari kode menipu Anda!  Metode ini didefinisikan dalam hal <code>collect</code> panggilan, dan keajaiban terjadi di sini.  Pohon panggilan dari metode ini (misalnya, hierarki panggilan) tumbuh dengan cepat ketika kita masuk lebih dalam ke <code>collect</code> .  Lihatlah diagram ini: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/584/306/ce3/584306ce380584ae1266e1026040389f.png"></p><br><p>  Mulai dari beberapa titik dalam proses melintasi pohon panggilan, inliner bersandar pada panggilan <code>opWrapSink</code> dari kerangka <code>opWrapSink</code> Java, yang merupakan metode abstrak: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/be4/43b/b46/be443bb464f938c962b8649ef26de75d.png"></p><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function">&lt;P_IN&gt; Sink&lt;P_IN&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrapSink</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sink&lt;P_OUT&gt; sink)</span></span></span></span>;</code> </pre> <br><p>  Biasanya inliner tidak akan melangkah lebih jauh, karena itu adalah panggilan tidak langsung.  Penentuan metode tertentu hanya akan terjadi selama pelaksanaan program, dan sekarang inlayner tidak tahu apa yang harus dikerjakan selanjutnya. </p><br><p>  Dalam kasus GraalVM, sesuatu yang lain terjadi: ia menyimpan profil dari jenis metode target untuk setiap titik panggilan tidak langsung.  Profil ini pada dasarnya hanya sebuah tabel yang memberitahukan seberapa sering setiap implementasi <code>wrapSink</code> .  Dalam kasus kami, profil tahu tentang tiga implementasi berbeda di kelas anonim: <code>ReferencePipeline$2</code> , <code>ReferencePipeline$3</code> , <code>ReferencePipeline$4</code> .  Implementasi ini disebut dengan probabilitas masing-masing 50%, 25%, dan 25%. </p><br><br><pre> <code class="plaintext hljs">0.500000: Ljava/util/stream/ReferencePipeline$2; 0.250000: Ljava/util/stream/ReferencePipeline$4; 0.250000: Ljava/util/stream/ReferencePipeline$3; notRecorded: 0.000000</code> </pre><br><p>  Informasi ini memberikan bantuan yang sangat berharga kepada kompiler, memungkinkan Anda untuk menghasilkan <em>typeswitch</em> - <code>switch</code> pendek yang memeriksa jenis metode dalam runtime, kemudian memanggil metode tertentu untuk setiap kasus yang terdaftar.  Gambar di bawah ini menunjukkan bagian dari tampilan perantara yang menunjukkan typeswitch (tiga <code>if</code> node) dengan tanda centang untuk melihat apakah tipe penerima adalah seseorang dari <code>ReferencePipeline$2</code> , <code>ReferencePipeline$3</code> atau <code>ReferencePipeline$4</code> .  Setiap panggilan langsung dalam percabangan yang sukses dari setiap pemeriksaan <code>InstanceOf</code> sekarang dapat sebaris atau menghubungkan beberapa optimasi tambahan untuk itu.  Jika tidak ada tipe yang lulus tes, kode akan dioptimalkan dalam simpul <code>Deopt</code> (sebagai alternatif, Anda dapat menjalankan pengiriman virtual). </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/26e/688/ca8/26e688ca89ea6c397b72f9acaba08ff3.png"></p><br><p>  Jika Anda ingin memahami inlining polimorfik lebih dalam, saya merekomendasikan karya klasik tentang topik ini, <a href="https://dl.acm.org/citation.cfm%3Fid%3D679839">"Inlining Metode Virtual"</a> . </p><br><h2>  <font color="#D93740">Analisis Pelarian Sebagian</font> </h2><br><p>  Mari kita kembali ke contoh bola voli kita.  Perhatikan bahwa tidak satu pun objek <code>Person</code> dialokasikan di dalam lambda yang dilewatkan ke fungsi <code>map</code> lolos dari cakupan metode <code>volleyballStars</code> .  Dengan kata lain, saat metode <code>volleyballStars</code> berakhir, tidak ada area memori yang akan menunjuk ke objek bertipe <code>Person</code> .  Khususnya, catatan nilai <code>getHeight</code> selanjutnya hanya digunakan untuk pemfilteran tinggi. </p><br><p>  Di beberapa titik selama kompilasi metode <code>volleyballStars</code> , kita sampai pada IR yang ditunjukkan pada diagram di bawah ini.  Blok dimulai dengan <code>Begin</code> simpul -1621 dimulai dengan alokasi objek <code>Person</code> (dalam simpul <code>Alloc</code> ), yang diinisialisasi dengan nilai bidang <code>age</code> dengan kenaikan 1 dan nilai sebelumnya dari bidang <code>height</code> .  Bidang <code>height</code> sebelumnya dibaca di simpul <code>LoadField</code> -1539.  Hasil alokasi dienkapsulasi di <code>AllocatedObject</code> -2137 dan dikirim ke pemanggilan metode <code>accept</code> -1625.  Compiler tidak dapat melakukan apa-apa lagi saat ini - dari sudut pandangnya, objek tersebut melarikan diri dari metode <code>volleyballStars</code> .  ( <em>Catatan Penerjemah: "melarikan diri suatu objek" disebut "melarikan diri" dalam bahasa Inggris, maka nama pengoptimalannya adalah "analisis pelarian"</em> ). </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a02/cca/495/a02cca495ad607770a0111040e0a724a.png"></p><br><p>  Setelah itu, kompiler memutuskan untuk inline panggilan <code>accept</code> - ini masuk akal.  Akibatnya, kami tiba di IR berikut: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/334/5b9/029/3345b90295b77a64ded506f3042a146a.png"></p><br><p>  Dan di sini JIT compiler memulai analisis pelarian parsial: ia mengetahui bahwa <code>AllocatedObject</code> hanya digunakan untuk membaca bidang <code>height</code> (ingat, <code>height</code> hanya digunakan dalam kondisi penyaringan, periksa bahwa tingginya lebih dari 198).  Oleh karena itu, kompiler dapat menetapkan ulang pembacaan bidang -2167 <code>height</code> sehingga dapat langsung bekerja dengan node yang sebelumnya ditulis ke objek <code>Person</code> ( <code>Alloc</code> -2136 node), dan ini adalah <code>LoadField</code> -1539 kami.  Selain itu, node <code>Alloc</code> selanjutnya tidak pergi ke input dari node lain, jadi Anda bisa menghapusnya - ini adalah kode mati! </p><br><p>  Optimalisasi ini, pada kenyataannya, alasan utama mengapa contoh <code>volleyballStars</code> mengalami akselerasi lima kali lipat setelah beralih ke GraalVM.  Meskipun semua objek <code>Person</code> tidak diperlukan dan dibuang segera setelah pembuatan, mereka masih perlu dialokasikan di heap, ingatan mereka masih perlu diinisialisasi.  Analisis pelarian sebagian memungkinkan Anda untuk menghilangkan alokasi atau menundanya dengan memindahkannya ke cabang kode di mana objek benar-benar lari dan yang terjadi jauh lebih jarang. </p><br><p>  Anda bisa mendapatkan pemahaman yang lebih dalam tentang analisis pelarian parsial dalam sebuah makalah yang disebut <a href="http://www.ssw.uni-linz.ac.at/Research/Papers/Stadler14/Stadler2014-CGO-PEA.pdf">Analisis Pelepasan Sebagian dan Penggantian Skalar untuk Jawa</a> . </p><br><h2>  <font color="#D93740">Ringkasan</font> </h2><br><p>  Dalam artikel ini, kami melihat tiga optimasi GraalVM: inlining, inline polimorfik, dan analisis pelarian parsial.  Ada banyak lagi optimisasi yang berbeda: promosi dan pemisahan siklus, duplikasi jalur, penomoran nilai-nilai global, konvolusi konstanta, penghapusan kode mati, eksekusi spekulatif dan sebagainya. </p><br><p>  Jika Anda ingin mempelajari lebih lanjut tentang cara kerja GraalVM, jangan ragu untuk membuka <a href="http://www.graalvm.org/community/publications/">halaman publikasi</a> .  Jika Anda ingin memastikan sendiri apakah GraalVM dapat mempercepat kode Anda, Anda dapat <a href="https://www.graalvm.org/downloads/">mengunduh binari</a> dan mencobanya sendiri. </p><br><hr><br><h2>  <font color="#D93740">Dari penerjemah: bahan tambahan</font> </h2><br>  Di konferensi, JPoint dan Joker sering berbicara tentang GraalVM.  Misalnya, pada JPoint 2019 terakhir, Thomas Wuerthinger (Direktur Riset di Oracle Labs, yang bertanggung jawab untuk GraalVM) dan Oleg Shelaev, salah satu dari dua penginjil teknologi resmi, mengunjungi kami. <br><br>  Anda dapat menonton ini dan video lainnya di saluran YouTube kami: <br><br><ul><li>  Thomas Wuerthinger: <a href="https://www.youtube.com/watch%3Fv%3DR_SeDk16PLY">"Memaksimalkan kinerja dengan GraalVM"</a> </li><li>  Oleg Shelaev: <a href="https://www.youtube.com/watch%3Fv%3DC5fATKdVxZ0">‚ÄúSuperkompilasi, evaluasi parsial, proyeksi Futamura dan bagaimana GraalVM akan menyelamatkan dunia‚Äù</a> </li><li>  Roberto Cortez: <a href="https://www.youtube.com/watch%3Fv%3DoY8sfg7A1kg">"GraalVM dan MicroProfile: Solusi layanan polyglot"</a> </li><li>  Ionut Balosin: <a href="https://www.youtube.com/watch%3Fv%3DRYLEIRHWsVo">‚ÄúBalapan dua penyusun: GraalVM JIT versus HotSpot JIT C2.</a>  <a href="https://www.youtube.com/watch%3Fv%3DRYLEIRHWsVo">Yang mana yang menawarkan kinerja runtime yang lebih baik? "</a> </li></ul><br><blockquote>  Kami mengingatkan Anda bahwa JPoint berikutnya akan diadakan 15-16 Mei 2020 di Moskow, dan tiket sudah dapat dibeli <a href="https://jpoint.ru/registration/%3Futm_source%3Dhabr%26utm_medium%3D485024%26utm_campaign%3Djpoint20">di situs web resmi</a> . </blockquote><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id485024/">https://habr.com/ru/post/id485024/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id485012/index.html">Cara menggunakan Kontrol Inversi di JavaScript dan Reactjs untuk menyederhanakan penanganan kode</a></li>
<li><a href="../id485014/index.html">Haruskah saya mengeluh tentang wawancara?</a></li>
<li><a href="../id485016/index.html">Database yang Dikelola di Selectel: Selamat Datang di Beta</a></li>
<li><a href="../id485018/index.html">Menulis shader dengan kode di Unity LWRP</a></li>
<li><a href="../id485022/index.html">Playme Sigma: DVR Fungsional dan Terjangkau</a></li>
<li><a href="../id485026/index.html">Peluang Georgia untuk para profesional TI</a></li>
<li><a href="../id485028/index.html">CRM 2020</a></li>
<li><a href="../id485030/index.html">8 biaya IEO teratas dan kapitalisasi mereka sekarang</a></li>
<li><a href="../id485032/index.html">Cara membuat aplikasi Bereaksi lebih cepat dengan negara hosting bersama</a></li>
<li><a href="../id485034/index.html">Mengotomatiskan pembuatan proyek Qt pada Windows di Travis CI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>