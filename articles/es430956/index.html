<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßùüèæ ‚è© üë©üèº‚Äçüè≠ Ense√±amos a un cerdo con monoides a creer en s√≠ mismos y volar üíû üîï üåç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En uno de los art√≠culos anteriores, habl√© sobre c√≥mo puede construir un ejecutor de programas para una m√°quina de pila virtual utilizando enfoques de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ense√±amos a un cerdo con monoides a creer en s√≠ mismos y volar</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430956/"><p> En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">uno</a> de los art√≠culos anteriores, habl√© sobre c√≥mo puede construir un ejecutor de programas para una m√°quina de pila virtual utilizando enfoques de programaci√≥n funcionales y orientados al lenguaje.  La estructura matem√°tica del lenguaje sugiri√≥ la estructura b√°sica para la implementaci√≥n de su traductor, basada en el concepto de semigrupos y monoides.  Este enfoque me permiti√≥ construir una implementaci√≥n hermosa y ampliable y romper los aplausos, pero la primera pregunta de la audiencia me hizo bajar de la tribuna y volver a subir a Emacs. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n2/ln/ne/n2lnneohm_d4rsc-qkw_n4cguyw.png" width="80%"></div><br><p>  Realic√© una prueba simple y me asegur√© de que en tareas simples que usan solo la pila, la m√°quina virtual funciona de manera inteligente, y cuando se usa la "memoria", una matriz con acceso aleatorio, comienzan grandes problemas.  Acerca de c√≥mo logramos resolverlos sin cambiar los principios b√°sicos de la arquitectura del programa y lograr una aceleraci√≥n mil veces mayor del programa, y ‚Äã‚Äãser√° discutido en este art√≠culo. </p><a name="habracut"></a><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mo>&amp;#x2217;</mo><mtext>&amp;#xA0;</mtext><mo>&amp;#x2217;</mo><mtext>&amp;#xA0;</mtext><mo>&amp;#x2217;</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.681ex" height="1.335ex" viewBox="0 -520.7 2445.9 574.6" role="img" focusable="false" style="vertical-align: -0.125ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMAIN-2217" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMAIN-2217" x="972" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMAIN-2217" x="1945" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>‚àó</mo><mtext>&nbsp;</mtext><mo>‚àó</mo><mtext>&nbsp;</mtext><mo>‚àó</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> * \ * \ * </script></p><br><p>  Haskell es un lenguaje peculiar con un nicho especial.  El objetivo principal de su creaci√≥n y desarrollo era la necesidad de que la lengua franca expresara y probara ideas de programaci√≥n funcional.  Esto justifica sus caracter√≠sticas m√°s llamativas: pereza, pureza extrema, √©nfasis en los tipos y manipulaciones con ellos.  No fue dise√±ado para el desarrollo diario, ni para la programaci√≥n industrial, ni para el uso generalizado.  El hecho de que realmente se use para crear proyectos a gran escala en la industria de redes y en el procesamiento de datos es la buena voluntad de los desarrolladores, prueba de concepto, si lo desea.  Pero hasta ahora, el producto m√°s importante, ampliamente utilizado y sorprendentemente poderoso escrito en Haskell es ... el compilador ghc.  Y esto est√° completamente justificado desde el punto de vista de su prop√≥sito: ser una herramienta para la investigaci√≥n en el campo de la inform√°tica.  El principio proclamado por Simon Payton-Johnson: "Evitar el √©xito a toda costa" es necesario para que el lenguaje siga siendo ese instrumento.  Haskell es como una c√°mara est√©ril en el laboratorio de un centro de investigaci√≥n que desarrolla tecnolog√≠as de semiconductores o nanomateriales.  Es terriblemente inconveniente trabajar en √©l, y para la pr√°ctica diaria tambi√©n restringe la libertad de acci√≥n, pero sin estos inconvenientes, sin una adhesi√≥n inflexible a las restricciones, no ser√° posible observar y estudiar los sutiles efectos que luego se convertir√°n en la base de los desarrollos industriales.  Al mismo tiempo, en la industria, la esterilidad ser√° necesaria solo en el volumen m√°s necesario, y los resultados de estos experimentos aparecer√°n en nuestros bolsillos en forma de dispositivos.  Estudiamos estrellas y galaxias no porque esperemos recibir beneficios directos de ellas, sino porque, en la escala de estos objetos poco pr√°cticos, los efectos cu√°nticos y relativistas se vuelven observables y estudiados, tanto que luego podemos usar este conocimiento para desarrollar algo muy utilitario.  Por lo tanto, Haskell con sus l√≠neas "incorrectas", la pereza poco pr√°ctica de los c√°lculos, la rigidez de algunos algoritmos de inferencia de tipos, con una curva de entrada extremadamente empinada, finalmente no le permite crear f√°cilmente una aplicaci√≥n inteligente en la rodilla o un sistema operativo.  Sin embargo, lentes, m√≥nadas, an√°lisis combinatorio, el uso generalizado de monoides, m√©todos de prueba autom√°tica de teoremas, gestores de paquetes funcionales declarativos, tipos lineales y dependientes se est√°n acercando al mundo pr√°ctico.  Esto encuentra aplicaci√≥n en condiciones menos est√©riles en los lenguajes Python, Scala, Kotlin, F #, Rust y muchos otros.  Pero no usar√≠a ninguno de estos maravillosos lenguajes para ense√±ar los principios de la programaci√≥n funcional: llevar√≠a al estudiante al laboratorio, le mostrar√≠a c√≥mo funciona en ejemplos claros y claros, y luego podr√° ver estos principios en acci√≥n en la f√°brica Una m√°quina grande e incomprensible, pero muy r√°pida.  Evitar el √©xito a toda costa es proteger contra los intentos de colocar una cafetera en un microscopio electr√≥nico para popularizarla.  Y en las competencias cuyo idioma es mejor, Haskell siempre estar√° fuera de las nominaciones habituales. </p><br><p>  Sin embargo, la persona es d√©bil y un demonio tambi√©n vive en m√≠, lo que me hace querer comparar, evaluar y defender "mi idioma favorito" frente a los dem√°s.  Entonces, despu√©s de haber escrito una implementaci√≥n elegante de una m√°quina apilada, basada en una composici√≥n monoidal, con el √∫nico prop√≥sito de ver si esta idea funciona para m√≠, inmediatamente me molest√≥ que me di cuenta de que la implementaci√≥n funcion√≥ de manera brillante, ¬°pero terriblemente ineficiente!  Es como si realmente lo voy a usar para tareas serias, o para vender mi m√°quina apilada en el mismo mercado donde se ofrecen m√°quinas virtuales Python o Java.  Pero maldita sea, el art√≠culo sobre el lech√≥n con el que comenz√≥ toda esta conversaci√≥n ofrece n√∫meros tan sabrosos: cientos de milisegundos para el lech√≥n, segundos para Python ... ¬°y mi hermoso monoide no puede hacer la misma tarea en una hora!  Tengo que tener √©xito!  ¬°Mi microscopio preparar√° espresso no peor que una m√°quina de caf√© en el pasillo del instituto!  ¬°Crystal Palace se puede dispersar y lanzar al espacio! </p><br><p>  ¬øPero a qu√© est√°s dispuesto a renunciar, me pregunta el √°ngel matem√°tico?  ¬øLa pureza y transparencia de la arquitectura del palacio?  ¬øLa flexibilidad y extensibilidad que proporcionan los homomorfismos de los programas a otras soluciones?  El demonio y el √°ngel son tercos, y el sabio tao√≠sta, a quien tambi√©n me permito vivir, propuso tomar el camino que mejor se adapte a ambos y seguirlo el mayor tiempo posible.  Sin embargo, no con el objetivo de identificar al ganador, sino con el fin de conocer el camino en s√≠ mismo, descubrir hasta d√≥nde llega y obtener una nueva experiencia.  Y entonces supe la vana tristeza y la alegr√≠a de la optimizaci√≥n. </p><br><p> Antes de comenzar, agregamos que las comparaciones de <em>idiomas</em> en t√©rminos de efectividad no tienen sentido.  Necesita comparar traductores (int√©rpretes o compiladores), o el desempe√±o de un programador que usa el lenguaje.  Al final, la afirmaci√≥n de que los programas C son los m√°s r√°pidos es f√°cil de refutar escribiendo un int√©rprete C completo en BASIC, por ejemplo.  Entonces, no estamos comparando Haskell y JavaScript, sino el rendimiento de los programas ejecutados por un traductor compilado por <code>ghc</code> y los programas ejecutados, por ejemplo, en un navegador en particular.  Toda la terminolog√≠a porcina proviene de un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo</a> inspirador sobre m√°quinas apiladas.  Todo el c√≥digo Haskell que acompa√±a al art√≠culo puede estudiarse en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">repositorio</a> . </p><br><h3 id="vyhodim-iz-zony-komforta">  Salimos de la zona de confort. </h3><br><p>  La posici√≥n inicial ser√° la implementaci√≥n de una m√°quina de pila monoidal en forma de <abbr title="Lenguaje Orientado a Dominio Embebido">EDSL</abbr> , un peque√±o lenguaje simple que permite combinar dos docenas de primitivas para representar programas para una m√°quina de pila virtual.  Tan pronto como entr√≥ en el segundo art√≠culo, le damos el nombre de <code>monopig</code> .  Se basa en el hecho de que los lenguajes para m√°quinas apiladas forman un <em>monoide</em> con una operaci√≥n de concatenaci√≥n y una operaci√≥n vac√≠a como una unidad.  En consecuencia, √©l mismo fue construido en forma de una transformaci√≥n monoide del estado de la m√°quina.  El estado incluye una pila, memoria en forma de un vector (una estructura que proporciona acceso aleatorio a los elementos), un indicador de parada de emergencia y una bater√≠a monoidal para acumular informaci√≥n de depuraci√≥n.  Toda esta estructura se transmite a lo largo de una cadena de endomorfismos de una operaci√≥n a otra, llevando a cabo un proceso computacional.  Se construy√≥ una estructura isom√≥rfica <em>de c√≥digos de</em> programa a partir de la estructura que forman los programas y, a partir de ella, los homomorfismos en otras estructuras √∫tiles que representan los requisitos del programa en t√©rminos de n√∫mero de argumentos y memoria.  La etapa final de la construcci√≥n fue la creaci√≥n de monoides de transformaci√≥n en la categor√≠a Claysley, que le permiten sumergir los c√°lculos en una m√≥nada arbitraria.  Entonces la m√°quina obtuvo las capacidades de entrada-salida y c√°lculos ambiguos.  Comenzaremos con esta implementaci√≥n.  Su c√≥digo se puede encontrar <a href="">aqu√≠</a> . </p><br><p>  Pondremos a prueba la efectividad del programa en la implementaci√≥n ingenua del tamiz de Erat√≥stenes, que llena la memoria (matriz) con ceros y unos, denotando primos por cero.  Le damos el c√≥digo de procedimiento del algoritmo en <code>javascript</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> memSize = <span class="hljs-number"><span class="hljs-number">65536</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; memSize; i++) arr.push(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sieve</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n*n &lt; memSize) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!arr[n]) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k = n; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (k &lt; memSize) { k+=n; arr[k] = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } n++; } }</code> </pre> <br><p>  El algoritmo est√° inmediatamente ligeramente optimizado.  Elimina el mal caminar a trav√©s de las celdas de memoria ya llenas.  Mi √°ngel matem√°tico no estuvo de acuerdo con una versi√≥n <em>realmente</em> ingenua de un ejemplo en el proyecto <code>PorosenokVM</code> , ya que esta optimizaci√≥n cuesta solo cinco instrucciones del lenguaje de pila.  As√≠ es como el algoritmo se traduce a <code>monopig</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">sieve</span></span> = push <span class="hljs-number"><span class="hljs-number">2</span></span> &lt;&gt; while (dup &lt;&gt; dup &lt;&gt; mul &lt;&gt; push memSize &lt;&gt; lt) (dup &lt;&gt; get &lt;&gt; branch mempty fill &lt;&gt; inc) &lt;&gt; pop fill = dup &lt;&gt; dup &lt;&gt; add &lt;&gt; while (dup &lt;&gt; push memSize &lt;&gt; lt) (dup &lt;&gt; push <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&gt; swap &lt;&gt; put &lt;&gt; exch &lt;&gt; add) &lt;&gt; pop</code> </pre> <br><p>  Y as√≠ es como puede escribir una implementaci√≥n equivalente de este algoritmo en el idiom√°tico Haskell, utilizando los mismos tipos que en <code>monopig</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">sieve'</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> sieve' km | k*k &lt; memSize = sieve' (k+<span class="hljs-number"><span class="hljs-number">1</span></span>) $ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m ! k == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> fill' k (<span class="hljs-number"><span class="hljs-number">2</span></span>*k) m <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> m | otherwise = m fill' :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> fill' knm | n &lt; memSize = fill' k (n+k) $ m // [(n,<span class="hljs-number"><span class="hljs-number">1</span></span>)] | otherwise = m</code> </pre> <br><p>  Utiliza el tipo <code>Data.Vector</code> y las herramientas para trabajar con √©l, que no son demasiado comunes para el trabajo diario en Haskell.  Expresi√≥n <code>m ! k</code>  <code>m ! k</code> devuelve el <code>k</code> elemento del vector <code>m</code> , y <code>m // [(n,1)]</code> : establece el elemento con el n√∫mero <code>n</code> en 1. Estoy escribiendo esto aqu√≠ porque tuve que acudir a ellos en busca de ayuda, a pesar de que trabajo en Haskell Casi todos los d√≠as.  El hecho es que las estructuras con acceso aleatorio en una implementaci√≥n funcional son ineficientes y, por esta raz√≥n, no son amadas. </p><br><p>  De acuerdo con las condiciones de competencia especificadas en el art√≠culo sobre el lech√≥n, el algoritmo se ejecuta 100 veces.  Y para deshacerse de una computadora espec√≠fica, comparemos las velocidades de ejecuci√≥n de estos tres programas, refiri√©ndolos al rendimiento del programa <code>javascript</code> que se ejecut√≥ en Chrome. </p><br><p><img src="https://habrastorage.org/webt/ir/hi/mj/irhimjjtdgec7vw1vduvivmzonm.png"></p><br><p>  Horror horror !!!  ¬° <code>monopig</code> no <code>monopig</code> ralentiza imp√≠amente, sino que la versi√≥n nativa no es mucho mejor!  ¬øHaskell, por supuesto, es genial, pero no tanto como inferior a un programa que se ejecuta en un navegador?  Como los entrenadores nos ense√±an, no puedes vivir as√≠, ¬°es hora de abandonar la zona de confort que nos brinda Haskell! </p><br><h3 id="preodolevaem-len">  Superar la pereza </h3><br><p>  Vamos a hacerlo bien.  Para hacer esto, compile un programa en <code>monopig</code> con el indicador <code>-rtsopts</code> para realizar un <code>-rtsopts</code> estad√≠sticas de tiempo de ejecuci√≥n y vea lo que necesitamos para ejecutar el tamiz de Erat√≥stenes una vez: </p><br><pre> <code class="plaintext hljs">$ ghc -O -rtsopts ./Monopig4.hs [1 of 1] Compiling Main ( Monopig4.hs, Monopig4.o ) Linking Monopig4 ... $ ./Monopig4 -RTS -sstderr "Ok" 68,243,040,608 bytes allocated in the heap 6,471,530,040 bytes copied during GC 2,950,952 bytes maximum residency (30667 sample(s)) 42,264 bytes maximum slop 15 MB total memory in use (7 MB lost due to fragmentation) Tot time (elapsed) Avg pause Max pause Gen 0 99408 colls, 0 par 2.758s 2.718s 0.0000s 0.0015s Gen 1 30667 colls, 0 par 57.654s 57.777s 0.0019s 0.0133s INIT time 0.000s ( 0.000s elapsed) MUT time 29.008s ( 29.111s elapsed) GC time 60.411s ( 60.495s elapsed) &lt;--   ! EXIT time 0.000s ( 0.000s elapsed) Total time 89.423s ( 89.607s elapsed) %GC time 67.6% (67.5% elapsed) Alloc rate 2,352,591,525 bytes per MUT second Productivity 32.4% of total user, 32.4% of total elapsed</code> </pre> <br><p>  La √∫ltima l√≠nea nos dice que el programa se dedicaba a la computaci√≥n productiva solo un tercio del tiempo.  El resto del tiempo, el recolector de basura se escap√≥ de la memoria y limpi√≥ para hacer c√°lculos flojos.  ¬°Cu√°ntas veces nos han dicho en la infancia que la pereza no es buena!  Aqu√≠, la caracter√≠stica principal de Haskell nos perjudic√≥ al intentar crear varios billones de transformaciones de pila y vectores diferidos. </p><br><p>  Un √°ngel matem√°tico en este lugar levanta un dedo y felizmente habla del hecho de que desde la √©poca de Alonzo Church, hay un teorema que establece que la estrategia de c√°lculo no afecta su resultado, lo que significa que somos libres de elegirlo por razones de eficiencia.  Cambiar los c√°lculos a estricto no es nada dif√≠cil: ¬°ponga una se√±al <code>!</code>  en la declaraci√≥n del tipo de pila y memoria y, por lo tanto, hace que estos campos sean estrictos. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Stack</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">status</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">memory</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Memory</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">journal</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  No cambiaremos nada m√°s y verificaremos inmediatamente el resultado: </p><br><pre> <code class="plaintext hljs">$ ./Monopig41 +RTS -sstderr "Ok" 68,244,819,008 bytes allocated in the heap 7,386,896 bytes copied during GC 528,088 bytes maximum residency (2 sample(s)) 25,248 bytes maximum slop 16 MB total memory in use (14 MB lost due to fragmentation) Tot time (elapsed) Avg pause Max pause Gen 0 129923 colls, 0 par 0.666s 0.654s 0.0000s 0.0001s Gen 1 2 colls, 0 par 0.001s 0.001s 0.0006s 0.0007s INIT time 0.000s ( 0.000s elapsed) MUT time 13.029s ( 13.048s elapsed) GC time 0.667s ( 0.655s elapsed) EXIT time 0.001s ( 0.001s elapsed) Total time 13.700s ( 13.704s elapsed) %GC time 4.9% (4.8% elapsed) Alloc rate 5,238,049,412 bytes per MUT second Productivity 95.1% of total user, 95.1% of total elapsed</code> </pre> <br><p>  La productividad ha crecido significativamente.  Los costos totales de memoria a√∫n se mantuvieron impresionantes debido a la inmutabilidad de los datos, pero lo m√°s importante, ahora que hemos limitado la pereza de los datos, el recolector de basura tiene la oportunidad de ser perezoso, solo queda el 5% del trabajo.  Ingrese una nueva entrada en la calificaci√≥n. </p><br><p><img src="https://habrastorage.org/webt/6z/z4/6j/6zz46jgmso3w95efydonusy8pok.png"></p><br><p>  Bueno, los c√°lculos rigurosos nos han acercado a la velocidad del c√≥digo nativo de Haskell, que vergonzosamente se ralentiza sin ninguna m√°quina virtual.  Esto significa que la sobrecarga de usar un vector inmutable excede <em>significativamente</em> el costo de mantener una m√°quina apilada.  Y esto significa que es hora de decir adi√≥s a la inmutabilidad de la memoria. </p><br><h3 id="vpuskaem-izmeneniya-v-zhizn">  Dejar cambios en la vida </h3><br><p>  El tipo <code>Data.Vector</code> bueno, pero al usarlo, pasamos mucho tiempo copiando, en nombre de preservar la pureza del proceso inform√°tico.  Reemplaz√°ndolo con el tipo <code>Data.Vector.Unpacked</code> al menos ahorramos en el empaque de la estructura, pero esto no cambia fundamentalmente la imagen.  La soluci√≥n correcta ser√≠a eliminar la memoria del estado de la m√°quina y proporcionar acceso al vector externo utilizando la categor√≠a Kleisley.  Al mismo tiempo, junto con los vectores puros, puede usar los denominados vectores mutables (mutables) <code>Data.Vector.Mutable</code> . </p><br><p>  Conectaremos los m√≥dulos apropiados y pensaremos c√≥mo manejar datos mutables en un programa funcional limpio. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad.Primitive <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Vector.Unboxed <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> V <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Vector.Unboxed.Mutable <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> M</code> </pre> <br><p>  Se supone que estos tipos sucios est√°n aislados del p√∫blico puro.  Est√°n contenidos en las m√≥nadas de la clase <code>PrimMonad</code> (estos incluyen <code>ST</code> o <code>IO</code> ), donde los programas limpios insertan cuidadosamente las instrucciones para las acciones escritas en un lenguaje funcional cristal en un pergamino precioso.  Por lo tanto, el comportamiento de estos animales inmundos est√° determinado por escenarios estrictamente ortodoxos y no es peligroso.  No todos los programas para nuestra m√°quina usan memoria, por lo que no es necesario condenar a toda la arquitectura a la inmersi√≥n en la m√≥nada <code>IO</code> .  Junto con un subconjunto limpio del lenguaje <code>monopig</code> crearemos cuatro instrucciones que brinden acceso a la memoria, y solo ellos tendr√°n acceso al territorio peligroso. </p><br><p>  El tipo de m√°quina limpia se acorta: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Stack</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">status</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">journal</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  Los dise√±adores de programas y los propios programas apenas notar√°n este cambio, pero sus tipos cambiar√°n.  Adem√°s, tiene sentido definir varios tipos de sin√≥nimos para simplificar las firmas. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Memory</span></span></span><span class="hljs-class"> m = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">M</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MVector</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PrimState</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Logger</span></span></span><span class="hljs-class"> ma = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Memory</span></span></span><span class="hljs-class"> m -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Code</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> a -&gt; m (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program'</span></span></span><span class="hljs-class"> ma = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Logger</span></span></span><span class="hljs-class"> ma -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Memory</span></span></span><span class="hljs-class"> m -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program</span></span></span><span class="hljs-class"> ma</span></span></code> </pre> <br><p>  Los constructores tendr√°n otro argumento que representa el acceso a la memoria.  Los ejecutores cambiar√°n significativamente, especialmente aquellos que mantienen un registro de c√°lculo, porque ahora necesitan preguntar por el estado del vector variable.  El <a href="">c√≥digo</a> completo se puede ver y estudiar en el repositorio, pero aqu√≠ dar√© lo m√°s interesante: la implementaci√≥n de los componentes b√°sicos para trabajar con memoria para mostrar c√≥mo se hace esto. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">geti</span></span> :: <span class="hljs-type"><span class="hljs-type">PrimMonad</span></span> m =&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Program'</span></span> ma geti i = programM (<span class="hljs-type"><span class="hljs-type">GETI</span></span> i) $ \mem -&gt; \s -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= i &amp;&amp; i &lt; memSize) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x &lt;- <span class="hljs-type"><span class="hljs-type">M</span></span>.unsafeRead mem i setStack (x:s) vm <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> err <span class="hljs-string"><span class="hljs-string">"index out of range"</span></span> puti :: <span class="hljs-type"><span class="hljs-type">PrimMonad</span></span> m =&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Program'</span></span> ma puti i = programM (<span class="hljs-type"><span class="hljs-type">PUTI</span></span> i) $ \mem -&gt; \<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (x:s) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= i &amp;&amp; i &lt; memSize) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>.unsafeWrite mem ix setStack s vm <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> err <span class="hljs-string"><span class="hljs-string">"index out of range"</span></span> _ -&gt; err <span class="hljs-string"><span class="hljs-string">"expected an element"</span></span> get :: <span class="hljs-type"><span class="hljs-type">PrimMonad</span></span> m =&gt; <span class="hljs-type"><span class="hljs-type">Program'</span></span> ma get = programM (<span class="hljs-type"><span class="hljs-type">GET</span></span>) $ \m -&gt; \<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (i:s) -&gt; \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x &lt;- <span class="hljs-type"><span class="hljs-type">M</span></span>.read mi setStack (x:s) vm _ -&gt; err <span class="hljs-string"><span class="hljs-string">"expected an element"</span></span> put :: <span class="hljs-type"><span class="hljs-type">PrimMonad</span></span> m =&gt; <span class="hljs-type"><span class="hljs-type">Program'</span></span> ma put = programM (<span class="hljs-type"><span class="hljs-type">PUT</span></span>) $ \m -&gt; \<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (i:x:s) -&gt; \vm -&gt; <span class="hljs-type"><span class="hljs-type">M</span></span>.write mix &gt;&gt; setStack s vm _ -&gt; err <span class="hljs-string"><span class="hljs-string">"expected two elemets"</span></span></code> </pre> <br><p>  El demonio optimizador se ofreci√≥ inmediatamente a ahorrar un poco m√°s en verificar los valores de √≠ndice permitidos en la memoria, porque para los <code>geti</code> <code>puti</code> y <code>geti</code> √≠ndices son conocidos en la etapa de creaci√≥n del programa y los valores incorrectos pueden eliminarse de antemano.  Los √≠ndices definidos din√°micamente para los comandos <code>put</code> y <code>get</code> no garantizan la seguridad, y el √°ngel matem√°tico no permiti√≥ que se les hicieran llamadas peligrosas. </p><br><p>  Todo este alboroto con poner la memoria en un argumento separado parece complicado.  Pero muestra muy claramente que los datos deben ser cambiados por su lugar: <em>deber√≠an estar afuera</em> .  Les recuerdo que estamos tratando de llevar a un repartidor de pizza a un laboratorio est√©ril.  Las funciones puras saben qu√© hacer con ellas, pero estos objetos nunca se convertir√°n en ciudadanos de primera clase, y no vale la pena preparar pizza en el laboratorio. </p><br><p>  Verifiquemos lo que compramos con estos cambios: </p><br><pre> <code class="plaintext hljs">$ ./Monopig5 +RTS -sstderr "Ok" 9,169,192,928 bytes allocated in the heap 2,006,680 bytes copied during GC 529,608 bytes maximum residency (2 sample(s)) 25,248 bytes maximum slop 2 MB total memory in use (0 MB lost due to fragmentation) Tot time (elapsed) Avg pause Max pause Gen 0 17693 colls, 0 par 0.094s 0.093s 0.0000s 0.0001s Gen 1 2 colls, 0 par 0.000s 0.000s 0.0002s 0.0003s INIT time 0.000s ( 0.000s elapsed) MUT time 7.228s ( 7.232s elapsed) GC time 0.094s ( 0.093s elapsed) EXIT time 0.000s ( 0.000s elapsed) Total time 7.325s ( 7.326s elapsed) %GC time 1.3% (1.3% elapsed) Alloc rate 1,268,570,828 bytes per MUT second Productivity 98.7% of total user, 98.7% of total elapsed</code> </pre> <br><p>  Esto ya es progreso!  El uso de la memoria se redujo ocho veces, la velocidad de ejecuci√≥n del programa aument√≥ 180 veces y el recolector de basura permaneci√≥ casi sin trabajo. </p><br><p><img src="https://habrastorage.org/webt/o7/cw/f8/o7cwf8ptddtz8x1gdy0lunionis.png"></p><br><p>  La soluci√≥n apareci√≥ <em>monopig st.</em>  <em>mut.</em>  , que es diez veces m√°s lento que la soluci√≥n nativa en <code>js</code> , pero aparte de eso, la soluci√≥n nativa en Haskell, que usa vectores mutables.  Aqu√≠ est√° su c√≥digo: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fill'</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Memory</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> (<span class="hljs-type"><span class="hljs-type">Memory</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span>) fill' knm | n &gt; memSize-k = return m | otherwise = <span class="hljs-type"><span class="hljs-type">M</span></span>.unsafeWrite mn <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt; fill' k (n+k) m sieve' :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Memory</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> (<span class="hljs-type"><span class="hljs-type">Memory</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span>) sieve' km | k*k &lt; memSize = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x &lt;- <span class="hljs-type"><span class="hljs-type">M</span></span>.unsafeRead mk <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> fill' k (<span class="hljs-number"><span class="hljs-number">2</span></span>*k) m &gt;&gt;= sieve' (k+<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sieve' (k+<span class="hljs-number"><span class="hljs-number">1</span></span>) m | otherwise = return m</code> </pre> <br><p>  Comienza de la siguiente manera </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> m &lt;- <span class="hljs-type"><span class="hljs-type">M</span></span>.replicate memSize <span class="hljs-number"><span class="hljs-number">0</span></span> stimes <span class="hljs-number"><span class="hljs-number">100</span></span> (sieve' <span class="hljs-number"><span class="hljs-number">2</span></span> m &gt;&gt; return ()) print <span class="hljs-string"><span class="hljs-string">"Ok"</span></span></code> </pre> <br><p>  Y ahora Haskell finalmente muestra que no es un lenguaje de juguete.  Solo necesitas usarlo sabiamente.  Por cierto, el c√≥digo anterior utiliza el hecho de que el tipo <code>IO ()</code> forma un semigrupo con la operaci√≥n de ejecuci√≥n secuencial de programas <code>(&gt;&gt;)</code> , y con la ayuda de <code>stimes</code> 100 veces el c√°lculo del problema de la prueba. </p><br><p>  Ahora est√° claro por qu√© hay tanta aversi√≥n por los arreglos funcionales y por qu√© nadie recuerda c√≥mo trabajar con ellos: tan pronto como un programador de Haskell realmente necesita estructuras de acceso aleatorio, se reenfoca en datos mutables y trabaja en m√≥nadas ST o IO. </p><br><p>  Sacar una parte de los comandos a una zona especial pone en duda la legalidad del isomorfismo. <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="20.072ex" height="2.419ex" viewBox="0 -780.1 8642 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMATHI-6C" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMATHI-6F" x="548" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMATHI-6E" x="1034" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMATHI-67" x="1634" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMATHI-6C" x="2115" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMATHI-65" x="2413" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMATHI-66" x="2880" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMATHI-74" x="3430" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMATHI-72" x="3792" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMATHI-69" x="4243" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMATHI-67" x="4589" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMATHI-68" x="5069" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMATHI-74" x="5646" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMATHI-61" x="6007" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMATHI-72" x="6537" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMATHI-72" x="6988" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMATHI-6F" x="7440" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMATHI-77" x="7925" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math></span></span><script type="math/tex" id="MathJax-Element-2"> \ longleftrightarrow </script>  <em>El programa</em> .  Despu√©s de todo, no podemos convertir simult√°neamente el c√≥digo en programas puros y mon√°dicos, esto no permite que el sistema de tipos lo haga.  Sin embargo, las clases de tipos son lo suficientemente flexibles como para que exista este isomorfismo.  <em>C√≥digo de</em> homomorfismo <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="16.177ex" height="2.419ex" viewBox="0 -780.1 6965 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMATHI-6C" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMATHI-6F" x="548" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMATHI-6E" x="1034" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMATHI-67" x="1634" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMATHI-72" x="2115" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMATHI-69" x="2566" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMATHI-67" x="2912" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMATHI-68" x="3392" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMATHI-74" x="3969" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMATHI-61" x="4330" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMATHI-72" x="4860" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMATHI-72" x="5311" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMATHI-6F" x="5763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMATHI-77" x="6248" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math></span></span><script type="math/tex" id="MathJax-Element-3"> \ longrightarrow </script>  <em>El programa</em> ahora se divide en varios homomorfismos para diferentes subconjuntos del lenguaje.  C√≥mo exactamente se hace esto se puede ver en el [c√≥digo] () completo del programa. </p><br><h3 id="ne-ostanavlivaysya-na-dostignutom">  No te detengas ah√≠ </h3><br><p>  Eliminar las llamadas innecesarias a funciones e incrustar su c√≥digo directamente usando el pragma <code>{-# INLINE #-}</code> ayudar√° a cambiar ligeramente la productividad del programa.  Este m√©todo no es adecuado para funciones recursivas, pero es ideal para componentes b√°sicos y funciones de establecimiento.  Reduce el tiempo de ejecuci√≥n del programa de prueba en otro 25% (ver <a href="">Monopig51.hs</a> ). </p><br><p><img src="https://habrastorage.org/webt/0k/-l/hu/0k-lhu49_zsiihqoom7c5g0ize8.png"></p><br><p>  El siguiente paso razonable ser√° deshacerse de las herramientas de registro cuando no sean necesarias.  En la etapa de formaci√≥n del endomorfismo que representa el programa, utilizamos un argumento externo, que determinamos al inicio.  El <code>program</code> constructores inteligentes y el <code>programM</code> pueden ser advertidos de que no puede haber ning√∫n argumento-logger.  En este caso, el c√≥digo del convertidor no contiene nada superfluo: solo la funcionalidad y la comprobaci√≥n del estado de la m√°quina. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">program</span></span> code f = programM code (const f) programM code f (<span class="hljs-type"><span class="hljs-type">Just</span></span> logger) mem = <span class="hljs-type"><span class="hljs-type">Program</span></span> . ([code],) . <span class="hljs-type"><span class="hljs-type">ActionM</span></span> $ \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> status vm <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; logger mem code =&lt;&lt; f mem (stack vm) vm _ -&gt; return vm programM code f _ mem = <span class="hljs-type"><span class="hljs-type">Program</span></span> . ([code],) . <span class="hljs-type"><span class="hljs-type">ActionM</span></span> $ \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> status vm <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; f mem (stack vm) vm _ -&gt; return vm</code> </pre> <br><p>  Ahora, las funciones de ejecuci√≥n deben indicar expl√≠citamente la presencia o ausencia de registro que no utiliza el c√≥digo auxiliar <code>none</code> , sino que usa el tipo <code>Maybe (Logger ma)</code> .  ¬øPor qu√© deber√≠a funcionar esto, porque si hay un registro o no, los componentes del programa lo descubrir√°n "en el √∫ltimo momento", antes de la ejecuci√≥n?  ¬øNo se coser√≠a el c√≥digo innecesario en la etapa de composici√≥n de la composici√≥n del programa?  Haskell es un lenguaje vago y aqu√≠ juega en nuestras manos.  Es antes de la ejecuci√≥n que el c√≥digo final se optimiza para una tarea espec√≠fica.  Esta optimizaci√≥n redujo el tiempo de ejecuci√≥n del programa en otro 40% (ver <a href="">Monopig52.hs</a> ). </p><br><p><img src="https://habrastorage.org/webt/co/gd/vy/cogdvyw-zsyliuiwsmhxs5gadhe.png"></p><br><p>  Con esto, completaremos el trabajo para acelerar el lech√≥n monoidal.  √âl ya est√° corriendo lo suficientemente r√°pido para que tanto el √°ngel como el demonio puedan calmarse.  Esto, por supuesto, no es C, todav√≠a usamos una lista limpia como una pila, pero reemplazarla con una matriz conducir√° a una excavaci√≥n exhaustiva del c√≥digo y al rechazo de usar plantillas elegantes en las definiciones de comandos b√°sicos.  Quer√≠a sobrevivir con cambios m√≠nimos, y principalmente a nivel de tipos. </p><br><p>  Algunos problemas persisten con el registro.  Un recuento simple del n√∫mero de pasos o el uso de la pila funciona bien (hicimos que el campo de registro sea estricto), pero emparejarlos ya comienza a comer memoria, tienes que meterte en patadas usando <code>seq</code> , lo cual ya es bastante molesto.  Pero dime, ¬øqui√©n registrar√° los 14 mil millones de pasos, si puedes depurar la tarea en los primeros cientos?  Entonces no pasar√© mi tiempo acelerando para acelerar. </p><br><p>  Solo queda agregar que en el art√≠culo sobre el lech√≥n, como uno de los m√©todos para optimizar los c√°lculos, se proporciona el seguimiento: la asignaci√≥n de secciones lineales de c√≥digo, los <em>rastros</em> dentro de los cuales se pueden realizar los c√°lculos sin pasar por el ciclo de env√≠o del comando principal (bloque de <code>switch</code> ).  En nuestro caso, la composici√≥n monoidal de los componentes del programa crea tales huellas, ya sea durante la formaci√≥n del programa a partir de los componentes EDSL, o durante la operaci√≥n del homomorfismo <code>fromCode</code> .  Este m√©todo de optimizaci√≥n nos llega gratis, por as√≠ decirlo, por construcci√≥n. </p><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mo>&amp;#x2217;</mo><mtext>&amp;#xA0;</mtext><mo>&amp;#x2217;</mo><mtext>&amp;#xA0;</mtext><mo>&amp;#x2217;</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.681ex" height="1.335ex" viewBox="0 -520.7 2445.9 574.6" role="img" focusable="false" style="vertical-align: -0.125ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMAIN-2217" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMAIN-2217" x="972" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhiQL67uwrNTkDadoLajxz6p9IuLFw#MJMAIN-2217" x="1945" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>‚àó</mo><mtext>&nbsp;</mtext><mo>‚àó</mo><mtext>&nbsp;</mtext><mo>‚àó</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-4"> * \ * \ * </script></p><br><p>  Hay muchas soluciones <code>Conduits</code> y r√°pidas en el ecosistema de Haskell, como las transmisiones de <code>Conduits</code> o <code>Pipes</code> , hay excelentes reemplazos de <code>String</code> y creadores √°giles de XML como blaze-html, y el analizador <code>attoparsec</code> es un est√°ndar para el an√°lisis combinatorio de las gram√°ticas LL (‚àû).  Todo esto es necesario para el funcionamiento normal.  Pero a√∫n m√°s se necesita investigaci√≥n que conduzca a estas decisiones.  Haskell ha sido y sigue siendo una herramienta de investigaci√≥n que cumple con los requisitos espec√≠ficos que el p√∫blico en general no necesita.  Vi en Kamchatka c√≥mo los ases en un helic√≥ptero Mi-4 cerraron cajas de f√≥sforos en una discusi√≥n, empujando el tren de aterrizaje con una rueda mientras colgaba en el aire.  Esto se puede hacer, y es genial, pero no es necesario. </p><br><p>  ¬°Pero, sin embargo, esto es genial! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es430956/">https://habr.com/ru/post/es430956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es430944/index.html">La NASA ha decidido a los participantes para su competencia de mini-rover de luna</a></li>
<li><a href="../es430948/index.html">El Ministerio de Comunicaciones propone reforzar el control sobre los datos personales.</a></li>
<li><a href="../es430950/index.html">Making Modern Build</a></li>
<li><a href="../es430952/index.html">Los autos el√©ctricos y los h√≠bridos deber√°n emitir sonidos adicionales: ¬øpor qu√© es necesario?</a></li>
<li><a href="../es430954/index.html">Qt Everywhere: WebAssembly y WebGL Streaming</a></li>
<li><a href="../es430958/index.html">Lanzamos el contenedor con pruebas unitarias en Azure DevOps (VSTS)</a></li>
<li><a href="../es430960/index.html">Sobre gamedev de una exposici√≥n de escritorio</a></li>
<li><a href="../es430962/index.html">Razor Support en Visual Studio Code</a></li>
<li><a href="../es430964/index.html">Pensamiento declarativo</a></li>
<li><a href="../es430966/index.html">Sprints generales en Atlassian Jira Software</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>