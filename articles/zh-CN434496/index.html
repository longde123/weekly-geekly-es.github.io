<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎗️ ✖️ 🏂🏼 两阶段提交和分布式系统的未来 ⤵️ 🔸 🤹🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在本文中，我们使用TLA +模拟和检查了两阶段提交协议。 

 两阶段提交协议是实用的，如今已在许多分布式系统中使用。 但是，它很短。 因此，我们可以快速对其建模并学到很多东西。 实际上，通过此示例，我们将说明在分布式系统中哪个结果根本上是不可能的 。 

 双阶段提交问题 
 交易通过资源管理器（...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>两阶段提交和分布式系统的未来</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434496/"> 在本文中，我们使用TLA +模拟和检查了两阶段提交协议。 <br><br> 两阶段提交协议是实用的，如今已在许多分布式系统中使用。 但是，它很短。 因此，我们可以快速对其建模并学到很多东西。 实际上，通过此示例，我们将说明在分布式系统中哪个结果<i>根本</i>上是<i>不可能的</i> 。 <br><br><h3> 双阶段提交问题 </h3><br> 交易通过<b>资源管理器（RM）</b> 。 所有RM必须就交易是<i>完成</i>还是<i>中止</i>达成一致。 <br><br> 事务管理器（TM）做出最终决定： <b>commit</b>或<b>cancel</b> 。 提交的条件是愿意提交所有RM。 否则，该交易应被取消。 <br><a name="habracut"></a><br><h3> 建模注意事项 </h3><br> 为简单起见，我们在共享内存模型中而不是在消息传递系统中执行仿真。 它还提供了快速的模型验证。 但是我们将非原子性添加到“从邻居节点读取并更新状态”的动作中，以捕获发送消息时的有趣行为。 <br><br>  RM只能读取TM状态并读取/更新其自己的状态。 它无法读取其他资源管理器的状态。  TM可以读取所有RM节点的状态并读取/更新其自己的状态。 <br><br><h3> 定义 </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/d93/803/abe/d93803abea49766a0fbd7bb1d168c2c1.png"><br><br> 第9-10 <code>rmState</code>每个RM的初始<code>rmState</code>设置为<code>working</code> ，将TM设置为<code>init</code> 。 <br><br> 如果所有RM已“准备好”（准备提交），则<code>canCommit</code>谓词为<code>true</code> 。 如果RM以结束状态存在，则<code>canAbort</code>谓词变为<code>canAbort</code> 。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f2a/8a9/11c/f2a8a911c47b672d4f95b1eb59d11e60.png"><br><br> 建模TM很简单。 事务管理器检查提交或取消的可能性-并相应地更新<code>tmState</code> 。 <br><br>  TM仅在将模型验证开始之前将<code>TMMAYFAIL</code>常量设置为<code>true</code> ，TM可能无法使<code>tmState</code> “不可访问”。 在TLA +标签中，确定原子度，即其粒度。 通过标签F1和F2，我们表示相对于先前的运算符，非原子地（在一段不确定的时间之后）执行了相应的运算符。 <br><br><h3>  RM模型 </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/425/42e/e7a/42542ee7a105be00451a28460cafc502.png"><br><br>  RM模型也很简单。 由于“工作”状态和“准备状态”是非最终状态，因此RM不确定地在操作之间进行选择，直到达到最终状态为止。  “工作” RM可以进入“中断”或“准备”状态。  “ Prepared” RM期望从TM提交/取消-并采取相应的措施。 下图显示了一个RM的可能状态转换。 但是请注意，我们有几个RM，每个RM都以自己的步调经过其状态，而不知道其他RM的状态。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8d9/b25/0bd/8d9b250bd8aeeba4807f08e1d52a2675.png"><br><br><h3> 两阶段提交模型 </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/62d/4e6/b1c/62d4e6b1c2046535daddbeeba285c7ac.png"><br><br> 我们需要检查两阶段提交的一致性：这样就不会有不同的RM，其中一个RM表示“ commit”，另一个表示“ abortion”。 <br><br>  <code>Completed</code>谓词可验证协议不会永远挂起：最后，每个RM都达到<code>committed</code>或<code>aborted</code>的最终状态。 <br><br> 现在我们准备测试协议模型。 最初，我们设置<code>TMMAYFAIL=FALSE, RM=1..3</code> ，以三个RM和一个TM来启动该协议，也就是说，以可靠的配置。 测试模型需要15秒，并表示没有错误。 对于RM动作和TM动作的任何交替，任何可能的协议执行都会满足“ <code>Consistency</code>和“ <code>Completed</code>要求。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c25/c9e/ed0/c25c9eed093f51eb577cbbb97a4775b2.png"><br><br> 现在设置<code>TMMAYFAIL=TRUE</code>并重新开始检查。 该程序很快产生相反的结果，RM停滞不前，等待来自不可用TM的响应。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/652/e12/7ec/652e127ec391fae452f651c27f2855db.png"><br><br> 我们看到，在<code>State=4</code>转换RM2被中断，在<code>State=7</code>转换RM3被中断，在<code>State=8</code> TM进入“挂起”状态并下降到<code>State=9</code> 。 在<code>State=10</code>系统冻结，因为RM1永远保持在准备状态，等待下降的TM做出决定。 <br><br><h3>  BTM模拟 </h3><br> 为避免事务冻结，我们添加了一个备份TM（BTM），如果主TM不可用，该备份可快速控制。  BTM使用与TM相同的逻辑进行决策。 为了简单起见，我们假设BTM不会崩溃。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/43b/96f/842/43b96f8421fe04f10b8adbc573507c36.png"><br><br> 当我们使用添加的BTM流程测试模型时，会收到一条新的错误消息。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/369/151/826/369151826a6dbe641acb2ae81340b1ea.png"><br><br>  BTM无法接受提交，因为我们的原始条件<code>canCommit</code>声明必须“准备”所有<code>RMstates</code> ，并且没有考虑到某些RM在TMB采取控制之前已经从原始TM接收到提交决定的条件。 考虑到这种情况，有必要重写<code>canCommit</code>的条件。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9ed/4cf/bd5/9ed4cfbd55de80c58a7068b246c2375b.png"><br><br> 成功！ 当我们测试模型时，我们实现了一致性和完整性，因为BTM可以控制并在TM下降时完成交易。  <a href="">这是TLA +中的2PCwithBTM模型</a> （BTM和canCommit的第二行最初没有注释）和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">相应的pdf</a> 。 <br><br><h3> 如果RM也失败怎么办？ </h3><br> 我们认为RM是可靠的。 现在取消此条件，并查看RM失败时协议的行为。 将“无法访问”状态添加到故障模型。 为了调查行为并模拟间歇性的可用性损失，请让紧急RM恢复并通过从日志中读取其状态来继续工作。 这是另一个RM状态转换图，其中添加了“不可访问”状态，并且转换标记为红色。 下面是RM的修订模型。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff1/f05/b6c/ff1f05b6cd817bb0d4050de4e30f37b6.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/94d/91f/8da/94d91f8da2aa4674044a71330da06d4e.png"><br><br> 还必须考虑到不可用状态来优化<code>canAbort</code> 。 如果任何服务处于中断或无法访问状态，TM可以做出“挂断”决定。 如果忽略此条件，则下降且未恢复的RM将中断事务的处理。 当然，同样，您应该考虑RM，RM是从源TM那里学习完成交易的决定的。 <br><br><h3> 模型检查 </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/bf7/973/f0f/bf7973f0fd5815dfec816ff93dc03f3c.png"><br><br> 当我们测试模型时，会出现不一致的问题！ 怎么会这样 我们追踪痕迹。 <br><br> 在<code>State=6</code>所有RM都处于准备状态，TM做出完成交易的决定，RM1看到此决定并切换到RC标签，这意味着准备将其状态更改为“完成”。  （记住RM1，这把枪会在最后一幕开火）。 不幸的是，TM在<code>State=7</code>下降，而RM2在<code>State=8</code>时不可用。 在第九步中，备用BTM进行控制并读取三个RM的状态为“已准备，不可访问，已准备”-并在第十步中决定取消交易。 还记得RM1吗？ 他决定完成交易，因为他收到了原始TM的此类决定，并在步骤11进入了<code>committed</code>状态。 在<code>State=13</code> RM3完成了从BTM中止交易的决定，并进入<code>aborted</code>状态-现在我们已经失去了与RM1的一致性。 <br><br> 在这种情况下，BTM做出了违反<b>一致性</b>的决定。 另一方面，如果让BTM等待RM离开不可访问状态，则在节点发生事故时BTM可能永远冻结，这将违反<b>实现</b> （进度）条件。 <br><br>  <a href="">可在此处获得更新的TLA +模型文件</a>以及<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">相应的pdf</a> 。 <br><br><h3> 不可能FLP </h3><br> 那怎么了 我们偶然地发现了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">费希尔，林奇，帕特森（FLP）</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">定理，</a>即在具有故障的异步系统中不可能达成共识。 <br><br> 在我们的示例中，BTM无法正确确定RM2是否处于失败状态-并且错误地决定中止事务。 如果仅由原始TM做出决定，那么在识别故障方面的这种不准确性将不是问题。  RM将遵守TM的任何决定，以便保持一致性和进度。 <br><br> 问题是我们有两个决策对象：TM和BTM，它们在不同时间查看RM的状态并做出不同的决策。 信息的这种不对称是分布式系统中所有邪恶的根源。 <br><br> 即使扩展到三相提交，问题也不会消失。  <a href="">这是一个以TLA +</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pdf版本</a> ） <a href="">建模的三阶段提交</a> ，下面是一个错误跟踪，显示这次违反了进度（在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wikipedia页面上有关三阶段提交的</a>描述，描述了一种情况，当RM1在提交之前收到决定后冻结，而RM2和RM3提交提交，这会违反一致性）。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0d3/6d8/06d/0d36d806d38003f3cd995bbefbc0802d.png"><br><br><h3>  Paxos试图使世界变得更美好。 </h3><br><img src="https://habrastorage.org/webt/q-/o_/wq/q-o_wq_jdl14y0ulz-nud8k4idw.jpeg"><br><br> 但是，并非一切都丢失了，希望没有死。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我们有Paxos</a> 。 它在FLP定理的框架内巧妙地起作用。  Paxos的创新之处在于，它<b>始终</b>是<b>安全的</b> （即使检测器不准确，异步执行和失败），并且在可能达成共识时<b>最终完成交易</b> 。 <br><br> 您可以在具有三个Paxos节点的群集上模拟TM，这将解决TM / BTM不一致问题。 或者，正如Gray和Lampport在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有关事务提交共识</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">科学文章中所</a>显示的那样，如果RM使用Paxos容器在TM响应的同时存储其决策，那么这将消除标准协议算法中的一个额外步骤。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN434496/">https://habr.com/ru/post/zh-CN434496/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN434480/index.html">新年，小玩意，火</a></li>
<li><a href="../zh-CN434482/index.html">我们博客的另一年：2018年的结果</a></li>
<li><a href="../zh-CN434486/index.html">会员卡。 用于ASP.NET中通行证的Google Pay API</a></li>
<li><a href="../zh-CN434490/index.html">我们如何通过水刀切割看到免提电话</a></li>
<li><a href="../zh-CN434494/index.html">阅读什么。 2017年和2018年俄语小说清单</a></li>
<li><a href="../zh-CN434498/index.html">MVP和Dagger 2-Android应用程序框架-第1部分</a></li>
<li><a href="../zh-CN434500/index.html">骗子叫珍妮或看你的耳朵</a></li>
<li><a href="../zh-CN434502/index.html">“数字考古学家”如何发现NES的失落版本SimCity并将其还原</a></li>
<li><a href="../zh-CN434504/index.html">快速报告20年“该产品是一口气创造出来的，只是高出……”</a></li>
<li><a href="../zh-CN434506/index.html">体验在Microsoft Store中发布视频编辑应用程序的经验</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>