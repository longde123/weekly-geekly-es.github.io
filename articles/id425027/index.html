<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🌾 🥙 🐑 Pengembangan shader GLSL di Kotlin 🏴󠁧󠁢󠁷󠁬󠁳󠁿 👩🏿‍🤝‍👨🏽 🚱</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! 

 Perusahaan kami sedang mengembangkan game online dan sekarang kami sedang mengerjakan versi mobile dari proyek utama kami. Pada arti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengembangan shader GLSL di Kotlin</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425027/"><img src="https://habrastorage.org/webt/qr/2o/e4/qr2oe43eauzbkvwv8r2tn2ze1do.jpeg"><br><br>  Halo semuanya! <br><br>  Perusahaan kami sedang mengembangkan game online dan sekarang kami sedang mengerjakan versi mobile dari proyek utama kami.  Pada artikel ini kami ingin berbagi pengalaman mengembangkan shader GLSL untuk proyek Android dengan contoh dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sumber</a> . <br><a name="habracut"></a><br><h3>  Tentang proyek </h3><br>  Awalnya, game ini berbasis browser pada Flash, tetapi berita tentang penghentian dukungan untuk Flash memaksa kami untuk mentransfer proyek ke HTML5.  Kotlin digunakan sebagai bahasa pengembangan, dan enam bulan kemudian kami dapat meluncurkan proyek di Android.  Sayangnya, tanpa optimasi pada perangkat seluler, gim ini tidak memiliki kinerja. <br><br>  Untuk meningkatkan FPS, diputuskan untuk mendesain ulang mesin grafis.  Kami dulu menggunakan beberapa shader universal, tetapi sekarang untuk setiap efek kami memutuskan untuk menulis shader terpisah, diasah untuk tugas tertentu, agar dapat membuat pekerjaan mereka lebih efisien. <br><br><h3>  Apa yang kurang dari kita </h3><br>  Shader dapat disimpan dalam sebuah string, tetapi metode ini menghilangkan pemeriksaan sintaksis dan pencocokan tipe, sehingga shader biasanya disimpan dalam Aset atau file Raw, karena ini memungkinkan Anda untuk mengaktifkan validasi dengan menginstal plug-in untuk Android Studio.  Tetapi pendekatan ini juga memiliki kelemahan - kurangnya penggunaan kembali: untuk melakukan pengeditan kecil, Anda harus membuat file shader baru. <br><br>  Jadi itu: <br><br>  - Mengembangkan shader di Kotlin, <br>  - lakukan pemeriksaan sintaks pada tahap kompilasi, <br>  - dapat menggunakan kembali kode antara shader, <br>  Saya perlu menulis "konverter" Kotlin ke GLSL. <br><br>  Hasil yang diinginkan: kode shader digambarkan sebagai kelas Kotlin, di mana atribut, variasi, seragam adalah properti dari kelas ini.  Parameter konstruktor utama kelas digunakan untuk cabang statis dan memungkinkan Anda untuk menggunakan kembali sisa kode shader.  Blok init adalah badan shader. <br><br><h3>  Solusi </h3><br>  Untuk implementasi, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">delegasi</a> Kotlin digunakan.  Mereka mengizinkan runtime untuk mengetahui nama properti yang didelegasikan, untuk menangkap get dan set saat panggilan dan untuk memberitahu mereka tentang ShaderBuilder - kelas dasar dari semua shader. <br><br><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShaderBuilder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> uniforms = HashSet&lt;String&gt;() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> attributes = HashSet&lt;String&gt;() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> varyings = HashSet&lt;String&gt;() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> instructions = ArrayList&lt;Instruction&gt;() ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: String = ... }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Mendelegasikan Implementasi</b> <div class="spoiler_text">  Variasi delegasi: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VaryingDelegate</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T : Variable</span></span></span><span class="hljs-class">&gt;</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> factory: (ShaderBuilder) -&gt; T) { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v: T <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideDelegate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ref: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ShaderBuilder</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">KProperty</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;*&gt;)</span></span></span></span>: VaryingDelegate&lt;T&gt; { v = factory(ref) v.value = p.name <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(thisRef: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ShaderBuilder</span></span></span></span><span class="hljs-function"><span class="hljs-params">, property: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">KProperty</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;*&gt;)</span></span></span></span>: T { thisRef.varyings.add(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${v.typeName}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${property.name}</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v } <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(thisRef: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ShaderBuilder</span></span></span></span><span class="hljs-function"><span class="hljs-params">, property: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">KProperty</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;*&gt;, value: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { thisRef.varyings.add(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${v.typeName}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${property.name}</span></span></span><span class="hljs-string">"</span></span>) thisRef.instructions.add(Instruction.assign(property.name, value.value)) } }</code> </pre><br>  Implementasi dari delegasi yang tersisa di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> . <br></div></div><br>  Contoh shader: <br><br><pre> <code class="hljs pgsql">//    useAlphaTest     , //       , ,  , //   . <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> FragmentShader(useAlphaTest: <span class="hljs-type"><span class="hljs-type">Boolean</span></span>) : ShaderBuilder() { private val alphaTestThreshold <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> uniform(::GLFloat) private val texture <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> uniform(::Sampler2D) private val uv <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-type"><span class="hljs-type">varying</span></span>(::Vec2) init { var color <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> vec4() color = texture2D(texture, uv) // static branching <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useAlphaTest) { // dynamic branching <span class="hljs-keyword"><span class="hljs-keyword">If</span></span>(color.w lt alphaTestThreshold) { <span class="hljs-keyword"><span class="hljs-keyword">discard</span></span>() } } //     ShaderBuilder. gl_FragColor = color } }</code> </pre><br>  Dan di sini adalah sumber GLSL yang dihasilkan (hasil dari FragmentShader (useAlphaTest = true) .getSource ()).  Konten dan struktur kode dipertahankan: <br><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> sampler2D texture; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> alphaTestThreshold; varying vec2 uv; void main(void) { vec4 <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = texture2D(texture, uv); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">color</span></span>.w &lt; alphaTestThreshold)) { discard; } gl_FragColor = <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>; }</code> </pre><br>  Lebih mudah untuk menggunakan kembali kode shader dengan mengatur parameter yang berbeda saat merakit sumber, tetapi ini tidak sepenuhnya menyelesaikan masalah penggunaan kembali.  Jika Anda perlu menulis kode yang sama di shader yang berbeda, Anda dapat memasukkan instruksi ini ke dalam ShaderBuilderComponent yang terpisah dan menambahkannya seperlunya ke ShaderBuilders utama: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShadowReceiveComponent</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ShaderBuilderComponent</span></span></span></span>() { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vertex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(parent: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ShaderBuilder</span></span></span></span><span class="hljs-function"><span class="hljs-params">, inp: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Vec4</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { vShadowCoord = shadowMVP * inp ... parent.appendComponent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fragment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(parent: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ShaderBuilder</span></span></span></span><span class="hljs-function"><span class="hljs-params">, brightness: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">GLFloat</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pixel <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> float() pixel = texture2D(shadowTexture, vShadowCoord.xy).x ... parent.appendComponent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } }</code> </pre><br>  Hore, fungsi yang diterima memungkinkan Anda untuk menulis shader di Kotlin, menggunakan kembali kode, memeriksa sintaks! <br><br>  Sekarang, mari kita ingat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Swizzling</a> di GLSL dan lihat implementasinya di Vec2, Vec3, Vec4. <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec2</span></span></span><span class="hljs-class"> { var x by </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ComponentDelegate</span></span></span><span class="hljs-class">(::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GLFloat</span></span></span><span class="hljs-class">) var y by </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ComponentDelegate</span></span></span><span class="hljs-class">(::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GLFloat</span></span></span><span class="hljs-class">) } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec3</span></span></span><span class="hljs-class"> { var x by </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ComponentDelegate</span></span></span><span class="hljs-class">(::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GLFloat</span></span></span><span class="hljs-class">) ... //  9 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec2</span></span></span><span class="hljs-class"> var xx by </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ComponentDelegate</span></span></span><span class="hljs-class">(::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec2</span></span></span><span class="hljs-class">) var xy by </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ComponentDelegate</span></span></span><span class="hljs-class">(::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec2</span></span></span><span class="hljs-class">) ... } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec4</span></span></span><span class="hljs-class"> { var x by </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ComponentDelegate</span></span></span><span class="hljs-class">(::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GLFloat</span></span></span><span class="hljs-class">) ... //  16 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec2</span></span></span><span class="hljs-class"> var xy by </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ComponentDelegate</span></span></span><span class="hljs-class">(::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec2</span></span></span><span class="hljs-class">) ... //  64 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec3</span></span></span><span class="hljs-class"> var xxx by </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ComponentDelegate</span></span></span><span class="hljs-class">(::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec3</span></span></span><span class="hljs-class">) ... }</span></span></code> </pre><br>  Dalam proyek kami, kompilasi shader dapat terjadi dalam siklus permainan sesuai permintaan, dan alokasi objek seperti itu menghasilkan panggilan GC besar, kelambatan muncul.  Oleh karena itu, kami memutuskan untuk mentransfer perakitan sumber shader ke tahap kompilasi menggunakan prosesor anotasi. <br><br>  Kami menandai kelas dengan anotasi ShaderProgram: <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@ShaderProgram(VertexShader::class, FragmentShader::class)</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShaderProgramName</span></span></span></span>(alphaTest: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>)</code> </pre><br>  Dan prosesor anotasi mengumpulkan semua jenis shader tergantung pada parameter konstruktor vertex dan kelas fragmen untuk kita: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShaderProgramNameSources</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sources</span></span></span></span>(vertex: String, fragment: String): ShaderProgramSources { Source0(<span class="hljs-string"><span class="hljs-string">"&lt;vertex code&gt;"</span></span>, <span class="hljs-string"><span class="hljs-string">"&lt;fragment code&gt;"</span></span>) ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(alphaTest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (alphaTest) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Source0 <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Source1 } }</code> </pre><br>  Sekarang Anda bisa mendapatkan teks shader dari kelas yang dihasilkan: <br><br><pre> <code class="hljs swift">val sources = <span class="hljs-type"><span class="hljs-type">ShaderProgramNameSources</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(replaceAlpha = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(sources.vertex) <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(sources.fragment)</code> </pre><br>  Karena hasil dari fungsi get - ShaderProgramSources adalah nilai dari enum, mudah untuk menggunakannya sebagai kunci dalam registri program (ShaderProgramSources) -&gt; CompiledShaderProgram. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> memiliki kode sumber untuk proyek tersebut, termasuk prosesor anotasi dan contoh sederhana shader dan komponen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425027/">https://habr.com/ru/post/id425027/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425015/index.html">Jual tanpa bug: keamanan digital platform e-commerce</a></li>
<li><a href="../id425019/index.html">Voronezh, menunggu Anda (dan tidak hanya) + kompetisi</a></li>
<li><a href="../id425021/index.html">Kami mencari pustaka universal cepat untuk bekerja dengan file grafik, memahami tolok ukur Google</a></li>
<li><a href="../id425023/index.html">Kami menerjemahkan resep ke dalam bahasa multicooker</a></li>
<li><a href="../id425025/index.html">Golang menguji di luar jangkauan kita</a></li>
<li><a href="../id425031/index.html">Lebih banyak latihan! Mari kita ajarkan Spring Framework dan profiling tanpa konferensi</a></li>
<li><a href="../id425033/index.html">Membangun Jetpack: Laporan Tahunan JetPack Aviation 2017</a></li>
<li><a href="../id425037/index.html">Berita IT Geek Hub: bagaimana kami melakukan pencarian sepeda di Praha dan apa yang menanti Anda di pertemuan berikutnya</a></li>
<li><a href="../id425039/index.html">Minggu Keamanan 37: Facebook, Twitter, dan Bug Tiup</a></li>
<li><a href="../id425041/index.html">Apa yang salah dengan GraphQL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>