<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍦 🐻 🐣 Keuntungan dan kerugian HugePages 🧑🏿‍🤝‍🧑🏽 🔏 👧🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Terjemahan artikel disiapkan untuk siswa kursus Administrator Linux . 



 Sebelumnya, saya berbicara tentang cara menguji dan mengaktifkan penggunaan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Keuntungan dan kerugian HugePages</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/460403/"><p><img src="https://habrastorage.org/webt/-w/lp/l5/-wlpl5yurwmjrqrh5ufgru7fejm.png"></p><br><p>  <em>Terjemahan artikel disiapkan untuk siswa kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Administrator Linux</a> .</em> </p><br><hr><br><p>  Sebelumnya, saya berbicara tentang cara menguji dan mengaktifkan penggunaan Hugepages di Linux. <br>  Artikel ini hanya akan berguna jika Anda benar-benar memiliki tempat untuk menggunakan Hugepages.  Saya telah bertemu banyak orang yang tertipu oleh prospek bahwa Hugepages secara ajaib akan meningkatkan produktivitas.  Namun, pelukan adalah topik yang kompleks, dan jika digunakan secara tidak benar, ini dapat mengurangi kinerja. <a name="habracut"></a></p><br><h1 id="chast-1-proveryaem-chto-hugepages-vklyucheny-v-linux-original-zdeshttpstechoverflownet20130801checking-if-hugepages-are-enabled-in-linux">  Bagian 1: verifikasi bahwa hugepage termasuk di Linux (asli di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ) </h1><br><p>  <strong>Masalah:</strong> <br>  Anda perlu memeriksa apakah HugePages diaktifkan di sistem Anda. </p><br><p>  <strong>Solusi:</strong> <br>  Ini sangat sederhana: </p><br><pre><code class="plaintext hljs">cat /sys/kernel/mm/transparent_hugepage/enabled</code> </pre> <br><p>  Anda akan mendapatkan sesuatu seperti ini: </p><br><pre> <code class="plaintext hljs">always [madvise] never</code> </pre> <br><p>  Anda akan melihat daftar opsi yang tersedia ( <em>selalu, madvise, tidak pernah</em> ), sedangkan opsi aktif saat ini akan dilampirkan dalam tanda kurung (secara default, <em>madvise</em> ). </p><br><p>  <em>madvise</em> berarti <code>transparent hugepages</code> hanya termasuk untuk wilayah memori yang secara eksplisit meminta hugepage dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">madvise (2)</a> . </p><br><p>  <em>selalu</em> berarti <code>transparent hugepages</code> selalu diaktifkan untuk semua proses.  Ini biasanya meningkatkan kinerja, tetapi jika Anda memiliki kasus penggunaan di mana banyak proses mengkonsumsi sejumlah kecil memori, maka total beban memori dapat meningkat secara dramatis. </p><br><p>  <em>tidak pernah</em> berarti <code>transparent hugepages</code> tidak akan disertakan bahkan ketika diminta menggunakan madvise.  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> kernel Linux untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">informasi</a> lebih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lanjut</a> . </p><br><h4 id="kak-izmenit-znachenie-po-umolchaniyu">  Cara mengubah nilai default </h4><br><p>  <strong>Opsi 1</strong> : Ubah <code>sysfs</code> secara langsung (setelah reboot, parameter akan kembali ke nilai default): </p><br><pre> <code class="plaintext hljs">echo always &gt;/sys/kernel/mm/transparent_hugepage/enabled echo madvise &gt;/sys/kernel/mm/transparent_hugepage/enabled echo never &gt;/sys/kernel/mm/transparent_hugepage/enabled</code> </pre> <br><p>  <strong>Opsi 2</strong> : Ubah default sistem dengan mengkompilasi ulang kernel dengan konfigurasi yang dimodifikasi (opsi ini hanya disarankan jika Anda menggunakan kernel Anda sendiri): </p><br><ul><li>  Untuk mengatur selalu ke default, gunakan: <br><pre> <code class="plaintext hljs">CONFIG_TRANSPARENT_HUGEPAGE_ALWAYS=y # Comment out CONFIG_TRANSPARENT_HUGEPAGE_MADVISE=y</code> </pre> </li><li>  Untuk mengatur madvise secara default, gunakan: <br><pre> <code class="plaintext hljs">CONFIG_TRANSPARENT_HUGEPAGE_MADVISE=y # Comment out CONFIG_TRANSPARENT_HUGEPAGE_ALWAYS=y</code> </pre> </li></ul><br><h1 id="chast-2-preimuschestva-i-nedostatki-hugepages">  Bagian 2: Keuntungan dan Kerugian dari HugePages </h1><br><p>  Kami akan mencoba menjelaskan secara selektif kelebihan, kekurangan, dan kemungkinan kesalahan saat menggunakan Hugepages.  Karena artikel yang canggih secara teknologi dan pedantic cenderung sulit bagi orang-orang yang tertipu dengan menganggap Hugepages sebagai obat mujarab, saya akan mengorbankan akurasi demi kesederhanaan.  Perlu diingat bahwa banyak topik sangat kompleks dan karenanya sangat disederhanakan. </p><br><p>  Harap dicatat bahwa kita berbicara tentang sistem x86 64-bit yang berjalan di Linux, dan saya hanya berasumsi bahwa sistem tersebut mendukung hugepage transparan (karena bukan suatu kerugian bahwa hugepage tidak diganti), seperti yang terjadi di hampir semua negara modern Lingkungan Linux. </p><br><p>  <em>Pada tautan di bawah ini saya akan melampirkan lebih banyak deskripsi teknis.</em> </p><br><h4 id="virtualnaya-pamyat">  Memori virtual </h4><br><p>  Jika Anda seorang programmer C ++, Anda tahu bahwa objek dalam memori memiliki alamat spesifik (nilai pointer). </p><br><p>  Namun, alamat-alamat ini tidak mencerminkan alamat fisik dalam memori (alamat dalam RAM).  Mereka adalah alamat dalam memori virtual.  Prosesor memiliki modul MMU (unit manajemen memori) khusus yang membantu kernel memetakan memori virtual ke lokasi fisik. </p><br><p>  Pendekatan ini memiliki banyak keunggulan, tetapi yang paling mendasar di antaranya: </p><br><ul><li>  Kinerja (karena berbagai alasan); </li><li>  Isolasi program, yaitu, tidak ada program yang dapat membaca dari memori program lain. </li></ul><br><h4 id="chto-takoe-stranicy">  Apa itu halaman? </h4><br><p>  Memori virtual dibagi menjadi beberapa halaman.  Setiap halaman individu menunjuk ke memori fisik tertentu, itu dapat menunjuk ke suatu wilayah dalam RAM, atau dapat menunjuk ke alamat yang ditugaskan untuk perangkat fisik, seperti kartu video. </p><br><p>  Sebagian besar halaman yang Anda berurusan dengan menunjuk ke RAM atau swap, yaitu, mereka disimpan di hard drive atau SSD Anda.  Kernel mengontrol tata letak fisik setiap halaman.  Jika halaman spoofed diakses, kernel menghentikan utas yang mencoba mengakses memori, membaca halaman dari hard drive / SSD ke dalam RAM, dan kemudian melanjutkan untuk menjalankan utas. </p><br><p>  Proses ini transparan untuk streaming, artinya, tidak harus membaca langsung dari hard drive / SSD.  Ukuran halaman normal adalah 4096 byte.  Hugepages berukuran 2 megabyte. </p><br><h4 id="bufer-associativnoy-translyacii-tlb">  Buffer Terjemahan Asosiatif (TLB) </h4><br><p>  Ketika suatu program mengakses halaman memori, prosesor pusat harus tahu dari mana halaman fisik untuk membaca data (mis., Memiliki peta alamat virtual). </p><br><p>  Inti memiliki struktur data (tabel halaman) yang berisi semua informasi tentang halaman yang digunakan.  Menggunakan struktur data ini, Anda dapat memetakan alamat virtual ke alamat fisik. </p><br><p>  Namun, tabel halaman agak rumit dan berjalan lambat, jadi kami tidak bisa menganalisis seluruh struktur data setiap kali suatu proses mengakses memori. </p><br><p>  Untungnya, prosesor kami memiliki TLB yang melakukan cache pemetaan alamat virtual dan fisik.  Ini berarti bahwa terlepas dari kenyataan bahwa kami perlu menganalisis tabel halaman saat pertama kali kami mencoba mengaksesnya, semua panggilan halaman berikutnya dapat diproses dalam TLB, yang memastikan operasi cepat. </p><br><p>  Karena diimplementasikan sebagai perangkat fisik (yang membuatnya cepat), kapasitasnya terbatas.  Karenanya, jika Anda ingin mengakses lebih banyak halaman, TLB tidak akan dapat menyimpan pemetaan untuk semuanya, karena itu program Anda akan bekerja jauh lebih lambat. </p><br><h4 id="hugepages-prihodyat-na-pomosch">  Hugepages datang untuk menyelamatkan </h4><br><p>  Jadi apa yang bisa kita lakukan untuk menghindari TLB overflow?  (Kami berasumsi bahwa program masih membutuhkan jumlah memori yang sama). </p><br><p>  Di sinilah Hugepages muncul.  Alih-alih 4096 byte, hanya membutuhkan satu entri di TLB, satu entri di TLB sekarang dapat mengarah ke 2 megabyte kekalahan.  Kami akan menganggap bahwa TLB memiliki 512 entri, di sini tanpa Hugepages kami dapat mencocokkan: </p><br><pre> <code class="plaintext hljs">4096 b⋅512=2 MB</code> </pre> <br><p>  Sedangkan dengan mereka kita dapat membandingkan: </p><br><pre> <code class="plaintext hljs">2 MB⋅512=1 GB</code> </pre> <br><p>  Itulah mengapa Hugepages mengagumkan.  Mereka dapat meningkatkan produktivitas tanpa upaya yang signifikan.  Tetapi ada pemesanan yang signifikan. </p><br><h4 id="podmena-hugepages">  Hugepages spoofing </h4><br><p>  Kernel secara otomatis melacak frekuensi penggunaan setiap halaman memori.  Jika memori fisik (RAM) tidak cukup, kernel akan memindahkan halaman yang kurang penting (lebih jarang digunakan) ke hard drive untuk membebaskan sebagian RAM untuk halaman yang lebih penting. <br>  Pada dasarnya, hal yang sama berlaku untuk Hugepages.  Namun, kernel hanya dapat menukar seluruh halaman, bukan byte individual. </p><br><p>  Misalkan kita memiliki program seperti ini: </p><br><pre> <code class="plaintext hljs">char* mymemory = malloc(2*1024*1024); //     Hugepage! //  mymemory -  //    , //      mymemory // ... //       putchar(mymemory[0]);</code> </pre> <br><p>  Dalam hal ini, kernel perlu mengganti (baca) informasi sebanyak 2 megabita dari hard drive / SSD hanya agar Anda dapat membaca satu byte.  Sedangkan untuk halaman reguler, hanya 4.096 byte yang perlu dibaca dari hard drive / SSD. </p><br><p>  Karena itu, jika hugepage diganti, pembacaannya lebih cepat hanya jika Anda perlu mengakses seluruh halaman.  Ini berarti bahwa jika Anda mencoba secara acak mengakses berbagai bagian memori dan hanya membaca beberapa kilobyte, Anda harus menggunakan halaman biasa dan tidak perlu khawatir tentang hal lain. </p><br><p>  Di sisi lain, jika Anda perlu mengakses sebagian besar memori secara berurutan, hugepage akan meningkatkan produktivitas Anda.  Namun demikian, Anda perlu memeriksa ini sendiri (dan bukan pada contoh perangkat lunak abstrak) dan melihat mana yang bekerja lebih cepat. </p><br><h4 id="allokaciya-v-pamyati">  Alokasi memori </h4><br><p>  Jika Anda menulis dalam C, Anda tahu bahwa Anda dapat meminta sejumlah kecil (atau hampir sewenang-wenang) jumlah memori dari tumpukan menggunakan <code>malloc()</code> .  Katakanlah Anda membutuhkan 30 byte memori: </p><br><pre> <code class="plaintext hljs">char* mymemory = malloc(30);</code> </pre> <br><p>  Tampaknya bagi pemrogram Anda "meminta" 30 byte memori dari sistem operasi dan mengembalikan pointer ke beberapa memori virtual.  Tetapi sebenarnya <code>malloc ()</code> hanyalah fungsi C yang memanggil fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">brk dan sbrk</a> dari dalam untuk meminta atau membebaskan memori dari sistem operasi. </p><br><p>  Namun, meminta lebih banyak dan lebih banyak memori untuk setiap alokasi tidak efisien;  kemungkinan besar segmen memori telah dibebaskan <code>(free())</code> , dan kita dapat menggunakannya kembali.  <code>malloc()</code> mengimplementasikan algoritma yang cukup kompleks untuk menggunakan kembali memori yang dibebaskan. </p><br><p>  Pada saat yang sama, semuanya terjadi tanpa disadari oleh Anda, jadi mengapa itu harus Anda perhatikan?  Tetapi karena panggilan untuk <code>free()</code> tidak berarti bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memori akan segera dikembalikan ke sistem operasi</a> . </p><br><p>  Ada yang namanya fragmentasi memori.  Dalam kasus ekstrim, ada segmen tumpukan di mana hanya beberapa byte yang digunakan, sementara semua di antaranya dibebaskan <code>(free())</code> . </p><br><p>  Perhatikan bahwa fragmentasi memori adalah topik yang sangat kompleks, dan bahkan perubahan kecil pada program dapat mempengaruhinya secara signifikan.  Dalam kebanyakan kasus, program tidak menyebabkan fragmentasi memori yang signifikan, tetapi Anda harus ingat bahwa jika fragmentasi terjadi di area tumpukan tertentu, hugepage hanya dapat memperburuk situasi. </p><br><h4 id="vyborochnoe-primenenie-hugepages">  Aplikasi kustom hugepages </h4><br><p>  Setelah membaca artikel, Anda telah menentukan bagian mana dari program Anda yang dapat mengambil manfaat dari penggunaan hugepage dan mana yang tidak.  Jadi haruskah hugepage dimasukkan sama sekali? </p><br><p>  Untungnya, Anda dapat menggunakan <code>madvise()</code> untuk mengaktifkan hugepaging hanya untuk area memori di mana itu akan berguna. </p><br><p>  Untuk memulai, verifikasi bahwa hugepage berfungsi dalam mode madvise (), menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">instruksi</a> di awal artikel. </p><br><p>  Kemudian, gunakan <code>madvise()</code> untuk memberi tahu kernel dengan tepat di mana harus menggunakan hugepages. </p><br><pre> <code class="plaintext hljs">#include &lt;sys/mman.h&gt; //    ,    size_t size = 256*1024*1024; char* mymemory = malloc(size); //   hugepages… madvise(mymemory, size, MADV_HUGEPAGE); // …    madvise(mymemory, size, MADV_HUGEPAGE | MADV_SEQUENTIAL)</code> </pre> <br><p>  Perhatikan bahwa metode ini hanya merupakan rekomendasi untuk kernel untuk manajemen memori.  Ini tidak berarti bahwa kernel akan secara otomatis menggunakan hugepage untuk memori yang diberikan. </p><br><p>  Lihat halaman <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">madvise</a> untuk lebih lanjut tentang manajemen memori dan <code>madvise()</code> , kurva belajar yang sangat curam untuk topik ini.  Karena itu, jika Anda ingin benar-benar memahaminya, bersiaplah untuk membaca dan mengujinya selama beberapa minggu sebelum menghitung setidaknya beberapa hasil positif. </p><br><p>  <strong>Apa yang harus dibaca?</strong> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IBM OpenStack Article on hugepages</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hugepage transparan vs hugepage non-transparan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel Wikipedia tentang TLB</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi kernel Linux tentang hugepage transparan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Stackoverflow: hugepage rentan terhadap fragmentasi memori</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel Manajemen Memori Virtual Microsoft</a> </li></ul><br><hr><br><p>  <em>Punya pertanyaan?</em>  <em>Tulis di komentar!</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460403/">https://habr.com/ru/post/id460403/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460387/index.html">Panduan SELinux Beginner</a></li>
<li><a href="../id460393/index.html">Latar belakang: apa yang diharapkan dari Fedora Silverblue</a></li>
<li><a href="../id460395/index.html">Analytics sebagai fitur: proses bekerja dengan data di Plesk</a></li>
<li><a href="../id460397/index.html">Mulai cepat dengan WebComponents</a></li>
<li><a href="../id460399/index.html">Indikator pemuatan SVG di Vue.js</a></li>
<li><a href="../id460405/index.html">Mengapa Anda membutuhkan mekanisme permainan tersembunyi</a></li>
<li><a href="../id460409/index.html">Arduino dan keyboard (panduan lengkap)</a></li>
<li><a href="../id460411/index.html">GIF'ok Konverter Gila ke stiker animasi untuk Telegram</a></li>
<li><a href="../id460413/index.html">7 situs dan aplikasi yang berguna untuk belajar bahasa Inggris</a></li>
<li><a href="../id460415/index.html">Apple Watch 4 (44 mm, 2019) vs Pebble Steel Classic (2014)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>