<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🎤 👇🏼 ☂️ NoVerify: Der Linter für PHP vom VKontakte-Team ist jetzt gemeinfrei 🙇🏾 😍 🈯️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich werde Ihnen erzählen, wie wir es geschafft haben, einen Linter zu schreiben, der schnell genug war, um bei jedem Git-Push nach Änderungen zu suche...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>NoVerify: Der Linter für PHP vom VKontakte-Team ist jetzt gemeinfrei</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/vk/blog/442284/"><img src="https://habrastorage.org/webt/zu/fg/gw/zufggwwy-grc8n2umc_p0_ioskw.png"><br><br>  Ich werde Ihnen erzählen, wie wir es geschafft haben, einen Linter zu schreiben, der schnell genug war, um bei jedem Git-Push nach Änderungen zu suchen, und dies in 5-10 Sekunden mit einer Codebasis von 5 Millionen Zeilen in PHP.  Wir haben es NoVerify genannt. <br><br>  NoVerify unterstützt grundlegende Dinge wie den Übergang zur Definition und die Suche nach Verwendungen und kann im <a href="">Sprachservermodus</a> arbeiten.  Unser Tool konzentriert sich zunächst auf die Suche nach potenziellen Fehlern, kann aber auch den Stil überprüfen.  Heute erschien der Quellcode in Open Source auf GitHub.  Suchen Sie nach dem Link am Ende des Artikels. <br><a name="habracut"></a><br><h2>  Warum brauchen wir unseren Linter? </h2><br>  Mitte 2018 beschlossen wir, einen Linter für PHP-Code zu implementieren.  Es gab zwei Ziele: Reduzierung der Anzahl der Fehler, die Benutzer sehen, und strengere Überwachung der Einhaltung des Codestils.  Das Hauptaugenmerk lag auf der Vermeidung typischer Fehler: das Vorhandensein nicht deklarierter und nicht verwendeter Variablen im Code, nicht erreichbarer Code und andere.  Ich wollte auch, dass der statische Analysator so schnell wie möglich auf unserer Codebasis funktioniert (5-6 Millionen Zeilen PHP-Code zum Zeitpunkt des Schreibens). <br><br>  Wie Sie wahrscheinlich wissen, ist der Quellcode für den größten Teil der Site in PHP geschrieben und mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">KPHP</a> kompiliert. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Daher</a> wäre es logisch, diese Überprüfungen dem Compiler hinzuzufügen.  Tatsächlich ist jedoch nicht der gesamte Code für die Ausführung über KPHP sinnvoll. Beispielsweise ist der Compiler nur schwach mit Bibliotheken von Drittanbietern kompatibel, sodass für einige Teile der Site weiterhin reguläres PHP verwendet wird.  Sie sind ebenfalls wichtig und sollten vom Linter überprüft werden. Daher gibt es leider keine Möglichkeit, sie in KPHP zu integrieren. <br><br><h2>  Warum NoVerify? </h2><br>  Angesichts der Menge an PHP-Code (ich möchte Sie daran erinnern, dass dies 5 bis 6 Millionen Zeilen sind) ist es nicht möglich, ihn sofort zu "reparieren", damit er unsere Prüfungen im Linter besteht.  Trotzdem möchte ich, dass der sich ändernde Code allmählich sauberer wird, den Codierungsstandards strenger folgt und auch weniger Fehler enthält.  Aus diesem Grund haben wir beschlossen, dass der Linter in der Lage sein sollte, die Änderungen zu überprüfen, die der Entwickler starten wird, und nicht auf den Rest zu schwören. <br><br>  Dazu muss der Linter das gesamte Projekt indizieren, die Dateien vor und nach den Änderungen vollständig analysieren und die Differenz zwischen den generierten Warnungen berechnen.  Dem Entwickler werden neue Warnungen angezeigt, die vor dem Push behoben werden müssen. <br><br>  Es gibt jedoch Situationen, in denen dieses Verhalten unerwünscht ist und Entwickler dann ohne lokale Hooks pushen können - mit dem <code>git push --no-verify</code> .  Option <code>--no-verify</code> und gab einem Linter einen Namen :) <br><br><h2>  Was waren die Alternativen </h2><br>  Die Codebasis in VK verwendet wenig OOP und besteht im Wesentlichen aus Funktionen und Klassen mit statischen Methoden.  Wenn Klassen in PHP das automatische Laden unterstützen, funktionieren Funktionen nicht.  Daher können wir keine statischen Analysatoren ohne wesentliche Änderungen verwenden, die ihre Arbeit auf der Tatsache basieren, dass beim automatischen Laden der gesamte fehlende Code geladen wird.  Zu diesen Lintern gehört beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Psalm von Vimeo</a> . <br><br>  Wir haben die folgenden statischen Analysewerkzeuge untersucht: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PHPStan</a> - Single-Threaded, erfordert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">automatisches Laden</a> , Codebasisanalyse hat 30% in einer halben Stunde erreicht; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Phan</a> - selbst im Schnellmodus mit 20 Prozessen kam die Analyse nach 20 Minuten um 5% zum Stillstand; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Psalm</a> - erfordert Autoload, Analyse dauerte 10 Minuten (ich möchte immer noch viel schneller sein); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PHPCS</a> - überprüft den Stil, aber nicht die Logik; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">phpcf</a> - prüft nur auf Formatierung. </li></ul><br>  Wie Sie dem Titel des Artikels entnehmen können, entspricht keines dieser Tools unseren Anforderungen, daher haben wir unser eigenes geschrieben. <br><br><h2>  Wie wurde der Prototyp erstellt? </h2><br>  Zuerst haben wir uns entschlossen, einen kleinen Prototyp zu bauen, um zu verstehen, ob es sich lohnt, einen vollwertigen Linter herzustellen.  Da eine der wichtigsten Anforderungen für den Linter die Geschwindigkeit ist, haben wir uns für Go anstelle von PHP entschieden.  "Schnell" bedeutet, dem Entwickler so schnell wie möglich eine Rückmeldung zu geben, vorzugsweise in nicht mehr als 10 bis 20 Sekunden.  Andernfalls verlangsamt der Zyklus "Code korrigieren, Linter erneut ausführen" die Entwicklung erheblich und beeinträchtigt die Stimmung für die Menschen :) <br><br>  Da für den Prototyp Go ausgewählt ist, benötigen Sie einen PHP-Parser.  Es gibt mehrere davon, aber das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PHP-Parser-</a> Projekt schien uns das ausgereifteste zu sein.  Dieser Parser ist nicht perfekt und wird noch entwickelt, aber für unsere Zwecke ist er durchaus geeignet. <br><br>  Für den Prototyp wurde beschlossen, eine der auf den ersten Blick einfachsten Inspektionen durchzuführen: den Zugriff auf eine undefinierte Variable. <br><br>  Die Grundidee für die Implementierung einer solchen Inspektion sieht einfach aus: Erstellen Sie für jeden Zweig (z. B. if) einen separaten verschachtelten Bereich und kombinieren Sie die Variablentypen am Ausgang.  Ein Beispiel: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rand()) { $a = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  : { $a: int } } else { $b = "test"; $a = "another_test"; //  : { $b: string, $a: string } } //   : { $b: string?, $a: int|string } echo $a, $b; //       , //   $b   </span></span></code> </pre><br>  Es sieht einfach aus, oder?  Bei gewöhnlichen bedingten Anweisungen funktioniert alles gut.  Aber wir müssen zum Beispiel ohne Unterbrechung wechseln; <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (rand()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: $a = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// { $a: int } case 2: $b = 2; // { $a: int, $b: int } default: $c = 3; // { $a: int, $b: int, $c: int } } // { $a: int?, $b: int?, $c: int }</span></span></code> </pre><br>  Aus dem Code geht nicht sofort hervor, dass $ c tatsächlich immer definiert wird.  Insbesondere ist dieses Beispiel fiktiv, aber es zeigt gut, welche schwierigen Momente für den Linter (und in diesem Fall auch für die Person) sind. <br><br>  Betrachten Sie ein komplexeres Beispiel: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> exec(<span class="hljs-string"><span class="hljs-string">"hostname"</span></span>, $out, $retval); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $out, $retval; <span class="hljs-comment"><span class="hljs-comment">// { $out: ???, $retval: ??? }</span></span></code> </pre><br>  Ohne Kenntnis der Signatur der exec-Funktion kann nicht gesagt werden, ob $ out und $ retval definiert werden.  Signaturen der integrierten Funktionen können aus dem Repository <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/JetBrains/phpstorm-stubs</a> entnommen werden.  Die gleichen Probleme treten jedoch beim Aufrufen benutzerdefinierter Funktionen auf, und ihre Signatur kann nur durch Indizieren des gesamten Projekts ermittelt werden.  Die exec-Funktion nimmt das zweite und dritte Argument als Referenz, was bedeutet, dass die Variablen $ out und $ retval definiert werden können.  Hier ist der Zugriff auf diese Variablen nicht unbedingt ein Fehler, und der Linter sollte nicht auf einen solchen Code schwören. <br><br>  Ähnliche Probleme beim impliziten Link-Passing treten bei Methoden auf, gleichzeitig wird jedoch die Notwendigkeit hinzugefügt, Variablentypen abzuleiten: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rand()) { $a = some_func(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $a = other_func(); } $a-&gt;some_method($b); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $b;</code> </pre><br>  Wir müssen wissen, welche Typen die Funktionen some_func () und other_func () zurückgeben, um später in diesen Klassen eine Methode namens some_method zu finden.  Nur dann können wir sagen, ob die Variable $ b definiert wird oder nicht.  Die Situation wird durch die Tatsache kompliziert, dass häufig einfache Funktionen und Methoden keine phpdoc-Annotationen enthalten. Sie müssen daher weiterhin in der Lage sein, die Arten von Funktionen und Methoden basierend auf ihrer Implementierung zu berechnen. <br><br>  Bei der Entwicklung des Prototyps musste ich etwa die Hälfte aller Funktionen implementieren, damit die einfachste Inspektion ordnungsgemäß funktionierte. <br><br><h2>  Arbeite als Sprachserver </h2><br>  Um das Debuggen der Logik des Linter und das Anzeigen der von ihm ausgegebenen Warnungen zu vereinfachen, haben wir beschlossen, den Betriebsmodus als <a href="">Sprachserver für PHP</a> hinzuzufügen.  Im Integrationsmodus mit Visual Studio Code sieht es ungefähr so ​​aus: <br><br><img src="https://habrastorage.org/webt/dr/ig/vj/drigvj1bhifibymyhcl_vzjq7q8.jpeg"><br><br>  In diesem Modus ist es praktisch, Hypothesen und komplexe Fälle zu testen (danach müssen Sie natürlich Tests schreiben).  Es ist auch gut, die Leistung zu testen: Selbst bei großen Dateien zeigt der PHP-Parser unter Go eine gute Geschwindigkeit. <br><br>  Die Unterstützung von Sprachservern ist alles andere als ideal, da der Hauptzweck darin besteht, Linter-Regeln zu debuggen.  In diesem Modus gibt es jedoch mehrere zusätzliche Funktionen: <br><br><ol><li>  Tipps für Variablennamen, Konstanten, Funktionen, Eigenschaften und Methoden. </li><li>  Markieren Sie abgeleitete Variablentypen. </li><li>  Gehen Sie zur Definition. </li><li>  Suche nach Verwendungen. </li></ol><br><h2>  Inferenz vom Typ "Lazy" </h2><br>  Im Sprachservermodus ist Folgendes erforderlich: Sie ändern den Code in einer Datei, und wenn Sie zu einer anderen wechseln, sollten Sie mit bereits aktualisierten Informationen darüber arbeiten, welche Typen in Funktionen oder Methoden zurückgegeben werden.  Stellen Sie sich die Dateien vor, die in der folgenden Reihenfolge bearbeitet werden: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">//  A.php,  1 class A { /** @var int */ public $prop; } //  B.php,   class B { public static function something() { $obj = new A; return $obj-&gt;prop; } } //  C.php,   $c = B::something(); // $c   int //  A.php,  2 class A { /** @var string &lt;---   string */ public $prop; } //  C.php,   $c = B::something(); // $c   string,   B.php,  C.php  </span></span></code> </pre><br>  Da wir Entwickler nicht zwingen, immer PHPDoc zu schreiben (insbesondere in solchen einfachen Fällen), benötigen wir eine Möglichkeit, Informationen darüber zu speichern, welchen Typ die Funktion B :: Something () zurückgibt.  Wenn sich die A.php-Datei ändert, sind die Typinformationen in der C.php-Datei sofort auf dem neuesten Stand. <br><br>  Eine mögliche Lösung besteht darin, "faule Typen" zu speichern.  Beispielsweise ist der Rückgabetyp der B :: Something () -Methode tatsächlich ein Ausdruckstyp (neues A) -&gt; Prop.  In diesem Formular speichert der Linter Informationen über den Typ. Dank dieser Funktion können Sie alle Metainformationen für jede Datei zwischenspeichern und nur aktualisieren, wenn sich diese Datei ändert.  Dies sollte sorgfältig durchgeführt werden, damit nicht versehentlich zu spezifische Informationen über Typen herauskommen.  Es ist auch erforderlich, die Cache-Version zu ändern, wenn sich die Typinferenzlogik ändert.  Trotzdem beschleunigt ein solcher Cache die Indizierungsphase (auf die ich später noch eingehen werde) um das 5- bis 10-fache im Vergleich zum wiederholten Parsen aller Dateien. <br><br><h2>  Zwei Arbeitsphasen: Indizierung und Analyse </h2><br>  Wie wir uns erinnern, sind selbst für die einfachste Code-Analyse Informationen über alle Funktionen und Methoden im Projekt erforderlich.  Dies bedeutet, dass Sie nicht nur eine Datei getrennt vom Projekt analysieren können.  Und doch - dass dies nicht in einem Durchgang möglich ist: Mit PHP können Sie beispielsweise auf Funktionen zugreifen, die in der Datei weiter deklariert sind. <br><br>  Aufgrund dieser Einschränkungen besteht der Betrieb des Linters aus zwei Phasen: der primären Indizierung und der anschließenden Analyse nur der erforderlichen Dateien.  Nun mehr zu diesen beiden Phasen. <br><br><h3>  Indizierungsphase </h3><br>  In dieser Phase werden alle Dateien analysiert und eine lokale Analyse des Codes von Methoden und Funktionen sowie des Codes auf oberster Ebene durchgeführt (um beispielsweise die Typen globaler Variablen zu bestimmen).  Informationen zu den deklarierten globalen Variablen, Konstanten, Funktionen, Klassen und ihren Methoden werden gesammelt und in den Cache geschrieben.  Für jede Datei im Projekt ist der Cache eine separate Datei auf der Festplatte. <br><br>  Ein globales Wörterbuch aller Metainformationen über das Projekt, das sich in Zukunft nicht ändert *, wird aus einzelnen Teilen zusammengestellt. <br><br>  <i>* Zusätzlich zur Funktionsweise als Sprachserver wird bei jeder Bearbeitung eine Indizierung und Analyse der geänderten Datei durchgeführt.</i> <br><br><h3>  Analysephase </h3><br>  In dieser Phase können wir Metainformationen (über Funktionen, Klassen ...) verwenden und den Code bereits direkt analysieren.  Hier ist eine Liste dessen, was NoVerify standardmäßig überprüfen kann: <br><br><ul><li>  nicht erreichbarer Code; </li><li>  Zugriff auf Objekte als Array; </li><li>  unzureichende Anzahl von Argumenten beim Aufrufen der Funktion; </li><li>  Aufrufen einer undefinierten Methode / Funktion; </li><li>  Zugriff auf die fehlende Klasseneigenschaft / Konstante; </li><li>  Mangel an Klasse; </li><li>  Ungültiges PHPDoc </li><li>  Zugriff auf eine undefinierte Variable; </li><li>  Zugriff auf eine Variable, die nicht immer definiert ist; </li><li>  Mangel an "Pause";  nach case in switch / case Konstrukten; </li><li>  Syntaxfehler </li><li>  nicht verwendete Variable. </li></ul><br>  Die Liste ist ziemlich kurz, aber Sie können projektspezifische Schecks hinzufügen. <br><br>  Während des Betriebs des Linter stellte sich heraus, dass die nützlichste Inspektion nur die letzte (nicht verwendete Variable) ist.  Dies passiert häufig, wenn Sie den Code umgestalten (oder einen neuen schreiben) und ihn im Variablennamen versiegeln: Dieser Code ist aus Sicht von PHP gültig, aber logisch fehlerhaft. <br><br><h2>  Arbeitsgeschwindigkeit </h2><br>  Wie lange ist die Änderung, die wir pushen möchten, überprüft?  Es hängt alles von der Anzahl der Dateien ab.  Mit NoVerify kann der Vorgang bis zu einer Minute dauern (als ich 1400 Dateien im Repository geändert habe). Wenn jedoch nur wenige Änderungen vorgenommen wurden, werden normalerweise alle Überprüfungen in 4 bis 5 Sekunden durchgeführt.  Während dieser Zeit wird das Projekt vollständig indiziert und analysiert neue Dateien sowie deren Analyse.  Wir konnten durchaus einen Linter für PHP erstellen, der auch mit unserer großen Codebasis schnell funktioniert. <br><br><h2>  Was ist das Ergebnis? </h2><br>  Da die Lösung in Go geschrieben ist, muss das Repository <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/JetBrains/phpstorm-stubs verwendet</a> werden, damit Definitionen aller Funktionen und Klassen in PHP integriert sind.  Im Gegenzug erreichten wir eine hohe Arbeitsgeschwindigkeit (Indizierung von 1 Million Zeilen pro Sekunde, Analyse von 100.000 Zeilen pro Sekunde) und konnten als einen der ersten Schritte bei Git-Push-Hooks Überprüfungen mit einem Linter hinzufügen. <br><br>  Es wurde eine praktische Basis für die Erstellung neuer Inspektionen entwickelt und ein Niveau des Codeverständnisses in der Nähe von PHPStorm erreicht.  Aufgrund der Tatsache, dass der Modus mit Diff-Berechnung standardmäßig unterstützt wird, ist es möglich, den Code schrittweise zu verbessern und neue potenziell problematische Konstruktionen im neuen Code zu vermeiden. <br><br>  Das Zählen von Diff ist nicht ideal: Wenn beispielsweise eine große Datei in mehrere kleine Dateien unterteilt wurde, kann git und damit NoVerify nicht feststellen, dass der Code verschoben wurde, und der Linter muss alle gefundenen Probleme beheben.  In dieser Hinsicht verhindert die Berechnung von diff ein umfangreiches Refactoring, weshalb es in solchen Fällen häufig deaktiviert wird. <br><br>  Das Schreiben eines Linter on Go hat einen weiteren Vorteil: Nicht nur der AST-Parser ist schneller und verbraucht weniger Speicher als PHP, sondern die nachfolgende Analyse ist auch sehr schnell im Vergleich zu allem, was in PHP durchgeführt werden könnte.  Dies bedeutet, dass unser Linter eine komplexere und tiefere Analyse des Codes durchführen kann, während gleichzeitig eine hohe Leistung erhalten bleibt (zum Beispiel erfordert die Funktion "Lazy Types" eine ziemlich große Anzahl von Berechnungen im Prozess). <br><br><h2>  Open Source </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NoVerify ist als Open Source auf GitHub verfügbar</a> <br><br>  Viel Spaß beim Einsatz in Ihrem Projekt! <br><br>  <b>UPD:</b> Ich habe eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo</a> vorbereitet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, die über WebAssembly funktioniert</a> .  Die einzige Einschränkung dieser Demo ist das Fehlen von Funktionsdefinitionen von phpstorm-stubs, sodass der Linter auf integrierte Funktionen schwören wird. <br><br>  <i>Yuri Nasretdinov, Entwickler der Infrastrukturabteilung von VKontakte</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442284/">https://habr.com/ru/post/de442284/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442272/index.html">Go + = Paketversionierung</a></li>
<li><a href="../de442274/index.html">Dart 2. Asynchrone Programmierung: Datenströme</a></li>
<li><a href="../de442278/index.html">Kibana Benutzerhandbuch. Visualisierung. Teil 6</a></li>
<li><a href="../de442280/index.html">Maschinelles Lernen in Dodo. So starten Sie eine neue Richtung, wenn Sie Entwickler sind</a></li>
<li><a href="../de442282/index.html">Dart 2. Asynchrone Programmierung: Futures</a></li>
<li><a href="../de442286/index.html">Russische Augenärzte sprachen über bionisches Sehen. Die neue mobile Anwendung demonstriert die Arbeit von Cyber</a></li>
<li><a href="../de442288/index.html">Strahlung: Quellen</a></li>
<li><a href="../de442290/index.html">ST-Link V2.1 aus chinesischem ST-Link V2 erstellen</a></li>
<li><a href="../de442292/index.html">Sberseasons-Praktikum: Python, UX / UI, Daten und vieles mehr für Studenten</a></li>
<li><a href="../de442294/index.html">Was Oleg Artamonov ist etwas falsch</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>