<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔩 🚠 💧 Tata bahasa meta untuk pengurai PEG 👨🏽‍🏫 🐏 ⏲️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Minggu ini kita membuat generator parser "independen", yaitu, akan menghasilkan parser sendiri. 
 Konten Seri Parser Python PEG 

- Pengurai pasak 
- ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tata bahasa meta untuk pengurai PEG</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471990/"><p>  Minggu ini kita membuat generator parser "independen", yaitu, akan menghasilkan parser sendiri. </p><br><div class="spoiler">  <b class="spoiler_title">Konten Seri Parser Python PEG</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengurai pasak</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Implementasi parser PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Generasi parser PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Visualisasi parser PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tata Bahasa PEG Rekursif Kiri</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menambahkan Tindakan ke Tata Bahasa PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tata bahasa meta untuk pengurai PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menerapkan fitur PEG yang tersisa</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PEG pada Core Developer Sprint</a> </li></ul></div></div><br><p> Jadi, kita sudah memiliki generator parser, yang sebagian adalah parser tata bahasa.  Kita bisa menyebutnya meta-parser.  Meta-parser bekerja mirip dengan yang dihasilkan: <code>GrammarParser</code> mewarisi dari <code>Parser</code> dan menggunakan mekanisme yang sama <code>mark()</code> / <code>reset()</code> / <code>hope()</code> .  Namun, di sana semuanya ditulis dengan tangan.  Tapi benarkah itu? </p><a name="habracut"></a><br><p>  Saat mendesain kompiler, biasanya kompiler ditulis dalam bahasa yang dikompilasi.  Saya ingat dengan cinta bahwa kompiler Pascal yang saya gunakan ketika saya pertama kali belajar memprogram ditulis dalam Pascal itu sendiri, GCC ditulis dalam C, dan kompiler Rust ditulis dalam Rust. </p><br><p>  Bagaimana cara melakukannya?  Pada awalnya, terapkan kompiler untuk subset atau versi bahasa sebelumnya dalam bahasa lain.  (Biarkan saya mengingatkan Anda bahwa kompiler Pascal asli ditulis dalam FORTRAN!) Kemudian kompiler baru ditulis dalam bahasa target dan dikompilasi menggunakan kompilasi bootstrap yang diimplementasikan di awal.  Segera setelah kompiler baru mulai bekerja dengan cukup baik, kompiler bootstrap dihapus, dan setiap versi bahasa atau kompiler berikutnya dibatasi untuk apa yang dapat dikompilasi menggunakan versi kompilator sebelumnya. </p><br><p>  Mari kita lakukan untuk parser meta kita.  Kami akan menulis tata bahasa untuk tata bahasa (meta-grammar) dan kemudian menghasilkan meta-parser baru dari ini.  Untungnya, saya merencanakan langkah ini dari awal, jadi itu akan sangat sederhana.  Tindakan yang kami tambahkan dalam episode sebelumnya adalah komponen penting karena kami tidak perlu mengubah generator, jadi kami perlu membuat struktur data yang kompatibel. </p><br><p>  Berikut ini adalah versi sederhana dari metagram tanpa tindakan: </p><br><pre> <code class="plaintext hljs">start: rules ENDMARKER rules: rule rules | rule rule: NAME ":" alts NEWLINE alts: alt "|" alts | alt alt: items items: item items | item item: NAME | STRING</code> </pre> <br><p>  Saya akan menunjukkan cara menambahkan tindakan dari bawah ke atas.  Ingat dari Bagian 3 bahwa ada objek <code>Rule</code> yang memiliki <code>name</code> dan <code>alts</code> .  Awalnya, <code>alts</code> hanyalah daftar daftar garis (daftar eksternal untuk alternatif dan daftar internal untuk setiap elemen alternatif), tetapi untuk mengimplementasikan tindakan, saya mengubahnya sehingga alternatif diwakili oleh objek <code>Alt</code> dengan <code>items</code> dan atribut <code>action</code> .  Elemen masih direpresentasikan sebagai string sederhana.  Untuk <code>item</code> kami dapatkan: </p><br><pre> <code class="plaintext hljs">item: NAME { name.string } | STRING { string.string }</code> </pre> <br><p>  Ini memerlukan sedikit penjelasan: ketika penganalisa memproses token, ia mengembalikan objek <code>TokenInfo</code> yang memiliki <code>type</code> , <code>string</code> dan atribut lainnya.  Kami tidak ingin generator menangani objek <code>TokenInfo</code> , jadi tindakan di sini mengekstrak string dari token.  Perhatikan bahwa untuk semua token huruf besar, seperti <code>NAME</code> , parser yang dihasilkan menggunakan versi string (di sini <code>name</code> ) sebagai nama variabel. </p><br><p>  Berikutnya adalah <code>items</code> yang harus mengembalikan daftar string: </p><br><pre> <code class="plaintext hljs">items: item items { [item] + items } | item { [item] }</code> </pre> <br><p>  Di sini saya menggunakan aturan rekursif kanan, jadi kami tidak bergantung pada pemrosesan rekursi kiri yang ditambahkan di Bagian 5. (Mengapa tidak? Selalu baik untuk menjaga hal-hal sesederhana mungkin, dan tata bahasa ini tidak akan banyak mendapat manfaat dari perubahan dalam rekursi kiri) Perhatikan bahwa satu <code>item</code> terdaftar, tetapi <code>items</code> rekursif tidak, karena sudah daftar. </p><br><p>  Aturan <code>alt</code> untuk membuat objek <code>Alt</code> : </p><br><pre> <code class="plaintext hljs">alt: items { Alt(items) }</code> </pre> <br><p>  Saya akan menghilangkan tindakan untuk <code>rules</code> dan <code>start</code> , karena mereka didefinisikan dengan cara ini. </p><br><p>  Namun, ada dua pertanyaan terbuka.  Pertama, bagaimana cara menemukan definisi kelas <code>Rule</code> dan <code>Alt</code> ?  Untuk melakukan ini, kita perlu menambahkan beberapa pernyataan <code>import</code> ke kode yang dihasilkan.  Cara paling sederhana adalah dengan mengedarkan flag ke generator, yang mengatakan "ini adalah meta-grammar", dan biarkan generator memasukkan <code>import</code> tambahan di awal program yang dihasilkan.  Tetapi sekarang setelah kita memiliki tindakan, banyak parser lain juga ingin menyesuaikan impor mereka, jadi mengapa tidak melihat apakah kita dapat menerapkan pendekatan yang lebih umum. </p><br><p>  Ada banyak cara untuk mengimplementasikannya.  Mekanisme sederhana dan umum adalah menambahkan bagian "definisi variabel" di bagian atas tata bahasa dan memungkinkan generator untuk menggunakan variabel-variabel ini untuk mengontrol berbagai aspek dari kode yang dihasilkan.  Saya memutuskan untuk menggunakan simbol <code>@</code> untuk mulai mendefinisikan variabel, diikuti oleh nama variabel ( <code>NAME</code> ) dan nilai ( <code>STRING</code> ).  Sebagai contoh, kita dapat meletakkan blok kode berikut di bagian atas meta-grammar: </p><br><pre> <code class="plaintext hljs">@subheader "from grammar import Rule, Alt"</code> </pre> <br><p>  Generator parser akan mencetak nilai variabel <code>subheader</code> setelah impor standar, yang ditambahkan secara default (misalnya, untuk mengimpor <code>memoize</code> ).  Jika Anda ingin beberapa elemen <code>import</code> , Anda dapat menggunakan string dengan tanda kutip tiga, misalnya, </p><br><pre> <code class="plaintext hljs">@subheader """ from token import OP from grammar import Rule, Alt """</code> </pre> <br><p>  Ini mudah ditambahkan ke meta-grammar: kita akan memecah aturan <code>start</code> menjadi yang berikut: </p><br><pre> <code class="plaintext hljs">start: metas rules ENDMARKER | rules ENDMARKER metas: meta metas | meta meta: "@" NAME STRING NEWLINE</code> </pre> <br><p>  (Saya tidak ingat mengapa saya menyebutnya "meta", tapi saya memilih nama ini ketika saya menulis kode, dan saya akan menaatinya. :-) </p><br><p>  Kita harus menambahkan ini ke metaparser bootstrap.  Sekarang tata bahasa bukan hanya daftar aturan, mari kita tambahkan objek tata bahasa dengan <code>metas</code> dan atribut <code>rules</code> .  Kami dapat mengatur tindakan berikut: </p><br><pre> <code class="plaintext hljs">start: metas rules ENDMARKER { Grammar(rules, metas) } | rules ENDMARKER { Grammar(rules, []) } metas: meta metas { [meta] + metas } | meta { [meta] } meta: "@" NAME STRING { (name.string, eval(string.string)) }</code> </pre> <br><p>  (Perhatikan bahwa <code>meta</code> mengembalikan tuple; dan juga menggunakan <code>eval()</code> untuk memproses kutipan string.) </p><br><p>  Saya tidak menyebutkan implementasi tindakan dalam aturan untuk <code>alt</code> !  Alasannya adalah mereka agak berantakan.  Tetapi tidak masuk akal untuk menunda lebih jauh, jadi di sini: </p><br><pre> <code class="plaintext hljs">alt: items action { Alt(items, action) } | items { Alt(items, None) } action: "{" stuffs "}" { stuffs } stuffs: stuff stuffs { stuff + " " + stuffs } | stuff { stuff } stuff: "{" stuffs "}" { "{" + stuffs + "}" } | NAME { name.string } | NUMBER { number.string } | STRING { string.string } | OP { None if op.string in ("{", "}") else op.string }</code> </pre> <br><p>  Kotoran dalam definisi ini disebabkan oleh keinginan saya untuk membuat kode Python sewenang-wenang valid antara kurung aksi keriting, termasuk bersarang di kurung kurawal lain.  Untuk tujuan ini, kami menggunakan token <code>OP</code> khusus, yang dihasilkan tokenizer kami untuk semua tanda baca yang dikenali oleh Python (mengembalikan satu token dengan tipe <code>OP</code> untuk operator multi-karakter, seperti <code>&lt;=</code> atau <code>**</code> ).  Satu-satunya token lain yang dapat terjadi dalam ekspresi Python adalah nama, angka, dan string.  Dengan demikian, kode antara kawat gigi luar aksi, tampaknya, dapat diekspresikan melalui pengulangan <code>NAME | NUMBER | STRING | OP</code> <code>NAME | NUMBER | STRING | OP</code>  <code>NAME | NUMBER | STRING | OP</code> . </p><br><p>  Sayangnya, ini tidak akan berhasil karena <code>OP</code> juga cocok dengan kurung kurawal, dan karena penganalisa PEG selalu serakah, ini akan menangkap braket penutup, dan kita tidak akan pernah melihat akhir aksinya.  Oleh karena itu, kami menambahkan sedikit penyesuaian, memungkinkan tindakan untuk melempar kesalahan pilihan alternatif, mengembalikan Tidak ada.  Saya tidak tahu apakah ini merupakan kejadian standar pada parser PEG lainnya - saya membuat ini di tempat ketika saya harus menyelesaikan masalah mengenali tanda kurung penutup (bahkan tanpa pasangan bersarang).  Ini tampaknya bekerja dengan baik, dan saya pikir itu cocok dengan filosofi keseluruhan analisis PEG.  Ini dapat dianggap sebagai bentuk pandangan jauh ke depan yang khusus (yang akan saya bahas di bawah). </p><br><p>  Dengan menggunakan hack kecil ini, kita bisa membuat perbandingan pada kejatuhan <code>OP</code> pada kurung kurawal.  Maka perbandingan <code>stuff</code> dan <code>action</code> akan dimungkinkan. </p><br><p>  Dengan hal-hal ini, meta-grammar dapat diurai oleh bootstrap metaparser, dan generator dapat mengubahnya menjadi meta-parser baru yang dapat menganalisis sendiri.  Dan, yang penting, meta-parser baru masih dapat menguraikan meta-grammar yang sama.  Jika kita mengkompilasi meta-grammar dengan meta-compiler baru, hasilnya sama: ini membuktikan bahwa meta-parser yang dihasilkan bekerja dengan benar. </p><br><p>  Inilah tata bahasa meta tindakan lengkap.  Dia dapat menganalisis dirinya sendiri, karena dia tahu cara menggabungkan garis panjang: </p><br><pre> <code class="plaintext hljs">@subheader """ from grammar import Grammar, Rule, Alt from token import OP """ start: metas rules ENDMARKER { Grammar(rules, metas) } | rules ENDMARKER { Grammar(rules, []) } metas: meta metas { [meta] + metas } | meta { [meta] } meta: "@" NAME STRING NEWLINE { (name.string, eval(string.string)) } rules: rule rules { [rule] + rules } | rule { [rule] } rule: NAME ":" alts NEWLINE { Rule(name.string, alts) } alts: alt "|" alts { [alt] + alts } | alt { [alt] } alt: items action { Alt(items, action) } | items { Alt(items, None) } items: item items { [item] + items } | item { [item] } item: NAME { name.string } | STRING { string.string } action: "{" stuffs "}" { stuffs } stuffs: stuff stuffs { stuff + " " + stuffs } | stuff { stuff } stuff: "{" stuffs "}" { "{" + stuffs + "}" } | NAME { name.string } | NUMBER { number.string } | STRING { string.string } | OP { None if op.string in ("{", "}") else op.string }</code> </pre> <br><p>  Sekarang kami memiliki tata bahasa yang berfungsi, kami hampir siap untuk melakukan beberapa perbaikan. </p><br><p>  Tetapi pertama-tama Anda perlu berpikir sedikit: garis kosong!  Ternyata modul <code>tokenize</code> stdlib membuat token tambahan untuk melacak <code>tokenize</code> baris yang tidak signifikan (token <code>NL</code> ) dan komentar (token <code>COMMENT</code> ).  Alih-alih memasukkan mereka dalam tata bahasa (saya mencobanya, tidak ada banyak kesenangan!), Ada sepotong kode yang sangat sederhana yang bisa kita tambahkan ke kelas tokenizer kita untuk memfilternya.  Inilah metode <code>peek_token</code> disempurnakan: </p><br><pre> <code class="plaintext hljs"> def peek_token(self): if self.pos == len(self.tokens): while True: token = next(self.tokengen) if token.type in (NL, COMMENT): continue break self.tokens.append(token) self.report() return self.tokens[self.pos]</code> </pre> <br><p>  Ini sepenuhnya menghapus token <code>NL</code> dan <code>COMMENT</code> , jadi kita tidak perlu lagi khawatir tentang mereka dalam tata bahasa. </p><br><p>  Akhirnya, mari kita lakukan peningkatan pada tata bahasa meta!  Semuanya murni kosmetik: Saya tidak suka kalau dipaksa menulis semua alternatif dalam satu baris.  Tata bahasa meta yang saya tunjukkan di atas sebenarnya tidak menguraikan sendiri karena hal-hal seperti: </p><br><pre> <code class="plaintext hljs">start: metas rules ENDMARKER { Grammar(rules, metas) } | rules ENDMARKER { Grammar(rules, []) }</code> </pre> <br><p>  Ini disebabkan oleh fakta bahwa tokenizer membuat token <code>NEWLINE</code> di akhir baris pertama, dan pada saat ini meta-parser akan menganggap ini sebagai akhir dari aturan.  Selain itu, <code>NEWLINE</code> ini akan diikuti oleh token <code>INDENT</code> , karena baris berikutnya indentasi.  Sampai awal aturan berikutnya, token <code>DEDENT</code> juga akan hadir. </p><br><p>  Inilah cara mengatasinya.  Untuk memahami perilaku modul <code>tokenize</code> , kita dapat melihat urutan token yang dihasilkan untuk blok indentasi dengan menjalankan modul <code>tokenize</code> sebagai skrip dan memberikannya beberapa teks: </p><br><pre> <code class="plaintext hljs">$ python -m tokenize foo bar baz dah dum ^D</code> </pre> <br><p>  Kita melihat bahwa ini menghasilkan urutan token berikut (saya sedikit menyederhanakan keluaran dari kode di atas): </p><br><pre> <code class="plaintext hljs">NAME 'foo' NAME 'bar' NEWLINE INDENT NAME 'baz' NEWLINE NAME 'dah' NEWLINE DEDENT NAME 'dum' NEWLINE</code> </pre> <br><p>  Dengan demikian, sekelompok string yang dipilih ditunjukkan oleh <code>DEDENT</code> dan <code>DEDENT</code> .  Sekarang kita dapat menulis ulang aturan meta-grammar untuk <code>rule</code> sebagai berikut: </p><br><pre> <code class="plaintext hljs">rule: NAME ":" alts NEWLINE INDENT more_alts DEDENT { Rule(name.string, alts + more_alts) } | NAME ":" alts NEWLINE { Rule(name.string, alts) } | NAME ":" NEWLINE INDENT more_alts DEDENT { Rule(name.string, more_alts) } more_alts: "|" alts NEWLINE more_alts { alts + more_alts } | "|" alts NEWLINE { alts }</code> </pre> <br><p>  (Saya memecah tindakan menjadi garis sehingga mereka membaca secara normal dalam kolom teks yang sempit. Ini dimungkinkan karena tokenizer mengabaikan pemisah garis di dalam kurung kurawal yang sesuai.) </p><br><p>  Keindahan dari hal ini adalah kita bahkan tidak perlu mengubah generator: struktur data yang dibuat oleh tata bahasa yang ditingkatkan ini sama dengan sebelumnya.  Perhatikan juga opsi ketiga untuk <code>rule</code> : ini memungkinkan kita untuk menulis: </p><br><pre> <code class="plaintext hljs">start: | metas rules ENDMARKER { Grammar(rules, metas) } | rules ENDMARKER { Grammar(rules, []) }</code> </pre> <br><p>  bahwa beberapa mungkin merasa lebih bersih daripada versi yang saya tunjukkan sebelumnya.  Kedua bentuk itu mudah diselesaikan, jadi kami tidak perlu berdebat tentang gaya. </p><br><p>  Dalam posting berikutnya, saya akan menunjukkan bagaimana saya mengimplementasikan berbagai fungsi PEG, seperti elemen opsional, pengulangan, dan tooltips.  (Sejujurnya, saya berencana untuk membicarakannya di artikel ini, tetapi sudah terlalu besar. Jadi saya akan membaginya menjadi dua bagian.) </p><br><p>  Lisensi untuk artikel ini dan kode yang dikutip: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CC BY-NC-SA 4.0</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id471990/">https://habr.com/ru/post/id471990/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id471978/index.html">Kami tidak bisa mempercayai sistem AI yang dibangun di atas pembelajaran yang mendalam saja</a></li>
<li><a href="../id471980/index.html">Penipu telepon. Babak Empat, Final ...</a></li>
<li><a href="../id471982/index.html">Membahas masa depan PHP</a></li>
<li><a href="../id471986/index.html">Tata Bahasa PEG Rekursif Kiri</a></li>
<li><a href="../id471988/index.html">Menambahkan Tindakan ke Tata Bahasa PEG</a></li>
<li><a href="../id471992/index.html">Menerapkan fitur PEG yang tersisa</a></li>
<li><a href="../id471994/index.html">Bekerja pada PEG pada Core Developer Sprint</a></li>
<li><a href="../id471998/index.html">F # 10: Daftar</a></li>
<li><a href="../id472000/index.html">“Sangat penting bagi masyarakat untuk menetapkan standar”: Marchin Moskala tentang Kotlin</a></li>
<li><a href="../id472002/index.html">Pengemasan Paket dalam Gradle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>