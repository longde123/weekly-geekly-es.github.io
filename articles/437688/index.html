<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÇüèΩ üìõ ü§õüèª OpenSceneGraph: T√©cnicas b√°sicas de programaci√≥n üçª üêî üë∞üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 
 Este art√≠culo se centrar√° no tanto en los gr√°ficos como en c√≥mo debe organizarse la aplicaci√≥n que lo usa, teniendo en cuenta las carac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: T√©cnicas b√°sicas de programaci√≥n</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437688/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="imagen"><br><h1>  Introduccion </h1><br>  Este art√≠culo se centrar√° no tanto en los gr√°ficos como en c√≥mo debe organizarse la aplicaci√≥n que lo usa, teniendo en cuenta las caracter√≠sticas espec√≠ficas del motor OpenSceneGraph y el software que proporciona. <br><br>  No es ning√∫n secreto que la clave del √©xito de cualquier producto de software es una arquitectura bien dise√±ada que brinde la capacidad de mantener y expandir el c√≥digo escrito.  En este sentido, el motor que estamos considerando est√° en un nivel bastante alto, proporcionando al desarrollador un conjunto de herramientas muy amplio, que proporciona la construcci√≥n de una arquitectura modular flexible. <br><br>  Este art√≠culo es bastante extenso e incluye una descripci√≥n general de las diversas herramientas y t√©cnicas (patrones de dise√±o, si lo desea) proporcionadas por el motor del desarrollador.  Todas las secciones del art√≠culo se proporcionan con ejemplos, cuyo c√≥digo se puede tomar en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mi repositorio</a> . <br><a name="habracut"></a><br><h1>  1. Opciones de l√≠nea de comando de an√°lisis </h1><br>  En C / C ++, los par√°metros de la l√≠nea de comandos se pasan a trav√©s de los argumentos a la funci√≥n main ().  En ejemplos anteriores, marcamos cuidadosamente estos par√°metros como no utilizados, ahora los usaremos para decirle a nuestro programa algunos datos cuando comience. <br><br>  OSG tiene herramientas de an√°lisis de l√≠nea de comandos incorporadas. <br><br>  Crea el siguiente ejemplo <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de l√≠nea de comando</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif // MAIN_H</span></span></span></span></code> </pre> <br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { osg::ArgumentParser args(&amp;argc, argv); std::string filename; args.read(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"--model"</span></span></span><span class="hljs-meta">, filename); osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; root = osgDB::readNodeFile(filename); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Establecer los par√°metros de inicio del programa en QtCreator <br><br><img src="https://habrastorage.org/webt/41/le/8p/41le8pjjdv2q-in3idhgnpe6-ao.png"><br><br>  Al ejecutar el programa para su ejecuci√≥n, obtenemos el resultado (modelo de cami√≥n <a href="">tomado del mismo OpenSceneGraph-Data</a> ) <br><br><img src="https://habrastorage.org/webt/t-/_o/bb/t-_obbiwlzwuax1e336kqd6tosy.png"><br><br>  Ahora veamos un ejemplo l√≠nea por l√≠nea <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">ArgumentParser </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">args</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;argc, argv)</span></span></span></span>;</code> </pre><br>  crea una instancia de la clase de analizador de l√≠nea de comando osg :: ArgumentParser.  Cuando se crea, el constructor de clase pasa los argumentos aceptados por la funci√≥n main () del sistema operativo. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> filename; args.read(<span class="hljs-string"><span class="hljs-string">"--model"</span></span>, filename);</code> </pre><br>  analizamos los argumentos, es decir, buscamos la clave "‚Äìmodelo" entre ellos, colocando su valor en el nombre del archivo de cadena.  Por lo tanto, utilizando esta clave, transferimos el nombre del archivo con un modelo tridimensional al programa.  Luego cargamos este modelo y lo mostramos <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; root = osgDB::readNodeFile(filename); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br>  El m√©todo read () de la clase osg :: ArgumentParser tiene muchas sobrecargas, lo que le permite leer no solo valores de cadena desde la l√≠nea de comando, sino tambi√©n enteros, n√∫meros de punto flotante, vectores, etc.  Por ejemplo, puede leer un determinado par√°metro de tipo float <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> size = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; args.read(<span class="hljs-string"><span class="hljs-string">"--size"</span></span>, size);</code> </pre><br>  Si este par√°metro no se muestra en la l√≠nea de comando, su valor permanecer√° como estaba despu√©s de que se inicializ√≥ la variable de tama√±o. <br><br><h1>  2. Mecanismo de notificaci√≥n y registro. </h1><br>  OpenSceneGraph tiene un mecanismo de notificaci√≥n que le permite mostrar mensajes de depuraci√≥n durante el proceso de representaci√≥n, as√≠ como tambi√©n iniciado por el desarrollador.  Esta es una gran ayuda al rastrear y depurar un programa.  El sistema de notificaci√≥n OSG admite la salida de informaci√≥n de diagn√≥stico (errores, advertencias, notificaciones) en el nivel central del motor y sus complementos.  El desarrollador puede mostrar un mensaje de diagn√≥stico durante la operaci√≥n del programa utilizando la funci√≥n osg :: notify (). <br><br>  Esta funci√≥n funciona como un flujo de salida est√°ndar de la biblioteca C ++ est√°ndar a trav√©s de la sobrecarga del operador &lt;&lt;.  Como argumento, toma el nivel de mensaje: SIEMPRE, FATAL, WARN, NOTICE, INFO, DEBUG_INFO y DEBUG_FP.  Por ejemplo <br><br><pre> <code class="cpp hljs">osg::notify(osg::WARN) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Some warning message"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  muestra una advertencia con texto definido por el usuario. <br><br>  Las notificaciones OSG pueden contener informaci√≥n importante sobre el estado del programa, extensiones del subsistema de gr√°ficos de la computadora, posibles problemas con el motor. <br><br>  En algunos casos, es necesario enviar estos datos no a la consola, sino poder redirigir esta salida a un archivo (en forma de registro) o a cualquier otra interfaz, incluido un widget gr√°fico.  El motor contiene una clase especial osg :: NotifyHandler que proporciona la redirecci√≥n de notificaciones a la secuencia de salida que necesita el desarrollador. <br><br>  Usando un ejemplo simple, considere c√≥mo puede redirigir la salida de notificaciones, por ejemplo, a un archivo de registro de texto.  Escribe el siguiente c√≥digo <br><br><div class="spoiler">  <b class="spoiler_title">Notificar ejemplo</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #include &lt;fstream&gt; #endif // MAIN_H</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> class LogFileHandler : public osg::NotifyHandler { public: LogFileHandler(const std::string &amp;file) { _log.open(file.c_str()); } virtual ~LogFileHandler() { _log.close(); } virtual void notify(osg::NotifySeverity severity, const char *msg) { _log </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; msg; } protected: std::ofstream _log; }; int main(int argc, char *argv[]) { osg::setNotifyLevel(osg::INFO); osg::setNotifyHandler(new LogFileHandler("../logs/log.txt")); osg::ArgumentParser args(&amp;argc, argv); osg::ref_ptr&lt;osg::Node&gt; root = osgDB::readNodeFiles(args); if (!root) { OSG_FATAL &lt;&lt; args.getApplicationName() &lt;&lt; ": No data loaded." &lt;&lt; std::endl; return -1; } osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Para redirigir la salida, escribimos la clase LogFileHandler, que es la sucesora de osg :: NotifyHandler.  El constructor y el destructor de esta clase controlan la apertura y el cierre de la secuencia de salida _log con la que est√° asociado el archivo de texto.  El m√©todo notify () es un m√©todo de clase base similar que redefinimos para enviar a las notificaciones de archivo enviadas por OSG durante la operaci√≥n a trav√©s del par√°metro msg. <br><br>  <strong>Class LogFileHandler</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LogFileHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osg::NotifyHandler { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: LogFileHandler(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;file) { _log.open(file.c_str()); } <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~LogFileHandler() { _log.close(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::NotifySeverity severity, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *msg)</span></span></span><span class="hljs-function"> </span></span>{ _log &lt;&lt; msg; } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ofstream _log; };</code> </pre><br>  Luego, en el programa principal, realice las configuraciones necesarias <br><br><pre> <code class="cpp hljs">osg::setNotifyLevel(osg::INFO);</code> </pre><br>  establezca el nivel de notificaciones INFO, es decir, la salida al registro de toda la informaci√≥n sobre el funcionamiento del motor, incluidas las notificaciones actuales de funcionamiento normal. <br><br><pre> <code class="cpp hljs">osg::setNotifyHandler(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LogFileHandler(<span class="hljs-string"><span class="hljs-string">"../logs/log.txt"</span></span>));</code> </pre><br>  Instale el controlador de notificaciones.  A continuaci√≥n, procesamos argumentos de l√≠nea de comando en los que se pasan las rutas a los modelos cargados <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">ArgumentParser </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">args</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;argc, argv)</span></span></span></span>; osg::ref_ptr&lt;osg::Node&gt; root = osgDB::readNodeFiles(args); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!root) { OSG_FATAL &lt;&lt; args.getApplicationName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">": No data loaded."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre><br>  Al mismo tiempo, manejamos la situaci√≥n de falta de datos en la l√≠nea de comando, mostrando un mensaje en el modo manual de registro utilizando la macro OSG_FATAL.  Ejecute el programa con los siguientes argumentos <br><br><img src="https://habrastorage.org/webt/mc/h4/so/mch4sot5pfjjpq9vb2dlolnjllm.png"><br><br>  obtener salida a un archivo de registro como este <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de registro OSG</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">Opened DynamicLibrary osgPlugins-3.7.0/mingw_osgdb_osgd.dll CullSettings::readEnvironmentalVariables() CullSettings::readEnvironmentalVariables() Opened DynamicLibrary osgPlugins-3.7.0/mingw_osgdb_deprecated_osgd.dll OSGReaderWriter wrappers loaded OK CullSettings::readEnvironmentalVariables() void StateSet::setGlobalDefaults() void StateSet::setGlobalDefaults() ShaderPipeline disabled. StateSet::setGlobalDefaults() Setting up GL2 compatible shaders CullSettings::readEnvironmentalVariables() CullSettings::readEnvironmentalVariables() CullSettings::readEnvironmentalVariables() CullSettings::readEnvironmentalVariables() ShaderComposer::ShaderComposer() 0xa5ce8f0 CullSettings::readEnvironmentalVariables() ShaderComposer::ShaderComposer() 0xa5ce330 View::setSceneData() Reusing existing scene0xa514220 CameraManipulator::computeHomePosition(0, 0) boundingSphere.center() = (-6.40034 1.96225 0.000795364) boundingSphere.radius() = 16.6002 CameraManipulator::computeHomePosition(0xa52f138, 0) boundingSphere.center() = (-6.40034 1.96225 0.000795364) boundingSphere.radius() = 16.6002 Viewer::realize() - No valid contexts found, setting up view across all screens. Applying osgViewer::ViewConfig : AcrossAllScreens . . . . ShaderComposer::~ShaderComposer() 0xa5ce330 ShaderComposer::~ShaderComposer() 0xa5ce8f0 ShaderComposer::~ShaderComposer() 0xa5d6228 close(0x1)0xa5d3e50 close(0)0xa5d3e50 ContextData::unregisterGraphicsContext 0xa5d3e50 DatabasePager::RequestQueue::~RequestQueue() Destructing queue. DatabasePager::RequestQueue::~RequestQueue() Destructing queue. DatabasePager::RequestQueue::~RequestQueue() Destructing queue. DatabasePager::RequestQueue::~RequestQueue() Destructing queue. ShaderComposer::~ShaderComposer() 0xa5de4e0 close(0x1)0xa5ddba0 close(0)0xa5ddba0 ContextData::unregisterGraphicsContext 0xa5ddba0 Done destructing osg::View DatabasePager::RequestQueue::~RequestQueue() Destructing queue. DatabasePager::RequestQueue::~RequestQueue() Destructing queue. DatabasePager::RequestQueue::~RequestQueue() Destructing queue. DatabasePager::RequestQueue::~RequestQueue() Destructing queue. Closing DynamicLibrary osgPlugins-3.7.0/mingw_osgdb_osgd.dll Closing DynamicLibrary osgPlugins-3.7.0/mingw_osgdb_deprecated_osgd.dll</code> </pre><br></div></div><br>  No importa que en este momento esta informaci√≥n le parezca in√∫til, en el futuro, tal conclusi√≥n puede ayudar a depurar errores en su programa. <br><br>  De manera predeterminada, OSG env√≠a mensajes a la salida est√°ndar std :: cout y mensajes de error a la secuencia std :: cerr.  Sin embargo, al anular el controlador de notificaciones, como se muestra en el ejemplo, esta salida se puede redirigir a cualquier flujo de salida, incluidos los elementos de la GUI. <br><br>  Tenga en cuenta que al establecer un alto nivel de notificaciones (por ejemplo, FATAL), el sistema ignora todas las notificaciones de un nivel inferior.  Por ejemplo, en un caso similar <br><br><pre> <code class="cpp hljs">osg::setNotifyLevel(osg::FATAL); . . . osg::notify(osg::WARN) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Some message."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  simplemente no se mostrar√° un mensaje personalizado. <br><br><h1>  3. Intercepci√≥n de atributos geom√©tricos. </h1><br>  La clase osg :: Geometry gestiona un conjunto de datos que describen v√©rtices y muestra una malla poligonal utilizando un conjunto ordenado de primitivas.  Sin embargo, esta clase no tiene idea sobre elementos de la topolog√≠a del modelo como caras, aristas y la relaci√≥n entre ellos.  Este matiz impide la implementaci√≥n de cosas como mover ciertas caras, por ejemplo, al animar modelos.  OSG no admite actualmente esta funcionalidad. <br><br>  Sin embargo, el motor implementa una serie de functores que le permiten volver a leer los atributos de geometr√≠a de cualquier objeto y usarlos para modelar la topolog√≠a de la malla poligonal.  En C ++, un functor es una construcci√≥n que le permite usar un objeto como funci√≥n. <br><br>  La clase osg :: Drawable proporciona al desarrollador cuatro tipos de functores: <br><br><ol><li>  osg :: Drawable :: AttributeFunctor - lee los atributos de los v√©rtices como una matriz de punteros.  Tiene varios m√©todos virtuales para aplicar atributos de v√©rtice de diferentes tipos de datos.  Para usar este functor, debe describir la clase y anular uno o m√°s de sus m√©todos, dentro de los cuales se realizan las acciones requeridas por el desarrollador <br></li></ol><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( osg::Drawable::AttributeType type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size, osg::Vec3* ptr )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  3-     ptr. //      }</span></span></code> </pre><br><ol><li>  osg :: Drawable :: ConstAttributeFunctor - versi√≥n de solo lectura del functor anterior: se pasa un puntero a una matriz de vectores como par√°metro constante <br></li><li>  osg :: PrimitiveFunctor - imita el proceso de renderizar objetos OpenGL.  Con el pretexto de representar un objeto, se llaman los m√©todos de funci√≥n anulados por el desarrollador.  Este functor tiene dos subclases de plantilla importantes: osg :: TemplatePrimitiveFunctor &lt;&gt; y osg :: TriangleFunctor &lt;&gt;.  Estas clases reciben v√©rtices primitivos como par√°metros y los pasan a m√©todos de usuario utilizando el operador operator (). <br></li><li>  osg :: PrimitiveIndexFunctor: realiza las mismas acciones que el functor anterior, pero acepta los √≠ndices de v√©rtice de la primitiva como par√°metro. <br></li></ol><br>  Las clases derivadas de osg :: Drawable, como osg :: ShapeDrawable y osg :: Geometry, tienen un m√©todo accept () que le permite aplicar varios functores. <br><br><h1>  4. Ejemplo de uso del functor primitivo </h1><br>  Ilustramos la funcionalidad descrita utilizando el ejemplo de recopilaci√≥n de informaci√≥n sobre caras triangulares y puntos de cierta geometr√≠a que determinamos previamente. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo Functor</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geode&gt; #include &lt;osg/Geometry&gt; #include &lt;osg/TriangleFunctor&gt; #include &lt;osgViewer/Viewer&gt; #include &lt;iostream&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> std::string vec2str(const osg::Vec3 &amp;v) { std::string tmp = std::to_string(vx()); tmp += </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" "</span></span></span><span class="hljs-meta">; tmp += std::to_string(vy()); tmp += </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" "</span></span></span><span class="hljs-meta">; tmp += std::to_string(vz()); return tmp; } struct FaceCollector { void operator()(const osg::Vec3 &amp;v1, const osg::Vec3 &amp;v2, const osg::Vec3 &amp;v3) { std::cout </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; "Face vertices: " &lt;&lt; vec2str(v1) &lt;&lt; "; " &lt;&lt; vec2str(v2) &lt;&lt; "; " &lt;&lt; vec2str(v3) &lt;&lt; std::endl; } }; int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 0.0f) ); vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 1.0f) ); vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 0.0f) ); vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 1.5f) ); vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 0.0f) ); vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 1.0f) ); vertices-&gt;push_back( osg::Vec3(3.0f, 0.0f, 0.0f) ); vertices-&gt;push_back( osg::Vec3(3.0f, 0.0f, 1.5f) ); vertices-&gt;push_back( osg::Vec3(4.0f, 0.0f, 0.0f) ); vertices-&gt;push_back( osg::Vec3(4.0f, 0.0f, 1.0f) ); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back( osg::Vec3(0.0f, -1.0f, 0.0f) ); osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; geom-&gt;setVertexArray(vertices.get()); geom-&gt;setNormalArray(normals.get()); geom-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); geom-&gt;addPrimitiveSet(new osg::DrawArrays(GL_QUAD_STRIP, 0, 10)); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(geom.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); osg::TriangleFunctor&lt;FaceCollector&gt; functor; geom-&gt;accept(functor); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Omitiendo el proceso de creaci√≥n de geometr√≠a considerado por nosotros muchas veces, prestemos atenci√≥n a lo siguiente.  Definimos una estructura FaceCollector para la cual redefinimos operator () de la siguiente manera <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FaceCollector</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osg::Vec3 &amp;v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osg::Vec3 &amp;v2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osg::Vec3 &amp;v3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Face vertices: "</span></span> &lt;&lt; vec2str(v1) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"; "</span></span> &lt;&lt; vec2str(v2) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"; "</span></span> &lt;&lt; vec2str(v3) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } };</code> </pre><br>  Este operador, cuando se lo llama, mostrar√° las coordenadas de los tres v√©rtices que le transmite el motor.  La funci√≥n vec2str es necesaria para traducir los componentes del vector osg :: Vec3 a std :: string.  Para llamar al functor, cree una instancia de √©l y p√°selo al objeto de geometr√≠a a trav√©s del m√©todo accept () <br><br><pre> <code class="cpp hljs">osg::TriangleFunctor&lt;FaceCollector&gt; functor; geom-&gt;accept(functor);</code> </pre><br>  Esta llamada, como se mencion√≥ anteriormente, imita la representaci√≥n de la geometr√≠a, reemplazando el dibujo en s√≠ mismo al llamar a un m√©todo de funci√≥n anulada.  En este caso, se llamar√° durante el "dibujo" de cada uno de los tri√°ngulos que componen la geometr√≠a del ejemplo. <br><br>  En la pantalla obtenemos tal geometr√≠a <br><br><img src="https://habrastorage.org/webt/ai/-a/6v/ai-a6vj4eeubetgk0bpicmjbgfm.png"><br><br>  y tal escape a la consola <br><br><pre> <code class="plaintext hljs">Face vertices: 0.000000 0.000000 0.000000; 0.000000 0.000000 1.000000; 1.000000 0.000000 0.000000 Face vertices: 0.000000 0.000000 1.000000; 1.000000 0.000000 1.500000; 1.000000 0.000000 0.000000 Face vertices: 1.000000 0.000000 0.000000; 1.000000 0.000000 1.500000; 2.000000 0.000000 0.000000 Face vertices: 1.000000 0.000000 1.500000; 2.000000 0.000000 1.000000; 2.000000 0.000000 0.000000 Face vertices: 2.000000 0.000000 0.000000; 2.000000 0.000000 1.000000; 3.000000 0.000000 0.000000 Face vertices: 2.000000 0.000000 1.000000; 3.000000 0.000000 1.500000; 3.000000 0.000000 0.000000 Face vertices: 3.000000 0.000000 0.000000; 3.000000 0.000000 1.500000; 4.000000 0.000000 0.000000 Face vertices: 3.000000 0.000000 1.500000; 4.000000 0.000000 1.000000; 4.000000 0.000000 0.000000</code> </pre><br>  De hecho, cuando se llama a geom-&gt; accept (...), los tri√°ngulos no se procesan, las llamadas de OpenGL se simulan y, en lugar de ellas, los datos sobre los v√©rtices del tri√°ngulo, cuya representaci√≥n se simula <br><br><img src="https://habrastorage.org/webt/gx/gp/il/gxgpilewn7pw26w9tdy-e28ypds.png"><br><br>  La clase osg :: TemplatePrimitiveFunctor recopila datos no solo sobre tri√°ngulos, sino tambi√©n sobre cualquier otra primitiva OpenGL.  Para implementar el procesamiento de estos datos, debe anular los siguientes operadores en el argumento de plantilla <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   void operator()( const osg::Vec3&amp;, bool ); //   void operator()( const osg::Vec3&amp;, const osg::Vec3&amp;, bool ); //   void operator()( const osg::Vec3&amp;, const osg::Vec3&amp;, const osg::Vec3&amp;, bool ); //   void operator()( const osg::Vec3&amp;, const osg::Vec3&amp;, const osg::Vec3&amp;, const osg::Vec3&amp;, bool );</span></span></code> </pre><br><br><h1>  5. El patr√≥n de visitante </h1><br>  El patr√≥n de visitante se utiliza para acceder a operaciones para cambiar los elementos del gr√°fico de escena sin cambiar las clases de estos elementos.  La clase visitante implementa todas las funciones virtuales relevantes para aplicarlas a varios tipos de elementos a trav√©s de un mecanismo de despacho dual.  Con este mecanismo, el desarrollador puede crear su propia instancia de visitante mediante la implementaci√≥n de la funcionalidad que necesita con la ayuda de operadores especiales y vincular al visitante a varios tipos de elementos de gr√°ficos de escena sobre la marcha, sin cambiar la funcionalidad de los elementos mismos.  Esta es una excelente manera de extender la funcionalidad de un elemento sin definir subclases de estos elementos. <br><br>  Para implementar este mecanismo en OSG, se define la clase osg :: NodeVisitor.  La clase heredada de osg :: NodeVisitor se mueve alrededor del gr√°fico de escena, visita cada nodo y le aplica las operaciones definidas por el desarrollador.  Esta es la clase principal utilizada para intervenir en el proceso de actualizaci√≥n de nodos y recorte de nodos invisibles, as√≠ como tambi√©n para aplicar algunas otras operaciones relacionadas con la modificaci√≥n de la geometr√≠a de los nodos en la escena, como osgUtil :: SmoothingVisitor, osgUtil :: Simplifier y osgUtil :: TriStripVisitor. <br><br>  Para subclasificar al visitante, debemos anular uno o m√°s m√©todos de aplicaci√≥n () sobrecargados virtuales proporcionados por la clase base osg :: NodeVisitor.  La mayor√≠a de los principales tipos de nodos OSG tienen estos m√©todos.  El visitante llamar√° autom√°ticamente al m√©todo apply () para cada uno de los nodos visitados al recorrer el gr√°fico de la escena.  El desarrollador anula el m√©todo apply () para cada uno de los tipos de nodo que necesita. <br><br>  En la implementaci√≥n del m√©todo apply (), el desarrollador, en el momento apropiado, debe llamar al m√©todo traverse () de la clase base osg :: NodeVisitor.  Esto inicia la transici√≥n del visitante al siguiente nodo, ya sea un hijo o un vecino en el nivel de jerarqu√≠a, si el nodo actual no tiene ning√∫n nodo hijo al que se pueda hacer la transici√≥n.  La ausencia de una llamada a traverse () significa detener el recorrido del gr√°fico de escena y se ignora el resto del gr√°fico de escena. <br><br>  Las sobrecargas del m√©todo apply () tienen formatos unificados <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( osg::Node&amp; )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( osg::Geode&amp; )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( osg::Group&amp; )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( osg::Transform&amp; )</span></span></span></span>;</code> </pre><br>  Para omitir el subgrafo del nodo actual para el objeto visitante, debe establecer el modo de rastreo, por ejemplo, <br><br><pre> <code class="cpp hljs">ExampleVisitor visitor; visitor-&gt;setTraversalMode( osg::NodeVisitor::TRAVERSE_ALL_CHILDREN ); node-&gt;accept( visitor );</code> </pre><br>  El modo de derivaci√≥n lo establecen varios enumeradores <br><br><ol><li>  TRAVERSE_ALL_CHILDREN: se mueve por todos los nodos secundarios. <br></li><li>  TRAVERSE_PARENTS: pasa del nodo actual sin llegar al nodo ra√≠z <br></li><li>  TRAVERSE_ACTIVE_CHILDREN: omite los nodos exclusivamente activos, es decir, aquellos cuya visibilidad se activa a trav√©s del nodo osg :: Switch. <br></li></ol><br><br><h1>  6. An√°lisis de la estructura del cessna ardiente. </h1><br>  El desarrollador siempre puede analizar esa parte del gr√°fico de escena que genera el modelo cargado desde el archivo. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo Functor</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #include &lt;iostream&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class InfoVisitor : public osg::NodeVisitor { public: InfoVisitor() : _level(0) { setTraversalMode(osg::NodeVisitor::TRAVERSE_ALL_CHILDREN); } std::string spaces() { return std::string(_level * 2, ' '); } virtual void apply(osg::Node &amp;node); virtual void apply(osg::Geode &amp;geode); protected: unsigned int _level; }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void InfoVisitor::apply(osg::Node &amp;node) { std::cout &lt;&lt; spaces() &lt;&lt; node.libraryName() &lt;&lt; "::" &lt;&lt; node.className() &lt;&lt; std::endl; _level++; traverse(node); _level--; } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void InfoVisitor::apply(osg::Geode &amp;geode) { std::cout &lt;&lt; spaces() &lt;&lt; geode.libraryName() &lt;&lt; "::" &lt;&lt; geode.className() &lt;&lt; std::endl; _level++; for (unsigned int i = 0; i &lt; geode.getNumDrawables(); ++i) { osg::Drawable *drawable = geode.getDrawable(i); std::cout &lt;&lt; spaces() &lt;&lt; drawable-&gt;libraryName() &lt;&lt; "::" &lt;&lt; drawable-&gt;className() &lt;&lt; std::endl; } traverse(geode); _level--; } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { osg::ArgumentParser args(&amp;argc, argv); osg::ref_ptr&lt;osg::Node&gt; root = osgDB::readNodeFiles(args); if (!root.valid()) { OSG_FATAL &lt;&lt; args.getApplicationName() &lt;&lt; ": No data leaded. " &lt;&lt; std::endl; return -1; } InfoVisitor infoVisitor; root-&gt;accept(infoVisitor); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Creamos la clase InfoVisitor, heredando de osg :: NodeVisitor <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InfoVisitor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osg::NodeVisitor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: InfoVisitor() : _level(<span class="hljs-number"><span class="hljs-number">0</span></span>) { setTraversalMode(osg::NodeVisitor::TRAVERSE_ALL_CHILDREN); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spaces</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(_level * <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::Node &amp;node)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::Geode &amp;geode)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _level; };</code> </pre><br>  La propiedad _level protegida apuntar√° al nivel del gr√°fico de escena en el que se encuentra actualmente nuestra clase de visitante.  En el constructor, inicialice el contador de nivel y establezca el modo de recorrido de nodo para evitar todos los nodos secundarios. <br><br>  Ahora redefina los m√©todos apply () para nodos <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> InfoVisitor::apply(osg::Node &amp;node) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; spaces() &lt;&lt; node.libraryName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"::"</span></span> &lt;&lt; node.className() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; _level++; traverse(node); _level--; }</code> </pre><br>  Aqu√≠ mostraremos el tipo del nodo actual.  El m√©todo libraryName () para el nodo muestra el nombre de la biblioteca OSG donde se implementa este nodo, y el m√©todo className muestra el nombre de la clase de nodo.  Estos m√©todos se implementan mediante el uso de macros en el c√≥digo de las bibliotecas OSG. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; spaces() &lt;&lt; node.libraryName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"::"</span></span> &lt;&lt; node.className() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  Despu√©s de eso, aumentamos el contador de nivel de gr√°fico y llamamos al m√©todo traverse (), iniciando una transici√≥n a un nivel superior, al nodo hijo.  Despu√©s de regresar de traverse (), nuevamente disminuimos el valor del contador.  Es f√°cil adivinar que traverse () inicia una llamada repetida al m√©todo apply (), traverse repetido () ya para un subgr√°fico que comienza desde el nodo actual.  Obtenemos la ejecuci√≥n recursiva de visitantes hasta llegar a los nodos finales del gr√°fico de escena. <br><br>  Para un nodo final de tipo osg :: Geode, se anula su sobrecarga del m√©todo apply () <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> InfoVisitor::apply(osg::Geode &amp;geode) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; spaces() &lt;&lt; geode.libraryName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"::"</span></span> &lt;&lt; geode.className() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; _level++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; geode.getNumDrawables(); ++i) { osg::Drawable *drawable = geode.getDrawable(i); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; spaces() &lt;&lt; drawable-&gt;libraryName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"::"</span></span> &lt;&lt; drawable-&gt;className() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } traverse(geode); _level--; }</code> </pre><br>  con c√≥digo de trabajo similar, excepto que mostramos datos en todos los objetos geom√©tricos adjuntos al nodo geom√©trico actual <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; geode.getNumDrawables(); ++i) { osg::Drawable *drawable = geode.getDrawable(i); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; spaces() &lt;&lt; drawable-&gt;libraryName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"::"</span></span> &lt;&lt; drawable-&gt;className() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre><br>  En la funci√≥n main (), procesamos argumentos de l√≠nea de comando a trav√©s de los cuales pasamos una lista de modelos cargados en la escena y formamos la escena <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">ArgumentParser </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">args</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;argc, argv)</span></span></span></span>; osg::ref_ptr&lt;osg::Node&gt; root = osgDB::readNodeFiles(args); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!root.valid()) { OSG_FATAL &lt;&lt; args.getApplicationName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">": No data leaded. "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre><br>  Al mismo tiempo, procesamos errores relacionados con la ausencia de nombres de archivo de modelo en la l√≠nea de comandos.  Ahora creamos una clase de visitante y la pasamos al gr√°fico de escena para ejecutar <br><br><pre> <code class="cpp hljs">InfoVisitor infoVisitor; root-&gt;accept(infoVisitor);</code> </pre><br>  Los siguientes son los pasos para iniciar el visor, que ya hemos hecho muchas veces.  Despu√©s de comenzar el programa con par√°metros <br><br><pre> <code class="bash hljs">$ visitor ../data/cessnafire.osg</code> </pre><br>  veremos la siguiente salida a la consola <br><br><pre> <code class="plaintext hljs">osg::Group osg::MatrixTransform osg::Geode osg::Geometry osg::Geometry osg::MatrixTransform osgParticle::ModularEmitter osgParticle::ModularEmitter osgParticle::ParticleSystemUpdater osg::Geode osgParticle::ParticleSystem osgParticle::ParticleSystem osgParticle::ParticleSystem osgParticle::ParticleSystem</code> </pre><br>  De hecho, tenemos un √°rbol completo de la escena cargada.  Disculpe, ¬ød√≥nde hay tantos nodos?  Todo es muy simple: los modelos del formato * .osg en s√≠ mismos son contenedores que almacenan no solo la geometr√≠a del modelo, sino tambi√©n otra informaci√≥n sobre su estructura en forma de un subgr√°fico de la escena OSG.  La geometr√≠a del modelo, las transformaciones, los efectos de part√≠culas que producen humo y llamas son todos nodos del gr√°fico de escena OSG.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cualquier escena puede descargarse desde * .osg o descargarse desde el visor al formato * .osg. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este es un ejemplo simple de aplicar la mec√°nica del visitante. </font><font style="vertical-align: inherit;">De hecho, dentro de los visitantes, puede realizar muchas operaciones para modificar los nodos durante la ejecuci√≥n del programa.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7. Controlar el comportamiento de los nodos en el gr√°fico de escena anulando el m√©todo traverse () </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una forma importante de trabajar con OSG es anular el m√©todo traverse (). Este m√©todo se llama cada vez que se dibuja un marco. Aceptan un par√°metro de tipo osg :: NodeVisitor y que informa qu√© paso del gr√°fico de escena se est√° realizando actualmente (actualizaci√≥n, procesamiento de eventos o recorte). La mayor√≠a de los hosts OSG anulan este m√©todo para implementar su funcionalidad. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debe recordarse que anular el m√©todo traverse () puede ser peligroso, ya que afecta el proceso de atravesar el gr√°fico de la escena y puede conducir a una visualizaci√≥n incorrecta de la escena. Tambi√©n es inconveniente si desea agregar una nueva funcionalidad a varios tipos de nodos. En este caso, se utilizan devoluciones de llamada de nodo, cuya conversaci√≥n se reducir√° un poco.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ya sabemos que el nodo osg :: Switch puede controlar la visualizaci√≥n de sus nodos secundarios, incluida la visualizaci√≥n de algunos nodos y desactivar la visualizaci√≥n de otros. </font><font style="vertical-align: inherit;">Pero √©l no sabe c√≥mo hacer esto autom√°ticamente, por lo que crearemos un nuevo nodo basado en el antiguo, que cambiar√° entre nodos secundarios en diferentes puntos en el tiempo, de acuerdo con el valor del contador interno.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo de animswitch</font></font></b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Switch&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class AnimatingSwitch : public osg::Switch { public: AnimatingSwitch() : osg::Switch(), _count(0) {} AnimatingSwitch(const AnimatingSwitch &amp;copy, const osg::CopyOp &amp;copyop = osg::CopyOp::SHALLOW_COPY) : osg::Switch(copy, copyop), _count(copy._count) {} META_Node(osg, AnimatingSwitch); virtual void traverse(osg::NodeVisitor &amp;nv); protected: unsigned int _count; }; void AnimatingSwitch::traverse(osg::NodeVisitor &amp;nv) { if (!((++_count) % 60) ) { setValue(0, !getValue(0)); setValue(1, !getValue(1)); } osg::Switch::traverse(nv); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Node&gt; model1 = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile("../data/cessnafire.osg"); osg::ref_ptr&lt;AnimatingSwitch&gt; root = new AnimatingSwitch; root-&gt;addChild(model1.get(), true); root-&gt;addChild(model2.get(), false); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Echemos un vistazo a este ejemplo. </font><font style="vertical-align: inherit;">Estamos creando una nueva clase AnimatingSwitch que hereda de osg :: Switch.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnimatingSwitch</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osg::Switch { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: AnimatingSwitch() : osg::Switch(), _count(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} AnimatingSwitch(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AnimatingSwitch &amp;copy, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> osg::CopyOp &amp;copyop = osg::CopyOp::SHALLOW_COPY) : osg::Switch(copy, copyop), _count(copy._count) {} META_Node(osg, AnimatingSwitch); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::NodeVisitor &amp;nv)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _count; }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AnimatingSwitch::traverse(osg::NodeVisitor &amp;nv) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!((++_count) % <span class="hljs-number"><span class="hljs-number">60</span></span>) ) { setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, !getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, !getValue(<span class="hljs-number"><span class="hljs-number">1</span></span>)); } osg::Switch::traverse(nv); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Esta clase contiene el constructor predeterminado. </font></font><br><br><pre> <code class="cpp hljs">AnimatingSwitch() : osg::Switch(), _count(<span class="hljs-number"><span class="hljs-number">0</span></span>) {}</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y constructor para copiar, creado de acuerdo con los requisitos de OSG </font></font><br><br><pre> <code class="cpp hljs">AnimatingSwitch(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AnimatingSwitch &amp;copy, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> osg::CopyOp &amp;copyop = osg::CopyOp::SHALLOW_COPY) : osg::Switch(copy, copyop), _count(copy._count) {}</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El constructor para copiar debe contener como par√°metros: una referencia constante a la instancia de clase que se copiar√° y el par√°metro osg :: CopyOp que especifica la configuraci√≥n de copia de la clase. </font><font style="vertical-align: inherit;">Siguen letras bastante extra√±as</font></font><br><br><pre> <code class="cpp hljs">META_Node(osg, AnimatingSwitch);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta es una macro que forma la estructura necesaria para el descendiente de una clase derivada de osg :: Node. </font><font style="vertical-align: inherit;">Hasta que le demos importancia a esta macro, es importante que est√© presente al heredar de osg :: Switch al definir todas las clases descendientes. </font><font style="vertical-align: inherit;">La clase contiene el campo protegido _count, el contador en funci√≥n del cual cambiamos. </font><font style="vertical-align: inherit;">Implementamos el cambio al anular el m√©todo traverse ()</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AnimatingSwitch::traverse(osg::NodeVisitor &amp;nv) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!((++_count) % <span class="hljs-number"><span class="hljs-number">60</span></span>) ) { setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, !getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, !getValue(<span class="hljs-number"><span class="hljs-number">1</span></span>)); } osg::Switch::traverse(nv); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cambiar el estado de visualizaci√≥n de los nodos ocurrir√° cada vez que el valor del contador (incrementando cada llamada al m√©todo) es un m√∫ltiplo de 60. Compilamos el ejemplo y lo ejecutamos </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z5/fl/2u/z5fl2uhbnzxafceoro_wbga-pk4.gif"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que el m√©todo traverse () se redefine constantemente para varios tipos de nodos, deber√≠a proporcionar un mecanismo para obtener matrices de transformaci√≥n y estados de representaci√≥n para su uso posterior por su algoritmo sobrecargado. </font><font style="vertical-align: inherit;">El par√°metro de entrada osg :: NodeVisitor es la clave para varias operaciones con nodos. </font><font style="vertical-align: inherit;">En particular, indica el tipo de recorrido actual del gr√°fico de escena, como la actualizaci√≥n, el procesamiento de eventos y el recorte de caras invisibles. </font><font style="vertical-align: inherit;">Los dos primeros est√°n relacionados con devoluciones de llamada de nodos y se tendr√°n en cuenta al estudiar la animaci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El paso de recorte se puede identificar convirtiendo el objeto osg :: NodeVisitor en osg :: CullVisitor</font></font><br><br><pre> <code class="cpp hljs">osgUtil::CullVisitor *cv = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;osgUtil::CullVisitor *&gt;(&amp;nv); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cv) { <span class="hljs-comment"><span class="hljs-comment">///  - ,     }</span></span></code> </pre><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8. Mecanismo de devoluci√≥n de llamada </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">art√≠culo anterior,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> implementamos la animaci√≥n de un objeto de escena cambiando los par√°metros de su transformaci√≥n dentro del ciclo de representaci√≥n de la escena. Como se ha mencionado muchas veces, este enfoque contiene un comportamiento de aplicaci√≥n potencialmente peligroso en el procesamiento de subprocesos m√∫ltiples. Para resolver este problema, se utiliza un mecanismo de devoluci√≥n de llamada que se realiza al recorrer el gr√°fico de escena. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay varios tipos de devoluciones de llamada en el motor. Las devoluciones de llamada se implementan mediante clases especiales, entre las cuales osg :: NodeCallback est√° dise√±ado para manejar el proceso de actualizaci√≥n de nodos de escena, y osg :: Drawable :: UpdateCallback, osg :: Drawable :: EventCallback y osg :: Drawable: CullCallback - realiza las mismas funciones, pero para objetos de geometr√≠a.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La clase osg :: NodeCallback tiene un operador de operador virtual () reemplazable proporcionado por el desarrollador para implementar su propia funcionalidad. </font><font style="vertical-align: inherit;">Para que la devoluci√≥n de llamada funcione, debe adjuntar una instancia de la clase de llamada al nodo para el que se procesar√° llamando al m√©todo setUpdateCallback () o addUpdateCallback (). </font><font style="vertical-align: inherit;">El operador operator () se llama autom√°ticamente durante la actualizaci√≥n de los nodos en el gr√°fico de escena cuando se procesa cada fotograma. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La siguiente tabla enumera las devoluciones de llamada disponibles para el desarrollador en OSG.</font></font><br><br><table><thead><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nombre </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Functor de devoluci√≥n de llamada </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> M√©todo virtual </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> M√©todo para adjuntar a un objeto </font></font></th></tr></thead><tbody><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Actualizaci√≥n de nodo </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> osg :: NodeCallback </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operador () </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> osg :: Node :: setUpdateCallback () </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Evento de nodo </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> osg :: NodeCallback </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operador () </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> osg :: Node :: setEventCallback () </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recorte de nodos </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> osg :: NodeCallback </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operador () </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> osg :: Node :: setCullCallback () </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Actualizaci√≥n de geometr√≠a </font></font></td><td> osg::Drawable::UpdateCallback </td><td> update() </td><td> osg::Drawable::setUpdateCallback() </td></tr><tr><td>   </td><td> osg::Drawable::EventCallback </td><td> event() </td><td> osg::Drawable::setEventCallback() </td></tr><tr><td>   </td><td> osg::Drawable::CullCallback </td><td> cull() </td><td> osg::Drawable::setCullCallback() </td></tr><tr><td>   </td><td> osg::StateAttributeCallback </td><td> operator() </td><td> osg::StateAttribute::setUpdateCallback() </td></tr><tr><td>   </td><td> osg::StateAttributeCallback </td><td> operator() </td><td> osg::StateAttribute::setEventCallback() </td></tr><tr><td>   </td><td> osg::Uniform::Callback </td><td> operator() </td><td> osg::Uniform::setUpdateCallback() </td></tr><tr><td>   </td><td> osg::Uniform::Callback </td><td> operator() </td><td> osg::Uniform::setEvevtCallback() </td></tr><tr><td>       </td><td> osg::Camera::DrawCallback </td><td> operator() </td><td> osg::Camera::PreDrawCallback() </td></tr><tr><td>       </td><td> osg::Camera::DrawCallback </td><td> operator() </td><td> osg::Camera::PostDrawCallback() </td></tr></tbody></table><br><br><h1> 9.  osg::Switch     </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un poco m√°s arriba, escribimos un ejemplo con el cambio de dos modelos de aviones. </font><font style="vertical-align: inherit;">Ahora repetiremos este ejemplo, pero haremos todo correctamente utilizando el mecanismo de devoluci√≥n de llamada OSG.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Callbacks con ejemplo</font></font></b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Switch&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class SwitchingCallback : public osg::NodeCallback { public: SwitchingCallback() : _count(0) {} virtual void operator()(osg::Node *node, osg::NodeVisitor *nv); protected: unsigned int _count; }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void SwitchingCallback::operator()(osg::Node *node, osg::NodeVisitor *nv) { osg::Switch *switchNode = static_cast&lt;osg::Switch *&gt;(node); if ( !((++_count) % 60) &amp;&amp; switchNode ) { switchNode-&gt;setValue(0, !switchNode-&gt;getValue(0)); switchNode-&gt;setValue(1, !switchNode-&gt;getValue(0)); } traverse(node, nv); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Node&gt; model1 = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile("../data/cessnafire.osg"); osg::ref_ptr&lt;osg::Switch&gt; root = new osg::Switch; root-&gt;addChild(model1, true); root-&gt;addChild(model2, false); root-&gt;setUpdateCallback( new SwitchingCallback ); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Debe crear una clase heredada de osg :: NodeCallback, que controla el nodo osg :: Switch </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SwitchingCallback</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osg::NodeCallback { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: SwitchingCallback() : _count(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::Node *node, osg::NodeVisitor *nv)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _count; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El contador _count controlar√° el cambio del nodo osg :: Switch de mapear un nodo hijo a otro, dependiendo de su valor. </font><font style="vertical-align: inherit;">En el constructor, inicializamos el contador y redefinimos el m√©todo del operador virtual ()</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SwitchingCallback::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>()(osg::Node *node, osg::NodeVisitor *nv) { osg::Switch *switchNode = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Switch *&gt;(node); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !((++_count) % <span class="hljs-number"><span class="hljs-number">60</span></span>) &amp;&amp; switchNode ) { switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, !switchNode-&gt;getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, !switchNode-&gt;getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); } traverse(node, nv); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El nodo en el que trabaj√≥ la llamada se le pasa a trav√©s del par√°metro de nodo. </font><font style="vertical-align: inherit;">Como sabemos con certeza que este ser√° un nodo del tipo osg :: Switch, realizamos una conversi√≥n est√°tica del puntero al nodo al puntero al nodo del interruptor</font></font><br><br><pre> <code class="cpp hljs">osg::Switch *switchNode = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Switch *&gt;(node);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cambiaremos los nodos secundarios mostrados con el valor v√°lido de este puntero, y cuando el valor del contador sea un m√∫ltiplo de 60 </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !((++_count) % <span class="hljs-number"><span class="hljs-number">60</span></span>) &amp;&amp; switchNode ) { switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, !switchNode-&gt;getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, !switchNode-&gt;getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No olvides llamar al m√©todo traverse () para continuar el recorrido recursivo del gr√°fico de escena </font></font><br><br><pre> <code class="cpp hljs">traverse(node, nv);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El resto del c√≥digo del programa es trivial, excepto la l√≠nea. </font></font><br><br><pre> <code class="cpp hljs">root-&gt;setUpdateCallback( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SwitchingCallback );</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">donde asignamos la devoluci√≥n de llamada que creamos al nodo ra√≠z de tipo osg :: Switch. </font><font style="vertical-align: inherit;">El programa funciona de manera similar al ejemplo anterior.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z5/fl/2u/z5fl2uhbnzxafceoro_wbga-pk4.gif"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasta ahora, hemos utilizado el misterioso m√©todo traverse () para dos prop√≥sitos: anular este m√©todo en las clases sucesoras y llamar a este m√©todo en la clase osg :: NodeVisitor para continuar atravesando el gr√°fico de la escena. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el ejemplo que acabamos de examinar, utilizamos la tercera opci√≥n de llamar a traverse (), pasando un puntero al nodo y un puntero a la instancia del visitante como par√°metros. Como en los dos primeros casos, si no hay una llamada a traverse () en este nodo, se detendr√° el rastreo del gr√°fico de escena. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los m√©todos addUpdateCallback () tambi√©n sirven para agregar una devoluci√≥n de llamada al nodo. A diferencia de setUpdateCallback (), se usa para agregar otra devoluci√≥n de llamada a las existentes. Por lo tanto, puede haber m√∫ltiples devoluciones de llamada para el mismo nodo.</font></font><br><br><h1>  Conclusi√≥n </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Examinamos las t√©cnicas b√°sicas utilizadas en el desarrollo de aplicaciones utilizando el motor gr√°fico OpenSceneGraph. </font><font style="vertical-align: inherit;">Sin embargo, esto est√° lejos de todos los puntos que me gustar√≠a mencionar (a pesar de que el art√≠culo result√≥ ser bastante largo), por lo tanto</font></font><br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Continuar√° ...</a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437688/">https://habr.com/ru/post/437688/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../437676/index.html">Las universidades y los aceleradores corporativos como apalancamiento para lanzar una startup B2B en los EE. UU.</a></li>
<li><a href="../437680/index.html">Mi colecci√≥n de bricolaje en Youtube</a></li>
<li><a href="../437682/index.html">Escribir otra herramienta de plantillas de Kubernetes</a></li>
<li><a href="../437684/index.html">Algoritmo Supremo - Compendio sesgado</a></li>
<li><a href="../437686/index.html">Aprendizaje: escribir un mensajero p2p con cifrado de extremo a extremo</a></li>
<li><a href="../437694/index.html">An√°lisis de la utilidad Files.walkFileTree ();</a></li>
<li><a href="../437696/index.html">El resumen de materiales interesantes para el desarrollador m√≥vil # 283 (del 21 al 27 de enero)</a></li>
<li><a href="../437698/index.html">Servicio de traducci√≥n de patentes WIPO Translate - mis experiencias</a></li>
<li><a href="../437702/index.html">An√°lisis de entrevistas de trabajo de Google: consultas sin√≥nimas</a></li>
<li><a href="../437704/index.html">Excelente conocimiento del curr√≠culo escolar como indicador de no la m√°s alta inteligencia.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>