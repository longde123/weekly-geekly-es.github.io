<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüé§ üßëüèæ‚Äçü§ù‚Äçüßëüèº üëºüèª R√©solution du probl√®me de mosa√Øque √† l'aide du solveur SAT √† l'aide de l'exemple pentamino üíÉ üí≠ üöÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Une fois que je suis tomb√© sur un jeu de pentomino o√π il fallait mettre 13 chiffres dans un carr√© de 8 par 8. Apr√®s un certain temps pendant lequel j'...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>R√©solution du probl√®me de mosa√Øque √† l'aide du solveur SAT √† l'aide de l'exemple pentamino</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/408299/"> Une fois que je suis tomb√© sur un jeu de pentomino o√π il fallait mettre 13 chiffres dans un carr√© de 8 par 8. Apr√®s un certain temps pendant lequel j'ai essay√© en vain de r√©soudre ce probl√®me, j'ai d√©cid√© qu'il √©tait n√©cessaire d'√©crire un programme qui ferait cela pour moi.  Pour ce faire, il a fallu choisir un algorithme de solution.  La premi√®re chose qui vient √† l'esprit est l'algorithme habituel des branches et des bordures, lorsque les figures sont empil√©es les unes √† c√¥t√© des autres (l'algorithme avec les liens dansants ne convient pas ici, car les figures sont diff√©rentes).  Diverses heuristiques sont g√©n√©ralement utilis√©es pour acc√©l√©rer cet algorithme, par exemple, la ramification avec le moins d'options est pr√©f√©r√©e.  Vous pouvez trouver et impl√©menter d'autres heuristiques dans cet algorithme, mais ici, je pensais que de nombreuses astuces diff√©rentes pour acc√©l√©rer la solution de ces probl√®mes ont d√©j√† √©t√© impl√©ment√©es dans les solveurs SAT.  Par cons√©quent, il est n√©cessaire de traduire la t√¢che dans le langage math√©matique appropri√© et d'utiliser une sorte de solveur SAT.  √Ä propos de la fa√ßon dont cela a √©t√© mis en ≈ìuvre et quels r√©sultats peuvent √™tre lus sous la coupe. <br><a name="habracut"></a><br>  Au d√©but, je veux vous rappeler ce qu'est le jeu pentamino.  Il s'agit d'un champ carr√© 8x8, qui doit √™tre carrel√© avec 13 chiffres - 12 gribouillis, qui se composent de 5 carr√©s et d'un chiffre 2x2: <br><br><img src="https://ic.pics.livejournal.com/andyplekhanov/66030250/59907/59907_900.jp" alt="image"><br><br>  Ici, il convient de dire quel est le probl√®me de satisfiabilit√© bool√©enne ou le probl√®me SAT.  En termes g√©n√©raux, elle peut √™tre formul√©e comme la recherche de telles valeurs de variables bool√©ennes dans lesquelles l'expression donn√©e devient vraie.  D'une mani√®re g√©n√©rale, il s'agit d'une t√¢che compl√®te de NP, cependant, il existe de nombreuses astuces qui aident √† la r√©soudre efficacement.  Pour ce faire, de nombreuses applications sp√©ciales appel√©es solveurs SAT ont √©t√© d√©velopp√©es.  J'utiliserai un solveur SAT nomm√© minisat.  Pour r√©soudre ce probl√®me, il est n√©cessaire de r√©√©crire l'expression d'entr√©e sous forme normale conjonctive, c'est-√†-dire sous la forme d'un produit de sommes logiques de variables.  Chaque parenth√®se sous forme normale conjonctive est appel√©e ici une clause, qui est le ¬´ou¬ª logique de certains litt√©raux, c'est-√†-dire les variables bool√©ennes ou leurs d√©nis.  Par exemple: <br><br>  (x1 V pas x3) (x2 V x4) (x2 V x3 V pas X4) <br><br>  J'avais besoin de traduire la t√¢che de tuilage en t√¢che SAT.  Prenez une figure pentamino et mettez-la sur le terrain de jeu de toutes les mani√®res possibles, y compris les changements, les virages et les r√©flexions.  Pour chacune de ces positions de la figure, nous associons une variable bool√©enne et nous supposerons que si dans notre solution finale cette figure est pr√©sente dans cette position particuli√®re, alors la variable sera vraie et sinon, alors fausse.  Nous le faisons pour tous les chiffres. <br><br>  √âtablissons maintenant une formule d√©crivant notre probl√®me, c'est-√†-dire que nous imposerons des restrictions sur nos variables.  La premi√®re chose √† faire est de s'assurer que toutes les cellules de notre terrain de jeu seront recouvertes d'au moins un chiffre.  Pour ce faire, pour chaque cellule de 64, nous retrouvons tous les chiffres et positions de ces chiffres qui couvrent cette cellule et composons une clause √† partir des variables qui sont affect√©es √† ces positions des chiffres.  La deuxi√®me chose √† faire est d'√©liminer l'intersection des formes.  Cela peut √™tre fait en un double cycle, en triant simplement toutes les positions possibles de toutes les figures et en d√©terminant si la paire a des cellules communes.  S'il y en a, alors ils se coupent et vous devez ajouter une clause du formulaire (pas x_i V pas x_j), o√π x_i est la variable affect√©e √† la premi√®re position, et x_j est la deuxi√®me position.  Cette clause est vraie lorsque x_i et x_j ne sont pas √©gaux √† un en m√™me temps, c'est-√†-dire, exclut les intersections.  Et enfin, la troisi√®me chose √† consid√©rer est que chaque figurine ne peut √™tre pr√©sente sur le terrain qu'une seule fois.  Pour ce faire, nous parcourons √©galement toutes les positions de chaque figure dans un double cycle et pour chaque paire de positions de la m√™me figure nous faisons une clause similaire √† la pr√©c√©dente et constitu√©e de deux n√©gatifs.  Autrement dit, lorsque deux chiffres identiques apparaissent (mais dans des positions diff√©rentes), l'une de ces clauses donnera faux et, par cons√©quent, exclura une telle solution. <br><br>  Tout cela n'√©tait qu'une th√©orie, et maintenant passons √† la pratique.  Chaque chiffre a un num√©ro de 1 √† d pour le distinguer des autres et l'imprimer facilement.  Ensuite, cr√©ez une matrice du terrain de jeu et encodez les cellules correspondantes du terrain de jeu comme occup√©es / non occup√©es par la figure: <br><br> <code>. . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . 1 1 . . . . . <br> 1 1 . . . . . . <br> . 1 . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 2 . . . . . . . <br> 2 . . . . . . . <br> 2 . . . . . . . <br> 2 . . . . . . . <br> 2 . . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 3 . . . . . . . <br> 3 . . . . . . . <br> 3 . . . . . . . <br> 3 3 . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 4 . . . . . . . <br> 4 . . . . . . . <br> 4 4 . . . . . . <br> . 4 . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 5 5 . . . . . . <br> 5 5 . . . . . . <br> 5 . . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 6 6 6 . . . . . <br> . 6 . . . . . . <br> . 6 . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 7 . 7 . . . . . <br> 7 7 7 . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 8 . . . . . . . <br> 8 . . . . . . . <br> 8 8 8 . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . 9 . . . . . <br> . 9 9 . . . . . <br> 9 9 . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . a . . . . . . <br> aaa . . . . . <br> . a . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> b . . . . . . . <br> bb . . . . . . <br> b . . . . . . . <br> b . . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . cc . . . . . <br> . c . . . . . . <br> cc . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> dd . . . . . . <br> dd . . . . . . <br></code> <br>  Maintenant, pour chaque pi√®ce, il est n√©cessaire de trouver toutes les positions possibles sur le terrain de jeu au moyen de d√©calages, de virages et de r√©flexions.  Commen√ßons par les virages et les reflets.  Au total, il y a 8 transformations possibles de spires et de r√©flexions, dont une transformation triviale qui laisse la figure intacte.  Pour ces transformations, je cr√©e 8 matrices correspondantes, comme indiqu√© ci-dessous.  Apr√®s rotation ou r√©flexion, la figurine peut d√©passer le terrain de jeu, vous devez donc la remettre sur le terrain de jeu.  Il convient √©galement de tenir compte du fait que certains chiffres peuvent se transformer en eux-m√™mes apr√®s la transformation, et de tels cas doivent √™tre exclus.  J'ajoute des options uniques √† la classe d'orientation.  Le r√©sultat est le code suivant: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dimension_ = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MATRIX_SIZE = dimension_ * dimension_; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> * matrix = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[ MATRIX_SIZE ]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; MATRIX_SIZE; i++ ) { matrix[ i ] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; dimension_; i++ ) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> * matrix1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[ MATRIX_SIZE ]; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy( matrix, matrix + MATRIX_SIZE, matrix1 ); matrix1[ i ] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = dimension_; j &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> * dimension_; j++ ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !matrix1[ j - dimension_ ] ) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> * matrix2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[ MATRIX_SIZE ]; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy( matrix1, matrix1 + MATRIX_SIZE, matrix2 ); matrix2[ j ] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NUMBER = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; dimension_; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> l = <span class="hljs-number"><span class="hljs-number">0</span></span>; l &lt; NUMBER; l++ ) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> * matrix3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[ MATRIX_SIZE ]; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy( matrix2, matrix2 + MATRIX_SIZE, matrix3 ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( l &amp; <span class="hljs-number"><span class="hljs-number">1</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> l1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; l1 &lt; dimension_; l1++ ) { matrix3[ l1 ] = -matrix3[ l1 ]; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( l &amp; <span class="hljs-number"><span class="hljs-number">2</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> l1 = dimension_; l1 &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> * dimension_; l1++ ) { matrix3[ l1 ] = -matrix3[ l1 ]; } } Orientation * orientation = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Orientation( figure ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Point *&gt;::const_iterator h = figure-&gt;points().begin(); h != figure-&gt;points().end(); ++h ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Point * p = *h; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; i1 &lt; dimension_; i1++ ) { x = x + p-&gt;coord( i1 ) * matrix3[ i1 ]; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; i1 &lt; dimension_; i1++ ) { y = y + p-&gt;coord( i1 ) * matrix3[ dimension_ + i1 ]; } <span class="hljs-function"><span class="hljs-function">Point </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( x, y )</span></span></span></span>; orientation-&gt;createPoint( p1.coord( <span class="hljs-number"><span class="hljs-number">0</span></span> ), p1.coord( <span class="hljs-number"><span class="hljs-number">1</span></span> ) ); } orientation-&gt;moveToOrigin(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( isUnique( orientations, orientation ) ) { orientations.push_back( orientation ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> orientation; } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> [] matrix3; } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> [] matrix2; } } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> [] matrix1; }</code> </pre><br>  Ce code est appliqu√© √† chacune des figures, puis les Orientations uniques re√ßues sont d√©cal√©es le long des axes x et y cr√©ant toutes les positions possibles de chaque figure.  En cons√©quence, nous avons le nombre suivant de positions diff√©rentes pour chacun des chiffres: <br><br> <code>---------- Figure 1 <br> Count = 288 <br> ---------- Figure 2 <br> Count = 64 <br> ---------- Figure 3 <br> Count = 280 <br> ---------- Figure 4 <br> Count = 280 <br> ---------- Figure 5 <br> Count = 336 <br> ---------- Figure 6 <br> Count = 144 <br> ---------- Figure 7 <br> Count = 168 <br> ---------- Figure 8 <br> Count = 144 <br> ---------- Figure 9 <br> Count = 144 <br> ---------- Figure a <br> Count = 36 <br> ---------- Figure b <br> Count = 280 <br> ---------- Figure c <br> Count = 144 <br> ---------- Figure d <br> Count = 49 <br></code> <br>  Ensuite, nous attribuons une variable bool√©enne √† chaque position possible et cr√©ons une formule, comme d√©crit ci-dessus.  Apr√®s cela, nous appelons minisat directement depuis l'application, qui retourne une solution - un ensemble de nos variables avec les valeurs assign√©es true ou false.  En sachant √† quelles positions ces variables ont √©t√© affect√©es, nous imprimons la solution: <br><br> <code>bbbb 3 3 3 3 <br> ddbc 8 8 8 3 <br> dd 1 ccc 8 2 <br> 5 5 1 1 1 c 8 2 <br> 5 5 5 1 4 4 4 2 <br> 7 7 a 4 4 9 6 2 <br> 7 aaa 9 9 6 2 <br> 7 7 a 9 9 6 6 6 <br></code> <br><img src="https://ic.pics.livejournal.com/andyplekhanov/66030250/60414/60414_900.jpg" alt="image"><br><br><h2>  Et ensuite </h2><br>  Naturellement, il ne serait pas si int√©ressant de s'y attarder.  Par cons√©quent, la premi√®re question qui s'est pos√©e pour moi √©tait ¬´combien de solutions diff√©rentes existent qui ne diff√®rent pas dans les virages triviaux et les r√©flexions du terrain de jeu?¬ª.  Pour ce faire, il existe un mode dans le solveur SAT qui vous permet d'ajouter des clauses sans perdre d'informations existantes, ce qui acc√©l√®re consid√©rablement le processus par rapport √† la recherche de la solution √† partir de z√©ro.  La solution suivante peut √™tre trouv√©e en ajoutant une clause qui contient la n√©gation de toutes les variables pr√©sentes dans la solution pr√©c√©dente.  Apr√®s avoir ajout√© cette proc√©dure et compar√© la nouvelle solution avec les pr√©c√©dentes, en tenant compte des virages et des r√©flexions du terrain de jeu, j'ai eu 1364 options diff√©rentes. <br><br>  Une autre extension int√©ressante que j'ai mise en ≈ìuvre a √©t√© l'√©tude de diverses autres formes de terrain de jeu et de figures.  Et enfin, l'√©tude des terrains de jeu en trois dimensions √©tait tr√®s int√©ressante.  Mais c'est un sujet pour un autre article. <br><br><h2>  Mettre √† jour </h2><br><br>  Apr√®s avoir ajout√© une condition suppl√©mentaire: pour chaque chiffre d'une clause - il devrait y avoir au moins une position de ce chiffre sur le terrain de jeu, le calcul est devenu beaucoup plus rapide.  De plus, une erreur a √©t√© corrig√©e, √† la suite de laquelle le nombre de toutes les options uniques possibles est 16146. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr408299/">https://habr.com/ru/post/fr408299/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr408285/index.html">Enqu√™te aupr√®s des utilisateurs Geektimes</a></li>
<li><a href="../fr408287/index.html">Qui est √† bl√¢mer pour un accident impliquant une voiture autonome? Quand verrons-nous KAMAZ autonome sur les routes?</a></li>
<li><a href="../fr408289/index.html">Interface utilisateur futuriste du nouveau Tesla Model 3</a></li>
<li><a href="../fr408291/index.html">Sur la plan√®te naine Ceres, un oc√©an pouvait exister dans le pass√©</a></li>
<li><a href="../fr408297/index.html">Comment fonctionnent les doubleurs: partie 2</a></li>
<li><a href="../fr408301/index.html">DJI menace le tribunal avec un sp√©cialiste de la cybers√©curit√© qui a d√©couvert les cl√©s pour acc√©der aux comptes de l'entreprise sur GitHub</a></li>
<li><a href="../fr408303/index.html">Une br√®ve histoire du papier √©lectronique: √©volution et perspectives</a></li>
<li><a href="../fr408305/index.html">Le r√©seau neuronal de Stanford diagnostique la pneumonie aux rayons X mieux que les m√©decins</a></li>
<li><a href="../fr408307/index.html">Raise3D: l'impression 3D remplace la fabrication traditionnelle de chaussures</a></li>
<li><a href="../fr408311/index.html">Protons et neutrons: encombrement √† l'int√©rieur de la mati√®re</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>