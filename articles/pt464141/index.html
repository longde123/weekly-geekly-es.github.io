<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõÄüèø ‚¨õÔ∏è ü•´ Fantasias sobre o assunto de metaclasses em C # üêøÔ∏è üë©üèª‚Äçüåæ üñ±Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Programadores como eu, que chegaram ao C # com vasta experi√™ncia em Delphi, geralmente n√£o t√™m o que Delphi √© chamado de refer√™ncia de classe e, no tr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fantasias sobre o assunto de metaclasses em C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464141/"> Programadores como eu, que chegaram ao C # com vasta experi√™ncia em Delphi, geralmente n√£o t√™m o que Delphi √© chamado de refer√™ncia de classe e, no trabalho te√≥rico, metaclasse.  V√°rias vezes em v√°rios f√≥runs me deparei com uma discuss√£o que ocorreu da mesma maneira.  Come√ßa com uma pergunta de um ex-delphist sobre como criar uma metaclasse em C #.  Os Sharpists simplesmente n√£o entendem o problema, tentando esclarecer que tipo de animal √© esse - uma metaclasse, golfistas como eles podem explicar, mas as explica√ß√µes s√£o curtas e incompletas e, como resultado, os sharpers est√£o completamente perdidos por que tudo isso √© necess√°rio.  Afinal, o mesmo pode ser feito com a ajuda de f√°bricas de reflex√£o e de classe. <br><br>  Neste artigo, tentarei explicar o que s√£o as metaclasses para aqueles que nunca as encontraram.  Al√©m disso, todos decidam por si mesmos se seria bom ter uma coisa dessas na linguagem ou se a reflex√£o √© suficiente.  Tudo o que estou escrevendo aqui s√£o apenas fantasias sobre como poderia ter sido se as metaclasses realmente existissem em C #.  Todos os exemplos deste artigo est√£o escritos nesta vers√£o hipot√©tica do C #, nem um √∫nico compilador existente no momento pode compil√°-los. <br><a name="habracut"></a><br><h2>  O que √© uma metaclasse? </h2><br>  Ent√£o, o que √© uma metaclasse?  Este √© um tipo especial que serve para descrever outros tipos.  H√° algo muito semelhante em C # - o tipo Type.  Mas apenas semelhante.  Um valor do tipo Type pode descrever qualquer tipo, uma metaclasse pode descrever apenas os herdeiros da classe especificada quando a metaclasse foi declarada. <br><br>  Para fazer isso, nossa vers√£o hipot√©tica do C # adquire o tipo Type &lt;T&gt;, que √© o sucessor do Type.  Mas o Tipo &lt;T&gt; √© adequado apenas para descrever o tipo T ou seus descendentes. <br>  Vou explicar isso com um exemplo: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A2</span></span> : <span class="hljs-title"><span class="hljs-title">A</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Type&lt;A&gt; ta; ta = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(A); <span class="hljs-comment"><span class="hljs-comment">//   ta = typeof(A2); //    ta = typeof(B); //   ‚Äì Type&lt;B&gt;   Type&lt;A&gt; ta = (Type&lt;A&gt;)typeof(B); //      -   Type tx = typeof(A); ta = tx; //   ‚Äì    Type  Type&lt;A&gt; ta = (Type&lt;A&gt;)tx; //    Type&lt;B&gt; tb = (Type&lt;B&gt;)tx; //  } }</span></span></code> </pre> <br>  O exemplo acima √© o primeiro passo para o surgimento de metaclasses.  Tipo Tipo &lt;T&gt; permite restringir quais tipos podem ser descritos pelos valores correspondentes.  Esse recurso pode ser √∫til por si s√≥, mas as possibilidades de metaclasses n√£o se limitam a isso. <br><br><h2>  Metaclasses e membros de classe est√°tica </h2><br>  Se alguma classe X tiver membros est√°ticos, a metaclasse Tipo &lt;X&gt; obter√° membros semelhantes, n√£o mais est√°ticos, pelos quais voc√™ pode acessar os membros est√°ticos do X. Vamos explicar esta frase confusa com um exemplo. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Type&lt;X&gt; tx = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(X); tx.DoSomething(); <span class="hljs-comment"><span class="hljs-comment">//   ,     X.DoSomething(); } }</span></span></code> </pre><br>  <i>Aqui, de um modo geral, surge a pergunta - e se na classe X for declarado um m√©todo est√°tico, cujo nome e conjunto de par√¢metros coincidam com o nome e o conjunto de par√¢metros de um dos m√©todos da classe Type, cujo herdador √© o Tipo &lt;X&gt;?</i>  <i>Existem v√°rias op√ß√µes bastante simples para resolver esse problema, mas n√£o vou me deter nelas - por simplicidade, acreditamos que em nossa linguagem de fantasia de conflitos n√£o h√° nomes m√°gicos.</i> <br><br>  O c√≥digo acima para qualquer pessoa normal deve ser desconcertante - por que precisamos de uma vari√°vel para chamar um m√©todo se podemos cham√°-lo diretamente?  De fato, nesta forma, essa oportunidade √© in√∫til.  Mas o benef√≠cio vem quando voc√™ adiciona m√©todos de classe a ele. <br><br><h2>  M√©todos de classe </h2><br>  M√©todos de classe s√£o outra constru√ß√£o que o Delphi possui, mas est√° ausente no C #.  Quando declarados, esses m√©todos s√£o marcados com a classe de palavras e s√£o um cruzamento entre m√©todos est√°ticos e m√©todos de inst√¢ncia.  Como m√©todos est√°ticos, eles n√£o est√£o vinculados a uma inst√¢ncia espec√≠fica e podem ser chamados pelo nome da classe sem criar uma inst√¢ncia.  Mas, diferentemente dos m√©todos est√°ticos, eles t√™m um par√¢metro impl√≠cito this.  Somente isso neste caso n√£o √© uma inst√¢ncia da classe, mas uma metaclasse, ou seja,  se o m√©todo da classe for descrito na classe X, esse par√¢metro ser√° do tipo Tipo &lt;X&gt;.  E voc√™ pode us√°-lo assim: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> class </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Report</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine($‚Äù    {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Name}‚Äù); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Y</span></span> : <span class="hljs-title"><span class="hljs-title">X</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { X.Report() <span class="hljs-comment"><span class="hljs-comment">// : ¬´    X¬ª Y.Report() // : ¬´    Y¬ª } }</span></span></code> </pre><br>  Esse recurso n√£o √© muito impressionante at√© agora.  Mas, gra√ßas a isso, os m√©todos de classe, diferentemente dos m√©todos est√°ticos, podem ser virtuais.  Mais precisamente, os m√©todos est√°ticos tamb√©m podem ser virtualizados, mas n√£o est√° claro o que fazer em seguida com essa virtualidade.  Mas com m√©todos de classe, esses problemas n√£o surgem.  Considere isso com um exemplo. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoReport</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(‚Äú!‚Äù); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Report</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { DoReport(); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Y</span></span> : <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoReport</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Consloe.WriteLine(‚Äú!‚Äù); } } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { X.Report() <span class="hljs-comment"><span class="hljs-comment">// : ¬´!¬ª Y.Report() // : ??? } }</span></span></code> </pre><br>  Pela l√≥gica das coisas, ao chamar Y.Report, ‚ÄúBye!‚Äù Deve ser exibido.  Mas o m√©todo X.Report n√£o possui informa√ß√µes sobre de qual classe ele foi chamado, portanto, n√£o pode escolher dinamicamente entre X.DoReport e Y.DoReport.  Como resultado, o X.Report sempre chamar√° X.DoReport, mesmo que o Relat√≥rio tenha sido chamado por meio de Y. N√£o faz sentido tornar virtual o m√©todo DoReport.  Portanto, o C # n√£o permite virtualizar m√©todos est√°ticos - seria poss√≠vel virtualiz√°-los, mas voc√™ n√£o poder√° se beneficiar da virtualidade deles. <br><br>  Outra coisa s√£o os m√©todos de classe.  Se o Relat√≥rio no exemplo anterior n√£o fosse est√°tico, mas classe, ele "saberia" quando foi chamado por meio de X e por Y. Assim, o compilador poderia gerar c√≥digo que selecionaria o DoReport desejado e resultaria em uma chamada para Y.Report. at√© a conclus√£o "Tchau!". <br><br>  Esse recurso √© √∫til por si s√≥, mas se torna ainda mais √∫til se voc√™ adicionar a capacidade de chamar vari√°veis ‚Äã‚Äãde classe por meio de metaclasses.  Algo assim: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Report</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(‚Äú!‚Äù); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Y</span></span> : <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Report</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Consloe.WriteLine(‚Äú!‚Äù); } } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Type&lt;X&gt; tx = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(X); tx.Report() <span class="hljs-comment"><span class="hljs-comment">// : ¬´!¬ª tx = typeof(Y); tx.Report() // : ¬´!¬ª } }</span></span></code> </pre><br>  Para atingir esse polimorfismo sem metaclasses e m√©todos de classe virtual, para a classe X e cada um de seus descendentes teria que escrever uma classe auxiliar com o m√©todo virtual usual.  Isso requer muito mais esfor√ßo, e o controle do compilador n√£o ser√° t√£o completo, o que aumenta a probabilidade de cometer algum erro.  Enquanto isso, situa√ß√µes em que o polimorfismo √© necess√°rio no n√≠vel do tipo, e n√£o no n√≠vel da inst√¢ncia, s√£o encontradas regularmente e, se a linguagem suportar esse polimorfismo, essa √© uma propriedade muito √∫til. <br><br><h2>  Construtores virtuais </h2><br>  Se metaclasses aparecerem no idioma, os construtores virtuais precisar√£o ser adicionados a eles.  Se um construtor virtual for declarado em uma classe, todos os seus descendentes dever√£o se sobrepor, ou seja,  tenha seu pr√≥prio construtor com o mesmo conjunto de par√¢metros, por exemplo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { ... } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">B</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">C</span></span> : <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">C</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ... } }</code> </pre><br>  Nesse c√≥digo, a classe C n√£o deve ser compilada, porque n√£o possui um construtor com os par√¢metros int x, int y, mas a classe B √© compilada sem erros. <br><br>  <i>Outra op√ß√£o √© poss√≠vel: se o construtor virtual do ancestral n√£o se sobrepuser ao herdeiro, o compilador o sobrep√µe automaticamente, assim como agora cria automaticamente o construtor padr√£o.</i>  <i>Ambas as abordagens t√™m pr√≥s e contras √≥bvios, mas isso n√£o √© importante para o quadro geral.</i> <br><br>  Um construtor virtual pode ser usado sempre que um construtor regular pode ser usado.  Al√©m disso, se a classe tiver um construtor virtual, sua metaclasse ter√° o m√©todo CreateInstance com o mesmo conjunto de par√¢metros que o construtor, e esse m√©todo instanciar√° a classe, conforme mostrado no exemplo abaixo. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { ... } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">B</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Type&lt;A&gt; ta = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(A); A a1 = ta.CreateInstance(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    A ta = typeof(B); A a2 = ta.CreateInstance(2, 7); //    B } }</span></span></code> </pre><br>  Em outras palavras, temos a oportunidade de criar objetos cujo tipo √© determinado em tempo de execu√ß√£o.  Agora isso tamb√©m pode ser feito usando Activator.CreateInstance.  Mas esse m√©todo funciona atrav√©s da reflex√£o, portanto, a corre√ß√£o do conjunto de par√¢metros √© verificada apenas no est√°gio de execu√ß√£o.  Mas se tivermos metaclasses, o c√≥digo com os par√¢metros errados simplesmente n√£o ser√° compilado.  Al√©m disso, ao usar a reflex√£o, a velocidade do trabalho deixa muito a desejar, e as metaclasses permitem minimizar os custos. <br><br><h2>  Conclus√£o </h2><br>  Sempre me surpreendi por que Halesberg, que √© o principal desenvolvedor do Delphi e do C #, n√£o fazia metaclasses em C #, embora eles se mostrassem t√£o bem no Delphi.  Talvez o ponto aqui seja que no Delphi (nessas vers√µes que Halesberg fez) quase n√£o h√° reflex√£o, e simplesmente n√£o h√° alternativa para as metaclasses, o que n√£o pode ser dito sobre C #.  De fato, todos os exemplos deste artigo n√£o s√£o t√£o dif√≠ceis de refazer, usando apenas as ferramentas que j√° est√£o no idioma.  Mas tudo isso funcionar√° visivelmente mais devagar do que poderia com as metaclasses, e a corre√ß√£o das chamadas ser√° verificada no tempo de execu√ß√£o, n√£o na compila√ß√£o.  Portanto, minha opini√£o pessoal √© que o C # se beneficiaria muito se metaclasses aparecessem nele. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt464141/">https://habr.com/ru/post/pt464141/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt464127/index.html">Desenvolvimento de favicons animados</a></li>
<li><a href="../pt464129/index.html">Inova√ß√µes em JavaScript: resultados do Google I / O 2019. Parte 1</a></li>
<li><a href="../pt464131/index.html">Inova√ß√µes em JavaScript: resultados do Google I / O 2019. Parte 2</a></li>
<li><a href="../pt464133/index.html">O desempenho n√£o se resume apenas √† CPU: criando seus pr√≥prios criadores de perfil para Python</a></li>
<li><a href="../pt464137/index.html">Suporte t√©cnico Miran: como funciona</a></li>
<li><a href="../pt464143/index.html">Cura pessoal do c√¢ncer. Como os genes dos pacientes afetam o sucesso do tratamento</a></li>
<li><a href="../pt464145/index.html">CMake: o caso em que a qualidade do projeto √© imperdo√°vel</a></li>
<li><a href="../pt464147/index.html">CMake: o caso em que o projeto √© imperdo√°vel, a qualidade do seu c√≥digo</a></li>
<li><a href="../pt464149/index.html">A hist√≥ria de um mon√≥lito</a></li>
<li><a href="../pt464151/index.html">Victor Vyalichkin: ‚ÄúLiberdade, igualdade, fraternidade est√£o apenas no OpenStreetMap, onde tudo est√° sempre √† vista‚Äù</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>