<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍✈️ 🥞 👩‍✈️ So starten Sie ein Haustierprojekt und erhalten keine Vorteile 👨🏾‍🌾 ✌🏾 👩‍👩‍👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TL; DR 

 Der Artikel beschreibt die Verwendung von Haustierprojekten als eine Möglichkeit, Fähigkeiten zu erhalten und zu verbessern. Der Autor hat e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So starten Sie ein Haustierprojekt und erhalten keine Vorteile</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479122/"><p><img src="https://habrastorage.org/webt/cz/x-/ln/czx-lnrbjewed61t5fm8k_pjvei.png" alt="So starten Sie ein Haustierprojekt und erhalten keine Vorteile"></p><br><div class="spoiler">  <b class="spoiler_title">TL; DR</b> <div class="spoiler_text"><p>  Der Artikel beschreibt die Verwendung von Haustierprojekten als eine Möglichkeit, Fähigkeiten zu erhalten und zu verbessern.  Der Autor hat eine <a href="https://github.com/liquetsoft/fias-symfony" rel="nofollow">PHP-Bibliothek</a> zur Installation von <a href="https://fias.nalog.ru/" rel="nofollow">FIAS</a> aus XML-Dateien erstellt. </p></div></div><br><h2 id="cel">  Zweck </h2><br><p>  Ich wechsle selten den Job, daher wird jede Aufgabe aufgrund des natürlichen Wunsches jeder Organisation nach festen Prozessen zur Routine.  Einerseits ist es für ein Unternehmen von Vorteil, einen solchen Zustand aufrechtzuerhalten, andererseits bedeutet dies für mich entweder einen vollständigen Verlust oder eine Überalterung der Fähigkeiten.  PHP entwickelt sich rasant und infolgedessen wächst auch die potenzielle Verzögerung rasant.  Schließlich wissen wir alle, dass es heutzutage für einen Programmierer schwierig ist, einen guten Job zu finden, ohne Kenntnisse über Elasticsearch, RabbitMQ, Kafka und andere Technologien, die in meiner täglichen Arbeit nicht oft vorkommen. </p><a name="habracut"></a><br><p>  Nachdem ich die nächste typische Site gestartet hatte, entschied ich, dass es Zeit war, etwas zu ändern.  Ich wollte meine Arbeit nicht ändern, aber ich erinnerte mich, wie der Sprecher auf einer der Konferenzen empfahl, sein eigenes optionales Projekt, das sogenannte Haustierprojekt, für das Training zu verwenden.  Die Methode schien angemessen und ich beschloss, es zu versuchen. </p><br><h2 id="vybor-zadachi">  Aufgabenauswahl </h2><br><p>  Die Wahl der Aufgabe erwies sich als der schwierigste Teil des Unternehmens.  Es fiel nichts Besonderes ein: Einige Dienste, wie ein Job-Parser, der einfach auf einem vertrauten Stack implementiert werden kann.  Ich gab die Idee des Projekts für einige Monate auf, bis ich versehentlich die Nachrichten über den Hackathon des Finanzministeriums sah.  Es wurde vorgeschlagen, eine der offenen Datenquellen zu verwenden, um einen Service zu erstellen.  Unter anderem wurde auch das Federal Information Address System (FIAS) angegeben.  Leider war der Hackathon bis dahin bereits beendet. </p><br><p>  Ich habe zum ersten Mal von FIAS erfahren, aber die Aufgabe schien interessant zu sein.  Überzeugen Sie sich selbst: Rund 30 GB XML-Dateien, rund 60 Millionen Zeilen in der Datenbank und darüber hinaus könnte sich die Bibliothek später als nützlich für die Arbeit erweisen.  Es gab einige fertige Lösungen auf Github, aber das hat mich nicht aufgehalten.  Im Gegenteil, basierend auf ihrer Analyse stellte ich zusätzliche Anforderungen, die meine Implementierung hervorheben würden. </p><br><p>  Mit Blick auf die Zukunft stieß ich auf weniger Schwierigkeiten als erwartet. </p><br><h2 id="formulirovka-zadachi">  Aufgabenstellung </h2><br><p>  90% des Erfolgs ist die korrekte Angabe des Problems.  Nach mehreren Jahren Vorlagenarbeit war es ziemlich schwierig, sich das Problem klar zu formulieren.  Ich wollte gerade anfangen zu arbeiten, aber schon in dem Prozess hätte sich alles von selbst geklärt.  Nach einer Stunde des Aufschubs schrieb ich schließlich: Erstellen Sie eine Bibliothek in PHP, um FIAS-Daten zu importieren. </p><br><p>  Später, nach einem Vorgeschmack, habe ich ein paar zusätzliche Anforderungen hinzugefügt: </p><br><ul><li>  Implementierung in PHP ohne Verwendung von Drittanbieter-Dienstprogrammen, ausschließlich Code in PHP und Erweiterungen von PECL, </li><li>  Import aller Daten aus dem FIAS-Set, </li><li>  vollständiger Installations- und Aktualisierungszyklus: Suche nach der erforderlichen Version, Empfang des Archivs, Entpacken, Schreiben in die Datenbank, </li><li>  maximale Flexibilität: die Möglichkeit, den Speicherort zu ändern, Daten vor der Aufzeichnung zu ändern, das Notwendige zu filtern usw. </li><li>  Die Bibliothek sollte sich problemlos in bestehende Projekte integrieren lassen. </li></ul><br><h2 id="fias">  FIAS </h2><br><p>  FIAS hat eine <a href="https://fias.nalog.ru/" rel="nofollow">offizielle Website</a> , auf der wir die Definition und den Zweck der Erstellung eines Systems angeben </p><br><blockquote>  Das Bundesinformationsadressensystem (FIAS) ist das Landesinformationssystem, das die Bildung, Pflege und Nutzung des Landesadressregisters vorsieht. <br><br>  Der Zweck der Schaffung des FIAS ist die Bildung einer einzigen Bundesressource, die zuverlässige, einheitliche, öffentlich zugängliche, strukturierte Adressinformationen enthält.  Dank der Implementierung von FIAS können diese Informationen kostenlos über das Internet auf dem offiziell registrierten FIAS-Portal abgerufen werden. </blockquote><p>  Materialien mit einer Beschreibung sind sowohl auf <a href="https://fias.nalog.ru/Updates.aspx" rel="nofollow">der FIAS-Website</a> als auch auf dem <a href="https://habr.com/ru/search/%3Fq%3D%25D0%25A4%25D0%2598%25D0%2590%25D0%25A1">Habré</a> völlig ausreichend, daher werde ich mich nicht darauf konzentrieren. </p><br><p>  Kurz gesagt.  FIAS gibt es in zwei Formaten: FIAS und KLADR.  Die zweite ist veraltet und wird nicht mehr verwendet.  Informationen werden entweder in DBF oder in XML gespeichert.  Jede Änderung in der Zusammensetzung des FIAS ist mit einer neuen Version gekennzeichnet.  Sie können entweder ein Paket mit vollständigen Daten anfordern, die aktuell sind, oder nur Änderungen zwischen den beiden Versionen enthalten.  Links bietet einen SOAP-Dienst.  Das Paket ist ein RAR-Archiv, das Dateien mit speziell geformten Namen enthält.  Sie bestehen aus einem Präfix, einem Datensatznamen und einem Erstellungsdatum.  Es gibt zwei Arten von Präfixen: AS_ für Dateien, aus denen Daten zur Datenbank hinzugefügt werden müssen, und AS <em>DEL</em> für Dateien, deren Daten aus der Datenbank gelöscht werden sollen. </p><br><p>  FIAS enthält folgende Daten: </p><br><ul><li>  Register der adressbildenden Elemente (dies ist die Grafik der Adressen: Regionen, Städte und Straßen), </li><li>  Adresselemente zur Identifizierung adressierbarer Objekte (Hausnummer und Hausdaten), </li><li>  Informationen über Grundstücke </li><li>  Informationen über die Räumlichkeiten (Wohnungen, Büros, Zimmer usw.), </li><li>  Angaben zum normativen Dokument, das die Grundlage für die Zuordnung des Namens zum Adresselement bildet. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Sowie mehrere Wörterbücher</b> <div class="spoiler_text"><ul><li>  eine Liste der möglichen Werte der Intervalle der Häuser (regelmäßig, gerade, ungerade), </li><li>  eine Liste der relevanten Status eines Eintrags eines Adresselements durch den KLADR4.0-Klassifizierer, </li><li>  eine Liste relevanter Status eines Eintrags eines Adresselements nach FIAS, </li><li>  eine Liste der vollständigen, abgekürzten Namen der Arten von Adresselementen und ihrer Klassifizierungsebenen, </li><li>  Liste der Gebäudetypen, </li><li>  Liste der möglichen Eigentumsarten </li><li>  Liste der Operationscodes mit adressierbaren Objekten, </li><li>  eine Liste möglicher Immobilienbedingungen, </li><li>  Liste der Arten von Räumlichkeiten oder Büros, </li><li>  Liste der Zimmertypen, </li><li>  Liste möglicher Zustände (Zentren) von Adressobjekten von Verwaltungseinheiten, </li><li>  Arten von Regulierungsdokumenten. </li></ul></div></div><br><p>  Die Datenstruktur ist im Dokument beschrieben, das <a href="https://fias.nalog.ru/Updates.aspx" rel="nofollow">im Abschnitt Aktualisierungen zu finden ist</a> . </p><br><p>  Letztendlich haben wir einen ziemlich einfachen und linearen FIAS-Installationsalgorithmus: </p><br><ul><li>  vom SOAP-Dienst einen Link zum Archiv und die aktuelle Versionsnummer erhalten, </li><li>  Archiv herunterladen, </li><li>  auspacken </li><li>  alle Daten aus Dateien mit dem Präfix AS_ in die Datenbank schreiben, </li><li>  alle Daten aus Dateien mit dem Präfix AS <em>DEL</em> aus der Datenbank löschen (ja, das ist richtig, während der Installation müssen Sie auch einige Daten löschen), </li><li>  Notieren Sie sich die Nummer der installierten Version. </li></ul><br><p>  Und nicht weniger einfacher Update-Algorithmus: </p><br><ul><li>  vom SOAP-Dienst eine Liste mit Versionsnummern und Links zu Dateien mit Änderungen erhalten, </li><li>  Wenn die aktuelle Version in der lokalen Datenbank die neueste ist, beenden Sie die Ausführung. </li><li>  einen Link zum Archiv mit den Änderungen zur nächsten Version erhalten, </li><li>  Archiv herunterladen, </li><li>  auspacken </li><li>  alle Daten aus Dateien mit dem Präfix AS_ in die Datenbank schreiben, </li><li>  alle Daten aus Dateien mit dem Präfix AS <em>DEL</em> aus der Datenbank entfernen, </li><li>  notieren Sie sich die Nummer der aktualisierten Version, </li><li>  kehren Sie zum ersten Schritt zurück. </li></ul><br><p>  FIAS hinterlässt widersprüchliche Eindrücke.  Einerseits: vollständige Automatisierung des gesamten Prozesses, offene Formate, gute Dokumentation.  Auf der anderen Seite: eine seltsame Entscheidung, proprietäres RAR für offene Daten zu verwenden;  Unterschiede zwischen Dokumentation und Realität (hauptsächlich im Zusammenhang mit obligatorischen Attributen), die viele kleine, aber unangenehme Probleme verursachen;  Gelegentlich kommen Archive, die unter Linux nicht entpackt werden können.  Einige Deltas zwischen den Versionen belegen 4 bis 5 GB. </p><br><h2 id="arhitektura">  Architektur </h2><br><p>  Jede Bibliothek sollte auf einer Grundidee basieren, einem Kern, um den der Rest der Funktionalität erweitert wird.  Das Muster der Aufgabenkette schien mir die beste Wahl für die Rolle einer solchen Idee zu sein.  Erstens ist es ideal: Mehrere sequenzielle Operationen, die eine Person durchgeführt hätte, wenn sie FIAS manuell installieren wollte, sind für den Entwickler offensichtlich und passen gut in kleine Klassen, die im SOLID-Stil geschrieben sind.  Zweitens lässt sich eine solche Kette in nahezu jeder Phase sehr leicht durch neue Operationen erweitern, was eine gute Flexibilität bietet.  Drittens wollte ich schon lange meine eigene Implementierung schreiben. </p><br><p>  Zusätzlich zu den Vorgängen habe ich mehrere Dienste erstellt, die mit DI übertragen werden können.  Sie ermöglichen es Ihnen, den Code wiederzuverwenden, die Implementierung für einfache Systemaufgaben (Herunterladen einer Datei, Entpacken eines Archivs, Schreiben in eine Datenbank und andere) zu ersetzen und dank Versehen eine gute Testabdeckung zu erzielen. </p><br><p>  Folglich enthält die Bibliothek vier Haupttypen von Objekten, für die der Verantwortungsbereich klar definiert ist: </p><br><ul><li>  Services - Bereitstellung von Tools für die Ausführung von Systemaufgaben auf niedriger Ebene, </li><li>  Statusobjekt - speichert Informationen für die Übertragung zwischen Operationen, </li><li>  Operationen - unter Verwendung der Dienste und Zustände implementieren sie den atomaren Teil der Geschäftslogik, </li><li>  Operationskette - Führt Operationen aus und überträgt den Status zwischen ihnen. </li></ul><br><p>  Durch die Verknüpfung von Operationen und Diensten, die von der Bibliothek bereitgestellt werden, können Sie auf einfache Weise eine neue Kette abrufen oder die vorhandene Kette nur mit Konfigurationsdateien ergänzen. </p><br><h2 id="freymvorki">  Frameworks </h2><br><p>  Mit langen Pausen und ständigen Umgestaltungen arbeitete ich anderthalb Jahre an der Bibliothek. </p><br><p>  Die erste relativ stabile Version war in zwei Monaten Arbeit abends fertig.  Tatsächlich könnte es unabhängig vom Framework existieren und alles Notwendige enthalten: ein Eingabeskript zur Ausführung in der Konsole, einen DI-Container, ein Add-On über PDO, einen eigenen Logger und Migrationen der Datenbankstruktur - worauf ich sehr stolz war. </p><br><p>  Natürlich lehnten ihre Kollegen sie gnadenlos ab. </p><br><p>  Das Hauptargument dagegen war die mangelnde Unterstützung für populäre Rahmenbedingungen.  Niemand wollte einen separaten Wrapper für die Bibliothek schreiben.  Aus diesem Grund habe ich den teuersten Fehler der Zeit gemacht: Ich begann, sowohl die Standalone-Version als auch einzelne Wrapper für jedes Framework zu unterstützen.  Echte FIAS-Dateien unterscheiden sich von den Angaben in der Dokumentation.  Jedes Mal, wenn es erforderlich war, beispielsweise nicht null in der Spaltenbeschreibung zu entfernen oder hinzuzufügen, musste ich Änderungen an drei Repositorys vornehmen.  Aufgrund des langwierigen Prozesses wurde die Arbeit für weitere sechs Monate unterbrochen. </p><br><p>  Das Gefühl der Unvollständigkeit quälte mich die ganze Zeit und zwang mich nach einem blutigen Kampf mit Faulheit, wieder eine neue Version zu entwerfen.  Zunächst entschied ich, dass niemand eine eigenständige Bibliothek benötigt. Das bedeutet, dass Sie alle Dienste, die Frameworks bereitstellen, aus dem Paket streichen und durch Schnittstellen ersetzen sollten.  Also gingen wir unter die Lupe: Ein Eingabeskript zur Ausführung in der Konsole, ein DI-Container, ein Add-On über PDO, unsere eigenen Logger- und Datenbankstrukturmigrationen.  Als Nächstes habe ich mich entschieden, für jedes Framework separate Pakete zu erstellen, die alle Teile vom Haupt-Skript zu einem funktionierenden Skript verbinden und spezifische Implementierungen von Diensten bereitstellen. </p><br><p>  Der entscheidende Punkt war das Modell.  Das ständige Aktualisieren heterogener Objektmengen in mehreren Repositories wollte nicht.  Gleichzeitig bekam ich bei der Hauptarbeit ein Projekt über Symfony.  Nachdem ich mich schnell damit vertraut gemacht hatte, entschied ich, dass die Codegenerierung die nützlichste Funktion von SF ist und alle meine Probleme lösen wird.  Ich habe im <a href="" rel="nofollow">Hauptpaket</a> eine <a href="" rel="nofollow">yaml-Datei</a> erstellt, die eine deklarative Beschreibung der FIAS-Daten enthält.  Dann habe ich Codegeneratoren hinzugefügt, die bestimmte Klassen für Modelle basierend auf dieser Beschreibung erstellen: Doctrine-Entitäten für Symfony- und Eloquent-Objekte für Laravel.  Während der Entwicklung von Generatoren wurde mir klar, dass Zweigvorlagen dafür nicht geeignet waren, und ich entschied mich für eine spezielle Lösung - den <a href="https://github.com/nette/php-generator" rel="nofollow">Nette PHP Generator</a> . </p><br><p>  Als Proof of Concept habe ich Bundles für <a href="https://github.com/liquetsoft/fias-laravel" rel="nofollow">Laravel</a> und <a href="https://github.com/liquetsoft/fias-symfony" rel="nofollow">Symfony erstellt</a> .  Da ich länger mit dem zweiten gearbeitet habe, werde ich alles Weitere in seinem Zusammenhang beschreiben. </p><br><h2 id="infrastruktura">  Die Infrastruktur </h2><br><p>  Die meisten meiner Kampfprojekte waren auf veraltete Technologien ausgerichtet, daher konnte ich auf keinem von ihnen moderne Code-Analysatoren verwenden.  Nachdem ich die alte Unterdrückung beseitigt hatte, installierte und konfigurierte ich alle Tools zur Codequalitätskontrolle, die ich nutzen konnte: </p><br><ul><li>  <a href="https://github.com/vimeo/psalm" rel="nofollow">Psalm</a> zur Typprüfung, </li><li>  <a href="https://scrutinizer-ci.com/" rel="nofollow">Scrutinizer</a> zur allgemeinen Qualitätsbewertung (hilft <a href="https://scrutinizer-ci.com/" rel="nofollow">viel</a> bei der zyklomatischen Komplexität) </li><li>  <a href="https://github.com/FriendsOfPHP/PHP-CS-Fixer" rel="nofollow">PHP Coding Standards Fixer</a> zur Überprüfung des Codestils, </li><li>  <a href="https://github.com/sebastianbergmann/phpcpd" rel="nofollow">PHP Copy / Paste Detector</a> zum Auffinden von Duplikaten, </li><li>  <a href="https://github.com/sebastianbergmann/phpunit" rel="nofollow">PHPUnit</a> zum Ausführen von Komponententests. </li></ul><br><p>  Integrierte Validierung in Github mit <a href="https://travis-ci.org/" rel="nofollow">Travis</a> .  Abschließend fügte er eine Docker-Datei hinzu, um eine lokale Entwicklerumgebung mit einer make-Datei zu erstellen, die die grundlegenden Befehle für den Container enthält (Starten von Überprüfungen, Tests, Erstellen von Modellen usw.). </p><br><h2 id="itogi-obucheniya">  Lernergebnisse </h2><br><h3 id="php-7">  PHP 7 </h3><br><p>  Bevor ich mit der Arbeit an der Bibliothek begonnen habe, habe ich die <a href="https://www.php.net/manual/ru/migration70.new-features.php" rel="nofollow">neuen Funktionen von PHP 7</a> nie wirklich genutzt.  Sie sind schön: von strengen Typen bis zu einer deutlichen Steigerung der Produktivität.  Besonderer Dank geht an die Entwickler für den Null-Koaleszenz-Operator.  Ich habe nach der Einführung eines Operators keinen so gravierenden Rückgang der Codebasis festgestellt. </p><br><h3 id="rar">  Rar </h3><br><p>  Überraschenderweise gab es in PECL ein <a href="https://www.php.net/manual/ru/book.rar.php" rel="nofollow">Paket für die Arbeit mit RAR</a> .  Normalerweise werden solche Erweiterungen nicht als vertrauenswürdig eingestuft, und ich versuche, sie zu vermeiden.  Es stellte sich als verdächtig stabil heraus: Es wurde problemlos in 7.2 installiert, es konnte relativ schnell und mit geringem RAM-Verbrauch große Archive entpacken (6 GB werden in 10-20 Minuten entpackt, abhängig von den verfügbaren Systemressourcen).  Ich fürchte immer noch, dass dies eine Manifestation von Murphys Gesetz ist. </p><br><h3 id="xmlreader">  Xmlreader </h3><br><p>  Das Lesen von riesigen XML-Dateien ist keine triviale Aufgabe.  Und wieder kam die PECL-Erweiterung zu Hilfe - <a href="https://www.php.net/manual/ru/book.xmlreader.php" rel="nofollow">XmlReader</a> .  Ich habe seine Leistungsfähigkeit nicht sofort erkannt, aber in mehreren Ansätzen in Verbindung mit dem <a href="https://symfony.com/doc/current/components/serializer.html" rel="nofollow">Symfony-Serializer</a> angepasst, um Daten aus FIAS-Dateien schnell und kostengünstig abzurufen.  Bibliotheksseitig implementiert das Reader-Objekt die Iterator-Schnittstelle, die nacheinander XML-Zeichenfolgen zurückgibt, die einem Datensatz in der Datei entsprechen.  Mit dem Symfony-Serializer werden diese Zeichenfolgen in Objekte konvertiert.  Eine 20-GB-Datei kann in 3-4 Minuten gelesen werden, wenn nicht mehr als 50 MB RAM verwendet werden. </p><br><h3 id="zapis-v-bazu-dannyh">  In die Datenbank schreiben </h3><br><p>  Natürlich habe ich mit assoziativen Arrays mit Daten und umfangreichen Tabellenbeschreibungen begonnen.  Der Code verwandelte sich schnell in einen Hash von Konfigurations- und Konvertierungsklassen. </p><br><p>  Die Magie der Doktrin zeigte, wie Objekte sich selbst beschreiben können.  Ich habe mich für denselben Ansatz entschieden, aber gleichzeitig meine eigene Implementierung des Schreibens von Daten in die Datenbank mithilfe von PDO aufgegeben.  Stattdessen habe ich eine Speicherschnittstelle erstellt, die Methoden zur Verarbeitung von Objekten beschreibt.  Basierend auf der Entitätsklasse entscheidet eine bestimmte Speicherimplementierung genau, wie und wo die Daten geschrieben werden sollen.  Dieser Ansatz machte es einfach, eine Vielzahl von Speichern zu verbinden: von MySQL bis zu CSV-Dateien. </p><br><h3 id="optimizaciya-vstavki-dannyh">  Dateneinfügeoptimierung </h3><br><p>  Ich habe den ersten Import nach 48 Stunden abgebrochen.  Es wurde deutlich, dass Sie den Prozess des Einfügens von Daten optimieren müssen. </p><br><p>  Zuerst habe ich zu den <a href="https://www.postgresql.org/docs/12/datatype-uuid.html" rel="nofollow">Spalten vom Typ ugid</a> für <a href="https://www.postgresql.org/docs/12/datatype-uuid.html" rel="nofollow">in PostgreSql integrierte</a> Primärschlüssel <a href="https://www.postgresql.org/docs/12/datatype-uuid.html" rel="nofollow">gewechselt</a> .  Das Schreiben in eine uuid-Spalte mit einem Index ist viel schneller als das Schreiben in eine Zeichenfolge. </p><br><p>  Danach habe ich alle unkritischen Indizes und Fremdschlüssel aufgegeben, da die Sorge um die Datenintegrität vollständig auf der Seite des FIAS-Teams liegt. </p><br><p> Dann habe ich die Speicheroberfläche überarbeitet, sodass das externe Skript es explizit über den Abschluss des Imports informieren kann.  Dies ermöglichte die Verwendung von Bulk-Insert, was die Aufnahme zeitweise beschleunigte.  <a href="https://www.postgresql.org/docs/current/populate.html" rel="nofollow">Auf der Suche nach Informationen</a> bin ich neben <a href="https://www.postgresql.org/docs/current/functions-xml.html" rel="nofollow"><code>query_to_xml</code></a> auch auf den Befehl <a href="https://www.postgresql.org/docs/current/sql-copy.html" rel="nofollow"><code>copy</code></a> <a href="https://www.postgresql.org/docs/current/functions-xml.html" rel="nofollow"><code>query_to_xml</code></a> .  Es hatte zwei große Nachteile: Erstens muss der PostgreSql-Benutzer über Leseberechtigungen für die Datei verfügen, die ich nicht garantieren kann, und zweitens ging die Möglichkeit verloren, die Daten im Skript vor dem Schreiben zu ändern. </p><br><p>  Trotz dieser Änderungen betrug die Importdauer mehr als 30 Stunden.  Eine radikale Änderung des Ansatzes war erforderlich. </p><br><h3 id="parallelnye-processy">  Parallele Prozesse </h3><br><p>  Das Internet ist voll mit Artikeln über Asynchronität in PHP.  Meine Wahl fiel auf <a href="https://amphp.org/" rel="nofollow">Amp</a> .  Es lief einfach nicht asynchron.  Erstens wurde der Code schnell zu einem furchterregenden Blatt mit Rückrufen und nicht offensichtlichen Anrufen (dies ist wahrscheinlich meine Schuld, nicht die asynchrone Vorgehensweise).  Zweitens musste ich auf die Verwendung von Standard-ORMs verzichten, da nicht blockierende Aufrufe der Datenbank über ein <a href="https://github.com/amphp/mysql" rel="nofollow">spezielles Framework</a> erforderlich sind.  Drittens, obwohl es Bedingungen gibt, unter denen PostgreSql Zeilen parallel einfügen kann, sind sie <a href="" rel="nofollow">äußerst</a> <a href="https://wiki.postgresql.org/wiki/Parallel_Query" rel="nofollow">schwierig zu</a> erfüllen.  Infolgedessen beobachtete ich nach 5 Stunden Arbeit, wie alle meine asynchronen Anforderungen auf der Datenbankseite zwangsweise "synchronisiert" wurden. </p><br><p>  Der Import ist jedoch gut in parallele Prozesse unterteilt: mehrere völlig unabhängige Aufgaben, die keine gemeinsamen Ressourcen haben, für die sie konkurrieren könnten, und Daten, die sie austauschen könnten.  Außerdem habe ich im Rahmen eines Threads einen schönen und linearen Code erhalten. </p><br><p>  Das erste Mal habe ich mich für die <a href="https://www.php.net/manual/ru/book.parallel.php" rel="nofollow">Parallel-</a> Erweiterung entschieden.  Es gibt einen schwerwiegenden Fehler: Der Interpreter muss mit Unterstützung für ZTS (Zend Thread Safety) erstellt werden.  Da ZTS in normalen Web-Skripten nicht funktioniert, müsste man zwei verschiedene Versionen des Interpreters haben.  Eine ohne ZTS für das Web, die zweite mit ZTS für die Installation von FIAS.  Die potenzielle Leistungssteigerung überwog diese Unannehmlichkeit, insbesondere angesichts der Tatsache, wie einfach es ist, einen neuen Docker-Container zusammenzubauen und in Verbindung mit dem alten zu verwenden.  Leider führte das Starten von Symfony in einem neuen Thread zum Überlauf des PHP-Stacks, und ich war nicht bereit, den DI-Container und die praktische Konfiguration abzulehnen. </p><br><p>  Schließlich fand ich den <a href="https://symfony.com/doc/current/components/process.html" rel="nofollow">Symfony-Prozess</a> .  Tatsächlich wird ein neuer Prozess für den angegebenen Konsolenbefehl gestartet und dessen Fertigstellung überwacht.  Ich musste zwei zusätzliche Ketten hinzufügen.  Der erste lädt das Archiv herunter, entpackt es und leitet parallele Prozesse zur Datenverarbeitung ein.  Der zweite Befehl entnimmt eine Liste von Dateien aus dem Befehlszeilenargument und schreibt deren Inhalt in die Datenbank. </p><br><p>  Aufgrund der mangelnden Erfahrung mit parallelen Prozessen habe ich anscheinend alle Anfängerfehler gemacht. </p><br><p>  Zum Beispiel hat mein Initiierungsprozess die Fertigstellung der Kinder in einer Endlosschleife überprüft, und natürlich hat er unangemessen viel Prozessorressourcen dafür ausgegeben.  Der Sleep-Aufruf zwischen den Iterationen half. </p><br><p>  In der ersten Implementierung wurden Dateien ungleichmäßig auf die Prozesse verteilt.  Die zwei größten fielen in einen Strom, der mehr als 20 Stunden lang verarbeitet wurde.  In der zweiten Implementierung habe ich einen speziellen Manager hinzugefügt, der Dateien basierend auf der Zeit verteilt, die zum Importieren erforderlich ist.  Jetzt werden die Prozesse gleichmäßig geladen. </p><br><p>  Nach diesen Änderungen konnte ich die Vollversion von FIAS in 16-20 Stunden importieren, abhängig von den Serverressourcen.  Nicht so gut, wie wir es uns wünschen, aber ich arbeite weiter an der Optimierung.  Der nächste Schritt ist eine vollständige Ablehnung von PostgreSql zugunsten von Elasticsearch. </p><br><h2 id="vyvody">  Schlussfolgerungen </h2><br><p>  War es das wert?  Zwei Jahre Arbeit an einer Bibliothek, die noch nie in ein Kampfprojekt geraten ist? </p><br><p>  Ja, vollständig. </p><br><p>  Ich habe trotzdem meinen Job gewechselt.  Während eines Rundgangs durch ein Dutzend Interviews beantwortete ich viele knifflige Fragen nur dank meines Lieblingsprojekts. </p><br><p>  Die Panik, die PHP im Sterben liegt, wird immer größer.  Ich werde die Tatsache nicht verbergen, dass ich selbst über die Migration in eine andere Sprache nachgedacht habe. </p><br><p>  Nachdem ich die enorme Arbeit gesehen hatte, die das PHP-Team in Version 7 gesteckt hatte;  er war durch persönliches Beispiel überzeugt, wie reif die Sprache wurde und wie reich das Ökosystem ist, das es gewachsen hat;  Ich kann mit Sicherheit sagen, dass die Gerüchte über den Tod von PHP stark übertrieben sind.  Und dies ist nur der Anfang: In Zukunft warten wir auf JIT, sofortige Asynchronität und vieles mehr. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de479122/">https://habr.com/ru/post/de479122/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de479102/index.html">Bekanntschaft mit Yandex.Maps oder Wie sehr ich Dokumentation liebe</a></li>
<li><a href="../de479106/index.html">Wie viel kosten Zaubertricks?</a></li>
<li><a href="../de479108/index.html">Ritterleben - Online-Arena mit RPG-Elementen</a></li>
<li><a href="../de479116/index.html">Impressionen bei der Suche Y. Direct: Warum Sie das 1,5-fache pro Klick bezahlen</a></li>
<li><a href="../de479120/index.html">Die Wahlbeteiligung ist gescheitert: Wir bringen AgentTesla zu sauberem Wasser. Teil 2</a></li>
<li><a href="../de479124/index.html">[Infografik] Künstliche Intelligenz in Science Fiction</a></li>
<li><a href="../de479126/index.html">Python in der mobilen Entwicklung</a></li>
<li><a href="../de479128/index.html">Wie funktioniert der medizinische Dienst am Flughafen?</a></li>
<li><a href="../de479132/index.html">Externe Komponente für 1C Mobile-Plattform (BroadcastReceiver)</a></li>
<li><a href="../de479136/index.html">Quantencomputer: das Ende der Blockchain?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>