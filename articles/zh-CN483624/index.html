<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛀🏼 👋🏿 🆖 Yandex.Taxi比赛：编程冠军赛的后端赛道分析 🧝🏿 👨🏾‍⚖️ 💤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="向后端赛道的参与者颁发奖品 
 我们正在完成对第二届编程冠军的一系列分析。 最近几周，我们发布了对以下三个方面的分析：ML，前端和移动开发。 仍然需要解析后端的轨道。 事实证明，最受欢迎的是：2682人参加了资格赛，其中320人进入了决赛。 Yandex.Taxi团队发明了后端开发人员的任务。 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Yandex.Taxi比赛：编程冠军赛的后端赛道分析</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/483624/"><img src="https://habrastorage.org/webt/za/i-/9x/zai-9xkajiamr99zrbldb0fstty.jpeg"><br><h5>  <sup><sub>向后端赛道的参与者颁发奖品</sub></sup> </h5><br> 我们正在完成对第二届编程冠军的一系列分析。 最近几周，我们发布了对以下三个方面的分析：ML，前端和移动开发。 仍然需要解析后端的轨道。 事实证明，最受欢迎的是：2682人参加了资格赛，其中320人进入了决赛。  Yandex.Taxi团队发明了后端开发人员的任务。 <br><a name="habracut"></a><br><h2> 火星促销代码 </h2>  <sup><i>作者：Maxim Pedchenko</i></sup> <br><div class="scrollable-table"><table><tbody><tr><td> 时间限制 </td><td>  1秒 </td></tr><tr><td> 内存限制 </td><td>  64兆字节 </td></tr><tr><td> 进入 </td><td> 标准输入或input.txt </td></tr><tr><td> 结论 </td><td> 标准输出或output.txt </td></tr></tbody></table></div> 自Yandex.Taxi在火星上发射以来已经过去了六个月。 在火星新年前，Yandex.Taxi决定向火星人提供促销代码。 但是事实证明，火星人无法使用地球促销代码，因为火星上的服务器无法按照地球规则工作。 因此，Yandex.Taxi提出了特殊的火星促销代码。 <br><br> 火星促销代码生成如下： <br><br><ol><li> 生成一个加密密钥。 </li><li> 加密密钥分为随机长度的子字符串。 </li><li> 在所有子串中，选择长度为L的子串。 </li><li> 选定的子字符串被混合并连接在一起。 </li><li> 串联的结果是促销代码。 </li></ol><br> 挑战： <br> 必须检查输入的促销代码是否有效。 如果促销代码有效，则需要打印“是”。 如果无效，则为“否”。 <br><br><div class="spoiler">  <b class="spoiler_title">I / O格式，示例和注释</b> <div class="spoiler_text"><h4> 输入格式 </h4><br>  &lt;促销代码长度&gt; <br>  &lt;促销代码&gt; <br><br>  &lt;密钥长度&gt; <br><br>  &lt;键&gt; <br><br>  &lt;子串长度L&gt; <br><br><h4> 输出格式 </h4><br> 促销代码有效期：是或否。 <br><br><h4> 例子1 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>进入</b> </td><td>  <b>结论</b> </td></tr><tr><td><code>6 <br> ABCDEA <br> 6 <br> EAABCD <br> 2</code> </td> <td> <code>YES</code> </td> </tr></tbody></table></div><h4> 例子2 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>进入</b> </td><td>  <b>结论</b> </td></tr><tr><td> <code>12 <br> MARS1234MARS <br> 24 <br> ASDGRV12MARSS1234VRCMARS <br> 4</code> </td> <td> <code>YES</code> </td> </tr></tbody></table></div><h4> 例子3 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>进入</b> </td><td>  <b>结论</b> </td></tr><tr><td> <code>12 <br> ABC123123ABC <br> 9 <br> ABC123123 <br> 3</code> </td> <td> <code>NO</code> </td> </tr></tbody></table></div><h4> 注意事项 </h4><br> 长度L&gt; 1。 <br> 促销代码字母[AZ，0-9]。 <br> 促销代码的长度在[6，30]范围内。 <br> 密钥长度在[6，30]范围内。 <br> 子串长度L &lt;密钥长度。 <br> 促销代码的长度是L的倍数。 </div></div><br><h4> 解决方案 </h4><br> 我们需要考虑将加密密钥的所有可能分区分成长度为L的子字符串，并检查此促销代码是否可以由可能的分区组成。 <br><br> 提示隐藏在条件注释中： <br><blockquote> 促销代码的长度在[6，30]范围内。 <br> 密钥长度在[6，30]范围内。 </blockquote><br> 较小的限制表明不需要有效的解决方案，这意味着您无需花费时间搜索优化-最好直接解决问题。 <br><br> 这种情况是产品后端开发的典型情况。 通常情况下，您可能需要花费数周的时间来研究最佳算法，但如果权衡了这些限制，很显然，最好使用快速而不是最佳的解决方案。 <br><br> 因此，我们将带有促销代码的行视为长度为L的子串S的序列。对于每个子串S，我们从加密密钥中找到与其相等的所有子串S <sub>k</sub> 。 对于每个S <sub>k，</sub>记住其用法，移至下一个子串S并重复该算法。 <br><br> 如果对于子字符串S不可能找到未使用的S <sub>k</sub> ，则有必要尝试另一种拆分方法，如果没有其他变量，则促销代码无效。 <br><br> 如果对于每个S至少有一种情况发现了S <sub>k</sub> ，则促销代码有效。 <br><br><h2> 火星运输系统优化 </h2>  <sup><i>作者：德米特里·波兰丘克（Dmitry Polishchuk）和安东·托杜（Anton Todua）</i></sup> <br><div class="scrollable-table"><table><tbody><tr><td> 时间限制 </td><td>  3秒 </td></tr><tr><td> 内存限制 </td><td>  64兆字节 </td></tr><tr><td> 进入 </td><td> 标准输入 </td></tr><tr><td> 结论 </td><td> 标准输出 </td></tr></tbody></table></div> 那是2058年。 最早的定居者殖民地已经登陆火星并开始在火星上居住，Yandex.Taxi开始部署穿梭站系统。 <br><br> 为了正常运行，穿梭站需要从能源网络持续供电。 要为电站供电，您必须在电站本身内部建造铀核能发生器，或将电缆铺设到另一个（已供电的）穿梭电站。 在不同的穿梭站内建造发电机的成本可能会有所不同。 穿梭站之间的电缆布线成本也不尽相同，而且并非总是可行。 电缆连接是双向的。 <br><br> 任务是为所有穿梭站组织高效（最低成本）的电力。 <br><br> 该程序在入口处接收穿梭站的总数，为每个穿梭站建造发电机的成本以及对穿梭站之间所有可能的电缆的描述（已连接站的数量和铺设电缆的成本）。 <br><br><div class="spoiler">  <b class="spoiler_title">I / O格式，示例和注释</b> <div class="spoiler_text"><h4> 输入格式 </h4><br>  <b>第一行</b>包含单个非负数的穿梭站N≤1000。 <br><br>  <b>第二行</b>包含N个数字，这些数字指定了在相应站点内构建发电机的成本。 <br><br>  <b>第三行在</b>穿梭站之间包含一个非负数的可能电缆K≤100000。 <br><br>  <b>接下来的K条线</b> （从第四<b>条</b>开始）包含对一根电缆的描述-三个整数非负数： <b>第一个站</b>的<b>数量，第二个站</b>的<b>数量</b>和实施<b>成本</b> 。 <br><br><h4> 输出格式 </h4><br> 对于给定的配置，所有往返站的最低电源成本为一个整数。 <br><br><h4> 例子1 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>进入</b> </td><td>  <b>结论</b> </td></tr><tr><td> <code>1 <br> 77 <br> 0</code> </td> <td> <code>77</code> </td> </tr></tbody></table></div><h4> 例子2 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>进入</b> </td><td>  <b>结论</b> </td></tr><tr><td> <code>2 <br> 11 29 <br> 1 <br> 1 2 17</code> </td> <td> <code>28</code> </td> </tr></tbody></table></div><h4> 注意事项 </h4><br> 工作站从一开始编号。 <br> 行内的数字用单个空格分隔。 <br> 不需要检查输入数据的正确性。 </div></div><br><h4> 解决方案 </h4><br> 首先，有必要从精美的描述变为无方向的加权图，在该图中，穿梭站的位置将出现峰顶，电缆将变成边缘，而建筑电缆的成本将变成相应边缘的权重。 但是问题仍然存在-如何考虑在车站（峰值）内部建造铀发生器的成本？ 这个问题的答案是问题的实质。 <br><br> 假设存在另一个顶点-能源，并且从该顶点到图形的每个顶点绘制一条边，其权重等于在相应站点（顶点）中建造铀发生器的成本。 这个假设使我们得到一个需要变成一棵树的连接图，以使图中的边的权重之和成为最小。 这无非是在图中找到最小生成树的问题。 您可以使用任何已知算法（例如Prima或Kraskal）构建最小生成树。 <br><br><div class="spoiler">  <b class="spoiler_title">带有注释的示例代码</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;tuple&gt; #include &lt;vector&gt; using Price = std::size_t; using Vertex = std::size_t; using Transition = std::tuple&lt;Price, Vertex, Vertex&gt;; using Graph = std::vector&lt;Transition&gt;; //        ( ). class Equals { public: //    . explicit Equals(std::size_t size) { equals_.resize(size); //     . for (std::size_t i = 0; i &lt; size; i++) { equals_[i] = i; } } //   v1  v2   true,    //      . bool Emplace(std::size_t v1, std::size_t v2) { while (v1 != v2) { if (v2 &lt; v1) { std::swap(v1, v2); } auto&amp; next_v2 = equals_[v2]; if (next_v2 == v2) { next_v2 = v1; return true; } v2 = next_v2; } return false; } private: std::vector&lt;size_t&gt; equals_; }; int main() { //   . std::size_t vertex_count = 0; std::cin &gt;&gt; vertex_count; if (vertex_count == 0) { std::cout &lt;&lt; 0 &lt;&lt; std::endl; return 0; } //    —   —   . vertex_count++; //  . Graph graph; graph.reserve(vertex_count); //       . for (Vertex i = 1; i &lt; vertex_count; i++) { Price price = 0; std::cin &gt;&gt; price; graph.emplace_back(price, 0, i); } //    . std::size_t edge_count = 0; std::cin &gt;&gt; edge_count; for (std::size_t i = 0; i &lt; edge_count; i++) { Price price = 0; Vertex from = 0, to = 0; std::cin &gt;&gt; from &gt;&gt; to &gt;&gt; price; graph.emplace_back(price, from, to); } //      . std::sort(graph.begin(), graph.end()); //      . // https://ru.wikipedia.org/wiki/_ Price result = 0; Equals equals{vertex_count}; for (const auto&amp; [price, from, to] : graph) { if (equals.Emplace(from, to)) { result += price; } } //  . std::cout &lt;&lt; result &lt;&lt; std::endl; return 0; }</span></span></span></span></code> </pre> </div></div><br><h2> 禁止停车 </h2>  <sup><i>作者：Ilya Mescherin和Artyom Serebriysky</i></sup> <br><div class="scrollable-table"><table><tbody><tr><td></td><td>  <b>所有语言</b> </td><td>  <b>Python 3.7.3和Python 2.7</b> </td></tr><tr><td> 时间限制 </td><td>  1秒 </td><td>  10秒 </td></tr><tr><td> 内存限制 </td><td colspan="2">  256兆字节 </td></tr><tr><td> 进入 </td><td colspan="2"> 标准输入或input.txt </td></tr><tr><td> 结论 </td><td colspan="2"> 标准输出或output.txt </td></tr></tbody></table></div> 在一个城市中，除登车外，禁止汽车停车。 乘客不同意等待超过3分钟。 在这个城市，行人命令出租车到达X点，并指出间隔为180秒。 驾驶员必须恰好在此间隔到达。 如果您提前到达，您将无法期待乘客。 如果您来不及，生气的乘客将取消订单。 <br><br> 由于这样的限制，只有Z个驾驶员留在了这个城市，每个人在任务开始时都处于流量图表的顶部。 控制系统应从设法到达指定时间间隔的人员中任命最佳驾驶员。 最好的驱动程序是在时间间隔的开始附近订购的驱动程序。 如果有几个这样的驱动程序，那么任何一个。 <br><br> 每个驾驶员有必要确定他是否有时间到达指示的时间间隔，如果是，则确定他可以在指示的时间间隔最早到达的时间。 <br><br>  <b>形式描述</b> <br><br> 鉴于： <br><br><ol><li> 定向图形G具有N个顶点和K个边，这些顶点的编号从0到N – 1，0≤N≤10 4，0≤K≤10 <sup>4</sup> 。 每个边沿都对应于其中的传播时间-整数W，10≤W≤10 <sup>4</sup> 。 </li><li> 订单在ID <sub>目标</sub>列上的排名。 </li><li> 驱动程序在IDsource列<sub>2</sub>中的Z位置，1≤Z≤10 <sup>4</sup> 。 </li><li> 时间t 0，0≤t0≤600是整数。 </li></ol><br> 每个驾驶员有必要找到这样的t <sub>min</sub> ： <br><br><ol><li> 从驾驶员IDsource <sub>z</sub>到ID <sub>target</sub>的路线有一条，使得驾驶员在t <sub>min</sub>到达， </li><li>  t min∈[t <sub>0</sub> ;  t <sub>0</sub> + 180]， </li><li> 这是最早的t <sub>min</sub> ：对于满足点1和2的任何t <sub>i</sub> ，t min≤t <sub>i</sub> </li><li> 或确保这样的t <sub>min</sub>不存在。 </li></ol><br><div class="spoiler">  <b class="spoiler_title">I / O格式，示例和注释</b> <div class="spoiler_text"><h4> 输入格式 </h4><br> 该图形以三元组-顶部-顶端-时间-旅行三元组的形式设置。 <br><br> 输入数据，每个项目单独一行： <br><br>  1. K是边数。 <br>  2. K的三倍ID ID重量-肋骨的初始顶点，肋骨的最终顶点，汽车驱动肋骨的量。 <br>  3. ID <sub>目标</sub> t <sub>0-</sub>需要到达时范围顶部的顺序[空格]。 <br>  4. Z-驱动程序数。 <br>  5.（Z倍）ID <sub>z是</sub>下一个驱动程序<sub>的</sub>顶部。 <br><br><h4> 输出格式 </h4><br> 对于每个驱动程序，按照它们输入的顺序，在单独的行上打印计算出的t <sub>min；</sub>如果不存在该t <sub>min</sub> ，则打印–1。 <br><br><h4> 例子1 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>进入</b> </td><td>  <b>结论</b> </td></tr><tr><td> <code>2 <br> 0 1 10 <br> 2 3 10 <br> 3 0 <br> 1 <br> 0</code> </td> <td> <code>-1</code> </td> </tr></tbody></table></div><h4> 例子2 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>进入</b> </td><td>  <b>结论</b> </td></tr><tr><td> <code>2 <br> 0 1 10 <br> 2 3 10 <br> 1 0 <br> 1 <br> 0</code> </td> <td> <code>10</code> </td> </tr></tbody></table></div><h4> 例子3 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>进入</b> </td><td>  <b>结论</b> </td></tr><tr><td> <code>1 <br> 0 1 10 <br> 1 100 <br> 1 <br> 0</code> </td> <td> <code>-1</code> </td> </tr></tbody></table></div><h4> 注意事项 </h4><br>  1.顶点A到顶点B可以有多个边，包括那些权重相同的边。 <br>  2.允许从A到A的肋骨。 <br>  3.允许同时存在边（A-&gt; B）和（B-&gt; A）（长度为2的循环）。 </div></div><br><h4> 解决方案 </h4><br>  <b>单驱动</b> <br><br> 首先，我们将分析一个驱动程序的简单情况。 肋骨的度量是[行驶时间]，光洁度的限制以相同单位表示，因此我们可以重新定义问题：“驾驶员根据图表从A点移至B点。 找到一条最小路径，使其长度位于线段[T，U]中。” <br><br> 最简单的方法是从A到B运行修改后的dijkstra： <br><br><ol><li> 修改1.假设我们从minQ处获得顶部，并且已经将其标记为黑色（也就是说，已经找到与其的最小距离）。 然后我们不忽略它，而是以标准方式处理它-将所有具有新距离的相邻顶点放回minQ中。 </li><li> 仅当到当前顶点的距离minQ严格大于U时，我们才停止它。 </li><li> 假设我们在遍历过程中遇到了峰值B，那么，如果当前距离≥T，请记住它作为答案R。在这一点上，dijkstra也可以被打断。 </li></ol><br> 因此，如果我们有R，这是长度在所需间隔内的最小路径。 <br><br>  <b>许多司机</b> <br><br> 前额的解决方案是为每个驱动程序运行一个算法。 但是，这种解决方案并不能通过限制时间来解决。 我们必须学会为O（1）的每个驱动器给出答案。 <br><br> 为此，我们为一个驱动程序修改了算法： <br><br><ol><li> 代替从驱动程序到订单点的dijkstra，我们根据带有倒置（！）边的图形从订单点开始dijkstra。 </li><li> 我们利用这样一个事实，即顶点的数量也限制为一万。 让我们得到一个答案数组R-对于每个顶点，这是可以从A到达[T，U]范围内的最短时间。 </li><li> 在遍历修改后的dijkstroy的图形的过程中，当我们遇到顶点j时，如果当前顶点与顶点j的距离在所需间隔[T，U]中，则输入R：R <sub>j</sub> = min（R <sub>j</sub> ，dist）。 </li></ol><br> 然后，对于顶点J处的每个驱动程序，可以查询R <sub>j以</sub>确定是否存在满足条件的路径及其长度。 <br><br>  <b>MinQ优化</b> <br><br> 路径长度始终是整数，并且从顶部开始一直限制为781-对于在t <sub>0</sub> = 600处执行的命令，驾驶员到达的最后一个有效秒数是780。在这种情况下，要实现dijkstra，您需要使用以下minQ实现。 <br><br> 我们有一个大小为[781]的边缘数组。 在边缘<sub>I的</sub>每个元素中，有一个unordered_set，用于存储路径长度为i的所有顶点的id。 <br><br>  1.添加一个距离为D的顶点： <br><br><pre> <code class="cpp hljs">fringe[D].insert(vertex);</code> </pre> <br>  2.根据条件，边缘的最小权重&gt;0。因此，您不必遍历整个minQ中的元素，而可以遍历整个切片： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; fringe.size(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fringe[i].empty()) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; vertex : fringe[i]) { <span class="hljs-comment"><span class="hljs-comment">// Do some stuff ProcessVertex(vertex, i); } }</span></span></code> </pre> <br><h2> 旅行费用计算器 </h2>  <sup><i>作者：尼古拉·菲尔琴科（Nikolay Filchenko）</i></sup> <br><div class="scrollable-table"><table><tbody><tr><td></td><td>  <b>所有语言</b> </td><td>  <b>Python 3.7.3和Python 2.7</b> </td></tr><tr><td> 时间限制 </td><td>  3秒 </td><td>  65℃ </td></tr><tr><td> 内存限制 </td><td>  64兆字节 </td><td>  256兆字节 </td></tr><tr><td> 进入 </td><td colspan="2"> 标准输入或input.txt </td></tr><tr><td> 结论 </td><td colspan="2"> 标准输出或output.txt </td></tr></tbody></table></div> 必须根据给定的公式计算出差旅费用。 每个行程均由K个整数参数表示。 该公式以相反的波兰语表示法给出。 <br><br> 允许的操作： <br><br><ul><li>  <b>+--</b>加减法； </li><li>  <b>* /</b> -乘法和整数除法； </li><li>  <b>&lt;=</b> -比较； </li><li>  <b>？</b>  -条件运算符。 如果第一个参数为true，则返回第二个参数，否则，返回第三个参数。 </li></ul><br> 公式<sup>中</sup>还使用了变量[az]和-10 <sup>9</sup>到10 <sup>9的</sup>整数。 <br><br> 我们可以假定公式中所有运算的结果绝对值不超过10 <sup>9</sup> 。 比较操作的结果仅用作条件运算符的参数。 <br><br><div class="spoiler">  <b class="spoiler_title">I / O格式和示例</b> <div class="spoiler_text"><h4> 输入格式 </h4><br> 在第一行，一个数字1≤K≤26-变量数。 <br><br> 第二行包含用于计算价格的公式（不超过3⋅104 <sup>个</sup>元素）。 所有元素都由空格分隔。 <br><br> 第三行，测试数为1≤N≤10 4。 <br><br> 接下来的N行各包含K个整数（–10 9≤v≤10 <sup>9</sup> ）-变量的值按字母顺序排列。 <br><br><h4> 输出格式 </h4><br>  N行包含一个整数-每组值的替换结果。 保证表达式的结果是有限的和定义的 <br><br><h4> 例子1 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>进入</b> </td><td>  <b>结论</b> </td></tr><tr><td> <code>1 <br> a 2 2 + * <br> 2 <br> 2 <br> 3</code> </td> <td> <code>8 <br> 12</code> </td> </tr></tbody></table></div><h4> 例子2 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>进入</b> </td><td>  <b>结论</b> </td></tr><tr><td> <code>2 <br> ab &lt; 5 14 ? <br> 2 <br> 10 5 <br> 5 10</code> </td> <td> <code>14 <br> 5</code> </td> </tr></tbody></table></div></div></div><br><h4> 解决方案 </h4><br> 这是需要认真执行和关注的任务。 解决方案中有两个要点： <br><br><ol><li> 原始表达式本身必须转换为数字和运算的数组，以免将字符串解析为每组变量。 </li><li> 必须记住，整数除以零会导致SIGFPE，因此在除法运算中，有必要明确检查分母是否不为零。 基于整个表达式结果的确定性和确定性的保证，我们可以理解：此类除法的结果不涉及最终结果，而是位于条件运算符的未使用分支中，因此您可以接受任何值（例如零）。 </li></ol><br><hr><br> 关于这个话题的争论： <br><br><ul><li>  <a href="https://habr.com/ru/company/yandex/blog/457262/">第一个冠军的后端轨迹分析</a> </li><li> 第二届冠军赛的汇报途径： <a href="https://habr.com/ru/company/yandex/blog/477452">ML</a> ， <a href="https://habr.com/ru/company/yandex/blog/478550/">前端</a> ， <a href="https://habr.com/ru/company/yandex/blog/482210/">移动开发</a> </li><li>  <a href="https://habr.com/ru/company/yandex/blog/464179/">Yandex.Taxi中的一个独立版本</a> ，或者您需要教后端开发人员什么 </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN483624/">https://habr.com/ru/post/zh-CN483624/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN483604/index.html">铱星：在家接收和解码卫星星座信号</a></li>
<li><a href="../zh-CN483608/index.html">可视化基于图像的分类器解决方案的边界</a></li>
<li><a href="../zh-CN483612/index.html">特斯拉司机因在自动驾驶仪上刷牙而被罚款</a></li>
<li><a href="../zh-CN483614/index.html">防止机器人俱乐部盗窃的方法</a></li>
<li><a href="../zh-CN483616/index.html">Lacmus项目：计算机视觉如何帮助挽救失去的人们</a></li>
<li><a href="../zh-CN483628/index.html">从OpenAPI v3（aka Swagger 3）到TypeScript的代码生成</a></li>
<li><a href="../zh-CN483630/index.html">灰烬时代-第130期</a></li>
<li><a href="../zh-CN483634/index.html">CSS中的最小和最大宽度/高度属性</a></li>
<li><a href="../zh-CN483646/index.html">哈克盒子-Bitlab演练。 弱JS混淆，GIT和反向Windows应用程序</a></li>
<li><a href="../zh-CN483648/index.html">佐治亚州IT业务的离岸市场：生活中的小事和陷阱</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>