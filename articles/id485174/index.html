<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🤝‍👨🏻 👨🏽‍🔬 👧🏿 Jenis bergantung Haskell: mengapa masa depan pengembangan perangkat lunak 🧘🏼 ♊️ 🚵🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di Serokell, kami tidak hanya terlibat dalam proyek komersial, tetapi juga berusaha untuk mengubah dunia menjadi lebih baik. Sebagai contoh, kami seda...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jenis bergantung Haskell: mengapa masa depan pengembangan perangkat lunak</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485174/"><p><img src="https://habrastorage.org/getpro/habr/post_images/fce/995/232/fce99523266b5bc548c3d1730c70b885.jpg"></p><br><p> Di Serokell, kami tidak hanya terlibat dalam proyek komersial, tetapi juga berusaha untuk mengubah dunia menjadi lebih baik.  Sebagai contoh, kami sedang berupaya meningkatkan alat utama semua Haskelists - Glasgow Haskell Compiler (GHC).  Kami fokus pada perluasan sistem tipe di bawah pengaruh karya Richard Eisenberg, <a href="https://github.com/goldfirere/thesis/blob/master/built/thesis.pdf" rel="nofollow">"Tipe Ketergantungan di Haskell: Teori dan Praktek</a> . <a href="https://github.com/goldfirere/thesis/blob/master/built/thesis.pdf" rel="nofollow">"</a> </p><br><p>  Di <a href="https://serokell.io/blog/why-dependent-haskell" rel="nofollow">blog kami,</a> Vladislav sudah berbicara tentang mengapa Haskell tidak memiliki tipe dependen dan bagaimana kami berencana untuk menambahkannya.  Kami memutuskan untuk menerjemahkan pos ini ke dalam bahasa Rusia sehingga sebanyak mungkin pengembang dapat menggunakan tipe dependen dan memberikan kontribusi lebih lanjut pada pengembangan Haskell sebagai bahasa. </p><a name="habracut"></a><br><h1 id="tekuschee-polozhenie-del">  Keadaan saat ini </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6d3/260/bba/6d3260bbad59d047ba6f10b1fffd5383.jpg" alt="Algoritma pemilihan bahasa pemrograman"></p><br><p>  Tipe dependen adalah yang paling saya rindukan di Haskell.  Mari kita bahas mengapa.  Dari kode yang kita inginkan: </p><br><ul><li>  kinerja, yaitu, kecepatan eksekusi dan konsumsi memori yang rendah; </li><li>  pemeliharaan dan kemudahan pemahaman; </li><li>  kebenaran dijamin dengan metode kompilasi itu. </li></ul><br><p>  Dengan teknologi yang ada, jarang mungkin untuk mencapai ketiga karakteristik, tetapi dengan dukungan untuk tipe-tipe yang bergantung pada Haskell, tugas ini disederhanakan. </p><br><h2 id="standartnyy-haskell-ergonomika--proizvoditelnost">  Haskell Standard: Ergonomi + Kinerja </h2><br><p>  Haskell didasarkan pada sistem sederhana: kalkulus lambda polimorfik dengan perhitungan malas, tipe data aljabar, dan kelas tipe.  Kombinasi fitur bahasa inilah yang memungkinkan kita untuk menulis kode yang elegan, didukung, dan produktif.  Untuk memperkuat klaim ini, kami membandingkan Haskell dengan bahasa yang lebih populer. </p><br><p>  Bahasa dengan akses memori yang tidak aman, seperti C, menyebabkan kesalahan dan kerentanan paling serius (misalnya, buffer overflows, kebocoran memori).  Kadang-kadang bahasa seperti itu dibutuhkan, tetapi paling sering penggunaannya adalah ide begitu-begitu. </p><br><p>  Bahasa akses memori yang aman membentuk dua kelompok: mereka yang mengandalkan pengumpul sampah, dan Rust.  Karat tampaknya unik dalam menawarkan <a href="https://pcwalton.github.io/2013/05/20/safe-manual-memory-management.html" rel="nofollow">akses aman ke memori tanpa pengumpulan sampah</a> .  Juga tidak ada lagi Siklon yang didukung dan bahasa riset lainnya dalam grup ini.  Tapi tidak seperti mereka, Rust sedang menuju popularitas.  Kerugiannya adalah bahwa meskipun ada keamanan, manajemen memori Rust bersifat non-sepele dan manual.  Dalam aplikasi yang mampu menggunakan pengumpul sampah, lebih baik menghabiskan waktu pengembang untuk tugas-tugas lain. </p><br><p>  Ada bahasa yang tersisa dengan pemulung, yang selanjutnya akan kami bagi menjadi dua kategori berdasarkan sistem tipenya. </p><br><p>  Bahasa yang diketik secara dinamis (atau lebih <a href="https://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/" rel="nofollow">monotip</a> ), seperti JavaScript atau Clojure, tidak memberikan analisis statis, dan karena itu tidak dapat memberikan tingkat kepercayaan yang sama dalam kebenaran kode (dan tidak, tes tidak dapat menggantikan jenis - Anda perlu keduanya) !). </p><br><p>  Bahasa yang diketik secara statis seperti Java atau Go seringkali memiliki sistem tipe yang sangat terbatas.  Ini memaksa pemrogram untuk menulis kode yang berlebihan dan menempatkan fitur bahasa yang tidak aman.  Misalnya, kurangnya tipe generik di Go memaksa penggunaan <a href="https://tour.golang.org/methods/14" rel="nofollow">antarmuka {}</a> dan <a href="https://golang.org/ref/spec" rel="nofollow">casting tipe runtime</a> .  Juga tidak ada pemisahan antara perhitungan dengan efek samping (input, output) dan perhitungan murni. </p><br><p>  Akhirnya, di antara bahasa-bahasa dengan akses memori aman, pengumpul sampah, dan sistem tipe yang kuat, Haskell menonjol karena malas.  <a href="https://augustss.blogspot.com/2011/05/more-points-for-lazy-evaluation-in.html" rel="nofollow">Komputasi malas</a> sangat berguna untuk menulis kode modular yang dapat disusun.  Mereka memungkinkan untuk terdekomposisi menjadi definisi tambahan setiap bagian dari ekspresi, termasuk konstruksi yang mendefinisikan aliran kontrol. </p><br><p>  Haskell tampaknya seperti bahasa yang hampir sempurna sampai Anda menyadari seberapa jauh dari mengeluarkan potensi penuh dalam hal verifikasi statis dibandingkan dengan alat bukti teorema seperti <a href="https://agda.readthedocs.io/en/latest/" rel="nofollow">Agda</a> . </p><br><p> Sebagai contoh sederhana di mana sistem tipe Haskell tidak cukup kuat, pertimbangkan operator <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html" rel="nofollow">pengindeksan daftar</a> dari <code>Prelude</code> (atau <a href="http://hackage.haskell.org/package/primitive-0.6.4.0/docs/Data-Primitive-Array.html" rel="nofollow">pengindeksan array</a> dari paket <code>primitive</code> ): </p><br><pre> <code class="haskell hljs">(!!) :: [a] -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; a indexArray :: <span class="hljs-type"><span class="hljs-type">Array</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; a</code> </pre> <br><p>  Tidak ada dalam tanda tangan jenis ini yang mencerminkan persyaratan bahwa indeks harus non-negatif dan kurang dari panjang koleksi.  Untuk perangkat lunak dengan persyaratan keandalan tinggi ini tidak dapat diterima. </p><br><h2 id="agda-ergonomika--korrektnost">  Agda: ergonomi + kebenaran </h2><br><p>  Sarana pembuktian teorema (misalnya, <a href="https://coq.inria.fr/" rel="nofollow">Coq</a> ) adalah alat perangkat lunak yang memungkinkan menggunakan komputer untuk mengembangkan bukti formal teorema matematika.  Bagi seorang ahli matematika, menggunakan alat seperti itu seperti menulis bukti di atas kertas.  Perbedaan dalam kekakuan yang belum pernah terjadi sebelumnya diperlukan oleh komputer untuk menetapkan validitas bukti tersebut. </p><br><p>  Untuk programmer, bagaimanapun, cara membuktikan teorema tidak begitu berbeda dari kompiler untuk bahasa pemrograman esoterik dengan sistem tipe yang luar biasa (dan mungkin lingkungan pengembangan terintegrasi), dan biasa-biasa saja (atau bahkan tidak ada) segalanya.  Sarana pembuktian teorema adalah, pada kenyataannya, bahasa pemrograman, yang penulis menghabiskan seluruh waktunya mengembangkan sistem pengetikan dan lupa bahwa program masih perlu dijalankan. </p><br><p>  Impian yang dihargai dari pengembang perangkat lunak yang diverifikasi adalah cara untuk membuktikan teorema, yang akan menjadi bahasa pemrograman yang baik dengan generator kode berkualitas tinggi dan runtime.  Dalam arah ini, termasuk pencipta <a href="https://www.idris-lang.org/" rel="nofollow">Idris</a> bereksperimen.  Tetapi ini adalah bahasa dengan perhitungan yang ketat (energetik), dan implementasinya saat ini tidak stabil. </p><br><p>  Di antara semua cara untuk membuktikan teorema, kaum Haskel dari Agda paling menyukai mereka.  Dalam banyak hal, ini mirip dengan Haskell, tetapi dengan sistem tipe yang lebih kuat.  Kami di Serokell menggunakannya untuk membuktikan berbagai properti dari program kami.  Kolega saya Dania Rogozin menulis <a href="https://serokell.io/blog/2018/11/14/logical-background" rel="nofollow">serangkaian artikel</a> tentang ini. </p><br><p>  Ini adalah tipe fungsi <a href="" rel="nofollow">pencarian yang</a> mirip dengan operator Haskell <code>(!!)</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">lookup</span></span> : ∀ (xs : <span class="hljs-type"><span class="hljs-type">List</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span>) → <span class="hljs-type"><span class="hljs-type">Fin</span></span> (length xs) → <span class="hljs-type"><span class="hljs-type">A</span></span></code> </pre> <br><p>  Parameter pertama di sini adalah tipe <code>List A</code> , yang sesuai dengan <code>[a]</code> di Haskell.  Namun, kami memberinya nama <code>xs</code> untuk merujuknya untuk sisa dari tipe tanda tangan.  Di Haskell, kita dapat mengakses argumen fungsi hanya di tubuh fungsi di level istilah: </p><br><pre> <code class="haskell hljs">(!!) :: [a] -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; a <span class="hljs-comment"><span class="hljs-comment">--   xs  (!!) = \xs i -&gt; ... --   xs </span></span></code> </pre> <br><p>  Tapi di Agda, kita bisa merujuk ke nilai <code>xs</code> ini di tingkat tipe, yang kita lakukan di parameter <code>lookup</code> kedua, <code>Fin (length xs)</code> .  Fungsi yang merujuk ke parameternya pada level tipe disebut <em>fungsi dependen</em> dan merupakan contoh tipe dependen. </p><br><p>  Parameter kedua dalam <code>lookup</code> adalah tipe <code>Fin n</code> untuk <code>n ~ length xs</code> .  Nilai tipe <code>Fin n</code> sesuai dengan angka dalam rentang <code>[0, n)</code> , jadi <code>Fin (length xs)</code> adalah angka non-negatif kurang dari panjang daftar input.  Inilah yang kami butuhkan untuk menyajikan indeks yang valid dari suatu item daftar.  Secara kasar, <code>lookup ["x","y","z"] 2</code> akan lulus pemeriksaan tipe, tetapi <code>lookup ["x","y","z"] 42</code> akan gagal. </p><br><p>  Ketika menjalankan program Agda, kita dapat mengkompilasinya di Haskell menggunakan <a href="http://wiki.portal.chalmers.se/agda/pmwiki.php%3Fn%3DDocs.MAlonzo" rel="nofollow">backend</a> MAlonzo.  Tetapi kinerja dari kode yang dihasilkan tidak memuaskan.  Ini bukan kesalahan MAlonzo: dia harus memasukkan banyak <code>unsafeCoerce</code> sehingga GHC <code>unsafeCoerce</code> kode yang sudah diverifikasi oleh Agda.  Tetapi <code>unsafeCoerce</code> sama <a href="https://dspace.library.uu.nl/bitstream/handle/1874/357868/3800296.pdf" rel="nofollow">mengurangi kinerja</a> <em>(setelah pembahasan artikel ini, ternyata masalah kinerja mungkin disebabkan oleh alasan lain - catatan penulis)</em> . </p><br><p>  Ini menempatkan kami pada posisi yang sulit: kami harus menggunakan Agda untuk pemodelan dan verifikasi formal, dan kemudian menerapkan kembali fungsi yang sama pada Haskell.  Dengan organisasi alur kerja ini, kode Agda kami bertindak sebagai spesifikasi yang diverifikasi komputer.  Ini lebih baik daripada spesifikasi dalam bahasa alami, tetapi jauh dari ideal.  Tujuannya adalah jika kode tersebut dikompilasi, maka ia akan bekerja sesuai dengan spesifikasi. </p><br><h2 id="haskell-s-rasshireniyami-korrektnost--proizvoditelnost">  Haskell dengan Extensions: Correctness + Performance </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/954/0e8/735/9540e8735ab539e67787046735ee5789.jpg"></p><br><p>  Bertujuan untuk jaminan statis bahasa dengan tipe dependen, GHC telah datang jauh.  Ekstensi ditambahkan padanya untuk meningkatkan ekspresi sistem tipe.  Saya mulai menggunakan Haskell ketika GHC 7.4 adalah versi terbaru dari kompiler.  Bahkan kemudian, ia memiliki ekstensi utama untuk pemrograman tingkat tipe lanjutan: <code>RankNTypes</code> , <code>GADTs</code> , <code>TypeFamilies</code> , <code>DataKinds</code> , dan <code>PolyKinds</code> . </p><br><p>  Namun demikian, masih belum ada tipe dependen lengkap di Haskell: tidak ada fungsi dependen (tipe)) maupun pasangan dependen (tipe Σ).  Di sisi lain, setidaknya kita memiliki penyandian untuk mereka! </p><br><p>  Praktek saat ini adalah sebagai berikut: </p><br><ul><li>  mengkodekan fungsi level type sebagai keluarga tipe privat, </li><li>  menggunakan fungsionalisasi untuk mengaktifkan fungsi tak jenuh, </li><li>  menjembatani kesenjangan antara istilah dan tipe menggunakan tipe tunggal. </li></ul><br><p>  Ini mengarah ke sejumlah besar kode berlebihan, tetapi perpustakaan <code>singletons</code> mengotomatiskan generasinya melalui Template Haskell. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/003/56f/e2a/00356fe2af43f034df850dbb556fb82f.jpg"></p><br><p>  Jadi yang paling berani dan paling menentukan adalah kode jenis-jenis yang bergantung pada Haskell sekarang.  Sebagai demonstrasi, berikut ini adalah implementasi dari fungsi <code>lookup</code> mirip dengan varian pada Agda: </p><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# OPTIONS -Wall -Wno-unticked-promoted-constructors -Wno-missing-signatures #-}</span></span> <span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE LambdaCase, DataKinds, PolyKinds, TypeFamilies, GADTs, ScopedTypeVariables, EmptyCase, UndecidableInstances, TypeSynonymInstances, FlexibleInstances, TypeApplications, TemplateHaskell #-}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> ListLookup <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Singletons.TH <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Singletons.Prelude singletons [d| data N = Z | SN len :: [a] -&gt; N len [] = Z len (<span class="hljs-title"><span class="hljs-title">_</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) = S (<span class="hljs-title"><span class="hljs-title">len</span></span> <span class="hljs-title"><span class="hljs-title">xs</span></span>) |] data Fin n where FZ :: Fin (<span class="hljs-type"><span class="hljs-type">S</span></span> <span class="hljs-title"><span class="hljs-title">n</span></span>) FS :: Fin n -&gt; Fin (<span class="hljs-type"><span class="hljs-type">S</span></span> <span class="hljs-title"><span class="hljs-title">n</span></span>) lookupS :: SingKind a =&gt; SList (<span class="hljs-title"><span class="hljs-title">xs</span></span> :: [<span class="hljs-title"><span class="hljs-title">a</span></span>]) -&gt; Fin (<span class="hljs-type"><span class="hljs-type">Len</span></span> <span class="hljs-title"><span class="hljs-title">xs</span></span>) -&gt; Demote a lookupS SNil = \case{} lookupS (<span class="hljs-type"><span class="hljs-type">SCons</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span> <span class="hljs-title"><span class="hljs-title">xs</span></span>) = \case FZ -&gt; fromSing x FS i' -&gt; lookupS xs i'</code> </pre> <br><p>  Dan di sini adalah sesi GHCi yang menunjukkan bahwa pencarian memang menolak indeks yang terlalu besar: </p><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">GHCi</span></span>, version <span class="hljs-number"><span class="hljs-number">8.6</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>: http://www.haskell.org/ghc/ :? for help [<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-type"><span class="hljs-type">Compiling</span></span> <span class="hljs-type"><span class="hljs-type">ListLookup</span></span> ( <span class="hljs-type"><span class="hljs-type">ListLookup</span></span>.hs, interpreted ) <span class="hljs-type"><span class="hljs-type">Ok</span></span>, one <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> loaded. *ListLookup&gt; :set -XTypeApplications -XDataKinds *ListLookup&gt; lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) FZ "x" *ListLookup&gt; lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>) "y" *ListLookup&gt; lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>)) "z" *ListLookup&gt; lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>))) &lt;interactive&gt;:5:34: error: • Couldn't match type ''S n0' with ''Z' Expected type: Fin (<span class="hljs-type"><span class="hljs-type">Len</span></span> '["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) Actual type: Fin ('<span class="hljs-type"><span class="hljs-type">S</span></span> ('<span class="hljs-type"><span class="hljs-type">S</span></span> ('<span class="hljs-type"><span class="hljs-type">S</span></span> ('<span class="hljs-type"><span class="hljs-type">S</span></span> <span class="hljs-title"><span class="hljs-title">n0</span></span>)))) • In the second argument of 'lookupS', namely '(<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>)))' In the expression: lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>))) In an equation for 'it': it = lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>)))</code> </pre> <br><p>  Contoh ini menunjukkan bahwa kelayakan tidak berarti praktis.  Saya senang bahwa Haskell memiliki kemampuan bahasa untuk mengimplementasikan <code>lookupS</code> , tetapi pada saat yang sama saya prihatin dengan kompleksitas yang tidak perlu yang muncul.  Di luar proyek penelitian, saya tidak akan merekomendasikan gaya kode seperti itu. </p><br><p>  Dalam kasus khusus ini, kita bisa mencapai hasil yang sama dengan kompleksitas yang lebih sedikit menggunakan vektor yang diindeks panjang.  Namun, terjemahan kode langsung dari Agda lebih baik mengungkapkan masalah yang harus Anda miliki dalam keadaan lain. </p><br><p>  Inilah beberapa di antaranya: </p><br><ul><li>  Relasi pengetikan <code>a :: t</code> dan relasi tujuan dari bentuk <code>t :: k</code> berbeda.  <code>5 :: Integer</code> benar dalam hal, tetapi tidak dalam jenis.  <code>"hi" :: Symbol</code> benar dalam tipe, tetapi tidak dalam istilah.  Ini mengharuskan <code>Demote</code> tipe <code>Demote</code> untuk memetakan tampilan dan tipe. </li><li>  Pustaka standar menggunakan <code>Int</code> sebagai representasi dari indeks daftar (dan <code>singletons</code> menggunakan <code>Nat</code> dalam definisi tinggi).  <code>Int</code> dan <code>Nat</code> adalah tipe non-induktif.  Meskipun lebih efisien daripada pengkodean bilangan asli, mereka tidak bekerja dengan baik dengan definisi induktif seperti <code>Fin</code> atau <code>lookupS</code> .  Karena itu, kami mendefinisikan ulang <code>length</code> sebagai <code>len</code> . </li><li>  Haskell tidak memiliki mekanisme bawaan untuk meningkatkan fungsi ke level tipe.  <code>singletons</code> mengkode mereka sebagai keluarga tipe pribadi dan menerapkan fungsionalisasi untuk menghindari kurangnya penggunaan sebagian dari keluarga tipe.  Pengkodean ini rumit.  Selain itu, kami harus memasukkan definisi <code>len</code> dalam kutipan Template Haskell sehingga para <code>singletons</code> menghasilkan mitra tingkat-jenisnya, <code>Len</code> . </li><li>  Tidak ada fungsi bawaan bawaan.  Kita harus menggunakan <a href="https://repository.brynmawr.edu/cgi/viewcontent.cgi%3Farticle%3D1009%26context%3Dcompsci_pubs" rel="nofollow">tipe unit</a> untuk menjembatani kesenjangan antara istilah dan tipe.  Alih-alih daftar yang biasa, kami meneruskan <code>SList</code> ke input pencarian.  Karena itu, kita harus mengingat beberapa definisi daftar sekaligus.  Ini juga mengarah ke overhead selama eksekusi program.  Mereka muncul karena konversi antara nilai biasa dan nilai tipe unit ( <code>toSing</code> , <code>fromSing</code> ) dan karena transfer prosedur konversi (pembatasan <code>SingKind</code> ). </li></ul><br><p>  Ketidaknyamanan adalah masalah yang lebih kecil.  Lebih buruk lagi, fitur bahasa ini tidak dapat diandalkan.  Misalnya, saya melaporkan masalah <a href="https://gitlab.haskell.org/ghc/ghc/issues/12564" rel="nofollow"># 12564</a> pada tahun 2016, dan ada juga <a href="https://gitlab.haskell.org/ghc/ghc/issues/12088" rel="nofollow"># 12088</a> di tahun yang sama.  Kedua masalah menghambat implementasi program yang lebih maju daripada contoh-contoh dari buku teks (seperti daftar pengindeksan).  Bug GHC ini masih belum diperbaiki, dan alasannya, menurut saya, adalah karena pengembang tidak punya cukup waktu.  Jumlah orang yang aktif bekerja di GHC ternyata sangat kecil, sehingga beberapa hal tidak dapat diatasi. </p><br><h2 id="rezyume">  Ringkasan </h2><br><p>  Saya sebutkan sebelumnya bahwa kami ingin ketiga properti dari kode, jadi di sini adalah tabel yang menggambarkan keadaan saat ini: </p><br><div class="scrollable-table"><table><thead><tr><th></th><th>  Haskell standar </th><th>  Agda </th><th>  Haskell dengan ekstensi </th></tr></thead><tbody><tr><td>  Ergonomi dan rawatan </td><td>  + </td><td>  + </td><td>  - </td></tr><tr><td>  Performa </td><td>  + </td><td>  - </td><td>  + </td></tr><tr><td>  Kebenaran dijamin oleh metode penyusunan </td><td>  - </td><td>  + </td><td>  + </td></tr></tbody></table></div><br><h1 id="svetloe-buduschee">  Masa depan yang cerah </h1><br><p>  Dari tiga opsi yang tersedia, masing-masing memiliki kekurangan.  Namun, kami dapat memperbaikinya: </p><br><ul><li>  Ambil Haskell standar dan tambahkan tipe dependen secara langsung alih-alih pengkodean yang tidak nyaman melalui <code>singletons</code> .  (Lebih mudah diucapkan daripada dilakukan.) </li><li>  Ambil Agda dan laksanakan penghasil kode efisien dan RTS untuk itu.  (Lebih mudah diucapkan daripada dilakukan.) </li><li>  Ambil Haskell dengan ekstensi, perbaiki bug, dan terus tambahkan ekstensi baru untuk menyederhanakan pengkodean tipe dependen.  (Lebih mudah diucapkan daripada dilakukan.) </li></ul><br><p>  Berita baiknya adalah ketiga opsi tersebut bertemu pada satu titik (dalam arti tertentu).  Bayangkan ekstensi terkecil dari Haskell standar yang menambahkan tipe dependen, dan karenanya, memungkinkan Anda untuk menjamin kebenaran kode dengan cara itu ditulis.  Kode agda dapat dikompilasi (dialihkan) ke bahasa ini tanpa <code>unsafeCoerce</code> .  Dan Haskell dengan ekstensi, dalam arti tertentu, merupakan prototipe bahasa ini yang belum selesai.  Sesuatu perlu ditingkatkan, dan sesuatu harus dihapus, tetapi pada akhirnya, kita akan mencapai hasil yang diinginkan. </p><br><h2 id="izbavlenie-ot-singletons">  Singkirkan <code>singletons</code> </h2><br><p>  Indikator kemajuan yang baik adalah penyederhanaan perpustakaan <code>singletons</code> .  Karena tipe dependen diterapkan di Haskell, penyelesaian dan penanganan khusus kasus khusus yang diimplementasikan dalam <code>singletons</code> tidak lagi diperlukan.  Pada akhirnya, kebutuhan akan paket ini akan hilang sepenuhnya.  Misalnya, pada tahun 2016, menggunakan ekstensi <code>-XTypeInType</code> saya <a href="https://github.com/goldfirere/singletons/pull/148/files" rel="nofollow">menghapus KProxy</a> dari <code>SingKind</code> dan <code>SomeSing</code> .  Perubahan ini dimungkinkan melalui penyatuan tipe dan tipe.  Bandingkan definisi lama dan baru: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kparam</span></span></span><span class="hljs-class"> ~ '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class">) =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kparam</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> kparam :: * fromSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> kparam toSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> kparam -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> kparam </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> ('</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kproxy</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sing</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> ('</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  Dalam definisi lama, <code>k</code> muncul secara eksklusif di posisi tampilan, di sebelah kanan anotasi bentuk <code>t :: k</code> .  Kami menggunakan <code>kparam :: KProxy k</code> untuk mentransfer <code>k</code> ke jenis. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> k </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> k :: * fromSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> k toSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> k -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> k </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> k </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> k where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sing</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> k</span></span></code> </pre> <br><p>  Dalam definisi baru, <code>k</code> bergerak bebas antara tampilan dan ketik posisi, jadi kita tidak lagi membutuhkan <code>KProxy</code> .  Alasannya adalah bahwa, dimulai dengan GHC 8.0, tipe dan tipe termasuk dalam kategori sintaksis yang sama. </p><br><p>  Ada tiga dunia yang sepenuhnya terpisah dalam Haskell standar: istilah, tipe, dan tampilan.  Jika Anda melihat kode sumber GHC 7.10, Anda dapat melihat <a href="" rel="nofollow">parser</a> terpisah untuk tampilan dan pemeriksaan terpisah.  GHC 8.0 tidak lagi memilikinya: <a href="" rel="nofollow">parser</a> dan <a href="" rel="nofollow">validasi</a> untuk tipe dan tampilan sudah umum. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d01/37e/387/d0137e3870470beb4b2aee56240926cf.jpg"></p><br><p>  Di Haskell with extensions, view hanyalah peran yang ada di: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">f</span></span> :: <span class="hljs-type"><span class="hljs-type">T</span></span> z -&gt; ... <span class="hljs-comment"><span class="hljs-comment">-- 'z'   g :: T (a :: z) -&gt; ... -- 'z'   h :: T z -&gt; T (a :: z) -&gt; ... -- 'z'   ,  </span></span></code> </pre> <br><p>  Dalam GHC 8.0-8.4, masih ada beberapa perbedaan antara resolusi nama dalam tipe dan tipe.  Tapi saya meminimalkan mereka ke GHC 8.6: Saya membuat ekstensi <code>StarIsType</code> dan memperkenalkan fungsionalitas <code>PolyKinds</code> di <code>PolyKinds</code> .  Perbedaan yang tersisa saya <a href="https://github.com/ghc/ghc/commit/8df24474d0194d28b8273c1539af05793156e23f" rel="nofollow">buat peringatan</a> untuk GHC 8.8, dan <a href="https://github.com/ghc/ghc/commit/5bc195b1fe788e9a900a15fbe473967850517c3e" rel="nofollow">sepenuhnya dihilangkan</a> dalam GHC 8.10 </p><br><p>  Apa langkah selanjutnya?  Mari kita lihat <code>SingKind</code> di versi <code>singletons</code> terbaru: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> k </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> k = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class">) | r -&gt; k fromSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sing</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> k toSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> k -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> k</span></span></code> </pre> <br><p>  Keluarga jenis <code>Demote</code> diperlukan untuk menjelaskan perbedaan antara relasi pengetikan <code>a :: t</code> dan relasi tujuan dari form <code>t :: k</code> .  Paling sering (untuk tipe data aljabar), <code>Demote</code> adalah pemetaan identitas: </p><br><ul><li> <code>type Demote Bool = Bool</code> </li> <li> <code>type Demote [a] = [Demote a]</code> </li> <li> <code>type Demote (Either ab) = Either (Demote a) (Demote b)</code> </li> </ul><br><p>  Karenanya, <code>Demote (Either [Bool] Bool) = Either [Bool] Bool</code> .  Pengamatan ini mendorong kami untuk membuat penyederhanaan berikut: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> k </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fromSing :: <span class="hljs-type"><span class="hljs-type">Sing</span></span> (a :: k) -&gt; k toSing :: k -&gt; <span class="hljs-type"><span class="hljs-type">SomeSing</span></span> k</code> </pre> <br><p>  <code>Demote</code> tidak diperlukan!  Dan, pada kenyataannya, ini akan bekerja dengan <code>Either [Bool] Bool</code> dan tipe data aljabar lainnya.  Namun dalam praktiknya, kita berurusan dengan tipe data non-aljabar: <code>Integer,</code> <code>Natural</code> , <code>Char</code> , <code>Text</code> , dan sebagainya.  Jika digunakan sebagai spesies, mereka tidak dihuni: <code>1 :: Natural</code> adalah benar pada tingkat istilah, tetapi tidak pada tingkat jenis.  Karena itu, kita berurusan dengan definisi seperti itu: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nat</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Natural</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Symbol</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Text</span></span></span></span></code> </pre> <br><p>  Solusi untuk masalah ini adalah membesarkan tipe primitif.  Misalnya, <code>Text</code> didefinisikan seperti ini: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- | A space efficient, packed, unboxed Unicode text type. data Text = Text {-# UNPACK #-} !Array -- payload (Word16 elements) {-# UNPACK #-} !Int -- offset (units of Word16, not Char) {-# UNPACK #-} !Int -- length (units of Word16, not Char) data Array = Array ByteArray# data Int = I# Int#</span></span></code> </pre> <br><p>  Jika kita menaikkan <code>ByteArray#</code> dan <code>Int#</code> ke level tipe, kita bisa menggunakan <code>Text</code> alih-alih <code>Symbol</code> .  Dengan melakukan hal yang sama dengan <code>Natural</code> dan mungkin beberapa tipe lainnya, Anda dapat menyingkirkan <code>Demote</code> , bukan? </p><br><p>  Sayangnya tidak.  Di atas, saya menutup mata untuk tipe data yang paling penting: fungsi.  Mereka juga memiliki contoh <code>Demote</code> khusus: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k1</span></span></span><span class="hljs-class"> ~&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k2</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> k1 -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> k2 </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> a ~&gt; b = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TyFun</span></span></span><span class="hljs-class"> ab -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TyFun</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span></span></code> </pre> <br><p>  <code>~&gt;</code> ini adalah tipe yang fungsi level-levelnya dikodekan dalam lajang berdasarkan keluarga tipe privat dan <a href="https://typesandkinds.wordpress.com/2013/04/01/defunctionalization-for-the-win/" rel="nofollow">fungsionalisasi</a> . </p><br><p>  Pada awalnya, mungkin tampak seperti ide yang baik untuk menggabungkan <code>~&gt;</code> dan <code>-&gt;</code> , karena keduanya berarti tipe (tipe) dari fungsi tersebut.  Masalahnya adalah bahwa <code>-&gt;</code> dalam posisi tipe dan <code>-&gt;</code> dalam posisi tampilan memiliki arti yang berbeda.  Pada level term, semua fungsi dari <code>a</code> ke <code>b</code> adalah tipe <code>a -&gt; b</code> .  Pada level type, hanya <em>konstruktor</em> dari <code>a</code> ke <code>b</code> yang bertipe <code>a -&gt; b</code> , tetapi mereka bukan sinonim dari tipe dan bukan tipe keluarga.  Untuk menyimpulkan tipe, GHC mengasumsikan bahwa <code>f ~ g</code> dan <code>a ~ b</code> mengikuti dari <code>fa ~ gb</code> , yang berlaku untuk konstruktor, tetapi tidak untuk fungsi - itu sebabnya ada batasan. </p><br><p>  Oleh karena itu, untuk meningkatkan fungsi ke level tipe, tetapi untuk mempertahankan inferensi tipe, kita harus memindahkan konstruktor ke tipe yang berbeda.  Kami menyebutnya <code>a :-&gt; b</code> , karena akan benar bahwa <code>f ~ g</code> dan <code>a ~ b</code> mengikuti dari <code>fa ~ gb</code> .  Fungsi lainnya masih berupa tipe <code>a -&gt; b</code> .  Misalnya, <code>Just :: a :-&gt; Maybe a</code> , tetapi pada saat yang sama <code>isJust :: Maybe a -&gt; Bool</code> . </p><br><p>  Ketika <code>Demote</code> selesai, langkah terakhir adalah menyingkirkan <code>Sing</code> itu sendiri.  Untuk melakukan ini, kita memerlukan kuantifier baru, hibrida antara <code>forall</code> dan <code>-&gt;</code> .  Mari kita lihat lebih dekat fungsi isJust: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">isJust</span></span> :: <span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> a. <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> isJust = \x -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> _ -&gt; <span class="hljs-type"><span class="hljs-type">True</span></span></code> </pre> <br><p>  Fungsi <code>isJust</code> diparameterisasi dengan tipe <code>a</code> dan kemudian dengan nilai <code>x :: Maybe a</code> .  Dua parameter ini memiliki sifat yang berbeda: </p><br><ul><li>  Kesederhanaan  Dalam <code>isJust (Just "hello")</code> , kita meneruskan <code>x = Just "hello"</code> secara eksplisit, dan <code>a = String</code> secara implisit dihasilkan oleh kompiler.  Di Haskell modern, kita juga dapat memaksa lewat eksplisit dari kedua parameter: <code>isJust @String (Just "hello")</code> . </li><li>  Relevansi  Nilai yang diteruskan ke input ke <code>isJust</code> dalam kode akan ditransmisikan selama pelaksanaan program: kami melakukan perbandingan dengan sampel menggunakan <code>case</code> untuk memeriksa apakah itu tidak <code>Nothing</code> atau <code>Just</code> .  Karena itu, nilainya dianggap relevan.  Tetapi tipenya dihapus dan tidak dapat dibandingkan dengan polanya: fungsi menangani <code>Maybe Int</code> , <code>Maybe String</code> , <code>Maybe Bool</code> , dll.  Karena itu, dianggap tidak relevan.  Properti ini juga disebut parametrik. </li><li>  Kecanduan.  Secara keseluruhan <code>forall a. t</code>  <code>forall a. t</code> , tipe <code>t</code> dapat merujuk ke <code>a</code> , dan oleh karena itu, tergantung pada yang dilalui tertentu  Sebagai contoh, <code>isJust @String</code> adalah tipe <code>Maybe String -&gt; Bool</code> , dan <code>isJust @Int</code> adalah tipe <code>Maybe Int -&gt; Bool</code> .  Ini berarti <code>forall</code> adalah <code>forall</code> dependen.  Perhatikan perbedaan dengan parameter nilai: tidak masalah apakah kita memanggil <code>isJust Nothing</code> atau <code>isJust (Just …)</code> , tipe hasilnya selalu <code>Bool</code> .  Oleh karena itu, <code>-&gt;</code> adalah penjumlah independen. </li></ul><br><p>  Untuk mengeluarkan <code>Sing</code> , kita membutuhkan quantifier yang eksplisit dan relevan, seperti <code>a -&gt; b</code> , dan pada saat yang sama bergantung, seperti <code>forall (a :: k). t</code>  <code>forall (a :: k). t</code> .  Nyatakan sebagai <code>foreach (a :: k) -&gt; t</code> .  Untuk mengeluarkan <code>SingI</code> , kami juga memperkenalkan quantifier dependen relevan yang relevan, <code>foreach (a :: k). t</code>  <code>foreach (a :: k). t</code> .  Akibatnya, <code>singletons</code> tidak diperlukan karena kami baru saja menambahkan fungsi dependen ke bahasa. </p><br><h2 id="kratkiy-vzglyad-na-haskell-s-zavisimymi-tipami">  Sekilas tentang Haskell dengan tipe dependen </h2><br><p>  Dengan naiknya fungsi ke tingkat tipe dan kuantifikasi <code>foreach</code> , kita dapat menulis ulang <code>lookupS</code> sebagai berikut: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">N</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Z</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SN</span></span></span><span class="hljs-class"> len :: [a] -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">N</span></span></span><span class="hljs-class"> len [] = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Z</span></span></span><span class="hljs-class"> len (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class">:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">len</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fin</span></span></span><span class="hljs-class"> n where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FZ</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fin</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">n</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FS</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fin</span></span></span><span class="hljs-class"> n -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fin</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">n</span></span></span><span class="hljs-class">) lookupS :: foreach (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class"> :: [</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">]) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fin</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">len</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class">) -&gt; a lookupS [] = \case{} lookupS (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class">) = \case </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FZ</span></span></span><span class="hljs-class"> -&gt; x </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FS</span></span></span><span class="hljs-class"> i' -&gt; lookupS xs i'</span></span></code> </pre> <br><p>  Singkatnya, kodenya tidak, namun <code>singletons</code> cukup pandai menyembunyikan kode mubazir.  Namun, kode baru ini jauh lebih sederhana: tidak ada lagi <code>Demote</code> , <code>SingKind</code> , <code>SList</code> , <code>SNil</code> , <code>fromSing</code> , <code>fromSing</code> .  Tidak ada penggunaan <code>TemplateHaskell</code> , karena sekarang kita dapat memanggil fungsi <code>len</code> secara langsung alih-alih membuat keluarga tipe <code>Len</code> .  Kinerja juga akan lebih baik, karena Anda tidak perlu lagi mengkonversi <code>fromSing</code> . </p><br><p>  Kita masih harus mendefinisikan ulang <code>length</code> sebagai <code>len</code> untuk mengembalikan <code>N</code> didefinisikan secara induktif daripada <code>Int</code> .  Mungkin masalah ini tidak boleh dipertimbangkan dalam kerangka menambahkan tipe dependen ke Haskell, karena Agda juga menggunakan <code>N</code> didefinisikan secara induktif dalam fungsi <code>lookup</code> . </p><br><p>  Dalam beberapa aspek, Haskell dengan tipe dependen bahkan lebih sederhana daripada Haskell standar.  Namun, dalam istilah itu, tipe dan tipe digabungkan menjadi satu bahasa yang seragam.  Saya dapat dengan mudah membayangkan menulis kode dalam gaya ini dalam proyek komersial untuk secara resmi membuktikan kebenaran komponen kunci aplikasi.  Banyak perpustakaan Haskell dapat menyediakan antarmuka yang lebih aman tanpa kerumitan <code>singletons</code> . </p><br><p>  Ini tidak akan mudah dicapai.  Kami dihadapkan dengan banyak masalah teknik yang mempengaruhi semua komponen GHC: parser, resolusi nama, pengecekan tipe, dan bahkan bahasa Core.  Semuanya perlu dimodifikasi, atau bahkan sepenuhnya didesain ulang. </p><br><hr><br><h1 id="tezaurus">  Tesaurus </h1><br><div class="scrollable-table"><table><tbody><tr><td>  <strong>Term</strong> <br></td><td>  <strong>Terjemahan</strong> <br></td><td>  <strong>Penjelasan</strong> <br></td></tr><tr><td> correct by construction <br></td><td> ,       <br></td><td>  ,         (,   ),   . <br></td></tr><tr><td> memory unsafe <br></td><td>      <br></td><td>         ,    . <br></td></tr><tr><td> unityped <br></td><td>  <br></td><td> ,   Bob Harper     ,    .           . <br></td></tr><tr><td> boilerplate <br></td><td>   <br></td><td>       ,    -   . <br></td></tr><tr><td> generics <br></td><td>   <br></td><td>       . ,     «»  «»,     ,    &lt;&gt;  &lt;&gt;. <br></td></tr><tr><td> runtime cast <br></td><td>     <br></td><td>              . <br></td></tr><tr><td> effectful computation <br></td><td>     <br></td><td> ,          . <br></td></tr><tr><td> composable <br></td><td>  <br></td><td>  ,          . <br></td></tr><tr><td> control structures <br></td><td> ,    <br></td><td>  ,       . <br></td></tr><tr><td> proof assistant <br></td><td>    <br></td><td>       . <br></td></tr><tr><td> strict (eager) evaluation <br></td><td>  ()  <br></td><td>   ,         . <br></td></tr><tr><td> backend <br></td><td>  <br></td><td>  ,         . <br></td></tr><tr><td> singleton type <br></td><td>   <br></td><td> ,   ,       . <br></td></tr><tr><td> promoted definitions <br></td><td>   <br></td><td>    ,         . <br></td></tr></tbody></table></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id485174/">https://habr.com/ru/post/id485174/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id485158/index.html">Nikolay Vavilov. Pria yang ingin memberi makan seluruh dunia dan meninggal karena kelaparan di sel penjara</a></li>
<li><a href="../id485160/index.html">Apa yang saya dalam ACID atau perspektif yang berbeda</a></li>
<li><a href="../id485162/index.html">Bagaimana komentar kode berkembang dari tahun 1940-an hingga 2020</a></li>
<li><a href="../id485164/index.html">Transformer dan Benci di Vancouver: Bagaimana Anti-Plagiarisme Mengendarai NeurIPS-2019</a></li>
<li><a href="../id485172/index.html">Masalah arsitektur dalam proyek besar</a></li>
<li><a href="../id485176/index.html">Enam skema untuk membantu menjelaskan konsep manajemen produk</a></li>
<li><a href="../id485178/index.html">Metodologi untuk rekonstruksi bangunan yang hilang dari foto</a></li>
<li><a href="../id485180/index.html">Apakah kita memerlukan data lake? Apa yang harus dilakukan dengan data warehouse?</a></li>
<li><a href="../id485182/index.html">Sennheiser pada tahun 2020 - headphone nirkabel yang diperbarui untuk peringatan tersebut</a></li>
<li><a href="../id485184/index.html">Hasil Jajak Pendapat Tab</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>