<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÖüèº üò¥ üíæ Cr√©er un effet de distribution des couleurs dans Unity üë®‚Äçüë©‚Äçüëß‚Äçüë¶ üòÉ ü•à</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet effet a √©t√© inspir√© par l' √©pisode de Powerpuff Girls . Je voulais cr√©er l'effet de la propagation de la couleur dans un monde en noir et blanc, m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cr√©er un effet de distribution des couleurs dans Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436456/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ia/i5/in/iai5inmdx06iz81yoz8pu_2oyui.gif"></div><br>  Cet effet a √©t√© inspir√© par l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©pisode de Powerpuff Girls</a> .  Je voulais cr√©er l'effet de la propagation de la couleur dans un monde en noir et blanc, mais l' <strong>impl√©menter dans les coordonn√©es de l'espace mondial</strong> , pour voir comment la <strong>couleur peint les objets</strong> , et pas seulement s'√©taler √† plat sur l'√©cran, comme dans un dessin anim√©. <br><br>  J'ai cr√©√© l'effet dans le nouveau <strong>pipeline de rendu l√©ger du</strong> moteur Unity, un exemple int√©gr√© du pipeline de rendu scriptable.  Tous les concepts s'appliquent √† d'autres pipelines, mais certaines fonctions ou matrices int√©gr√©es peuvent avoir des noms diff√©rents.  J'ai √©galement utilis√© la nouvelle pile de post-traitement, mais dans le didacticiel, j'omettre une description d√©taill√©e de ses param√®tres, car elle est assez bien d√©crite dans d'autres manuels, par exemple, dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette vid√©o</a> . <br><a name="habracut"></a><br><hr><br><h1>  L'effet du post-traitement en niveaux de gris </h1><br>  Juste pour r√©f√©rence, voici √† quoi ressemble une sc√®ne sans effets de post-traitement. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43b/283/6ad/43b2836ad62ee59df7efdd98494d0140.png"></div><br>  Pour cet effet, j'ai utilis√© le nouveau package de post-traitement Unity 2018, qui peut √™tre t√©l√©charg√© depuis le gestionnaire de packages.  Si vous ne savez pas comment l'utiliser, alors je recommande <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce tutoriel</a> . <br><br>  J'ai √©crit mon propre effet en √©tendant les classes PostProcessingEffectSettings et PostProcessEffectRenderer √©crites en C #, dont le code source peut √™tre vu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  En fait, je n'ai rien fait de particuli√®rement int√©ressant avec ces effets c√¥t√© CPU (en code C #) sauf que j'ai ajout√© un groupe de propri√©t√©s g√©n√©rales √† l'inspecteur, donc je ne vais pas expliquer comment faire cela dans le tutoriel.  J'esp√®re que mon code parle de lui-m√™me. <br><br>  Passons au code de shader et commen√ßons par l'effet de niveaux de gris.  Dans le tutoriel, nous ne modifierons pas le fichier shaderlab, les structures d'entr√©e et le vertex shader, vous pouvez donc voir leur code source <a href="">ici</a> .  Au lieu de cela, nous nous occuperons du fragment shader. <br><br>  Pour convertir une couleur en niveaux de gris, nous <strong>r√©duisons la valeur de chaque pixel √† une valeur de luminance</strong> qui d√©crit sa <strong>luminosit√©</strong> .  Cela peut √™tre fait en prenant le produit scalaire de <strong>la valeur de couleur de la texture de la cam√©ra</strong> et du <strong>vecteur pond√©r√©</strong> , qui d√©crit la contribution de chaque canal de couleur √† la luminosit√© globale des couleurs. <br><br>  <strong>Pourquoi utilisons-nous un produit scalaire?</strong>  N'oubliez pas que les produits scalaires sont calcul√©s comme suit: <br><br> <code>dot(a, b) = a <sub>x</sub> * b <sub>x</sub> + a <sub>y</sub> * b <sub>y</sub> + a <sub>z</sub> * b <sub>z</sub></code> <br> <br>  Dans ce cas, nous multiplions chaque canal de <strong>la valeur de couleur</strong> par le <strong>poids</strong> .  Ensuite, nous ajoutons ces produits pour les r√©duire √† une seule valeur scalaire.  Lorsque la couleur RVB a les m√™mes valeurs dans les canaux R, G et B, la couleur devient grise. <br><br>  Voici √† quoi ressemble le code du shader: <br><br><pre> <code class="cpp hljs">float4 fullColor = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.screenPos); float3 weight = float3(<span class="hljs-number"><span class="hljs-number">0.299</span></span>, <span class="hljs-number"><span class="hljs-number">0.587</span></span>, <span class="hljs-number"><span class="hljs-number">0.114</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> luminance = dot(fullColor.rgb, weight); float3 greyscale = luminance.xxx; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float4(greyscale, <span class="hljs-number"><span class="hljs-number">1.0</span></span>);</code> </pre> <br>  Si le shader de base est correctement configur√©, l'effet de post-traitement doit colorer tout l'√©cran en niveaux de gris. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/596/217/fc5/596217fc5e9caed9176480f1f9eb2bb1.png"></div><br><hr><br><h1>  Effet de rendu des couleurs dans l'espace mondial </h1><br>  Comme il s'agit d'un effet de post-traitement, <strong>nous n'avons aucune information sur la g√©om√©trie de la</strong> sc√®ne dans le vertex shader.  Au stade du post-traitement, les seules informations dont nous disposons sont l' <strong>image rendue par la cam√©ra</strong> et l' <strong>espace des coordonn√©es tronqu√©es</strong> pour l'√©chantillonner.  Cependant, nous voulons que l'effet de coloration se r√©pande sur les objets, comme s'il se produisait dans le monde, et pas seulement sur un √©cran plat. <br><br>  Pour dessiner cet effet dans la g√©om√©trie de la sc√®ne, nous avons besoin des <strong>coordonn√©es de l'espace monde de</strong> chaque pixel.  Pour passer des <strong>coordonn√©es de l'espace des coordonn√©es tronqu√©es</strong> aux <strong>coordonn√©es de l'espace mondial</strong> , nous devons effectuer une <strong>transformation de l'espace des coordonn√©es</strong> . <br><br>  Habituellement, pour passer d'un espace de coordonn√©es √† un autre, une matrice est n√©cessaire qui d√©finit la transformation de l'espace de coordonn√©es A vers l'espace B.Pour passer de A √† B, nous multiplions le vecteur dans l'espace de coordonn√©es A par cette matrice de transformation.  Dans notre cas, nous allons effectuer la transition suivante: l' <strong>espace des coordonn√©es tronqu√©es (espace clip)</strong> -&gt; l' <strong>espace vue (espace vue)</strong> -&gt; l' <strong>espace monde (espace monde)</strong> .  Autrement dit, nous avons besoin de la matrice clip-to-view-space et de la matrice view-to-world-space fournies par Unity. <br><br>  Cependant, les <strong>coordonn√©es Unity de l'espace de coordonn√©es tronqu√© n'ont pas de valeur z</strong> qui d√©termine la profondeur du pixel ou la distance √† la cam√©ra.  Nous avons besoin de cette valeur pour passer de l'espace des coordonn√©es tronqu√©es √† l'espace des esp√®ces.  Commen√ßons par √ßa! <br><br><h2>  Obtention de la valeur du tampon de profondeur </h2><br>  Si le pipeline de rendu est activ√©, il dessine une texture dans la <strong>fen√™tre</strong> qui stocke <strong>les valeurs z</strong> dans une structure appel√©e <strong>tampon de profondeur</strong> .  Nous pouvons √©chantillonner ce tampon pour obtenir la <strong>valeur z</strong> manquante <strong>de</strong> notre espace de coordonn√©es de coordonn√©es tronqu√©es! <br><br>  Tout d'abord, assurez-vous que le <strong>tampon de profondeur est</strong> r√©ellement rendu en cliquant sur la section ¬´Ajouter des donn√©es suppl√©mentaires¬ª de la cam√©ra dans l'inspecteur et en v√©rifiant que la case ¬´Texture de profondeur requise¬ª est coch√©e.  Assurez-vous √©galement que l'option Autoriser MSAA est activ√©e pour la cam√©ra.  Je ne sais pas pourquoi cet effet doit √™tre v√©rifi√©, mais √ßa l'est.  Si le tampon de profondeur est dessin√©, alors dans le <strong>d√©bogueur de trame,</strong> vous devriez voir l'√©tape <strong>¬´Depth Prepass¬ª</strong> . <br><br>  Cr√©er un √©chantillonneur _CameraDepthTexture dans le <strong>fichier hlsl</strong> <br><br><pre> <code class="cpp hljs">TEXTURE2D_SAMPLER2D(_CameraDepthTexture, sampler_CameraDepthTexture);</code> </pre> <br>  √âcrivons maintenant la fonction GetWorldFromViewPosition et pour l'instant nous allons l'utiliser pour v√©rifier <strong>le tampon de profondeur</strong> .  (Plus tard, nous allons l'√©tendre pour obtenir une position dans le monde.) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWorldFromViewPosition</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VertexOutput i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> z = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, sampler_CameraDepthTexture, i.screenPos).r; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> z.xxx; }</code> </pre> <br>  Dans le fragment shader, tracez la valeur de l'√©chantillon de texture de profondeur. <br><br><pre> <code class="cpp hljs">float3 depth = GetWorldFromViewPosition(i); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float4(depth, <span class="hljs-number"><span class="hljs-number">1.0</span></span>);</code> </pre> <br>  Voici √† quoi ressemblent mes r√©sultats quand il n'y a qu'une seule plaine vallonn√©e dans la sc√®ne (j'ai d√©sactiv√© tous les arbres afin de simplifier davantage le test des valeurs de l'espace mondial).  Votre r√©sultat devrait ressembler.  Les valeurs en noir et blanc d√©crivent la distance entre la g√©om√©trie et la cam√©ra. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b10/6b6/5cc/b106b65cc3d1441aacd5042ee21b25a6.png"></div><br>  Voici quelques √©tapes √† suivre si vous rencontrez des probl√®mes: <br><br><ul><li>  Assurez-vous que le rendu en profondeur de la cam√©ra est activ√©. </li><li>  Assurez-vous que la cam√©ra a activ√© MSAA. </li><li>  Essayez de changer le plan proche et √©loign√© de la cam√©ra. </li><li>  Assurez-vous que les objets que vous pr√©voyez de voir dans le tampon de profondeur utilisent un shader avec une passe de profondeur.  Cela garantit que l'objet dessine dans le tampon de profondeur.  Tous les shaders standard de LWRP le font. </li></ul><br><h2>  Obtenir de la valeur dans l'espace mondial </h2><br>  Maintenant que nous avons toutes les informations n√©cessaires pour l' <strong>espace des coordonn√©es tronqu√©es</strong> , passons √† l' <strong>espace des esp√®ces</strong> , puis √† l' <strong>espace</strong> du <strong>monde</strong> . <br><br>  Notez que les matrices de transformation requises pour ces op√©rations sont d√©j√† dans la biblioth√®que SRP.  Cependant, ils sont contenus dans la biblioth√®que C # du moteur Unity, je les ai donc ins√©r√©s dans le shader de la fonction Render du script <a href="">ColorSpreadRenderer</a> : <br><br><pre> <code class="cpp hljs">sheet.properties.SetMatrix(<span class="hljs-string"><span class="hljs-string">"unity_ViewToWorldMatrix"</span></span>, context.camera.cameraToWorldMatrix); sheet.properties.SetMatrix(<span class="hljs-string"><span class="hljs-string">"unity_InverseProjectionMatrix"</span></span>, projectionMatrix.inverse);</code> </pre> <br>  √âtendons maintenant notre fonction GetWorldFromViewPosition. <br><br>  Tout d'abord, nous devons obtenir la position dans la fen√™tre en <strong>multipliant la position dans l'espace de coordonn√©es tronqu√© par InverseProjectionMatrix</strong> .  Nous devons √©galement faire un peu plus de magie vaudou avec une position √† l'√©cran, qui est li√©e √† la fa√ßon dont Unity stocke sa position dans l'espace des coordonn√©es tronqu√©es. <br><br>  Enfin, nous pouvons <strong>multiplier la position dans la fen√™tre d'affichage par ViewToWorldMatrix</strong> pour obtenir la position dans l' <strong>espace mondial</strong> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWorldFromViewPosition</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VertexOutput i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    float z = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, sampler_CameraDepthTexture, i.screenPos).r; //      float4 result = mul(unity_InverseProjectionMatrix, float4(2*i.screenPos-1.0, z, 1.0)); float3 viewPos = result.xyz / result.w; //      float3 worldPos = mul(unity_ViewToWorldMatrix, float4(viewPos, 1.0)); return worldPos; }</span></span></code> </pre> <br>  Faisons une v√©rification pour nous assurer que les positions dans l'espace global sont correctes.  Pour ce faire, j'ai √©crit un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">shader</a> qui ne renvoie que la position d'un objet dans l' <strong>espace mondial</strong> ;  il s'agit d'un calcul assez simple bas√© sur un shader r√©gulier, dont l'exactitude peut √™tre fiable.  D√©sactivez l'effet du post-traitement et prenez une capture d'√©cran de ce shader de test pour l' <strong>espace mondial</strong> .  Mon apr√®s avoir appliqu√© le shader √† la surface de la terre dans la sc√®ne ressemble √† ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a91/4f2/b78/a914f2b787501e385ef27746865429bd.png"></div><br>  (Notez que les valeurs dans l'espace mondial sont beaucoup plus grandes que 1,0, alors ne vous inqui√©tez pas que ces couleurs aient un sens; au lieu de cela, assurez-vous simplement que les r√©sultats sont les m√™mes pour les r√©ponses ¬´vraies¬ª et ¬´calcul√©es¬ª.) Ensuite, revenons au test l'objet est un mat√©riau ordinaire (et non le mat√©riau de test de l'espace mondial), puis r√©activez l'effet de post-traitement.  Mes r√©sultats ressemblent √† ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9e/deb/7ce/f9edeb7cea30fb33b72705a568264638.png"></div><br>  Ceci est compl√®tement similaire au shader de test que j'ai √©crit, c'est-√†-dire que les calculs de l'espace mondial sont probablement corrects! <br><br><h2>  Dessiner un cercle dans l'espace mondial </h2><br>  Maintenant que nous avons des <strong>positions dans l'espace mondial</strong> , nous pouvons dessiner un cercle de couleur dans la sc√®ne!  Nous devons d√©finir le <strong>rayon</strong> dans lequel l'effet dessinera la couleur.  √Ä l'ext√©rieur, l'effet rendra l'image en niveaux de gris.  Pour le d√©finir, vous devez ajuster les valeurs <strong>du rayon d'</strong> effet ( <strong>_MaxSize</strong> ) et du centre du cercle (_Center).  J'ai d√©fini ces valeurs dans la classe C # <a href="">ColorSpread</a> afin qu'elles soient visibles dans l'inspecteur.  D√©veloppons notre fragment shader en le for√ßant <strong>√† v√©rifier si le pixel actuel se trouve dans le rayon du cercle</strong> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VertexOutput i)</span></span></span><span class="hljs-function"> : SV_Target </span></span>{ float3 worldPos = GetWorldFromViewPosition(i); <span class="hljs-comment"><span class="hljs-comment">// ,      .  //   ,   ,  ,   float dist = distance(_Center, worldPos); float blend = dist &lt;= _MaxSize? 0 : 1; //   float4 fullColor = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.screenPos); //   float luminance = dot(fullColor.rgb, float3(0.2126729, 0.7151522, 0.0721750)); float3 greyscale = luminance.xxx; // ,       float3 color = (1-blend)*fullColor + blend*greyscale; return float4(color, 1.0); }</span></span></code> </pre> <br>  Enfin, nous pouvons dessiner la couleur selon qu'elle se trouve √† l'int√©rieur d'un <strong>rayon</strong> dans l' <strong>espace mondial</strong> .  Voil√† √† quoi ressemble l'effet de base! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/983/6be/fb0/9836befb050f5a354b1eb4e6faee50d5.png"></div><br><hr><br><h1>  Ajout d'effets sp√©ciaux </h1><br>  J'examinerai quelques autres techniques utilis√©es pour r√©partir la couleur sur le sol.  Il y a beaucoup plus pour le plein effet, mais le tutoriel est d√©j√† devenu trop volumineux, nous allons donc nous limiter au plus important. <br><br><h2>  Animation d'agrandissement du cercle </h2><br>  Nous voulons que l'effet se r√©pande dans le monde entier, c'est-√†-dire comme s'il grandissait.  Pour ce faire, vous devez modifier le <strong>rayon en</strong> fonction de l'heure. <br><br>  _StartTime indique l'heure √† laquelle le cercle devrait commencer √† se d√©velopper.  Dans mon projet, j'ai utilis√© un script suppl√©mentaire qui vous permet de cliquer n'importe o√π sur l'√©cran pour d√©marrer la croissance du cercle;  dans ce cas, l'heure de d√©but est √©gale √† l'heure √† laquelle la souris a √©t√© cliqu√©e. <br><br>  _GrowthSpeed ‚Äã‚Äãd√©finit la vitesse d'augmentation du cercle. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//           float timeElapsed = _Time.y - _StartTime; float effectRadius = min(timeElapsed * _GrowthSpeed, _MaxSize); //  ,      effectRadius = clamp(effectRadius, 0, _MaxSize);</span></span></code> </pre> <br>  Nous devons √©galement mettre √† jour le contr√¥le de distance pour comparer la distance actuelle avec le <strong>rayon</strong> croissant <strong>de l'effet</strong> , et non avec _MaxSize. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ,         //   ,   ,  ,   float dist = distance(_Center, worldPos); float blend = dist &lt;= effectRadius? 0 : 1; //     ...</span></span></code> </pre> <br>  Voici √† quoi devrait ressembler le r√©sultat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecb/3bc/761/ecb3bc76112c56270745db56f2272e7c.gif"></div><br><h2>  Ajout au rayon de bruit </h2><br>  Je voulais que l'effet ressemble plus √† un flou de peinture, pas seulement √† un cercle en pleine croissance.  Pour ce faire, <strong>ajoutons du bruit au rayon de l'effet</strong> afin que la distribution soit in√©gale. <br><br>  Nous devons d'abord √©chantillonner la texture dans l' <strong>espace mondial</strong> .  Les coordonn√©es UV de i.screenPos sont situ√©es dans l' <strong>espace de</strong> l' <strong>√©cran</strong> , et si nous √©chantillonnons en fonction d'eux, la forme de l'effet se d√©placera avec la cam√©ra;  utilisons donc les coordonn√©es dans l' <strong>espace mondial</strong> .  J'ai ajout√© le param√®tre <strong>_NoiseTexScale</strong> pour contr√¥ler l' <strong>√©chelle de l'√©chantillon de texture de bruit</strong> , car les coordonn√©es dans l'espace mondial sont assez grandes. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//          float2 worldUV = worldPos.xz; worldUV *= _NoiseTexScale;</span></span></code> </pre> <br>  √âchantillons maintenant la texture du bruit et ajoutons cette valeur au rayon de l'effet.  J'ai utilis√© l'√©chelle _NoiseSize pour plus de contr√¥le sur la taille du bruit. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     float noise = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, worldUV).r; effectRadius -= noise * _NoiseSize;</span></span></code> </pre> <br>  Voici √† quoi ressemblent les r√©sultats apr√®s quelques ajustements: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51f/b77/f57/51fb77f570eb4ba77fa4e8eaa8cadb20.gif"></div><br><hr><br><h1>  En conclusion </h1><br>  Vous pouvez suivre les mises √† jour des tutoriels sur mon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Twitter</a> , et sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Twitch</a> je passe des streams de codage!  (De plus, je diffuse des jeux de temps en temps, alors ne soyez pas surpris si vous me voyez assis en pyjama et jouant √† Kingdom Hearts 3.) <br><br>  Remerciements: <br><br><ul><li>  Tous les mod√®les de projet sont extraits de ce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pack d'environnement LowPoly</a> du magasin Unity. </li><li>  <a href="">L'effet ScreenSpaceReflections du moteur Unity</a> m'a vraiment aid√© √† comprendre comment obtenir une position tridimensionnelle dans la fen√™tre √† partir des coordonn√©es UV bidimensionnelles de l'espace d'√©cran. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr436456/">https://habr.com/ru/post/fr436456/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr436444/index.html">D√©ploiement invisible d'une application monolithique en production sur AWS. Exp√©rience personnelle</a></li>
<li><a href="../fr436448/index.html">Moniteur IPS 27 pouces Acer HA270bid: pour l'auto-am√©lioration</a></li>
<li><a href="../fr436450/index.html">T√©l√©commande et contr√¥le, libert√© et gouvernement. Conversation avec Staply</a></li>
<li><a href="../fr436452/index.html">7 domaines de d√©veloppement Linux en 2019</a></li>
<li><a href="../fr436454/index.html">Questions et r√©ponses sur JavaScript</a></li>
<li><a href="../fr436458/index.html">Progr√®s et battage m√©diatique dans la recherche en IA</a></li>
<li><a href="../fr436460/index.html">Le choix de la technologie, de l'architecture et du design dans les projets logiciels - sans esp√®ces</a></li>
<li><a href="../fr436464/index.html">2. Analyse du journal des points de contr√¥le: SmartEvent</a></li>
<li><a href="../fr436466/index.html">Electron: d√©veloppement d'applications de bureau en HTML, CSS et JavaScript</a></li>
<li><a href="../fr436468/index.html">Exp√©rience l√©gislative avec l'innovation num√©rique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>