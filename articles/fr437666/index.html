<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🅾️ 💆🏻 🍷 Annonce de l'aperçu de F # 4.6 👩🏻‍🎨 🤞🏾 🦄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous sommes ravis d'annoncer que Visual Studio 2019 livrera une nouvelle version de F # lors de sa sortie: F # 4.6! 


 F # 4.6 est une mise à jour pl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Annonce de l'aperçu de F # 4.6</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/437666/"><img align="left" width="200" src="https://habrastorage.org/webt/zh/zi/wx/zhziwxp-1d-vh9pn0kioaevu0kg.png"><p>  Nous sommes ravis d'annoncer que Visual Studio 2019 livrera une nouvelle version de F # lors de sa sortie: F # 4.6! </p><br><p>  F # 4.6 est une mise à jour plus petite du langage F #, ce qui en fait une «vraie» version ponctuelle.  Comme pour les versions précédentes de F #, F # 4.6 a été entièrement développé via un processus RFC ouvert (demandes de commentaires).  La communauté F # a offert des commentaires très détaillés dans les discussions sur cette version du langage.  Vous pouvez voir tous les RFC qui correspondent à cette version ici: </p><br><ul><li>  <a href="">RFC F # 4.6</a> </li><li>  <a href="">RFC FSharp.Core 4.6.0</a> </li></ul><br><p>  Ce message détaillera l'ensemble des fonctionnalités et comment commencer. </p><a name="habracut"></a><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Original dans le blog</a> <br><br><h2>  Commencez </h2><br><p>  Installez d'abord: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Aperçu du SDK .NET 2.1.6xx ou 2.2.6xx du SDK .NET</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Visual Studio 2019 Preview 2</a> </li></ul><br><p>  Ensuite, mettez à jour votre dépendance FSharp.Core vers FSharp.Core 4.6 (ou supérieur).  Si vous utilisez Visual Studio, vous pouvez le faire avec l'interface utilisateur de gestion des packages NuGet.  Si vous n'utilisez pas Visual Studio ou préférez les fichiers de projet de modification manuelle, ajoutez ceci au fichier de projet: </p><br><pre><code class="cpp hljs">&lt;ItemGroup&gt; &lt;PackageReference Update=<span class="hljs-string"><span class="hljs-string">"FSharp.Core"</span></span> Version=<span class="hljs-string"><span class="hljs-string">"4.6.0"</span></span> /&gt; &lt;/ItemGroup&gt;</code> </pre> <br><p>  Une fois que vous avez installé les bits nécessaires, vous pouvez utiliser F # 4.6 avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Visual Studio</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Visual Studio pour Mac</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Visual Studio Code avec Ionide</a> . </p><br><h2>  Enregistrements anonymes </h2><br><p>  Mis à part diverses corrections de bogues, le seul changement de langue dans F # 4.6 est l'introduction de <a href="">types d'enregistrement anonyme</a> . </p><br><h3>  Utilisation basique </h3><br><p>  Du point de vue F # uniquement, les enregistrements anonymes sont des types d'enregistrement F # qui n'ont pas de noms explicites et peuvent être déclarés de manière ad hoc.  Bien qu'il soit peu probable qu'ils changent fondamentalement la façon dont vous écrivez du code F #, ils comblent de nombreuses lacunes plus petites que les programmeurs F # ont rencontrées au fil du temps et peuvent être utilisés pour une manipulation de données succincte qui n'était pas possible auparavant. </p><br><p>  Ils sont assez faciles à utiliser.  Par exemple, voici comment vous pouvez interagir avec une fonction qui produit un enregistrement anonyme: </p><br><pre> <code class="cpp hljs">open System let circleStats radius = let d = radius * <span class="hljs-number"><span class="hljs-number">2.0</span></span> let a = Math.PI * (radius ** <span class="hljs-number"><span class="hljs-number">2.0</span></span>) let c = <span class="hljs-number"><span class="hljs-number">2.0</span></span> * Math.PI * radius {| Diameter=d; Area=a; Circumference=c |} let r = <span class="hljs-number"><span class="hljs-number">2.0</span></span> let stats = circleStats r printfn <span class="hljs-string"><span class="hljs-string">"Circle with radius: %f has diameter %f, area %f, and circumference %f"</span></span> r stats.Diameter stats.Area stats.Circumference</code> </pre> <br><p>  Cependant, ils peuvent être utilisés pour plus que des conteneurs de données de base.  L'exemple suivant développe l'exemple précédent pour utiliser une fonction d'impression plus sécurisée: </p><br><pre> <code class="cpp hljs">let circleStats radius = let d = radius * <span class="hljs-number"><span class="hljs-number">2.0</span></span> let a = Math.PI * (radius ** <span class="hljs-number"><span class="hljs-number">2.0</span></span>) let c = <span class="hljs-number"><span class="hljs-number">2.0</span></span> * Math.PI * radius {| Diameter=d; Area=a; Circumference=c |} let printCircleStats r (stats: {| Area: <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>; Circumference: <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>; Diameter: <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> |}) = printfn <span class="hljs-string"><span class="hljs-string">"Circle with radius: %f has diameter %f, area %f, and circumference %f"</span></span> r stats.Diameter stats.Area stats.Circumference let r = <span class="hljs-number"><span class="hljs-number">2.0</span></span> let stats = circleStats r printCircleStats r stats</code> </pre> <br><p>  Si vous essayez d'appeler `printCircleStats` avec un enregistrement anonyme qui avait les mêmes types de données sous-jacents mais des étiquettes différentes, il ne parviendra pas à compiler: </p><br><pre> <code class="cpp hljs">printCircleStats r {| Diameter=<span class="hljs-number"><span class="hljs-number">2.0</span></span>; Area=<span class="hljs-number"><span class="hljs-number">4.0</span></span>; MyCircumference=<span class="hljs-number"><span class="hljs-number">12.566371</span></span> |} <span class="hljs-comment"><span class="hljs-comment">// Two anonymous record types have mismatched sets of field names '["Area"; "Circumference"; "Diameter"]' and '["Area"; "Diameter"; "MyCircumference"]'</span></span></code> </pre> <br><p>  C'est exactement comme cela que les types d'enregistrement F # fonctionnent, sauf que tout a été déclaré ad hoc plutôt que d'avance.  Cela présente des avantages et des inconvénients en fonction de votre situation particulière.Nous vous recommandons donc d'utiliser judicieusement les enregistrements anonymes plutôt que de remplacer toutes vos déclarations d'enregistrements F # initiales. </p><br><h3>  Structurer des enregistrements anonymes </h3><br><p>  Les enregistrements anonymes peuvent également être des structures en utilisant le mot clé <em>struct</em> : </p><br><pre> <code class="cpp hljs">open System let circleStats radius = let d = radius * <span class="hljs-number"><span class="hljs-number">2.0</span></span> let a = Math.PI * (radius ** <span class="hljs-number"><span class="hljs-number">2.0</span></span>) let c = <span class="hljs-number"><span class="hljs-number">2.0</span></span> * Math.PI * radius <span class="hljs-comment"><span class="hljs-comment">// Note that the keyword comes before the '{| |}' brace pair struct {| Area=a; Circumference=c; Diameter=d |} // the 'struct' keyword also comes before the '{| |}' brace pair when declaring the parameter type let printCircleStats r (stats: struct {| Area: float; Circumference: float; Diameter: float |}) = printfn "Circle with radius: %f has diameter %f, area %f, and circumference %f" r stats.Diameter stats.Area stats.Circumference let r = 2.0 let stats = circleStats r printfn "Circle with radius: %f has diameter %f, area %f, and circumference %f" r stats.Diameter stats.Area stats.Circumference</span></span></code> </pre> <br><p>  Vous pouvez appeler une fonction qui prend un enregistrement anonyme struct peut être fait explicitement comme ceci: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">let printCircleStats </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stats: struct {| Area: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">; Circumference: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">; Diameter: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> |})</span></span></span><span class="hljs-function"> </span></span>= printfn <span class="hljs-string"><span class="hljs-string">"Circle with radius: %f has diameter %f, area %f, and circumference %f"</span></span> r stats.Diameter stats.Area stats.Circumference printCircleStats r <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span>| Area=<span class="hljs-number"><span class="hljs-number">4.0</span></span>; Circumference=<span class="hljs-number"><span class="hljs-number">12.6</span></span>; Diameter=<span class="hljs-number"><span class="hljs-number">12.6</span></span> |}</code> </pre> <br><p>  Ou vous pouvez utiliser «inférence de structure» pour éluder la «structure» sur le site de l'appel: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">let printCircleStats </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stats: struct {| Area: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">; Circumference: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">; Diameter: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> |})</span></span></span><span class="hljs-function"> </span></span>= printfn <span class="hljs-string"><span class="hljs-string">"Circle with radius: %f has diameter %f, area %f, and circumference %f"</span></span> r stats.Diameter stats.Area stats.Circumference printCircleStats r {| Area=<span class="hljs-number"><span class="hljs-number">4.0</span></span>; Circumference=<span class="hljs-number"><span class="hljs-number">12.6</span></span>; Diameter=<span class="hljs-number"><span class="hljs-number">12.6</span></span> |}</code> </pre> <br><p>  Cela traitera l'instance de l'enregistrement anonyme que vous avez créé comme s'il s'agissait d'une structure. </p><br><p>  Notez que l'inverse n'est pas vrai: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">let printCircleStats </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stats: {| Area: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">; Circumference: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">; Diameter: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> |})</span></span></span><span class="hljs-function"> </span></span>= printfn <span class="hljs-string"><span class="hljs-string">"Circle with radius: %f has diameter %f, area %f, and circumference %f"</span></span> r stats.Diameter stats.Area stats.Circumference <span class="hljs-comment"><span class="hljs-comment">// This will fail to compile for hopefully obvious reasons! printCircleStats r struct {| Area=4.0; Circumference=12.6; Diameter=12.6 |}</span></span></code> </pre> <br><p>  Il n'est actuellement pas possible de définir les types d'enregistrement anonyme de structure <em>IsByRefLike</em> ou <em>IsReadOnly</em> .  Il existe une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">suggestion de langage</a> qui propose cette amélioration, mais en raison de bizarreries dans la syntaxe, elle est toujours en discussion. </p><br><h3>  Aller plus loin </h3><br><p>  Les enregistrements anonymes peuvent être utilisés dans un ensemble plus large de contextes plus avancés. </p><br><h4>  Les enregistrements anonymes sont sérialisables </h4><br><p>  Vous pouvez sérialiser et désérialiser des enregistrements anonymes: </p><br><pre> <code class="cpp hljs">open Newtonsoft.Json let phillip = {| name=<span class="hljs-string"><span class="hljs-string">"Phillip"</span></span>; age=<span class="hljs-number"><span class="hljs-number">28</span></span> |} let str = JsonConvert.SerializeObject(phillip) printfn <span class="hljs-string"><span class="hljs-string">"%s"</span></span> str let phillip' = JsonConvert.DeserializeObject&lt;{|name: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; age: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>|}&gt;(str) printfn <span class="hljs-string"><span class="hljs-string">"Name: %s Age: %d"</span></span> phillip<span class="hljs-string"><span class="hljs-string">'.name phillip'</span></span>.age</code> </pre> <br><p>  Cela produit ce que vous attendez: </p><br><pre> <code class="cpp hljs">{<span class="hljs-string"><span class="hljs-string">"age"</span></span>:<span class="hljs-number"><span class="hljs-number">28</span></span>,<span class="hljs-string"><span class="hljs-string">"name"</span></span>:<span class="hljs-string"><span class="hljs-string">"Phillip"</span></span>} Name: Phillip Age: <span class="hljs-number"><span class="hljs-number">28</span></span></code> </pre> <br><p>  Voici un exemple de bibliothèque qui est également appelée dans un autre projet: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> AnonyRecdOne open Newtonsoft.Json <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> AR = let serialize () = let phillip = {| name=<span class="hljs-string"><span class="hljs-string">"Phillip"</span></span>; age=<span class="hljs-number"><span class="hljs-number">28</span></span> |} JsonConvert.SerializeObject(phillip)</code> </pre> <br><pre> <code class="cpp hljs">open AnonyRecdOne open Newtonsoft.Json [&lt;EntryPoint&gt;] let main _ = let str = AR.serialize () let phillip = JsonConvert.DeserializeObject&lt;{|name: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; age: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>|}&gt;(str) printfn <span class="hljs-string"><span class="hljs-string">"Name: %s Age: %d"</span></span> phillip.name phillip.age</code> </pre> <br><p>  Cela peut faciliter les choses pour des scénarios tels que des données légères passant sur un réseau dans un système composé de microservices. </p><br><h4>  Les enregistrements anonymes peuvent être combinés avec d'autres définitions de type </h4><br><p>  Vous pouvez avoir un modèle de données arborescent dans votre domaine, tel que l'exemple suivant: </p><br><pre> <code class="cpp hljs">type FullName = { FirstName: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; LastName: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } type Employee = | Engineer of FullName | Manager of name: FullName * reports: Employee <span class="hljs-built_in"><span class="hljs-built_in">list</span></span> | Executive of name: FullName * reports: Employee <span class="hljs-built_in"><span class="hljs-built_in">list</span></span> * assistant: Employee</code> </pre> <br><p>  Il est typique de voir des cas modélisés sous forme de tuples avec des champs d'union nommés, mais à mesure que les données se compliquent, vous pouvez extraire chaque cas avec des enregistrements: </p><br><pre> <code class="cpp hljs">type FullName = { FirstName: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; LastName: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } type Employee = | Engineer of FullName | Manager of Manager | Executive of Executive <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> Manager = { Name: FullName; Reports: Employee <span class="hljs-built_in"><span class="hljs-built_in">list</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> Executive = { Name: FullName; Reports: Employee <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>; Assistant: Employee }</code> </pre> <br><p>  Cette définition récursive peut désormais être raccourcie avec des enregistrements anonymes si elle convient à votre base de code: </p><br><pre> <code class="cpp hljs">type FullName = { FirstName: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; LastName: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } type Employee = | Engineer of FullName | Manager of {| Name: FullName; Reports: Employee <span class="hljs-built_in"><span class="hljs-built_in">list</span></span> |} | Executive of {| Name: FullName; Reports: Employee <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>; Assistant: Employee |}</code> </pre> <br><p>  Comme pour les exemples précédents, cette technique doit être appliquée judicieusement et lorsqu'elle s'applique à votre scénario. </p><br><h4>  Les enregistrements anonymes facilitent l'utilisation de LINQ en F # </h4><br><p>  Les programmeurs F # préfèrent généralement utiliser les combinateurs List, Array et Sequence lorsqu'ils travaillent avec des données, mais il peut parfois être utile d'utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LINQ</a> .  Cela a toujours été un peu pénible, car LINQ utilise des types anonymes C #. </p><br><p>  Avec les enregistrements anonymes, vous pouvez utiliser les méthodes LINQ comme vous le feriez avec C # et les types anonymes: </p><br><pre> <code class="cpp hljs">open System.Linq let names = [ <span class="hljs-string"><span class="hljs-string">"Ana"</span></span>; <span class="hljs-string"><span class="hljs-string">"Felipe"</span></span>; <span class="hljs-string"><span class="hljs-string">"Emillia"</span></span>] let nameGrouping = names.Select(fun n -&gt; {| Name=n; FirstLetter=n.[<span class="hljs-number"><span class="hljs-number">0</span></span>] |}) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ng in nameGrouping <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> printfn <span class="hljs-string"><span class="hljs-string">"%s has first letter %c"</span></span> ng.Name ng.FirstLetter</code> </pre> <br><p>  Cela imprime: </p><br><pre> <code class="cpp hljs">Ana has first letter A Felipe has first letter F Emillia has first letter E</code> </pre> <br><h4>  Les enregistrements anonymes facilitent le travail avec Entity Framework et d'autres ORM </h4><br><p>  Les programmeurs F # utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des expressions de requête F #</a> pour interagir avec une base de données devraient voir quelques améliorations mineures de la qualité de vie avec des enregistrements anonymes. </p><br><p>  Par exemple, vous pouvez être habitué à utiliser des tuples pour regrouper des données avec une clause `select`: </p><br><pre> <code class="cpp hljs">let q = query { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row in db.Status <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> select (row.StatusID, row.Name) }</code> </pre> <br><p>  Mais cela se traduit par des colonnes avec des noms comme <em>Item1</em> et <em>Item2</em> qui ne sont pas idéaux.  Avant les enregistrements anonymes, vous devez déclarer un type d'enregistrement et l'utiliser.  Maintenant, vous n'avez pas besoin de faire ça: </p><br><pre> <code class="cpp hljs">let q = query { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row in db.Status <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> select {| StatusID = row.StatusID; Name = row.Name |} }</code> </pre> <br><p>  Pas besoin de spécifier le type d'enregistrement à l'avance!  Cela rend les expressions de requête beaucoup plus alignées avec le SQL réel qu'elles modélisent. </p><br><p>  Les enregistrements anonymes vous permettent également d'éviter de créer <em>des</em> types <em>AnonymousObject</em> dans des requêtes plus avancées simplement pour créer un regroupement ad-hoc de données aux fins de la requête. </p><br><h4>  Les enregistrements anonymes facilitent l'utilisation du routage personnalisé dans ASP.NET Core </h4><br><p>  Vous utilisez peut-être déjà ASP.NET Core avec F #, mais vous avez peut-être rencontré une gêne lors de la définition de routes personnalisées.  Comme pour les exemples précédents, cela pourrait toujours être fait en définissant un type d'enregistrement à l'avance, mais cela a souvent été considéré comme inutile par les développeurs F #.  Vous pouvez maintenant le faire en ligne: </p><br><pre> <code class="cpp hljs">app.UseMvc(fun routes -&gt; routes.MapRoute(<span class="hljs-string"><span class="hljs-string">"blog"</span></span>,<span class="hljs-string"><span class="hljs-string">"blog/{*article}"</span></span>, defaults={| controller=<span class="hljs-string"><span class="hljs-string">"Blog"</span></span>; action=<span class="hljs-string"><span class="hljs-string">"Article"</span></span> |}) |&gt; ignore ) |&gt; ignore</code> </pre> <br><p>  Ce n'est toujours pas idéal en raison du fait que F # est strict sur les types de retour (contrairement à C #, où vous n'avez pas besoin d'ignorer explicitement les choses qui retournent une valeur).  Cependant, cela vous permet de supprimer des définitions d'enregistrement précédemment définies qui ne servaient à rien d'autre que de vous permettre d'envoyer des données dans le pipeline de middleware ASP.NET. </p><br><h4>  Copier et mettre à jour des expressions avec des enregistrements anonymes </h4><br><p>  Comme pour les types d'enregistrement, vous pouvez utiliser la syntaxe de copie et de mise à jour avec des enregistrements anonymes: </p><br><pre> <code class="cpp hljs">let data = {| X = <span class="hljs-number"><span class="hljs-number">1</span></span>; Y = <span class="hljs-number"><span class="hljs-number">2</span></span> |} let expandedData = {| data with Z = <span class="hljs-number"><span class="hljs-number">3</span></span> |} <span class="hljs-comment"><span class="hljs-comment">// Gives {| X=1; Y=2; Z=3 |} let stringifiedY = {| expandedData with Y="Hello!" |} // Gives {| X=1; Y="Hello!"; Z=3 |}</span></span></code> </pre> <br><p>  L'expression d'origine peut également être un type d'enregistrement: </p><br><pre> <code class="cpp hljs">type R = { X: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } let data = { X=<span class="hljs-number"><span class="hljs-number">1</span></span> } let data' = {| data with Y = <span class="hljs-number"><span class="hljs-number">2</span></span> |} <span class="hljs-comment"><span class="hljs-comment">// Gives {| X=1; Y=2 |}</span></span></code> </pre> <br><p>  Vous pouvez également copier des données vers et depuis des enregistrements anonymes de référence et de structure: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Copy data from a reference record into a struct anonymous record type R1 = { X: int } let r1 = { X=1 } let data1 = struct {| r1 with Y=1 |} // Copy data from a struct record into a reference anonymous record [&lt;Struct&gt;] type R2 = { X: int } let r2 = { X=1 } let data2 = {| r1 with Y=1 |}</span></span></code> </pre> <br><p>  L'utilisation d'expressions de copie et de mise à jour confère aux enregistrements anonymes une grande flexibilité lors de l'utilisation de données en F #. </p><br><h4>  Égalité et correspondance de motifs </h4><br><p>  Les enregistrements anonymes sont structurellement équitables et comparables: </p><br><pre> <code class="cpp hljs">{| a = <span class="hljs-number"><span class="hljs-number">1</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span> |} = {| a = <span class="hljs-number"><span class="hljs-number">2</span></span> |} <span class="hljs-comment"><span class="hljs-comment">// true {| a = 1+1 |} &gt; {| a = 1 |} // true</span></span></code> </pre> <br><p>  Cependant, les types comparés doivent avoir la même «forme»: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// error FS0001: Two anonymous record types have mismatched sets of field names '["a"]' and '["a"; "b"]' {| a = 1+1 |} = {| a = 2; b = 1|}</span></span></code> </pre> <br><p>  Bien que vous puissiez assimiler et comparer des enregistrements anonymes, vous ne pouvez pas faire correspondre les modèles sur eux.  Ceci pour deux raisons: </p><br><ul><li>  Un modèle doit tenir compte de chaque champ d'un enregistrement anonyme, contrairement aux types d'enregistrement.  En effet, les enregistrements anonymes ne prennent pas en charge le sous-typage structurel - ce sont des types nominaux. </li><li>  Il n'est pas possible d'avoir des modèles supplémentaires dans une expression de correspondance de modèle, car chaque modèle distinct impliquerait un type d'enregistrement anonyme différent. </li><li>  L'obligation de tenir compte de chaque champ dans un enregistrement anonyme rendrait un modèle plus verbeux que l'utilisation de la notation «point». </li></ul><br><p>  Au lieu de cela, la syntaxe «point» est utilisée pour extraire les valeurs d'un enregistrement anonyme.  Ce sera toujours au plus aussi verbeux que si la correspondance de modèles était utilisée, et dans la pratique, il est probable qu'il soit moins verbeux car il n'extrait pas toujours toutes les valeurs d'un enregistrement anonyme.  Voici comment travailler avec un exemple précédent où les enregistrements anonymes font partie d'une union discriminée: </p><br><pre> <code class="cpp hljs">type Employee = | Engineer of FullName | Manager of {| Name: FullName; Reports: Employee <span class="hljs-built_in"><span class="hljs-built_in">list</span></span> |} | Executive of {| Name: FullName; Reports: Employee <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>; Assistant: Employee |} let getFirstName e = match e with | Engineer fullName -&gt; fullName.FirstName | Manager m -&gt; m.Name.FirstName | Executive ex -&gt; ex.Name.FirstName</code> </pre> <br><p>  Il existe actuellement une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">suggestion ouverte</a> pour autoriser la correspondance des modèles sur les enregistrements anonymes dans les contextes limités qui pourraient en fait être activés.  Si vous avez un cas d'utilisation proposé, veuillez utiliser ce problème pour en discuter! </p><br><h2>  Ajouts FSharp.Core </h2><br><p>  Ce ne serait pas une autre version F # sans ajouts à la bibliothèque F # Core! </p><br><h3>  Extension ValueOption </h3><br><p>  Le type <em>ValueOption</em> introduit dans F # 4.5 a maintenant quelques autres goodies attachés au type: </p><br><ul><li>  L'attribut <em>DebuggerDisplay</em> pour aider au débogage </li><li>  <em>Membres IsNone</em> , <em>IsSome</em> , <em>None</em> , <em>Some</em> , <em>op_Implicit</em> et <em>ToString</em> </li></ul><br><p>  Cela lui donne une «parité» avec le type d'option. </p><br><p>  De plus, il existe maintenant un module <em>ValueOption</em> contenant les mêmes fonctions que le module `Option` a: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> ValueOption = [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"IsSome"</span></span>)&gt;] val <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> isSome: voption:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; bool [&lt;CompiledName("IsNone")&gt;] val inline isNone: voption:'</span></span>T voption -&gt; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"DefaultValue"</span></span>)&gt;] val defaultValue: value:<span class="hljs-string"><span class="hljs-string">'T -&gt; voption:'</span></span>T voption -&gt; <span class="hljs-string"><span class="hljs-string">'T [&lt;CompiledName("DefaultWith")&gt;] val defaultWith: defThunk:(unit -&gt; '</span></span>T) -&gt; voption:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; '</span></span>T [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"OrElse"</span></span>)&gt;] val orElse: ifNone:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; voption:'</span></span>T voption -&gt; <span class="hljs-string"><span class="hljs-string">'T voption [&lt;CompiledName("OrElseWith")&gt;] val orElseWith: ifNoneThunk:(unit -&gt; '</span></span>T voption) -&gt; voption:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; '</span></span>T voption [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"GetValue"</span></span>)&gt;] val get: voption:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; '</span></span>T [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"Count"</span></span>)&gt;] val count: voption:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; int [&lt;CompiledName("Fold")&gt;] val fold&lt;'</span></span>T,<span class="hljs-string"><span class="hljs-string">'State&gt; : folder:('</span></span>State -&gt; <span class="hljs-string"><span class="hljs-string">'T -&gt; '</span></span>State) -&gt; state:<span class="hljs-string"><span class="hljs-string">'State -&gt; voption:'</span></span>T voption -&gt; <span class="hljs-string"><span class="hljs-string">'State [&lt;CompiledName("FoldBack")&gt;] val foldBack&lt;'</span></span>T,<span class="hljs-string"><span class="hljs-string">'State&gt; : folder:('</span></span>T -&gt; <span class="hljs-string"><span class="hljs-string">'State -&gt; '</span></span>State) -&gt; voption:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; state:'</span></span>State -&gt; <span class="hljs-string"><span class="hljs-string">'State [&lt;CompiledName("Exists")&gt;] val exists: predicate:('</span></span>T -&gt; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>) -&gt; voption:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; bool [&lt;CompiledName("ForAll")&gt;] val forall: predicate:('</span></span>T -&gt; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>) -&gt; voption:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; bool [&lt;CompiledName("Contains")&gt;] val inline contains: value:'</span></span>T -&gt; voption:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; bool when '</span></span>T : equality [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"Iterate"</span></span>)&gt;] val iter: action:(<span class="hljs-string"><span class="hljs-string">'T -&gt; unit) -&gt; voption:'</span></span>T voption -&gt; unit [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"Map"</span></span>)&gt;] val <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>: mapping:(<span class="hljs-string"><span class="hljs-string">'T -&gt; '</span></span>U) -&gt; voption:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; '</span></span>U voption [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"Map2"</span></span>)&gt;] val map2: mapping:(<span class="hljs-string"><span class="hljs-string">'T1 -&gt; '</span></span>T2 -&gt; <span class="hljs-string"><span class="hljs-string">'U) -&gt; voption1: '</span></span>T1 voption -&gt; voption2: <span class="hljs-string"><span class="hljs-string">'T2 voption -&gt; '</span></span>U voption [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"Map3"</span></span>)&gt;] val map3: mapping:(<span class="hljs-string"><span class="hljs-string">'T1 -&gt; '</span></span>T2 -&gt; <span class="hljs-string"><span class="hljs-string">'T3 -&gt; '</span></span>U) -&gt; <span class="hljs-string"><span class="hljs-string">'T1 voption -&gt; '</span></span>T2 voption -&gt; <span class="hljs-string"><span class="hljs-string">'T3 voption -&gt; '</span></span>U voption [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"Bind"</span></span>)&gt;] val bind: binder:(<span class="hljs-string"><span class="hljs-string">'T -&gt; '</span></span>U voption) -&gt; voption:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; '</span></span>U voption [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"Flatten"</span></span>)&gt;] val flatten: voption:<span class="hljs-string"><span class="hljs-string">'T voption voption -&gt; '</span></span>T voption [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"Filter"</span></span>)&gt;] val filter: predicate:(<span class="hljs-string"><span class="hljs-string">'T -&gt; bool) -&gt; voption:'</span></span>T voption -&gt; <span class="hljs-string"><span class="hljs-string">'T voption [&lt;CompiledName("ToArray")&gt;] val toArray: voption:'</span></span>T voption -&gt; <span class="hljs-string"><span class="hljs-string">'T[] [&lt;CompiledName("ToList")&gt;] val toList: voption:'</span></span>T voption -&gt; <span class="hljs-string"><span class="hljs-string">'T list [&lt;CompiledName("ToNullable")&gt;] val toNullable: voption:'</span></span>T voption -&gt; Nullable&lt;<span class="hljs-string"><span class="hljs-string">'T&gt; [&lt;CompiledName("OfNullable")&gt;] val ofNullable: value:Nullable&lt;'</span></span>T&gt; -&gt; <span class="hljs-string"><span class="hljs-string">'T voption [&lt;CompiledName("OfObj")&gt;] val ofObj: value: '</span></span>T -&gt; <span class="hljs-string"><span class="hljs-string">'T voption when '</span></span>T : null [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"ToObj"</span></span>)&gt;] val toObj: value: <span class="hljs-string"><span class="hljs-string">'T voption -&gt; '</span></span>T when <span class="hljs-string"><span class="hljs-string">'T : null</span></span></code> </pre> <br><p>  Cela devrait atténuer les préoccupations selon lesquelles «ValueOption» est le frère étrange de «Option» qui n'obtient pas le même ensemble de fonctionnalités. </p><br><h3>  tryExactlyOne pour List, Array et Seq </h3><br><p>  Cette belle fonction a été apportée par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Grzegorz Dziadkiewicz</a> .  Voici comment cela fonctionne: </p><br><pre> <code class="cpp hljs">List.tryExactlyOne [] <span class="hljs-comment"><span class="hljs-comment">// None List.tryExactlyOne [1] // Some 1 List.tryExactlyOne [1; 2] // None Array.tryExactlyOne null // ArgumentNullException Array.tryExactlyOne [||] // None Array.tryExactlyOne [|1|] // Some 1 Array.tryExactlyOne [|1; 2|] // None Seq.tryExactlyOne null // ArgumentNullException Seq.tryExactlyOne (Seq.ofList []) // None Seq.tryExactlyOne (Seq.ofList [1]) // Some 1 Seq.tryExactlyOne (Seq.ofList [1; 2]) // None</span></span></code> </pre> <br><h2>  Envelopper </h2><br><p>  Bien que la liste totale des fonctionnalités de F # 4.6 ne soit pas énorme, elles vont toujours assez loin!  Nous vous encourageons à essayer F # 4.6 et à nous laisser vos commentaires afin que nous puissions affiner les choses avant la sortie complète.  Comme toujours, merci à la communauté F # pour ses contributions - à la fois dans la discussion sur le code et la conception - qui nous aident à continuer à faire avancer le langage F #. </p><br><p>  Bravo et bon piratage! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr437666/">https://habr.com/ru/post/fr437666/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr437654/index.html">Imprimantes 3D photopolymères peu coûteuses et abordables</a></li>
<li><a href="../fr437656/index.html">Éléphant dans une boutique de porcelaine: imprimantes 3D avec un immense champ d'impression</a></li>
<li><a href="../fr437658/index.html">Guide: Thymeleaf + Spring. 3e partie</a></li>
<li><a href="../fr437660/index.html">Mise à jour du profil à vie dans Visual Studio 2019 Preview 2</a></li>
<li><a href="../fr437664/index.html">Récupération du composé</a></li>
<li><a href="../fr437670/index.html">Mises à jour du backend MSVC dans Visual Studio 2019 Preview 2: nouvelles optimisations, améliorations OpenMP et Build Throughput</a></li>
<li><a href="../fr437672/index.html">cyberd: Calculer les connaissances du web3</a></li>
<li><a href="../fr437674/index.html">Méthodes de reconnaissance d'objets 3D pour les véhicules sans pilote. Rapport Yandex</a></li>
<li><a href="../fr437676/index.html">Les universités et les accélérateurs d'entreprise comme levier pour lancer une start-up B2B aux États-Unis</a></li>
<li><a href="../fr437680/index.html">Ma collection de bricolage sur Youtube</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>