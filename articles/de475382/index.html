<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏍️ 🏇🏿 👨‍👦 Wie haben wir WebAssembly in Yandex.Maps implementiert und warum haben wir JavaScript verlassen? ✍🏾 👃🏿 👩🏾‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mein Name ist Valery Shavel, ich bin vom Entwicklungsteam der Yandex.Maps-Vektor-Engine. Kürzlich haben wir die WebAssembly-Technologie in die Engine ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie haben wir WebAssembly in Yandex.Maps implementiert und warum haben wir JavaScript verlassen?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/475382/">  Mein Name ist Valery Shavel, ich bin vom Entwicklungsteam der Yandex.Maps-Vektor-Engine.  Kürzlich haben wir die WebAssembly-Technologie in die Engine implementiert.  Im Folgenden erkläre ich Ihnen, warum wir es ausgewählt haben, welche Ergebnisse wir erzielt haben und wie Sie diese Technologie in Ihrem Projekt einsetzen können. <br><br><img src="https://habrastorage.org/webt/an/k6/3k/ank63kqu8nzp0l-yc6qeql2gpow.png"><br><a name="habracut"></a><br>  In Yandex.Maps besteht eine Vektorkarte aus Teilen, die als Kacheln bezeichnet werden.  Tatsächlich ist die Kachel der indizierte Bereich der Karte.  Die Karte ist ein Vektor, daher enthält jede Kachel viele geometrische Grundelemente.  Kacheln werden vom Server zum Client verschlüsselt, und vor der Anzeige müssen alle Grundelemente verarbeitet werden.  Manchmal dauert es sehr lange.  Eine Kachel kann mehr als 2000 Polylinien und Polygone enthalten. <br><br><img src="https://habrastorage.org/webt/xh/o4/lu/xho4lutlo850vm89roaysk5kcno.png"><br><br>  Bei der Verarbeitung von Grundelementen ist die Leistung am wichtigsten.  Wenn die Kachel nicht schnell genug vorbereitet wird, sieht der Benutzer sie zu spät und die nächsten Kacheln werden in der Warteschlange verzögert.  Um die Verarbeitung zu beschleunigen, haben wir uns für die relativ neue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WebAssembly (Wasm)</a> -Technologie entschieden. <br><br><h2>  Verwenden von WebAssembly in Maps <br></h2><br>  Jetzt findet der Großteil der Verarbeitung von Primitiven im Hintergrundthread (Web Worker) statt, der ein separates Leben führt.  Dies geschieht, um den Haupt-Thread so weit wie möglich zu entladen.  Wenn der Code zum Anzeigen der Karte auf der Service-Seite eingebettet ist, die selbst eine erhebliche Belastung verursachen kann, treten daher weniger Bremsen auf.  Der Nachteil ist, dass Sie das Messaging zwischen dem Hauptthread und dem Web Worker ordnungsgemäß konfigurieren müssen. <br><br>  Der Teil der Verarbeitung, der im Hintergrundthread stattfindet, besteht im Wesentlichen aus zwei Schritten: <br><br><ol><li>  Das vom Server kommende Protobuf-Format wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dekodiert</a> . </li><li>  Geometrien werden generiert und in Puffer geschrieben. </li></ol><br>  Im zweiten Schritt werden Vertex- und Indexpuffer für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WebGL gebildet</a> .  Diese Puffer werden beim Rendern wie folgt verwendet.  Ein Scheitelpunktpuffer enthält für jeden Scheitelpunkt seine Parameter, die zur Bestimmung seiner Position auf dem Bildschirm zu einem bestimmten Zeitpunkt erforderlich sind.  Ein Indexpuffer besteht aus Dreifachen von Indizes.  Jedes Tripel bedeutet, dass ein Dreieck mit Eckpunkten aus dem Eckpunktpuffer an den angegebenen Indizes auf dem Bildschirm angezeigt werden soll.  Daher muss das Grundelement in Dreiecke unterteilt werden, was auch eine zeitaufwändige Aufgabe sein kann: <br><br><img width="600" src="https://habrastorage.org/webt/c0/tx/g_/c0txg_g-tfkpja6efsq_tp5cu_a.png"><br><br>  Offensichtlich gibt es im zweiten Schritt viele Gedächtnismanipulationen und mathematische Berechnungen, da Sie für das korrekte Rendern von Grundelementen viele Informationen zu jedem Scheitelpunkt des Grundelements benötigen: <br><br><img width="600" src="https://habrastorage.org/webt/ug/-o/ej/ug-oej1lr58fgc7-r_ug7bbc--o.png"><br><br>  Wir waren mit der Leistung unseres JavaScript-Codes nicht zufrieden.  Zu dieser Zeit begann jeder über WebAssembly zu schreiben, die Technologie wurde ständig weiterentwickelt und verbessert.  Nachdem wir die Forschungsergebnisse gelesen hatten, schlugen wir vor, dass Wasm unsere Operationen beschleunigen könnte.  Obwohl wir uns dessen nicht ganz sicher waren: Es stellte sich als schwierig heraus, Daten zur Verwendung von Wasm in einem so großen Projekt zu finden. <br><br>  Wasm ist auch etwas schlechter als TypeScript: <br><br><ol><li> Wir müssen ein spezielles Modul mit den von uns benötigten Funktionen initialisieren.  Dies kann zu einer Verzögerung führen, bevor diese Funktionalität funktioniert. </li><li>  Die Größe des Quellcodes beim Kompilieren von Wasm ist viel größer als in TS. </li><li>  Entwickler müssen eine alternative Version der Codeausführung unterstützen, die auch für das Frontend in einer atypischen Sprache geschrieben ist. </li></ol><br>  Trotzdem riskierten wir, einen Teil unseres Codes mit Wasm neu zu schreiben. <br><br><h2>  Allgemeine Informationen zu WebAssembly </h2><br><img src="https://habrastorage.org/webt/jn/lz/5h/jnlz5h5iwocxqes5bsmv9tdcil4.png"><br><br>  Wasm ist ein Binärformat.  Sie können verschiedene Sprachen darin kompilieren und den Code dann in einem Browser ausführen.  Oft ist ein solcher vorkompilierter Code schneller als klassisches JavaScript.  Der Code im WebAssembly-Format hat keinen Zugriff auf die DOM-Elemente der Seite und wird in der Regel zum Ausführen zeitaufwendiger Rechenaufgaben auf dem Client verwendet. <br><br>  Wir haben C ++ als kompilierte Sprache gewählt, da es sehr praktisch und schnell ist. <br><br>  Um C ++ in WebAssembly zu kompilieren, haben wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">emscripten verwendet</a> .  Nach der Installation und dem Hinzufügen zu einem C ++ - Projekt müssen Sie die Hauptprojektdatei auf eine bestimmte Weise schreiben, um das Modul zu erhalten.  Zum Beispiel könnte es so aussehen: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;emscripten/bind.h&gt; #include &lt;emscripten.h&gt; #include &lt;math.h&gt; struct Point { double x; double y; }; double sqr(double x) { return x * x; } EMSCRIPTEN_BINDINGS(my_value_example) { emscripten::value_object&lt;Point&gt;("Point") .field("x", &amp;Point::x) .field("y", &amp;Point::y) ; emscripten::register_vector&lt;Point&gt;("vector&lt;Point&gt;"); emscripten::function("distance", emscripten::optional_override( [](Point point1, Point point2) { return sqrt(sqr(point1.x - point2.x) + sqr(point1.y - point2.y)) ; })); }</span></span></span></span></code> </pre> <br>  Als Nächstes beschreibe ich, wie Sie diesen Code in Ihrem TypeScript-Projekt verwenden können. <br><br>  Im Code definieren wir die Point-Struktur und ordnen sie der Point-Schnittstelle in TypeScript zu, in der es zwei Felder gibt - x und y, die den Feldern der Struktur entsprechen. <br><br>  Wenn wir den Standardvektorcontainer von C ++ nach TypeScript zurückgeben möchten, müssen wir ihn für den Point-Typ registrieren.  Dann wird in TypeScript die Schnittstelle mit den erforderlichen Funktionen entsprechen. <br><br>  Und schließlich zeigt der Code, wie Sie Ihre Funktion registrieren, um sie von TypeScript mit dem entsprechenden Namen aufzurufen. <br><br>  Kompilieren Sie die Datei mit emscripten und fügen Sie das resultierende Modul Ihrem TypeScript-Projekt hinzu.  Jetzt können wir eine generische d.ts-Datei für ein beliebiges emscripten-Modul schreiben, in der nützliche Funktionen und Typen vordefiniert sind: <br><br><pre> <code class="javascript hljs">declare <span class="hljs-built_in"><span class="hljs-built_in">module</span></span> <span class="hljs-string"><span class="hljs-string">"emscripten_module"</span></span> { interface EmscriptenModule { readonly wasmMemory: WebAssembly.Memory; readonly HEAPU8: <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>; readonly HEAPF64: <span class="hljs-built_in"><span class="hljs-built_in">Float64Array</span></span>; locateFile: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">path: string</span></span></span><span class="hljs-function">) =&gt;</span></span> string; onRuntimeInitialized: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; _malloc: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">size: size_t</span></span></span><span class="hljs-function">) =&gt;</span></span> uintptr_t; _free: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">addr: size_t</span></span></span><span class="hljs-function">) =&gt;</span></span> uintptr_t; } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> EmscriptenModule; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> type uintptr_t = number; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> type size_t = number; }</code> </pre> <br>  Und wir können die Datei d.ts für unser Modul schreiben: <br><br><pre> <code class="javascript hljs">declare <span class="hljs-built_in"><span class="hljs-built_in">module</span></span> <span class="hljs-string"><span class="hljs-string">"emscripten_point"</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> EmscriptenModule, {uintptr_t, size_t} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'emscripten_module'</span></span>; interface NativeObject { <span class="hljs-attr"><span class="hljs-attr">delete</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; } interface Vector&lt;T&gt; extends NativeObject { get(index: number): T; size(): number; } interface Point { readonly x: number; readonly y: number; } interface PointModule extends EmscriptenModule { <span class="hljs-attr"><span class="hljs-attr">distance</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">point1: Point, point2: Point</span></span></span><span class="hljs-function">) =&gt;</span></span> number; } type PointModuleUninitialized = Partial&lt;PointModule&gt;; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createModuleApi</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Module: Partial&lt;PointModule&gt;</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PointModule</span></span></span><span class="hljs-function">; }</span></span></code> </pre> <br>  Jetzt können wir eine Funktion schreiben, die Promise für die Modulinitialisierung erstellt, und sie verwenden: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> EmscriptenModule <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'emscripten_module'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> createPointModuleApi, {PointModule} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'emscripten_point'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pointModule <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'emscripten_point.wasm'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Promisifies initialization of emscripten module. * * @param moduleUrl URL to wasm file, it could be encoded data URL. * @param moduleInitializer Escripten module factory, * see https://emscripten.org/docs/compiling/WebAssembly.html#compiler-output. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initEmscriptenModule</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ModuleT</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extends</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmscriptenModule</span></span></span><span class="hljs-function">&gt;(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> moduleUrl: string, moduleInitializer: (module: Partial&lt;EmscriptenModule&gt;</span></span></span><span class="hljs-function">) =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ModuleT</span></span></span><span class="hljs-function"> ): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Promise</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ModuleT</span></span></span><span class="hljs-function">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span> = moduleInitializer({ <span class="hljs-attr"><span class="hljs-attr">locateFile</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> moduleUrl, <span class="hljs-attr"><span class="hljs-attr">onRuntimeInitialized</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// module itself is thenable, to prevent infinite promise resolution delete (&lt;any&gt;module).then; resolve(module); } }); }); } const initialization = initEmscriptenModule( 'data:application/wasm;base64,' + pointModule, createPointModuleApi );</span></span></code> </pre> <br>  Jetzt für dieses Versprechen bekommen wir unser Modul zusammen mit der Distanzfunktion. <br><br>  Leider können Sie den Wasm-Code nicht zeilenweise im Browser debuggen.  Daher ist es notwendig, Tests zu schreiben und Code darauf wie in normalem C ++ auszuführen, damit Sie die Möglichkeit zum bequemen Debuggen haben.  Trotzdem haben Sie auch im Browser Zugriff auf den Standard-Cout-Stream, der alles an die Browserkonsole ausgibt. <br><br>  Ein Projektbeispiel aus dem Artikel ist über diesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> verfügbar, wo Sie die Einstellungen für webpack.config und CMakeLists sehen können. <br><br><h2>  Ergebnisse </h2><br>  Also haben wir einen Teil unseres Codes neu geschrieben und ein Experiment gestartet, um das Parsen von Polygonen und Polygonen zu berücksichtigen.  Das Diagramm zeigt die mittleren Ergebnisse für eine Kachel für Wasm und JavaScript: <br><br><img src="https://habrastorage.org/webt/3b/of/sn/3bofsn_aq7y_urztp3diizivt1k.png"><br><br>  Als Ergebnis erhalten wir für jede Metrik solche relativen Koeffizienten: <br><br><img src="https://habrastorage.org/webt/mx/ol/hh/mxolhhmakjlt9d7n8bzkbyarrfc.png"><br><br>  Wie Sie an der reinen primitiven Parsing-Zeit und der Dekodierungszeit für Kacheln sehen können, ist Wasm mehr als viermal schneller.  Wenn Sie sich die gesamte Parsing-Zeit ansehen, ist der Unterschied ebenfalls signifikant, aber immer noch etwas geringer.  Dies ist auf die Kosten zurückzuführen, die für die Übermittlung von Daten an Wasm und die Erfassung des Ergebnisses anfallen.  Es ist auch erwähnenswert, dass in den ersten Kacheln der Gesamtgewinn sehr hoch ist (in den ersten zehn - mehr als fünf Mal).  Dann nimmt der relative Koeffizient jedoch auf etwa drei ab. <br><br>  Auf diese Weise konnte die Verarbeitungszeit einer Kachel im Hintergrundfaden um 20–25% reduziert werden.  Natürlich ist dieser Unterschied nicht so groß wie der der vorherigen, aber Sie müssen verstehen, dass das Parsen von unterbrochenen Linien und Polygonen weit von der gesamten Kachelverarbeitung entfernt ist. <br><br>  Wenn wir über die Notwendigkeit sprechen, das Modul zu initialisieren, hatte ungefähr die Hälfte der Benutzer eine Verzögerung, bevor sie die erste Kachel analysierten.  Die mediane Verzögerung beträgt 188 ms.  Die Verzögerung tritt nur vor dem ersten Plättchen auf, und der Gewinn beim Parsen ist konstant, sodass Sie am Anfang eine kleine Pause in Kauf nehmen können, die kein ernstes Problem darstellt. <br><br>  Eine andere negative Seite ist die Größe der Quellcodedatei.  Gzip-komprimierter verkleinerter Code für die gesamte Vektorkarten-Engine ohne Wasm - 85 KB, mit Wasm - 191 KB.  Gleichzeitig wird in Wasm nur das Parsen von unterbrochenen Linien und Rechtecken implementiert, und nicht alle Grundelemente, die sich in einer Kachel befinden können.  Außerdem musste ich zum Dekodieren von protobuf eine Bibliotheksimplementierung in reinem C wählen, bei einer C ++ - Implementierung war die Größe sogar noch größer.  Dieser Unterschied kann durch die Verwendung des Compiler-Flags -Oz anstelle von -O3 beim Kompilieren von C ++ etwas verringert werden, ist aber immer noch von Bedeutung.  Darüber hinaus verlieren wir durch einen solchen Austausch an Produktivität. <br><br>  Die Größe der Quelle hatte jedoch keinen wesentlichen Einfluss auf die Initialisierungsgeschwindigkeit der Karte.  Wasm ist nur auf langsamen Geräten schlechter und die Differenz beträgt weniger als 2%.  Die anfänglich sichtbaren Vektorkacheln in der Implementierung mit Wasm wurden den Benutzern jedoch etwas schneller als mit der JS-Implementierung angezeigt.  Dies ist auf den höheren Gewinn bei den ersten bearbeiteten Kacheln zurückzuführen, während JS noch nicht optimiert ist. <br><br>  Daher ist Wasm jetzt eine gute Option, wenn Sie mit der Leistung von JavaScript-Code nicht vertraut sind.  Gleichzeitig können Sie weniger Leistungsgewinn erzielen als wir, oder Sie können ihn überhaupt nicht erzielen.  Dies liegt an der Tatsache, dass JavaScript selbst manchmal recht schnell funktioniert und Sie in Wasm Daten übertragen und das Ergebnis sammeln müssen. <br><br>  Auf unseren Karten wird jetzt regelmäßig JavaScript ausgeführt.  Dies liegt an der Tatsache, dass der Gewinn beim Parsen vor dem allgemeinen Hintergrund nicht so groß ist, und an der Tatsache, dass nur einige Arten von Grundelementen in Wasm implementiert sind.  Wenn sich dies ändert, verwenden wir möglicherweise Wasm.  Ein weiteres schlagkräftiges Argument dagegen ist die Komplexität des Assemblierens und Debuggens: Die Unterstützung eines Projekts in zwei Sprachen ist nur dann sinnvoll, wenn sich der Leistungszuwachs lohnt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de475382/">https://habr.com/ru/post/de475382/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de475358/index.html">Gehaltsanalyse in der IT-Branche in Armenien sowie offene Stellen in den TOP10-IT-Unternehmen</a></li>
<li><a href="../de475366/index.html">Droidcon London 2019: Neue Trends und die interessantesten Berichte</a></li>
<li><a href="../de475368/index.html">Wie berechnet man die Effektivität von Werbung?</a></li>
<li><a href="../de475372/index.html">Front-End-Domain basierend auf TLS 1.3</a></li>
<li><a href="../de475378/index.html">"Wir können die Rechte für personenbezogene Daten nicht großen Unternehmen überlassen" - ehemaliger Chefredakteur von Wired UK über die Zukunft der Technologie</a></li>
<li><a href="../de475384/index.html">Was ist neu in Spring Boot 2.2?</a></li>
<li><a href="../de475386/index.html">Achtung, FAS: Wie verstößt man nicht gegen das Werbegesetz? Werbetreibenden-Memo</a></li>
<li><a href="../de475388/index.html">Sicherheitswoche 46: Mikrofone, Laser und Sicherheit geschulter Maschinen</a></li>
<li><a href="../de475390/index.html">So erstellen Sie Ihre erste Webanwendung mit Go</a></li>
<li><a href="../de475392/index.html">Warum sollte man python -m pip verwenden?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>