<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèçÔ∏è üèáüèø üë®‚Äçüë¶ Wie haben wir WebAssembly in Yandex.Maps implementiert und warum haben wir JavaScript verlassen? ‚úçüèæ üëÉüèø üë©üèæ‚Äç‚öïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mein Name ist Valery Shavel, ich bin vom Entwicklungsteam der Yandex.Maps-Vektor-Engine. K√ºrzlich haben wir die WebAssembly-Technologie in die Engine ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie haben wir WebAssembly in Yandex.Maps implementiert und warum haben wir JavaScript verlassen?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/475382/">  Mein Name ist Valery Shavel, ich bin vom Entwicklungsteam der Yandex.Maps-Vektor-Engine.  K√ºrzlich haben wir die WebAssembly-Technologie in die Engine implementiert.  Im Folgenden erkl√§re ich Ihnen, warum wir es ausgew√§hlt haben, welche Ergebnisse wir erzielt haben und wie Sie diese Technologie in Ihrem Projekt einsetzen k√∂nnen. <br><br><img src="https://habrastorage.org/webt/an/k6/3k/ank63kqu8nzp0l-yc6qeql2gpow.png"><br><a name="habracut"></a><br>  In Yandex.Maps besteht eine Vektorkarte aus Teilen, die als Kacheln bezeichnet werden.  Tats√§chlich ist die Kachel der indizierte Bereich der Karte.  Die Karte ist ein Vektor, daher enth√§lt jede Kachel viele geometrische Grundelemente.  Kacheln werden vom Server zum Client verschl√ºsselt, und vor der Anzeige m√ºssen alle Grundelemente verarbeitet werden.  Manchmal dauert es sehr lange.  Eine Kachel kann mehr als 2000 Polylinien und Polygone enthalten. <br><br><img src="https://habrastorage.org/webt/xh/o4/lu/xho4lutlo850vm89roaysk5kcno.png"><br><br>  Bei der Verarbeitung von Grundelementen ist die Leistung am wichtigsten.  Wenn die Kachel nicht schnell genug vorbereitet wird, sieht der Benutzer sie zu sp√§t und die n√§chsten Kacheln werden in der Warteschlange verz√∂gert.  Um die Verarbeitung zu beschleunigen, haben wir uns f√ºr die relativ neue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WebAssembly (Wasm)</a> -Technologie entschieden. <br><br><h2>  Verwenden von WebAssembly in Maps <br></h2><br>  Jetzt findet der Gro√üteil der Verarbeitung von Primitiven im Hintergrundthread (Web Worker) statt, der ein separates Leben f√ºhrt.  Dies geschieht, um den Haupt-Thread so weit wie m√∂glich zu entladen.  Wenn der Code zum Anzeigen der Karte auf der Service-Seite eingebettet ist, die selbst eine erhebliche Belastung verursachen kann, treten daher weniger Bremsen auf.  Der Nachteil ist, dass Sie das Messaging zwischen dem Hauptthread und dem Web Worker ordnungsgem√§√ü konfigurieren m√ºssen. <br><br>  Der Teil der Verarbeitung, der im Hintergrundthread stattfindet, besteht im Wesentlichen aus zwei Schritten: <br><br><ol><li>  Das vom Server kommende Protobuf-Format wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dekodiert</a> . </li><li>  Geometrien werden generiert und in Puffer geschrieben. </li></ol><br>  Im zweiten Schritt werden Vertex- und Indexpuffer f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WebGL gebildet</a> .  Diese Puffer werden beim Rendern wie folgt verwendet.  Ein Scheitelpunktpuffer enth√§lt f√ºr jeden Scheitelpunkt seine Parameter, die zur Bestimmung seiner Position auf dem Bildschirm zu einem bestimmten Zeitpunkt erforderlich sind.  Ein Indexpuffer besteht aus Dreifachen von Indizes.  Jedes Tripel bedeutet, dass ein Dreieck mit Eckpunkten aus dem Eckpunktpuffer an den angegebenen Indizes auf dem Bildschirm angezeigt werden soll.  Daher muss das Grundelement in Dreiecke unterteilt werden, was auch eine zeitaufw√§ndige Aufgabe sein kann: <br><br><img width="600" src="https://habrastorage.org/webt/c0/tx/g_/c0txg_g-tfkpja6efsq_tp5cu_a.png"><br><br>  Offensichtlich gibt es im zweiten Schritt viele Ged√§chtnismanipulationen und mathematische Berechnungen, da Sie f√ºr das korrekte Rendern von Grundelementen viele Informationen zu jedem Scheitelpunkt des Grundelements ben√∂tigen: <br><br><img width="600" src="https://habrastorage.org/webt/ug/-o/ej/ug-oej1lr58fgc7-r_ug7bbc--o.png"><br><br>  Wir waren mit der Leistung unseres JavaScript-Codes nicht zufrieden.  Zu dieser Zeit begann jeder √ºber WebAssembly zu schreiben, die Technologie wurde st√§ndig weiterentwickelt und verbessert.  Nachdem wir die Forschungsergebnisse gelesen hatten, schlugen wir vor, dass Wasm unsere Operationen beschleunigen k√∂nnte.  Obwohl wir uns dessen nicht ganz sicher waren: Es stellte sich als schwierig heraus, Daten zur Verwendung von Wasm in einem so gro√üen Projekt zu finden. <br><br>  Wasm ist auch etwas schlechter als TypeScript: <br><br><ol><li> Wir m√ºssen ein spezielles Modul mit den von uns ben√∂tigten Funktionen initialisieren.  Dies kann zu einer Verz√∂gerung f√ºhren, bevor diese Funktionalit√§t funktioniert. </li><li>  Die Gr√∂√üe des Quellcodes beim Kompilieren von Wasm ist viel gr√∂√üer als in TS. </li><li>  Entwickler m√ºssen eine alternative Version der Codeausf√ºhrung unterst√ºtzen, die auch f√ºr das Frontend in einer atypischen Sprache geschrieben ist. </li></ol><br>  Trotzdem riskierten wir, einen Teil unseres Codes mit Wasm neu zu schreiben. <br><br><h2>  Allgemeine Informationen zu WebAssembly </h2><br><img src="https://habrastorage.org/webt/jn/lz/5h/jnlz5h5iwocxqes5bsmv9tdcil4.png"><br><br>  Wasm ist ein Bin√§rformat.  Sie k√∂nnen verschiedene Sprachen darin kompilieren und den Code dann in einem Browser ausf√ºhren.  Oft ist ein solcher vorkompilierter Code schneller als klassisches JavaScript.  Der Code im WebAssembly-Format hat keinen Zugriff auf die DOM-Elemente der Seite und wird in der Regel zum Ausf√ºhren zeitaufwendiger Rechenaufgaben auf dem Client verwendet. <br><br>  Wir haben C ++ als kompilierte Sprache gew√§hlt, da es sehr praktisch und schnell ist. <br><br>  Um C ++ in WebAssembly zu kompilieren, haben wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">emscripten verwendet</a> .  Nach der Installation und dem Hinzuf√ºgen zu einem C ++ - Projekt m√ºssen Sie die Hauptprojektdatei auf eine bestimmte Weise schreiben, um das Modul zu erhalten.  Zum Beispiel k√∂nnte es so aussehen: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;emscripten/bind.h&gt; #include &lt;emscripten.h&gt; #include &lt;math.h&gt; struct Point { double x; double y; }; double sqr(double x) { return x * x; } EMSCRIPTEN_BINDINGS(my_value_example) { emscripten::value_object&lt;Point&gt;("Point") .field("x", &amp;Point::x) .field("y", &amp;Point::y) ; emscripten::register_vector&lt;Point&gt;("vector&lt;Point&gt;"); emscripten::function("distance", emscripten::optional_override( [](Point point1, Point point2) { return sqrt(sqr(point1.x - point2.x) + sqr(point1.y - point2.y)) ; })); }</span></span></span></span></code> </pre> <br>  Als N√§chstes beschreibe ich, wie Sie diesen Code in Ihrem TypeScript-Projekt verwenden k√∂nnen. <br><br>  Im Code definieren wir die Point-Struktur und ordnen sie der Point-Schnittstelle in TypeScript zu, in der es zwei Felder gibt - x und y, die den Feldern der Struktur entsprechen. <br><br>  Wenn wir den Standardvektorcontainer von C ++ nach TypeScript zur√ºckgeben m√∂chten, m√ºssen wir ihn f√ºr den Point-Typ registrieren.  Dann wird in TypeScript die Schnittstelle mit den erforderlichen Funktionen entsprechen. <br><br>  Und schlie√ülich zeigt der Code, wie Sie Ihre Funktion registrieren, um sie von TypeScript mit dem entsprechenden Namen aufzurufen. <br><br>  Kompilieren Sie die Datei mit emscripten und f√ºgen Sie das resultierende Modul Ihrem TypeScript-Projekt hinzu.  Jetzt k√∂nnen wir eine generische d.ts-Datei f√ºr ein beliebiges emscripten-Modul schreiben, in der n√ºtzliche Funktionen und Typen vordefiniert sind: <br><br><pre> <code class="javascript hljs">declare <span class="hljs-built_in"><span class="hljs-built_in">module</span></span> <span class="hljs-string"><span class="hljs-string">"emscripten_module"</span></span> { interface EmscriptenModule { readonly wasmMemory: WebAssembly.Memory; readonly HEAPU8: <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>; readonly HEAPF64: <span class="hljs-built_in"><span class="hljs-built_in">Float64Array</span></span>; locateFile: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">path: string</span></span></span><span class="hljs-function">) =&gt;</span></span> string; onRuntimeInitialized: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; _malloc: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">size: size_t</span></span></span><span class="hljs-function">) =&gt;</span></span> uintptr_t; _free: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">addr: size_t</span></span></span><span class="hljs-function">) =&gt;</span></span> uintptr_t; } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> EmscriptenModule; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> type uintptr_t = number; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> type size_t = number; }</code> </pre> <br>  Und wir k√∂nnen die Datei d.ts f√ºr unser Modul schreiben: <br><br><pre> <code class="javascript hljs">declare <span class="hljs-built_in"><span class="hljs-built_in">module</span></span> <span class="hljs-string"><span class="hljs-string">"emscripten_point"</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> EmscriptenModule, {uintptr_t, size_t} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'emscripten_module'</span></span>; interface NativeObject { <span class="hljs-attr"><span class="hljs-attr">delete</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; } interface Vector&lt;T&gt; extends NativeObject { get(index: number): T; size(): number; } interface Point { readonly x: number; readonly y: number; } interface PointModule extends EmscriptenModule { <span class="hljs-attr"><span class="hljs-attr">distance</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">point1: Point, point2: Point</span></span></span><span class="hljs-function">) =&gt;</span></span> number; } type PointModuleUninitialized = Partial&lt;PointModule&gt;; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createModuleApi</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Module: Partial&lt;PointModule&gt;</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PointModule</span></span></span><span class="hljs-function">; }</span></span></code> </pre> <br>  Jetzt k√∂nnen wir eine Funktion schreiben, die Promise f√ºr die Modulinitialisierung erstellt, und sie verwenden: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> EmscriptenModule <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'emscripten_module'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> createPointModuleApi, {PointModule} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'emscripten_point'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pointModule <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'emscripten_point.wasm'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Promisifies initialization of emscripten module. * * @param moduleUrl URL to wasm file, it could be encoded data URL. * @param moduleInitializer Escripten module factory, * see https://emscripten.org/docs/compiling/WebAssembly.html#compiler-output. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initEmscriptenModule</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ModuleT</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extends</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmscriptenModule</span></span></span><span class="hljs-function">&gt;(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> moduleUrl: string, moduleInitializer: (module: Partial&lt;EmscriptenModule&gt;</span></span></span><span class="hljs-function">) =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ModuleT</span></span></span><span class="hljs-function"> ): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Promise</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ModuleT</span></span></span><span class="hljs-function">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span> = moduleInitializer({ <span class="hljs-attr"><span class="hljs-attr">locateFile</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> moduleUrl, <span class="hljs-attr"><span class="hljs-attr">onRuntimeInitialized</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// module itself is thenable, to prevent infinite promise resolution delete (&lt;any&gt;module).then; resolve(module); } }); }); } const initialization = initEmscriptenModule( 'data:application/wasm;base64,' + pointModule, createPointModuleApi );</span></span></code> </pre> <br>  Jetzt f√ºr dieses Versprechen bekommen wir unser Modul zusammen mit der Distanzfunktion. <br><br>  Leider k√∂nnen Sie den Wasm-Code nicht zeilenweise im Browser debuggen.  Daher ist es notwendig, Tests zu schreiben und Code darauf wie in normalem C ++ auszuf√ºhren, damit Sie die M√∂glichkeit zum bequemen Debuggen haben.  Trotzdem haben Sie auch im Browser Zugriff auf den Standard-Cout-Stream, der alles an die Browserkonsole ausgibt. <br><br>  Ein Projektbeispiel aus dem Artikel ist √ºber diesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> verf√ºgbar, wo Sie die Einstellungen f√ºr webpack.config und CMakeLists sehen k√∂nnen. <br><br><h2>  Ergebnisse </h2><br>  Also haben wir einen Teil unseres Codes neu geschrieben und ein Experiment gestartet, um das Parsen von Polygonen und Polygonen zu ber√ºcksichtigen.  Das Diagramm zeigt die mittleren Ergebnisse f√ºr eine Kachel f√ºr Wasm und JavaScript: <br><br><img src="https://habrastorage.org/webt/3b/of/sn/3bofsn_aq7y_urztp3diizivt1k.png"><br><br>  Als Ergebnis erhalten wir f√ºr jede Metrik solche relativen Koeffizienten: <br><br><img src="https://habrastorage.org/webt/mx/ol/hh/mxolhhmakjlt9d7n8bzkbyarrfc.png"><br><br>  Wie Sie an der reinen primitiven Parsing-Zeit und der Dekodierungszeit f√ºr Kacheln sehen k√∂nnen, ist Wasm mehr als viermal schneller.  Wenn Sie sich die gesamte Parsing-Zeit ansehen, ist der Unterschied ebenfalls signifikant, aber immer noch etwas geringer.  Dies ist auf die Kosten zur√ºckzuf√ºhren, die f√ºr die √úbermittlung von Daten an Wasm und die Erfassung des Ergebnisses anfallen.  Es ist auch erw√§hnenswert, dass in den ersten Kacheln der Gesamtgewinn sehr hoch ist (in den ersten zehn - mehr als f√ºnf Mal).  Dann nimmt der relative Koeffizient jedoch auf etwa drei ab. <br><br>  Auf diese Weise konnte die Verarbeitungszeit einer Kachel im Hintergrundfaden um 20‚Äì25% reduziert werden.  Nat√ºrlich ist dieser Unterschied nicht so gro√ü wie der der vorherigen, aber Sie m√ºssen verstehen, dass das Parsen von unterbrochenen Linien und Polygonen weit von der gesamten Kachelverarbeitung entfernt ist. <br><br>  Wenn wir √ºber die Notwendigkeit sprechen, das Modul zu initialisieren, hatte ungef√§hr die H√§lfte der Benutzer eine Verz√∂gerung, bevor sie die erste Kachel analysierten.  Die mediane Verz√∂gerung betr√§gt 188 ms.  Die Verz√∂gerung tritt nur vor dem ersten Pl√§ttchen auf, und der Gewinn beim Parsen ist konstant, sodass Sie am Anfang eine kleine Pause in Kauf nehmen k√∂nnen, die kein ernstes Problem darstellt. <br><br>  Eine andere negative Seite ist die Gr√∂√üe der Quellcodedatei.  Gzip-komprimierter verkleinerter Code f√ºr die gesamte Vektorkarten-Engine ohne Wasm - 85 KB, mit Wasm - 191 KB.  Gleichzeitig wird in Wasm nur das Parsen von unterbrochenen Linien und Rechtecken implementiert, und nicht alle Grundelemente, die sich in einer Kachel befinden k√∂nnen.  Au√üerdem musste ich zum Dekodieren von protobuf eine Bibliotheksimplementierung in reinem C w√§hlen, bei einer C ++ - Implementierung war die Gr√∂√üe sogar noch gr√∂√üer.  Dieser Unterschied kann durch die Verwendung des Compiler-Flags -Oz anstelle von -O3 beim Kompilieren von C ++ etwas verringert werden, ist aber immer noch von Bedeutung.  Dar√ºber hinaus verlieren wir durch einen solchen Austausch an Produktivit√§t. <br><br>  Die Gr√∂√üe der Quelle hatte jedoch keinen wesentlichen Einfluss auf die Initialisierungsgeschwindigkeit der Karte.  Wasm ist nur auf langsamen Ger√§ten schlechter und die Differenz betr√§gt weniger als 2%.  Die anf√§nglich sichtbaren Vektorkacheln in der Implementierung mit Wasm wurden den Benutzern jedoch etwas schneller als mit der JS-Implementierung angezeigt.  Dies ist auf den h√∂heren Gewinn bei den ersten bearbeiteten Kacheln zur√ºckzuf√ºhren, w√§hrend JS noch nicht optimiert ist. <br><br>  Daher ist Wasm jetzt eine gute Option, wenn Sie mit der Leistung von JavaScript-Code nicht vertraut sind.  Gleichzeitig k√∂nnen Sie weniger Leistungsgewinn erzielen als wir, oder Sie k√∂nnen ihn √ºberhaupt nicht erzielen.  Dies liegt an der Tatsache, dass JavaScript selbst manchmal recht schnell funktioniert und Sie in Wasm Daten √ºbertragen und das Ergebnis sammeln m√ºssen. <br><br>  Auf unseren Karten wird jetzt regelm√§√üig JavaScript ausgef√ºhrt.  Dies liegt an der Tatsache, dass der Gewinn beim Parsen vor dem allgemeinen Hintergrund nicht so gro√ü ist, und an der Tatsache, dass nur einige Arten von Grundelementen in Wasm implementiert sind.  Wenn sich dies √§ndert, verwenden wir m√∂glicherweise Wasm.  Ein weiteres schlagkr√§ftiges Argument dagegen ist die Komplexit√§t des Assemblierens und Debuggens: Die Unterst√ºtzung eines Projekts in zwei Sprachen ist nur dann sinnvoll, wenn sich der Leistungszuwachs lohnt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de475382/">https://habr.com/ru/post/de475382/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de475358/index.html">Gehaltsanalyse in der IT-Branche in Armenien sowie offene Stellen in den TOP10-IT-Unternehmen</a></li>
<li><a href="../de475366/index.html">Droidcon London 2019: Neue Trends und die interessantesten Berichte</a></li>
<li><a href="../de475368/index.html">Wie berechnet man die Effektivit√§t von Werbung?</a></li>
<li><a href="../de475372/index.html">Front-End-Domain basierend auf TLS 1.3</a></li>
<li><a href="../de475378/index.html">"Wir k√∂nnen die Rechte f√ºr personenbezogene Daten nicht gro√üen Unternehmen √ºberlassen" - ehemaliger Chefredakteur von Wired UK √ºber die Zukunft der Technologie</a></li>
<li><a href="../de475384/index.html">Was ist neu in Spring Boot 2.2?</a></li>
<li><a href="../de475386/index.html">Achtung, FAS: Wie verst√∂√üt man nicht gegen das Werbegesetz? Werbetreibenden-Memo</a></li>
<li><a href="../de475388/index.html">Sicherheitswoche 46: Mikrofone, Laser und Sicherheit geschulter Maschinen</a></li>
<li><a href="../de475390/index.html">So erstellen Sie Ihre erste Webanwendung mit Go</a></li>
<li><a href="../de475392/index.html">Warum sollte man python -m pip verwenden?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>