<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👔 ⭐️ 👛 Bungkus urutan dalam Swift 🚱 🤾🏼 💇🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya. Hari ini kami ingin membagikan terjemahan yang disiapkan pada malam sebelum peluncuran kursus “Pengembang iOS. Kursus Lanjutan . " Ayo ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bungkus urutan dalam Swift</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/464995/"><p>  <em>Halo semuanya.</em>  <em>Hari ini kami ingin membagikan terjemahan yang disiapkan pada malam sebelum peluncuran kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">“Pengembang iOS.</a></em>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kursus Lanjutan</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"</a></em>  <em>Ayo pergi!</em> </p><br><p><img src="https://habrastorage.org/webt/sk/fh/uc/skfhuco7bg9_mhjmpvov6ie9qao.png"></p><br><p>  Salah satu keunggulan utama desain berbasis protokol Swift adalah memungkinkan kita untuk menulis kode generik yang kompatibel dengan berbagai jenis, dan tidak secara khusus diterapkan untuk semua orang.  Terutama jika kode umum seperti itu dimaksudkan untuk salah satu protokol, yang dapat ditemukan di perpustakaan standar, yang akan memungkinkan menggunakannya dengan baik tipe bawaan dan yang ditetapkan pengguna. </p><a name="habracut"></a><br><p>  Contoh protokol semacam itu adalah Sequence, yang diterima oleh semua jenis pustaka standar yang dapat diulang, seperti Array, Kamus, Set, dan banyak lainnya.  Minggu ini, mari kita lihat bagaimana kita dapat membungkus Sequence dalam wadah universal, yang akan memungkinkan kita untuk merangkum berbagai algoritma pada inti API yang mudah digunakan. </p><br><h3 id="iskusstvo-byt-lenivym">  Seni menjadi malas </h3><br><p>  Sangat mudah untuk bingung dengan berpikir bahwa semua urutan mirip dengan Array, karena semua elemen langsung dimuat ke memori ketika urutan dibuat.  Karena satu-satunya persyaratan protokol Urutan adalah bahwa penerima harus dapat mengulangi, kami tidak dapat membuat asumsi tentang bagaimana elemen dari urutan yang tidak diketahui dimuat atau disimpan. <br>  Sebagai contoh, seperti yang kita bahas dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Swift Sequences: The Art of Being Lazy</a> , sekuens kadang-kadang dapat memuat elemen mereka dengan malas - baik karena alasan kinerja atau karena tidak dijamin bahwa seluruh sekuens dapat masuk dalam memori.  Berikut adalah beberapa contoh dari urutan tersebut: </p><br><pre><code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,          ,           . let records = database.records(matching: searchQuery) //     ,       ,      . let folders = folder.subfolders //   ,     ,            . let nodes = node.children</span></span></code> </pre> <br><p>  Karena semua urutan di atas malas karena alasan tertentu, kami tidak ingin memaksanya ke dalam array, misalnya, dengan memanggil Array (folder.subfolderers).  Tapi kami mungkin masih ingin memodifikasi dan bekerja dengannya dengan cara yang berbeda, jadi mari kita lihat bagaimana kita bisa melakukan ini dengan membuat jenis pembungkus urutan. </p><br><h3 id="sozdanie-osnovy">  Pembuatan fondasi </h3><br><p>  Mari kita mulai dengan membuat tipe dasar yang dapat kita gunakan untuk membuat semua jenis API yang nyaman di atas urutan apa pun.  Kami akan menyebutnya WrappedSequence, dan itu akan menjadi tipe universal yang mengandung kedua jenis urutan yang kami bungkus dan jenis elemen yang kami ingin urutan baru kami buat. <br>  Fitur utama pembungkus kami adalah IteratorFunction-nya, yang akan memungkinkan kami untuk mengendalikan pencarian urutan dasar - mengubah Iterator yang digunakan untuk setiap iterasi: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WrappedSequence</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapped</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Element</span></span></span><span class="hljs-class">&gt;: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">IteratorFunction</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> <span class="hljs-type"><span class="hljs-type">Wrapped</span></span>.<span class="hljs-type"><span class="hljs-type">Iterator</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Element?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> wrapped: <span class="hljs-type"><span class="hljs-type">Wrapped</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iterator: <span class="hljs-type"><span class="hljs-type">IteratorFunction</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(wrapping wrapped: <span class="hljs-type"><span class="hljs-type">Wrapped</span></span>, iterator: @escaping <span class="hljs-type"><span class="hljs-type">IteratorFunction</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.wrapped = wrapped <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.iterator = iterator } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeIterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">AnyIterator</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Element</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wrappedIterator = wrapped.makeIterator() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">AnyIterator</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.iterator(&amp;wrappedIterator) } } }</code> </pre> <br><p>  <em>Seperti yang Anda lihat di atas, Sequence menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pola pabrik</a> sehingga setiap urutan membuat instance iterator baru untuk setiap iterasi - menggunakan metode makeIterator ().</em> </p><br><p>  Di atas, kami menggunakan tipe AnyIterator dari library standar, yang merupakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">iterator dari penghapusan tipe</a> yang dapat menggunakan implementasi IteratorProtocol dasar untuk mendapatkan nilai Elemen.  Dalam kasus kami, kami akan membuat elemen dengan memanggil Fungsi Iterator kami, meneruskan sebagai argumen iterator kami sendiri dari urutan yang dibungkus, dan karena argumen ini ditandai sebagai inout, kami dapat mengubah iterator dasar di tempatnya di dalam fungsi kami. </p><br><p>  Karena WrappedSequence juga merupakan urutan, kita dapat menggunakan semua fungsi pustaka standar yang terkait dengannya, seperti mengulanginya atau mengubah nilainya menggunakan peta: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> folderNames = <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>(wrapping: folders) { iterator <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iterator.next()?.name } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> folderNames { ... } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> uppercasedNames = folderNames.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span>.uppercased() }</code> </pre> <br><p>  Sekarang mari kita mulai dengan WrappedSequence baru kami! </p><br><h3 id="prefiksy-i-suffiksy">  Prefiks dan Sufiks </h3><br><p>  Ketika bekerja dengan urutan sangat sering ada keinginan untuk memasukkan awalan atau akhiran dalam urutan yang kita kerjakan - tetapi bukankah lebih bagus jika kita bisa melakukan ini tanpa mengubah urutan utama?  Ini dapat menghasilkan kinerja yang lebih baik dan memungkinkan kami untuk menambahkan awalan dan sufiks ke urutan apa pun, dan bukan hanya tipe umum seperti Array. </p><br><p>  Menggunakan WrappedSequence, kita bisa melakukan ini dengan mudah.  Yang perlu kita lakukan adalah memperluas Sequence dengan metode yang menciptakan urutan terbungkus dari array elemen untuk disisipkan sebagai awalan.  Kemudian, ketika kita beralih lagi, kita mulai mengulangi semua elemen awalan sebelum melanjutkan dengan urutan dasar - seperti ini: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prefixed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( with prefixElements: Element... )</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Self</span></span>, <span class="hljs-type"><span class="hljs-type">Element</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> prefixIndex = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>(wrapping: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { iterator <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-comment"><span class="hljs-comment">//        ,   ,   ,   : guard prefixIndex &gt;= prefixElements.count else { let element = prefixElements[prefixIndex] prefixIndex += 1 return element } //           : return iterator.next() } } }</span></span></code> </pre> <br><p>  <em>Di atas, kami menggunakan parameter dengan sejumlah variabel argumen (menambahkan ... ke tipenya) untuk memungkinkan transmisi satu atau lebih elemen ke metode yang sama.</em> <br>  Dengan cara yang sama, kita dapat membuat metode yang menambahkan seperangkat sufiks yang diberikan ke akhir urutan - pertama dengan melakukan iterasi kita sendiri dari urutan dasar dan kemudian iterasi di atas elemen sufiks: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">suffixed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( with suffixElements: Element... )</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Self</span></span>, <span class="hljs-type"><span class="hljs-type">Element</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> suffixIndex = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>(wrapping: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { iterator <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> next = iterator.next() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    ,     nil      : guard suffixIndex &lt; suffixElements.count else { return nil } let element = suffixElements[suffixIndex] suffixIndex += 1 return element } return next } } }</span></span></code> </pre> <br><p>  Dengan dua metode yang disebutkan di atas, kita sekarang dapat menambahkan awalan dan sufiks ke urutan apa pun yang kita inginkan.  Berikut adalah beberapa contoh bagaimana API baru kami dapat digunakan: </p><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//      : let allFolders = rootFolder.subfolders.prefixed(with: rootFolder) //       : let messages = inbox.messages.suffixed(with: composer.message) //       ,      : let characters = code.prefixed(with: "{").suffixed(with: "}")</span></span></code> </pre> <br><p>  Meskipun semua contoh di atas dapat diimplementasikan menggunakan tipe tertentu (seperti Array dan String), keuntungan menggunakan tipe WrappedSequence kami adalah bahwa semuanya dapat dilakukan dengan malas - kami tidak melakukan mutasi atau mengevaluasi urutan apa pun untuk menambahkan awalan atau sufiks - yang bisa sangat berguna dalam situasi kritis untuk kinerja, atau ketika bekerja dengan kumpulan data besar. </p><br><h3 id="cegmentaciya">  Segmentasi </h3><br><p>  Selanjutnya, mari kita lihat bagaimana kita dapat membungkus urutan untuk membuat versi tersegmentasi dari mereka.  Dalam iterasi tertentu, tidak cukup untuk mengetahui apa elemen saat ini - kita mungkin juga memerlukan informasi tentang elemen berikutnya dan sebelumnya. <br>  Saat bekerja dengan urutan yang diindeks, kita sering dapat mencapai ini menggunakan enumerated () API, yang juga menggunakan pembungkus urutan untuk memberi kita akses ke elemen saat ini dan indeksnya: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (index, current) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> list.items.enumerated() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> previous = (index &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) ? list.items[index - <span class="hljs-number"><span class="hljs-number">1</span></span>] : <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> next = (index &lt; list.items.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) ? list.items[index + <span class="hljs-number"><span class="hljs-number">1</span></span>] : <span class="hljs-literal"><span class="hljs-literal">nil</span></span> ... }</code> </pre> <br><p>  Namun, teknik di atas tidak hanya cukup bertele-tele dalam hal doa, itu juga bergantung pada penggunaan array lagi - atau setidaknya beberapa bentuk urutan yang memberi kita akses acak ke elemen-elemennya - yang banyak urutan, terutama yang malas, tidak diterima <br>  Alih-alih, mari kita gunakan WrappedSequence kami lagi - untuk membuat pembungkus urutan yang dengan malas memberikan tampilan tersegmentasi dalam urutan basisnya, melacak elemen sebelumnya dan saat ini dan memperbaruinya saat terus beralih ke: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">Segment</span></span> = ( previous: <span class="hljs-type"><span class="hljs-type">Element?</span></span>, current: <span class="hljs-type"><span class="hljs-type">Element</span></span>, next: <span class="hljs-type"><span class="hljs-type">Element?</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> segmented: <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Self</span></span>, <span class="hljs-type"><span class="hljs-type">Segment</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> previous: <span class="hljs-type"><span class="hljs-type">Element?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> current: <span class="hljs-type"><span class="hljs-type">Element?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> endReached = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>(wrapping: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { iterator <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-comment"><span class="hljs-comment">//        ,      ,   ,        ,     . guard !endReached, let element = current ?? iterator.next() else { return nil } let next = iterator.next() let segment = (previous, element, next) //     ,    ,      : previous = element current = next endReached = (next == nil) return segment } } }</span></span></code> </pre> <br><p>  Sekarang kita dapat menggunakan API di atas untuk membuat versi tersegmentasi dari setiap urutan kapan pun kita perlu melihat ke depan atau ke belakang saat melakukan iterasi.  Sebagai contoh, berikut adalah bagaimana kami dapat menggunakan segmentasi sehingga kami dapat dengan mudah menentukan kapan kami telah mencapai akhir daftar: </p><br><pre> <code class="plaintext hljs">for segment in list.items.segmented { addTopBorder() addView(for: segment.current) if segment.next == nil { //   ,     addBottomBorder() } } ```swift        ,   .    ,               : ```swift for segment in path.nodes.segmented { let directions = ( enter: segment.previous?.direction(to: segment.current), exit: segment.next.map(segment.current.direction) ) let nodeView = NodeView(directions: directions) nodeView.center = segment.current.position.cgPoint view.addSubview(nodeView) }</code> </pre> <br><p>  Sekarang kita mulai melihat kekuatan sebenarnya dari urutan pembungkusan - karena memungkinkan kita untuk menyembunyikan lebih banyak dan lebih kompleks algoritma dalam API yang sangat sederhana.  Semua penelepon perlu melakukan segmentasi urutan mengakses properti tersegmentasi dalam Urutan apapun, dan implementasi dasar kami akan mengurus sisanya. </p><br><h3 id="rekursiya">  Rekursi </h3><br><p>  Akhirnya, mari kita lihat bagaimana iterasi rekursif dapat dimodelkan menggunakan pembungkus urutan.  Misalkan kita ingin memberikan cara sederhana untuk secara berulang mengulangi hierarki nilai di mana setiap elemen dalam hierarki berisi urutan elemen anak.  Mungkin cukup sulit untuk melakukannya dengan benar, jadi alangkah baiknya jika kita dapat menggunakan satu implementasi untuk melakukan semua iterasi seperti itu di basis kode kita. <br>  Menggunakan WrappedSequence, kita dapat mencapai ini dengan memperluas Sequence dengan metode yang menggunakan batasan tipe generik yang sama untuk memastikan bahwa setiap elemen dapat memberikan urutan bersarang yang memiliki tipe iterator yang sama seperti aslinya.  Untuk dapat mengakses secara dinamis setiap urutan bersarang, kami juga akan meminta pemanggil untuk menentukan KeyPath untuk properti yang harus digunakan untuk rekursi, yang akan memberi kami implementasi yang terlihat seperti ini: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">recursive</span></span></span><span class="hljs-function">&lt;S: Sequence&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> keyPath: KeyPath&lt;Element, S&gt; )</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Self</span></span>, <span class="hljs-type"><span class="hljs-type">Element</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-type"><span class="hljs-type">S</span></span>.<span class="hljs-type"><span class="hljs-type">Iterator</span></span> == <span class="hljs-type"><span class="hljs-type">Iterator</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parentIterators = [<span class="hljs-type"><span class="hljs-type">Iterator</span></span>]() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">moveUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; (iterator: <span class="hljs-type"><span class="hljs-type">Iterator</span></span>, element: <span class="hljs-type"><span class="hljs-type">Element</span></span>)? { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> !parentIterators.isEmpty <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> iterator = parentIterators.removeLast() <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> element = iterator.next() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//          ,    ,      : return moveUp() } return (iterator, element) } return WrappedSequence(wrapping: self) { iterator in //       ,      ,      : let element = iterator.next() ?? { return moveUp().map { iterator = $0 return $1 } }() //       ,  ,         ,         . if let nested = element?[keyPath: keyPath].makeIterator() { let parent = iterator parentIterators.append(parent) iterator = nested } return element } } }</span></span></code> </pre> <br><p>  Dengan menggunakan di atas, kita sekarang dapat secara berulang mengulangi urutan apa pun, terlepas dari bagaimana itu dibangun di dalam, dan tanpa harus memuat seluruh hierarki di muka.  Misalnya, inilah cara kami dapat menggunakan API baru ini untuk secara berulang mengulangi melalui hierarki folder: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> allFolders = folder.subfolders.recursive(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: \.subfolders) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> folder <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> allFolders { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> loadContent(from: folder) }</code> </pre> <br><p>  Kami juga dapat menggunakannya untuk beralih pada semua simpul pohon atau untuk secara rekursif melintasi serangkaian catatan basis data - misalnya, untuk membuat daftar semua grup pengguna dalam suatu organisasi: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> allNodes = tree.recursive(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: \.children) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> allGroups = database.groups.recusive(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: \.subgroups)</code> </pre> <br><p>  Satu hal yang perlu kita berhati-hati ketika datang ke iterasi rekursif adalah untuk mencegah referensi melingkar - ketika jalur tertentu mengembalikan kita ke elemen yang telah kita temui - yang akan membawa kita ke loop tak terbatas. <br>  Salah satu cara untuk memperbaikinya adalah dengan melacak semua elemen yang terjadi (tetapi bisa bermasalah dari sudut pandang memori), untuk memastikan bahwa tidak ada referensi melingkar dalam kumpulan data kami, atau untuk menangani kasus-kasus seperti itu setiap kali dari sisi panggilan (menggunakan break, melanjutkan atau kembali untuk menyelesaikan setiap iterasi siklik). </p><br><h3 id="zaklyuchenie">  Kesimpulan </h3><br><p>  Sequence adalah salah satu protokol paling sederhana di perpustakaan standar - hanya membutuhkan satu metode - tetapi masih salah satu yang paling kuat, terutama ketika datang ke berapa banyak fungsionalitas yang bisa kita buat berdasarkan itu.  Sama seperti perpustakaan standar yang berisi urutan wrapper untuk hal-hal seperti enumerasi, kami juga dapat membuat pembungkus kami sendiri - yang memungkinkan kami menyembunyikan fungsionalitas tingkat lanjut dengan API yang sangat sederhana. </p><br><p>  Meskipun abstraksi selalu ada harganya, penting untuk mempertimbangkan kapan bermanfaat (dan mungkin lebih penting jika tidak layak) untuk memperkenalkannya, jika kita dapat membangun abstraksi langsung di atas apa yang disediakan oleh perpustakaan standar - menggunakan konvensi yang sama - maka ini abstraksi biasanya lebih mungkin bertahan dalam ujian waktu. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464995/">https://habr.com/ru/post/id464995/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464985/index.html">Internet of Things (IoT) akan Mengubah Dunia. Masa depan IoT</a></li>
<li><a href="../id464987/index.html">Repositori di Kubernetes: OpenEBS vs Rook (Ceph) vs Rancher Longhorn vs StorageOS vs Robin vs Portworx vs Linstor</a></li>
<li><a href="../id464989/index.html">Konteks Extravaganza</a></li>
<li><a href="../id464991/index.html">Proyek yang tidak lepas landas</a></li>
<li><a href="../id464993/index.html">Membangun paket RPM untuk Rosa Linux dalam praktiknya</a></li>
<li><a href="../id464997/index.html">Tentang pengembangan teknologi VR: di mana mereka menggunakannya, mengapa bisnis VR dan perangkat mana yang digunakan</a></li>
<li><a href="../id464999/index.html">Bagaimana spesifik bekerja dengan server aplikasi berubah menggunakan contoh OpenLiberty</a></li>
<li><a href="../id465001/index.html">Amazon Prime Day 2019 - Didukung oleh AWS</a></li>
<li><a href="../id465003/index.html">Minat untuk genre ARPG</a></li>
<li><a href="../id465007/index.html">Mengecek Django dan DRF</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>