<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë©‚Äçüëß ü§∏üèª üëçüèª De copiar e colar para componentes: reutilizando c√≥digo em diferentes aplicativos ‚õ∏Ô∏è üë®üèø‚Äçüöí üë≤üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O Badoo desenvolve v√°rias aplica√ß√µes, e cada uma delas √© um produto separado, com suas pr√≥prias caracter√≠sticas, gerenciamento, produto e equipes de e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>De copiar e colar para componentes: reutilizando c√≥digo em diferentes aplicativos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/466049/"><img src="https://habrastorage.org/webt/4j/xp/to/4jxptoi9jrqf5aynpoeurc816ee.jpeg"><br><br>  O Badoo desenvolve v√°rias aplica√ß√µes, e cada uma delas √© um produto separado, com suas pr√≥prias caracter√≠sticas, gerenciamento, produto e equipes de engenharia.  Mas todos trabalhamos juntos no mesmo escrit√≥rio e resolvemos problemas semelhantes. <br><br>  O desenvolvimento de cada projeto ocorreu √† sua maneira.  A base de c√≥digo foi influenciada n√£o apenas por diferentes prazos e solu√ß√µes de produtos, mas tamb√©m pela vis√£o dos desenvolvedores.  No final, percebemos que os projetos t√™m a mesma funcionalidade, que √© fundamentalmente diferente na implementa√ß√£o. <br><br>  Decidimos chegar a uma estrutura que nos daria a oportunidade de reutilizar recursos entre aplicativos.  Agora, em vez de desenvolver funcionalidades em projetos individuais, criamos componentes comuns que se integram a todos os produtos.  Se voc√™ est√° interessado em como chegamos a isso, seja bem-vindo ao gato. <a name="habracut"></a><br><br>  Mas primeiro, vamos nos debru√ßar sobre os problemas, cuja solu√ß√£o levou √† cria√ß√£o de componentes comuns.  Havia v√°rios deles: <br><br><ul><li>  copiar e colar entre aplicativos; <br></li><li>  processos que inserem varas nas rodas; <br></li><li>  arquitetura diferente de projetos. <br></li></ul><br><img src="https://habrastorage.org/webt/wq/ls/ov/wqlsovroayg0xhqrwibqc37pv6y.png"><br><br>  <i>Este artigo √© uma vers√£o em texto do meu relat√≥rio com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AppsConf 2019</a> , que pode ser visualizada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .</i> <br><br><h2>  Problema: copiar e colar </h2><br>  Algum tempo atr√°s, quando as √°rvores estavam mais nebulosas, a grama era mais verde e eu era um ano mais jovem, muitas vezes tivemos a seguinte situa√ß√£o. <br><br>  H√° um desenvolvedor, vamos cham√°-lo de Lesha.  Ele cria um m√≥dulo interessante para sua tarefa, conta a seus colegas e o coloca no reposit√≥rio do aplicativo, onde ele o usa. <br><br>  O problema √© que todos os nossos aplicativos est√£o em reposit√≥rios diferentes. <br><br><img src="https://habrastorage.org/webt/-a/1f/zq/-a1fzqhp9m--jhxy1tcrmx7plwi.png"><br><br>  O desenvolvedor Andrey atualmente est√° trabalhando em outro aplicativo em um reposit√≥rio diferente.  Ele quer usar este m√≥dulo em sua tarefa, que √© suspeitamente semelhante ao que Lesha estava envolvido.  Mas h√° um problema: o processo de reutiliza√ß√£o de c√≥digo √© completamente depurado. <br><br>  Nessa situa√ß√£o, Andrei escrever√° sua decis√£o (o que acontece em 80% dos casos) ou copiar√° e cole a solu√ß√£o do Lyosha e alterar√° tudo nela para que se adapte √† sua aplica√ß√£o, tarefa ou humor. <br><br><img src="https://habrastorage.org/webt/2e/nd/95/2end959nckg-szaxu_nwwwcqxtm.png"><br><br>  Depois disso, Lesha pode atualizar seu m√≥dulo adicionando altera√ß√µes ao seu c√≥digo para sua tarefa.  Ele n√£o conhece outra vers√£o e atualizar√° apenas seu reposit√≥rio. <br><br>  Esta situa√ß√£o traz v√°rios problemas. <br><br>  Primeiro, temos v√°rias aplica√ß√µes, cada uma com seu pr√≥prio hist√≥rico de desenvolvimento.  Ao trabalhar em cada aplicativo, a equipe do produto geralmente criava solu√ß√µes dif√≠ceis de trazer para uma √∫nica estrutura. <br><br>  Em segundo lugar, equipes separadas est√£o envolvidas em projetos, que se comunicam mal entre si e, portanto, raramente se informam sobre atualiza√ß√µes / reutiliza√ß√£o de um ou outro m√≥dulo. <br><br>  Em terceiro lugar, a arquitetura do aplicativo √© muito diferente: do MVP ao MVI, da atividade divina √† atividade √∫nica. <br><br>  Bem, o "destaque do programa": os aplicativos est√£o em reposit√≥rios diferentes, cada um com seus pr√≥prios processos. <br><br>  No in√≠cio da luta contra esses problemas, estabelecemos o objetivo final: reutilizar nossas melhores pr√°ticas (l√≥gica e interface do usu√°rio) entre todos os aplicativos. <br><br><h2>  Decis√µes: estabelecemos processos </h2><br>  Dos problemas acima, dois est√£o relacionados aos processos: <br><br><ol><li>  Dois reposit√≥rios que compartilharam projetos com uma parede impenetr√°vel. <br></li><li>  Equipes separadas sem comunica√ß√£o estabelecida e requisitos diferentes das equipes de aplica√ß√£o do produto. <br></li></ol><br>  Vamos come√ßar com o primeiro: estamos lidando com dois reposit√≥rios com a mesma vers√£o do m√≥dulo.  Teoricamente, poder√≠amos usar git-subtree ou solu√ß√µes similares e colocar m√≥dulos de projetos comuns em reposit√≥rios separados. <br><br><img src="https://habrastorage.org/webt/ro/q0/nr/roq0nrr9xuy2my8ajbsldfcismw.png"><br><br>  O problema ocorre durante a modifica√ß√£o.  Diferentemente dos projetos de c√≥digo aberto, que possuem uma API est√°vel e s√£o distribu√≠dos por fontes externas, as altera√ß√µes geralmente ocorrem em componentes internos que quebram tudo.  Ao usar a sub√°rvore, cada uma dessas migra√ß√µes se torna um problema. <br><br>  Meus colegas da equipe do iOS t√™m uma experi√™ncia semelhante e acabou n√£o tendo muito sucesso, como Anton Schukin falou na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">confer√™ncia Mobius</a> no ano passado. <br><br>  Depois de estudar e compreender sua experi√™ncia, mudamos para um √∫nico reposit√≥rio.  Todos os aplicativos Android agora est√£o em um s√≥ lugar, o que nos d√° alguns benef√≠cios: <br><br><ul><li>  voc√™ pode reutilizar o c√≥digo com seguran√ßa usando os m√≥dulos Gradle; <br></li><li>  conseguimos conectar a cadeia de ferramentas no CI usando uma infraestrutura para compila√ß√µes e testes; <br></li><li>  essas mudan√ßas removeram as barreiras f√≠sicas e mentais entre as equipes, pois agora somos livres para usar os desenvolvimentos e solu√ß√µes uns dos outros. <br></li></ul><br>  Obviamente, esta solu√ß√£o tamb√©m tem desvantagens.  Temos um projeto enorme, que √†s vezes n√£o est√° sujeito ao IDE e Gradle.  O problema pode ser parcialmente resolvido pelos m√≥dulos Carregar / Descarregar no Android Studio, mas √© dif√≠cil us√°-los se voc√™ precisar trabalhar simultaneamente em todos os aplicativos e alternar com frequ√™ncia. <br><br>  O segundo problema - intera√ß√£o entre equipes - consistia em v√°rias partes: <br><br><ul><li>  equipes separadas sem comunica√ß√£o estabelecida; <br></li><li>  distribui√ß√£o indistinta de responsabilidade por m√≥dulos comuns; <br></li><li>  requisitos diferentes das equipes de produtos. <br></li></ul><br>  Para resolv√™-lo, formamos equipes envolvidas na implementa√ß√£o de determinadas funcionalidades em cada aplicativo: por exemplo, bate-papo ou registro.  Al√©m do desenvolvimento, eles tamb√©m s√£o respons√°veis ‚Äã‚Äãpela integra√ß√£o desses componentes no aplicativo. <br><br>  As equipes de produto j√° t√™m componentes em m√£os, melhorando e personalizando-os de acordo com as necessidades de um projeto espec√≠fico. <br><br>  Assim, agora a cria√ß√£o de um componente reutiliz√°vel faz parte do processo para toda a empresa, desde o est√°gio da ideia at√© o in√≠cio da produ√ß√£o. <br><br><h2>  Solu√ß√µes: simplificando a arquitetura </h2><br>  Nosso pr√≥ximo passo para reutilizar foi otimizar a arquitetura.  Por que fizemos isso? <br><br>  Nossa base de c√≥digo carrega o legado hist√≥rico de v√°rios anos de desenvolvimento.  Juntamente com o tempo e as pessoas, as abordagens mudaram.  Ent√£o nos encontramos em uma situa√ß√£o com um zool√≥gico inteiro de arquiteturas, o que resultou nos seguintes problemas: <br><br><ol><li>  A integra√ß√£o de m√≥dulos comuns foi quase mais lenta do que a cria√ß√£o de novos.  Al√©m dos recursos do funcional, era necess√°rio suportar a estrutura do componente e do aplicativo. <br></li><li>  Os desenvolvedores que precisavam alternar entre aplicativos muitas vezes passavam muito tempo dominando novas abordagens. <br></li><li>  Muitas vezes, os wrappers eram gravados de uma abordagem para outra, o que equivalia a metade do c√≥digo na integra√ß√£o do m√≥dulo. <br></li></ol><br>  No final, decidimos pela abordagem MVI, que estruturamos em nossa biblioteca MVICore ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> ).  Est√°vamos particularmente interessados ‚Äã‚Äãem uma de suas caracter√≠sticas - atualiza√ß√µes de estado at√¥mico, que sempre garantem validade.  Fomos um pouco mais longe e combinamos os estados das camadas l√≥gicas e de apresenta√ß√£o, reduzindo a fragmenta√ß√£o.  Assim, chegamos a uma estrutura em que a √∫nica entidade √© respons√°vel pela l√≥gica e a exibi√ß√£o exibe apenas o modelo criado a partir do estado. <br><br><img src="https://habrastorage.org/webt/ze/4z/kr/ze4zkr0ecnm_x9il17ibon6uzkk.png"><br><br>  A separa√ß√£o de responsabilidades ocorre atrav√©s da transforma√ß√£o de modelos entre n√≠veis.  Gra√ßas a isso, recebemos um b√¥nus na forma de reutiliza√ß√£o.  Conectamos os elementos de fora, ou seja, cada um deles n√£o suspeita que o outro exista - eles simplesmente d√£o alguns modelos e reagem ao que lhes chega.  Isso permite que voc√™ retire componentes e os use em outros lugares escrevendo adaptadores para seus modelos. <br><br>  Vejamos um exemplo de uma tela simples como ela se parece na realidade. <br><br><img src="https://habrastorage.org/webt/wm/0k/cs/wm0kcsuh1io0cr4cnil0ui11gme.png"><br><br>  Usamos as interfaces b√°sicas do RxJava para indicar os tipos com os quais o elemento trabalha.  A entrada √© indicada pela interface Consumidor &lt;T&gt;, sa√≠da - ObservableSource &lt;T&gt;. <br><br><pre><code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// input = Consumer&lt;ViewModel&gt; // output = ObservableSource&lt;Event&gt; class View( val events: PublishRelay&lt;Event&gt; ): ObservableSource&lt;Event&gt; by events, Consumer&lt;ViewModel&gt; { val button: Button val textView: TextView init { button.setOnClickListener { events.accept(Event.ButtonClick) } } override fun accept(model: ViewModel) { textView.text = model.text } }</span></span></code> </pre> <br>  Usando essas interfaces, podemos expressar View como Consumer &lt;ViewModel&gt; e ObservableSource &lt;Event&gt;.  Observe que o ViewModel cont√©m apenas o estado da tela e pouco tem a ver com o MVVM.  Depois de receber o modelo, podemos mostrar os dados dele e, quando clicamos no bot√£o, enviamos o evento, que √© transmitido para fora. <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// input = Consumer&lt;Wish&gt; // output = ObservableSource&lt;State&gt; class Feature: ReducerFeature&lt;Wish, State&gt;( initialState = State(counter = 0), reducer = ReducerImpl() ) { class ReducerImpl: Reducer&lt;Wish, State&gt; { override fun invoke(state: State, wish: Wish) = when (wish) { is Increment -&gt; state.copy(counter = state.counter + 1) } } }</span></span></code> </pre> <br>  O recurso j√° implementa o ObservableSource e o Consumidor para n√≥s;  precisamos transferir para l√° o estado inicial (contador igual a 0) e indicar como alterar esse estado. <br><br>  Ap√≥s a transfer√™ncia do Wish, √© chamado Redutor, o que cria um novo com base no √∫ltimo estado.  Al√©m do Redutor, a l√≥gica pode ser descrita por outros componentes.  Voc√™ pode aprender mais sobre eles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  Depois de criar os dois elementos, resta para n√≥s conect√°-los. <br><br><img width="250" src="https://habrastorage.org/webt/pq/kh/jp/pqkhjphpe4pvypmm5y8icqralhy.png" align="left"><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> eventToWish: (Event) -&gt; Wish = { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (it) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ButtonClick -&gt; Increment } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> stateToModel: (State) -&gt; ViewModel = { ViewModel(text = state.counter.toString()) } Binder().apply { bind(view to feature using eventToWish) bind(feature to view using stateToModel) }</code> </pre> <br>  Primeiro, indicamos como transformamos um elemento de um tipo em outro.  Portanto, ButtonClick se torna Increment, e o campo do contador State entra em texto. <br><br>  Agora podemos criar cada uma das cadeias com a transforma√ß√£o desejada.  Para isso, usamos o Binder.  Ele permite que voc√™ crie relacionamentos entre o ObservableSource e o Consumidor, observando o ciclo de vida.  E tudo isso com uma boa sintaxe.  Esse tipo de conex√£o nos leva a um sistema flex√≠vel que nos permite extrair e usar elementos individualmente. <br><br>  Os elementos MVICore funcionam muito bem com nosso "zool√≥gico" de arquiteturas depois de escrever wrappers da ObservableSource e Consumer.  Por exemplo, podemos agrupar os m√©todos de Caso de Uso de Arquitetura Limpa em Desejo / Estado e usar na cadeia em vez de Recurso. <br><br><img src="https://habrastorage.org/webt/l3/x7/ee/l3x7eef1pxxq4qbl6epceicz_1a.png"><br><br><h2>  Componente </h2><br>  Finalmente, passamos aos componentes.  Como eles s√£o? <br><br>  Considere a tela no aplicativo e divida-a em partes l√≥gicas. <br><br><img src="https://habrastorage.org/webt/s6/xb/mg/s6xbmgomehcdqao1psynv5mnnlc.png"><br><br>  Pode ser distinguido: <br><br><ul><li>  barra de ferramentas com logotipo e bot√µes na parte superior; <br></li><li>  um cart√£o com um perfil e logotipo; <br></li><li>  Se√ß√£o do Instagram. <br></li></ul><br>  Cada uma dessas partes √© o pr√≥prio componente que pode ser reutilizado em um contexto completamente diferente.  Portanto, a se√ß√£o do Instagram pode se tornar parte da edi√ß√£o de perfis em outro aplicativo. <br><br><img src="https://habrastorage.org/webt/o_/yh/c7/o_yhc7jqyzwma6l4nljmf2jasuk.png"><br><br>  No caso geral, um componente √© composto por v√°rios modos de exibi√ß√£o, elementos l√≥gicos e componentes aninhados, unidos pela funcionalidade comum.  E imediatamente surge a pergunta: como mont√°-los em uma estrutura suportada? <br><br>  O primeiro problema que encontramos √© que o MVICore ajuda a criar e ligar elementos, mas n√£o oferece uma estrutura comum.  Ao reutilizar elementos de um m√≥dulo comum, n√£o est√° claro onde juntar essas pe√ßas: dentro da pe√ßa comum ou no lado da aplica√ß√£o? <br><br>  No caso geral, definitivamente n√£o queremos fornecer √† aplica√ß√£o partes dispersas.  Idealmente, buscamos algum tipo de estrutura que nos permita obter depend√™ncias e montar o componente como um todo com o ciclo de vida desejado. <br><br>  Inicialmente, dividimos os componentes em telas.  A conex√£o dos elementos ocorreu ao lado da cria√ß√£o de cont√™ineres DI para atividade ou fragmento.  Esses cont√™ineres j√° conhecem todas as depend√™ncias, t√™m acesso ao View e ao ciclo de vida. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> SomeScopedComponent : ScopedComponent&lt;SomeComponent&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: SomeComponent { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DaggerSomeComponent.builder() .build() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> SomeComponent.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Array&lt;Disposable&gt; = arrayOf( Binder().apply { bind(feature().news to otherFeature()) bind(feature() to view()) } ) }</code> </pre> <br>  Os problemas come√ßaram em dois lugares ao mesmo tempo: <br><br><ol><li>  O DI come√ßou a trabalhar com a l√≥gica, o que levou √† descri√ß√£o de todo o componente em uma classe. <br></li><li>  Como o cont√™iner √© anexado a uma Atividade ou Fragmento e descreve pelo menos a tela inteira, h√° muitos elementos nessa tela / cont√™iner, o que se traduz em uma enorme quantidade de c√≥digo para conectar todas as depend√™ncias dessa tela. <br></li></ol><br>  Resolvendo os problemas em ordem, come√ßamos colocando a l√≥gica em um componente separado.  Assim, podemos coletar todos os recursos desse componente e nos comunicar com o View por meio de entrada e sa√≠da.  Do ponto de vista da interface, parece um elemento MVICore comum, mas ao mesmo tempo √© criado a partir de v√°rios outros. <br><br><img src="https://habrastorage.org/webt/bx/xf/ih/bxxfihgylnpbclxg3o9pcem9xr8.png"><br><br>  Tendo resolvido esse problema, compartilhamos a responsabilidade de conectar os elementos.  Mas ainda compartilhamos os componentes nas telas, o que claramente n√£o estava dispon√≠vel para n√≥s, resultando em um grande n√∫mero de depend√™ncias em um s√≥ lugar. <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Scope</span></span> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> params: ScreenParams, news: NewsRelay, <span class="hljs-meta"><span class="hljs-meta">@OnDisposeAction</span></span> onDisposeAction: () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>, globalFeature: GlobalFeature, conversationControlFeature: ConversationControlFeature, messageSyncFeature: MessageSyncFeature, conversationInfoFeature: ConversationInfoFeature, conversationPromoFeature: ConversationPromoFeature, messagesFeature: MessagesFeature, messageActionFeature: MessageActionFeature, initialScreenFeature: InitialScreenFeature, initialScreenExplanationFeature: InitialScreenExplanationFeature?, errorFeature: ErrorFeature, conversationInputFeature: ConversationInputFeature, sendRegularFeature: SendRegularFeature, sendContactForCreditsFeature: SendContactForCreditsFeature, screenEventTrackingFeature: ScreenEventTrackingFeature, messageReadFeature: MessageReadFeature?, messageTimeFeature: MessageTimeFeature?, photoGalleryFeature: PhotoGalleryFeature?, onlineStatusFeature: OnlineStatusFeature?, favouritesFeature: FavouritesFeature?, isTypingFeature: IsTypingFeature?, giftStoreFeature: GiftStoreFeature?, messageSelectionFeature: MessageSelectionFeature?, reportingFeature: ReportingFeature?, takePhotoFeature: TakePhotoFeature?, giphyFeature: GiphyFeature, goodOpenersFeature: GoodOpenersFeature?, matchExpirationFeature: MatchExpirationFeature, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> pushIntegration: PushIntegration ) : AbstractMviComponent&lt;UiEvent, States&gt;(</code> </pre> <br>  A solu√ß√£o correta nessa situa√ß√£o √© quebrar o componente.  Como vimos acima, cada tela consiste em muitos elementos l√≥gicos que podemos dividir em partes independentes. <br><br>  Depois de um pouco de reflex√£o, chegamos a uma estrutura em √°rvore e, construindo-a ing√™nua a partir de componentes existentes, obtivemos o seguinte esquema: <br><br><img src="https://habrastorage.org/webt/el/yl/v1/elylv1elwdrgyoqdamiepx0lleo.png"><br><br>  Obviamente, √© quase imposs√≠vel manter a sincroniza√ß√£o de duas √°rvores (do View e da l√≥gica).  No entanto, se o componente for respons√°vel por exibir sua Visualiza√ß√£o, podemos simplificar esse esquema.  Tendo estudado as solu√ß√µes j√° criadas, repensamos nossa abordagem, contando com os RIBs da Uber. <br><br><img src="https://habrastorage.org/webt/sy/xt/kd/syxtkdw8uiusbnrneqna1-bqfbe.png"><br><br>  As id√©ias por tr√°s dessa abordagem s√£o muito semelhantes √†s no√ß√µes b√°sicas do MVICore.  RIB √© um tipo de "caixa preta", comunica√ß√£o com a qual ocorre atrav√©s de uma interface estritamente definida a partir de depend√™ncias (ou seja, entrada e sa√≠da).  Apesar da aparente complexidade de oferecer suporte a essa interface em um produto iterativo r√°pido, temos grandes oportunidades para reutilizar o c√≥digo. <br><br>  Assim, em compara√ß√£o com itera√ß√µes anteriores, obtemos: <br><br><ul><li>  l√≥gica encapsulada dentro de um componente; <br></li><li>  suporte para aninhamento, o que possibilita dividir telas em partes; <br></li><li>  intera√ß√£o com outros componentes atrav√©s de uma interface rigorosa de entrada / sa√≠da com suporte para MVICore; <br></li><li>  conex√£o segura em tempo de compila√ß√£o de depend√™ncias de componentes (confiando no Dagger como um DI). <br></li></ul><br>  Claro, isso est√° longe de tudo.  O reposit√≥rio no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> cont√©m uma descri√ß√£o mais detalhada e atualizada. <br><br>  E aqui temos um mundo perfeito.  Possui componentes a partir dos quais podemos construir uma √°rvore totalmente reutiliz√°vel. <br><br>  Mas vivemos em um mundo imperfeito. <br><br><h2>  Bem-vindo √† realidade! </h2><br>  Em um mundo imperfeito, h√° um monte de coisas que temos que aturar.  Estamos preocupados com o seguinte: <br><br><ul><li>  diferentes funcionalidades: apesar de toda a unifica√ß√£o, ainda estamos lidando com produtos individuais com requisitos diferentes; <br></li><li>  suporte: como sem novas funcionalidades nos testes A / B? <br></li><li>  Legado (tudo o que foi escrito antes de nossa nova arquitetura). <br></li></ul><br>  A complexidade das solu√ß√µes aumenta exponencialmente, pois cada aplicativo adiciona algo pr√≥prio aos componentes comuns. <br><br>  Considere o processo de registro como um exemplo de um componente comum que se integra aos aplicativos.  Em geral, o registro √© uma cadeia de telas com a√ß√µes que afetam todo o fluxo.  Cada aplicativo possui telas diferentes e sua pr√≥pria interface do usu√°rio.  O objetivo final √© criar um componente reutiliz√°vel flex√≠vel, o que tamb√©m nos ajudar√° a resolver os problemas da lista acima. <br><br><img src="https://habrastorage.org/webt/22/v6/cd/22v6cdpd9uf8ebuxcdo0j4mgc5a.png"><br><br><h3>  Requisitos diversos </h3><br>  Cada aplicativo possui suas pr√≥prias varia√ß√µes de registro exclusivas, tanto do lado l√≥gico quanto do lado da interface do usu√°rio.  Portanto, come√ßamos a generalizar a funcionalidade no componente com um m√≠nimo: baixando dados e roteando todo o fluxo. <br><br><img src="https://habrastorage.org/webt/nv/lr/1b/nvlr1bpwh_s1bw0lrlfk0py2zww.png"><br><br>  Esse cont√™iner transfere dados para o aplicativo do servidor, que √© convertido em uma tela finalizada com l√≥gica.  O √∫nico requisito √© que as telas passadas para esse cont√™iner precisem satisfazer depend√™ncias para interagir com a l√≥gica de todo o fluxo. <br><br>  Depois de fazer esse truque com algumas aplica√ß√µes, percebemos que a l√≥gica das telas √© quase a mesma.  Em um mundo ideal, criar√≠amos uma l√≥gica comum personalizando a Visualiza√ß√£o.  A quest√£o √© como personaliz√°-los. <br><br>  Como voc√™ pode se lembrar da descri√ß√£o do MVICore, o View e o Feature s√£o baseados na interface do ObservableSource e Consumer.  Utilizando-os como uma abstra√ß√£o, podemos substituir a implementa√ß√£o sem alterar as partes principais. <br><br><img src="https://habrastorage.org/webt/ay/ox/lo/ayoxlo24e49tsprdsdxplsdv4yo.png"><br><br>  Ent√£o, reutilizamos a l√≥gica dividindo a interface do usu√°rio.  Como resultado, o suporte se torna muito mais conveniente. <br><br><h3>  Suporte </h3><br>  Considere o teste A / B para a varia√ß√£o de elementos visuais.  Nesse caso, nossa l√≥gica n√£o muda, o que nos permite substituir outra interface do View pela interface existente de ObservableSource e Consumer. <br><br><img src="https://habrastorage.org/webt/ag/qg/vm/agqgvmwnzn_cztnwovas8jk9ydw.png"><br><br>  Obviamente, algumas vezes novos requisitos contradizem a l√≥gica j√° escrita.  Nesse caso, sempre podemos retornar ao esquema original, onde o aplicativo fornece a tela inteira.  Para n√≥s, √© uma esp√©cie de "caixa preta" e n√£o importa para o cont√™iner o que eles passam para ele, desde que sua interface seja observada. <br><br><h3>  Integra√ß√£o </h3><br>  Como mostra a pr√°tica, a maioria dos aplicativos usa o Activity como unidades b√°sicas, os meios de comunica√ß√£o entre os quais h√° muito s√£o conhecidos.  Tudo o que tivemos que fazer foi aprender a agrupar componentes no Activity e transmitir dados atrav√©s de entrada e sa√≠da.  Como se viu, essa abordagem funciona muito bem com fragmentos. <br><br>  Para aplicativos de atividade √∫nica, nada muda muito.  Quase todas as estruturas oferecem seus elementos b√°sicos nos quais os componentes do RIB se permitem envolver. <br><br><h2>  No final </h2><br>  Passados ‚Äã‚Äãesses est√°gios, aumentamos significativamente a porcentagem de reutiliza√ß√£o de c√≥digo entre os projetos de nossa empresa.  No momento, o n√∫mero de componentes est√° se aproximando de 100, e a maioria deles implementa funcionalidade para v√°rios aplicativos ao mesmo tempo. <br><br>  Nossa experi√™ncia mostra que: <br><br><ul><li>  apesar da crescente complexidade de projetar componentes comuns, dados os requisitos de diferentes aplicativos, seu suporte √© muito mais f√°cil a longo prazo; <br></li><li>  construindo componentes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">isolados uns dos outros</a> , simplificamos bastante sua integra√ß√£o em aplicativos criados com base em princ√≠pios diferentes; <br></li><li>  as revis√µes de processo, juntamente com a √™nfase no desenvolvimento e suporte de componentes, t√™m um efeito positivo na qualidade da funcionalidade geral. <br></li></ul><br>  Meu colega Zsolt Kocsi escreveu anteriormente sobre o MVICore e as id√©ias por tr√°s dele.  Eu recomendo a leitura dos artigos dele, que traduzimos em nosso blog ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3</a> ). <br><br>  Sobre os RIBs, voc√™ pode ler o artigo original do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Uber</a> .  E, para conhecimento pr√°tico, recomendo tirar algumas li√ß√µes <a href="">de n√≥s</a> (em ingl√™s). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt466049/">https://habr.com/ru/post/pt466049/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt466033/index.html">Como envolver uma equipe na busca de id√©ias e obter muito mais do que id√©ias</a></li>
<li><a href="../pt466039/index.html">Bibliotecas PHP para com√©rcio eletr√¥nico: trabalhando com ATOL e Payture, analisando c√≥digos GS1 e outras tarefas</a></li>
<li><a href="../pt466041/index.html">O primeiro evento offline da comunidade Circle Developer Circle: Moscow - Launch Event</a></li>
<li><a href="../pt466045/index.html">Como revitalizar uma marca: contar hist√≥rias que funcionaram</a></li>
<li><a href="../pt466047/index.html">Projetando lojas online. Parte 3. P√°gina Inicial e Cat√°logo</a></li>
<li><a href="../pt466051/index.html">Automatize a cria√ß√£o de perfil em Java 10/09</a></li>
<li><a href="../pt466053/index.html">Representa√ß√£o de empresas de TI russas em Cingapura: por que n√£o?</a></li>
<li><a href="../pt466059/index.html">Livro ‚ÄúDesign Thinking. Do insight a novos produtos e mercados ‚Äù</a></li>
<li><a href="../pt466065/index.html">Resumo de not√≠cias do PostgreSQL. Edi√ß√£o No.17</a></li>
<li><a href="../pt466067/index.html">Protetor de tela encantador para Kodi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>