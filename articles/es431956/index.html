<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧙🏾 🕵🏾 🎡 Lógica, explicabilidad y comprensión futura. 🧜🏼 📻 🎳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Descubrimiento relacionado con la lógica 
 La lógica es la base de muchas cosas. ¿Pero cuáles son los fundamentos de la lógica misma? 

 En la lógica ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lógica, explicabilidad y comprensión futura.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431956/"><h3>  Descubrimiento relacionado con la lógica </h3><br>  La lógica es la base de muchas cosas.  ¿Pero cuáles son los fundamentos de la lógica misma? <br><br>  En la lógica simbólica, los símbolos como p y q se introducen para denotar declaraciones (o "proposiciones") del tipo "este es un ensayo interesante".  Todavía hay ciertas reglas de lógica, por ejemplo, para cualquier p y cualquier q, la expresión NOT (p AND q) es similar a (NOT p) OR (NOT q). <br><br>  ¿Pero de dónde vienen estas "reglas de la lógica"?  La lógica es un sistema formal.  Al igual que la geometría euclidiana, se puede construir sobre axiomas.  ¿Pero qué son los axiomas?  Puede comenzar con declaraciones como p AND q = q AND p, o NOT NOT p = p.  ¿Pero cuántos axiomas se requieren?  ¿Qué tan simples pueden ser? <br><br>  Esta pregunta ha sido dolorosa por mucho tiempo.  Pero a las 20:31 del domingo 29 de enero de 2000, el único axioma apareció en la pantalla de mi computadora.  Ya he demostrado que nada podría ser más simple, pero pronto establecí que este pequeño axioma era suficiente para crear toda la lógica: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a5/426/b76/8a5426b76ec6ff73e4b9f521f1e66764.png"></div><a name="habracut"></a><br>  ¿Cómo supe que era verdad?  Porque hice que la computadora lo probara.  Y aquí está la prueba que imprimí en el libro " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Un nuevo tipo de ciencia</a> " (ya disponible en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el repositorio de datos de Wolfram</a> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c7/d9f/11e/9c7d9f11e1cb651d7bfbe6b4edad66dd.png"></div><br>  Usando la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">última versión de</a> Wolfram Language, cualquiera puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">generar</a> esta prueba en no más de un minuto.  Y cada uno de sus pasos es fácil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de verificar</a> .  Pero, ¿por qué el resultado será cierto?  ¿Cómo explicarlo? <br><br>  Cada vez se hacen más preguntas similares sobre todo tipo de sistemas informáticos y aplicaciones relacionadas con el aprendizaje automático y la IA.  Sí, vemos lo que está pasando.  ¿Pero podemos entender esto? <br><br>  Creo que este tema es profundamente inherente, y críticamente importante para el futuro de la ciencia y la tecnología, y para el futuro de todo el desarrollo intelectual. <br><br>  Pero antes de hablar sobre esto, discutamos el axioma que descubrí. <br><br><h2>  La historia </h2><br>  La lógica como disciplina formal proviene de Aristóteles, que vivió en el siglo IV a. C.  Como parte de la obra de su vida en la catalogación de cosas (animales, causas, etc.), Aristóteles compiló un catálogo de formas permitidas de argumentos y creó plantillas simbólicas para ellos, que, en esencia, proporcionaron el contenido principal de la lógica para dos mil años por delante. <br><br>  Sin embargo, en el siglo XV, se inventó el álgebra, y con él apareció una imagen más clara de las cosas.  Pero no fue hasta 1847 que George Bull finalmente formuló la lógica de la misma manera que el álgebra, con operaciones lógicas como AND y OR que funcionan de acuerdo con reglas similares a las del álgebra. <br><br>  Después de unos años, la gente ya estaba escribiendo sistemas axiomáticos para la lógica.  Un ejemplo típico fue: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b7/f83/b05/1b7f83b053013cbb17e8a3e3f9734097.png"></div><br>  ¿Pero son AND, OR y NOT realmente necesarios para la lógica?  Después de la primera década del siglo XX, varias personas han descubierto que la única operación que ahora llamamos NAND será suficiente y, por ejemplo, p OR q puede calcularse como (p NAND p) NAND (q NAND q).  La "integridad funcional" de NAND podría seguir siendo extraña para siempre si no fuera por el desarrollo de la tecnología de semiconductores: implementa todos los miles de millones de operaciones lógicas en un microprocesador moderno utilizando una combinación de transistores que realizan solo la función NAND o el NOR asociado. <br><br>  Bueno, entonces, ¿cómo son los axiomas de la lógica en términos de NAND?  Aquí está la primera versión conocida de ellos, registrada por Henry Schaeffer en 1913 (aquí el punto denota NAND): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2fd/af7/5d1/2fdaf75d1c346bb2d8c3c4d470ffcd68.png"></div><br>  En 1910, Principia Mathematica, un trabajo de tres volúmenes sobre la lógica y la filosofía de las matemáticas por Alfred North Whitehead y Bertrand Russell, popularizó la idea de que quizás todas las matemáticas pueden deducirse de la lógica.  Ante esto, fue bastante interesante estudiar la cuestión de cuán simples pueden ser los axiomas de la lógica.  El trabajo más significativo en esta área se llevó a cabo en Lviv y Varsovia (entonces estas ciudades eran parte de Polonia), en particular, Jan Lukasevich (como efecto secundario de su trabajo en 1920, inventó un registro "polaco" que no requiere corchetes).  En 1944, a la edad de 66 años, Lukasevich huyó del avance del ejército soviético y en 1947 terminó en Irlanda. <br><br>  Mientras tanto, el irlandés Carew Meredith, que estudió en Winchester y Cambridge, y se convirtió en profesor de matemáticas en Cambridge, se vio obligado a regresar a Irlanda en 1939 debido a su pacifismo.  En 1947, Meredith asistió a la conferencia de Lukasevich en Dublín, que lo inspiró a buscar axiomas simples, lo que hizo, en su mayor parte, por el resto de su vida. <br><br>  Para 1949, Meredith descubrió un sistema de dos axiomas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/237/0cf/7a8/2370cf7a8b94b221152f17f905223919.png"></div><br>  Casi 20 años después, en 1967 pudo simplificar esto para: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/245/ba1/89c/245ba189c20baf7290fde8e6164b1050.png"></div><br>  ¿Es posible simplificar esto aún más?  Meredith ha estado jugando con esto durante años, descubriendo dónde más puedes eliminar la NAND adicional.  Pero después de 1967, no avanzó más (y murió en 1976), aunque en 1969 encontró un sistema de tres axiomas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/650/552/dcd/650552dcd498bb69a243af9ca9373091.png"></div><br>  Cuando comencé a estudiar los sistemas de lógica axiomáticos, no sabía nada sobre el trabajo de Meredith.  Me interesé en este tema como parte de un intento de comprender qué comportamiento podría surgir de reglas simples.  En la década de 1980, descubrí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">inesperadamente</a> que incluso los autómatas celulares con las reglas más simples posibles, como mi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">regla</a> favorita <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">30</a> , pueden conducir a un comportamiento increíblemente complejo. <br><br>  Después de pasar la década de 1990 en un intento de comprender la generalidad de este fenómeno, finalmente quise ver cómo se puede aplicar a las matemáticas.  En matemáticas, de hecho, comenzamos a trabajar con axiomas (por ejemplo, en aritmética, en geometría, en lógica), y luego, sobre la base, intentamos probar un conjunto completo de teoremas complejos. <br><br>  Sin embargo, ¿qué tan simples pueden ser los axiomas?  Eso es lo que quería establecer en 1999.  Como primer ejemplo, decidí estudiar lógica (o, equivalentemente, álgebra booleana).  Refutando todas mis expectativas, mi experiencia con autómatas celulares, máquinas de Turing y otros sistemas, incluso ecuaciones diferenciales parciales, sugiere que simplemente puede comenzar a enumerar los casos más simples posibles y en algún momento ver algo interesante <br><br>  Pero, ¿es posible "abrir la lógica" de esta manera?  Solo había una forma de decir esto.  Y a fines de 1999, arreglé todo para comenzar a explorar el espacio de todos los posibles sistemas de axiomas, comenzando por el más simple. <br><br>  En cierto sentido, cualquier sistema de axiomas define un conjunto de restricciones, por ejemplo, en p · q.  Ella no dice qué es p · q, solo da propiedades que p · q debe satisfacer (por ejemplo, puede decir que q · p = p · q).  Entonces la pregunta es si es posible derivar de estas propiedades todos los teoremas de la lógica que se mantienen cuando p · q es Nand [p, q]: ni más ni menos. <br><br>  Algo puede ser verificado directamente.  Podemos tomar el sistema de axiomas y ver qué formas p · q satisfacen los axiomas, si pyq son, por ejemplo, verdaderas y falsas.  Si el sistema de axiomas es que q · p = p · q, entonces sí, p · q puede ser Nand [p, q], pero no necesariamente.  También puede ser And [p, q] o Equal [p, q], o muchas otras opciones que no satisfacen los mismos niveles que la función NAND en lógica.  Pero cuando llegamos al sistema de axiomas {((p · p) · q) · (q · p) = q}, llegamos al estado en el que Nand [p, q] (y el equivalente de Nor [p , q]) siguen siendo los únicos modelos p · q en funcionamiento, al menos si suponemos que q y p solo tienen dos valores posibles. <br><br>  ¿Es este un sistema de axiomas para la lógica?  No  Porque implica, por ejemplo, la existencia de una variante donde p y q tienen tres valores, pero esto no está en la lógica.  Sin embargo, el hecho de que este sistema de axiomas de un axioma esté cerca de lo que necesitamos indica que vale la pena buscar un solo axioma a partir del cual se reproduzca la lógica.  Esto es exactamente lo que hice en enero de 2000 (en nuestro tiempo, esta tarea se ha facilitado gracias a la función bastante nueva y muy conveniente de Wolfram Language, Groupings). <br><br>  Era bastante fácil verificar que los axiomas en los que había 3 o menos NAND (u "operadores de puntos") no funcionaban.  A las 5 a.m.del domingo 29 de enero (sí, entonces era un búho), descubrí que los axiomas que contenían 4 NAND tampoco funcionarían.  Cuando dejé de trabajar alrededor de las 6 de la mañana, tenía 14 candidatos en mis manos con cinco NAND.  Pero al continuar trabajando el domingo por la noche y realizando pruebas adicionales, tuve que abandonarlas todas. <br><br>  No hace falta decir que el siguiente paso fue verificar los axiomas con 6 NAND.  Había 288,684 de ellos, pero mi código funcionó eficientemente y no pasó mucho tiempo antes de que apareciera lo siguiente en la pantalla (sí, de la Versión 4 de Mathematica): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb1/eb6/b59/cb1eb6b59aa53f1cc55cc91c2ec76271.png"></div><br>  Al principio no entendí lo que hice.  Solo sabía que tengo 25 axiomas no equivalentes con 6 NAND que han podido avanzar más que los axiomas con 5 NAND.  ¿Pero había axiomas entre ellos que generaban lógica?  Tenía un método empírico capaz de descartar axiomas innecesarios.  Pero la única forma de saber con certeza la corrección de un axioma particular era demostrar que podía reproducir con éxito, por ejemplo, los axiomas de Schaeffer para la lógica. <br><br>  Tomó un poco de juego con los programas, pero después de unos días descubrí que la mayoría de los 25 axiomas recibidos no funcionaban.  Como resultado, dos sobrevivieron: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f1/a4a/5e0/6f1a4a5e040e1acbd2e14406b8a05eff.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/311/20f/394/31120f394c33c0d1c95c0d22ee9caf45.png"></div><br>  Y para mi gran alegría, pude probar usando una computadora que ambos son axiomas para la lógica.  La técnica utilizada garantizó la ausencia de axiomas más simples para la lógica.  Por lo tanto, sabía que había alcanzado el objetivo: después de un siglo (o tal vez un par de milenios) de búsquedas, finalmente podemos decir que hemos encontrado el axioma más simple para la lógica. <br><br>  Poco después, descubrí sistemas de dos axiomas con 6 NAND en general, que, como probé, son capaces de reproducir la lógica: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b9/311/d22/7b9311d22392f15be81d05b43df9861c.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/920/f41/3e1/920f413e173d5e9c859b580d27eb3819.png"></div><br>  Y si damos por sentado la conmutatividad p · q = q · p, entonces la lógica se puede obtener del axioma que contiene solo 4 NAND. <br><br><h2>  ¿Por qué es esto importante? </h2><br>  Bueno, digamos que es genial poder decir que alguien "completó el trabajo iniciado por Aristóteles" (o al menos Boole) y descubrió el sistema de axiomas más simple posible para la lógica.  ¿Es solo un truco o este hecho tiene consecuencias importantes? <br><br>  Antes de la plataforma que desarrollé en A New Kind of Science, creo que sería difícil considerar este hecho como algo más que una simple curiosidad.  Pero ahora debe quedar claro que está conectado con todo tipo de preguntas básicas, como si las matemáticas deben considerarse un descubrimiento o una invención. <br><br>  Las matemáticas que las personas hacen se basan en un puñado de ciertos sistemas de axiomas, cada uno de los cuales define un área específica de las matemáticas (lógica, teoría de grupos, geometría, teoría de conjuntos).  Pero hablando de manera abstracta, hay un número infinito de sistemas de axiomas, cada uno de los cuales define un campo de las matemáticas que puede estudiarse incluso si las personas aún no lo han hecho. <br><br>  Antes del libro A New Kind of Science, aparentemente quería decir que todo lo que existe "en algún lugar" en el universo informático debería ser "menos interesante" que lo que la gente ha creado y estudiado.  Pero mis descubrimientos con respecto a programas simples indican que los sistemas que simplemente "en algún lugar" tienen posibilidades no menos ricas que aquellos sistemas cuidadosamente seleccionados por las personas. <br><br>  Entonces, ¿qué pasa con el sistema de axiomas para las matemáticas?  Para comparar el existente "en algún lugar" con lo que las personas estudiaron, debe saber si los sistemas de axiomas se encuentran en las áreas existentes de matemáticas que estudiamos.  Y, en base a los sistemas tradicionales creados por personas, podemos concluir que deben estar en algún lugar muy, muy lejos, y en general solo se pueden encontrar si ya sabe dónde está. <br><br>  Pero mi descubrimiento del sistema de axiomas respondió la pregunta "¿Hasta dónde está la lógica?"  Para cosas como un autómata celular, es bastante fácil numerar (como lo hice en la década de 1980) todos los autómatas celulares posibles.  Es un poco más difícil hacer esto con los sistemas axiom, pero no por mucho.  En un enfoque, mi axioma se puede denotar como 411; 3; 7; 118 - o, en Wolfram Language: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/315/5d5/ef0/3155d5ef0d85da9df2a25e407c617625.png"></div><br>  Y, al menos en el espacio de posibles formas funcionales (sin tener en cuenta el marcado de las variables) hay una representación visual de la ubicación de este axioma: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb2/e6c/eb2/bb2e6ceb2b5a36d51e32d16727e89ef9.png"></div><br>  Dada la importancia fundamental de la lógica para un número tan grande de sistemas formales que las personas estudian, uno podría pensar que, en cualquier representación razonable, la lógica corresponde a uno de los sistemas de axiomas más simples posibles.  Pero, al menos en una presentación con NAND, esto no es así.  Para ella, todavía hay un sistema muy simple de axiomas, pero probablemente resulte ser cien mil sistemas de axiomas de todos los posibles que se pueden encontrar si comienzas a numerar el sistema de axiomas, comenzando por el más simple. <br><br>  Dado esto, la siguiente pregunta obvia será: ¿qué pasa con todos los demás sistemas de axiomas?  ¿Cómo se comportan?  Es este tema el que explora el libro A New Kind of Science.  Y en él afirmo que cosas como los sistemas observados en la naturaleza a menudo se describen mejor con estas "otras reglas" que podemos encontrar al enumerar las posibilidades. <br><br>  En cuanto a los sistemas de axiomas, hice una imagen que representa lo que está sucediendo en las "áreas de las matemáticas" correspondientes a varios sistemas de axiomas.  La serie muestra las consecuencias de un cierto sistema de axiomas, y los recuadros indican la verdad de un cierto teorema en un sistema de axiomas dado (sí, en algún momento entra en vigor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el teorema de Gödel</a> , después de lo cual se vuelve increíblemente difícil probar o refutar un teorema dado en un sistema de axiomas dado; en la práctica, con según mis métodos, esto sucede un poco a la derecha de lo que se muestra en la imagen). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/627/56f/8e5/62756f8e5e47459b575ad148feacee99.png"></div><br>  ¿Hay algo fundamentalmente especial en las áreas de las matemáticas que son "investigadas por personas"?  A juzgar por esta y otras imágenes, no se me ocurre nada obvio.  Sospecho que solo hay una característica en estas áreas: el hecho histórico de que fueron estudiadas.  (Puede hacer declaraciones como "describen el mundo real" o "relacionadas con el funcionamiento del cerebro", pero los resultados descritos en el libro sugieren lo contrario). <br><br>  Bueno, ¿cuál es el significado de mi sistema de axiomas para la lógica?  Su tamaño te hace sentir el contenido final de información de la lógica como un sistema axiomático.  Y nos hace creer, al menos por ahora, que debemos considerar la lógica más como una "construcción inventada por el hombre" que como un "descubrimiento" que sucedió por "razones naturales". <br><br>  Si la historia fuera diferente y buscamos constantemente (como se hace en el libro) muchos sistemas de axiomas más simples posibles, entonces probablemente "abriríamos" el sistema de axiomas para la lógica, como el sistema cuyas propiedades encontramos interesantes.  Pero como hemos estudiado un número tan pequeño de todos los posibles sistemas de axiomas, creo que sería razonable considerar la lógica como una "invención", una construcción especialmente creada. <br><br>  En cierto sentido, en la Edad Media, la lógica se veía así: cuando los silogismos posibles (tipos aceptables de argumentos) se representaban en forma de mnemotecnia latina como bArbArA y cElErAnt.  Por lo tanto, ahora es interesante encontrar una representación mnemónica de lo que ahora conocemos como el sistema más simple de axiomas para la lógica. <br><br>  A partir de ((p · q) · r) · (p · ((p · r) · p)) = r, cada p · q puede representarse como un prefijo o una entrada polaca (inversa a la "entrada polaca inversa" de la calculadora HP ) en forma de Dpq, por lo tanto, todo el axioma se puede escribir como = DDDpqrDpDDprpr.  También hay una mnemónica inglesa sobre este tema: FIGURE OuT Queue, donde los roles p, q, r son interpretados por u, r, e.  O puede mirar las primeras letras de las palabras en la siguiente oración (donde B es un operador y p, q, r son a, p, c): "Poco a poco, un programa calculó el mejor axioma binario de álgebra booleana que cubre todos los casos" [ el mejor axioma binario de álgebra booleana calculado mediante un programa describe gradualmente todos los casos]. <br><br><h2>  Mecánica de prueba </h2><br>  Bien, entonces, ¿cómo demuestras la corrección de mi sistema de axiomas?  Lo primero que viene a la mente es demostrar que es posible deducir de él un conocido sistema de axiomas para la lógica, por ejemplo, el sistema de axiomas de Schaeffer: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5f/54a/161/b5f54a161b3ff941c7459003cd9dffd9.png"></div><br>  Aquí hay tres axiomas, y necesitamos derivar cada uno.  Esto es lo que puede hacer para generar el primero, utilizando la última versión de Wolfram Language: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47b/f3e/10c/47bf3e10c7a79db3328816c3ff931a68.png"></div><br>  Es de destacar que ahora es posible hacer esto.  En el "objeto de evidencia" está escrito que se usaron 54 pasos para la prueba.  En base a este objeto, podemos generar un "cuaderno" que describe cada uno de los pasos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2d/b12/0f3/b2db120f3a2bd50432ed16525ca72342.png"></div><br>  En general, aquí se demuestra toda la secuencia de lemas intermedios, lo que nos permite deducir el resultado final.  Entre los lemas hay una red completa de dependencias mutuas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc1/272/d6f/dc1272d6fd14710be4e2a49ec684efa8.png"></div><br>  Pero las redes involucradas en la derivación de los tres axiomas en el sistema de axiomas Scheffer: para este último, se utilizan increíbles 504 pasos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c33/0e5/d15/c330e5d159782e0d4cff4931f2b9f605.png"></div><br>  Sí, es obvio que estas redes son bastante confusas.  Pero antes de discutir qué significa esta complejidad, hablemos de lo que sucede en cada paso de esta evidencia. <br><br>  La idea principal es simple.  Imagine que tenemos un axioma que simplemente se escribe como p · q = q · p (matemáticamente, esto significa que el operador es conmutativo).  Más precisamente, el axioma dice que para cualquier expresión p y q, p · q es equivalente a q · p. <br><br>  Bueno, digamos que queremos deducir de este axioma que (a · b) · (c · d) = (d · c) · (b · a).  Esto se puede hacer usando el axioma para convertir d · c en c · d, b · a en a · b, y finalmente (c · d) · (a · b) en (a · b) · (c · d ) <br><br>  FindEquationalProof hace esencialmente lo mismo, aunque no sigue estos pasos exactamente en el mismo orden, y cambia tanto el lado izquierdo de la ecuación como el derecho. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f4/f43/f6b/9f4f43f6b97bb816052eeb50ec01dcb2.png"></div><br>  Una vez recibida dicha prueba, simplemente puede realizar un seguimiento de cada paso y verificar que den el resultado indicado.  ¿Pero cómo encontrar evidencia?  Hay muchas secuencias posibles de permutaciones y transformaciones.  ¿Cómo encontrar una secuencia que traiga con éxito el resultado final? <br><br>  Uno podría decidir: ¿por qué no probar todas las secuencias posibles, y si hay una secuencia de trabajo entre ellas, entonces eventualmente debería encontrarse?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El problema es que puede llegar rápidamente a un número astronómico de secuencias. </font><font style="vertical-align: inherit;">La mayor parte del arte de probar automáticamente los teoremas consiste en encontrar formas de reducir el número de secuencias para verificar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto se desliza rápidamente a los detalles técnicos, pero la idea básica es fácil de discutir si conoce los conceptos básicos de álgebra. </font><font style="vertical-align: inherit;">Supongamos que estamos tratando de demostrar un resultado algebraico como</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc0/402/9b6/fc04029b6fa134be318b5b9999d0beeb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hay una manera garantizada de hacer esto: simplemente aplicando las reglas de álgebra para revelar cada lado, puedes ver inmediatamente su similitud: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c93/6e3/5b0/c936e35b0bf0addb94eece9e2379f15f.png"></div><br>  Por que funciona<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Porque hay una manera de trabajar con tales expresiones, reduciéndolas sistemáticamente hasta que tomen una forma estándar. ¿Es posible hacer la misma operación en sistemas arbitrarios de axiomas? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No de inmediato En álgebra, esto funciona porque tiene una propiedad especial que garantiza que siempre se pueda "mover" a lo largo de la ruta de simplificación de expresiones. Pero en la década de 1970, diferentes científicos descubrieron varias veces de forma independiente (bajo nombres como el algoritmo Knuth-Bendix o la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base de Gröbner</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) que incluso si el sistema axiom no tiene la propiedad interna necesaria, es posible descubrir "adiciones" a este sistema en el que hay</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto es lo que sucede en la evidencia típica que proporciona FindEquationalProof (basado en el sistema de Valdmeister, "maestro de árboles"). </font><font style="vertical-align: inherit;">Hay los llamados </font><font style="vertical-align: inherit;">Los "lemas críticos de pares", que no avanzan directamente la prueba, pero hacen posible la aparición de caminos capaces de esto. </font><font style="vertical-align: inherit;">Todo es complicado debido al hecho de que, aunque la expresión final que queremos obtener es bastante corta, en el camino, es posible que tenga que pasar por expresiones intermedias mucho más largas. </font><font style="vertical-align: inherit;">Por lo tanto, por ejemplo, la prueba del primer axioma de Schaeffer tiene tales pasos intermedios:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b0f/c98/287/b0fc98287cfb9bb8968eea6664aaa0ec.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En este caso, el mayor de los pasos es 4 veces más grande que el axioma original: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cdd/885/774/cdd885774255091503fdb07d55fd8b0b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dichas expresiones se pueden representar como un árbol. </font><font style="vertical-align: inherit;">Aquí está su árbol, comparado con el árbol del axioma original:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7f/465/f16/a7f465f1661555adf78695f71ea4fb8c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y así es como se desarrollan los tamaños de los pasos intermedios en el curso de las pruebas de cada uno de los axiomas de Schaeffer: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d2/ba7/c59/5d2ba7c5933f2d3d77b0b8acfb594020.png"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¿Por qué es tan difícil? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Es de extrañar que esta evidencia sea tan compleja? </font><font style="vertical-align: inherit;">No realmente, de verdad. </font><font style="vertical-align: inherit;">Después de todo, somos conscientes de que las matemáticas pueden ser complejas. </font><font style="vertical-align: inherit;">En principio, podría ser que todas las verdades en matemáticas serían fáciles de probar. </font><font style="vertical-align: inherit;">Pero uno de los efectos secundarios del teorema de Gödel de 1931 es que incluso aquellas cosas que tienen evidencia, el camino hacia ellas puede ser arbitrariamente largo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este es un síntoma de un fenómeno mucho más general, que yo llamo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">irreductibilidad computacional</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Considere un sistema controlado por una simple regla de un autómata celular (por supuesto, en cualquiera de mis ensayos siempre habrá autómatas celulares). </font><font style="vertical-align: inherit;">Ejecute este sistema.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/511/f6e/5b2/511f6e5b21afb7a21c62622cab036fd4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se podría decidir que si el sistema se basa en una regla simple, entonces debería haber una forma rápida de entender lo que hace el sistema.</font></font> Pero esto no es así.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Según mi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">principio de equivalencia computacional</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , la operación de un sistema a menudo corresponde a cálculos, cuya complejidad coincide con cualquier cálculo que podamos hacer para comprender el comportamiento del sistema. Esto significa que el comportamiento real del sistema, de hecho, corresponde a tal cantidad de trabajo computacional, que en principio no se puede reducir. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con respecto a la imagen de arriba: digamos que queremos saber si el patrón muere al final. Podríamos seguir cumpliéndolo, y si tenemos suerte, eventualmente degenerará en algo, cuyo destino será obvio. Sin embargo, en general, no hay límite superior en cuanto tiempo tenemos que gastar, de hecho, en la prueba.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando algo así sucede con evidencia lógica, sucede de manera un poco diferente. En lugar de comenzar algo que funcione de acuerdo con ciertas reglas, preguntamos si hay una manera de alcanzar cierto resultado al seguir varios pasos, cada uno de los cuales obedece a una determinada regla. Y esta tarea, como una tarea computacional práctica, es mucho más complicada. Pero la esencia de la complejidad es el mismo fenómeno de irreductibilidad computacional, y este fenómeno sugiere que no hay una forma general de recorrer brevemente el proceso de estudiar lo que hará el sistema.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Huelga decir que hay muchas cosas en el mundo, especialmente en tecnología y modelado científico, así como en áreas donde hay varias formas de reglas, diseñadas tradicionalmente para evitar la irreductibilidad computacional y para que el resultado de su trabajo sea inmediatamente visible. sin la necesidad de realizar una cantidad irreducible de cálculos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero una de las consecuencias de mi principio de equivalencia computacional es que estos casos son singulares y antinaturales: argumenta que la irreductibilidad computacional existe en todos los sistemas del universo informático.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué hay de las matemáticas? </font><font style="vertical-align: inherit;">Tal vez las reglas de las matemáticas se eligen específicamente para demostrar la reducibilidad computacional. </font><font style="vertical-align: inherit;">Y en algunos casos este es el caso (y en cierto sentido, esto también sucede en la lógica). </font><font style="vertical-align: inherit;">Pero en su mayor parte, parece que los sistemas de axiomas de las matemáticas no son atípicos para el espacio de todos los posibles sistemas de axiomas, donde la irreductibilidad computacional se desata inevitablemente.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¿Por qué necesitamos evidencia? </font></font></h2><br>  En cierto sentido, se necesitan pruebas para saber la verdad de algo.  Por supuesto, especialmente en nuestro tiempo, la evidencia se ha desvanecido en el fondo, dando paso a la computación pura.  En la práctica, el deseo de generar algo mediante cálculos es mucho más común que el deseo de "dar un paso atrás" y construir una prueba de la verdad de algo. <br><br>  Sin embargo, en matemática pura, a menudo hay que lidiar con conceptos que incluyen, al menos nominalmente, un número infinito de casos ("verdadero para todos los números primos", etc.) para los que los cálculos de la frente no funcionarán .  Y cuando surge la pregunta de confirmación ("¿puede este programa terminar con un error?" O "¿puedo gastar esta criptomoneda dos veces?") Es más razonable intentar probar esto que calcular todos los casos posibles. <br><br>  Pero en la práctica matemática real, la prueba es más que establecer la verdad.  Cuando Euclides escribió sus " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Principios</a> ", simplemente indicó los resultados y "los dejó al lector".  Pero, de una forma u otra, especialmente durante el siglo pasado, la evidencia se ha convertido en algo que no solo sucede detrás de escena, sino que es el medio principal a través del cual es necesario transmitir conceptos. <br><br>  Me parece que como resultado de algún capricho de la historia, la evidencia se ofrece hoy como un objeto que la gente debería entender, y los programas se consideran simplemente algo que una computadora debería ejecutar.  ¿Por qué sucedió esto?  Bueno, al menos en el pasado, la evidencia podría presentarse en forma de texto; por lo tanto, si alguien la usó, entonces solo las personas.  Y los programas casi siempre se grababan en forma de lenguaje informático.  Y durante mucho tiempo, estos lenguajes se crearon para que pudieran traducirse más o menos directamente en operaciones informáticas de bajo nivel, es decir, la computadora los entendió de inmediato, pero las personas no tienen que hacerlo. <br><br>  Pero uno de los objetivos principales de mi trabajo en las últimas décadas ha sido cambiar este estado de cosas y desarrollar en Wolfram Language un verdadero "lenguaje de comunicación computacional" en el que las ideas computacionales puedan transmitirse para que puedan ser entendidas por computadoras y personas. <br><br>  Tal lenguaje tiene muchas consecuencias.  Uno de ellos está cambiando el papel de la evidencia.  Supongamos que miramos algún resultado matemático.  En el pasado, la única forma plausible de entenderlo era dar evidencia de que la gente leía.  Pero ahora es posible otra cosa: puede entregar un programa para Wolfram Language que calcule el resultado.  Y esta es, en muchos sentidos, una forma mucho más rica de transmitir la verdad del resultado.  Cada parte del programa es algo preciso e inequívoco: todos pueden iniciarlo.  No existe el problema de que los intentos de comprender alguna parte del texto requieran llenar algunos vacíos.  Todo está indicado en el texto claramente. <br><br>  ¿Qué hay de la evidencia?  ¿Hay alguna forma clara y precisa de escribir evidencia?  Potencialmente sí, aunque esto no es particularmente fácil.  Y aunque la fundación Wolfram Language ha existido durante 30 años, solo hoy ha aparecido una forma razonable de presentar evidencia estructuralmente directa con ella, como uno de mis axiomas anteriores. <br><br>  Puede imaginarse creando evidencia en Wolfram Language de la misma manera que las personas crean programas, y estamos trabajando para proporcionar versiones de alto nivel de esta funcionalidad que "ayude con la evidencia".  Sin embargo, nadie creó la prueba de mi sistema axiom: una computadora lo encontró.  Y esto se parece más a la salida del programa que al programa en sí.  Sin embargo, como un programa, en cierto sentido, la prueba también se puede "ejecutar" para verificar el resultado. <br><br><h2>  Creando claridad </h2><br>  La mayoría de las veces, las personas que usan Wolfram Language, o Wolfram | Alpha, quieren contar algo.  Necesitan obtener el resultado, no entender por qué obtuvieron esos resultados.  Pero en Wolfram | Alpha, especialmente en áreas como las matemáticas y la química, una característica popular entre los estudiantes es la construcción de soluciones "paso a paso". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77d/a19/015/77da190153b5c78394653c8bdee8bb98.png"></div><br>  Cuando el sistema Wolfram | Alpha calcula, por ejemplo, una integral, utiliza todo tipo de potentes técnicas algorítmicas que están optimizadas para recibir respuestas.  Pero cuando se le pide que muestre las etapas de los cálculos, hace algo más: necesita explicar en pasos por qué este es el resultado obtenido. <br><br>  No habría beneficio en explicar cómo se obtuvo realmente el resultado;  Este es un proceso muy inapropiado para los humanos.  Ella necesita entender qué operaciones aprendidas por las personas se pueden utilizar para obtener un resultado.  A menudo se le ocurre algún truco útil.  Sí, ella tiene una forma sistemática de hacer esto, que siempre funciona.  Pero hay demasiadas etapas "mecánicas" en él.  Un "truco" (sustitución, integración parcial, etc.) no funcionará en el caso general, pero en este caso dará una respuesta más rápida. <br><br>  ¿Qué hay de obtener versiones claras de otras cosas?  Por ejemplo, el trabajo de los programas en el caso general.  O evidencia de mi sistema de axiomas. <br><br>  Comencemos con los programas.  Supongamos que escribimos un programa y queremos explicar cómo funciona.  Uno de los enfoques tradicionales es incluir comentarios en el código.  Si escribimos en un lenguaje tradicional de bajo nivel, esta puede ser la mejor salida.  Pero toda la esencia de Wolfram Language como lenguaje de comunicación computacional es que el lenguaje en sí mismo debería permitir la transmisión de ideas, sin la necesidad de incluir textos adicionales. <br><br>  Se deben hacer esfuerzos para que el programa Wolfram Language sea una buena descripción del proceso, así como para que el texto en inglés simple sea una buena descripción del proceso.  Sin embargo, puede obtener un fragmento de código Wolfram Language que explica muy claramente cómo funciona todo por sí solo. <br><br>  Por supuesto, a menudo sucede que la ejecución real del código conduce a cosas que obviamente no se siguen del programa.  Pronto mencionaré casos extremos como autómatas celulares.  Pero por ahora, imaginemos que hemos creado un programa mediante el cual podemos imaginar lo que generalmente hace. <br><br>  En ese caso, descubrí que los ensayos informáticos presentados como cuadernos Wolfram son una gran herramienta para explicar lo que está sucediendo.  Es importante que Wolfram Language, esto le permite ejecutar incluso las partes más pequeñas de los programas por separado (con las expresiones simbólicas correspondientes como datos de entrada y salida).  Después de eso, puede imaginar la secuencia de pasos del programa como una secuencia de elementos de diálogo que forman la base de un cuaderno de cómputo. <br><br>  En la práctica, a menudo es necesario crear visualizaciones de los datos de entrada y salida.  Sí, todo se puede expresar como una representación simbólica inequívoca.  Pero es mucho más fácil para las personas entender la representación visual de las cosas que cualquier línea unidimensional similar al lenguaje. <br><br>  Por supuesto, crear buenas visualizaciones es similar al arte.  Pero en Wolfram Language, trabajamos mucho para automatizar este arte, a menudo con la ayuda de un aprendizaje automático bastante sofisticado y otros algoritmos que realizan cosas como el diseño de redes o elementos gráficos. <br><br>  ¿Qué tal comenzar con un simple seguimiento del programa?  Esto es dificil de hacer.  He estado experimentando con esto durante décadas, y nunca he estado completamente satisfecho con los resultados.  Sí, puede acercar y ver muchos detalles de lo que está sucediendo.  Pero no encontré suficientes buenas técnicas para comprender la imagen completa, y automáticamente di algunas cosas particularmente útiles. <br><br>  En algún nivel, esta tarea es similar a la ingeniería inversa.  Se le muestra un código de máquina, un circuito de chip, lo que sea.  Y debe dar un paso atrás y recrear la descripción de alto nivel de la cual la persona se repelió, que de alguna manera "compiló" lo que ve. <br><br>  En el enfoque tradicional de la ingeniería, cuando las personas crean un producto por pasos, siempre teniendo la capacidad de anticipar las consecuencias de lo que crean, este enfoque puede funcionar en principio.  Pero si, en cambio, simplemente deambula por el universo informático en busca de un programa óptimo (como estaba buscando posibles sistemas de axiomas para encontrar un sistema para la lógica), entonces no hay garantía de que haya alguna "historia humana" o explicación detrás de este programa. <br><br>  Un problema similar se encuentra en las ciencias naturales.  Usted ve cómo se desarrolla un conjunto complejo de todo tipo de procesos en un sistema biológico.  ¿Es posible someterlos a "ingeniería inversa" para encontrar una "explicación"?  A veces se puede decir que la evolución con selección natural conducirá a esto.  O que a menudo se encuentra en el universo informático, por lo que la probabilidad de que ocurra es alta.  Pero no hay garantía de que el mundo natural esté necesariamente diseñado para que las personas puedan explicarlo. <br><br>  Naturalmente, al modelar cosas, inevitablemente consideramos solo los aspectos que nos interesan e idealizamos todo lo demás.  Y especialmente en áreas como la medicina, a menudo tiene que trabajar con un modelo aproximado con un árbol de decisión superficial, que es fácil de explicar. <br><br><h2>  La naturaleza de la explicabilidad. </h2><br>  ¿Qué significa la frase "algo se puede explicar"?  En esencia, esto significa que las personas pueden entenderlo. <br><br>  ¿Qué se requiere de las personas para entender algo?  Necesitamos darnos cuenta de alguna manera de esto.  Tome un autómata celular típico con un comportamiento complejo.  La computadora no tiene ningún problema para poder seguir cada paso de su evolución.  Con enormes esfuerzos y trabajo, una persona podría reproducir el trabajo de una computadora. <br><br>  Pero no se puede decir que en este caso una persona "entendería" lo que hace un autómata celular.  Para esto, una persona tendría que hablar fácilmente sobre el comportamiento de un autómata celular a un alto nivel.  O, en otras palabras, una persona debe ser capaz de "contar una historia" sobre el comportamiento de un autómata que otras personas puedan entender. <br><br>  ¿Hay una manera universal de hacer esto?  No, debido a la irreductibilidad computacional.  Sin embargo, puede suceder que ciertas características que son importantes para las personas se puedan explicar a un alto nivel con ciertas limitaciones. <br><br>  Como funciona  Para hacer esto, debe crear un cierto lenguaje de alto nivel que pueda describir las características que nos interesan.  Al estudiar un dibujo típico del autómata celular, se puede tratar de hablar no en términos de colores de una gran cantidad de células individuales, sino en términos de estructuras de un nivel superior que se pueden detectar.  Lo principal es que puede compilar al menos un catálogo parcial de tales estructuras: aunque habrá muchos detalles que no encajan en la clasificación, ciertas estructuras son comunes. <br><br>  Y si queremos comenzar a "explicar" el comportamiento de un autómata celular, comenzaremos nombrando las estructuras y luego hablaremos sobre lo que está sucediendo desde el punto de vista de estas estructuras. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b79/395/b3b/b79395b3bad1a1a63252ad645d54cc4b.png"></div><br>  El caso del autómata celular tiene una característica simplificadora: dado que funciona sobre la base de reglas deterministas simples, tiene estructuras igualmente repetitivas.  En la naturaleza, por ejemplo, generalmente no encontramos una repetición tan idéntica.  Solo hay uno, por ejemplo, un tigre, muy similar al otro, por lo tanto, los llamamos a ambos "tigres", aunque la disposición de sus átomos no es idéntica. <br><br>  ¿Cuál es el significado general de todo esto?  Consiste en utilizar la idea de representación simbólica.  Decimos que podemos asignar un cierto símbolo, a menudo esta palabra, que puede usarse para describir simbólicamente una clase completa de cosas, sin tener que enumerar en detalle cada detalle de todos los componentes de estas cosas. <br><br>  Esto es similar a la compresión de información: utilizamos construcciones simbólicas para encontrar una forma más corta de describir cosas que nos interesan. <br><br>  Supongamos que generamos una estructura gigantesca, por ejemplo, una matemática: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27d/923/5ac/27d9235ac9fd46bd22ef8c526e0afbc6.png"></div><br>  El primer paso es crear algún tipo de representación interna de alto nivel.  Por ejemplo, podemos detectar estructuras reutilizables.  Y podemos darles nombres.  Y luego muestre el "esqueleto" de toda la estructura con su ayuda: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba2/102/c89/ba2102c898a14c573ddd207694fd5696.png"></div><br>  Sí, este esquema, similar a la "compresión de diccionario", es útil para alcanzar el primer nivel de explicabilidad. <br><br>  Pero volvamos a la prueba de mi sistema de axiomas.  Los lemas creados en esta prueba se seleccionan especialmente como elementos reutilizables.  Sin embargo, al excluirlos, todavía nos quedan pruebas de que las personas no pueden entender de inmediato. <br><br>  ¿Qué más puedes hacer?  Necesitamos encontrar algún tipo de descripción de un nivel aún más alto.  Que podria ser <br><br><h2>  Concepto de conceptos </h2><br>  Si está tratando de explicarle algo a alguien, entonces será mucho más fácil hacerlo si encuentra algo más, pero similar que una persona ya podría entender.  Imagine cómo explicará el concepto de un avión no tripulado moderno a una persona de la Edad de Piedra.  Será difícil de hacer.  Pero será mucho más fácil explicarle esto a una persona que vivió hace 50 años y que ya vio helicópteros y aviones modelo. <br><br>  Y al final, la conclusión es que cuando explicamos algo, lo hacemos en un idioma conocido tanto por nosotros como por aquel a quien le explicamos.  Y cuanto más rico es el lenguaje, menos elementos nuevos tenemos que introducir para transmitir lo que estamos tratando de explicar. <br><br>  Hay un patrón que se repite a lo largo de la historia de la mente.  Un cierto conjunto de cosas se notan muchas veces.  Gradualmente, comienzan a comprender que estas cosas son de alguna manera abstractamente similares, y todas ellas pueden describirse en términos de un nuevo concepto, que se describe en alguna nueva palabra o frase. <br><br>  Supongamos que notamos cosas como agua, sangre y aceite.  En algún momento, entendemos que existe un concepto generalizado de "líquido", y todos ellos pueden describirse como líquidos.  Y cuando tenemos ese concepto, podemos comenzar a razonar en sus términos, encontrando más conceptos, digamos viscosidad, en base a él. <br><br>  ¿Cuándo tiene sentido combinar las cosas en un concepto?  Una pregunta difícil que no se puede responder sin prever todo lo que se puede hacer con este concepto.  En la práctica, en el proceso de evolución del lenguaje y las ideas de una persona, se observa un cierto proceso de aproximación sucesiva. <br><br>  En el sistema moderno de aprendizaje automático, se produce una suma de información mucho más rápida.  Imagine que tomamos todo tipo de objetos en todo el mundo y los alimentamos con funciones <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FeatureSpacePlot</a> para ver qué sucede.  Si obtenemos ciertos grupos en el espacio de características, entonces podemos concluir que cada uno de ellos se puede definir como correspondiente a un cierto "concepto", que, por ejemplo, se puede marcar con una palabra. <br><br>  Honestamente, lo que sucede con FeatureSpacePlot, como en el proceso de desarrollo intelectual humano, es, en cierto sentido, un proceso paso a paso.  Para distribuir objetos por espacio de características, FeatureSpacePlot usa características que aprendió a extraer de intentos anteriores de categorización. <br><br>  Bueno, si aceptamos el mundo tal como es, ¿cuáles son las mejores categorías, o conceptos, que se pueden usar para describir cosas?  Esta pregunta está en constante evolución.  En general, todos los avances, ya sea ciencia, tecnología u otra cosa, a menudo se asocian con precisión con la realización de la posibilidad de identificar una nueva categoría o concepto de una manera útil. <br><br>  Pero en el proceso de evolución de nuestra civilización hay una cierta espiral.  En primer lugar, se define un cierto concepto definido, digamos, la idea de un programa.  Después de eso, las personas comienzan a usarlo y a reflexionar en sus términos.  Muy pronto, muchos conceptos diferentes se construyen sobre la base de este concepto.  Y luego se determina otro nivel de abstracción, se crean nuevos conceptos basados ​​en el anterior. <br><br>  La historia es característica del conjunto tecnológico de conocimiento de la civilización moderna y su conjunto intelectual de conocimiento.  Tanto allí como hay torres de conceptos y niveles de abstracción que van uno tras otro. <br><br><h2>  Problema de aprendizaje </h2><br>  Para que las personas puedan comunicarse utilizando un determinado concepto, necesitan saberlo.  Y sí, algunos conceptos (como la constancia de los objetos) son reconocidos automáticamente por las personas simplemente observando la naturaleza.  Pero suponga que si mira la lista de palabras comunes del inglés moderno, quedará claro que la mayoría de los conceptos utilizados por nuestra civilización moderna no se aplican a aquellos que las personas conocen de sí mismas, observando la naturaleza. <br><br>  En cambio, que recuerda mucho al aprendizaje automático moderno, necesitan un conocimiento especial del mundo "bajo supervisión", organizado para enfatizar la importancia de ciertos conceptos.  Y en áreas más abstractas (como las matemáticas), probablemente necesiten encontrar conceptos en su forma abstracta inmediata. <br><br>  Bueno, pero ¿necesitaremos aprender más y más todo el tiempo con el aumento en la cantidad de conocimiento intelectual acumulado de la civilización?  Puede haber preocupación de que en algún momento nuestro cerebro simplemente no podrá mantenerse al día con el desarrollo, y tendremos que agregar ayuda adicional.  Pero me parece que, afortunadamente, este es uno de esos casos en los que el problema puede resolverse "a nivel de software". <br><br>  El problema es este: en cualquier momento de la historia hay un cierto conjunto de conceptos que es importante para la vida en el mundo en este período.  Y sí, con el desarrollo de la civilización, se revelan nuevos conceptos y se introducen nuevos conceptos.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, hay otro proceso: los nuevos conceptos introducen nuevos niveles de abstracción, que generalmente incluyen una gran cantidad de conceptos anteriores. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A menudo podemos observar esto en tecnología. Hubo un tiempo en que necesitabas conocer muchos detalles de bajo nivel para trabajar en una computadora. Pero con el tiempo, estos detalles se abstrajeron, por lo que ahora solo necesita un concepto general. Hace clic en el icono y comienza el proceso; no es necesario que comprenda las complejidades del funcionamiento de los sistemas operativos, los controladores de interrupciones, los programadores y todos los demás detalles.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y, por supuesto, Wolfram Language ofrece un gran ejemplo de esto. Pone mucho esfuerzo en automatizar muchos detalles de bajo nivel (por ejemplo, cuál de los algoritmos debe usarse) y permite a los usuarios pensar en conceptos de alto nivel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sí, todavía se necesita gente que entienda los detalles que subyacen a las abstracciones (aunque no estoy seguro de cuántos cortadores de piedras requiere la sociedad moderna). Pero en su mayor parte, la educación puede concentrarse en un alto nivel de conocimiento.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A menudo se supone que para lograr conceptos de alto nivel en el proceso de aprendizaje, una persona debe primero resumir de alguna manera la historia de cómo estos conceptos llegaron a ser históricamente. Pero generalmente, y tal vez siempre, parece que no es así. Puede dar un ejemplo extremo: imagine que para aprender a usar una computadora, primero debe revisar toda la historia de la lógica matemática. Sin embargo, en realidad se sabe que las personas recurren inmediatamente a los conceptos modernos de computación, sin la necesidad de estudiar algún tipo de historia. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero, ¿cómo se ve la claridad de la red de conceptos? ¿Hay conceptos que solo pueden entenderse entendiendo otros conceptos? Dada la capacitación de las personas sobre la base de la interacción con el medio ambiente (o la capacitación de una red neuronal), es probable que exista su orden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero me parece que un cierto principio, similar a la universalidad de la informática, sugiere que con un "cerebro puro" en la mano, puede comenzar desde cualquier lugar. </font><font style="vertical-align: inherit;">Entonces, si algunos extraterrestres aprenderían sobre la teoría de categorías y casi nada más, sin duda, construirían una red de conceptos donde esta teoría está en la raíz, y lo que conocemos como los fundamentos de la aritmética se estudiaría a partir de ellos. en algún lugar análogo a nuestro instituto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, estos extraterrestres podrían construir su conjunto de tecnologías y su entorno de una manera muy diferente a la nuestra, al igual que nuestra historia podría ser completamente diferente si las computadoras pudieran desarrollarse con éxito en el siglo XIX y no a mediados del siglo XX.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Progreso matemático </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A menudo reflexioné sobre hasta qué punto la trayectoria histórica de las matemáticas está sujeta al papel del azar, y hasta qué punto era inevitable. Como ya mencioné, en el nivel de los sistemas formales, hay muchos sistemas posibles de axiomas en los que puede construir algo que se parezca formalmente a las matemáticas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero la historia real de las matemáticas no comenzó con un sistema arbitrario de axiomas. Comenzó en la época de los babilonios con intentos de usar la aritmética para el comercio y la geometría con el propósito de desarrollar tierras. Y a partir de estas raíces prácticas, se comenzaron a agregar niveles subsiguientes de abstracción, que finalmente condujeron a las matemáticas modernas: por ejemplo, los números se generalizaron gradualmente de enteros positivos a racionales, luego a raíces, luego a todos los enteros, a fracciones decimales, a números complejos, a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algebraicos. numeros</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuaterniones</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , etc. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Hay una inevitabilidad de tal camino de desarrollo de abstracciones? </font><font style="vertical-align: inherit;">Sospecho, hasta cierto punto, sí. </font><font style="vertical-align: inherit;">Quizás este sea el caso con otros tipos de formación de conceptos. </font><font style="vertical-align: inherit;">Una vez alcanzado un cierto nivel, tiene la oportunidad de estudiar varias cosas y, con el tiempo, los grupos de estas cosas se convierten en ejemplos de construcciones más generales y abstractas, que a su vez determinan un nuevo nivel, a partir del cual, uno puede aprender algo nuevo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Hay alguna forma de salir de este ciclo? </font><font style="vertical-align: inherit;">Una posibilidad puede estar relacionada con experimentos matemáticos. </font><font style="vertical-align: inherit;">Uno puede probar sistemáticamente cosas relacionadas con ciertos sistemas matemáticos. </font><font style="vertical-align: inherit;">Pero uno puede notar empíricamente hechos matemáticos, como </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ramanujan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> una vez notado que </font></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mi>e</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>&amp;#x03C0;</mi><msqrt><mn>163</mn></msqrt></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.092ex" height="2.78ex" viewBox="0 -1091.4 2623.1 1197.1" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/431956/&amp;usg=ALkJrhjF8r1A2IAW3byiz9kvuCd4XjQB_Q#MJMATHI-65" x="0" y="0"></use><g transform="translate(466,362)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/431956/&amp;usg=ALkJrhjF8r1A2IAW3byiz9kvuCd4XjQB_Q#MJMATHI-3C0" x="0" y="0"></use><g transform="translate(405,0)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/431956/&amp;usg=ALkJrhjF8r1A2IAW3byiz9kvuCd4XjQB_Q#MJMAIN-221A" x="0" y="26"></use><rect stroke="none" width="1061" height="42" x="589" y="543"></rect><g transform="translate(589,0)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/431956/&amp;usg=ALkJrhjF8r1A2IAW3byiz9kvuCd4XjQB_Q#MJMAIN-31"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/431956/&amp;usg=ALkJrhjF8r1A2IAW3byiz9kvuCd4XjQB_Q#MJMAIN-36" x="500" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/431956/&amp;usg=ALkJrhjF8r1A2IAW3byiz9kvuCd4XjQB_Q#MJMAIN-33" x="1001" y="0"></use></g></g></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>e</mi><mrow class="MJX-TeXAtom-ORD"><mi>π</mi><msqrt><mn>163</mn></msqrt></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-1">e^{\pi \sqrt{163}}</script><br><br><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De la misma manera que uno puede numerar sistemas de axiomas, uno puede imaginar la numeración de posibles preguntas en matemáticas. Pero esto inmediatamente plantea un problema. El teorema de Gödel establece que en sistemas de axiomas como el relacionado con la aritmética, existen teoremas "formalmente insolubles" que no pueden ser probados o refutados dentro del marco de este sistema de axiomas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, los ejemplos específicos creados por Gödel parecían estar muy lejos de lo que realmente podría surgir en las clases de matemáticas. Y durante mucho tiempo se creyó que, de alguna manera, el fenómeno de la insolubilidad era algo que, en principio, existe, pero que no estará relacionado con la "matemática real".</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, de acuerdo con mi principio de equivalencia computacional y mi experiencia en el universo computacional, estoy bastante seguro de que esto no es así, y que de hecho la insolubilidad está muy cerca incluso en las matemáticas típicas. No me sorprendería si una parte tangible de los problemas de las matemáticas sin resolver por hoy (la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hipótesis de Riemann</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , P = NP, etc.) </font><font style="vertical-align: inherit;">no se puede resolver </font><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero si hay mucha insolubilidad, ¿cómo es que tantas cosas en matemáticas se resuelven con éxito? Creo que esto se debe a que los problemas resueltos con éxito se eligieron especialmente para evitar la insolvencia, simplemente debido a cómo se construye el desarrollo de las matemáticas. Porque, de hecho, si formamos niveles sucesivos de abstracción basados ​​en conceptos que hemos demostrado, entonces estamos allanando el camino para avanzar sin convertirse en insolubilidad. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, las matemáticas experimentales o las "preguntas aleatorias" pueden llevarnos inmediatamente a un área llena de insolubilidad. Pero, al menos por ahora, la disciplina básica de las matemáticas no se ha desarrollado de esta manera.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Y qué hay de estos "hechos aleatorios de las matemáticas"? Sí, lo mismo que con otras áreas de investigación intelectual. Los "hechos aleatorios" no se incluyen en el camino del desarrollo intelectual hasta que se construya alguna estructura, generalmente algunos conceptos abstractos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un buen ejemplo es mi descubrimiento favorito del origen de la complejidad en tales sistemas, generalmente 30 autómatas celulares. Sí, fenómenos similares ya se observaron incluso hace miles de años (por ejemplo, aleatoriedad en una secuencia de números primos). Pero sin una plataforma conceptual más amplia, pocas personas les prestaron atención.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otro ejemplo son las secuencias anidadas (fractales). Hay algunos ejemplos de cómo se conocieron en el mosaico del siglo XIII, pero nadie les prestó atención hasta que en la década de 1980 surgió una plataforma completa alrededor de los fractales. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La misma historia se repite una y otra vez: hasta que se definan los conceptos abstractos, es difícil hablar de nuevos conceptos, incluso cuando se enfrentan a un fenómeno que los demuestra. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sospecho que este es el caso en las matemáticas: existe una cierta estratificación inevitable de algunos conceptos abstractos sobre otros, lo que determina el camino de las matemáticas. ¿Es este camino único? Sin duda no. En el vasto espacio de posibles hechos matemáticos, hay ciertas direcciones que se seleccionan para futuras construcciones. Pero puedes elegir otros.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Significa esto que los temas de matemáticas son inevitablemente impulsados ​​por accidentes históricos? </font><font style="vertical-align: inherit;">No tanto como podrías pensar. </font><font style="vertical-align: inherit;">De hecho, a medida que las matemáticas se descubrieron una y otra vez, comenzando con cosas como álgebra y geometría, existe una tendencia notable en la que diferentes direcciones y diferentes enfoques conducen a resultados equivalentes o correspondientes entre sí. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quizás, hasta cierto punto, esto sea una consecuencia del principio de equivalencia computacional y el fenómeno de la universalidad computacional: aunque las reglas básicas (o "lenguaje") utilizadas en diferentes áreas de las matemáticas difieren, el resultado es una forma de traducir entre ellas, y en el siguiente nivel de abstracción el camino elegido ya no será tan crítico.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Prueba lógica y automatización de la abstracción. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De vuelta a las pruebas lógicas. ¿Cómo se relacionan con las matemáticas típicas? Hasta ahora, de ninguna manera. Sí, la prueba tiene nominalmente la misma forma que la prueba matemática estándar. Pero no es "amigable con las personas de matemáticas". Estas son solo partes mecánicas. No está asociado con conceptos abstractos de alto nivel que sean entendibles para las matemáticas humanas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos ayudaría mucho si descubriéramos que los lemas de pruebas no triviales ya aparecieron en la literatura matemática (no lo creo, pero nuestras posibilidades de búsqueda por teoremas aún no han alcanzado un nivel tal que podamos estar seguros). Pero si aparecen, probablemente nos dará una manera de conectar estos lemas con otras cosas en matemáticas, y definir su círculo de conceptos abstractos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero, ¿cómo se puede explicar la evidencia sin esto? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quizás haya otra forma de llevar a cabo la prueba, fundamentalmente más relacionada con las matemáticas existentes. Pero incluso con la evidencia que tenemos ahora, uno puede imaginar "ajustar" nuevos conceptos que definirían un mayor nivel de abstracción y ubicarían esta prueba en un contexto más general. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No estoy seguro de cómo hacer esto. Estaba considerando nominar un premio (algo así como mi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Premio Turing 2007</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) para "transformar la evidencia en una forma comprensible". Sin embargo, es completamente incomprensible cómo se puede evaluar la "explicabilidad". Se le podría pedir que grabe un video de una hora de duración en el que se ofrecería una explicación exitosa de la prueba, adecuada para un matemático típico, pero eso sería muy subjetivo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero de la misma manera que es posible automatizar la búsqueda de hermosos diseños de redes, quizás podamos automatizar el proceso de convertir la evidencia en algo explicable. La prueba actual, de hecho, sin explicación, sugiere considerar varios cientos de lemas. Pero supongamos que pudiéramos definir un pequeño número de lemas "interesantes". Quizás de alguna manera podríamos agregarlos a nuestro canon de matemáticas famosas, y luego podríamos usarlos para comprender la prueba.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existe una analogía con el desarrollo de los lenguajes. Al crear Wolfram Language, trato de identificar las "piezas de trabajo computacional" que la gente suele necesitar. Creamos funciones integradas en el lenguaje a partir de ellos, con nombres específicos que las personas pueden usar para referirse a ellos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un proceso similar está en marcha, aunque no tan organizado, en la evolución de los lenguajes naturales. Las “piezas de significado” que resultan útiles eventualmente obtienen sus palabras en el idioma. A veces comienzan con frases que consisten en varias palabras existentes. Pero los más influyentes suelen estar tan lejos de las palabras existentes que aparecen en forma de palabras nuevas, que son potencialmente bastante difíciles de definir.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al desarrollar Wolfram Language, cuyas funciones se llaman usando palabras en inglés, confío en la comprensión general del idioma inglés por parte de una persona (y, a veces, en la comprensión de las palabras que se usan en aplicaciones informáticas comunes). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uno tendría que hacer algo similar para determinar qué lemas agregar al canon matemático. Sería necesario no solo asegurarse de que cada lema sea de alguna manera "esencialmente interesante", sino también seleccionar lemas que sean "fáciles de deducir" de los conceptos y resultados matemáticos existentes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero, ¿qué hace que el lema sea "esencialmente interesante"? Hay que decir que antes de trabajar en mi libro, culpé a la elección de lemas (o torres) en cualquier área de las matemáticas que se describe y nombra en los libros de texto, gran arbitrariedad y accidentes históricos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero, habiendo analizado los teoremas de la lógica básica en detalle, me sorprendió encontrar algo completamente diferente. Supongamos que hemos construido todos los teoremas de lógica correctos en orden de su tamaño </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(por ejemplo, p = p será el primero, p AND p = p, un poco más tarde, etc.). Esta lista tiene mucha redundancia. La mayoría de los teoremas resultan ser una extensión trivial de los teoremas que ya han aparecido en la lista. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero a veces aparece un teorema que produce nueva información que no se puede probar sobre la base de teoremas que ya han aparecido en la lista. Un hecho notable: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">existen 14 teoremas de este tipo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y, en esencia, corresponden exactamente a los teoremas que generalmente se dan nombres en los libros de texto sobre lógica (aquí AND es ∧, OR es ∨, y NOT es ¬.)</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a00/078/057/a0007805787992eee313fa748deba866.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En otras palabras, en este caso los teoremas nombrados o "interesantes" son precisamente aquellos que hacen declaraciones sobre nueva información de un tamaño mínimo. Sí, de acuerdo con esta definición, después de algún tiempo, ya no existirá nueva información, ya que obtendremos todos los axiomas necesarios para demostrar todo lo que es posible, aunque puede ir más allá al comenzar a limitar la complejidad de la evidencia admisible. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué pasa con los teoremas de NAND, por ejemplo, los que se encuentran en la prueba? Nuevamente, puede construir todos los teoremas verdaderos en orden, y encontrar cuáles no se pueden probar sobre la base de los teoremas anteriores de la lista:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a8/4b3/022/3a84b3022c9b5408ce524671b006c814.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NAND no tiene una tradición histórica como AND, OR y NOT. Y, aparentemente, no existe un lenguaje humano en el que NAND se denota con una palabra. Pero en la lista de teoremas de NAND, el primero de los anteriores se reconoce fácilmente como la conmutatividad de NAND. Después de eso, solo se necesitan unas pocas traducciones para darles nombres: a = (a · a) · (a · a) es como doble negación, a = (a · a) · (a · b) es como la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ley de absorción</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , (a · A) · b = (a · b) · b es similar a "debilitamiento", y así sucesivamente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bueno, si vamos a aprender algunos "teoremas clave" de la lógica NAND, ¿qué tipo de teoremas deberían ser estos? Quizás estos deberían ser "lemas populares" en las pruebas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, cualquier teorema puede tener muchas pruebas posibles. Pero supongamos que solo usaremos la evidencia que produce FindEquationalProof. Entonces resulta que en la prueba de los primeros mil teoremas NAND, el lema más popular es a · a = a · ((a · a) · a), seguido de lemas del tipo (a · ((a · a) · a)) · ( a (a ((a a) a))) = a. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué son estos lemas? Son útiles para los métodos utilizados por FindEquationalProof. Pero para las personas, no parecen ser muy adecuadas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué pasa con los lemas que resultan ser cortos? a · b = b · a definitivamente no es el más popular, sino el más corto. (a · a) · (a · a) = a es más popular, pero más largo. Y luego hay lemas como (a · a) · (b · a) = a.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué tan útiles serán estos lemas? Aquí hay una forma de verificar esto. Veamos los primeros mil teoremas NAND y evalúe cómo la adición de lemas acorta las pruebas de estos teoremas (al menos los encontrados por FindEquationalProof):</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/549/2f6/5d5/5492f65d5a0b28d9b2ad56e910d4a673.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a · b = b · a tiene mucho éxito y, a menudo, recorta la prueba en casi 100 pasos. </font><font style="vertical-align: inherit;">(a · a) · (a · a) = a es mucho menos exitoso; </font><font style="vertical-align: inherit;">a veces incluso "confunde" FindEquationalProof, lo que le obliga a dar más pasos de los necesarios (valores negativos en los gráficos). </font><font style="vertical-align: inherit;">(a · a) · (b · a) = a hace frente a la contracción, pero no tan bueno como a · b = b · a. </font><font style="vertical-align: inherit;">Aunque, si lo combina con a · b = b · a, como resultado, las reducciones ocurren con mayor frecuencia. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El análisis puede continuar, por ejemplo, mediante la inclusión de una comparación de cuánto acorta un lema particular la longitud de la evidencia con respecto a su longitud original. </font><font style="vertical-align: inherit;">Pero el problema es que si agrega algunos "lemas útiles" como a · b = b · a y (a · a) · (b · a) = a, todavía hay mucha evidencia larga, es decir, mucho de lo que se necesita Para entender.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c5/410/c0e/5c5410c0e4690236d76c45f5e32e53f3.png"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¿Qué podemos entender? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay diferentes formas de modelar cosas. Durante varios cientos de años, las ciencias exactas estuvieron dominadas por la idea de encontrar ecuaciones matemáticas que pudieran resolverse para mostrar cómo se comportaría el sistema. Pero desde la aparición de mi libro, ha habido un cambio activo hacia la creación de programas que puede ejecutar para ver cómo se comportarán los sistemas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A veces, dichos programas se escriben para una tarea específica; a veces son buscados por mucho tiempo. Y en nuestro tiempo, al menos una clase de tales programas se deriva mediante el aprendizaje automático, mediante el método de movimiento inverso a partir de ejemplos conocidos de comportamiento del sistema.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Y cuán fácil es "comprender lo que está sucediendo" con estos diversos tipos de modelado? Encontrar la "solución exacta" de las ecuaciones matemáticas es una gran ventaja: entonces el comportamiento del sistema puede describirse mediante una fórmula matemática exacta. Pero incluso cuando esto no sea así, a menudo es posible escribir algunas declaraciones matemáticas lo suficientemente abstractas como para relacionarlas con otros sistemas y comportamientos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como escribí anteriormente, con un programa, como un autómata celular, todo puede ser diferente. Muy a menudo sucede que nos encontramos de inmediato con la irreductibilidad computacional, lo que limita nuestra capacidad de avanzar un poco y "explicar" lo que está sucediendo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué pasa con el aprendizaje automático y las redes neuronales? En cierto sentido, el entrenamiento de redes neuronales es como un breve resumen de la búsqueda inductiva que se realiza en las ciencias naturales. Estamos intentando, comenzando con ejemplos, deducir un modelo de comportamiento del sistema. ¿Pero entonces será posible entender el modelo? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y de nuevo, hay problemas con la irreductibilidad computacional. Pero analicemos un caso en el que podemos imaginar cómo sería la situación en la que podemos entender lo que está sucediendo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En lugar de utilizar una red neuronal para simular el comportamiento del sistema, echemos un vistazo a la creación de una red neuronal que clasifique algún aspecto del mundo: por ejemplo, tomar imágenes y distribuirlas según su contenido ("barco", "jirafa", etc.). Cuando entrenamos la red neuronal, aprende a producir la salida correcta. Pero puede imaginarse este proceso como una construcción interna de una secuencia de diferencias (algo así como un juego de " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">veinte preguntas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "), que finalmente determina la conclusión correcta.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Pero cuáles son estas diferencias? A veces podemos reconocerlos. Por ejemplo, "¿Hay mucho azul en la imagen?" Pero la mayoría de las veces estas son algunas propiedades del mundo que la gente no nota. Quizás haya una historia alternativa de las ciencias naturales en la que algunas de ellas demostrarían estar. Pero no son parte del canon actual de percepción o análisis. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si quisiéramos agregarlos, entonces tal vez vendríamos con nombres para ellos. Pero esta situación es similar a la situación con evidencia lógica. El sistema automático ha creado algunas cosas que utiliza como hitos para generar el resultado. Pero no reconocemos estos hitos, no significan nada para nosotros.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuevamente, si descubrimos que a menudo se encuentran ciertas diferencias específicas en las redes neuronales, podríamos decidir que son dignas de nosotros para estudiarlas por nosotros mismos y agregarlas al canon estándar de formas de describir el mundo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Podemos esperar que un pequeño número de tales diferencias nos permita crear algo significativo? Parece que la pregunta es si un pequeño número de teoremas nos ayudará a entender una prueba lógica. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creo que la respuesta no está clara. Si estudia, por ejemplo, un gran conjunto de trabajos científicos en matemáticas, puede hacer preguntas sobre la frecuencia de uso de varios teoremas. Resulta que la frecuencia de los teoremas corresponde casi perfectamente </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a la ley de Zipf</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (y en primer lugar habrá un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">teorema del límite central</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ,</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">teorema de la </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">función implícita</font></a><font style="vertical-align: inherit;"> y el </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">teorema de Tonelli-Fubini</font></a><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Lo mismo probablemente sucede con las diferencias que "vale la pena conocer", o con nuevos teoremas que "vale la pena conocer". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El conocimiento de varios teoremas nos dará la oportunidad de avanzar lo suficiente, pero siempre habrá una cola exponencial infinita y no llegaremos al final.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Futuro del conocimiento </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al estudiar matemáticas, ciencias o tecnología, puede ver caminos básicos similares de desarrollo cualitativo, que consisten en construir un conjunto de abstracciones cada vez mayores. </font><font style="vertical-align: inherit;">Sería bueno cuantificar este proceso. </font><font style="vertical-align: inherit;">Quizás sea posible calcular cómo se incluyen ciertos términos o descripciones que a menudo se encuentran al mismo tiempo en niveles más altos de abstracción, en los cuales aparecen a su vez nuevos términos o descripciones en relación con ellos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es posible crear un modelo idealizado de este proceso utilizando un modelo formal de cómputo como las máquinas de Turing. Imagine que en el nivel más bajo hay una máquina básica de Turing sin abstracciones. Ahora imagine que seleccionamos programas para esta máquina de Turing de acuerdo con algún proceso aleatorio específico. Luego ejecutamos estos programas y los analizamos para ver qué modelo del nivel de cómputo "superior" puede reproducir con éxito el comportamiento conjunto de estos programas sin tener que realizar cada paso en cada uno de ellos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se podría decidir que la irreductibilidad computacional conduciría al hecho de que la creación de este modelo de computación de nivel superior inevitablemente sería más complicada. Pero el punto clave es que solo estamos tratando de reproducir el comportamiento conjunto de los programas, y no su comportamiento separado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero, ¿qué sucede si este proceso se repite una y otra vez, reproduciendo la historia intelectual idealizada del hombre y creando una torre de abstracciones cada vez más altas? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Presumiblemente, aquí podemos dibujar una analogía con fenómenos críticos en física y el método del </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grupo de renormalización</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Si es así, podemos imaginar que podemos determinar la trayectoria en el espacio de plataformas para representar conceptos. ¿Qué hará esta trayectoria?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tal vez tenga un valor fijo cuando en cualquier momento de la historia haya aproximadamente la misma cantidad de estudio valioso de los conceptos: los nuevos conceptos se abren lentamente y los viejos se absorben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué significa esto para las matemáticas? </font><font style="vertical-align: inherit;">Por ejemplo, que cualquier "hecho matemático aleatorio" descubierto empíricamente eventualmente será considerado al alcanzar un cierto nivel de abstracción. </font><font style="vertical-align: inherit;">No hay una comprensión obvia de cómo funcionará este proceso. </font><font style="vertical-align: inherit;">De hecho, en cualquier nivel de abstracción, siempre hay nuevos hechos empíricos a los que uno debe "saltar". </font><font style="vertical-align: inherit;">También puede ocurrir que "elevar el nivel de abstracción" se mueva más lento de lo necesario para estos "saltos".</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Futuro de la comprensión </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué significa todo esto para la comprensión futura? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el pasado, cuando las personas estudiaban la naturaleza, tenían una pequeña cantidad de razones para entenderla. A veces personificaban ciertos aspectos en forma de espíritus o deidades. Pero lo aceptaron como era, sin pensar en la posibilidad de comprender todos los detalles de las causas de los procesos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con el advenimiento de la ciencia moderna, y especialmente cuando pasamos cada vez más nuestras vidas en entornos artificiales dominados por las tecnologías desarrolladas por nosotros, estas expectativas han cambiado. Y cuando estudiamos los cálculos realizados por AI, no nos gusta que no podamos entenderlos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, siempre habrá una competencia entre lo que hacen los sistemas de nuestro mundo y lo que nuestro cerebro puede calcular a partir de su comportamiento. Si decidimos interactuar solo con sistemas que son mucho más simples que el cerebro en potencia informática, entonces podemos esperar que podamos entender sistemáticamente lo que están haciendo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero si queremos utilizar todas las capacidades informáticas disponibles en el universo, inevitablemente los sistemas con los que interactuamos alcanzarán el poder de procesamiento de nuestro cerebro. Y esto significa que, de acuerdo con el principio de irreductibilidad computacional, nunca podemos "adelantar" o "comprender" sistemáticamente el funcionamiento de estos sistemas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero, ¿cómo podemos usarlos? Bueno, al igual que los humanos siempre usaban los sistemas de la naturaleza. Por supuesto, no conocemos todos los detalles de su trabajo o capacidades. Pero en un cierto nivel de abstracción, sabemos lo suficiente como para entender cómo lograr nuestros objetivos con su ayuda. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué pasa con áreas como las matemáticas? En matemáticas, estamos acostumbrados a construir nuestro conjunto de conocimientos para que podamos entender cada paso. Pero las matemáticas experimentales, así como características como la prueba automática de teoremas, hacen evidente la existencia de áreas en las que dicho método no estará disponible para nosotros.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Los llamaremos "matemáticas"? </font><font style="vertical-align: inherit;">Creo que deberían hacerlo. </font><font style="vertical-align: inherit;">Pero esta tradición es diferente de la que estamos acostumbrados en el último milenio. </font><font style="vertical-align: inherit;">Todavía podemos crear abstracciones allí y construir nuevos niveles de comprensión. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero en algún lugar de su base habrá todo tipo de versiones diferentes de irreductibilidad computacional, que nunca podremos transferir al campo de la comprensión humana. </font><font style="vertical-align: inherit;">Esto es aproximadamente lo que sucede en la prueba de mi pequeño axioma de lógica. </font><font style="vertical-align: inherit;">Este es un ejemplo temprano de lo que creo que será uno de los principales aspectos de las matemáticas, y mucho más, en el futuro.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es431956/">https://habr.com/ru/post/es431956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es431944/index.html">Yealink Meeting Server 2.0 - Nuevas características de videoconferencia</a></li>
<li><a href="../es431946/index.html">Semana de la seguridad 49: piratería de Dell y Marriott</a></li>
<li><a href="../es431948/index.html">Deep Mind enseñó a su IA a predecir la estructura de la proteína</a></li>
<li><a href="../es431950/index.html">Cómo pronosticar la demanda y automatizar las compras usando el aprendizaje automático: caso Ozon</a></li>
<li><a href="../es431954/index.html">El ex vicepresidente de Sun y DEC se convierte en presidente de MIPS / Wave, habla sobre Rusia y RISC / V</a></li>
<li><a href="../es431958/index.html">La estación de energía de batería virtual de Tesla se expande a 1,000 hogares en Australia</a></li>
<li><a href="../es431960/index.html">Nvidia se vuelve loca y abre PhysX bajo BSD-3</a></li>
<li><a href="../es431964/index.html">Combinar clasificaciones</a></li>
<li><a href="../es431968/index.html">Grandes preguntas frecuentes sobre trenes de larga distancia y reglas no obvias</a></li>
<li><a href="../es431970/index.html">Departamento de soporte: Expectativa vs Realidad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>