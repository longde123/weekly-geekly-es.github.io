<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè¶ ‚èèÔ∏è üë®üèø‚Äç‚öïÔ∏è Tr√™s tipos de vazamentos de mem√≥ria ü§õüèª üïé üéà</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° colegas. 

 Nossa longa pesquisa por livros atemporais e mais vendidos sobre otimiza√ß√£o de c√≥digo produziu apenas os primeiros resultados, mas est...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tr√™s tipos de vazamentos de mem√≥ria</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/432072/"> Ol√° colegas. <br><br>  Nossa longa pesquisa por livros atemporais e mais vendidos sobre otimiza√ß√£o de c√≥digo produziu apenas os primeiros resultados, mas estamos prontos para agradar a voc√™ que a tradu√ß√£o do lend√°rio livro de Ben Watson, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Writing High Performance .NET .NET Code</a> ", foi literalmente conclu√≠da.  Nas lojas - provisoriamente em abril, preste aten√ß√£o √† publicidade. <br><br>  Hoje, oferecemos a voc√™ a leitura de um artigo puramente pr√°tico sobre os tipos mais prementes de vazamento de mem√≥ria, escrito por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Nelson Ilheidzhe</a> (Strike). <br><a name="habracut"></a><br>  Portanto, voc√™ tem um programa que leva mais tempo para ser conclu√≠do, mais tempo leva.  Provavelmente, n√£o ser√° dif√≠cil para voc√™ entender que esse √© um sinal claro de vazamento de mem√≥ria. <br>  No entanto, o que exatamente queremos dizer com "vazamento de mem√≥ria"?  Na minha experi√™ncia, vazamentos de mem√≥ria expl√≠cita s√£o divididos em tr√™s categorias principais, cada uma das quais √© caracterizada por um comportamento especial e, para depura√ß√£o de cada uma das categorias, s√£o necess√°rias ferramentas e t√©cnicas especiais.  Neste artigo, quero descrever todas as tr√™s classes e sugerir como reconhecer corretamente, com <br>  com qual classe voc√™ est√° lidando e como encontrar um vazamento. <br><br>  Tipo (1): Fragmento de mem√≥ria inacess√≠vel alocado <br><br>  Este √© um vazamento de mem√≥ria cl√°ssico em C / C ++.  Algu√©m alocou mem√≥ria usando <code>new</code> ou <code>malloc</code> e n√£o chamou <code>free</code> ou <code>delete</code> para liberar mem√≥ria depois de terminar de trabalhar com ele. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leak_memory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *leaked = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">4096</span></span>); use_a_buffer(leaked); <span class="hljs-comment"><span class="hljs-comment">/* ,   free() */</span></span> }</code> </pre> <br>  <i>Como determinar se um vazamento pertence a esta categoria</i> <br><br><ul><li>  Se voc√™ escreve em C ou C ++, especialmente em C ++, sem o amplo uso de ponteiros inteligentes para controlar o tempo de vida √∫til dos segmentos de mem√≥ria, essa √© a op√ß√£o que estamos considerando primeiro. </li><li>  Se o programa for executado em um ambiente com coleta de lixo, √© poss√≠vel que um vazamento desse tipo seja provocado por uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">extens√£o de c√≥digo nativa</a> ; no entanto, os vazamentos dos tipos (2) e (3) devem ser eliminados primeiro. </li></ul><br>  <i>Como encontrar um vazamento</i> <br><br><ul><li>  Use <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ASAN</a> .  Use ASAN.  Use ASAN. </li><li>  Use um detector diferente.  Eu tentei as ferramentas Valgrind ou tcmalloc para trabalhar com muitos, tamb√©m existem outras ferramentas em outros ambientes. </li><li>  Alguns alocadores de mem√≥ria permitem despejar o perfil de heap, que mostrar√° todas as √°reas de mem√≥ria n√£o alocada.  Se houver um vazamento, depois de algum tempo, quase todas as descargas ativas sair√£o dele, portanto, provavelmente n√£o ser√° dif√≠cil encontr√°-lo. </li><li>  Se tudo mais falhar, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">despeje um despejo de mem√≥ria e examine-o da maneira mais meticulosa poss√≠vel</a> .  Mas definitivamente n√£o deve come√ßar com isso. </li></ul><br>  <b>Tipo (2): aloca√ß√µes n√£o planejadas de mem√≥ria de longa dura√ß√£o</b> <br><br>  Tais situa√ß√µes n√£o s√£o "vazamentos" no sentido cl√°ssico da palavra, uma vez que um link de algum lugar para esse peda√ßo de mem√≥ria ainda √© preservado, portanto, no final, ele pode ser liberado (se o programa conseguir chegar l√° sem usar toda a mem√≥ria). <br>  Situa√ß√µes nesta categoria podem surgir por v√°rios motivos espec√≠ficos.  Os mais comuns s√£o: <br><br><ul><li>  Ac√∫mulo n√£o intencional de estado em uma estrutura global;  por exemplo, o servidor HTTP grava na lista global cada objeto de <code>Request</code> recebido. </li><li>  Caches sem uma pol√≠tica de obsolesc√™ncia bem pensada.  Por exemplo, um cache ORM que armazena em cache todos os objetos carregados, ativos durante a migra√ß√£o, nos quais todos os registros presentes na tabela s√£o carregados sem exce√ß√£o. </li><li>  Um estado muito volumoso √© capturado no circuito.  Esse caso √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">especialmente comum</a> no Java Script, mas tamb√©m pode ocorrer em outros ambientes. </li><li>  Em um sentido mais amplo, a reten√ß√£o inadvertida de cada elemento de uma matriz ou fluxo, enquanto se supunha que esses elementos seriam processados ‚Äã‚Äãpor streaming online. </li></ul><br>  <i>Como determinar se um vazamento pertence a esta categoria</i> <br><br><ul><li>  Se o programa for executado em um ambiente com coleta de lixo, essa √© a op√ß√£o que estamos considerando primeiro. </li><li>  Compare o tamanho do heap exibido nas estat√≠sticas do coletor de lixo com o tamanho da mem√≥ria livre gerada pelo sistema operacional.  Se um vazamento se encaixar nessa categoria, os n√∫meros ser√£o compar√°veis ‚Äã‚Äãe, o mais importante, seguir√£o um ao outro ao longo do tempo. </li></ul><br>  <i>Como encontrar um vazamento</i> <br><br>  Use as ferramentas de cria√ß√£o de perfil ou despejo de heap dispon√≠veis em seu ambiente.  Eu sei que h√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">guppy</a> no Python ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">memory_profiler</a> no Ruby, e tamb√©m escrevi o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ObjectSpace</a> diretamente no Ruby. <br><br>  <b>Tipo (3): mem√≥ria livre, mas n√£o utilizada ou inutiliz√°vel</b> <br><br>  Essa categoria √© mais dif√≠cil de caracterizar, mas √© precisamente a mais importante para entender e levar em conta. <br><br>  Vazamentos desse tipo ocorrem na zona cinza, entre a mem√≥ria, que √© considerada "livre" do ponto de vista do alocador dentro da VM ou no ambiente de tempo de execu√ß√£o, e a mem√≥ria, que √© "livre" do ponto de vista do sistema operacional.  A raz√£o mais comum (mas n√£o a √∫nica) para esse fen√¥meno √© a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fragmenta√ß√£o da pilha</a> .  Alguns alocadores simplesmente aceitam e n√£o retornam mem√≥ria ao sistema operacional depois que ele foi alocado. <br><br>  Um caso desse tipo pode ser considerado com um exemplo de um programa curto escrito em Python: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> guppy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> hpy hp = hpy() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rss</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">4096</span></span> * int(open(<span class="hljs-string"><span class="hljs-string">'/proc/self/stat'</span></span>).read().split(<span class="hljs-string"><span class="hljs-string">' '</span></span>)[<span class="hljs-number"><span class="hljs-number">23</span></span>]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gcsize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hp.heap().size rss0, gc0 = (rss(), gcsize()) buf = [bytearray(<span class="hljs-number"><span class="hljs-number">1024</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">200</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>)] print(<span class="hljs-string"><span class="hljs-string">"start rss={} gcsize={}"</span></span>.format(rss()-rss0, gcsize()-gc0)) buf = buf[::<span class="hljs-number"><span class="hljs-number">2</span></span>] print(<span class="hljs-string"><span class="hljs-string">"end rss={} gcsize={}"</span></span>.format(rss()-rss0, gcsize()-gc0))</code> </pre> <br>  Alocamos 200.000 buffers de 1 kb e salvamos cada subsequente.  A cada segundo, exibimos o estado da mem√≥ria do ponto de vista do sistema operacional e do ponto de vista do nosso pr√≥prio coletor de lixo Python. <br><br>  No meu laptop, recebo algo assim: <br><br> <code>start rss=232222720 gcsize=11667592 <br> end rss=232222720 gcsize=5769520</code> <br> <br>  Podemos garantir que o Python realmente liberou metade dos buffers, porque o n√≠vel de gcsize caiu quase metade do valor de pico, mas n√£o foi poss√≠vel retornar um byte dessa mem√≥ria ao sistema operacional.  A mem√≥ria liberada permanece acess√≠vel para o mesmo processo Python, mas n√£o para qualquer outro processo nesta m√°quina. <br><br>  Esses fragmentos de mem√≥ria livres, mas n√£o utilizados, podem ser problem√°ticos e inofensivos.  Se um programa Python age dessa maneira e depois aloca um punhado de fragmentos de 1kb, esse espa√ßo √© simplesmente reutilizado e tudo est√° bem. <br><br>  Por√©m, se fiz√©ssemos isso durante a instala√ß√£o inicial e subsequentemente aloc√°ssemos a mem√≥ria ao m√≠nimo, ou se todos os fragmentos alocados subsequentemente tivessem 1,5kb cada e n√£o se ajustassem a esses buffers deixados com anteced√™ncia, toda a mem√≥ria alocada dessa maneira sempre permaneceria ociosa seria desperdi√ßado. <br><br>  Problemas desse tipo s√£o especialmente relevantes em um ambiente espec√≠fico, a saber, em sistemas de servidores com v√°rios processos para trabalhar com linguagens como Ruby ou Python. <br><br>  Digamos que configuramos um sistema no qual: <br><br><ul><li>  Em cada servidor, N trabalhadores de thread √∫nico s√£o usados ‚Äã‚Äãpara atender solicita√ß√µes com compet√™ncia.  Vamos usar N = 10 para precis√£o. </li><li>  Como regra, cada funcion√°rio tem uma quantidade quase constante de mem√≥ria.  Para maior precis√£o, vamos usar 500 MB. </li><li>  Com alguma frequ√™ncia baixa, recebemos solicita√ß√µes que exigem muito mais mem√≥ria que a solicita√ß√£o mediana.  Para maior precis√£o, vamos supor que, uma vez por minuto, recebamos uma solicita√ß√£o, cujo tempo de execu√ß√£o requer adicionalmente 1 GB de mem√≥ria extra e, quando a solicita√ß√£o √© processada, essa mem√≥ria √© liberada. </li></ul><br>  A cada minuto, chega uma solicita√ß√£o "cet√°ceo", cujo processamento confiamos a um dos 10 trabalhadores, por exemplo, aleatoriamente: <code>~random</code> .  Idealmente, durante o processamento dessa solicita√ß√£o, esse funcion√°rio deve alocar 1 GB de RAM e, ap√≥s o t√©rmino do trabalho, devolver essa mem√≥ria ao sistema operacional para que possa ser reutilizada posteriormente.  Para processar solicita√ß√µes de forma ilimitada por esse princ√≠pio, o servidor precisar√° de apenas 10 * 500 MB + 1 GB = 6 GB de RAM. <br><br>  No entanto, vamos supor que, devido √† fragmenta√ß√£o ou por algum outro motivo, a m√°quina virtual nunca possa retornar essa mem√≥ria ao sistema operacional.  Ou seja, a quantidade de RAM necess√°ria para o sistema operacional √© igual √† maior quantidade de mem√≥ria que voc√™ precisa alocar por vez.  Nesse caso, quando um funcion√°rio espec√≠fico atende a uma solicita√ß√£o que consome muitos recursos, a √°rea ocupada por esse processo na mem√≥ria inchar√° para sempre por um gigabyte inteiro. <br><br>  Quando voc√™ inicia o servidor, ver√° que a quantidade de mem√≥ria usada √© 10 * 500MB = 5GB.  Assim que a primeira grande solicita√ß√£o chega, o primeiro trabalhador ocupa 1 GB de mem√≥ria e n√£o a devolve.  A quantidade total de mem√≥ria usada aumentar√° para 6 GB.  As seguintes solicita√ß√µes de entrada podem ocasionalmente ser redirecionadas para o processo que processou a ‚Äúbaleia‚Äù anteriormente; nesse caso, a quantidade de mem√≥ria usada n√£o ser√° alterada.  √Äs vezes, por√©m, uma solicita√ß√£o t√£o grande √© entregue a outro funcion√°rio, por causa do qual a mem√≥ria √© inflada por mais 1 GB e assim sucessivamente at√© que cada funcion√°rio tenha a oportunidade de processar uma solicita√ß√£o t√£o grande pelo menos uma vez.  Nesse caso, voc√™ ter√° at√© 10 * (500 MB + 1 GB) = 15 GB de RAM com essas opera√ß√µes, o que √© muito mais do que os 6 GB ideais!  Al√©m disso, se voc√™ considerar como a frota de servidores √© usada ao longo do tempo, poder√° ver como a quantidade de mem√≥ria usada aumenta gradualmente de 5 GB para 15 GB, o que lembrar√° muito um vazamento "real". <br><br>  <i>Como determinar se um vazamento pertence a esta categoria</i> <br><br><ul><li>  Compare o tamanho do heap exibido nas estat√≠sticas do coletor de lixo com o tamanho da mem√≥ria livre gerada pelo sistema operacional.  Se o vazamento pertencer a esta (terceira) categoria, os n√∫meros divergir√£o ao longo do tempo. </li><li>  Gosto de configurar meus servidores de aplicativos para que esses dois n√∫meros se afastem periodicamente da infraestrutura de s√©ries temporais, por isso √© conveniente exibir gr√°ficos neles. </li><li>  No Linux, visualize o status do sistema operacional no campo 24 de <code>/proc/self/stat</code> e visualize o alocador de mem√≥ria por meio de uma API espec√≠fica de linguagem ou m√°quina virtual. </li></ul><br>  <i>Como encontrar um vazamento</i> <br><br>  Como j√° mencionado, essa categoria √© um pouco mais insidiosa do que as anteriores, pois o problema geralmente surge mesmo quando todos os componentes funcionam "como pretendido".  No entanto, existem v√°rios truques √∫teis para ajudar a mitigar ou reduzir o impacto de tais "vazamentos virtuais": <br><br><ul><li>  Reinicie seus processos com mais frequ√™ncia.  Se o problema crescer lentamente, talvez n√£o seja dif√≠cil reiniciar todos os processos de aplicativos uma vez a cada 15 minutos ou uma vez por hora. </li><li>  Uma abordagem ainda mais radical: voc√™ pode ensinar todos os processos a reiniciarem independentemente, assim que o espa√ßo que eles ocupam na mem√≥ria exceder um determinado valor limite ou aumentar por um valor predeterminado.  No entanto, tente prever que toda a sua frota de servidores n√£o possa iniciar uma reinicializa√ß√£o s√≠ncrona espont√¢nea. </li><li>  Mude o alocador de mem√≥ria.  A longo prazo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tcmalloc</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">jemalloc</a> geralmente lidam com a fragmenta√ß√£o muito melhor que o alocador padr√£o, e experimentar com eles √© muito conveniente usando a vari√°vel <code>LD_PRELOAD</code> . </li><li>  Descubra se voc√™ possui consultas individuais que consomem muito mais mem√≥ria que o restante.  No Stripe, nossos servidores de API medem o RSS (consumo constante de mem√≥ria) antes e depois de atender a cada solicita√ß√£o de API e registram o delta.  Em seguida, consultamos com facilidade nossos sistemas de agrega√ß√£o de logs para determinar se existem terminais e usu√°rios (e padr√µes) que podem ser usados ‚Äã‚Äãpara amortizar surtos de consumo de mem√≥ria. </li><li>  Ajuste o coletor de lixo / alocador de mem√≥ria.  Muitos deles possuem par√¢metros personaliz√°veis ‚Äã‚Äãque permitem especificar com que intensidade esse mecanismo retornar√° mem√≥ria ao sistema operacional, como otimizado para eliminar a fragmenta√ß√£o;  existem outras op√ß√µes √∫teis.  Tudo aqui tamb√©m √© bastante complicado: entenda exatamente o que voc√™ est√° medindo e otimizando e tente encontrar um especialista na m√°quina virtual apropriada e consulte-o. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt432072/">https://habr.com/ru/post/pt432072/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt432060/index.html">As melhores maneiras de memorizar palavras em ingl√™s</a></li>
<li><a href="../pt432062/index.html">Desenvolvimento de IA usando o exemplo do jogo Dicey Dungeons</a></li>
<li><a href="../pt432064/index.html">Como escapar das lebres. Instru√ß√£o UV</a></li>
<li><a href="../pt432068/index.html">Como facilitar o estudo do ingl√™s: 5 servi√ßos √∫teis</a></li>
<li><a href="../pt432070/index.html">Brevemente sobre canais redux-saga</a></li>
<li><a href="../pt432074/index.html">Como os jogadores rasgam o pano de realidade Spelunky com espingardas</a></li>
<li><a href="../pt432076/index.html">Fun√ß√£o n√£o reconhecida retarda o programa 5 vezes</a></li>
<li><a href="../pt432078/index.html">Tr√°fego no final do t√∫nel ou DNS no pentest</a></li>
<li><a href="../pt432080/index.html">Conceitos equivocados dos jogadores ao avaliar riscos. Controle do gerador de n√∫meros aleat√≥rios em desenvolvimento</a></li>
<li><a href="../pt432082/index.html">Microsoft AI Chatbot lan√ßa cole√ß√£o de roupas na China</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>