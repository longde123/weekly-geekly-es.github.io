<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕵🏿 🖖🏾 😧 “Class-field-proposal” atau “Apa yang salah di tc39 commit” 💞 🥩 🐺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kita semua sudah lama menginginkan enkapsulasi normal dalam JS, yang dapat digunakan tanpa gerakan yang tidak perlu. Kami juga menginginkan konstruksi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>“Class-field-proposal” atau “Apa yang salah di tc39 commit”</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428119/"><p>  Kita semua sudah lama menginginkan enkapsulasi normal dalam JS, yang dapat digunakan tanpa gerakan yang tidak perlu.  Kami juga menginginkan konstruksi yang mudah untuk mendeklarasikan properti kelas.  Dan akhirnya, kami ingin semua fitur dalam bahasa ini muncul sedemikian rupa agar tidak merusak aplikasi yang ada. </p><br><p> Kelihatannya di sini adalah kebahagiaan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kelas-bidang-proposal</a> , yang setelah bertahun-tahun siksaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komite tc39</a> masih sampai ke <code>stage 3</code> dan bahkan mendapatkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">implementasi di chrome</a> . </p><br><p>  Jujur, saya benar-benar ingin menulis artikel tentang mengapa Anda harus menggunakan fitur bahasa baru dan bagaimana melakukannya, tetapi, sayangnya, artikel itu tidak akan membahas hal itu sama sekali. </p><a name="habracut"></a><br><h1 id="opisanie-tekuschego-propozala">  Deskripsi saat ini hilang </h1><br><p>  Saya tidak akan mengulangi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">deskripsi asli</a> , <a href="">FAQ</a> , dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perubahan dalam spesifikasi di sini</a> , tetapi hanya menjelaskan secara singkat poin-poin utama. </p><br><h2 id="polya-klassa">  Bidang kelas </h2><br><p>  Mendeklarasikan bidang dan menggunakannya di dalam kelas: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ x = <span class="hljs-number"><span class="hljs-number">1</span></span>; method() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x); } }</code> </pre> <br><p>  Akses ke bidang di luar kelas: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(ax);</code> </pre> <br><p>  Semuanya tampak jelas dan selama bertahun-tahun kami telah menggunakan sintaks ini menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Babel</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TypeScript</a> . </p><br><p>  Hanya ada nuansa.  Sintaks baru ini menggunakan <code>[[Define]]</code> , dan bukan <code>[[Set]]</code> semantik yang dengannya kita hidup selama ini. </p><br><p>  Dalam praktiknya, ini berarti bahwa kode di atas <strong>tidak sama dengan</strong> ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = <span class="hljs-number"><span class="hljs-number">1</span></span>; } method() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x); } }</code> </pre> <br><p>  Tetapi sebenarnya ini <strong>setara</strong> dengan ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"x"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">writable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }); } method() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x); } }</code> </pre> <br><p>  Dan, meskipun untuk contoh di atas, kedua pendekatan pada dasarnya melakukan hal yang sama, ini adalah perbedaan <strong>SANGAT SERIUS</strong> , dan inilah alasannya: </p><br><p>  Katakanlah kita memiliki kelas induk seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ x = <span class="hljs-number"><span class="hljs-number">1</span></span>; method() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x); } }</code> </pre> <br><p>  Berdasarkan itu, kami membuat yang lain: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ x = <span class="hljs-number"><span class="hljs-number">2</span></span>; }</code> </pre> <br><p>  Dan mereka menggunakannya: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B(); b.method(); <span class="hljs-comment"><span class="hljs-comment">//   2  </span></span></code> </pre> <br><p>  Kemudian, untuk beberapa alasan, kelas <code>A</code> diubah dengan cara yang tampaknya terbelakang: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ _x = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ,   ,        get x() { return this._x; }; set x(val) { return this._x = val; }; method() { console.log(this._x); } }</span></span></code> </pre> <br><p>  Dan untuk semantik <code>[[Set]]</code> , ini benar-benar perubahan yang kompatibel ke belakang, tetapi tidak untuk <code>[[Define]]</code> .  Sekarang panggilan ke <code>b.method()</code> akan ditampilkan ke konsol <code>1</code> bukan <code>2</code> .  Dan ini akan terjadi karena <code>Object.defineProperty</code> mendefinisikan ulang deskriptor properti dan, karenanya, pengambil / penyetel dari kelas <code>A</code> tidak akan dipanggil.  Bahkan, di kelas anak, kami <em>mengaburkan</em> properti <code>x</code> dari orang tua, mirip dengan bagaimana kita bisa melakukan ini dalam lingkup leksikal: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">2</span></span>; }</code> </pre> <br><p>  Benar, dalam hal ini, linter dengan aturan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>no-shadowed-variable</code></a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>no-shadow</code></a> akan menyelamatkan kita, tetapi kemungkinan seseorang akan membuat <code>no-shadowed-class-field</code> cenderung nol. </p><br><blockquote>  Ngomong-ngomong, saya akan berterima kasih untuk istilah Rusia yang lebih sukses karena <code>shadowed</code> . </blockquote><p>  Terlepas dari semua hal di atas, saya bukan lawan semantik baru yang tidak dapat diterima (walaupun saya lebih suka yang lain), karena memiliki aspek positifnya sendiri.  Tapi, sayangnya, nilai tambah ini tidak melebihi minus yang paling penting - kami telah menggunakan semantik <code>[[Set]]</code> selama bertahun-tahun, karena ini digunakan dalam <code>babel6</code> dan <code>TypeScript</code> secara default. </p><br><blockquote>  Benar, perlu dicatat bahwa dalam <code>babel7</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">default telah diubah</a> . </blockquote><p>  Lebih banyak diskusi orisinal tentang topik ini dapat dibaca di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><h2 id="privatnye-polya">  Bidang pribadi </h2><br><p>  Dan sekarang kita akan beralih ke bagian paling kontroversial dari yang satu ini.  Sangat kontroversial sehingga: </p><br><ol><li>  Terlepas dari kenyataan bahwa itu sudah diterapkan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Chrome Canary</a> dan bidang publik sudah diaktifkan secara default, bidang pribadi masih di belakang bendera; </li><li>  Terlepas dari kenyataan bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">prozal awal untuk bidang pribadi</a> digabungkan dengan yang saat ini, permintaan masih dibuat untuk pemisahan kedua fitur ini (misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tiga</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">empat</a> ); </li><li>  bahkan beberapa anggota komite (seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Allen Wirfs-Brock</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kevin Smith</a> ) berbicara dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menawarkan alternatif</a> , meskipun ada <strong>stage3</strong> ; </li><li>  ini melewatkan satu set rekor untuk jumlah masalah - <strong>129</strong> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori saat ini</a> + <strong>96</strong> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aslinya</a> , versus <strong>126</strong> untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BigInt</a> , dan pemegang catatan sebagian besar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komentar negatif</a> ; </li><li>  Saya harus membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">utas terpisah</a> dengan upaya untuk merangkum semua klaim yang menentangnya; </li><li>  Saya harus menulis <a href="">FAQ terpisah</a> yang mencakup bagian ini <br><blockquote>  Namun, karena argumen yang agak lemah, diskusi seperti itu muncul ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua</a> ) <br></blockquote></li><li>  Saya, secara pribadi, menghabiskan semua waktu luang saya (dan kadang-kadang bekerja) untuk jangka waktu yang lama untuk mencari tahu segalanya dan bahkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menemukan penjelasan</a> mengapa dia seperti itu atau menawarkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alternatif yang cocok</a> ; </li><li>  pada akhirnya, saya memutuskan untuk menulis artikel ulasan ini. </li></ol><br><p>  Bidang pribadi dinyatakan sebagai berikut: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ #priv; }</code> </pre> <br><p>  Dan akses ke mereka adalah sebagai berikut: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ #priv = <span class="hljs-number"><span class="hljs-number">1</span></span>; method() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.#priv); } }</code> </pre> <br><p>  Saya bahkan tidak akan mengangkat topik bahwa model mental di balik ini tidak terlalu intuitif ( <code>this.#priv !== this['#priv']</code> ), tidak menggunakan kata-kata <code>private</code> / <code>protected</code> sudah dipesan (yang tentunya akan menyebabkan rasa sakit tambahan untuk pengembang TypeScript), tidak jelas bagaimana memperluasnya untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengubah akses lainnya</a> , dan sintaksisnya sendiri tidak terlalu indah.  Meskipun semua ini adalah alasan asli yang mendorong saya untuk belajar lebih dalam dan berpartisipasi dalam diskusi. </p><br><p>  Ini semua berhubungan dengan sintaksis, di mana preferensi estetika subyektif sangat kuat.  Dan seseorang dapat hidup dengannya dan terbiasa dengannya seiring waktu.  Jika bukan karena satu hal: ada masalah semantik yang sangat signifikan ... </p><br><h3 id="cemantika-weakmap">  Semantics <code>WeakMap</code> </h3><br><p>  Mari kita lihat apa yang ada di balik proposisi yang ada.  Kita dapat menulis ulang contoh di atas dengan enkapsulasi dan tanpa menggunakan sintaks baru, tetapi mempertahankan semantik dari yang sekarang: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> privatesForA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">WeakMap</span></span>(); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { privatesForA.set(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, {}); privatesForA.get(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).priv = <span class="hljs-number"><span class="hljs-number">1</span></span>; } method() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(privatesForA.get(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).priv); } }</code> </pre> <br><blockquote>  Ngomong-ngomong, berdasarkan semantik ini, salah satu anggota komite bahkan membangun <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan utilitas</a> kecil yang memungkinkan Anda untuk menggunakan negara swasta sekarang, untuk menunjukkan bahwa fungsi seperti itu terlalu dibesar-besarkan oleh komite.  Kode yang diformat hanya membutuhkan 27 baris. </blockquote><p>  Secara umum, semuanya cukup baik, kita mendapatkan <code>hard-private</code> , yang tidak dapat diperoleh / dicegat / dilacak dengan cara apa pun dari kode eksternal, dan pada saat yang sama kita dapat mengakses bidang pribadi dari instance lain dari kelas yang sama, misalnya seperti ini: </p><br><pre> <code class="javascript hljs">isEquals(obj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> privatesForA.get(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).id === privatesForA.get(obj).id; }</code> </pre> <br><p>  Yah, ini sangat mudah, kecuali untuk fakta bahwa semantik ini, selain enkapsulasi itu sendiri, juga mencakup <code>brand-checking</code> (Anda tidak dapat mengetahui apa itu Google - Anda tidak mungkin menemukan informasi yang relevan). <br>  <code>brand-checking</code> adalah kebalikan dari <code>duck-typing</code> , dalam arti bahwa itu tidak memeriksa antarmuka publik objek, tetapi fakta bahwa objek itu dibangun menggunakan kode tepercaya. <br>  Cek semacam itu, pada kenyataannya, memiliki cakupan tertentu - ini terutama terkait dengan keamanan memanggil kode yang tidak dipercaya dalam ruang alamat tunggal dengan yang dipercaya dan kemampuan untuk bertukar objek secara langsung tanpa serialisasi. </p><br><blockquote>  Meskipun beberapa insinyur menganggap ini bagian penting dari enkapsulasi yang tepat. </blockquote><p>  Terlepas dari kenyataan bahwa ini adalah kesempatan yang agak aneh, yang terkait erat dengan pola <code></code> (deskripsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pendek</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lebih panjang</a> ), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">propaganda <code>Realms</code></a> dan karya ilmiah di bidang Ilmu Komputer, di mana <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mark Samuel Miller</a> (dia juga anggota komite) terlibat, dalam pengalaman saya , dalam praktik kebanyakan pengembang, ini hampir tidak pernah terjadi. </p><br><blockquote>  Kebetulan, saya masih menemukan membran (meskipun saya tidak tahu apa itu) ketika saya menulis ulang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">vm2 agar</a> sesuai dengan kebutuhan saya. </blockquote><br><h3 id="problema-brand-checking">  Masalah <code>brand-checking</code> </h3><br><p>  Seperti disebutkan sebelumnya, <code>brand-checking</code> adalah kebalikan dari <code>duck-typing</code> .  Dalam praktiknya, ini berarti memiliki kode ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> brands = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">WeakMap</span></span>(); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { brands.set(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, {}); } method() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } brandCheckedMethod() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!brands.has(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-string"><span class="hljs-string">'Brand-check failed'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.method()); } }</code> </pre> <br><p>  <code>brandCheckedMethod</code> hanya bisa dipanggil dengan instance dari kelas <code>A</code> dan bahkan jika target adalah objek yang mempertahankan invarian dari kelas ini, metode ini akan mengeluarkan pengecualian: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> duckTypedObj = { <span class="hljs-attr"><span class="hljs-attr">method</span></span>: A.prototype.method.bind(duckTypedObj), <span class="hljs-attr"><span class="hljs-attr">brandCheckedMethod</span></span>: A.prototype.brandCheckedMethod.bind(duckTypedObj), }; duckTypedObj.method(); <span class="hljs-comment"><span class="hljs-comment">//        1 duckTypedObj.brandCheckedMethod(); //     </span></span></code> </pre> <br><p>  Jelas, contoh ini cukup sintetik dan penggunaan <code>duckTypedObj</code> seperti ini diragukan, sampai kita berpikir tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Proxy</code></a> . <br>  Salah satu skenario penggunaan proxy yang sangat penting adalah metaprogramming.  Agar proxy dapat melakukan semua pekerjaan bermanfaat yang diperlukan, metode objek yang dibungkus menggunakan proxy harus dieksekusi dalam konteks proxy, dan bukan dalam konteks target, yaitu: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> proxy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>(a, { get(target, p, receiver) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> property = <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.get(target, p, receiver); doSomethingUseful(<span class="hljs-string"><span class="hljs-string">'get'</span></span>, retval, target, p, receiver); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> property === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) ? property.bind(proxy) : property; } });</code> </pre> <br><p>  Panggil <code>proxy.method();</code>  akan melakukan pekerjaan yang bermanfaat yang dinyatakan dalam proxy dan mengembalikan <code>1</code> , sambil memanggil <code>proxy.brandCheckedMethod();</code>  alih-alih melakukan pekerjaan yang bermanfaat dua kali dari proksi, itu akan mengeluarkan pengecualian, karena <code>a !== proxy</code> , yang berarti <code>brand-check</code> tidak lulus. </p><br><p>  Ya, kami dapat menjalankan metode / fungsi dalam konteks target nyata, bukan proxy, dan untuk beberapa skenario ini cukup (misalnya, untuk menerapkan pola <code></code> ), tetapi ini tidak cukup untuk semua kasus (misalnya, untuk menerapkan properti reaktif: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MobX 5</a> sudah menggunakan proxy untuk ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vue.js</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aurelia sedang</a> bereksperimen dengan pendekatan ini untuk rilis di masa mendatang). </p><br><p>  Secara umum, selama <code>brand-check</code> perlu dilakukan secara eksplisit, ini bukan masalah - pengembang hanya perlu memutuskan trade-off yang dibuatnya dan apakah ia membutuhkannya, apalagi, dalam hal <code>brand-check</code> secara eksplisit <code>brand-check</code> Anda dapat menerapkannya sedemikian rupa sehingga kesalahan tidak akan terjadi pada proksi tepercaya. </p><br><p>  Sayangnya, yang sekarang telah merampas fleksibilitas kami: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ #priv; method() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.#priv; <span class="hljs-comment"><span class="hljs-comment">//    brand-check   } }</span></span></code> </pre> <br><p>  <code>method</code> seperti itu akan selalu melemparkan pengecualian jika tidak dipanggil dalam konteks objek yang dibangun menggunakan konstruktor <code>A</code>  Dan bagian terburuknya adalah <code>brand-check</code> tersirat di sini dan dicampur dengan fungsi lain - enkapsulasi. </p><br><p>  Meskipun <code></code> hampir diperlukan untuk kode apa pun, <code>brand-check</code> memiliki cakupan yang agak sempit.  Dan menggabungkannya menjadi satu sintaks akan mengarah pada fakta bahwa banyak <code>brand-check</code> tidak disengaja muncul dalam kode pengguna, ketika pengembang hanya bermaksud menyembunyikan detail implementasi. <br>  Dan slogan yang digunakan untuk mempromosikan ini adalah <code># is the new _</code> hanya memperburuk situasi. </p><br><blockquote>  Anda juga dapat membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diskusi terperinci tentang bagaimana prozal yang ada memecah proxy</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Salah satu pengembang</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penulis</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aurelia</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vue.js berbicara dalam diskusi</a> . <br><br>  Juga, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komentar saya</a> , yang menjelaskan secara lebih rinci perbedaan antara skenario proksi yang berbeda, mungkin tampak menarik bagi seseorang.  Secara keseluruhan, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seluruh diskusi tentang koneksi bidang pribadi dan membran</a> . </blockquote><br><h1 id="alternativy">  Alternatif </h1><br><p>  Semua diskusi ini tidak masuk akal jika tidak ada alternatif.  Sayangnya, tidak ada satu pun pengganti yang ada di <strong>stage1</strong> , dan, sebagai hasilnya, bahkan tidak memiliki kesempatan untuk dikerjakan cukup.  Namun, saya akan mendaftar di sini alternatif yang entah bagaimana menyelesaikan masalah yang dijelaskan di atas. </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>Symbol.private</strong></a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>prozazil</strong></a> alternatif salah satu anggota komite. <br><ol><li>  Ini menyelesaikan semua masalah di atas (walaupun mungkin memiliki masalahnya sendiri, tetapi, mengingat kurangnya pekerjaan aktif di sana, sulit untuk menemukannya) </li><li>  sekali lagi dilemparkan kembali pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertemuan terakhir komite</a> karena kurangnya pemeriksaan <code>brand-check</code> terintegrasi, masalah dengan pola membran (meskipun <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> + <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> menawarkan solusi yang memadai) dan kurangnya sintaksis yang mudah digunakan </li><li>  Sintaks yang mudah digunakan dapat dibangun di atas yang sebenarnya, seperti yang saya tunjukkan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di sini</a> </li></ol></li><li>  <a href=""><strong>Kelas 1.1</strong></a> - posozal sebelumnya dari penulis yang sama </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>Menggunakan <em>pribadi</em> sebagai objek</strong></a> </li></ol><br><h1 id="vmesto-zaklyucheniya">  Alih-alih sebuah kesimpulan </h1><br><p>  Dengan nada artikel itu, mungkin kelihatannya saya mengutuk komite - ini tidak benar.  Menurut saya, selama bertahun-tahun (tergantung pada apa titik awalnya, bahkan mungkin beberapa dekade) bahwa komite bekerja pada enkapsulasi di JS, banyak hal dalam industri telah berubah, dan tampilan dapat dikaburkan, yang menyebabkan peringkat prioritas yang salah . </p><br><p>  Selain itu, kami, sebagai komunitas, <strong>mendorong tc39 yang</strong> memaksa mereka untuk merilis fitur lebih cepat, sementara kami memberikan umpan balik yang sangat sedikit di tahap awal prozos, menurunkan kemarahan kami hanya pada saat ketika sedikit yang dapat diubah. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Diyakini</a> bahwa dalam kasus ini, prosesnya gagal. </p><br><p>  Setelah memasukkannya ke dalam kepala saya dan berbicara dengan beberapa perwakilan, saya memutuskan bahwa saya akan melakukan yang terbaik untuk mencegah terulangnya situasi yang sama - tetapi saya dapat melakukan sedikit (menulis artikel ulasan, melakukan implementasi <code>stage1</code> hilang dalam <code>babel</code> dan itu saja). </p><br><p>  Tetapi yang paling penting adalah umpan balik - jadi saya akan meminta Anda untuk mengambil bagian dalam survei kecil ini.  Dan saya, pada gilirannya, akan mencoba menyampaikannya kepada komite. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id428119/">https://habr.com/ru/post/id428119/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id428109/index.html">Tembok perusahaan</a></li>
<li><a href="../id428111/index.html">Aritmatika presisi sewenang-wenang di Erlang</a></li>
<li><a href="../id428113/index.html">Untuk pertanyaan tentang kurva Bezier, kecepatan Arduino dan satu situs menarik, atau bagaimana saya menghabiskan akhir pekan</a></li>
<li><a href="../id428115/index.html">Pengembangan web untuk e-niaga: 5 tren teknologi untuk 2019</a></li>
<li><a href="../id428117/index.html">Prosesor tensor gratis dari Google di Colaboratory Cloud</a></li>
<li><a href="../id428121/index.html">Stan Drapkin. Perangkap Kriptografi Tingkat Tinggi di .NET</a></li>
<li><a href="../id428123/index.html">Minggu Keamanan 41: Kabar Baik</a></li>
<li><a href="../id428125/index.html">Siapa analitik produk dan mengapa mereka diperlukan dalam sebuah tim?</a></li>
<li><a href="../id428127/index.html">Cache nginx: semuanya baru - lama terlupakan</a></li>
<li><a href="../id428129/index.html">Logika fuzzy sederhana saling menempel “dari apa dulu” untuk mesin turbin gas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>