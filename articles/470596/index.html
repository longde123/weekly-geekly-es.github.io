<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚óæÔ∏è üÉè üõèÔ∏è Caracter√≠sticas de Q y KDB + en el ejemplo de un servicio en tiempo real üöä üëåüèø ‚õπüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Qu√© es KDB +, el lenguaje de programaci√≥n Q, cu√°les son sus fortalezas y debilidades, se pueden encontrar en mi art√≠culo anterior y brevemente en la i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Caracter√≠sticas de Q y KDB + en el ejemplo de un servicio en tiempo real</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dbtc/blog/470596/">  Qu√© es KDB +, el lenguaje de programaci√≥n Q, cu√°les son sus fortalezas y debilidades, se pueden encontrar en mi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo</a> anterior y brevemente en la introducci√≥n.  En el art√≠culo, implementamos un servicio en Q que procesar√° el flujo de datos entrantes y calcular√° por minuto varias funciones de agregaci√≥n en el modo "en tiempo real" (es decir, lograr√° contar todo hasta el siguiente dato).  La caracter√≠stica principal de Q es que es un lenguaje vectorial que le permite operar no con objetos individuales, sino con sus matrices, matrices de matrices y otros objetos complejos.  Idiomas como Q y sus K, J, APL relacionados son famosos por su brevedad.  A menudo, un programa que abarca varias pantallas de c√≥digo en un lenguaje familiar como Java puede escribirse en ellas en varias l√≠neas.  Esto es exactamente lo que quiero demostrar en este art√≠culo. <br><br><img src="https://habrastorage.org/webt/wb/ej/zy/wbejzyzkg_-aypnh92it6kecrtq.jpeg"><br><a name="habracut"></a><br><h3>  Introduccion </h3><br>  KDB + es una base de datos de columnas enfocada en grandes vol√∫menes de datos, ordenados de cierta manera (principalmente por tiempo).  Se utiliza, en primer lugar, en organizaciones financieras: bancos, fondos de inversi√≥n, compa√±√≠as de seguros.  El lenguaje Q es un lenguaje interno de KDB + que le permite trabajar eficazmente con estos datos.  La ideolog√≠a de Q es brevedad y eficiencia, mientras que se sacrifica la claridad.  Esto se justifica por el hecho de que, en cualquier caso, el lenguaje vectorial ser√° dif√≠cil de percibir, y la brevedad y riqueza de la grabaci√≥n le permite ver una parte mucho m√°s grande del programa en una pantalla, lo que en √∫ltima instancia facilita su comprensi√≥n. <br><br>  En este art√≠culo, estamos implementando un programa Q completo y es posible que desee probarlo.  Para hacer esto, necesitar√° la Q real. Puede descargar la versi√≥n gratuita de 32 bits en el sitio web de la compa√±√≠a kx: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">www.kx.com</a> .  En el mismo lugar, si est√° interesado, encontrar√° informaci√≥n de referencia sobre Q, el libro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Q For Mortals</a> y varios art√≠culos sobre este tema. <br><br>
<h3>  Declaraci√≥n del problema. </h3><br>  Hay una fuente que env√≠a una tabla de datos cada 25 milisegundos.  Dado que KDB + se usa principalmente en finanzas, suponemos que se trata de una tabla de operaciones en la que existen las siguientes columnas: tiempo (tiempo en milisegundos), sym (nombre de la empresa en el intercambio - <b>IBM</b> , <b>AAPL</b> , ...), precio (precio por el cual se compraron las acciones), tama√±o (tama√±o de la transacci√≥n).  Se elige arbitrariamente un intervalo de 25 milisegundos, no es demasiado peque√±o ni demasiado grande.  Su presencia significa que los datos que llegan al servicio ya est√°n almacenados en el b√∫fer.  Ser√≠a f√°cil implementar el almacenamiento en b√∫fer en el lado del servicio, incluido el almacenamiento en b√∫fer din√°mico, dependiendo de la carga actual, pero por simplicidad nos detenemos en un intervalo fijo. <br><br>  El servicio debe considerar por minuto para cada car√°cter entrante de la columna sym un conjunto de funciones de agregaci√≥n: precio m√°ximo, precio promedio, tama√±o de suma, etc.  informaci√≥n √∫til  Para simplificar, asumimos que todas las funciones se pueden calcular de forma incremental, es decir  Para obtener un nuevo valor, es suficiente conocer dos n√∫meros: el antiguo y el valor entrante.  Por ejemplo, las funciones max, average, sum tienen esta propiedad, pero la funci√≥n mediana no. <br><br>  Tambi√©n asumimos que el flujo de datos entrantes est√° ordenado por tiempo.  Esto nos dar√° la oportunidad de trabajar solo con el √∫ltimo minuto.  En la pr√°ctica, es suficiente para poder trabajar con los minutos actuales y anteriores en caso de que las actualizaciones lleguen tarde.  Por simplicidad, no consideraremos este caso. <br><br><h3>  Funciones agregadas </h3><br>  A continuaci√≥n se enumeran las funciones agregadas requeridas.  Los tom√© lo m√°s posible para aumentar la carga en el servicio: <br><br><ul><li>  alto - precio m√°ximo - precio m√°ximo por minuto. </li><li>  bajo - precio m√≠nimo - el precio m√≠nimo por minuto. </li><li>  firstPrice - primer precio - el primer precio por minuto. </li><li>  lastPrice - last price - el √∫ltimo precio por minuto. </li><li>  firstSize - primer tama√±o - el primer tama√±o de oferta en un minuto. </li><li>  lastSize - last size - el √∫ltimo tama√±o de oferta en un minuto. </li><li>  numTrades - cuenta i - el n√∫mero de transacciones por minuto. </li><li>  volumen - tama√±o de suma - la suma de los tama√±os de transacci√≥n por minuto. </li><li>  pvolume - precio de suma - la suma de precios por minuto, necesaria para avgPrice. </li><li>  volumen de negocios - precio total * tama√±o - volumen total de transacciones por minuto. </li><li>  avgPrice - pvolume% numTrades - precio promedio por minuto. </li><li>  avgSize - volumen% numTrades - tama√±o promedio de oferta por minuto. </li><li>  vwap - volumen de volumen de negocios% - el precio promedio por minuto ponderado por el tama√±o de la transacci√≥n. </li><li>  cumVolume - volumen de suma - tama√±o de transacci√≥n acumulado para todo el tiempo. </li></ul><br>  Discuta inmediatamente un punto no obvio: c√≥mo inicializar estas columnas por primera vez y para cada minuto siguiente.  Algunas columnas del tipo firstPrice deben inicializarse con nulo cada vez, su valor no est√° definido.  Otros tipos de volumen siempre deben establecerse en 0. Todav√≠a hay columnas que requieren un enfoque combinado; por ejemplo, cumVolume debe copiarse del minuto anterior y para el primer conjunto en 0. Configuraremos todos estos par√°metros usando el diccionario de tipos de datos (an√°logo del registro): <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// list ! list ‚Äì  , 0n ‚Äì float null, 0N ‚Äì long null, `sym ‚Äì  , `sym1`sym2 ‚Äì   initWith:`sym`time`high`low`firstPrice`lastPrice`firstSize`lastSize`numTrades`volume`pvolume`turnover`avgPrice`avgSize`vwap`cumVolume!(`;00:00;0n;0n;0n;0n;0N;0N;0;0;0.0;0.0;0n;0n;0n;0); aggCols:reverse key[initWith] except `sym`time; //    , reverse  </span></span></code> </pre> <br>  Agregu√© sym y time al diccionario por conveniencia, ahora initWith es una l√≠nea terminada de la tabla agregada final, donde queda establecer el sym y el tiempo correctos.  Puede usarlo para agregar nuevas filas a la tabla. <br><br>  aggCols que necesitamos al crear una funci√≥n agregada.  La lista debe invertirse debido a las peculiaridades del orden en que se calculan las expresiones en Q (de derecha a izquierda).  El objetivo es proporcionar un c√°lculo en la direcci√≥n de alto a cumVolume, ya que algunas columnas dependen de las anteriores. <br><br>  Columnas que se copiar√°n a un nuevo minuto del anterior, columna de sym agregada para mayor comodidad: <br><br><pre> <code class="cpp hljs">rollColumns:`sym`cumVolume;</code> </pre><br>  Ahora dividimos las columnas en grupos seg√∫n c√≥mo deben actualizarse.  Se pueden distinguir tres tipos: <br><br><ol><li>  Bater√≠as (volumen, rotaci√≥n, ...): debemos agregar el valor de entrada al anterior. </li><li>  Con un punto especial (alto, bajo, ..): el primer valor en un minuto se toma de los datos de entrada, el resto se cuenta utilizando la funci√≥n. </li><li>  El resto  Siempre se cuenta con una funci√≥n. </li></ol><br>  Defina variables para estas clases: <br><br><pre> <code class="cpp hljs">accumulatorCols:`numTrades`volume`pvolume`turnover; specialCols:`high`low`firstPrice`firstSize;</code> </pre><br><h3>  Orden de c√°lculo </h3><br>  Actualizaremos la tabla agregada en dos etapas.  Para mayor eficiencia, primero reduciremos la tabla entrante para que quede una fila para cada car√°cter y minuto.  El hecho de que todas nuestras funciones sean incrementales y asociativas nos garantiza que el resultado de este paso adicional no cambiar√°.  Puede exprimir la tabla usando select: <br><br><pre> <code class="cpp hljs">select high:max price, low:min price ‚Ä¶ by sym,time.minute from table</code> </pre><br>  Este m√©todo tiene un signo negativo: el conjunto de columnas calculadas est√° predefinido.  Afortunadamente, en Q, la selecci√≥n tambi√©n se implementa como una funci√≥n donde puede sustituir argumentos creados din√°micamente: <br><br><pre> <code class="cpp hljs">?[table;whereClause;byClause;selectClause]</code> </pre><br>  ¬°No describir√© en detalle el formato de los argumentos, en nuestro caso solo las expresiones by y select no son triviales y deber√≠an ser diccionarios de las columnas de formulario! Expresiones.  Por lo tanto, la funci√≥n de constricci√≥n se puede definir como sigue: <br><br><pre> <code class="cpp hljs">selExpression:`high`low`firstPrice`lastPrice`firstSize`lastSize`numTrades`volume`pvolume`turnover!<span class="hljs-function"><span class="hljs-function">parse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">each</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"max price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"min price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"first price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"last price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"first size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"last size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"count i"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"sum size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"sum price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"sum price*size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// each   map  Q    preprocess:?[;();`sym`time!`sym`time.minute;selExpression];</span></span></code> </pre><br>  Para mayor claridad, utilic√© la funci√≥n de an√°lisis, que convierte una cadena con una expresi√≥n Q en un valor que se puede pasar a la funci√≥n eval y que se requiere en la selecci√≥n de funciones.  Tambi√©n tenga en cuenta que el preproceso se define como una proyecci√≥n (es decir, una funci√≥n con argumentos parcialmente definidos) de la funci√≥n de selecci√≥n, falta un argumento (tabla).  Si aplicamos el preproceso a una tabla, obtenemos una tabla reducida. <br><br>  La segunda etapa es actualizar la tabla agregada.  Primero, escribimos el algoritmo en pseudoc√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> each sym in inputTable idx: row index in agg table <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> sym+currentTime; aggTable[idx;`high]: aggTable[idx;`high] | inputTable[sym;`high]; aggTable[idx;`volume]: aggTable[idx;`volume] + inputTable[sym;`volume]; ‚Ä¶</code> </pre><br>  En Q, en lugar de bucles, se acostumbra usar las funciones map / reduce.  Pero dado que Q es un lenguaje vectorial y todas las operaciones que podemos aplicar de manera segura a todos los s√≠mbolos a la vez, entonces, como primera aproximaci√≥n, podemos prescindir de un ciclo, haciendo operaciones con todos los s√≠mbolos a la vez: <br><br><pre> <code class="cpp hljs">idx:calcIdx inputTable; row:aggTable idx; aggTable[idx;`high]: row[`high] | inputTable`high; aggTable[idx;`volume]: row[`volume] + inputTable`volume; ‚Ä¶</code> </pre><br>  Pero podemos ir m√°s all√°, en Q hay un operador √∫nico y extremadamente poderoso: el operador de asignaci√≥n generalizada.  Le permite cambiar el conjunto de valores en una estructura de datos compleja utilizando una lista de √≠ndices, funciones y argumentos.  En nuestro caso, se ve as√≠: <br><br><pre> <code class="cpp hljs">idx:calcIdx inputTable; rows:aggTable idx; <span class="hljs-comment"><span class="hljs-comment">// .[target;(idx0;idx1;..);function;argument] ~ target[idx 0;idx 1;‚Ä¶]: function[target[idx 0;idx 1;‚Ä¶];argument],     ‚Äì   .[aggTable;(idx;aggCols);:;flip (row[`high] | inputTable`high;row[`volume] + inputTable`volume;‚Ä¶)];</span></span></code> </pre><br>  Desafortunadamente, para asignar a una tabla necesita una lista de filas, no columnas, y debe transponer la matriz (lista de columnas en una lista de filas) utilizando la funci√≥n de volteo.  Para una tabla grande, esto es innecesario, por lo que aplicamos la asignaci√≥n generalizada a cada columna por separado, utilizando la funci√≥n de mapa (que parece un ap√≥strofe): <br><br><pre> <code class="sql hljs">.[aggTable;;:;]'[(idx;)each aggCols; (row[`high] | inputTable`high;row[`volume] + inputTable`volume;‚Ä¶)];</code> </pre><br>  Nuevamente usamos la funci√≥n de proyecci√≥n.  Tambi√©n tenga en cuenta que en Q, crear una lista tambi√©n es una funci√≥n y podemos llamarla usando la funci√≥n each (map) para obtener una lista de listas. <br><br>  Para que el conjunto de columnas calculadas no sea fijo, cree la expresi√≥n anterior din√°micamente.  Primero, definimos las funciones para calcular cada columna, usando las variables fila e inp para hacer referencia a datos agregados y de entrada: <br><br><pre> <code class="cpp hljs">aggExpression:`high`low`firstPrice`lastPrice`firstSize`lastSize`avgPrice`avgSize`vwap`cumVolume! (<span class="hljs-string"><span class="hljs-string">"row[`high]|inp`high"</span></span>;<span class="hljs-string"><span class="hljs-string">"row[`low]&amp;inp`low"</span></span>;<span class="hljs-string"><span class="hljs-string">"row`firstPrice"</span></span>;<span class="hljs-string"><span class="hljs-string">"inp`lastPrice"</span></span>;<span class="hljs-string"><span class="hljs-string">"row`firstSize"</span></span>;<span class="hljs-string"><span class="hljs-string">"inp`lastSize"</span></span>;<span class="hljs-string"><span class="hljs-string">"pvolume%numTrades"</span></span>;<span class="hljs-string"><span class="hljs-string">"volume%numTrades"</span></span>;<span class="hljs-string"><span class="hljs-string">"turnover%volume"</span></span>;<span class="hljs-string"><span class="hljs-string">"row[`cumVolume]+inp`volume"</span></span>);</code> </pre><br>  Algunas columnas son especiales; su primer valor no debe ser calculado por una funci√≥n.  Podemos determinar que es el primero en la fila de la columna [`numTrades]; si tiene 0, entonces el valor es el primero.  Q tiene una funci√≥n de selecci√≥n -? [Lista booleana; lista1; lista2] - que selecciona un valor de la lista 1 o 2 dependiendo de la condici√≥n en el primer argumento: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// high -&gt; ?[isFirst;inp`high;row[`high]|inp`high] // @ -         @[`aggExpression;specialCols;{[x;y]"?[isFirst;inp`",y,";",x,"]"};string specialCols];</span></span></code> </pre><br>  Aqu√≠ llam√© una asignaci√≥n gen√©rica con mi funci√≥n (expresi√≥n entre llaves).  Se le pasa el valor actual (el primer argumento) y un argumento adicional, que paso en el cuarto par√°metro. <br><br>  Por separado, agregamos altavoces de bater√≠a, porque para ellos la funci√≥n es la misma: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// volume -&gt; row[`volume]+inp`volume aggExpression[accumulatorCols]:{"row[`",x,"]+inp`",x } each string accumulatorCols;</span></span></code> </pre><br>  Esta es una asignaci√≥n habitual seg√∫n los est√°ndares de Q, solo asigno una lista de valores a la vez.  Finalmente, cree la funci√≥n principal: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ":",/:aggExprs ~ map[{":",x};aggExpr] =&gt; ":row[`high]|inp`high"    ,          // string[cols],'exprs ~ map[,;string[cols];exprs] =&gt; "high:row[`high]|inp`high"   . ,'   map[concat] // ";" sv exprs ‚Äì String from Vector (sv),     ‚Äú;‚Äù  updateAgg:value "{[aggTable;idx;inp] row:aggTable idx; isFirst:0=row`numTrades; .[aggTable;;:;]'[(idx;)each aggCols;(",(";"sv string[aggCols],'":",/:aggExpression aggCols),")]}";</span></span></code> </pre><br>  Con esta expresi√≥n, creo din√°micamente una funci√≥n a partir de una cadena que contiene la expresi√≥n que cit√© anteriormente.  El resultado se ver√° as√≠: <br><br><pre> <code class="sql hljs">{[aggTable;idx;inp] rows:aggTable idx; isFirst:0=row`numTrades; .[aggTable;;:;]'[(idx;)each aggCols ;(cumVolume:row[`cumVolume]+inp`cumVolume;‚Ä¶ ; high:?[isFirst;inp`high;row[`high]|inp`high])]}</code> </pre><br>  El orden de c√°lculo de las columnas se invierte, ya que en Q el orden de c√°lculo es de derecha a izquierda. <br><br>  Ahora tenemos dos funciones principales necesarias para los c√°lculos, queda agregar una peque√±a infraestructura y el servicio est√° listo. <br><br><h3>  Pasos finales </h3><br>  Tenemos funciones de preproceso y actualizaci√≥nAgg que hacen todo el trabajo.  Pero a√∫n es necesario garantizar la transici√≥n correcta en minutos y calcular los √≠ndices de agregaci√≥n.  Primero definimos la funci√≥n init: <br><br><pre> <code class="cpp hljs">init:{ tradeAgg:: <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-meta"><span class="hljs-meta">#enlist[initWith]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//    , enlist    ,  0#   0    currTime::00:00; //   0, :: ,      currSyms::`u#`symbol$(); // `u# -    ,     offset::0; //   tradeAgg,     rollCache:: `sym xkey update `u#sym from rollColumns#tradeAgg; //     roll ,    sym }</span></span></span></span></code> </pre><br>  Tambi√©n definimos la funci√≥n de desplazamiento, que cambiar√° el minuto actual: <br><br><pre> <code class="cpp hljs">roll:{[tm] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>[currTime&gt;tm; :init[]]; <span class="hljs-comment"><span class="hljs-comment">//    ,    init rollCache,::offset _ rollColumns#tradeAgg; //   ‚Äì  roll   aggTable, ,   rollCache offset::count tradeAgg; currSyms::`u#`$(); }</span></span></code> </pre><br>  Necesitamos una funci√≥n para agregar nuevos personajes: <br><br><pre> <code class="java hljs">addSyms:{[syms] currSyms,::syms; <span class="hljs-comment"><span class="hljs-comment">//     //    sym, time  rollColumns   . //  ^      roll ,     . value flip table     . `tradeAgg upsert @[count[syms]#enlist initWith;`sym`time,cols rc;:;(syms;currTime), (initWith cols rc)^value flip rc:rollCache ([] sym: syms)]; }</span></span></code> </pre><br>  Y finalmente, la funci√≥n upd (el nombre tradicional de esta funci√≥n para los servicios Q), que el cliente llama, para agregar datos: <br><br><pre> <code class="cpp hljs">upd:{[tblName;data] <span class="hljs-comment"><span class="hljs-comment">// tblName   ,       tm:exec distinct time from data:() xkey preprocess data; // preprocess &amp; calc time updMinute[data] each tm; //      }; updMinute:{[data;tm] if[tm&lt;&gt;currTime; roll tm; currTime::tm]; //  ,   data:select from data where time=tm; //  if[count msyms:syms where not (syms:data`sym)in currSyms; addSyms msyms]; //   updateAgg[`tradeAgg;offset+currSyms?syms;data]; //   .  ?        . };</span></span></code> </pre><br>  Eso es todo  Aqu√≠ est√° el c√≥digo completo de nuestro servicio, seg√∫n lo prometido, solo unas pocas l√≠neas: <br><br><pre> <code class="cpp hljs">initWith:`sym`time`high`low`firstPrice`lastPrice`firstSize`lastSize`numTrades`volume`pvolume`turnover`avgPrice`avgSize`vwap`cumVolume!(`;<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>N;<span class="hljs-number"><span class="hljs-number">0</span></span>N;<span class="hljs-number"><span class="hljs-number">0</span></span>;<span class="hljs-number"><span class="hljs-number">0</span></span>;<span class="hljs-number"><span class="hljs-number">0.0</span></span>;<span class="hljs-number"><span class="hljs-number">0.0</span></span>;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>); aggCols:reverse key[initWith] except `sym`time; rollColumns:`sym`cumVolume; accumulatorCols:`numTrades`volume`pvolume`turnover; specialCols:`high`low`firstPrice`firstSize; selExpression:`high`low`firstPrice`lastPrice`firstSize`lastSize`numTrades`volume`pvolume`turnover!<span class="hljs-function"><span class="hljs-function">parse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">each</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"max price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"min price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"first price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"last price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"first size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"last size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"count i"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"sum size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"sum price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"sum price*size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; preprocess:?[;();`sym`time!`sym`time.minute;selExpression]; aggExpression:`high`low`firstPrice`lastPrice`firstSize`lastSize`avgPrice`avgSize`vwap`cumVolume!(<span class="hljs-string"><span class="hljs-string">"row[`high]|inp`high"</span></span>;<span class="hljs-string"><span class="hljs-string">"row[`low]&amp;inp`low"</span></span>;<span class="hljs-string"><span class="hljs-string">"row`firstPrice"</span></span>;<span class="hljs-string"><span class="hljs-string">"inp`lastPrice"</span></span>;<span class="hljs-string"><span class="hljs-string">"row`firstSize"</span></span>;<span class="hljs-string"><span class="hljs-string">"inp`lastSize"</span></span>;<span class="hljs-string"><span class="hljs-string">"pvolume%numTrades"</span></span>;<span class="hljs-string"><span class="hljs-string">"volume%numTrades"</span></span>;<span class="hljs-string"><span class="hljs-string">"turnover%volume"</span></span>;<span class="hljs-string"><span class="hljs-string">"row[`cumVolume]+inp`volume"</span></span>); @[`aggExpression;specialCols;{<span class="hljs-string"><span class="hljs-string">"?[isFirst;inp`"</span></span>,y,<span class="hljs-string"><span class="hljs-string">";"</span></span>,x,<span class="hljs-string"><span class="hljs-string">"]"</span></span>};<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> specialCols]; aggExpression[accumulatorCols]:{<span class="hljs-string"><span class="hljs-string">"row[`"</span></span>,x,<span class="hljs-string"><span class="hljs-string">"]+inp`"</span></span>,x } each <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> accumulatorCols; updateAgg:value <span class="hljs-string"><span class="hljs-string">"{[aggTable;idx;inp] row:aggTable idx; isFirst:0=row`numTrades; .[aggTable;;:;]'[(idx;)each aggCols;("</span></span>,(<span class="hljs-string"><span class="hljs-string">";"</span></span>sv <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[aggCols],<span class="hljs-string"><span class="hljs-string">'":",/:aggExpression aggCols),")]}"; / '</span></span> init:{ tradeAgg::<span class="hljs-number"><span class="hljs-number">0</span></span>#enlist[initWith]; currTime::<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>; currSyms::`u#`symbol$(); offset::<span class="hljs-number"><span class="hljs-number">0</span></span>; rollCache:: `sym xkey update `u#sym from rollColumns#tradeAgg; }; roll:{[tm] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>[currTime&gt;tm; :init[]]; rollCache,::offset _ rollColumns#tradeAgg; offset::count tradeAgg; currSyms::`u#`$(); }; addSyms:{[syms] currSyms,::syms; `tradeAgg upsert @[count[syms]#enlist initWith;`sym`time,cols rc;:;(syms;currTime),(initWith cols rc)^value flip rc:rollCache ([] sym: syms)]; }; upd:{[tblName;data] updMinute[data] each exec distinct time from data:() xkey preprocess data}; updMinute:{[data;tm] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>[tm&lt;&gt;currTime; roll tm; currTime::tm]; data:select from data where time=tm; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>[count msyms:syms where <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> (syms:data`sym)in currSyms; addSyms msyms]; updateAgg[`tradeAgg;offset+currSyms?syms;data]; };</code> </pre><br><h3>  Prueba </h3><br>  Verifique el desempe√±o del servicio.  Para hacer esto, ejec√∫telo en un proceso separado (coloque el c√≥digo en el archivo service.q) y llame a la funci√≥n init: <br><br><pre> <code class="plaintext hljs">q service.q ‚Äìp 5566 q)init[]</code> </pre><br>  En otra consola, inicie el segundo proceso Q y con√©ctese al primero: <br><br><pre> <code class="cpp hljs">h:hopen `:host:<span class="hljs-number"><span class="hljs-number">5566</span></span> h:hopen <span class="hljs-number"><span class="hljs-number">5566</span></span> <span class="hljs-comment"><span class="hljs-comment">//     </span></span></code> </pre><br>  Primero, cree una lista de caracteres: 10,000 piezas y agregue una funci√≥n para crear una tabla aleatoria.  En la segunda consola: <br><br><pre> <code class="cpp hljs">syms:`IBM`AAPL`GOOG,<span class="hljs-number"><span class="hljs-number">-9997</span></span>?`<span class="hljs-number"><span class="hljs-number">8</span></span> rnd:{[n;t] ([] sym:n?syms; time:t+asc n#til <span class="hljs-number"><span class="hljs-number">25</span></span>; price:n?<span class="hljs-number"><span class="hljs-number">10f</span></span>; size:n?<span class="hljs-number"><span class="hljs-number">10</span></span>)}</code> </pre><br>  Agregu√© tres caracteres reales a la lista de caracteres para que sea m√°s conveniente buscarlos en la tabla.  La funci√≥n rnd crea una tabla aleatoria con n filas, donde el tiempo var√≠a de t a t + 25 milisegundos. <br><br>  Ahora puede intentar enviar datos al servicio (agregue las primeras diez horas): <br><br><pre> <code class="cpp hljs">{h (`upd;`trade;rnd[<span class="hljs-number"><span class="hljs-number">10000</span></span>;x])} each `time$<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span> + til <span class="hljs-number"><span class="hljs-number">60</span></span>*<span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br>  Puede verificar en el servicio que la tabla ha sido actualizada: <br><br><pre> <code class="cpp hljs">\c <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> select from tradeAgg where sym=`AAPL <span class="hljs-number"><span class="hljs-number">-20</span></span>#select from tradeAgg where sym=`AAPL</code> </pre><br>  Resultado: <br><br><pre> <code class="1c hljs">sym<span class="hljs-string"><span class="hljs-string">|time|high|low|firstPrice|lastPrice|firstSize|lastSize|numTrades|volume|pvolume|turnover|avgPrice|avgSize|vwap|cumVolume --|--|--|--|--|-------------------------------- AAPL|09:27|9.258904|9.258904|9.258904|9.258904|8|8|1|8|9.258904|74.07123|9.258904|8|9.258904|2888 AAPL|09:28|9.068162|9.068162|9.068162|9.068162|7|7|1|7|9.068162|63.47713|9.068162|7|9.068162|2895 AAPL|09:31|4.680449|0.2011121|1.620827|0.2011121|1|5|4|14|9.569556|36.84342|2.392389|3.5|2.631673|2909 AAPL|09:33|2.812535|2.812535|2.812535|2.812535|6|6|1|6|2.812535|16.87521|2.812535|6|2.812535|2915 AAPL|09:34|5.099025|5.099025|5.099025|5.099025|4|4|1|4|5.099025|20.3961|5.099025|4|5.099025|2919</span></span></code> </pre> <br>  Ahora realizaremos pruebas de carga para averiguar cu√°ntos datos puede procesar el servicio por minuto.  Perm√≠tame recordarle que establecemos el intervalo para las actualizaciones en 25 milisegundos.  En consecuencia, un servicio deber√≠a (en promedio) caber en al menos 20 milisegundos por actualizaci√≥n para dar a los usuarios tiempo para solicitar datos.  Ingrese lo siguiente en el segundo proceso: <br><br><pre> <code class="cpp hljs">tm:<span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.000</span></span> stressTest:{[n] <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[tm],<span class="hljs-string"><span class="hljs-string">" "</span></span>; times,::h ({st:.zT; upd[`trade;x]; .zT-st};rnd[n;tm]); tm+:<span class="hljs-number"><span class="hljs-number">25</span></span>} start:{[n] times::(); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>[<span class="hljs-number"><span class="hljs-number">4800</span></span>;stressTest[n]]; <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-string"><span class="hljs-string">" "</span></span>; `min`avg`med`max!(min times;avg times;med times;max times)}</code> </pre><br>  4800 son dos minutos.  Puede intentar comenzar primero por 1000 l√≠neas cada 25 milisegundos: <br><br><pre> <code class="cpp hljs">start <span class="hljs-number"><span class="hljs-number">1000</span></span></code> </pre><br>  En mi caso, el resultado es alrededor de un par de milisegundos por actualizaci√≥n.  As√≠ que aumentar√© inmediatamente el n√∫mero de filas a 10.000: <br><br><pre> <code class="cpp hljs">start <span class="hljs-number"><span class="hljs-number">10000</span></span></code> </pre><br>  Resultado: <br><br><pre> <code class="cpp hljs">min| <span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.004</span></span> avg| <span class="hljs-number"><span class="hljs-number">9.191458</span></span> med| <span class="hljs-number"><span class="hljs-number">9f</span></span> max| <span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.030</span></span></code> </pre><br>  De nuevo, nada especial, pero esto es 24 millones de l√≠neas por minuto, 400 mil por segundo.  Durante m√°s de 25 milisegundos, la actualizaci√≥n se ralentiz√≥ solo 5 veces, aparentemente al cambiar el minuto.  Incremento a 100,000: <br><br><pre> <code class="cpp hljs">start <span class="hljs-number"><span class="hljs-number">100000</span></span></code> </pre><br>  Resultado: <br><br><pre> <code class="cpp hljs">min| <span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.013</span></span> avg| <span class="hljs-number"><span class="hljs-number">25.11083</span></span> med| <span class="hljs-number"><span class="hljs-number">24f</span></span> max| <span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.108</span></span> q)sum times <span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">02</span></span>:<span class="hljs-number"><span class="hljs-number">00.532</span></span></code> </pre><br>  Como puede ver, el servicio apenas se las arregla, pero sin embargo logra mantenerse a flote.  Esta cantidad de datos (240 millones de l√≠neas por minuto) es extremadamente grande, en tales casos se acostumbra ejecutar varios clones (o incluso docenas de clones) del servicio, cada uno de los cuales procesa solo una parte de los caracteres.  Sin embargo, el resultado es impresionante para el lenguaje interpretado, que se centra principalmente en el almacenamiento de datos. <br><br>  Puede surgir la pregunta de por qu√© el tiempo crece de forma no lineal con el tama√±o de cada actualizaci√≥n.  La raz√≥n es que la funci√≥n de compresi√≥n es en realidad una funci√≥n C que funciona de manera mucho m√°s eficiente que updateAgg.  Comenzando con alg√∫n tama√±o de actualizaci√≥n (alrededor de 10.000), updateAgg alcanza su l√≠mite y luego su tiempo de ejecuci√≥n no depende del tama√±o de la actualizaci√≥n.  Debido al paso preliminar Q, el servicio puede digerir dichos vol√∫menes de datos.  Esto enfatiza cu√°n importante es cuando se trabaja con big data para elegir el algoritmo correcto.  Otro punto es el almacenamiento correcto de datos en la memoria.  Si los datos no se almacenaron en columnas o no se ordenaron por tiempo, entonces nos familiarizar√≠amos con la falta de cach√© TLB: la ausencia de una direcci√≥n de p√°gina de memoria en el cach√© de direcciones del procesador.  Encontrar la direcci√≥n tarda aproximadamente 30 veces m√°s en caso de falla y en el caso de datos dispersos puede ralentizar el servicio varias veces. <br><br><h3>  Conclusi√≥n </h3><br>  En este art√≠culo, mostr√© que las bases de datos KDB + y Q son adecuadas no solo para almacenar grandes datos y un f√°cil acceso a ellas mediante select, sino tambi√©n para crear servicios de procesamiento de datos que pueden digerir cientos de millones de filas / gigabytes de datos incluso en un solo proceso Q .  El lenguaje Q en s√≠ mismo permite implementar algoritmos extremadamente breves y eficientes relacionados con el procesamiento de datos debido a su naturaleza vectorial, un int√©rprete incorporado del dialecto SQL y un conjunto muy exitoso de funciones de biblioteca. <br><br>  Notar√© que lo anterior es solo una parte de las capacidades de Q, tiene otras caracter√≠sticas √∫nicas.  Por ejemplo, un protocolo IPC extremadamente simple que borra la frontera entre procesos Q separados y le permite combinar cientos de estos procesos en una sola red, que puede ubicarse en docenas de servidores en diferentes partes del mundo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/470596/">https://habr.com/ru/post/470596/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../470578/index.html">C√≥mo "humanizamos" la contabilidad en un banco m√≥vil</a></li>
<li><a href="../470582/index.html">Verificaci√≥n de la interfaz de usuario de Telerik para UWP como una forma de comenzar con PVS-Studio</a></li>
<li><a href="../470584/index.html">Verifique la interfaz de usuario de Telerik para UWP para familiarizarse con PVS-Studio</a></li>
<li><a href="../470592/index.html">Revisi√≥n de Plesk - hosting y paneles de control del sitio</a></li>
<li><a href="../470594/index.html">Informe del espect√°culo de luces "Circle of Light" 2019 en Mosc√∫</a></li>
<li><a href="../470598/index.html">El libro "Java moderno. Expresiones Lambda, flujos y programaci√≥n funcional "</a></li>
<li><a href="../470600/index.html">Acerca de las consolas seguras noVNC, el autoescalado en Kubernetes, Haproxy en Ostrovka y el trabajo de los administradores con programadores</a></li>
<li><a href="../470602/index.html">C√≥mo se ver√≠a el metro de Mosc√∫ en un mundo tridimensional</a></li>
<li><a href="../470604/index.html">Velocidad de carga de sitios en comercio electr√≥nico: an√°lisis de las 48 mejores tiendas en l√≠nea en Rusia</a></li>
<li><a href="../470608/index.html">Optimizaci√≥n de la interfaz de usuario de Unity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>