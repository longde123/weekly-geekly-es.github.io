<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé° ‚Ü™Ô∏è üõÄüèΩ Netramesh - leichte Service-Mesh-L√∂sung üìé üö° üç©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beim √úbergang von einer monolithischen Anwendung zu einer Microservice-Architektur stehen wir vor neuen Problemen. 


 In einer monolithischen Anwendu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Netramesh - leichte Service-Mesh-L√∂sung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/avito/blog/449974/"><p>  Beim √úbergang von einer monolithischen Anwendung zu einer Microservice-Architektur stehen wir vor neuen Problemen. </p><br><p>  In einer monolithischen Anwendung ist es normalerweise recht einfach zu bestimmen, in welchem ‚Äã‚ÄãTeil des Systems ein Fehler aufgetreten ist.  Das Problem liegt h√∂chstwahrscheinlich im Code des Monolithen selbst oder in der Datenbank.  Wenn wir jedoch nach einem Problem in der Microservice-Architektur suchen, ist nicht alles so offensichtlich.  Sie m√ºssen den gesamten Pfad finden, den die Anforderung von Anfang bis Ende durchlaufen hat, um sie aus Hunderten von Microservices auszuw√§hlen.  Dar√ºber hinaus verf√ºgen viele von ihnen √ºber eigene Repositorys, in denen auch logische Fehler sowie Leistungs- und Fehlertoleranzprobleme auftreten k√∂nnen. </p><br><p><img src="https://habrastorage.org/webt/m8/0j/9n/m80j9nw5mgqijdf5crurmq7jv0q.png"></p><br><p>  Ich habe lange nach einem Tool gesucht, das bei der Bew√§ltigung solcher Probleme hilft (ich habe dar√ºber in Habr√© geschrieben: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2</a> ), aber am Ende habe ich meine eigene Open-Source-L√∂sung entwickelt.  In dem Artikel spreche ich √ºber die Vorteile des Service-Mesh-Ansatzes und teile ein neues Tool f√ºr dessen Implementierung. </p><a name="habracut"></a><br><p> Die verteilte Ablaufverfolgung ist eine h√§ufige L√∂sung f√ºr das Problem, Fehler in verteilten Systemen zu finden.  Was aber, wenn das System einen solchen Ansatz zum Sammeln von Informationen √ºber Netzwerkinteraktionen noch nicht implementiert hat oder, schlimmer noch, in dem Teil des Systems, in dem es bereits ordnungsgem√§√ü funktioniert, und in dem Teil, in dem dies nicht der Fall ist, da es nicht zu den alten Diensten hinzugef√ºgt wird?  Um die genaue Grundursache des Problems zu ermitteln, m√ºssen Sie ein vollst√§ndiges Bild davon haben, was im System geschieht.  Es ist besonders wichtig zu verstehen, welche Microservices an den wichtigsten gesch√§ftskritischen Pfaden beteiligt sind. </p><br><p>  Hier kann uns ein Service-Mesh-Ansatz zu Hilfe kommen, der sich mit allen Maschinen zum Sammeln von Netzwerkinformationen auf einer Ebene befasst, die niedriger ist als die der Services selbst.  Dieser Ansatz erm√∂glicht es uns, den gesamten Verkehr abzufangen und im laufenden Betrieb zu analysieren.  Dar√ºber hinaus sollten Anwendungen dar√ºber nicht einmal etwas wissen. </p><br><h1 id="service-mesh-podhod">  Service-Mesh-Ansatz </h1><br><p>  Die Hauptidee des Service-Mesh-Ansatzes besteht darin, eine weitere Infrastrukturschicht √ºber das Netzwerk hinzuzuf√ºgen, die es uns erm√∂glicht, alle Dinge mit dienst√ºbergreifender Interaktion zu tun.  Die meisten Implementierungen funktionieren wie folgt: Jedem Mikrodienst wird ein zus√§tzlicher Beiwagencontainer mit einem transparenten Proxy hinzugef√ºgt, √ºber den der gesamte eingehende und ausgehende Dienstverkehr geleitet wird.  Und hier k√∂nnen wir den Kundenausgleich durchf√ºhren, Sicherheitsrichtlinien anwenden, die Anzahl der Anforderungen einschr√§nken und wichtige Informationen √ºber das Zusammenspiel von Diensten in der Produktion sammeln. </p><br><p><img src="https://habrastorage.org/webt/6r/zb/zk/6rzbzk2278btzronnwaok9jyqcw.png"></p><br><h1 id="resheniya">  L√∂sungen </h1><br><p>  Es gibt bereits mehrere Implementierungen dieses Ansatzes: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Istio</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">linkerd2</a> .  Sie bieten viele sofort einsatzbereite Funktionen.  Gleichzeitig entsteht ein gro√üer Aufwand f√ºr die Ressourcen.  Je gr√∂√üer der Cluster ist, in dem ein solches System funktioniert, desto mehr Ressourcen werden f√ºr die Wartung der neuen Infrastruktur ben√∂tigt.  In Avito betreiben wir Kubernetes-Cluster mit Tausenden von Service-Instanzen (und ihre Anzahl w√§chst weiterhin schnell).  In der aktuellen Implementierung verbraucht Istio ~ 300 MB RAM pro Dienstinstanz.  Aufgrund der gro√üen Anzahl von Funktionen wirkt sich ein transparenter Ausgleich auch auf die Gesamtantwortzeit von Diensten aus (bis zu 10 ms). </p><br><p>  Infolgedessen haben wir uns genau angesehen, welche Funktionen wir gerade ben√∂tigen, und festgestellt, dass der Hauptgrund f√ºr die Implementierung solcher L√∂sungen die M√∂glichkeit war, Ablaufverfolgungsinformationen vom gesamten System transparent zu erfassen.  Wir wollten auch die Kontrolle √ºber die Interaktion von Diensten haben und verschiedene Manipulationen mit den Headern vornehmen, die zwischen Diensten √ºbertragen werden. </p><br><p>  Am Ende kamen wir zu unserer Entscheidung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Netramesh</a> . </p><br><h1 id="netramesh">  Netramesh </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Netramesh</a> ist eine leichte Service-Mesh-L√∂sung mit unendlicher Skalierbarkeit, unabh√§ngig von der Anzahl der Services im System. </p><br><p>  Die Hauptziele der neuen L√∂sung waren ein geringer Ressourcenaufwand und eine hohe Leistung.  Von den Hauptfunktionen wollten wir sofort in der Lage sein, Ablaufverfolgungsbereiche transparent an unser Jaeger-System zu senden. </p><br><p>  Heute sind die meisten Cloud-L√∂sungen auf Golang implementiert.  Und daf√ºr gibt es nat√ºrlich Gr√ºnde.  Das Schreiben von Golang-Netzwerkanwendungen, die asynchron mit E / A arbeiten und nach Bedarf auf Kernel skaliert werden, ist bequem und recht einfach.  Und was auch sehr wichtig ist, die Leistung reicht aus, um dieses Problem zu l√∂sen.  Deshalb haben wir uns auch f√ºr Golang entschieden. </p><br><h1 id="proizvoditelnost">  Leistung </h1><br><p>  Wir haben uns darauf konzentriert, maximale Leistung zu erzielen.  F√ºr eine L√∂sung, die neben jeder Instanz des Dienstes bereitgestellt wird, ist ein geringer RAM- und Prozessorverbrauch erforderlich.  Und nat√ºrlich sollte auch die Verz√∂gerung bei der Beantwortung gering sein. </p><br><p>  Mal sehen, was die Ergebnisse sind. </p><br><h2 id="ram">  RAM </h2><br><p>  Netramesh verbraucht ~ 10 MB ohne Datenverkehr und maximal 50 MB mit einer Last von bis zu 10.000 RPS pro Instanz. </p><br><p>  Der Istio Envoy Proxy verbraucht in unseren Clustern mit Tausenden von Instanzen immer ~ 300 MB.  Auf diese Weise k√∂nnen Sie es nicht auf den gesamten Cluster skalieren. </p><br><p><img src="https://habrastorage.org/webt/y6/io/ys/y6ioysd0roxkllgujmzof3lps30.png"></p><br><p><img src="https://habrastorage.org/webt/mi/70/2q/mi702qegemdopjkdh7or3bqv9c0.png"></p><br><p>  Mit Netramesh haben wir ~ 10-mal weniger Speicherverbrauch. </p><br><h2 id="cpu">  CPU </h2><br><p>  Die CPU-Auslastung ist unter Last relativ gleich.  Dies h√§ngt von der Anzahl der Anfragen pro Zeiteinheit an den Beiwagen ab.  Werte bei 3000 Anfragen pro Sekunde in der Spitze: </p><br><p><img src="https://habrastorage.org/webt/nm/dp/5s/nmdp5ssxux47zzuohvhacbgjqzw.png"></p><br><p><img src="https://habrastorage.org/webt/8y/kn/bq/8yknbqlejeqprvut2c2n_pgsay0.png"></p><br><p>  Es gibt noch einen weiteren wichtigen Punkt: Netramesh - eine L√∂sung ohne Steuerebene und ohne Last verbraucht keine CPU-Zeit.  Mit Istio aktualisieren die Beiwagen immer die Service-Endpunkte.  Als Ergebnis k√∂nnen wir ein solches Bild ohne Last sehen: </p><br><p><img src="https://habrastorage.org/webt/hz/ne/2h/hzne2hf6m_z_tefolvtoiwuwcpq.png"></p><br><p>  Wir verwenden HTTP / 1, um zwischen Diensten zu kommunizieren.  Die Verl√§ngerung der Antwortzeit f√ºr Istio beim Proxen durch den Gesandten betrug bis zu 5-10 ms, was f√ºr Dienste, die in einer Millisekunde bereit sind, zu antworten, ziemlich viel ist.  Mit Netramesh verringerte sich diese Zeit auf 0,5 bis 2 ms. </p><br><h1 id="masshtabiruemost">  Skalierbarkeit </h1><br><p>  Eine geringe Menge an Ressourcen, die von jedem Proxy ausgegeben wird, erm√∂glicht es, ihn neben jedem Dienst zu platzieren.  Netramesh wurde absichtlich ohne eine Steuerebenenkomponente entwickelt, um einfach die Leichtigkeit jedes Beiwagens aufrechtzuerhalten.  In Service-Mesh-L√∂sungen verteilt die Steuerebene h√§ufig Service-Discovery-Informationen an jeden Beiwagen.  Dazu kommen Informationen zu Zeit√ºberschreitungen und Ausgleichseinstellungen.  All dies erm√∂glicht es Ihnen, viele n√ºtzliche Dinge zu tun, aber leider vergr√∂√üert sich die Seitenwagengr√∂√üe. </p><br><h1 id="service-discovery">  Serviceerkennung </h1><br><p><img src="https://habrastorage.org/webt/sl/2o/gf/sl2ogfr5t31zfqwefxmcoe89xmu.png"></p><br><p>  Netramesh f√ºgt keine zus√§tzlichen Mechanismen f√ºr die Serviceerkennung hinzu.  Der gesamte Verkehr wird transparent √ºber den netra-Beiwagen √ºbertragen. </p><br><p> Netramesh unterst√ºtzt das HTTP / 1-Anwendungsprotokoll.  Eine konfigurierbare Liste von Ports wird verwendet, um dies zu bestimmen.  In der Regel gibt es mehrere Ports auf einem System, die √ºber HTTP kommunizieren.  Beispielsweise verwenden wir 80, 8890, 8080 f√ºr die Interaktion von Diensten und externen Anforderungen. In diesem Fall k√∂nnen sie mithilfe der Umgebungsvariablen <code>NETRA_HTTP_PORTS</code> . </p><br><p>  Wenn Sie Kubernetes als Orchester und seinen Mechanismus von Service-Entit√§ten f√ºr die Intracluster-Interaktion zwischen Services verwenden, bleibt der Mechanismus genau derselbe.  Zun√§chst erh√§lt der Microservice die Service-IP-Adresse mit kube-dns und stellt eine neue Verbindung her.  Diese Verbindung wird zuerst mit dem lokalen Netra-Sidecar hergestellt, und alle TCP-Pakete kommen zun√§chst in Netra an.  Als n√§chstes stellt netra-sidecar eine Verbindung zum urspr√ºnglichen Ziel her.  NAT auf dem Pod IP auf dem Knoten bleibt genau das gleiche wie ohne Netra. </p><br><h1 id="raspredelennyy-tracing-i-prokidyvanie-konteksta">  Verteilte Ablaufverfolgung und Kontext-Scrolling </h1><br><p>  Netramesh bietet die Funktionalit√§t, die zum Senden von Ablaufverfolgungsbereichen f√ºr HTTP-Interaktionen erforderlich ist.  Netra-Sidecar analysiert das HTTP-Protokoll, misst Anforderungsverz√∂gerungen und ruft die erforderlichen Informationen aus HTTP-Headern ab.  Letztendlich erhalten wir alle Spuren in einem einzigen Jaeger-System.  Zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Feinabstimmung k√∂nnen</a> Sie auch die Umgebungsvariablen verwenden, die von der offiziellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jaeger Go-Bibliothek bereitgestellt werden</a> . </p><br><p><img src="https://habrastorage.org/webt/ak/rg/_a/akrg_a52och5z3sfg625xb8se6m.png"></p><br><p><img src="https://habrastorage.org/webt/ol/c9/ga/olc9gakhzkqcbgkcnjbhsy2e5eo.png"></p><br><p>  Aber es gibt ein Problem.  Solange die Dienste keinen speziellen Uber-Header generieren und weiterleiten, werden die verbundenen Ablaufverfolgungsbereiche im System nicht angezeigt.  Und das ist es, was wir brauchen, um schnell die Ursache der Probleme zu finden.  Hier hat Netramesh wieder eine L√∂sung.  Proxies lesen HTTP-Header und generieren sie, wenn sie keine √ºbergeordnete Trace-ID haben.  Netramesh speichert auch Informationen zu eingehenden und ausgehenden Anforderungen im Beiwagen und vergleicht diese, indem die erforderlichen Header ausgehender Anforderungen angereichert werden.  In den Diensten muss lediglich ein <code>X-Request-Id</code> <code>NETRA_HTTP_REQUEST_ID_HEADER_NAME</code> <code>X-Request-Id</code> Header <code>NETRA_HTTP_REQUEST_ID_HEADER_NAME</code> werden, der mit der Umgebungsvariablen <code>NETRA_HTTP_REQUEST_ID_HEADER_NAME</code> konfiguriert werden <code>NETRA_HTTP_REQUEST_ID_HEADER_NAME</code> .  Um die Gr√∂√üe des Kontexts in Netramesh zu steuern, k√∂nnen Sie die folgenden Umgebungsvariablen <code>NETRA_TRACING_CONTEXT_EXPIRATION_MILLISECONDS</code> : <code>NETRA_TRACING_CONTEXT_EXPIRATION_MILLISECONDS</code> (die Zeit, in der der Kontext gespeichert wird) und <code>NETRA_TRACING_CONTEXT_CLEANUP_INTERVAL</code> (Periodizit√§t der Kontextbereinigung). </p><br><p>  Es ist auch m√∂glich, mehrere Pfade in Ihrem System zu kombinieren, indem Sie sie mit einem speziellen Sitzungsmarker markieren.  Mit Netra k√∂nnen Sie <code>HTTP_HEADER_TAG_MAP</code> , um HTTP-Header in geeignete Tracing-Span-Tags <code>HTTP_HEADER_TAG_MAP</code> .  Dies kann besonders zum Testen n√ºtzlich sein.  Nach dem Bestehen des Funktionstests k√∂nnen Sie sehen, welcher Teil des Systems durch Filtern nach dem entsprechenden Sitzungsschl√ºssel betroffen ist. </p><br><h1 id="opredelenie-istochnika-zaprosa">  Ermitteln der Quelle der Anforderung </h1><br><p>  Um festzustellen, woher die Anforderung stammt, k√∂nnen Sie mit der Funktion automatisch einen Header mit einer Quelle hinzuf√ºgen.  Mit der Umgebungsvariablen <code>NETRA_HTTP_X_SOURCE_HEADER_NAME</code> k√∂nnen Sie den Namen des Headers angeben, der automatisch festgelegt wird.  Mit <code>NETRA_HTTP_X_SOURCE_VALUE</code> Sie den Wert festlegen, in dem der X-Source-Header f√ºr alle ausgehenden Anforderungen festgelegt wird. </p><br><p>  Auf diese Weise k√∂nnen Sie das gesamte Netzwerk einheitlich verteilen, um die Verteilung dieses n√ºtzlichen Headers vorzunehmen.  Dann k√∂nnen Sie es bereits in Diensten verwenden und zu Protokollen und Metriken hinzuf√ºgen. </p><br><h1 id="routing-trafika-i-vnutrennosti-netramesh">  Netramesh-Verkehr und internes Routing </h1><br><p>  Netramesh besteht aus zwei Hauptkomponenten.  Der erste, netra-init, legt Netzwerkregeln zum Abfangen von Datenverkehr fest.  Es verwendet <a href="">Umleitungsregeln</a> f√ºr <a href="">iptables</a> , um den gesamten oder einen Teil des Datenverkehrs auf dem Beiwagen abzufangen, der die zweite Hauptkomponente von Netramesh darstellt.  Sie k√∂nnen konfigurieren, welche Ports Sie f√ºr eingehende und ausgehende TCP-Sitzungen <code>INBOUND_INTERCEPT_PORTS, OUTBOUND_INTERCEPT_PORTS</code> : <code>INBOUND_INTERCEPT_PORTS, OUTBOUND_INTERCEPT_PORTS</code> . </p><br><p>  Das Tool hat auch eine interessante Funktion - probabilistisches Routing.  Wenn Sie Netramesh ausschlie√ülich zum Sammeln von Ablaufverfolgungsbereichen verwenden, k√∂nnen Sie in einer Produktionsumgebung Ressourcen sparen und das probabilistische Routing mithilfe der Variablen <code>NETRA_INBOUND_PROBABILITY</code> und <code>NETRA_OUTBOUND_PROBABILITY</code> (von 0 bis 1) <code>NETRA_OUTBOUND_PROBABILITY</code> .  Der Standardwert ist 1 (der gesamte Datenverkehr wird abgefangen). </p><br><p>  Nach einem erfolgreichen Abfangen akzeptiert netra sidecar eine neue Verbindung und verwendet die Socket-Option <code>SO_ORIGINAL_DST</code> , um das urspr√ºngliche Ziel <code>SO_ORIGINAL_DST</code> .  Netra stellt dann eine neue Verbindung zur urspr√ºnglichen IP-Adresse her und stellt eine bidirektionale TCP-Kommunikation zwischen den Parteien her, wobei der gesamte durchgelassene Datenverkehr abgeh√∂rt wird.  Wenn der Port als HTTP definiert ist, versucht Netra, ihn zu analysieren und weiterzuleiten.  Wenn die HTTP-Analyse nicht erfolgreich ist, greift Netra auf TCP und transparente Proxy-Bytes zur√ºck. </p><br><h1 id="postroenie-grafa-zavisimostey">  Erstellen eines Abh√§ngigkeitsdiagramms </h1><br><p>  Nachdem ich in Jaeger viele Informationen zur Ablaufverfolgung erhalten habe, m√∂chte ich ein vollst√§ndiges Diagramm der Interaktionen im System erhalten.  Wenn Ihr System jedoch ausreichend ausgelastet ist und sich t√§glich Milliarden von Ablaufverfolgungsbereichen ansammeln, wird die Aggregation nicht so einfach.  Es gibt einen offiziellen Weg, dies zu tun: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funkenabh√§ngigkeiten</a> .  Es wird jedoch Stunden dauern, bis das vollst√§ndige Diagramm erstellt und der gesamte Datensatz in den letzten 24 Stunden von Jaeger heruntergeladen wurde. </p><br><p>  Wenn Sie Elasticsearch zum Speichern von Ablaufverfolgungsbereichen verwenden, k√∂nnen Sie ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einfaches Dienstprogramm f√ºr Golang verwenden</a> , mit dem mithilfe der Funktionen und F√§higkeiten von Elasticsearch in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wenigen</a> Minuten dasselbe Diagramm erstellt wird. </p><br><p><img src="https://habrastorage.org/webt/ob/t8/av/obt8avxi13fb9ykb1rj3ljreup0.png"></p><br><h1 id="kak-ispolzovat-netramesh">  Wie man Netramesh benutzt </h1><br><p>  Netra kann einfach zu jedem Dienst hinzugef√ºgt werden, auf dem ein beliebiger Orchestrator ausgef√ºhrt wird.  Hier sehen Sie ein Beispiel. </p><br><p>  Derzeit ist Netra nicht in der Lage, Sidecar automatisch f√ºr Services bereitzustellen, es gibt jedoch Pl√§ne f√ºr die Implementierung. </p><br><h1 id="buduschee-netramesh">  Zuk√ºnftiger Netramesh </h1><br><p>  Das Hauptziel von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Netramesh</a> besteht darin, minimale Ressourcenkosten und eine hohe Leistung zu erzielen und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hauptm√∂glichkeiten</a> f√ºr die Beobachtbarkeit und Kontrolle der Interaktion zwischen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diensten bereitzustellen</a> . </p><br><p>  In Zukunft wird Netramesh Unterst√ºtzung f√ºr andere Protokolle auf Anwendungsebene als HTTP erhalten.  In naher Zukunft wird es die M√∂glichkeit des L7-Routings geben. </p><br><p>  Verwenden Sie Netramesh, wenn Sie auf √§hnliche Probleme sto√üen, und schreiben Sie uns Fragen und Vorschl√§ge. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de449974/">https://habr.com/ru/post/de449974/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de449964/index.html">Probefahrt nanoCAD SPDS Baustelle 8. Teil 2</a></li>
<li><a href="../de449966/index.html">Tabellen in Figma. Datenrasterdesign nach einer Komponente</a></li>
<li><a href="../de449968/index.html">Redmadrobot diskutiert AppsConf 2019: Video</a></li>
<li><a href="../de449970/index.html">Poste unter der schwarzen Flagge oder Da ich deinen Videokurs nicht auf den Tracker gesetzt habe</a></li>
<li><a href="../de449972/index.html">Wie kann man Pools schnell in den Upstream injizieren?</a></li>
<li><a href="../de449976/index.html">Assoziative Multithread-Container in C ++. Yandex-Bericht</a></li>
<li><a href="../de449978/index.html">Igor Antarov vom Moskauer Tesla Club k√§mpft mit 20 Mythen √ºber Tesla und Elektroautos</a></li>
<li><a href="../de449984/index.html">Google News und Leo Tolstoy: Visualisierung von Word2Vec-Worteinbettungen mit t-SNE</a></li>
<li><a href="../de449986/index.html">Blockchain: Was sollen wir einen Fall bauen?</a></li>
<li><a href="../de449990/index.html">Wie kann man Latex, Formeln und Habr finden?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>