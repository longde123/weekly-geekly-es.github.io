<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§Ø üßôüèø üöØ Menor fonte poss√≠vel üà≥ üßóüèª üï∫üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tarefa: usando a menor quantidade poss√≠vel de recursos, renderize um texto significativo. 


- Qu√£o pequena pode ser uma fonte leg√≠vel? 
- Quanta mem√≥...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menor fonte poss√≠vel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460697/"><p>  Tarefa: usando a menor quantidade poss√≠vel de recursos, renderize um texto significativo. </p><br><ul><li>  Qu√£o pequena pode ser uma fonte leg√≠vel? </li><li> Quanta mem√≥ria ser√° necess√°ria para armazen√°-lo? </li><li>  Quanto c√≥digo ser√° necess√°rio para us√°-lo? </li></ul><br><p>  Vamos ver o que temos.  Spoiler </p><br><p><img src="https://habrastorage.org/webt/6k/jr/6m/6kjr6md92hgpbm7gvs8ia3o1cti.png"></p><a name="habracut"></a><br><h2 id="vvedenie-v-bitmepy">  Introdu√ß√£o aos bitmaps </h2><br><p> Os computadores apresentam bitmaps como bitmaps.  N√£o se trata do formato <code>.bmp</code> , mas de uma maneira de armazenar pixels na mem√≥ria.  Para entender o que est√° acontecendo, precisamos aprender algo sobre esse caminho. </p><br><h3 id="sloi">  Camadas </h3><br><p>  Uma imagem geralmente cont√©m v√°rias <em>camadas</em> umas sobre as outras.  Na maioria das vezes, correspondem √†s coordenadas do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">espa√ßo de cores RGB</a> .  Uma camada para <em>vermelho</em> , uma para <em>verde</em> e uma para <em>azul</em> .  Se o formato da imagem suportar transpar√™ncia, ser√° criada uma quarta camada, geralmente chamada <em>alfa</em> .  Grosso modo, uma imagem colorida √© tr√™s (ou quatro, se houver um canal alfa) em preto e branco, localizada uma acima da outra. </p><br><ul><li>  RGB n√£o √© o √∫nico espa√ßo de cor;  O formato JPEG, por exemplo, usa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">YUV</a> .  Mas neste artigo n√£o precisaremos do restante dos espa√ßos de cores, portanto, n√£o os consideramos. </li></ul><br><p>  Um conjunto de camadas pode ser representado na mem√≥ria de duas maneiras.  Eles s√£o armazenados separadamente ou valores de diferentes camadas s√£o intercalados.  No √∫ltimo caso, as camadas s√£o chamadas de <em>canais</em> , e √© assim que a maioria dos formatos modernos funciona. </p><br><p>  Suponha que tenhamos um desenho 4x4 contendo tr√™s camadas: <em>R</em> para vermelho, <em>G</em> para verde e <em>B</em> para o componente azul de cada um dos pixels.  Pode ser representado assim: </p><br><pre> <code class="plaintext hljs"> RRRR RRRR RRRR RRRR GGGG GGGG GGGG GGGG BBBB BBBB BBBB BBBB</code> </pre> <br><p>  Todas as tr√™s camadas s√£o armazenadas separadamente.  O formato alternado parece diferente: </p><br><pre> <code class="plaintext hljs"> RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB</code> </pre> <br><ul><li>  cada triplo de caracteres corresponde <strong>exatamente a</strong> um pixel </li><li>  os valores dentro do triplo est√£o na ordem <em>RGB</em> .  √Äs vezes, uma ordem diferente pode ser usada (por exemplo, <em>BGR</em> ), mas essa √© a mais comum. </li></ul><br><p>  Para simplificar, organizei os pixels na forma de uma matriz bidimensional, porque √© mais claro onde esse ou aquele triplo est√° na imagem.  Mas, na verdade, a mem√≥ria do computador n√£o √© bidimensional, mas unidimensional; portanto, a imagem 4x4 ser√° armazenada assim: </p><br><pre> <code class="plaintext hljs">RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB</code> </pre> <br><h3 id="bpp">  bpp </h3><br><p>  A abrevia√ß√£o <em>bpp</em> refere-se ao n√∫mero de bits ou bytes por pixel (bits / bytes por pixel).  Voc√™ pode ter visto <code>24bpp</code> ou <code>3bpp</code> .  Essas duas caracter√≠sticas significam a mesma coisa - <strong>24 <em>bits</em> por pixel</strong> ou <strong>3 <em>bytes</em> por pixel</strong> .  Como sempre existem 8 bits em um byte, voc√™ pode adivinhar pelo valor de qual das unidades em quest√£o. </p><br><h3 id="predstavlenie-v-pamyati">  Representa√ß√£o de mem√≥ria </h3><br><p>  <code>24bpp</code> , tamb√©m conhecido como <code>3bpp</code> - o formato mais comum para armazenar flores.  √â assim que um <strong>√∫nico pixel</strong> na ordem <em>RGB</em> fica no n√≠vel de bits individuais. </p><br><pre> <code class="plaintext hljs"> 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  RRRRRRRRGGGGGGGGBBBBB BBB</code> </pre> <br><ul><li>  Um byte para <em>R</em> , um para <em>G</em> e um para <em>B</em> , totalizando tr√™s bytes. </li><li>  Cada um deles cont√©m um valor de 0 a 255. </li></ul><br><p>  Portanto, se o pixel fornecido tiver a seguinte cor: </p><br><ul><li> <code>R 255</code> </li> <li> <code>G 80</code> </li> <li> <code>B 100</code> </li> </ul><br><p>  Em seguida, <code>255</code> armazenados no primeiro byte, <code>80</code> no segundo e <code>100</code> no terceiro. </p><br><p>  Na maioria das vezes, esses valores s√£o representados em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">hexadecimal</a> .  Diga <code>#ff5064</code> .  Isso √© muito mais conveniente e compacto: <code>R = 0xff</code> (ou seja, <code>R=255</code> em decimal), <code>G = 0x50</code> (= <code>G=80</code> ), <code>B=0x64</code> (= <code>B=100</code> ). </p><br><ul><li>  A representa√ß√£o hexadecimal possui uma propriedade √∫til.  Como cada byte de cor √© representado por dois caracteres, cada caractere codifica <strong>exatamente</strong> meio byte ou quatro bits.  A prop√≥sito, 4 bits s√£o chamados de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mordidelas</a> . </li></ul><br><h3 id="shirina-stroki">  Largura da linha </h3><br><p>  Quando os pixels v√£o um ap√≥s o outro e cada um cont√©m mais de um canal, os dados s√£o facilmente confundidos.  N√£o se sabe quando uma linha termina e a seguinte come√ßa, portanto, para interpretar um arquivo com um bitmap, voc√™ precisa saber o tamanho da imagem e o <em>bpp</em> .  No nosso caso, a imagem tem uma largura de <code>w = 4</code> pixels e cada um desses pixels cont√©m 3 bytes; portanto, a string √© codificada com 12 (no caso geral, <code>w*bpp</code> ) bytes. </p><br><ul><li>  Uma string nem sempre √© codificada com exatamente <code>w*bpp</code> bytes;  Freq√ºentemente, pixels "ocultos" s√£o adicionados a ele para aumentar a largura da imagem.  Por exemplo, dimensionar imagens √© mais r√°pido e mais conveniente quando o tamanho em pixels √© igual a duas vezes.  Portanto, o arquivo pode conter (acess√≠vel ao usu√°rio) uma imagem de 120x120 pixels, mas ser armazenado como uma imagem de 128x128.  Quando uma imagem √© exibida na tela, esses pixels s√£o ignorados.  No entanto, n√£o precisamos saber sobre eles. </li></ul><br><p>  A coordenada de qualquer pixel <code>(x, y)</code> na representa√ß√£o unidimensional √© <code>(y * w + x) * bpp</code> .  Isso, em geral, √© √≥bvio: <code>y</code> √© o n√∫mero da linha, cada linha cont√©m <code>w</code> pixels, ent√£o <code>y * w</code> √© o in√≠cio da linha desejada e <code>+x</code> nos leva ao <code>x</code> desejado dentro dela.  E como as coordenadas n√£o est√£o em bytes, mas em pixels, tudo isso √© multiplicado pelo tamanho do pixel <code>bpp</code> , neste caso em bytes.  Como o pixel tem um tamanho diferente de zero, voc√™ precisa ler exatamente os bytes de <code>bpp</code> , come√ßando pela coordenada recebida, e teremos uma representa√ß√£o completa do pixel desejado. </p><br><h2 id="atlas-shrifta">  Atlas de fontes </h2><br><p>  Na verdade, os monitores existentes n√£o exibem um pixel como um todo, mas tr√™s subpixels - vermelho, azul e verde.  Se voc√™ olhar para o monitor sob amplia√ß√£o, ver√° algo parecido com isto: </p><br><p><img src="https://habrastorage.org/webt/w8/nb/c9/w8nbc98aixpbrxgvffsccmxelyk.png"></p><br><ul><li>  Desenho da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Wikipedia</a> </li></ul><br><p>  Estamos interessados ‚Äã‚Äãno LCD, pois provavelmente √© nesse monitor que voc√™ l√™ este texto.  Claro, existem armadilhas: </p><br><ul><li>  Nem todas as matrizes usam exatamente essa ordem de subpixels, √†s vezes BGR. </li><li>  Se voc√™ ligar o monitor (por exemplo, procure o telefone na orienta√ß√£o paisagem), o padr√£o tamb√©m ser√° rotacionado e a fonte deixar√° de funcionar. </li><li>  Diferentes orienta√ß√µes da matriz e a organiza√ß√£o dos subpixels exigir√£o o retrabalho da pr√≥pria fonte. </li><li>  Em particular, ele n√£o funciona em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">monitores AMOLED</a> que usam o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">layout PenTile</a> .  Esses monitores s√£o mais frequentemente usados ‚Äã‚Äãem dispositivos m√≥veis. </li></ul><br><p>  O uso de hacks de subpixel para aumentar a resolu√ß√£o √© chamado de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">renderiza√ß√£o de subpixel</a> .  Voc√™ pode ler sobre seu uso em tipografia, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p><br><p>  Felizmente para n√≥s, Matt Sarnov j√° descobriu usando renderiza√ß√£o de subpixel para criar uma fonte min√∫scula de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">militext</a> .  Manualmente, ele criou esta pequena imagem: </p><br><p><img src="https://habrastorage.org/webt/p7/jk/xe/p7jkxececbln6pxlatfoa9kyymq.png"></p><br><p>  Que, se voc√™ olhar com muito cuidado para o monitor, fica assim: </p><br><p><img src="https://habrastorage.org/webt/8n/wz/fq/8nwzfqilnvn_jronmwqbfnodllg.png"></p><br><p>  E aqui est√°, programaticamente aumentado em 12 vezes: </p><br><p><img src="https://habrastorage.org/webt/fa/9p/us/fa9puspiilp5ip-50cuyxfyrdva.png"></p><br><p>  Com base em seu trabalho, criei um atlas de fontes no qual cada caractere corresponde a uma coluna de <code>1x5</code> pixels.  A ordem dos caracteres √© a seguinte: </p><br><pre> <code class="plaintext hljs">0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ</code> </pre> <br><p><img src="https://habrastorage.org/webt/qe/ip/_v/qeip_vlwmjwfnnbbuz9cq6rhfn4.png"></p><br><p>  O mesmo atlas aumentou 12 vezes: </p><br><p><img src="https://habrastorage.org/webt/m3/ds/eg/m3dseggtbsmpgnmvlekvlz2aqow.png"></p><br><p>  Com 36 caracteres usados, s√£o <code>365</code> exatamente <code>365</code> pixels.  Se assumirmos que cada pixel ocupa 3 bytes, precisamos de <code>36*5*3 = 540</code> bytes para armazenar a imagem inteira ( <em>aprox. Por: no original, uma s√©rie confusa de edi√ß√µes sobre o canal alfa, exclus√£o de metadados etc.). n. Na tradu√ß√£o, eu o omiti e uso apenas a vers√£o final do arquivo</em> ).  Um arquivo PNG passado atrav√©s de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pngcrush</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">optipng</a> leva ainda menos: </p><br><pre> <code class="plaintext hljs"># wc -c &lt; font-crushed.png 390</code> </pre> <br><p>  Mas voc√™ pode obter um tamanho ainda menor se usar uma abordagem ligeiramente diferente </p><br><h1 id="szhatie">  Compress√£o </h1><br><p>  O leitor atento pode perceber que o atlas usa apenas 7 cores: </p><br><ol><li> <code>#ffffff</code> </li> <li> <code>#ff0000</code> </li> <li> <code>#00ff00</code> </li> <li> <code>#0000ff</code> </li> <li> <code>#00ffff</code> </li> <li> <code>#ff00ff</code> </li> <li> <code>#ffff00</code> </li> </ol><br><h2 id="palitra">  Paleta </h2><br><p>  Em tais situa√ß√µes, geralmente √© mais f√°cil criar uma paleta.  Ent√£o, para cada pixel, voc√™ pode armazenar n√£o tr√™s bytes de cor, mas apenas o n√∫mero da cor na paleta.  No nosso caso, 3 bits ( <code>7 &lt; 2^3</code> ) ser√£o suficientes para escolher entre 7 cores.  Se atribuirmos um valor de tr√™s bits a cada pixel, o atlas inteiro caber√° em <em>68 bytes</em> . </p><br><ul><li>  O leitor, versado em compacta√ß√£o de dados, pode responder que, em geral, existem ‚Äúbits fracion√°rios‚Äù e, no nosso caso, <strong>2.875 bits por pixel s√£o</strong> suficientes.  Essa densidade pode ser alcan√ßada usando magia negra, conhecida como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">codifica√ß√£o aritm√©tica</a> .  N√£o faremos isso, porque a codifica√ß√£o aritm√©tica √© uma coisa complicada e 68 bytes j√° √© um pouco. </li></ul><br><h2 id="vyravnivanie">  Alinhamento </h2><br><p>  A codifica√ß√£o de tr√™s bits tem uma s√©ria desvantagem.  Os pixels n√£o podem ser distribu√≠dos uniformemente pelos bytes de 8 bits, o que √© importante porque os bytes s√£o a menor √°rea de mem√≥ria endere√ß√°vel.  Digamos que queremos salvar tr√™s pixels: </p><br><pre> <code class="plaintext hljs">ABC</code> </pre> <br><p>  Se cada um receber 3 bits, ser√£o necess√°rios 2 bytes para armazen√°-los ( <code>-</code> indica bits n√£o utilizados): </p><br><pre> <code class="plaintext hljs">bit 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 pixel AAABBBCCC - - - - - - -</code> </pre> <br><p>  √â importante ressaltar que o pixel <strong>C</strong> n√£o deixa apenas um monte de espa√ßo vazio;  est√° <em>dividido</em> entre dois bytes.  Quando come√ßamos a adicionar os seguintes pixels, eles podem ser posicionados arbitrariamente em rela√ß√£o aos limites de bytes.  A solu√ß√£o mais simples seria usar mordiscar por pixel, porque 8 √© perfeitamente dividido por 4 e permite que voc√™ coloque exatamente dois pixels em cada byte.  Mas isso aumentar√° o tamanho do atlas em um ter√ßo, de <strong>68 bytes</strong> para <strong>90 bytes</strong> . </p><br><ul><li>  De fato, o arquivo pode ser ainda menor usando a codifica√ß√£o pal√≠ndromo, codifica√ß√£o por intervalo e outras t√©cnicas de compacta√ß√£o.  Como a codifica√ß√£o aritm√©tica, adiamos essas t√©cnicas para o pr√≥ximo artigo. </li></ul><br><h2 id="bitovyy-bufer">  Buffer de bits </h2><br><p>  Felizmente, n√£o h√° nada fundamentalmente imposs√≠vel no trabalho com valores de 3 bits.  Voc√™ s√≥ precisa monitorar qual posi√ß√£o dentro do byte estamos escrevendo ou lendo no momento.  A classe simples a seguir converte um fluxo de dados de 3 bits em uma matriz de bytes. </p><br><ul><li>  Por motivos de legibilidade, o c√≥digo √© escrito em JS, mas o mesmo m√©todo √© generalizado para outros idiomas. </li><li>  Pedido usado de byte baixo a alto ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Little Endian</a> ) </li></ul><br><pre> <code class="plaintext hljs">class BitBuffer { constructor(bytes) { this.data = new Uint8Array(bytes); this.offset = 0; } write(value) { for (let i = 0; i &lt; 3; ) { // bits remaining const remaining = 3 - i; // bit offset in the byte ie remainder of dividing by 8 const bit_offset = this.offset &amp; 7; // byte offset for a given bit offset, ie divide by 8 const byte_offset = this.offset &gt;&gt; 3; // max number of bits we can write to the current byte const wrote = Math.min(remaining, 8 - bit_offset); // mask with the correct bit-width const mask = ~(0xff &lt;&lt; wrote); // shift the bits we want to the start of the byte and mask off the rest const write_bits = value &amp; mask; // destination mask to zero all the bits we're changing first const dest_mask = ~(mask &lt;&lt; bit_offset); value &gt;&gt;= wrote; // write it this.data[byte_offset] = (this.data[byte_offset] &amp; dest_mask) | (write_bits &lt;&lt; bit_offset); // advance this.offset += wrote; i += wrote; } } to_string() { return Array.from(this.data, (byte) =&gt; ('0' + (byte &amp; 0xff).toString(16)).slice(-2)).join(''); } };</code> </pre> <br><p>  Vamos baixar e codificar o arquivo atlas: </p><br><pre> <code class="plaintext hljs">const PNG = require('png-js'); const fs = require('fs'); // this is our palette of colors const Palette = [ [0xff, 0xff, 0xff], [0xff, 0x00, 0x00], [0x00, 0xff, 0x00], [0x00, 0x00, 0xff], [0x00, 0xff, 0xff], [0xff, 0x00, 0xff], [0xff, 0xff, 0x00] ]; // given a color represented as [R, G, B], find the index in palette where that color is function find_palette_index(color) { const [sR, sG, sB] = color; for (let i = 0; i &lt; Palette.length; i++) { const [aR, aG, aB] = Palette[i]; if (sR === aR &amp;&amp; sG === aG &amp;&amp; sB === aB) { return i; } } return -1; } // build the bit buffer representation function build(cb) { const data = fs.readFileSync('subpixels.png'); const image = new PNG(data); image.decode(function(pixels) { // we need 3 bits per pixel, so w*h*3 gives us the # of bits for our buffer // however BitBuffer can only allocate bytes, dividing this by 8 (bits for a byte) // gives us the # of bytes, but that division can result in 67.5 ... Math.ceil // just rounds up to 68. this will give the right amount of storage for any // size atlas. let result = new BitBuffer(Math.ceil((image.width * image.height * 3) / 8)); for (let y = 0; y &lt; image.height; y++) { for (let x = 0; x &lt; image.width; x++) { // 1D index as described above const index = (y * image.width + x) * 4; // extract the RGB pixel value, ignore A (alpha) const color = Array.from(pixels.slice(index, index + 3)); // write out 3-bit palette index to the bit buffer result.write(find_palette_index(color)); } } cb(result); }); } build((result) =&gt; console.log(result.to_string()));</code> </pre> <br><p>  Como esperado, o atlas se encaixa em <strong>68 bytes</strong> , 6 vezes menor que o arquivo PNG. </p><br><p>  ( <em>faixa aproximada: o autor √© um tanto falso: ele n√£o salvou o tamanho da paleta e da imagem, o que, de acordo com minhas estimativas, exigir√° 23 bytes com um tamanho fixo de paleta e aumentar√° o tamanho da imagem para 91 bytes</em> ) </p><br><p>  Agora vamos converter a imagem em uma string para que voc√™ possa col√°-la no c√≥digo fonte.  Em ess√™ncia, o m√©todo <code>to_string</code> seguinte: representa o conte√∫do de cada byte como um n√∫mero hexadecimal. </p><br><pre> <code class="plaintext hljs">305000000c0328d6d4b24cb46d516d4ddab669926a0ddab651db76150060009c0285 e6a0752db59054655bd7b569d26a4ddba053892a003060400d232850b40a6b61ad00</code> </pre> <br><p>  Mas a sequ√™ncia resultante ainda √© bastante longa, porque nos limitamos a um alfabeto de 16 caracteres.  Voc√™ pode substitu√≠-lo por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">base64</a> , no qual h√° quatro vezes mais caracteres. </p><br><pre> <code class="plaintext hljs">to_string() { return Buffer.from(this.data).toString('base64'); }</code> </pre> <br><p>  Em base64, o atlas √© assim: </p><br><pre> <code class="plaintext hljs">MFAAAAwDKNbUsky0bVFtTdq2aZJqDdq2Udt2FQBgAJwCheagdS21kFRlW9e1adJqTdugU4kqADBgQA0jKFC0CmthrQA=</code> </pre> <br><p>  Essa linha pode ser codificada no m√≥dulo JS e usada para rasterizar o texto. </p><br><h1 id="rasterizaciya">  Rasteriza√ß√£o </h1><br><p>  Para economizar mem√≥ria, apenas uma letra ser√° decodificada por vez. </p><br><pre> <code class="plaintext hljs">const Alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; const Atlas = Uint8Array.from(Buffer.from('MFAAAAwDKNbUsky0bVFtTdq2aZJqDdq2Udt2FQBgAJwCheagdS21kFRlW9e1adJqTdugU4kqADBgQA0jKFC0CmthrQA=', 'base64')); const Palette = [ [0xff, 0xff, 0xff], [0xff, 0x00, 0x00], [0x00, 0xff, 0x00], [0x00, 0x00, 0xff], [0x00, 0xff, 0xff], [0xff, 0x00, 0xff], [0xff, 0xff, 0x00] ]; // at the given bit offset |offset| read a 3-bit value from the Atlas read = (offset) =&gt; { let value = 0; for (let i = 0; i &lt; 3; ) { const bit_offset = offset &amp; 7; const read = Math.min(3 - i, 8 - bit_offset); const read_bits = (Atlas[offset &gt;&gt; 3] &gt;&gt; bit_offset) &amp; (~(0xff &lt;&lt; read)); value |= read_bits &lt;&lt; i; offset += read; i += read; } return value; }; // for a given glyph |g| unpack the palette indices for the 5 vertical pixels unpack = (g) =&gt; { return (new Uint8Array(5)).map((_, i) =&gt; read(Alphabet.length*3*i + Alphabet.indexOf(g)*3)); }; // for given glyph |g| decode the 1x5 vertical RGB strip decode = (g) =&gt; { const rgb = new Uint8Array(5*3); unpack(g).forEach((value, index) =&gt; rgb.set(Palette[value], index*3)); return rgb; }</code> </pre> <br><p>  A fun√ß√£o de <code>decode</code> pega um caractere como entrada e retorna a coluna correspondente na imagem de origem.  O que √© impressionante aqui √© que s√£o necess√°rios apenas <strong>5 bytes de</strong> mem√≥ria para decodificar um √∫nico caractere, al√©m de <strong>~ 1,875</strong> bytes para ler a parte desejada da matriz, ou seja,  uma m√©dia de <strong>6,875</strong> por letra.  Se voc√™ adicionar <strong>68 bytes</strong> para armazenar a matriz e <strong>36 bytes</strong> para armazenar o alfabeto, acontece que <em>teoricamente</em> voc√™ pode renderizar texto com 128 bytes de RAM. </p><br><ul><li>  Isso √© poss√≠vel se voc√™ reescrever o c√≥digo em C ou assembler.  No contexto da sobrecarga de JS, isso economiza em correspond√™ncias. </li></ul><br><p>  Resta apenas coletar essas colunas em um √∫nico todo e retornar uma imagem com texto. </p><br><pre> <code class="plaintext hljs">print = (t) =&gt; { const c = t.toUpperCase().replace(/[^\w\d ]/g, ''); const w = c.length * 2 - 1, h = 5, bpp = 3; // * 2 for whitespace const b = new Uint8Array(w * h * bpp); [...c].forEach((g, i) =&gt; { if (g !== ' ') for (let y = 0; y &lt; h; y++) { // copy each 1x1 pixel row to the the bitmap b.set(decode(g).slice(y * bpp, y * bpp + bpp), (y * w + i * 2) * bpp); } }); return {w: w, h: h, data: b}; };</code> </pre> <br><p>  Essa ser√° a menor fonte poss√≠vel. </p><br><pre> <code class="plaintext hljs">const fs = require('fs'); const result = print("Breaking the physical limits of fonts"); fs.writeFileSync(`${result.w}x${result.h}.bin`, result.data);</code> </pre> <br><p>  Adicione uma pequena imagem para obter a imagem em um formato leg√≠vel: </p><br><pre> <code class="plaintext hljs"># convert -size 73x5 -depth 8 rgb:73x5.bin done.png</code> </pre> <br><p>  E aqui est√° o resultado final: </p><br><p><img src="https://habrastorage.org/webt/jv/lf/gs/jvlfgsoyr4xbnxsbzuzax3shp4s.png"></p><br><p>  Tamb√©m √© aumentado em 12 vezes: </p><br><p><img src="https://habrastorage.org/webt/6k/jr/6m/6kjr6md92hgpbm7gvs8ia3o1cti.png"></p><br><p>  √â filmado a partir de uma macro de monitor mal calibrada: </p><br><p><img src="https://habrastorage.org/webt/pd/qp/li/pdqplibvzty8wtoxosah5d3phxe.png"></p><br><p>  E, finalmente, √© melhor no monitor: </p><br><p><img src="https://habrastorage.org/webt/ge/oz/rh/geozrhsclx2squmratxt8flet1a.png"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt460697/">https://habr.com/ru/post/pt460697/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt460675/index.html">Extra√ß√£o de dados de aprendizado de m√°quina</a></li>
<li><a href="../pt460683/index.html">Projetor de Eventos Laravel e conceito de gera√ß√£o de eventos</a></li>
<li><a href="../pt460685/index.html">Distribu√≠mos arquivos do Google Drive usando nginx</a></li>
<li><a href="../pt460687/index.html">Como as latas ficam por dentro</a></li>
<li><a href="../pt460695/index.html">O que √© o DAA e como esse sistema ajuda os drones?</a></li>
<li><a href="../pt460699/index.html">Habr Weekly # 10 / Super servi√ßos e passaporte eletr√¥nico, smartphones e russos, "gadgets de espionagem", vida sem sat√©lites</a></li>
<li><a href="../pt460701/index.html">Curso "Start in Data Science": o primeiro passo no trabalho com dados</a></li>
<li><a href="../pt460703/index.html">Oceano Azul de Oportunidade: de zero a 400 mil entrevistas em v√≠deo</a></li>
<li><a href="../pt460707/index.html">Est√° na hora dos desenvolvedores de jogos pararem de ouvir seus f√£s?</a></li>
<li><a href="../pt460709/index.html">Reflex√µes sobre o Agile</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>