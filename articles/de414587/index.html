<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∑üèø üëºüèº üçº DIY Standalone-Drohne mit Kontrolle √ºber das Internet. Teil 2 √ºber Software ü§∞üèø ‚õπÔ∏è üöé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist eine Fortsetzung der Geschichte einer autonomen Drohne. Der erste Teil sprach √ºber Hardware, dieser wird √ºber Software sprechen. Zun√§chst ein...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DIY Standalone-Drohne mit Kontrolle √ºber das Internet. Teil 2 √ºber Software</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414587/">  Dies ist eine Fortsetzung der Geschichte einer autonomen Drohne.  Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erste Teil</a> sprach √ºber Hardware, dieser wird √ºber Software sprechen.  Zun√§chst ein kleines Schulungsprogramm √ºber die Interaktion des Bedieners mit dem Hubschrauber.  Hier ist ein typisches Layout f√ºr die meisten selbstmontierten Drohnen: <br><br><img src="https://habrastorage.org/webt/f6/jn/na/f6jnnadl96jkvjtcngwxhxogkcu.png" alt="Bild"><br><br>  Und hier ist das Schema f√ºr fortgeschrittene Drohnen: <br><br><img src="https://habrastorage.org/webt/gz/5t/bg/gz5tbg7qqv82_5t86usnrsyhgsg.png" alt="Bild"><br><a name="habracut"></a><br>  So funktionieren Spielzeugdrohnen, die von einem Smartphone aus gesteuert werden: <br><br><img src="https://habrastorage.org/webt/zr/tu/7r/zrtu7r2febul6zxzy2uzrkpf8rq.png" alt="Bild"><br><br>  Sie k√∂nnen die Drohne √ºber das Internet steuern (wenn Sie eine SIM-Karte mit einer statischen IP-Adresse haben): <br><br><img src="https://habrastorage.org/webt/ae/d1/yk/aed1yk46dzosxybjpglxk6bwu5i.png" alt="Bild"><br><br>  Oder wenn die IP-Adresse dynamisch ist: <br><br><img src="https://habrastorage.org/webt/v2/x_/jo/v2x_jo1dtumefo_wekedrufda0o.png" alt="Bild"><br><br>  F√ºr die Zuverl√§ssigkeit und Redundanz von Kommunikationskan√§len kann die letztere Option in einem solchen Zustand entwickelt werden: <br><br><img src="https://habrastorage.org/webt/x6/yz/ho/x6yzhoievpeggh8ya7jo8cmxvo4.png" alt="Bild"><br><br>  Als n√§chstes beschreibe ich den Einrichtungsprozess f√ºr den Emlid Navio 2 Flugcontroller und den Raspberry Pi 3 Mikrocomputer. <br><br><img src="https://habrastorage.org/webt/7g/lr/cv/7glrcvssoyxvii2swoekbsrkuf8.jpeg" alt="Bild"><br>  Mit geringf√ºgigen √Ñnderungen sind diese Einstellungen jedoch f√ºr jeden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Flugcontroller</a> geeignet, mit dem Sie √ºber das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MAVLink-</a> Protokoll in Verbindung mit jedem Computer einer Linux-Betriebssystemfamilie kommunizieren k√∂nnen. <br><br><img src="https://habrastorage.org/webt/bq/6c/my/bq6cmyprlzet6b8w4kemu_nn_ao.png" alt="Bild"><br><br>  <b><u>Wichtig!</u></b>  <b><u>Die Einstellung muss bei ausgeschaltetem Drehzahlregler erfolgen, damit die Motoren nicht versehentlich starten.</u></b> <br><br><h3>  Drohnensteuerungssoftware f√ºr PC und Tablets </h3><br>  Zur Steuerung des UAV werden spezielle GCS-Programme (Ground Control Station) verwendet.  Weiter im Text werde ich diese Abk√ºrzung verwenden.  Ich mochte das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">QGroundControl</a> , ein Open-Source-GCS f√ºr mehrere Plattformen (Windows, Linux, MacOS, iOS, Android), das Teil des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DroneCode-</a> Projekts wurde.  Es gibt jedoch kostenlose und kommerzielle Alternativen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">APM-Planer</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MissionPlanner</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UgCS</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LibrePilot</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenPilot</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tower</a> (DroidPlanner) f√ºr Android, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MAVPilot</a> (iOS), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SidePilot</a> (iOS).  Sowie die Konsole <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MAVProxy</a> . <br><br><h3>  Installieren Sie ein Betriebssystem-Image auf einer SD-Karte </h3><br>  F√ºr den normalen Autopilotbetrieb wird dringend empfohlen, ‚Äûschnelle‚Äú SD-Karten (Klasse 10) zu verwenden.  Langsame Speicherkarten haben auch bei niedriger Frequenz keine Zeit, Autopilot-Protokolle zu speichern, wodurch sie sich als schief oder gar nicht geschrieben herausstellen.  Dies kann auf einen Fehler " <i>Kein E / A-Herzschlag</i> " zur√ºckzuf√ºhren sein, der in der MAVLink-Konsole beobachtet werden kann (wie die MAVLink-Konsole √ºberwacht wird, wird unten beschrieben).  Achten Sie beim Kauf auf die M√∂glichkeit, 4K-Videos zu schreiben: H√∂chstwahrscheinlich handelt es sich um eine schnelle SD.  Leider habe ich dies nach dem Fall der Drohne erfahren, als es notwendig war, die Protokolle zu analysieren und den Grund herauszufinden.  Protokolle waren f√ºr mehrere GCS nicht lesbar.  Der Grund f√ºr das Ausschalten der Motoren w√§hrend des Fluges erwies sich als banal: Ich habe vergessen, die Mindestspannung an der Batterie in den Einstellungen f√ºr den ausfallsicheren Betrieb einzustellen. <br><br>  Laden Sie also das fertige Raspbian Stretch-Image mit vorinstalliertem Ardupilot und ROS von Emlid von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">urspr√ºnglichen Anweisungsseite</a> herunter.  Und wir schreiben es mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Etcher</a> oder einem √§hnlichen Programm auf eine Speicherkarte. <br><br>  Um Raspberry sofort nach dem Einschalten mit Ihrem WiFi-Netzwerk zu verbinden, m√ºssen Sie die Datei <i>wpa_supplicant.conf</i> im Stammverzeichnis der SD-Karte bearbeiten.  Es sollte die folgenden Zeilen enthalten: <br><br><pre><code class="bash hljs">network={ ssid=<span class="hljs-string"><span class="hljs-string">"_wifi_"</span></span> psk=<span class="hljs-string"><span class="hljs-string">"_wifi_"</span></span> }</code> </pre> <br>  Sie k√∂nnen es auch ohne WLAN konfigurieren, indem Sie einen Einplattencomputer mit einem Ethernet-Kabel an den Router anschlie√üen.  Entfernen Sie nun die SD-Karte aus dem PC, legen Sie sie in die Himbeere ein und schalten Sie das Ger√§t ein.  Nach einer halben Minute sollte es im Admin-Bereich des Routers auf der Seite der verbundenen Ger√§te (Navio- <i>Hostname</i> ) angezeigt werden. <br><br><h3>  Aktualisieren des Distributionskits und Installieren der erforderlichen Pakete </h3><br>  √ñffnen Sie den SSH-Client und stellen Sie eine Verbindung zu Raspberry her (lokale Navio-IP-Adresse anstelle von <i>RASPBERRY_IP_ADDRESS</i> ): <br><br><pre> <code class="bash hljs">ssh pi@RASPBERRY_IP_ADDRESS</code> </pre> <br>  Standard Passwort: <i>Himbeere</i> .  Zun√§chst muss das Dateisystem des Betriebssystems auf das gesamte Volume der SD-Karte erweitert werden: <br><br><pre> <code class="bash hljs">sudo raspi-config --expand-rootfs</code> </pre> <br>  und neu starten: <br><br><pre> <code class="bash hljs">sudo reboot</code> </pre> <br>  Stellen Sie nach dem Neustart erneut eine Verbindung her und aktualisieren Sie die Distribution: <br><br><pre> <code class="bash hljs">sudo apt-get update &amp;&amp; sudo apt-get dist-upgrade -y</code> </pre> <br>  Installieren Sie zus√§tzliche Pakete: <br><br><pre> <code class="bash hljs">sudo apt-get install autoconf automake libtool pkg-config libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev libraspberrypi-dev gstreamer1.0-tools gstreamer1.0-plugins-good gstreamer1.0-plugins-bad</code> </pre> <br>  und kompilieren Sie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gst-rpicamsrc-Wrapper</a> f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gstreamer</a> und die native Raspicam-Kamera: <br><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/thaytan/gst-rpicamsrc.git rpicamsrc <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> rpicamsrc chmod +x autogen.sh ./autogen.sh --prefix=/usr --libdir=/usr/lib/arm-linux-gnueabihf/ make sudo make install</code> </pre> <br>  √úberpr√ºfen Sie, ob die Kamera funktioniert (Videodatei test.h264 wird erstellt): <br><br><pre> <code class="bash hljs">gst-launch-1.0 rpicamsrc bitrate=1000000 ! filesink location=test.h264</code> </pre> <br>  Wenn gstreamer startet, warten Sie einige Sekunden, bis das Video aufgenommen wurde.  Sie k√∂nnen den Vorgang unterbrechen, indem Sie <i>Strg + C</i> dr√ºcken <i>.</i>  Wenn es ein Video gibt, funktioniert die Kamera. <br><br><h3>  Konfigurieren und starten Sie Ardupilot </h3><br>  Die Ver√∂ffentlichung neuer Versionen von Ardupilot erfolgt etwas sp√§t in der Montage von Emlid.  Wenn die erforderliche Funktionalit√§t in der neuesten Version verf√ºgbar ist, k√∂nnen Sie sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mithilfe dieser Anweisung</a> von der Quelle installieren. <br><br>  Navio-Entwickler haben ihren Sensoren ein einfaches und praktisches <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Emlid-Tool hinzugef√ºgt,</a> mit dem sie Sensoren √ºberpr√ºfen und Ardupilot einrichten k√∂nnen.  √úberpr√ºfen Sie zun√§chst, ob die Himbeere den Navio-Controller sieht: <br><br><pre> <code class="bash hljs">emlidtool info</code> </pre> <br>  Wenn als Antwort auf diesen Befehl etwas erzeugt wird wie: <br><br><pre> <code class="bash hljs">Vendor: Emlid Limited Product: Navio 2 Issue: Emlid 2018-06-05 831f3b08594f2da17dccae980a2e3659115ef71f Kernel: 4.14.34-emlid-v7+ RCIO firmware: 0xcaec2284</code> </pre> <br>  es bedeutet, dass er sieht.  √úberpr√ºfen Sie den Status der Sensoren (Liste und Status anzeigen): <br><br><pre> <code class="bash hljs">emlidtool <span class="hljs-built_in"><span class="hljs-built_in">test</span></span></code> </pre> <br>  und PWM-Controller-Treiber im Linux-Kernel: <br><br><pre> <code class="bash hljs">cat /sys/kernel/rcio/status/alive</code> </pre> <br>  0 = funktioniert nicht, 1 = funktioniert. <br><br>  Die Firmware des PWM-Controllers wird wie folgt aktualisiert: <br><br><pre> <code class="bash hljs">sudo emlidtool rcio update</code> </pre> <br>  Konfigurieren Sie nun Ardupilot: <br><br><pre> <code class="bash hljs">sudo emlidtool ardupilot</code> </pre> <br>  Im Terminal wird eine Text-GUI mit schrittweisen Men√ºs ge√∂ffnet.  Wir w√§hlen den Copter der neuesten Version aus, geben <i>arducopter ein</i> , <i>starten</i> beim Start <i>automatisch</i> (beim <i>Booten: aktivieren</i> ) und starten nach der Konfiguration ( <i>Ardupilot: start</i> ). <br><br><img src="https://habrastorage.org/webt/w8/p7/yn/w8p7ynlxvrqybsaqrdkqxbk68yy.png" alt="Bild"><br><br>  Wir verlassen den Men√ºpunkt <i>Beenden</i> . <br><br>  √úberpr√ºfen Sie, ob Ardupilot gestartet wurde: <br><br><pre> <code class="bash hljs">sudo systemctl status arducopter</code> </pre> <br>  Bitte beachten Sie, dass die Startdatei in systemd als <u>arducopter bezeichnet wird</u> , da die <i>Copter-</i> Option konfiguriert wurde. <br><br>  Jetzt m√ºssen wir den Ardupilot so konfigurieren, dass er uns Telemetrie sendet.  Bearbeiten Sie dazu die Konfigurationsdatei: <br><br><pre> <code class="bash hljs">sudo nano /etc/default/arducopter</code> </pre> <br>  Es sollte die folgenden Zeilen enthalten: <br><br><pre> <code class="bash hljs">TELEM1=<span class="hljs-string"><span class="hljs-string">"-A udp:127.0.0.1:14550"</span></span> ARDUPILOT_OPTS=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$TELEM1</span></span></span><span class="hljs-string">"</span></span></code> </pre> <br>  Speichern Sie die Datei ( <i>Strg + X</i> , dann <i>Y</i> ) und starten Sie Ardupilot neu: <br><br><pre> <code class="bash hljs">sudo systemctl daemon-reload sudo systemctl restart arducopter</code> </pre> <br>  Sie k√∂nnen den Status des Ardupilot-Prozesses mit dem folgenden Befehl √ºberpr√ºfen: <br><br><pre> <code class="bash hljs">sudo systemctl status arducopter</code> </pre> <br>  Mit diesen Einstellungen √ºbertr√§gt Ardupilot Telemetrie ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MAVLink-</a> Pakete) an den lokalen UDP-Port 14550. Als N√§chstes √ºbernimmt das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MAVProxy-</a> Skript (Beschreibung unten) die Telemetrie von dort und sendet sie an GCS oder das Skript sowie Pakete mit Befehlen in die entgegengesetzte Richtung. <br><br>  Anstelle der lokalen Adresse und des Ports k√∂nnen Sie die IP-Adresse eines PCs oder Tablets im lokalen Netzwerk aufzeichnen, und die Pakete werden sofort dort gesendet. <br><br><img src="https://habrastorage.org/webt/8p/no/vv/8pnovvpynimp8tvucgtqnbvqhls.png" alt="Bild"><br><br>  Dieser Ansatz ist jedoch gerechtfertigt, wenn Telemetriedaten nirgendwo anders verwendet werden und das Ger√§t mit GCS eine statische IP-Adresse hat.  Andernfalls m√ºssen Sie jedes Mal einen neuen Ardupiloten in den Einstellungen registrieren.  Um mit dem Autopiloten √ºber TCP, mehrere GCSs mit dynamischen Adressen und einigen anderen Skripten auf dem Bordcomputer gleichzeitig zu kommunizieren, ist es bequemer, MAVProxy zu verwenden. <br><br><img src="https://habrastorage.org/webt/lt/gu/o6/ltguo6ghxcrnv8syshno6arbwi8.png" alt="Bild"><br><br>  Dieses Skript (in Python geschrieben) kann MAVLink-Pakete an eine lokale UDP-Adresse empfangen und diese √ºber UDP und TCP an mehrere lokale oder Remote-IP-Adressen weiterleiten.  Pakete werden in beide Richtungen an das Ardupilot ‚áî GCS gesendet.  Dar√ºber hinaus ist MAVProxy ein vollwertiges GCS, jedoch mit einer Textschnittstelle. <br><br><h3>  MAVProxy </h3><br>  MAVProxy ist bereits im Navio-Image installiert.  Es kann auch auf einem PC (Windows, Linux, MacOS) f√ºr die weitere Kommunikation mit dem Autopiloten im Konsolenmodus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">installiert</a> werden. <br><br>  Nachdem Sie sichergestellt haben, dass Ardupilot funktioniert, f√ºhren Sie das MAVProxy-Skript auf Raspberry mit dem folgenden Befehl aus: <br><br><pre> <code class="bash hljs">mavproxy.py --master=udp:127.0.0.1:14550</code> </pre> <br>  Der <i>Parameter --master = udp: 127.0.0.1: 14550</i> legt die Datenquelle f√ºr das Skript fest.  Dies ist der lokale UDP-Port, der in der Ardupilot-Konfigurationsdatei registriert wurde.  Nach dem Ausf√ºhren des Befehls stellt MAVProxy eine Verbindung zu diesem Port her und zeigt Autopilot-Meldungen an, √§hnlich wie bei mir: <br><br><pre> <code class="bash hljs">pi@navio:~ $ mavproxy.py --master=udp:127.0.0.1:14550 Connect udp:127.0.0.1:14550 source_system=255 Failed to load module: No module named adsb. Use <span class="hljs-string"><span class="hljs-string">'set moddebug 3'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the MAVProxy console to <span class="hljs-built_in"><span class="hljs-built_in">enable</span></span> traceback Log Directory: Telemetry <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>: mav.tlog Waiting <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> heartbeat from 127.0.0.1:14550 MAV&gt; online system 1 STABILIZE&gt; Mode STABILIZE fence breach GPS lock at 0 meters APM: APM:Copter V3.5.5 (88a1ecdd) APM: Frame: UNKNOWN APM: PreArm: RC Roll not configured APM: PreArm: Compass not calibrated APM: PreArm: 3D Accel calibration needed APM: PreArm: check firmware or FRAME_CLASS APM: PreArm: Throttle below Failsafe</code> </pre> <br>  Da der Autopilot noch nicht kalibriert und nicht vollst√§ndig eingestellt ist, sprechen auch Nachrichten beredt dar√ºber.  In diesem Modus k√∂nnen Sie √ºber Befehle mit dem Autopiloten kommunizieren.  Wenn die Drohne vollst√§ndig abgestimmt w√§re, w√ºrde eine solche Folge von zwei Befehlen zum Starten der Motoren und zum Abheben der Drohne bis zu einer H√∂he von 20 m f√ºhren: <br><br><pre> <code class="bash hljs">arm throttle takeoff 20</code> </pre> <br>  Ein nicht kalibrierter Autopilot fliegt nicht, zeigt jedoch Meldungen mit Gr√ºnden an, warum dies nicht m√∂glich ist. <br><br><h3>  Herstellen der Kommunikation mit der Drohne im lokalen Netzwerk </h3><br>  Stoppen Sie das Skript ( <i>Strg + C</i> ) und f√ºhren Sie es erneut in folgender Form aus: <br><br><pre> <code class="bash hljs">mavproxy.py --master=udp:127.0.0.1:14550 --out=tcpin:0.0.0.0:5762</code> </pre> <br>  Mit dem zus√§tzlichen Parameter <i>--out = tcpin: 0.0.0.0: 5762</i> √ºberwacht MAVProxy Port 5762 auf eingehende TCP-Verbindungen von GCS.  Sobald das GCS eine Verbindung herstellt, werden Datenpakete zwischen der Drohne und dem GCS verschoben.  Versuchen wir, eine Verbindung von einem PC aus herzustellen: <br><br><img src="https://habrastorage.org/webt/8e/zz/eb/8ezzebgztbjr6nkllbyefkdots0.png" alt="Bild"><br><br>  Wenn die Verbindung erfolgreich hergestellt wurde, zeigt GCS eine Reihe von Meldungen mit der Aufforderung an, die Sensoren zu kalibrieren und die integrierten Parameter mit ihren aktuellen Werten zu laden: <br><br><img src="https://habrastorage.org/webt/mz/gy/co/mzgycobpds-e3bk7i5szgplvvey.png" alt="Bild"><br><br><img src="https://habrastorage.org/webt/i1/bx/ms/i1bxms-du1v9tbqpemtfv-sgodw.png" alt="Bild"><br><br><h3>  Kalibrierung von Sensoren und Abstimmung der Autopilot-Parameter </h3><br>  Die Autopilot-Kalibrierung kann in nahezu jedem GCS durchgef√ºhrt werden.  In der Ardupilot-Dokumentation wird dies ausf√ºhrlich beschrieben.  Zun√§chst legen wir den Rahmentyp fest.  Ich habe ein Standard-4-Motor-Layout, das ist also <i>Quad X.</i> <br><br><img src="https://habrastorage.org/webt/mv/gc/bi/mvgcbi8augohhzhrcfrnosuia-s.png" alt="Bild"><br><br>  Der erste Flug wird noch besser im manuellen Modus durchgef√ºhrt.  Wir verbinden und kalibrieren die Funksteuerung (Empf√§nger und Sender). <br><br><img src="https://habrastorage.org/webt/dj/ay/xw/djayxw3ulzuaabk4ubn3qavp0d4.png" alt="Bild"><br><br>  Beschleunigungsmesser und Kompass m√ºssen noch kalibriert werden. <br><br><img src="https://habrastorage.org/webt/bm/rs/1r/bmrs1rhiwgxu2udg11td3t8slak.png" alt="Bild"><br><br>  Stellen Sie die erforderlichen Parameter ein, damit Ardupilot Daten von externen Sensoren sehen und ber√ºcksichtigen kann: <br><br>  F√ºr <u>PX4Flow</u> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kalibrierung des Sensors selbst und Firmware-Update</a> ) <br><br> <code>FLOW_ENABLE = 1 (Enabled) <br> FLOW_ADDR = 0 (0 =     042)</code> <br> <br>  F√ºr Laserh√∂henmesser <u>VL53L0X</u> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anleitung</a> ) <br><br> <code>RNGFND_TYPE = 16 (VL53L0X) <br> RNGFND_ORIENT = 25 (  ) <br> RNGFND_ADDR = 41 (I2C-   ).   - 0x29,     = 41. <br> RNGFND_SCALING = 1 <br> RNGFND_MIN_CM = 5 <br> RNGFND_MAX_CM = 120 <br> RNGFND_GNDCLEAR = 15 (    ,     )</code> <br> <br>  F√ºr <u>IRLock</u> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">detaillierte Anleitung</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wiki IR-Lock</a> ) <br><br> <code>PLND_ENABLED = 1 <br> PLND_TYPE = 2 <br> PLND_BUS = 1</code> <br> <br>  F√ºr Vorderansicht Sonar ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anleitung</a> ) <br><br> <code>RNGFND2_TYPE = 2 (MaxbotixI2C sonar) <br> RNGFND2_ORIENT = 0 (  ) <br> RNGFND2_MAX_CM = 700 (   )</code> <br> <br>  Vollst√§ndige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Liste der</a> Ardupilot- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Optionen</a> . <br><br>  Starten Sie nun Ardupilot √ºber das GCS-Men√º neu, stellen Sie die Verbindung zur Karte wieder her und √∂ffnen Sie das MAVLink Inspector-Fenster, um die Daten von den Sensoren anzuzeigen. <br><br><img src="https://habrastorage.org/webt/6z/x_/8z/6zx_8zmfbc4nflyaxyz-h2yv8zs.png" alt="Bild"><br><br>  Leider sind die Messwerte von IR-Lock hier nicht sichtbar. F√ºr die Analyse seiner Arbeit m√ºssen Sie sich die Protokolle an Bord ansehen.  Wie das geht, wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> beschrieben. <br><br>  Die Sicherheitseinstellungen m√ºssen noch konfiguriert werden, und Sie k√∂nnen die Drohne starten: <br><br><img src="https://habrastorage.org/webt/ex/jp/x-/exjpx-pjkbvzmugdr-r1ujqpziw.png" alt="Bild"><br><br>  Wie man die Kreiselaufh√§ngung konfiguriert und die Hauptkamera im Detail steuert Ich werde in einem der folgenden Artikel schreiben, die Hauptpunkte werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier beschrieben</a> . <br><br><h3>  Video√ºbertragung </h3><br>  Lassen Sie uns √ºberpr√ºfen, wie Video√ºbertragungen im WiFi-Netzwerk funktionieren.  Mit diesem Befehl k√∂nnen Sie Videos in einem TCP-Port auf Raspberry mit dem nativen Dienstprogramm raspivid f√ºr die Raspicam-Kamera ausf√ºhren: <br><br><pre> <code class="bash hljs">raspivid -t 0 -hf -fps 25 -w 640 -h 480 -o - | gst-launch-1.0 fdsrc ! h264parse ! rtph264pay config-interval=1 pt=96 ! gdppay ! tcpserversink host=0.0.0.0 port=5001</code> </pre> <br>  Dieser Befehl macht jedoch dasselbe und verwendet nur den zuvor kompilierten rpi-camsrc-Wrapper f√ºr gstreamer: <br><br><pre> <code class="bash hljs">gst-launch-1.0 rpicamsrc sensor-mode=4 ! h264parse ! rtph264pay config-interval=1 pt=96 ! gdppay ! tcpserversink host=0.0.0.0 port=5001</code> </pre> <br>  In beiden F√§llen ist h264 Broadcast unter der Raspberry IP-Adresse an Port 5001 verf√ºgbar. <br><br>  Sie k√∂nnen es sehen, indem Sie einen solchen Befehl auf Ihrem PC <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausf√ºhren</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gstreamer</a> muss installiert sein). <i>Geben Sie</i> anstelle von <i>RPI_ADDRESS</i> die <i>Himbeeradresse</i> im Netzwerk an: <br><br><pre> <code class="bash hljs">gst-launch-1.0 -v tcpclientsrc host=RPI_ADDRESS port=5001 ! gdpdepay ! rtph264depay ! avdec_h264 ! videoconvert ! autovideosink sync=<span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br>  Infolgedessen sollte sich das Fenster mit dem Video √∂ffnen. <br><br>  Fast jedes GCS verf√ºgt √ºber einen integrierten Videoplayer, der einen RTSP-Videostream anzeigen kann.  Um einen RTSP-Server aus einer Himbeere zu erstellen, k√∂nnen Sie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VLC-</a> Konsolenspieler verwenden.  Installation: <br><br><pre> <code class="bash hljs">sudo apt-get install vlc</code> </pre> <br>  Die Video√ºbertragung beginnt wie folgt: <br><br><pre> <code class="bash hljs">raspivid -o - -t 0 -n -w 320 -h 240 -fps 25 | cvlc -vvv stream:///dev/stdin --sout <span class="hljs-string"><span class="hljs-string">'#rtp{sdp=rtsp://:8554/live}'</span></span> :demux=h264</code> </pre> <br>  Das Video ist verf√ºgbar unter (anstelle von <i>RPI_ADDRESS</i> , <i>Himbeeradresse</i> ): <br><br> <code>rtsp://RPI_ADDRESS:8554/live</code> <br> <br>  GCS-Setup: <br><br><img src="https://habrastorage.org/webt/uk/x8/hu/ukx8huklwh9kxu5glz289xkzenq.png" alt="Bild"><br><br><img src="https://habrastorage.org/webt/7r/og/gw/7roggwghpf_arhxggulllplkr6i.png" alt="Bild"><br><br>  Die Stream-Adresse kann verwendet werden, um mehrere Player auf verschiedenen Ger√§ten zu verbinden. Da die Videoaufnahme und -√ºbertragung f√ºr Raspberry jedoch sehr zeitaufw√§ndig ist, ist es f√ºr mehrere Videokonsumenten besser, einen externen Server zu verwenden (Beschreibung unten). <br><br><h3>  Telemetrie √ºber das Internet </h3><br>  Damit GCS √ºber das Internet eine Verbindung zu einer Drohne mit einer dynamischen IP-Adresse herstellen kann, ist ein Zwischenserver mit einer statischen IP erforderlich, auf dem das MAVProxy-Skript gestartet wird.  Zu diesem Zweck nutzte ich einen Cloud-Server-Verleih von einem der bekanntesten Anbieter.  F√ºr MAVProxy ist die minimalste Konfiguration geeignet, aber da ich denselben Server zum Weiterleiten von Videos verwenden werde, habe ich die Option mit etwas mehr Speicher gew√§hlt (ein Kern und 1 GB Speicher, Ubuntu 18.04).  F√ºr die minimale Verz√∂gerung bei der Daten√ºbertragung zwischen der Karte und dem GCS sollte sich der Server in der maximalen geografischen N√§he zur Drohne und zum GCS befinden. <br><br><img src="https://habrastorage.org/webt/eu/yl/3i/euyl3i1m1s5zjyjl5suhj0gw4sg.png" alt="Bild"><br><br>  Installieren Sie MAVProxy auf dem Server.  Erste Abh√§ngigkeiten: <br><br><pre> <code class="bash hljs">sudo apt-get install python-dev python-opencv python-wxgtk3.0 python-pip python-matplotlib python-pygame python-lxml python-yaml</code> </pre> <br>  und dann das Skript selbst √ºber PIP: <br><br><pre> <code class="bash hljs">sudo pip install MAVProxy</code> </pre> <br>  schreibe den Pfad: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"export PATH=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$PATH</span></span></span><span class="hljs-string">:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$HOME</span></span></span><span class="hljs-string">/.local/bin"</span></span> &gt;&gt; ~/.bashrc</code> </pre> <br>  und f√ºhren Sie das Skript mit den folgenden Parametern aus: <br><br><pre> <code class="bash hljs">mavproxy.py --master=udp:0.0.0.0:15001 --out=tcpin:0.0.0.0:15002</code> </pre> <br>  MAVProxy √ºberwacht Port 15001 auf eingehende Telemetriepakete von der Drohne √ºber UDP und Port 15002 auf eingehende TCP-Verbindungen von GCS. <br><br>  F√ºhren Sie MAVProxy auf Raspberry mit einem weiteren Parameter aus, damit die Telemetrie auch an den Server gesendet wird (anstelle von <i>SERVER_IP die</i> Adresse Ihres Servers): <br><br><pre> <code class="bash hljs">mavproxy.py --master=udp:127.0.0.1:14550 --out=tcpin:0.0.0.0:5762 --out=udpout:SERVER_IP:15001</code> </pre> <br>  Nach dem Starten des Skripts auf dem Bordcomputer werden Meldungen vom Autopiloten in der Serverkonsole angezeigt.  Wie oben erw√§hnt, ist MAVProxy ein vollwertiges GCS mit einer Textschnittstelle. In diesem Zustand ist es bereits m√∂glich, Parameter zu bearbeiten und die Drohne √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Befehle</a> in der Serverkonsole zu steuern. <br><br>  Verbinden Sie das GCS auf dem PC oder Tablet mit dem Server.  Die Verbindungseinstellungen sind dieselben wie f√ºr das lokale Netzwerk, nur dass anstelle der Raspberry-IP-Adresse die Serveradresse und der Port 15002 angegeben werden. <br><br><img src="https://habrastorage.org/webt/8m/ed/rc/8medrcfonj1lsyr1wvufdi2elom.png" alt="Bild"><br><br>  Jetzt k√∂nnen Sie ein 4G-USB-Modem an Raspberry anschlie√üen und die Verz√∂gerung bewerten, mit der der Horizont auf dem Bildschirm reagiert. <br><br><h3>  Internetvideo </h3><br><img src="https://habrastorage.org/webt/7i/w2/ow/7iw2owafcz4bjjmwu116q9tr65i.png" alt="Bild"><br><br>  Installieren Sie den VLC-Player auf dem Server, um das Video weiterzuleiten: <br><br><pre> <code class="bash hljs">sudo apt-get install vlc</code> </pre> <br>  F√ºhren Sie es nach der Installation als Relay vom UDP-Port 5001 im RTSP-Kanal <i><b>SERVER_IP: 8554 / live</b></i> : <br><br><pre> <code class="bash hljs">cvlc -vvv udp://@:5001 --sout <span class="hljs-string"><span class="hljs-string">'#rtp{sdp=rtsp://:8554/live}'</span></span> :demux=h264</code> </pre> <br>  An Bord starten wir die Video√ºbertragung von der Kamera √ºber UDP zum Server (anstelle der <i>Serveradresse SERVER_IP</i> ): <br><br><pre> <code class="bash hljs">gst-launch-1.0 rpicamsrc bitrate=1000000 ! video/x-h264,width=640,height=480,framerate=25/1 ! h264parse ! udpsink host=SERVER_IP port=5001</code> </pre> <br>  Die Stream-Adresse kann jetzt in den GCS-Einstellungen als Videoquelle verwendet oder in jedem Player ge√∂ffnet werden, der dieses Protokoll unterst√ºtzt. <br><br>  Jetzt k√∂nnen Sie die Flugroute planen und die Drohne √ºber das Internet starten, nachdem Sie sie zuvor beispielsweise mit dem Telefonassistenten eingeschaltet haben. <br><br>  Aufgrund der relativ langen Reisezeit von Video und Telemetrie √ºber das Netzwerk ist diese Methode offensichtlich kaum f√ºr FPV-Fl√ºge im manuellen Modus zwischen Hindernissen geeignet. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/43rqRE9f1hA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Themen f√ºr sp√§tere Ver√∂ffentlichungen: <br><br><ul><li>  Optionen zum automatischen Laden der Drohne in meinem Vogelhaus und bei welcher ich angehalten habe. </li><li>  Implementieren von webbasiertem GCS mit MAVProxy, NodeJS, socket.io und einem Medienserver zur gleichzeitigen Verwaltung mehrerer Drohnen. </li><li>  Redundante Kommunikationskan√§le und Drohnenrettungssysteme </li><li>  Bildverarbeitung und Lidars zur Vermeidung von Kollisionen mit Hindernissen </li></ul><br>  Fortsetzung folgt‚Ä¶ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414587/">https://habr.com/ru/post/de414587/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414577/index.html">Devilution: Diablo Reverse Engineering Projekt</a></li>
<li><a href="../de414579/index.html">Google AI hat gelernt, vorherzusagen, wann ein Patient sterben wird (aber nicht alles ist so d√ºster)</a></li>
<li><a href="../de414581/index.html">Wo ist sein Knopf ?! Wie kann eine einfache Person Daten aus Kibana und Elasticsearch entladen und die Entwickler nicht belasten?</a></li>
<li><a href="../de414583/index.html">RIT ++, Tech RaDarts und alles in allem</a></li>
<li><a href="../de414585/index.html">Wie meine String.getBytes (UTF_8) kaputt gingen und was ich damit gemacht habe</a></li>
<li><a href="../de414589/index.html">Sberbank Collaborative Robotics: Was f√ºr einen Roboter k√∂nnen wir mit Ihnen machen?</a></li>
<li><a href="../de414593/index.html">Vergleich von C # und JavaScript. Die Grundlagen</a></li>
<li><a href="../de414597/index.html">Fragen Sie Ethan: Wie nahe k√∂nnen au√üerirdische Zivilisationen zusammenkommen?</a></li>
<li><a href="../de414605/index.html">Mini-Imperien</a></li>
<li><a href="../de414609/index.html">Kann 2018 PWA (Progressive Web Apps) ein w√ºrdiger Wettbewerb f√ºr native Anwendungen sein?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>