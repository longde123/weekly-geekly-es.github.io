<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚻 🧙🏻 ❗️ Einfache Programmierung: Kanban-Board für GitLab an einem Arbeitstag 👩🏿‍🚀 🔪 👰🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Arbeitsmontag begann mit folgendem Dialog: 

 Anführer (P): In Ihrem Team ist nicht klar, wer was tut. 
 I (I): Ja, wir haben kein Tool, das das a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einfache Programmierung: Kanban-Board für GitLab an einem Arbeitstag</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lanit/blog/462855/"><blockquote>  Der Arbeitsmontag begann mit folgendem Dialog: <br><br>  Anführer (P): In Ihrem Team ist nicht klar, wer was tut. <br>  I (I): Ja, wir haben kein Tool, das das allgemeine Bild der Arbeit an Aufgaben widerspiegelt.  Es gibt Kanban-Boards im Hitlab, aber sie sind nur im Kontext von Projekten und Gruppen.  Ein gemeinsames Kanban-Board würde das Problem lösen. <br>  R: Dann mach ein Brett. <br>  Ich: Am Morgen wird es fertig sein. </blockquote><br>  Früher <s>oder später kommt der</s> Moment im Leben eines Anfängerteamleiters, als er erkennt, dass sein Team ein Kanban-Board benötigt.  Es beseitigt die Angst vor der Kontrolle des Entwicklungsprozesses und gibt Vertrauen in die Zukunft.  Normalerweise wird dieses Problem durch die niedrigste Aufforderung an den Manager gelöst, eine Magnettafel, einen Satz mehrfarbiger Aufkleber und einige Markierungen für die Platine zu kaufen.  Nun, oder mit Diensten wie Jira.  Unser Team hat jedoch einen Entwickler auf der Fernbedienung und Gitlab in einem geschlossenen Kreislauf (aus Gründen der Informationssicherheit nicht im Internet verfügbar). Daher musste ich die einfachste von zwei möglichen Lösungen auswählen: <br><br>  a) die Schaffung eines mechanischen Arms und eines Controllers dafür, der die Aufkleber aus der Ferne wieder auf die Tafel klebt. Um die Entscheidung nicht zu erschweren, müssen wir die Aufkleber für unseren unzugänglichen Kollegen aufschreiben, was unfair ist. <br>  b) Implementierung eines Software-Kanban-Boards, das alle Aufgaben von unserem Hitlab sammelt. <br><br>  Natürlich lag die Seele an der Röhre des physischen Brettes.  Ich habe sogar darüber nachgedacht, DualShock 4 als mechanische Armsteuerung zu verwenden, aber ich selbst habe die Frist am nächsten Morgen festgelegt, sodass ich mit einer seelenlosen Softwarelösung auskommen musste. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/py/y1/nr/pyy1nr-n2oomevtit82fe-6hkk4.jpeg"></div><a name="habracut"></a><br>  Bevor ich den technischen Teil der Geschichte beschreibe, erzähle ich Ihnen, wie wir Gitlab in Onlanta verwenden.  Die Gruppen im Hitlab, die wir haben, entsprechen dem internen / externen Kunden oder einem separaten großen Projekt, und das Projekt ist ein Repository für den Code eines bestimmten Dienstes.  Zum Beispiel haben wir eine Gruppe von Abrechnungskontrollfeldern, in denen vier Projekte Dienste und Webanwendungen sind, und es gibt eine Marketinggruppe, in der es ein Projekt für eine Unternehmenswebsite, einen Mikroservice für die Integration mit amoCRM, alle Arten von Zielseiten usw. gibt.  Wir haben derzeit neun aktive Gruppen und es gibt weniger Programmierer, sodass alle Programmierer an allen Gruppen teilnehmen. <br><br>  Und alles, was wir brauchten, war eine Seite mit allen Aufgaben aus dem Hitlab, aus allen Gruppen und Projekten, aber diese Funktionalität in GitLab ist leider nicht.  Quick Google hat daher nicht geholfen, eine eigenständige Lösung zu finden <br><br><h2>  Wir werden brauchen: </h2><br>  - Backend auf Node.js - zum Sammeln von Aufgaben mit GitLab und zum Übertragen auf den Client; <br>  - Client auf Vue.js - um es schnell und schön zu machen; <br>  - natürlich alles mit TypeScript würzen! <br>  - PostgreSQL - wo wir Informationen über Aufgaben und ihre Position an der Tafel speichern; <br>  - 8 Stunden Arbeitszeit; <br>  - gute Laune. <br><br>  Die wichtigste Bedingung ist, dass die Entwicklung einfach und unterhaltsam sein sollte. Nennen wir es "einfache Programmierung". <br><br><h2>  Der Zoo </h2><br>  Aus offensichtlichen Gründen kann ich die Projekte und Aufgaben aus unserem Unternehmens-Hitlab nicht verwenden, um den Artikel über Habré zu veranschaulichen. Deshalb habe ich mein Hitlab mit Affen und Krokodilen bereitgestellt.  Ja, dies ist ein Gitlab für einen fiktiven Zoo, aber dort werden nicht weniger ernsthafte Aufgaben gestellt als in jedem anderen Gitlab.  Schauen Sie sich die Liste der Projekte an: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ie/z3/wj/iez3wjnmgipdeidl53j1jlwmgrk.jpeg"></div><br><h2>  Karcass </h2><br>  Im Laufe der Jahre der Entwicklung habe ich meine eigene Vision entwickelt, wie die Backend-Anwendung auf Node.js erstellt werden soll, und dieser Ansatz hatte die Form eines Frameworks - einer Reihe von Dateien.  Um ein neues Projekt zu erstellen, habe ich einfach das Verzeichnis mit der Vorlage kopiert.  Dies konnte nicht ewig so weitergehen, und ich erstellte das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Karcass-Npm-</a> Paket (der Name <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Carcass</a> wurde bereits von demselben Fahrrad-Enthusiasten wie ich übernommen), das den Prozess der Erstellung der Basis für die Anwendung automatisiert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rk/uz/8f/rkuz8fkc3bpzr4dksqgerrganjo.gif"></div><br>  Jetzt müssen wir uns mit dem Empfang und der Speicherung von Gruppen, Projekten, Aufgaben und natürlich Darstellern befassen. <br><br><h2>  TypeORM </h2><br><blockquote>  <i>"Ich sehe einige Entitäten ..."</i> <br>  <sup>- aus Diskussionen im Hellseher-Forum</sup> </blockquote><br>  Da wir die Daten aus dem Gitlab in einer für uns geeigneten Form präsentieren müssen, müssen wir sie zwischen dem Sammeln und Präsentieren dieser Daten irgendwie speichern.  Kürzlich entdeckte ich die erstaunliche Bibliothek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TypeORM</a> für die Arbeit mit Datenbanken, die für das JS-Ökosystem erstaunlich ist.  Es ist immer noch grün, hat aber jede Chance, Sequelize vom Thron zu verdrängen. <br><br>  In wenigen zehn Minuten werden Migrationen und Klassen für <a href="">Benutzer</a> , <a href="">Gruppen</a> , <a href="">Projekte</a> und <a href="">Aufgaben</a> angezeigt.  Hier ist einer von ihnen: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Entity, PrimaryColumn, Column } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'typeorm'</span></span> @Entity({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'group'</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Group</span></span></span><span class="hljs-class"> </span></span>{ @PrimaryColumn(<span class="hljs-string"><span class="hljs-string">'integer'</span></span>) public id!: number @Column(<span class="hljs-string"><span class="hljs-string">'varchar'</span></span>) public name!: string @Column(<span class="hljs-string"><span class="hljs-string">'varchar'</span></span>) public url!: string }</code> </pre> <br>  Und um Migrationen zu erstellen, habe ich wieder ein <a href="">CreateMigrationCommand-</a> Assistentenrad erstellt.  Dieser Befehl ist sehr einfach zu verwenden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/am/s4/du/ams4duyc_iym2w-mwe3lkkgdmkq.gif"></div><br>  In der Issue-Klasse fügen wir zusätzlich zu den Feldern, in denen Daten aus Gitlab gespeichert sind, Felder hinzu, aufgrund derer die ganze Aufregung begann, dh die Position der Aufgabe auf der Kanban-Tafel angibt: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Issue</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> @Column(<span class="hljs-string"><span class="hljs-string">'varchar'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'kanban_status'</span></span> }) public kanbanStatus?: <span class="hljs-string"><span class="hljs-string">'new'</span></span>|<span class="hljs-string"><span class="hljs-string">'planed'</span></span>|<span class="hljs-string"><span class="hljs-string">'working'</span></span>|<span class="hljs-string"><span class="hljs-string">'checking'</span></span>|<span class="hljs-string"><span class="hljs-string">'done'</span></span> @Column(<span class="hljs-string"><span class="hljs-string">'int'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'kanban_order'</span></span> }) public kanbanOrder?: number }</code> </pre> <br><h2>  Wir brauchen Informationen </h2><br>  Als ich anfing, GitLab kennenzulernen, schien es mir ein einfaches (gelesenes „gehasstes“) Produkt zu sein, aber als ich jeden Tag damit arbeitete, wurde mir klar, wie falsch ich war.  Diesmal war ich also überrascht - es stellt sich heraus, dass GitLab über eine sehr umfangreiche API verfügt, die fast alle über die Benutzeroberfläche verfügbaren Funktionen abdeckt.  Um unser Problem zu lösen, benötigen Sie jedoch nur vier Methoden, deren Namen für sich sprechen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">/ Benutzer</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">/ Gruppen</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">/ Projekte</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">/ Projekte /: ID / Probleme</a> .  GitlabService ist für die direkte Interaktion mit GitLab verantwortlich, und andere Klassen greifen darauf zu.  Die Implementierung der updateGroups-Methode der GroupService-Klasse sieht beispielsweise folgendermaßen aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroupService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> updateGroups() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.app.gitlabService.getGroups()) { <span class="hljs-comment"><span class="hljs-comment">// &lt;=     GitlabService let group = await this.getGroup(data.id) if (!group) { group = this.groupRepository.create({ id: data.id, }) } group.name = data.name group.url = data.web_url await this.groupRepository.save(group) } } /* ... */ }</span></span></code> </pre> <br>  Der Befehl <a href="">updateProjectsCommand</a> ist dafür verantwortlich, Informationen vom Gitab abzurufen und die relevanten Informationen in unserer Datenbank zu aktualisieren, die über die Konsole aufgerufen werden können. Unsere Anwendung startet sie jedoch selbst mit der in der Konfiguration angegebenen Häufigkeit: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Application</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> protected initCron() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.config.gitlab.updateInterval) { setInterval(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.updateProjectsCommand) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.updateProjectsCommand = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UpdateProjectsCommand(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.updateProjectsCommand.execute() }, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.config.gitlab.updateInterval * <span class="hljs-number"><span class="hljs-number">1000</span></span>) } } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br>  Wir werden die Anzahl, Farbe und den Namen der Spalten auf der Platine nicht fest codieren, sondern sie in config.js anpassbar machen.  Wir haben fünf davon, aber für jemanden werden vielleicht nur zwei benötigt und saure Farbe: <br><br><pre> <code class="javascript hljs">columns: [ { <span class="hljs-attr"><span class="hljs-attr">key</span></span>: <span class="hljs-string"><span class="hljs-string">'new'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">'rgb(255, 255, 219)'</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">key</span></span>: <span class="hljs-string"><span class="hljs-string">'planed'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">'rgb(236, 236, 191)'</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">key</span></span>: <span class="hljs-string"><span class="hljs-string">'working'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">'rgb(253, 214, 162)'</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">key</span></span>: <span class="hljs-string"><span class="hljs-string">'checking'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">'rgb(162, 226, 253)'</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">key</span></span>: <span class="hljs-string"><span class="hljs-string">'done'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">'rgb(162, 253, 200)'</span></span> }, ],</code> </pre> <br>  Die Hauptsache ist, dass es mindestens zwei geben sollte, sonst wird die Anwendung nicht gestartet. <br><br>  Um mit der Front zu interagieren, benötigen wir eine Methode, die Aufgaben aus der Datenbank empfängt und in „Spalten“ sortiert: <br><br><div class="spoiler">  <b class="spoiler_title">Show IssueService.ts</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IssueService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> getKanban() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> issues = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.issueRepository.find({ <span class="hljs-attr"><span class="hljs-attr">where</span></span>: { <span class="hljs-attr"><span class="hljs-attr">updatedTimestamp</span></span>: MoreThanOrEqual(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>().getTimestamp() - <span class="hljs-number"><span class="hljs-number">60</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span> * <span class="hljs-number"><span class="hljs-number">24</span></span> * <span class="hljs-number"><span class="hljs-number">30</span></span>) }, <span class="hljs-attr"><span class="hljs-attr">order</span></span>: { <span class="hljs-attr"><span class="hljs-attr">kanbanOrder</span></span>: <span class="hljs-string"><span class="hljs-string">'ASC'</span></span>, <span class="hljs-attr"><span class="hljs-attr">updatedTimestamp</span></span>: <span class="hljs-string"><span class="hljs-string">'DESC'</span></span> }, }) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> keys = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.app.config.columns.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c</span></span></span><span class="hljs-function"> =&gt;</span></span> c.key) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result: { [key: string]: Issue[] } = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ki = keys.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; ki &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; ki--) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> key = keys[ki] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ki === keys.length - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//        result[key] = issues.filter(i =&gt; i.closed) } else if (ki === 0) { // ,  ,    ,    result[key] = issues } else { result[key] = issues.filter(i =&gt; i.kanbanStatus === key) } issues = issues.filter(i =&gt; !result[key].includes(i)) //     } return result } /* ... */ }</span></span></code> </pre> </div></div><br>  Und ein Controller, der neue Aufgabenpositionen speichert: <br><br><div class="spoiler">  <b class="spoiler_title">Show IssueController.ts</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IssueController</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> kanbanUpdate(data: IQueryData) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> keys = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.app.config.columns.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c</span></span></span><span class="hljs-function"> =&gt;</span></span> c.key) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> data.params <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> { <span class="hljs-attr"><span class="hljs-attr">key</span></span>: string, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: string, <span class="hljs-attr"><span class="hljs-attr">color</span></span>: string, <span class="hljs-attr"><span class="hljs-attr">issues</span></span>: number[] }[]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keys.indexOf(c.key) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> c.issues) { index++ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> issue = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.app.issueService.getIssue(i) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!issue) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> } issue.kanbanStatus = c.key issue.kanbanOrder = index <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.app.issueService.issueRepository.save(issue) } } } }</code> </pre> </div></div><br>  Stosh.  Wir sammeln Informationen von GitLab, bereiten Daten für die Anzeige des Boards vor und wissen sogar, wie aktualisierte Aufgabenpositionen auf dem Board gespeichert werden.  Das einzige was noch übrig ist, ist das Board selbst zu machen.  Und hier sind wir mit einem mächtigen Werkzeug bewaffnet: <br><br><h2>  Vue CLI - Anstelle von tausend Wörtern </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rt/re/r8/rtrer806kqdf2v9vkv_noeu-iyq.gif"></div><br><h2>  TSX </h2><br>  Um das Refactoring, das Auffinden von Fehlern, das Flusen und andere Probleme zu erleichtern, verwenden wir Tsx-Vorlagen, die Vue.js <sup>fast</sup> sofort unterstützt <sup>*</sup> .  Zum Beispiel die wichtigste Komponente in unserem Board, die Komponente der Aufgabenpräsentation: <br><br><div class="spoiler">  <b class="spoiler_title">Code anzeigen Issue.tsx</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Vue, Component, Prop, Watch } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vue-property-decorator'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./Issue.css'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { CreateElement, VNode } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vue'</span></span> interface IIssue { <span class="hljs-attr"><span class="hljs-attr">groupId</span></span>: number groupName: string groupUrl: string projectName: string projectUrl: string url: string title: string executor: { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: string, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: string } spent: number estimate: number } @Component <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vue</span></span></span><span class="hljs-class"> </span></span>{ @Prop() public issue!: IIssue public issueValue!: IIssue public selectUser = <span class="hljs-literal"><span class="hljs-literal">false</span></span> @Watch(<span class="hljs-string"><span class="hljs-string">'issue'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">immediate</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }) public onIssueChange() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.issueValue = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.issue } <span class="hljs-comment"><span class="hljs-comment">// eslint-disable-next-line @typescript-eslint/no-unused-vars public render(h: CreateElement): VNode { return &lt;div class="kvcIssue"&gt; &lt;div class="kvciTitle"&gt; { this.issueValue.groupId ? &lt;small&gt;&lt;a href={ this.issueValue.groupUrl } target="_blank"&gt; { this.issueValue.groupName } &lt;/a&gt; / &lt;/small&gt; : undefined } &lt;a href={ this.issueValue.projectUrl } target="_blank"&gt;{ this.issueValue.projectName }&lt;/a&gt; &lt;/div&gt; &lt;div class="kvciText"&gt;&lt;a href={ this.issueValue.url } target="_blank"&gt;{ this.issueValue.title }&lt;/a&gt;&lt;/div&gt; &lt;div class={ ['kvciExecutor', this.issueValue.executor ? '' : 'none'] }&gt; &lt;span class="timeTd"&gt; &lt;span title=" "&gt;{ this.issueValue.spent.time() }&lt;/span&gt; / &lt;span title=" "&gt; { this.issueValue.estimate.time() }&lt;/span&gt; &lt;/span&gt; { this.issueValue.executor ? &lt;span class="kvcieUser" style={ { background: this.issueValue.executor.color } }&gt; { this.issueValue.executor.name } &lt;/span&gt; : &lt;span class="kvcieSelect"&gt; &lt;/span&gt; } &lt;/div&gt; &lt;/div&gt; } }</span></span></code> </pre> </div></div><br>  Diese Komponente zeigt eine Taskleiste an.  Beachten Sie, dass die Aufgabe tatsächlich Zeit aufgewendet und geplant hat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pv/hm/xg/pvhmxgsviyekg9e0ajxc8rszmje.png"></div><br>  Es gibt auch <a href="">Column.tsx-</a> und <a href="">Kanban.tsx-Komponenten</a> .  Nur drei Komponenten bieten die Darstellung von Aufgaben an der Tafel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/f_/cg/rz/f_cgrz6koa31rvzod4afs4ivv1o.gif"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vue.Draggable</a> , dessen Beine aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SortableJS</a> wachsen, ist für das Verschieben von Aufgaben auf dem Board verantwortlich.  Es ist sehr einfach zu bedienen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Draggable <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vuedraggable'</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vue</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> public render(h: CreateElement): VNode { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> &lt;Draggable <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"kvcIssues"</span></span> vModel={ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.issuesValue } group={ { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'issues'</span></span>, <span class="hljs-attr"><span class="hljs-attr">pull</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">put</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } onEnd={ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onDrag } onAdd={ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onDrag } &gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.issuesValue.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> &lt;Issue key={ i.id } issue={ i } /&gt;) } &lt;<span class="hljs-regexp"><span class="hljs-regexp">/Draggable&gt; /</span></span>* ... *<span class="hljs-regexp"><span class="hljs-regexp">/ } }</span></span></code> </pre> <br>  Sicherlich haben Sie bemerkt, dass jeder Benutzer seine eigene Farbe hat, mit der das Login angezeigt wird.  Dies ist sehr praktisch - unter einer Reihe von Aufgaben können Sie schnell Ihre eigenen finden.  Es gibt zwei Möglichkeiten, um „Mehrfarben“ zu erreichen: die Farbe mit den Händen für jeden Benutzer festzulegen oder sie basierend auf etwas zu generieren. <br><br><h2>  Geben Sie mir Ihren Benutzernamen und ich sage Ihnen, welche Farbe Sie haben </h2><br>  Der Farbwähler der Benutzerklasse ist für die Farbgenerierung verantwortlich.  Ich habe diese Funktionalität speziell im Backend implementiert, da ich Kryptografie benötigte und es ein Verbrechen ist, eine ganze Bibliothek für eine so kleine Aufgabe nach vorne zu ziehen.  Und es ist richtiger, wenn die Rückseite und nicht die Vorderseite für die Eigenschaften von Entitäten verantwortlich ist: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> public get color() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hash = crypto.createHash(<span class="hljs-string"><span class="hljs-string">'md5'</span></span>).update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.username).digest() <span class="hljs-comment"><span class="hljs-comment">//  md5       .     -   . const result: number[] = [] for (let i = 0; i &lt; 3; i++) { result.push(Math.round(200 - hash[i] / 255 * 150)) //      ,     ,       } return `rgb(${result.join(', ')})` } }</span></span></code> </pre> <br>  Für diejenigen, die wissen wollen, welche Farbe für sie bestimmt ist, war ich nicht zu faul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, um das Snippet auf CodePen zu schneiden</a> . <br><br><h2>  Das ist alles </h2><br><blockquote>  Der Arbeitsdienstag begann mit folgendem Dialog: <br><br>  R: Nun, wie ist das Board fertig? <br>  Ich: Ja, hier. <br>  R: Oh, cool! </blockquote><br>  Das Ergebnis meines "Arbeitstages" liegt hier: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/onlanta/kanban</a> .  Sie können es nicht nur sehen, berühren, sondern auch verwenden (Anweisungen dort).  Und Sie können darauf einen ganzen Zeit-Tracker für Hitlab aufbauen, den wir in der Firma gemacht haben. <br><br>  Warum habe ich beschlossen, diese Notiz zu schreiben?  Dies ist einer der jüngsten Glanzmomente in meiner beruflichen Tätigkeit, als die Aufgabe wichtig, interessant und gleichzeitig recht einfach war und sich herausstellte, dass ihre Lösung einfach und elegant war.  Ich schlage in den Kommentaren vor, ähnliche Aufgaben aus Ihrer Praxis in Erinnerung zu rufen. <br><br><div class="spoiler">  <b class="spoiler_title">Wo sind wir ohne freie Stellen?</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Führender Systemingenieur VMware</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Full-Stack-Entwickler</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Systemarchitekt</a> </li></ul></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462855/">https://habr.com/ru/post/de462855/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462845/index.html">Massage für Ihr Gehirn: Sprechen Sie über ASMR</a></li>
<li><a href="../de462847/index.html">Hewlett Packard Enterprise-Webinare von August bis Oktober 2019</a></li>
<li><a href="../de462849/index.html">Irgendwas mit Inode</a></li>
<li><a href="../de462851/index.html">Wir bieten einen Cloud-Service für die Verwaltung von Verbrauchsmaterialien (Angular + Firebase).</a></li>
<li><a href="../de462853/index.html">Aktualisieren von Statistiken zu sekundären Replikaten der Verfügbarkeitsgruppe</a></li>
<li><a href="../de462859/index.html">Wie ein europäisches Busunternehmen in Russland operiert: Wie unterscheiden sich Busse und Fahrgäste?</a></li>
<li><a href="../de462863/index.html">21. August Sendung Zabbix Moscow Meetup # 5</a></li>
<li><a href="../de462867/index.html">Auswählen eines Farbschemas für Ihre App: Wie machen Sie es einfach?</a></li>
<li><a href="../de462869/index.html">Agileanisches Projektmanagementsystem</a></li>
<li><a href="../de462875/index.html">So senken Sie Kosten und bieten optimalen IT-Support für das Geschäftsmodell. Wir suchen den „mittleren Weg der Erlösung“</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>