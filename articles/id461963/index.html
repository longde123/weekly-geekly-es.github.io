<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ“¢ ğŸ“ ğŸª Pengurangan argumen templat kelas ğŸŒ¼ ğŸ‘©ğŸ¼â€ğŸ“ ğŸ˜µ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Standar C ++ 17 menambahkan fitur baru ke bahasa: Pengurangan Argumen Templat Kelas (CTAD) . Seiring dengan fitur-fitur baru di C ++, secara tradision...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengurangan argumen templat kelas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461963/"><p><img src="https://habrastorage.org/webt/od/-t/zm/od-tzmtj9pxbfzw-hrpd7ml2gpw.jpeg"></p><br><p>  Standar C ++ 17 menambahkan fitur baru ke bahasa: <strong>Pengurangan Argumen Templat Kelas (CTAD)</strong> .  Seiring dengan fitur-fitur baru di C ++, secara tradisional menambahkan cara baru untuk memotret anggota tubuh mereka sendiri.  Dalam artikel ini kita akan memahami apa CTAD itu, apa yang digunakan untuk, bagaimana menyederhanakan hidup, dan apa jebakan yang dikandungnya. </p><a name="habracut"></a><br><h2 id="nachnyom-izdaleka">  Mari kita mulai dari jauh </h2><br><p>  Ingat apa yang dimaksud dengan <em>Pengurangan Argumen Templat</em> dan untuk apa.  Jika Anda merasa cukup percaya diri dengan templat C ++, Anda dapat melewati bagian ini dan segera melanjutkan ke yang berikutnya. </p><br><p>  Sebelum ke C ++ 17, output dari templat parameter hanya diterapkan pada templat fungsi.  Saat membuat contoh templat fungsi, Anda tidak dapat secara eksplisit menentukan argumen templat yang dapat disimpulkan dari jenis argumen fungsi yang sebenarnya.  Aturan untuk menyimpulkan cukup rumit, mereka dikhususkan untuk seluruh bagian <strong>17.9.2</strong> dalam Standar <strong>[temp.deduct]</strong> (selanjutnya saya merujuk pada versi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">draft Standar yang</a> tersedia secara bebas; dalam versi mendatang, penomoran bagian dapat berubah, jadi saya sarankan mencari dengan kode mnemonik yang ditentukan dalam kurung kotak). </p><br><p> Kami tidak akan menganalisis secara terperinci semua seluk-beluk aturan ini, hanya diperlukan oleh pengembang kompiler.  Untuk penggunaan praktis, cukup mengingat aturan sederhana: kompiler dapat secara independen menurunkan argumen templat fungsi, jika ini dapat dilakukan dengan jelas berdasarkan informasi yang tersedia.  Saat menurunkan jenis parameter parameter templat, transformasi standar diterapkan seperti saat memanggil fungsi biasa ( <em>const</em> dibuang dari tipe literal, array dikurangi menjadi pointer, referensi fungsi dikurangi menjadi pointer fungsi, dll.). </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } int some_func(double d) { return static_cast&lt;int&gt;(d); } int main() { const int i = 123; func(i); // func&lt;int&gt; char arr[] = "Some text"; func(arr); // func&lt;char *&gt; func(some_func); // func&lt;int (*)(double)&gt; return 0; }</span></span></code> </pre> <br><p>  Semua ini menyederhanakan penggunaan templat fungsi, tetapi, sayangnya, sepenuhnya tidak dapat diterapkan pada templat kelas.  Saat membuat instance templat kelas, semua parameter templat non-default harus ditentukan secara eksplisit.  Karena properti yang tidak menyenangkan ini, seluruh keluarga fungsi gratis dengan awalan <em>make_</em> muncul di perpustakaan standar: <em>make_unique</em> , <em>make_share</em> , <em>make_pair</em> , <em>make_tuple</em> , dll. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  auto tup1 = std::tuple&lt;int, char, double&gt;(123, 'a', 40.0); //   auto tup2 = std::make_tuple(123, 'a', 40.0);</span></span></code> </pre> <br><h2 id="novoe-v-c17">  Baru di C ++ 17 </h2><br><p>  Dalam Standar baru, dengan analogi dengan parameter templat fungsi, parameter templat kelas diturunkan dari argumen yang disebut konstruktor: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">pair </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">45.67</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// std::pair&lt;bool, double&gt; std::tuple tup(123, 'a', 40.0); // std::tuple&lt;int, char, double&gt; std::less l; // std::less&lt;void&gt;,     std::less&lt;&gt; l template &lt;typename T&gt; struct A { A(T,T); }; auto y = new A{1, 2}; //  A&lt;int&gt; auto lck = std::lock_guard(mtx); // std::lock_guard&lt;std::mutex&gt; std::copy_n(vi1, 3, std::back_insert_iterator(vi2)); //       template &lt;typename T&gt; struct F { F(T); } std::for_each(vi.begin(), vi.end(), Foo([&amp;](int i) {...})); // F&lt;lambda&gt;</span></span></code> </pre> <br><p>  Segera perlu disebutkan pembatasan CTAD yang berlaku pada saat C ++ 17 (mungkin pembatasan ini akan dihapus dalam versi Standar yang akan datang): </p><br><ul><li>  CTAD tidak berfungsi dengan alias template: </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> X&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PairIntX = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, X&gt;; PairIntX p{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre> <br><ul><li>  CTAD tidak mengizinkan sebagian hasil argumen (cara kerjanya untuk <em>Pengurangan Argumen Templat</em> biasa): </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair p{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// OK std::pair&lt;double&gt; q{1, 5}; // ,   std::pair&lt;double, int&gt; r{1, 5}; // OK</span></span></code> </pre> <br><p>  Selain itu, kompiler tidak akan dapat menyimpulkan jenis parameter templat yang tidak secara eksplisit terkait dengan jenis argumen konstruktor.  Contoh paling sederhana adalah konstruktor kontainer yang menerima sepasang iterator: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyVector</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> It&gt; MyVector(It from, It to); }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; dv = {<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>, <span class="hljs-number"><span class="hljs-number">5.0</span></span>, <span class="hljs-number"><span class="hljs-number">7.0</span></span>}; MyVector v2{dv.begin(), dv.end()}; <span class="hljs-comment"><span class="hljs-comment">//     T   It</span></span></code> </pre> <br><p>  Jenis <em>ini</em> tidak terkait langsung dengan <em>T</em> , meskipun kami pengembang tahu persis cara mendapatkannya.  Untuk memberi tahu kompiler bagaimana cara menghasilkan tipe yang tidak berhubungan secara langsung, konstruksi bahasa baru muncul di C ++ 17 - <em>panduan deduksi</em> , yang akan kita bahas di bagian selanjutnya. </p><br><h2 id="deduction-guides">  Panduan pengabdian </h2><br><p>  Untuk contoh di atas, <em>panduan deduksi</em> akan terlihat seperti ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> It&gt; MyVector(It, It) -&gt; MyVector&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::iterator_traits&lt;It&gt;::value_type&gt;;</code> </pre> <br><p>  Di sini kita memberi tahu kompiler bahwa untuk konstruktor dengan dua parameter dari tipe yang sama, Anda dapat menentukan tipe <em>T</em> menggunakan <code>std::iterator_traits&lt;It&gt;::value_type</code> konstruksi <code>std::iterator_traits&lt;It&gt;::value_type</code> .  Harap dicatat bahwa <em>panduan deduksi</em> berada di luar definisi kelas, ini memungkinkan Anda untuk menyesuaikan perilaku kelas eksternal, termasuk kelas dari C ++ Standard Library. </p><br><p>  Deskripsi formal sintaks <em>panduan deduksi</em> diberikan dalam C ++ Standard 17 di bagian <strong>17.10 [temp.deduct.guide]</strong> : </p><br><pre> <code class="cpp hljs">[<span class="hljs-keyword"><span class="hljs-keyword">explicit</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>-name (parameter-declaration-clause) -&gt; simple-<span class="hljs-keyword"><span class="hljs-keyword">template</span></span>-id;</code> </pre> <br><p>  Kata kunci <strong>eksplisit</strong> sebelum <em>panduan pemotongan</em> melarang penggunaannya dengan <em>inisialisasi daftar salin</em> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> It&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyVector</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(It, It)</span></span></span><span class="hljs-function"> -&gt; MyVector&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typename</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::iterator_traits&lt;It&gt;::value_type&gt;</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; dv = {<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>, <span class="hljs-number"><span class="hljs-number">5.0</span></span>, <span class="hljs-number"><span class="hljs-number">7.0</span></span>}; MyVector v2{dv.begin(), dv.end()}; <span class="hljs-comment"><span class="hljs-comment">//  MyVector v3 = {dv.begin(), dv.end()}; //  </span></span></code> </pre> <br><p>  Omong-omong, <em>panduan deduksi</em> tidak harus menjadi templat: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> {</span></span> S(T); }; S(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*) -&gt; S&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;; S s{<span class="hljs-string"><span class="hljs-string">"hello"</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// S&lt;std::string&gt;</span></span></code> </pre> <br><h2 id="podrobnyy-algoritm-raboty-ctad">  Algoritma CTAD terperinci </h2><br><p>  Aturan formal untuk memperoleh argumen templat kelas dijelaskan secara rinci dalam klausa <strong>16.3.1.8 [over.match.class.deduct] dari</strong> C ++ Standard 17.  Mari kita coba mencari tahu mereka. </p><br><p>  Jadi, kami memiliki tipe template <em>C</em> yang menerapkan CTAD.  Untuk memilih konstruktor dan parameter mana yang harus dipanggil, untuk <em>C</em> , banyak fungsi templat dibentuk sesuai dengan aturan berikut: </p><br><ul><li>  Untuk setiap konstruktor <em>Ci</em> , fungsi template <em>Fi</em> dummy dihasilkan.  Parameter template <em>Fi</em> adalah parameter <em>C</em> , diikuti oleh parameter template <em>Ci</em> (jika ada), termasuk parameter dengan nilai default.  Tipe parameter dari fungsi <em>Fi</em> sesuai dengan tipe parameter konstruktor <em>Ci</em> .  Mengembalikan fungsi dummy Tipe <em>Fi</em> <em>C</em> dengan argumen yang cocok dengan parameter template <em>C.</em> </li></ul><br><p>  Kodesemu: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> V, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> W = A&gt; C(V, W); }; <span class="hljs-comment"><span class="hljs-comment">//    template &lt;typename T, typename U, typename V, typename W = A&gt; C&lt;T, U&gt; Fi(V, W);</span></span></code> </pre> <br><ul><li>  Jika tipe <em>C</em> tidak didefinisikan, atau tidak ada konstruktor yang ditentukan, aturan di atas berlaku untuk konstruktor hipotetis <em>C ()</em> . </li><li>  Fungsi dummy tambahan dihasilkan untuk konstruktor <em>C Â©</em> , untuk itu, mereka bahkan datang dengan nama khusus: <em>copy deduksi kandidat</em> . </li><li>  Untuk setiap <em>panduan deduksi</em> , fungsi dummy <em>Fi</em> juga dihasilkan dengan parameter template dan argumen <em>panduan deduksi</em> dan nilai balik yang sesuai dengan jenis di sebelah kanan -&gt; dalam <em>panduan deduksi</em> (dalam definisi formal disebut <em>simple-template-id</em> ). </li></ul><br><p>  Kodesemu: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> V&gt; C(T, V) -&gt; C&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> DT&lt;T&gt;, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> DT&lt;V&gt;&gt;; <span class="hljs-comment"><span class="hljs-comment">//    template &lt;typename T, typename V&gt; C&lt;typename DT&lt;T&gt;, typename DT&lt;V&gt;&gt; Fi(T,V);</span></span></code> </pre> <br><p>  Selanjutnya, untuk himpunan fungsi boneka <em>Fi</em> , aturan yang biasa untuk mengeluarkan parameter template dan resolusi kelebihan diterapkan dengan satu pengecualian: ketika fungsi boneka dipanggil dengan daftar inisialisasi yang terdiri dari parameter tunggal dari tipe <em>cv U</em> , di mana <em>U</em> adalah spesialisasi <em>C</em> atau jenis yang diwarisi dari spesialisasi <em>C</em> (untuk berjaga-jaga, saya akan mengklarifikasi bahwa <em>cv == const volatile</em> ; catatan seperti itu berarti tipe <em>U</em> , <em>const U</em> , <em>volatile U</em> dan <em>const volatile U</em> diperlakukan dengan cara yang sama), aturan yang memberikan prioritas pada konstruktor <code>C(std::initializer_list&lt;&gt;)</code> (dilewati untuk rincian <em>daftar inisi</em>  <em>lisasi</em> dapat ditemukan pada klausa <strong>16.3.1.7 [over.match.list] dari</strong> C ++ Standard 17).  Contoh: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span> v1{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// std::vector&lt;int&gt; std::vector v2{v1}; // std::vector&lt;int&gt;,   std::vector&lt;std::vector&lt;int&gt;&gt;</span></span></code> </pre> <br><p>  Akhirnya, jika mungkin untuk memilih satu-satunya fungsi boneka yang paling cocok, maka konstruktor atau <em>panduan deduksi yang</em> sesuai dipilih.  Jika tidak ada yang cocok, atau ada beberapa yang sama-sama cocok, kompiler melaporkan kesalahan. </p><br><h2 id="podvodnye-kamni">  Perangkap </h2><br><p>  CTAD digunakan untuk menginisialisasi objek, dan inisialisasi secara tradisional merupakan bagian yang sangat membingungkan dari bahasa C ++.  Dengan penambahan <em>inisialisasi seragam</em> dalam C ++ 11, cara untuk melepaskan kaki Anda hanya meningkat.  Sekarang Anda dapat memanggil konstruktor untuk objek dengan kurung bulat dan keriting.  Dalam banyak kasus, kedua opsi ini bekerja sama, tetapi tidak selalu: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span> v1{<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// [8, 15] std::vector v2(8, 15); // [15, 15, â€¦ 15] (8 ) std::vector v3{8}; // [8] std::vector v4(8); //  </span></span></code> </pre> <br><p>  Sejauh ini, semuanya tampaknya cukup logis: <em>v1</em> dan <em>v3</em> memanggil konstruktor yang mengambil <code>std::initializer_list&lt;int&gt;</code> , int disimpulkan dari parameter;  <em>v4</em> tidak dapat menemukan konstruktor yang hanya mengambil satu parameter tipe <em>int</em> .  Tapi ini masih bunga, beri di depan: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span> v5{<span class="hljs-string"><span class="hljs-string">"hi"</span></span>, <span class="hljs-string"><span class="hljs-string">"world"</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// [â€œhiâ€, â€œworldâ€] std::vector v6("hi", "world"); // ??</span></span></code> </pre> <br><p>  <em>v5</em> , seperti yang diharapkan, akan bertipe <code>std::vector&lt;const char*&gt;</code> dan diinisialisasi dengan dua elemen, tetapi baris berikutnya melakukan sesuatu yang sama sekali berbeda.  Untuk vektor, hanya ada satu konstruktor yang mengambil dua parameter dari jenis yang sama: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vector</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">last</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Allocator</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alloc</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Allocator</span></span></span><span class="hljs-class">() );</span></span></code> </pre> <br><p>  berkat <em>panduan deduksi</em> untuk <code>std::vector</code> "hai" dan "world" akan diperlakukan sebagai iterator, dan semua elemen yang terletak "antara" akan ditambahkan ke vektor bertipe <code>std::vector&lt;char&gt;</code> .  Jika kita beruntung dan dua konstanta string ini berada dalam memori berturut-turut, maka tiga elemen akan jatuh ke dalam vektor: 'h', 'i', '\ x00', tetapi, kemungkinan besar, kode tersebut akan menyebabkan pelanggaran perlindungan memori dan crash program. </p><br><h2 id="ispolzuemye-materialy">  Bahan yang digunakan </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Draf Standar C ++ 17</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CTAD</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CppCon 2018: Stephan T. Lavavej "Pengurangan Argumen Template Kelas untuk Semua Orang"</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461963/">https://habr.com/ru/post/id461963/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461941/index.html">Pijat itu</a></li>
<li><a href="../id461945/index.html">Intisari acara untuk profesional SDM di bidang TI untuk Agustus 2019</a></li>
<li><a href="../id461949/index.html">AppCode 2019.2: Swift 5.1, analisis cakupan kode dengan tes, tampilan kode dibongkar dan banyak lagi</a></li>
<li><a href="../id461951/index.html">Plug-in Veeam untuk cadangan dan pemulihan database SAP HANA</a></li>
<li><a href="../id461955/index.html">Pertukaran token atau cara memperkuat portofolio crypto pada tahun 2019</a></li>
<li><a href="../id461965/index.html">Aplikasi web MVC tanpa kerangka kerja dan servlet</a></li>
<li><a href="../id461967/index.html">Antiquities: tape recorder fungsional</a></li>
<li><a href="../id461971/index.html">Kekuatan Oracle SQL</a></li>
<li><a href="../id461973/index.html">Test drive Audi e-tron</a></li>
<li><a href="../id461975/index.html">Layanan kami berbahaya dan sulit, atau Zyxel ATP500</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>