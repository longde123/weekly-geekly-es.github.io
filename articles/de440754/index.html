<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìì üíÄ ü§∂üèø Plattform√ºbergreifendes englisches Dienstprogramm zum Anzeigen russisch qualifizierter Zertifikate x509 ‚ùáÔ∏è üßëüèø‚Äçü§ù‚Äçüßëüèæ üßòüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute ist die Verwendung digitaler Zertifikate X509 v.3 an der Tagesordnung. Immer mehr Menschen nutzen sie, um auf die Website des Staatsdienstes, de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Plattform√ºbergreifendes englisches Dienstprogramm zum Anzeigen russisch qualifizierter Zertifikate x509</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440754/"><img src="https://habrastorage.org/webt/tj/bp/mp/tjbpmpejv6ig2dqs8r22x1zcmzw.png" alt="Bild" align="left">  Heute ist die Verwendung digitaler Zertifikate X509 v.3 an der Tagesordnung.  Immer mehr Menschen nutzen sie, um auf die Website des Staatsdienstes, des Bundessteuerdienstes, elektronischer Gebote usw. zuzugreifen.  Und immer mehr Menschen m√∂chten wissen, was sich in dieser ‚ÄûTruhe‚Äú befindet, die als Zertifikat bezeichnet wird.  Und wenn das Zertifikat ein Analogon eines Passes ist, wie kann es dann gelesen / angezeigt werden?  Ja, in Betriebssystemen gibt es verschiedene Dienstprogramme zum Anzeigen.  Aber sie werden dem normalen B√ºrger wenig geben.  Nehmen wir zum Beispiel das Dienstprogramm gcr-viewer, das in der Tat das Standardwerkzeug f√ºr die Anzeige auf Linux-Systemen und damit auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">inl√§ndischen Betriebssystemen ist</a> : <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/lf/7g/nf/lf7gnfqkvwpo2cuhy_mcvulf_a8.png"><br><br><h3>  Standard-Viewer </h3><br>  Das Dienstprogramm ist gut gemacht, bequem.  Im Allgemeinen ist es als universelles Dienstprogramm zum Anzeigen von Dateien gedacht, die Daten in verschiedenen kryptografischen Formaten enthalten (Zertifikate, Anforderungen, elektronische Signaturen / PKCS # 7, gesch√ºtzte Container PKCS # 12 usw.).  Leider ist es f√ºr die westliche Kryptographie konzipiert und ber√ºcksichtigt keine in Ihrem Land eingegebenen Oids.  Wenn Sie sich den Screenshot ansehen, werden unverst√§ndliche Zeichen angezeigt, wenn die Informationen zum Zertifikatsinhaber angezeigt werden.  Links sind die Oids selbst und rechts in der 16. Form die asn1-Struktur mit ihren Werten.  In diesem Fall sind dies OGRN (1.2.643.100.1), SNILS (1.2.643.100.3) und TIN (1.2.643.3.131.1.1).  Und so sollte ein gew√∂hnlicher B√ºrger sicherstellen, dass dies seine Daten sind.  Denken Sie nicht, dass dies nur unter Linux m√∂glich ist, es ist eine gemeinsame Funktion jedes Zertifikat-Viewers.  Und wenn Sie weiter schauen, wird alles unverst√§ndlich: <br><br><img src="https://habrastorage.org/webt/55/6s/ib/556sib6y76f81ohud2laq0knsho.png"><br><br>  Einige Erweiterungen, Bezeichner und Werte werden angezeigt.  In diesem Fall verbirgt oid 1.2.643.100.111 den Namen der CIPF, die vom Benutzer zum Generieren des Schl√ºsselpaars verwendet wurde, den privaten Schl√ºssel, mit dem die Zertifikatanforderung signiert wurde, und den √∂ffentlichen Schl√ºssel, von dem im Zertifikat liegt: <br><br><img src="https://habrastorage.org/webt/yv/yx/uu/yvyxuu6hjoasxtytu7foy-s1o20.png"><br><br>  Und hier ist dem Zertifikatsinhaber wenig bekannt.  Er versteht nicht einmal, mit welchem ‚Äã‚ÄãAlgorithmus der Schl√ºssel generiert wurde, entweder GOST R 34.10-2001 oder GOST R 34.10-2012 und mit welcher Schl√ºssell√§nge. <br><br>  Sie k√∂nnen weiterhin Beispiele nennen.  Wenn zum Beispiel die G√ºltigkeit des Zertifikats klar ist, wo ist dann der Schl√ºssel? <br><br>  Es gibt zwei weitere Fragen, auf die Zertifikatsinhaber eine Antwort haben m√∂chten: Wo kann ich eine Kette von Stammzertifikaten erhalten (oder noch besser nur eine) und eine √§hnliche Frage in der Liste der widerrufenen Zertifikate. <br><br>  Und schlie√ülich m√∂chte ich ein universelles Dienstprogramm haben, das die Merkmale der russischen PKI / PKI ber√ºcksichtigt, die wirklich plattform√ºbergreifend ist und auf inl√§ndischen und nicht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">inl√§ndischen Betriebssystemen ausgef√ºhrt wird</a> .  Was ist zu entwickeln?  Nat√ºrlich in einer Skriptsprache, schon allein wegen ihrer plattform√ºbergreifenden Natur. <br><br>  Dann erinnerte ich mich, dass die sch√∂ne Skriptsprache Tcl (Tool Command Language) k√ºrzlich ihr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">30-j√§hriges Bestehen</a> gefeiert hatte.  Es ist eine Freude, darauf zu programmieren.  Es hat eine gro√üe Anzahl von Erweiterungen (Paket), die fast alles erlauben.  Um mit ASN-Strukturen arbeiten zu k√∂nnen, gibt es ein ASN-Paket.  Dar√ºber hinaus gibt es f√ºr die Arbeit mit Zertifikaten (wir sind in diesem Fall daran interessiert, sie zu analysieren) ein pki-Paket.  Und f√ºr die Entwicklung einer grafischen Oberfl√§che gibt es ein Tk-Paket. <br><br>  Trotzdem kann man √ºber Pyton mit Tkinter und √ºber Perl und √ºber Rubin sagen.  Jeder kann nach seinem Geschmack w√§hlen.  Wir halten an einem Haufen Tcl / Tk. <br><br>  Wir werden das Grafikdesign f√ºr das Dienstprogramm vom Dienstprogramm gcr-viewer ausleihen.  Und noch eine Anforderung. <br><br>  Da Habr eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">englische Version hatte</a> , wollte ich, dass das Dienstprogramm verschiedene Schnittstellen hat (Russisch / Englisch).  Dies ist jedoch nicht der Hauptgrund.  Noch wichtiger ist, dass immer mehr B√ºrger der westlichen Welt B√ºrger der Russischen F√∂deration werden, zum Beispiel der weltber√ºhmte Schauspieler Depardieu.  Sie k√∂nnen Einw√§nde erheben: Er ist ein Franzose.  Ich bin aber auch ein Milit√§r√ºbersetzer aus dem Franz√∂sischen: <br><br><img src="https://habrastorage.org/webt/ma/xr/4d/maxr4dvthbpwapmxmodkjceujh4.png"><br><br>  Es ist also einfach, eine franz√∂sische Benutzeroberfl√§che hinzuzuf√ºgen.  Aber ich denke, Depardieu hat keine Probleme mit der englischen Sprache.  Auf der anderen Seite ist unser Land multinational und es w√§re sehr sch√∂n, wenn die inl√§ndische Software und das inl√§ndische Betriebssystem mindestens mehrere nationale Schnittstellen h√§tten. <br>  Ein wenig voraus zu laufen, ist das, was daraus wurde: <br><br><img src="https://habrastorage.org/webt/-e/d8/df/-ed8dfn1in3wl7iwa2wmf-w0w-w.png"><br><br><h3>  Wir laden einen √úbersetzer ein </h3><br>  Beginnen wir also mit dem ‚Äû√úbersetzer‚Äú.  Im Screenshot versteckt er sich unter der Nationalflagge.  Die Hauptanforderung f√ºr einen √úbersetzer ist die Synchronisation der √úbersetzung, d.h.  die M√∂glichkeit, jederzeit zu einer anderen Sprache zu wechseln.  Die √úbersetzerfunktionen in Tcl / Tk sind das msgcat-Paket: <br><br><pre><code class="plaintext hljs">package require msgcat</code> </pre> <br>  Verwenden Sie den folgenden Befehl, um die aktuelle Sprache festzulegen: <br><br><pre> <code class="plaintext hljs">msgcat::mclocale ru</code> </pre> <br>  Das Vokabular des ‚Äû√úbersetzers‚Äú wird wie folgt in der Datei ru.msg gespeichert: <br><br><pre> <code class="plaintext hljs">#  msgcat::mcset      #     mcset namespace import -force msgcat::mcset #     mcset ru "Language" "" ‚Ä¶</code> </pre> <br>  Das Folgende ist der Text des Tests <div class="spoiler">  <b class="spoiler_title">Skript mit √úbersetzer:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#!/usr/bin/wish -f #  msgcat package require msgcat #   ru msgcat::mclocale ru #  ::msgcat::mc      #     mc namespace import msgcat::mc #    [msgcat::mclocale].msg. #       . msgcat::mcload [file join [file dirname [info script]]] #  image create photo rf_32x21_f -file rf_32x21.png image create photo gb_32x21_f -file gb_32x21.png #,      label .lab -text "[mc Language]: " -relief flat -bd 0 ‚Äìbg snow -anchor sw -width 10 button .but_lang -image rf_32x21_f -command ::changelang -relief flat -bd 0 pack .lab -side left -pady {2 0} pack .but_lang -side left #      proc ::changelang {} { #     #    if {[msgcat::mclocale] == "ru"} { msgcat::mclocale en .but_lang configure -image gb_32x21_f } else { msgcat::mclocale ru .but_lang configure -image rf_32x21_f } #  .lab configure -text "[mc Language]: " }</code> </pre> <br></div></div><br>  In diesem Skript fungiert die Prozedur :: changelang als √úbersetzer, der aufgerufen wird, wenn die Schaltfl√§che .but_lang mit dem Flag gedr√ºckt wird. <br><br>  Wenn Sie dieses Skript ausf√ºhren, werden Sie deutlich sehen, wie der √úbersetzer funktioniert: <br><br><img src="https://habrastorage.org/webt/hs/4y/e6/hs4ye6p49e5soy4ud6aje91-e2i.png"><br><br><h3>  Holen Sie sich den √∂ffentlichen Schl√ºssel </h3><br>  Nachdem wir uns f√ºr einen √úbersetzer entschieden haben, fahren wir mit der Analyse des Zertifikats fort.  Dazu ben√∂tigen wir das pki-Paket: <br><br><pre> <code class="plaintext hljs">package require pki).</code> </pre> <br>  Das pki-Paket funktioniert mit RSA-Algorithmusschl√ºsseln und -Zertifikaten.  Wenn das Zertifikat (proc :: pki :: x509 :: parse_cert) mit einem anderen Schl√ºsseltyp erstellt wurde, erhalten wir keine Informationen zu diesem Schl√ºssel: <br><br><pre> <code class="plaintext hljs"># Handle RSA public keys by extracting N and E switch -- $ret(pubkey_algo) { "rsaEncryption" { set pubkey [binary format B* $pubkey] binary scan $pubkey H* ret(pubkey) ::asn::asnGetSequence pubkey pubkey_parts ::asn::asnGetBigInteger pubkey_parts ret(n) ::asn::asnGetBigInteger pubkey_parts ret(e) set ret(n) [::math::bignum::tostr $ret(n)] set ret(e) [::math::bignum::tostr $ret(e)] set ret(l) [expr {int([::pki::_bits $ret(n)] / 8.0000 + 0.5) * 8}] set ret(type) rsa } }</code> </pre> <br>  √úberraschenderweise gibt der Public-Key-Algorithmus immer noch zur√ºck (ret (pubkey_algo)) <br>  Die Situation ist dieselbe wie beim Parsen der Zertifikatanforderung (proc :: pki :: pkcs :: parse_csr): <br><br><pre> <code class="plaintext hljs"># Parse public key, based on type switch -- $pubkey_type { "rsaEncryption" { set pubkey [binary format B* $pubkey] ::asn::asnGetSequence pubkey pubkey_parts ::asn::asnGetBigInteger pubkey_parts key(n) ::asn::asnGetBigInteger pubkey_parts key(e) set key(n) [::math::bignum::tostr $key(n)] set key(e) [::math::bignum::tostr $key(e)] set key(l) [expr {2**int(ceil(log([::pki::_bits $key(n)])/log(2)))}] set key(type) rsa } default { return -code error "Unsupported key type: $pubkey_type" } }</code> </pre> <br>  Aber hier gibt er sogar Informationen √ºber den Fehler zur√ºck.  Aber heute werden neben RSA beispielsweise Schl√ºssel auf elliptischen Kurven der EU verwendet, einschlie√ülich GOST R 34.10-2012 (GOST R 34.10-2001 gibt es derzeit auch). <br><br>  Standardm√§√üig reicht es jedoch aus, die ASN-Struktur des √∂ffentlichen Schl√ºssels zur√ºckzugeben, der im Zertifikat oder in der Anforderung enthalten ist, und der Benutzer selbst analysiert den √∂ffentlichen Schl√ºssel je nach Schl√ºsseltyp.  F√ºgen Sie dazu einfach die ASN-Struktur des √∂ffentlichen Schl√ºssels in hexadezimalen Werten zu den zur√ºckgegebenen Werten hinzu: <br><br><pre> <code class="plaintext hljs">proc ::pki::x509::parse_cert {cert} { . . . ::asn::asnGetSequence cert subject ::asn::asnGetSequence cert pubkeyinfo #    ASN-  . binary scan $pubkeyinfo H* ret(pubkey_pubkeyinfo) . . . }</code> </pre> <br>  Alles, nichts anderes zu tun.  Auf diese Weise gibt die Prozedur :: pki :: x509 :: parse_cert die meisten Zertifikatserweiterungen aus dem einfachen Grund zur√ºck, dass sie nicht wei√ü, wie sie analysiert werden sollen (z. B. subjectSignTool mit unseren qualifizierten Zertifikaten), d. H.  gibt nach Ermessen des Benutzers. <br><br>  Andererseits gibt die Prozedur :: pki :: x509 :: parse_cert eines der Ergebnisse eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TBT-Zertifikats zur√ºck</a> , das alle Informationen aus dem Zertifikat enth√§lt, mit Ausnahme der Signatur (Signatur) und des Signaturtyps (Signatur_algo): <br><br><pre> <code class="plaintext hljs">#    set fd [open ¬´cert.pem¬ª r] chan configure ‚Äìtranslation binary set datacert [read $fd] close $fd #  array set cert_parse [::pki::x509::parse_cert $datacert] # tbs- set cert_tbs_hex $cert_parse(cert)</code> </pre> <br>  Wir schreiben das Verfahren zum Extrahieren von Public-Key-Informationen aus einem TBS-Zertifikat: <br><br><pre> <code class="plaintext hljs">proc ::pki::x509::parse_cert_pubkeyinfo {cert_tbs_hex} { array set ret [list] set wholething [binary format H* $cert_tbs_hex] ::asn::asnGetSequence wholething cert ::asn::asnPeekByte cert peek_tag if {$peek_tag != 0x02} { # Version number is optional, if missing assumed to be value of 0 ::asn::asnGetContext cert - asn_version ::asn::asnGetInteger asn_version ret(version) } ::asn::asnGetBigInteger cert ret(serial_number) ::asn::asnGetSequence cert data_signature_algo_seq ::asn::asnGetObjectIdentifier data_signature_algo_seq ret(data_signature_algo) ::asn::asnGetSequence cert issuer ::asn::asnGetSequence cert validity ::asn::asnGetUTCTime validity ret(notBefore) ::asn::asnGetUTCTime validity ret(notAfter) ::asn::asnGetSequence cert subject ::asn::asnGetSequence cert pubkeyinfo #    hex asn-   binary scan $pubkeyinfo H* ret(pubkeyinfo) return $ret(pubkeyinfo) }</code> </pre> <br>  Und da wir an russischer Kryptographie interessiert sind, werden wir sofort das Verfahren zum Parsen des √∂ffentlichen GOST-Schl√ºssels schreiben: <br><br><pre> <code class="plaintext hljs">proc parse_key_gost {pubkeyinfo_hex} { array set ret [list] set pubkeyinfo [binary format H* $pubkeyinfo_hex] ::asn::asnGetSequence pubkeyinfo pubkey_algoid ::asn::asnGetObjectIdentifier pubkey_algoid ret(pubkey_algo) #,   - if {[string first "1 2 643 " $ret(pubkey_algo)] == -1} { return [array get ret] } ::asn::asnGetBitString pubkeyinfo pubkey set pubkey [binary format B* $pubkey] #   binary scan $pubkey H* ret(pubkey) ::asn::asnGetSequence pubkey_algoid pubalgost #OID -  ::asn::asnGetObjectIdentifier pubalgost ret(paramkey) #OID -   ::asn::asnGetObjectIdentifier pubalgost ret(hashkey) #puts "ret(paramkey)=$ret(paramkey)\n" #puts "ret(hashkey)=$ret(hashkey)\n" #parray ret #  :  ,     return [array get ret] }</code> </pre><br>  Ja, ich habe es fast verpasst: Nach dem Laden des pki-Pakets m√ºssen Sie dem Array :: pki :: oids oids hinzuf√ºgen, die das GOST und das qualifizierte Zertifikat charakterisieren oder in diesem Array einfach fehlen: <br><br><pre> <code class="plaintext hljs">package require pki # oid- set ::pki::oids(1.2.643.100.1) "OGRN" set ::pki::oids(1.2.643.100.5) "OGRNIP" set ::pki::oids(1.2.643.3.131.1.1) "INN" set ::pki::oids(1.2.643.100.3) "SNILS" set ::pki::oids(1.2.643.2.2.19) "GOST R 34.10-2001" set ::pki::oids(1.2.643.7.1.1.1.1) "GOST R 34.10-2012-256" set ::pki::oids(1.2.643.7.1.1.1.2) "GOST R 34.10-2012-512" set ::pki::oids(1.2.643.2.2.3) "GOST R 34.10-2001 with GOST R 34.11-94" set ::pki::oids(1.2.643.7.1.1.3.2) "GOST R 34.10-2012-256 with GOSTR 34.11-2012-256" set ::pki::oids(1.2.643.7.1.1.3.3) "GOST R 34.10-2012-512 with GOSTR 34.11-2012-512" set ::pki::oids(1.2.643.100.113.1) "KC1 Class Sign Tool" set ::pki::oids(1.2.643.100.113.2) "KC2 Class Sign Tool" . . .</code> </pre> <br>  Sie k√∂nnen das Vokabular des √úbersetzers auch auff√ºllen, indem Sie der Datei ru.msg Folgendes hinzuf√ºgen: <br><br><pre> <code class="plaintext hljs">mcset ru "GOST R 34.10-2001" "  34.10-2001" mcset ru "GOST R 34.10-2012-256" "  34.10-2012-256" mcset ru "GOST R 34.10-2012-512" "  34.10-2012-512" mcset ru "GOST R 34.10-2001 with GOST R 34.11-94" "  34.10-2001    34.11-94" mcset ru "GOST R 34.10-2012-256 with GOSTR 34.11-2012-256" "  34.10-2012-256    34.11-2012-256" mcset ru "GOST R 34.10-2012-512 with GOSTR 34.11-2012-512" "  34.10-2012-512    34.11-2012-512" . . .</code> </pre>  :: <br><img src="https://habrastorage.org/webt/am/gu/td/amgutdxuj-xkszh1qpmeaa-hf1g.png"><br><br><h3>  Stammzertifikatskette und Zertifikatsperrliste </h3><br>  Wie man eine Kette von Stammzertifikaten erh√§lt, wurde bereits fr√ºher besprochen.  In Analogie wird eine Prozedur geschrieben, um eine Liste der widerrufenen COS / CRL-Zertifikate zu erhalten.  Der Quellcode des Dienstprogramms und seiner Distributionen f√ºr Linux, OS X (macOS) und MS Windows finden Sie hier <br><br><div class="spoiler">  <b class="spoiler_title">hier</b> <div class="spoiler_text"><ul><li>  <a href="">Quellcode</a> </li><li>  <a href="">Linux32</a> </li><li>  <a href="">Linux64</a> </li><li>  <a href="">OS X.</a> </li><li>  <a href="">WIN32</a> </li><li>  <a href="">WIN64</a> </li></ul><br></div></div><br>  Im Quellcode finden Sie alle Verfahren zum Parsen von Zertifikatserweiterungen. <br>  F√ºr Gegner von Tk (Tcl / Tk, Python / Tkinter usw.) empfehle ich, wie sie sagen, 10 (zehn) Unterschiede zwischen den beiden Dienstprogrammen zu finden: das in gtk geschriebene Dienstprogramm gcr-viewer und das in Tk entwickelte Dienstprogramm certViewer: <br><br><img src="https://habrastorage.org/webt/pq/k5/a5/pqk5a5yrh7fbjhlrfipmdvu5tyg.png"><br><br><h3>  PKCS # 11 Token / Smartcard-Zertifikate </h3><br>  Oben haben wir √ºber die Arbeit mit Zertifikaten gesprochen (Durchsuchen, Abrufen der Kette von Stammzertifikaten, Listen widerrufener Zertifikate, Fingerabdr√ºcke von sha1 und sha256 usw.), die in Dateien gespeichert sind.  Auf PKCS # 11-Token / Smartcards sind jedoch noch Zertifikate gespeichert.  Und der nat√ºrliche Wunsch besteht nicht nur darin, sie zu sehen und dann in eine Datei zu exportieren.  Wie das geht, beschreiben wir im folgenden Artikel: <br><br><img src="https://habrastorage.org/webt/vx/25/cu/vx25culnj3anfl_jwbkgd-t8nk4.png"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de440754/">https://habr.com/ru/post/de440754/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440742/index.html">AMP- und Turbo-Seiten: Vor- und Nachteile sowie Implementierungsergebnisse</a></li>
<li><a href="../de440744/index.html">PHP f√ºr Anf√§nger. Fehlerbehandlung</a></li>
<li><a href="../de440746/index.html">Die Wissensmanagement-Technologiezyklen von Gartner werden anhand von Fallstudien bei KnowledgeConf durchgef√ºhrt</a></li>
<li><a href="../de440748/index.html">Der schnellste Supercomputer der Welt bricht den KI-Rekord</a></li>
<li><a href="../de440752/index.html">Auswahl der Priorit√§t der Benutzeranforderung</a></li>
<li><a href="../de440756/index.html">Serverloses CI / CD unter AWS</a></li>
<li><a href="../de440758/index.html">Treffen Sie sich bei Acronis! (Moskau, Fiztehpark)</a></li>
<li><a href="../de440760/index.html">Das neue goldene Zeitalter f√ºr Computerarchitektur</a></li>
<li><a href="../de440762/index.html">Arbeitgeberbewertungen: Art und Bedeutungslosigkeit anonymer Bewertungen</a></li>
<li><a href="../de440766/index.html">Von Geeks zu Geeks: Geschenke f√ºr den 23. Februar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>