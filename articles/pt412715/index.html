<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏿‍🤝‍🧑🏽 🐘 👩🏻‍🚀 Aprendendo a programação Go multithread com fotos 🧜🏻 🚴🏾 ♀️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Provavelmente, você já ouviu falar sobre a linguagem de programação Go, sua popularidade está em constante crescimento, o que é bastante razoável. Ess...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aprendendo a programação Go multithread com fotos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412715/"><img src="https://habrastorage.org/webt/qk/hi/im/qkhiimd_phctfhx4kka_rhpkepq.png"><br>  Provavelmente, você já ouviu falar sobre a linguagem de programação Go, sua popularidade está em constante crescimento, o que é bastante razoável.  Esse idioma é simples, rápido e conta com uma ótima comunidade.  Um dos aspectos mais curiosos da linguagem é o modelo de programação multithread.  As primitivas subjacentes permitem criar programas multithread com facilidade e simplicidade.  Este artigo é destinado a quem deseja aprender essas primitivas: goroutines e canais.  E, através das ilustrações, mostrarei como trabalhar com elas.  Espero que seja uma boa ajuda para você em seus estudos futuros. <br><a name="habracut"></a><br><h4>  Programas únicos e multithread </h4><br>  Você provavelmente já escreveu programas de thread único.  Normalmente, é assim: existe um conjunto de funções para executar várias tarefas, cada função é chamada apenas quando a anterior preparou os dados para ela.  Assim, o programa é executado seqüencialmente. <br><br>  Esse será o nosso primeiro exemplo - o programa de mineração de minério.  Nossas funções buscarão, extrair e processar minério.  O minério na mina em nosso exemplo é representado por listas de strings, funções as tomam como parâmetros e retornam uma lista de strings "processados".  Para um programa de thread único, nosso aplicativo será projetado da seguinte maneira: <br><br><img src="https://habrastorage.org/webt/c5/ua/ja/c5uajayyncivzzj9_orh-u_sw34.png"><br><br>  Neste exemplo, todo o trabalho é realizado por um thread (Gopher de Gary).  Três funções principais: pesquisa, produção e processamento são executadas seqüencialmente uma após a outra. <br><br><pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { theMine := [<span class="hljs-number"><span class="hljs-number">5</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{<span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>} foundOre := finder(theMine) minedOre := miner(foundOre) smelter(minedOre) }</code> </pre> <br>  Se imprimirmos o resultado de cada função, obtemos o seguinte: <br><br><pre> <code class="hljs powershell">From Finder: [<span class="hljs-type"><span class="hljs-type">ore</span></span> <span class="hljs-type"><span class="hljs-type">ore</span></span> <span class="hljs-type"><span class="hljs-type">ore</span></span>] From Miner: [<span class="hljs-type"><span class="hljs-type">minedOre</span></span> <span class="hljs-type"><span class="hljs-type">minedOre</span></span> <span class="hljs-type"><span class="hljs-type">minedOre</span></span>] From Smelter: [<span class="hljs-type"><span class="hljs-type">smeltedOre</span></span> <span class="hljs-type"><span class="hljs-type">smeltedOre</span></span> <span class="hljs-type"><span class="hljs-type">smeltedOre</span></span>]</code> </pre><br>  O design e a implementação simples são uma vantagem de uma abordagem de thread único.  Mas e se você quiser executar e executar funções independentemente uma da outra?  Aqui, a programação multithread ajuda você. <br><br><img src="https://habrastorage.org/webt/om/x1/mq/omx1mqphfsqqs57lab9bngsnggi.png"><br>  Essa abordagem para a mineração de minério é muito mais eficiente.  Agora, vários threads (esquilos) trabalham de forma independente, e Gary faz apenas parte do trabalho.  Um esquilo procura minério, o outro produz e o terceiro derrete, e tudo isso é potencialmente simultâneo.  Para implementar essa abordagem, precisamos de duas coisas no código: criar processadores Gopher independentemente um do outro e transferir minério entre eles.  Go tem goroutines e canais para isso. <br><br><h4>  Gorutins </h4><br>  As goroutines podem ser consideradas como "threads leves". Para criar goroutines, basta colocar a palavra-chave <b>go</b> antes do código de chamada da função.  Para demonstrar como é simples, vamos criar duas funções de pesquisa, chamá-las com a palavra-chave <b>go</b> e imprimir uma mensagem toda vez que encontrarem o “minério” na mina. <br><img src="https://habrastorage.org/webt/jz/wx/nb/jzwxnbgxocr-a0rq7kmdoujt_gg.png"><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { theMine := [<span class="hljs-number"><span class="hljs-number">5</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{<span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> finder1(theMine) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> finder2(theMine) &lt;-time.After(time.Second * <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">//       }</span></span></code> </pre><br>  A saída do nosso programa será a seguinte: <br><br><pre> <code class="hljs pgsql">Finder <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore!</code> </pre><br>  Como você pode ver, não há ordem em que a função “encontre minério” primeiro;  As funções de pesquisa funcionam simultaneamente.  Se você executar o exemplo várias vezes, a ordem será diferente.  Agora podemos executar programas multithread (multi-sphere), e este é um progresso sério.  Mas o que fazer quando precisamos estabelecer uma conexão entre goroutines independentes?  Está chegando a hora da magia dos canais. <br><br><h4>  Canais </h4><br><img src="https://habrastorage.org/webt/pa/a-/5r/paa-5r_dtecx3fzem9r0dsv42jo.png"><br>  Canais permitem que goroutines troquem dados.  Este é um tipo de tubo através do qual as goroutins podem enviar e receber informações de outras goroutines. <br><img src="https://habrastorage.org/webt/-d/vp/fz/-dvpfzbpaa65exwi7l4pgerte48.png"><br>  A leitura e gravação no canal são realizadas usando o operador de seta (&lt;-), que indica a direção do movimento dos dados. <br><img src="https://habrastorage.org/webt/wd/1j/qp/wd1jqp8ipkwvcdgc5xbuoyy6wey.png"><br><pre> <code class="go hljs">myFirstChannel := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) myFirstChannel &lt;- <span class="hljs-string"><span class="hljs-string">"hello"</span></span> <span class="hljs-comment"><span class="hljs-comment">//    myVariable := &lt;- myFirstChannel //   </span></span></code> </pre><br>  Agora nosso escoteiro não precisa acumular minério, ele pode transferi-lo imediatamente usando os canais. <br><img src="https://habrastorage.org/webt/60/yx/_j/60yx_jlczbwcy2tfmsqgvzwp4dg.png"><br>  Atualizei o exemplo, agora o código do localizador e do minerador é de funções anônimas.  Não se preocupe muito se você não os encontrou antes, mas lembre-se de que cada um deles é chamado com a palavra-chave <b>go</b> , portanto, ela será executada em sua própria goroutine.  O mais importante aqui é que as goroutines transmitem dados entre si usando o canal <b>oreChan</b> .  E vamos lidar com funções anônimas mais perto do fim. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { theMine := [<span class="hljs-number"><span class="hljs-number">5</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{“ore1”, “ore2”, “ore3”} oreChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   go func(mine [5]string) { for _, item := range mine { oreChan &lt;- item // } }(theMine) //   go func() { for i := 0; i &lt; 3; i++ { foundOre := &lt;-oreChan // fmt.Println(“Miner: Received “ + foundOre + “ from finder”) } }() &lt;-time.After(time.Second * 5) //     }</span></span></code> </pre><br>  A conclusão abaixo demonstra claramente que nosso mineiro recebe três vezes do minério de canal uma porção de cada vez. <br><br><pre> <code class="hljs cs">Miner: Received ore1 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> finder Miner: Received ore2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> finder Miner: Received ore3 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> finder</code> </pre><br>  Portanto, agora podemos transferir dados entre diferentes goroutines (Gopher), mas antes de começarmos a escrever um programa complexo, vamos examinar algumas propriedades importantes dos canais. <br><br><h4>  Fechaduras </h4><br>  Em algumas situações, ao trabalhar com canais, a goroutin pode estar bloqueada.  Isso é necessário para que as goroutines possam sincronizar-se umas com as outras antes de começar ou continuar trabalhando. <br><br><h4>  Bloqueio de gravação </h4><br><img src="https://habrastorage.org/webt/ir/vv/zi/irvvziqxuk3opysywirescrn40e.png"><br><br>  Quando a goroutine (gopher) envia dados para um canal, ela é bloqueada até que outra goroutine leia os dados do canal. <br><br><h4>  Bloqueio de leitura </h4><br><img src="https://habrastorage.org/webt/eq/e5/k8/eqe5k854n39oia6xwaavj5xfk-q.png"><br><br>  Semelhante ao bloqueio ao gravar em um canal, a goroutin pode ser bloqueada durante a leitura de um canal até que nada seja gravado nele. <br>  Se as fechaduras, à primeira vista, parecerem complicadas para você, você pode imaginá-las como uma "transferência de dinheiro" entre duas goroutinas (esquilos).  Quando um esquilo quer transferir ou receber dinheiro, ele precisa aguardar o segundo participante da transação. <br><br>  Depois de lidar com os bloqueios de goroutina nos canais, vamos discutir dois tipos diferentes de canais: com buffer e sem buffer.  Escolhendo esse ou aquele tipo, determinamos amplamente o comportamento do programa. <br><br><h4>  Canais sem buffer </h4><br><img src="https://habrastorage.org/webt/hv/k0/ba/hvk0badnrvqhncjqf9uwyrlowq8.png"><br><br>  Em todos os exemplos anteriores, usamos apenas esses canais.  Nesses canais, apenas um dado pode ser transmitido por vez (com bloqueio, como descrito acima). <br><br><h4>  Canais tamponados </h4><br><img src="https://habrastorage.org/webt/zs/zg/b1/zszgb15grrrjjiyaqs6gwtfkkye.png"><br><br>  Os fluxos em um programa nem sempre podem ser perfeitamente sincronizados.  Suponha, no nosso exemplo, que um gopher-scout encontrou três partes de minério, enquanto um gopher-mineiro conseguiu extrair apenas uma parte das reservas encontradas ao mesmo tempo.  Aqui, para que o reconhecimento do esquilo não passe a maior parte do tempo esperando o mineiro terminar seu trabalho, usaremos canais em buffer.  Vamos começar criando um canal com capacidade para 3. <br><br><pre> <code class="go hljs">bufferedChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br>  Podemos enviar vários dados para o canal em buffer, sem a necessidade de lê-los com outra goroutine.  Essa é a principal diferença em relação aos canais sem buffer. <br><br><img src="https://habrastorage.org/webt/sh/ok/f2/shokf2oswaiw1yk6i-uwplypezi.png"><br><pre> <code class="go hljs">bufferedChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { bufferedChan &lt;- <span class="hljs-string"><span class="hljs-string">"first"</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"Sent 1st"</span></span>) bufferedChan &lt;- <span class="hljs-string"><span class="hljs-string">"second"</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"Sent 2nd"</span></span>) bufferedChan &lt;- <span class="hljs-string"><span class="hljs-string">"third"</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"Sent 3rd"</span></span>) }() &lt;-time.After(time.Second * <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { firstRead := &lt;- bufferedChan fmt.Println(<span class="hljs-string"><span class="hljs-string">"Receiving.."</span></span>) fmt.Println(firstRead) secondRead := &lt;- bufferedChan fmt.Println(secondRead) thirdRead := &lt;- bufferedChan fmt.Println(thirdRead) }()</code> </pre><br>  A ordem de saída nesse programa será a seguinte: <br><br><pre> <code class="hljs dos">Sent <span class="hljs-number"><span class="hljs-number">1</span></span>st Sent <span class="hljs-number"><span class="hljs-number">2</span></span>nd Sent <span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-built_in"><span class="hljs-built_in">rd</span></span> Receiving.. first second third</code> </pre><br>  Para evitar complicações desnecessárias, não usaremos canais em buffer em nosso programa.  Mas é importante lembrar que esses tipos de canais também estão disponíveis para uso. <br>  Também é importante observar que os canais em buffer nem sempre o impedem de bloquear.  Por exemplo, se um gopher scout é dez vezes mais rápido que um gopher miner, e eles são conectados através de um canal em buffer com capacidade de 2, então o gopher scout será bloqueado toda vez que for enviado, se já houver duas partes de dados no canal. <br><br><h4>  Juntando tudo </h4><br>  Assim, armados com goroutines e canais, podemos escrever um programa usando todas as vantagens da programação multithread no Go. <br><br><img src="https://habrastorage.org/webt/cq/xa/h7/cqxah7wnmg1wbcjqwhd13gyejaw.png"><br><pre> <code class="go hljs">theMine := [<span class="hljs-number"><span class="hljs-number">5</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{<span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>} oreChannel := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) minedOreChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  go func(mine [5]string) { for _, item := range mine { if item == "ore" { oreChannel &lt;- item //   oreChannel } } }(theMine) //  go func() { for i := 0; i &lt; 3; i++ { foundOre := &lt;-oreChannel //   oreChannel fmt.Println("From Finder: ", foundOre) minedOreChan &lt;- "minedOre" //   minedOreChan } }() //  go func() { for i := 0; i &lt; 3; i++ { minedOre := &lt;-minedOreChan //   minedOreChan fmt.Println("From Miner: ", minedOre) fmt.Println("From Smelter: Ore is smelted") } }() &lt;-time.After(time.Second * 5) //    </span></span></code> </pre><br>  Esse programa produzirá o seguinte: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Finder: ore <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Finder: ore <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Miner: minedOre <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Smelter: Ore <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> smelted <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Miner: minedOre <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Smelter: Ore <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> smelted <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Finder: ore <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Miner: minedOre <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Smelter: Ore <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> smelted</code> </pre><br>  Comparado ao nosso primeiro exemplo, essa é uma grande melhoria, agora todas as funções são executadas independentemente, cada uma em sua própria goroutine.  E também recebemos um transportador de canais, através do qual o minério é transferido imediatamente após o processamento.  Para manter o foco em um entendimento básico da operação de canais e goroutines, omiti alguns pontos, o que pode levar a dificuldades no lançamento do programa.  Concluindo, quero me debruçar sobre esses recursos da linguagem, pois eles ajudam no trabalho com goroutines e canais. <br><br><h4>  Gorutins anônimos </h4><br><img src="https://habrastorage.org/webt/ko/t5/y6/kot5y6lv7cf-3h2zbyghvqwf1is.png"><br><br>  Assim como executamos uma função regular na goroutine, podemos declarar uma função anônima imediatamente após a palavra-chave <b>go</b> e chamá-la usando a seguinte sintaxe: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//   go func() { fmt.Println("I'm running in my own go routine") }()</span></span></code> </pre><br>  Assim, se precisarmos chamar uma função em apenas um lugar, podemos executá-la em uma goroutine separada sem nos preocuparmos com sua declaração prévia. <br><br><h4>  A principal função é goroutine. </h4><br><img src="https://habrastorage.org/webt/c_/bo/y7/c_boy7hpqt3y3krcd1utthdjy3s.png"><br><br>  Sim, a função <b>principal</b> funciona em sua própria goroutine.  E, mais importante, após sua conclusão, todas as outras goroutines também terminam.  É por esse motivo que efetuamos uma chamada temporizada no final de nossa função <b>principal</b> .  Essa chamada cria um canal e envia dados para ele após 5 segundos. <br><br><pre> <code class="go hljs">&lt;-time.After(time.Second * <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">//      </span></span></code> </pre><br>  Lembre-se de que a goroutine será bloqueada durante a leitura do canal até que algo seja enviado a ele?  É exatamente o que acontece quando o código especificado é adicionado.  A goroutine principal será bloqueada, dando às outras goroutias 5 segundos de tempo para trabalhar.  Este método funciona bem, mas geralmente é usada uma abordagem diferente para verificar se todas as goroutines concluíram seu trabalho.  Para transmitir um sinal sobre a conclusão do trabalho, um canal especial é criado, a goroutine principal é impedida de ler a partir dele e, assim que a goroutine filha conclui seu trabalho, ela grava nesse canal;  A goroutine principal é desbloqueada e o programa termina. <br><br><img src="https://habrastorage.org/webt/vi/4e/zv/vi4ezv-tyvzugvamrwi3z9xod8a.png"><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { doneChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//  -  doneChan &lt;- “I'm all done!” }() &lt;-doneChan //        }</span></span></code> </pre><br><h4>  Leia de um tubo em um loop de alcance </h4><br>  Em nosso exemplo, na função do goffer-getter, usamos o loop <b>for</b> para selecionar três elementos do canal.  Mas o que fazer se não se sabe com antecedência quantos dados podem existir no canal?  Nesses casos, você pode usar o canal como argumento para o loop <b>for-range</b> , assim como nas coleções.  A função atualizada pode ser assim: <br><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">//  go func() { for foundOre := range oreChan { fmt.Println(“Miner: Received “ + foundOre + “ from finder”) } }()</span></span></code> </pre><br>  Assim, o minerador lerá tudo o que o escoteiro lhe enviar, o uso do canal no ciclo garantirá isso.  Observe que após todos os dados do canal terem sido processados, o ciclo será bloqueado na leitura;  para evitar o bloqueio, você precisa fechar o canal chamando <b>close (channel)</b> . <br><br><h4>  Leitura de canal sem bloqueio </h4><br>  Usando a construção de <b>caso de seleção</b> , o bloqueio de leituras do tubo pode ser evitado.  A seguir, é apresentado um exemplo do uso dessa construção: goroutine lerá os dados do canal, se houver, caso contrário, o bloco <b>padrão</b> será executado: <br><br><pre> <code class="go hljs">myChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ myChan &lt;- “Message!” }() <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> msg := &lt;- myChan: fmt.Println(msg) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: fmt.Println(“No Msg”) } &lt;-time.After(time.Second * <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> msg := &lt;- myChan: fmt.Println(msg) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: fmt.Println(“No Msg”) }</code> </pre><br>  Uma vez iniciado, esse código produzirá o seguinte: <br><br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">No</span></span> <span class="hljs-type"><span class="hljs-type">Msg</span></span> <span class="hljs-type"><span class="hljs-type">Message!</span></span></code> </pre><br><h4>  Gravação de canal sem bloqueio </h4><br>  Bloqueios ao gravar em um canal podem ser evitados usando a mesma construção de <b>caso de seleção</b> .  Vamos fazer uma pequena edição no exemplo anterior: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> myChan &lt;- “message”: fmt.Println(“sent the message”) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: fmt.Println(“no message sent”) }</code> </pre><br><h4>  O que estudar mais </h4><br><img src="https://habrastorage.org/webt/d6/69/yd/d669ydnx51qv_h0tf-p-lbo8xyu.png"><br><br>  Há um grande número de artigos e relatórios que cobrem o trabalho com canais e goroutines com muito mais detalhes.  E agora, com o código, você tem uma idéia clara do porquê e como essas ferramentas são usadas, você pode tirar o máximo proveito dos seguintes materiais: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Google I / O 2012 - Padrões de simultaneidade Go</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Rob Pike - 'Concorrência não é paralelismo'</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GopherCon 2017: Edward Muller - Go Anti-Patterns</a> </li></ul><br><br>  Obrigado por reservar um tempo para ler.  Espero ter ajudado você a entender os canais, goroutines e os benefícios que os programas multithread oferecem. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt412715/">https://habr.com/ru/post/pt412715/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt412703/index.html">Em uma conferência com a Veeam: uma revisão do VeeamON 2018 e um convite para o VeeamON Forum em Moscou</a></li>
<li><a href="../pt412705/index.html">Hackeado no sistema: como mudamos a seleção e adaptação dos desenvolvedores</a></li>
<li><a href="../pt412709/index.html">Oh, meu código: Machine Learning e Analytics em Classmates</a></li>
<li><a href="../pt412711/index.html">Para verificar as equações de Einstein, você precisa chutar um buraco negro</a></li>
<li><a href="../pt412713/index.html">Uma visão geral das inovações mais interessantes da atualização de maio do Power BI</a></li>
<li><a href="../pt412717/index.html">Olá alienígenas; por favor não nos mate</a></li>
<li><a href="../pt412719/index.html">ODM anuncia concurso de síntese de fala</a></li>
<li><a href="../pt412721/index.html">Três esperanças da humanidade para a descoberta de alienígenas</a></li>
<li><a href="../pt412723/index.html">Procurando uma nova cor de bilhões de dólares</a></li>
<li><a href="../pt412725/index.html">Como tornar sua infraestrutura de TI chata</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>