<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèø‚Äçü§ù‚ÄçüßëüèΩ üêò üë©üèª‚ÄçüöÄ Aprendendo a programa√ß√£o Go multithread com fotos üßúüèª üö¥üèæ ‚ôÄÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Provavelmente, voc√™ j√° ouviu falar sobre a linguagem de programa√ß√£o Go, sua popularidade est√° em constante crescimento, o que √© bastante razo√°vel. Ess...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aprendendo a programa√ß√£o Go multithread com fotos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412715/"><img src="https://habrastorage.org/webt/qk/hi/im/qkhiimd_phctfhx4kka_rhpkepq.png"><br>  Provavelmente, voc√™ j√° ouviu falar sobre a linguagem de programa√ß√£o Go, sua popularidade est√° em constante crescimento, o que √© bastante razo√°vel.  Esse idioma √© simples, r√°pido e conta com uma √≥tima comunidade.  Um dos aspectos mais curiosos da linguagem √© o modelo de programa√ß√£o multithread.  As primitivas subjacentes permitem criar programas multithread com facilidade e simplicidade.  Este artigo √© destinado a quem deseja aprender essas primitivas: goroutines e canais.  E, atrav√©s das ilustra√ß√µes, mostrarei como trabalhar com elas.  Espero que seja uma boa ajuda para voc√™ em seus estudos futuros. <br><a name="habracut"></a><br><h4>  Programas √∫nicos e multithread </h4><br>  Voc√™ provavelmente j√° escreveu programas de thread √∫nico.  Normalmente, √© assim: existe um conjunto de fun√ß√µes para executar v√°rias tarefas, cada fun√ß√£o √© chamada apenas quando a anterior preparou os dados para ela.  Assim, o programa √© executado seq√ºencialmente. <br><br>  Esse ser√° o nosso primeiro exemplo - o programa de minera√ß√£o de min√©rio.  Nossas fun√ß√µes buscar√£o, extrair e processar min√©rio.  O min√©rio na mina em nosso exemplo √© representado por listas de strings, fun√ß√µes as tomam como par√¢metros e retornam uma lista de strings "processados".  Para um programa de thread √∫nico, nosso aplicativo ser√° projetado da seguinte maneira: <br><br><img src="https://habrastorage.org/webt/c5/ua/ja/c5uajayyncivzzj9_orh-u_sw34.png"><br><br>  Neste exemplo, todo o trabalho √© realizado por um thread (Gopher de Gary).  Tr√™s fun√ß√µes principais: pesquisa, produ√ß√£o e processamento s√£o executadas seq√ºencialmente uma ap√≥s a outra. <br><br><pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { theMine := [<span class="hljs-number"><span class="hljs-number">5</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{<span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>} foundOre := finder(theMine) minedOre := miner(foundOre) smelter(minedOre) }</code> </pre> <br>  Se imprimirmos o resultado de cada fun√ß√£o, obtemos o seguinte: <br><br><pre> <code class="hljs powershell">From Finder: [<span class="hljs-type"><span class="hljs-type">ore</span></span> <span class="hljs-type"><span class="hljs-type">ore</span></span> <span class="hljs-type"><span class="hljs-type">ore</span></span>] From Miner: [<span class="hljs-type"><span class="hljs-type">minedOre</span></span> <span class="hljs-type"><span class="hljs-type">minedOre</span></span> <span class="hljs-type"><span class="hljs-type">minedOre</span></span>] From Smelter: [<span class="hljs-type"><span class="hljs-type">smeltedOre</span></span> <span class="hljs-type"><span class="hljs-type">smeltedOre</span></span> <span class="hljs-type"><span class="hljs-type">smeltedOre</span></span>]</code> </pre><br>  O design e a implementa√ß√£o simples s√£o uma vantagem de uma abordagem de thread √∫nico.  Mas e se voc√™ quiser executar e executar fun√ß√µes independentemente uma da outra?  Aqui, a programa√ß√£o multithread ajuda voc√™. <br><br><img src="https://habrastorage.org/webt/om/x1/mq/omx1mqphfsqqs57lab9bngsnggi.png"><br>  Essa abordagem para a minera√ß√£o de min√©rio √© muito mais eficiente.  Agora, v√°rios threads (esquilos) trabalham de forma independente, e Gary faz apenas parte do trabalho.  Um esquilo procura min√©rio, o outro produz e o terceiro derrete, e tudo isso √© potencialmente simult√¢neo.  Para implementar essa abordagem, precisamos de duas coisas no c√≥digo: criar processadores Gopher independentemente um do outro e transferir min√©rio entre eles.  Go tem goroutines e canais para isso. <br><br><h4>  Gorutins </h4><br>  As goroutines podem ser consideradas como "threads leves". Para criar goroutines, basta colocar a palavra-chave <b>go</b> antes do c√≥digo de chamada da fun√ß√£o.  Para demonstrar como √© simples, vamos criar duas fun√ß√µes de pesquisa, cham√°-las com a palavra-chave <b>go</b> e imprimir uma mensagem toda vez que encontrarem o ‚Äúmin√©rio‚Äù na mina. <br><img src="https://habrastorage.org/webt/jz/wx/nb/jzwxnbgxocr-a0rq7kmdoujt_gg.png"><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { theMine := [<span class="hljs-number"><span class="hljs-number">5</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{<span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> finder1(theMine) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> finder2(theMine) &lt;-time.After(time.Second * <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">//       }</span></span></code> </pre><br>  A sa√≠da do nosso programa ser√° a seguinte: <br><br><pre> <code class="hljs pgsql">Finder <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore!</code> </pre><br>  Como voc√™ pode ver, n√£o h√° ordem em que a fun√ß√£o ‚Äúencontre min√©rio‚Äù primeiro;  As fun√ß√µes de pesquisa funcionam simultaneamente.  Se voc√™ executar o exemplo v√°rias vezes, a ordem ser√° diferente.  Agora podemos executar programas multithread (multi-sphere), e este √© um progresso s√©rio.  Mas o que fazer quando precisamos estabelecer uma conex√£o entre goroutines independentes?  Est√° chegando a hora da magia dos canais. <br><br><h4>  Canais </h4><br><img src="https://habrastorage.org/webt/pa/a-/5r/paa-5r_dtecx3fzem9r0dsv42jo.png"><br>  Canais permitem que goroutines troquem dados.  Este √© um tipo de tubo atrav√©s do qual as goroutins podem enviar e receber informa√ß√µes de outras goroutines. <br><img src="https://habrastorage.org/webt/-d/vp/fz/-dvpfzbpaa65exwi7l4pgerte48.png"><br>  A leitura e grava√ß√£o no canal s√£o realizadas usando o operador de seta (&lt;-), que indica a dire√ß√£o do movimento dos dados. <br><img src="https://habrastorage.org/webt/wd/1j/qp/wd1jqp8ipkwvcdgc5xbuoyy6wey.png"><br><pre> <code class="go hljs">myFirstChannel := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) myFirstChannel &lt;- <span class="hljs-string"><span class="hljs-string">"hello"</span></span> <span class="hljs-comment"><span class="hljs-comment">//    myVariable := &lt;- myFirstChannel //   </span></span></code> </pre><br>  Agora nosso escoteiro n√£o precisa acumular min√©rio, ele pode transferi-lo imediatamente usando os canais. <br><img src="https://habrastorage.org/webt/60/yx/_j/60yx_jlczbwcy2tfmsqgvzwp4dg.png"><br>  Atualizei o exemplo, agora o c√≥digo do localizador e do minerador √© de fun√ß√µes an√¥nimas.  N√£o se preocupe muito se voc√™ n√£o os encontrou antes, mas lembre-se de que cada um deles √© chamado com a palavra-chave <b>go</b> , portanto, ela ser√° executada em sua pr√≥pria goroutine.  O mais importante aqui √© que as goroutines transmitem dados entre si usando o canal <b>oreChan</b> .  E vamos lidar com fun√ß√µes an√¥nimas mais perto do fim. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { theMine := [<span class="hljs-number"><span class="hljs-number">5</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{‚Äúore1‚Äù, ‚Äúore2‚Äù, ‚Äúore3‚Äù} oreChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   go func(mine [5]string) { for _, item := range mine { oreChan &lt;- item // } }(theMine) //   go func() { for i := 0; i &lt; 3; i++ { foundOre := &lt;-oreChan // fmt.Println(‚ÄúMiner: Received ‚Äú + foundOre + ‚Äú from finder‚Äù) } }() &lt;-time.After(time.Second * 5) //     }</span></span></code> </pre><br>  A conclus√£o abaixo demonstra claramente que nosso mineiro recebe tr√™s vezes do min√©rio de canal uma por√ß√£o de cada vez. <br><br><pre> <code class="hljs cs">Miner: Received ore1 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> finder Miner: Received ore2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> finder Miner: Received ore3 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> finder</code> </pre><br>  Portanto, agora podemos transferir dados entre diferentes goroutines (Gopher), mas antes de come√ßarmos a escrever um programa complexo, vamos examinar algumas propriedades importantes dos canais. <br><br><h4>  Fechaduras </h4><br>  Em algumas situa√ß√µes, ao trabalhar com canais, a goroutin pode estar bloqueada.  Isso √© necess√°rio para que as goroutines possam sincronizar-se umas com as outras antes de come√ßar ou continuar trabalhando. <br><br><h4>  Bloqueio de grava√ß√£o </h4><br><img src="https://habrastorage.org/webt/ir/vv/zi/irvvziqxuk3opysywirescrn40e.png"><br><br>  Quando a goroutine (gopher) envia dados para um canal, ela √© bloqueada at√© que outra goroutine leia os dados do canal. <br><br><h4>  Bloqueio de leitura </h4><br><img src="https://habrastorage.org/webt/eq/e5/k8/eqe5k854n39oia6xwaavj5xfk-q.png"><br><br>  Semelhante ao bloqueio ao gravar em um canal, a goroutin pode ser bloqueada durante a leitura de um canal at√© que nada seja gravado nele. <br>  Se as fechaduras, √† primeira vista, parecerem complicadas para voc√™, voc√™ pode imagin√°-las como uma "transfer√™ncia de dinheiro" entre duas goroutinas (esquilos).  Quando um esquilo quer transferir ou receber dinheiro, ele precisa aguardar o segundo participante da transa√ß√£o. <br><br>  Depois de lidar com os bloqueios de goroutina nos canais, vamos discutir dois tipos diferentes de canais: com buffer e sem buffer.  Escolhendo esse ou aquele tipo, determinamos amplamente o comportamento do programa. <br><br><h4>  Canais sem buffer </h4><br><img src="https://habrastorage.org/webt/hv/k0/ba/hvk0badnrvqhncjqf9uwyrlowq8.png"><br><br>  Em todos os exemplos anteriores, usamos apenas esses canais.  Nesses canais, apenas um dado pode ser transmitido por vez (com bloqueio, como descrito acima). <br><br><h4>  Canais tamponados </h4><br><img src="https://habrastorage.org/webt/zs/zg/b1/zszgb15grrrjjiyaqs6gwtfkkye.png"><br><br>  Os fluxos em um programa nem sempre podem ser perfeitamente sincronizados.  Suponha, no nosso exemplo, que um gopher-scout encontrou tr√™s partes de min√©rio, enquanto um gopher-mineiro conseguiu extrair apenas uma parte das reservas encontradas ao mesmo tempo.  Aqui, para que o reconhecimento do esquilo n√£o passe a maior parte do tempo esperando o mineiro terminar seu trabalho, usaremos canais em buffer.  Vamos come√ßar criando um canal com capacidade para 3. <br><br><pre> <code class="go hljs">bufferedChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br>  Podemos enviar v√°rios dados para o canal em buffer, sem a necessidade de l√™-los com outra goroutine.  Essa √© a principal diferen√ßa em rela√ß√£o aos canais sem buffer. <br><br><img src="https://habrastorage.org/webt/sh/ok/f2/shokf2oswaiw1yk6i-uwplypezi.png"><br><pre> <code class="go hljs">bufferedChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { bufferedChan &lt;- <span class="hljs-string"><span class="hljs-string">"first"</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"Sent 1st"</span></span>) bufferedChan &lt;- <span class="hljs-string"><span class="hljs-string">"second"</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"Sent 2nd"</span></span>) bufferedChan &lt;- <span class="hljs-string"><span class="hljs-string">"third"</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"Sent 3rd"</span></span>) }() &lt;-time.After(time.Second * <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { firstRead := &lt;- bufferedChan fmt.Println(<span class="hljs-string"><span class="hljs-string">"Receiving.."</span></span>) fmt.Println(firstRead) secondRead := &lt;- bufferedChan fmt.Println(secondRead) thirdRead := &lt;- bufferedChan fmt.Println(thirdRead) }()</code> </pre><br>  A ordem de sa√≠da nesse programa ser√° a seguinte: <br><br><pre> <code class="hljs dos">Sent <span class="hljs-number"><span class="hljs-number">1</span></span>st Sent <span class="hljs-number"><span class="hljs-number">2</span></span>nd Sent <span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-built_in"><span class="hljs-built_in">rd</span></span> Receiving.. first second third</code> </pre><br>  Para evitar complica√ß√µes desnecess√°rias, n√£o usaremos canais em buffer em nosso programa.  Mas √© importante lembrar que esses tipos de canais tamb√©m est√£o dispon√≠veis para uso. <br>  Tamb√©m √© importante observar que os canais em buffer nem sempre o impedem de bloquear.  Por exemplo, se um gopher scout √© dez vezes mais r√°pido que um gopher miner, e eles s√£o conectados atrav√©s de um canal em buffer com capacidade de 2, ent√£o o gopher scout ser√° bloqueado toda vez que for enviado, se j√° houver duas partes de dados no canal. <br><br><h4>  Juntando tudo </h4><br>  Assim, armados com goroutines e canais, podemos escrever um programa usando todas as vantagens da programa√ß√£o multithread no Go. <br><br><img src="https://habrastorage.org/webt/cq/xa/h7/cqxah7wnmg1wbcjqwhd13gyejaw.png"><br><pre> <code class="go hljs">theMine := [<span class="hljs-number"><span class="hljs-number">5</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{<span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>} oreChannel := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) minedOreChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  go func(mine [5]string) { for _, item := range mine { if item == "ore" { oreChannel &lt;- item //   oreChannel } } }(theMine) //  go func() { for i := 0; i &lt; 3; i++ { foundOre := &lt;-oreChannel //   oreChannel fmt.Println("From Finder: ", foundOre) minedOreChan &lt;- "minedOre" //   minedOreChan } }() //  go func() { for i := 0; i &lt; 3; i++ { minedOre := &lt;-minedOreChan //   minedOreChan fmt.Println("From Miner: ", minedOre) fmt.Println("From Smelter: Ore is smelted") } }() &lt;-time.After(time.Second * 5) //    </span></span></code> </pre><br>  Esse programa produzir√° o seguinte: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Finder: ore <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Finder: ore <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Miner: minedOre <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Smelter: Ore <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> smelted <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Miner: minedOre <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Smelter: Ore <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> smelted <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Finder: ore <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Miner: minedOre <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Smelter: Ore <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> smelted</code> </pre><br>  Comparado ao nosso primeiro exemplo, essa √© uma grande melhoria, agora todas as fun√ß√µes s√£o executadas independentemente, cada uma em sua pr√≥pria goroutine.  E tamb√©m recebemos um transportador de canais, atrav√©s do qual o min√©rio √© transferido imediatamente ap√≥s o processamento.  Para manter o foco em um entendimento b√°sico da opera√ß√£o de canais e goroutines, omiti alguns pontos, o que pode levar a dificuldades no lan√ßamento do programa.  Concluindo, quero me debru√ßar sobre esses recursos da linguagem, pois eles ajudam no trabalho com goroutines e canais. <br><br><h4>  Gorutins an√¥nimos </h4><br><img src="https://habrastorage.org/webt/ko/t5/y6/kot5y6lv7cf-3h2zbyghvqwf1is.png"><br><br>  Assim como executamos uma fun√ß√£o regular na goroutine, podemos declarar uma fun√ß√£o an√¥nima imediatamente ap√≥s a palavra-chave <b>go</b> e cham√°-la usando a seguinte sintaxe: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//   go func() { fmt.Println("I'm running in my own go routine") }()</span></span></code> </pre><br>  Assim, se precisarmos chamar uma fun√ß√£o em apenas um lugar, podemos execut√°-la em uma goroutine separada sem nos preocuparmos com sua declara√ß√£o pr√©via. <br><br><h4>  A principal fun√ß√£o √© goroutine. </h4><br><img src="https://habrastorage.org/webt/c_/bo/y7/c_boy7hpqt3y3krcd1utthdjy3s.png"><br><br>  Sim, a fun√ß√£o <b>principal</b> funciona em sua pr√≥pria goroutine.  E, mais importante, ap√≥s sua conclus√£o, todas as outras goroutines tamb√©m terminam.  √â por esse motivo que efetuamos uma chamada temporizada no final de nossa fun√ß√£o <b>principal</b> .  Essa chamada cria um canal e envia dados para ele ap√≥s 5 segundos. <br><br><pre> <code class="go hljs">&lt;-time.After(time.Second * <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">//      </span></span></code> </pre><br>  Lembre-se de que a goroutine ser√° bloqueada durante a leitura do canal at√© que algo seja enviado a ele?  √â exatamente o que acontece quando o c√≥digo especificado √© adicionado.  A goroutine principal ser√° bloqueada, dando √†s outras goroutias 5 segundos de tempo para trabalhar.  Este m√©todo funciona bem, mas geralmente √© usada uma abordagem diferente para verificar se todas as goroutines conclu√≠ram seu trabalho.  Para transmitir um sinal sobre a conclus√£o do trabalho, um canal especial √© criado, a goroutine principal √© impedida de ler a partir dele e, assim que a goroutine filha conclui seu trabalho, ela grava nesse canal;  A goroutine principal √© desbloqueada e o programa termina. <br><br><img src="https://habrastorage.org/webt/vi/4e/zv/vi4ezv-tyvzugvamrwi3z9xod8a.png"><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { doneChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//  -  doneChan &lt;- ‚ÄúI'm all done!‚Äù }() &lt;-doneChan //        }</span></span></code> </pre><br><h4>  Leia de um tubo em um loop de alcance </h4><br>  Em nosso exemplo, na fun√ß√£o do goffer-getter, usamos o loop <b>for</b> para selecionar tr√™s elementos do canal.  Mas o que fazer se n√£o se sabe com anteced√™ncia quantos dados podem existir no canal?  Nesses casos, voc√™ pode usar o canal como argumento para o loop <b>for-range</b> , assim como nas cole√ß√µes.  A fun√ß√£o atualizada pode ser assim: <br><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">//  go func() { for foundOre := range oreChan { fmt.Println(‚ÄúMiner: Received ‚Äú + foundOre + ‚Äú from finder‚Äù) } }()</span></span></code> </pre><br>  Assim, o minerador ler√° tudo o que o escoteiro lhe enviar, o uso do canal no ciclo garantir√° isso.  Observe que ap√≥s todos os dados do canal terem sido processados, o ciclo ser√° bloqueado na leitura;  para evitar o bloqueio, voc√™ precisa fechar o canal chamando <b>close (channel)</b> . <br><br><h4>  Leitura de canal sem bloqueio </h4><br>  Usando a constru√ß√£o de <b>caso de sele√ß√£o</b> , o bloqueio de leituras do tubo pode ser evitado.  A seguir, √© apresentado um exemplo do uso dessa constru√ß√£o: goroutine ler√° os dados do canal, se houver, caso contr√°rio, o bloco <b>padr√£o</b> ser√° executado: <br><br><pre> <code class="go hljs">myChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ myChan &lt;- ‚ÄúMessage!‚Äù }() <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> msg := &lt;- myChan: fmt.Println(msg) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: fmt.Println(‚ÄúNo Msg‚Äù) } &lt;-time.After(time.Second * <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> msg := &lt;- myChan: fmt.Println(msg) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: fmt.Println(‚ÄúNo Msg‚Äù) }</code> </pre><br>  Uma vez iniciado, esse c√≥digo produzir√° o seguinte: <br><br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">No</span></span> <span class="hljs-type"><span class="hljs-type">Msg</span></span> <span class="hljs-type"><span class="hljs-type">Message!</span></span></code> </pre><br><h4>  Grava√ß√£o de canal sem bloqueio </h4><br>  Bloqueios ao gravar em um canal podem ser evitados usando a mesma constru√ß√£o de <b>caso de sele√ß√£o</b> .  Vamos fazer uma pequena edi√ß√£o no exemplo anterior: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> myChan &lt;- ‚Äúmessage‚Äù: fmt.Println(‚Äúsent the message‚Äù) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: fmt.Println(‚Äúno message sent‚Äù) }</code> </pre><br><h4>  O que estudar mais </h4><br><img src="https://habrastorage.org/webt/d6/69/yd/d669ydnx51qv_h0tf-p-lbo8xyu.png"><br><br>  H√° um grande n√∫mero de artigos e relat√≥rios que cobrem o trabalho com canais e goroutines com muito mais detalhes.  E agora, com o c√≥digo, voc√™ tem uma id√©ia clara do porqu√™ e como essas ferramentas s√£o usadas, voc√™ pode tirar o m√°ximo proveito dos seguintes materiais: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Google I / O 2012 - Padr√µes de simultaneidade Go</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Rob Pike - 'Concorr√™ncia n√£o √© paralelismo'</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GopherCon 2017: Edward Muller - Go Anti-Patterns</a> </li></ul><br><br>  Obrigado por reservar um tempo para ler.  Espero ter ajudado voc√™ a entender os canais, goroutines e os benef√≠cios que os programas multithread oferecem. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt412715/">https://habr.com/ru/post/pt412715/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt412703/index.html">Em uma confer√™ncia com a Veeam: uma revis√£o do VeeamON 2018 e um convite para o VeeamON Forum em Moscou</a></li>
<li><a href="../pt412705/index.html">Hackeado no sistema: como mudamos a sele√ß√£o e adapta√ß√£o dos desenvolvedores</a></li>
<li><a href="../pt412709/index.html">Oh, meu c√≥digo: Machine Learning e Analytics em Classmates</a></li>
<li><a href="../pt412711/index.html">Para verificar as equa√ß√µes de Einstein, voc√™ precisa chutar um buraco negro</a></li>
<li><a href="../pt412713/index.html">Uma vis√£o geral das inova√ß√µes mais interessantes da atualiza√ß√£o de maio do Power BI</a></li>
<li><a href="../pt412717/index.html">Ol√° alien√≠genas; por favor n√£o nos mate</a></li>
<li><a href="../pt412719/index.html">ODM anuncia concurso de s√≠ntese de fala</a></li>
<li><a href="../pt412721/index.html">Tr√™s esperan√ßas da humanidade para a descoberta de alien√≠genas</a></li>
<li><a href="../pt412723/index.html">Procurando uma nova cor de bilh√µes de d√≥lares</a></li>
<li><a href="../pt412725/index.html">Como tornar sua infraestrutura de TI chata</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>