<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí™üèø üè≥Ô∏è‚Äçüåà ü•¢ Kontinuierliche Integration in Yandex üê≠ ‚öæÔ∏è „äóÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Aufrechterhaltung einer riesigen Codebasis bei gleichzeitiger Gew√§hrleistung einer hohen Produktivit√§t f√ºr eine gro√üe Anzahl von Entwicklern ist e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kontinuierliche Integration in Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/428972/"><p>  Die Aufrechterhaltung einer riesigen Codebasis bei gleichzeitiger Gew√§hrleistung einer hohen Produktivit√§t f√ºr eine gro√üe Anzahl von Entwicklern ist eine ernsthafte Herausforderung.  In den letzten 5 Jahren hat Yandex ein spezielles System f√ºr die kontinuierliche Integration entwickelt.  In diesem Artikel werden wir √ºber die Gr√∂√üe der Yandex-Codebasis sprechen, √ºber die √úbertragung der Entwicklung in ein einzelnes Repository mit einem stammbasierten Entwicklungsansatz und dar√ºber, welche Aufgaben ein kontinuierliches Integrationssystem l√∂sen muss, um unter solchen Bedingungen effektiv zu arbeiten. </p><br><img src="https://habrastorage.org/webt/wb/mt/xc/wbmtxcvurtd6cdv1aomjrtcyfw8.png"><br><p>  Vor vielen Jahren hatte Yandex keine besonderen Regeln f√ºr die Entwicklung von Diensten: Jede Abteilung konnte beliebige Sprachen, Technologien und Bereitstellungssysteme verwenden.  Und wie die Praxis gezeigt hat, hat diese Freiheit nicht immer dazu beigetragen, schneller voranzukommen.  Zu dieser Zeit gab es zur L√∂sung der gleichen Probleme h√§ufig mehrere propriet√§re oder Open-Source-Entwicklungen.  Als das Unternehmen wuchs, funktionierte ein solches √ñkosystem schlechter.  Gleichzeitig wollten wir ein einziges gro√ües Yandex bleiben und uns nicht in viele unabh√§ngige Unternehmen aufteilen, da dies viele Vorteile bietet: Viele Menschen erledigen die gleichen Aufgaben, die Ergebnisse ihrer Arbeit k√∂nnen wiederverwendet werden.  Ausgehend von einer Vielzahl von Datenstrukturen wie verteilten Hash-Tabellen und Warteschlangen ohne Sperren und endend mit vielen verschiedenen speziellen Codes, die wir √ºber 20 Jahre geschrieben haben. </p><a name="habracut"></a><br><p>  Viele der Aufgaben, die wir l√∂sen, l√∂sen sich in der Open-Source-Welt nicht.  Es gibt kein MapReduce, das auf unseren Volumes (√ºber 5000 Server) und unseren Aufgaben gut funktioniert. Es gibt keinen Task-Tracker, der all unsere zig Millionen Tickets verarbeiten kann.  Das ist attraktiv in Yandex - Sie k√∂nnen wirklich gro√üartige Dinge tun. </p><br><p>  Wir verlieren jedoch ernsthaft an Effizienz, wenn wir dieselben Probleme erneut l√∂sen, vorgefertigte L√∂sungen wiederholen und die Integration zwischen Komponenten erschweren.  Es ist gut und bequem, alles nur f√ºr sich selbst in Ihrer eigenen Ecke zu tun. Sie k√∂nnen vorerst nicht an andere denken.  Sobald der Dienst jedoch ausreichend auff√§llt, weist er Abh√§ngigkeiten auf.  Es scheint nur, dass verschiedene Dienste nur schwach voneinander abh√§ngig sind - es gibt viele Verbindungen zwischen verschiedenen Teilen des Unternehmens.  Viele Dienste sind √ºber die Yandex-Anwendung / den Browser / usw. verf√ºgbar oder ineinander eingebettet.  Zum Beispiel erscheint <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alice</a> im Browser. Mit Alice k√∂nnen Sie ein Taxi bestellen.  Wir alle verwenden gemeinsame Komponenten: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">YT</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">YQL</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nirvana</a> . </p><br><p>  Das alte Entwicklungsmodell hatte erhebliche Probleme.  Aufgrund des Vorhandenseins vieler Repositories ist es f√ºr einen normalen Entwickler, insbesondere f√ºr Anf√§nger, schwierig, Folgendes herauszufinden: </p><br><ul><li>  Wo ist die Komponente? </li><li>  wie es funktioniert: Es gibt keine M√∂glichkeit zum "Nehmen und Lesen" </li><li>  Wer entwickelt und unterst√ºtzt es jetzt? </li><li>  Wie fange ich an, es zu benutzen? </li></ul><br><p> Infolgedessen trat das Problem der gegenseitigen Verwendung von Komponenten auf.  Komponenten konnten fast keine anderen Komponenten verwenden, da sie "Black Boxes" f√ºr einander darstellten.  Dies wirkte sich negativ auf das Unternehmen aus, da die Komponenten nicht nur nicht wiederverwendet, sondern h√§ufig nicht verbessert wurden.  Viele Komponenten wurden dupliziert, die Menge an Code, die unterst√ºtzt werden musste, nahm erheblich zu.  Wir bewegten uns im Allgemeinen langsamer als wir konnten. </p><br><h3 id="edinyy-repozitoriy-i-infrastruktura">  Single Repository und Infrastruktur </h3><br><p>  Vor 5 Jahren haben wir ein Projekt gestartet, um die Entwicklung auf ein einziges Repository zu √ºbertragen, mit gemeinsamen Systemen f√ºr Montage, Test, Bereitstellung und √úberwachung. </p><br><p>  Das Hauptziel, das wir erreichen wollten, war es, die Hindernisse zu beseitigen, die die Integration des Codes eines anderen verhindern.  Das System sollte einen einfachen Zugriff auf den fertigen Arbeitscode, ein klares Schema f√ºr die Verbindung und Verwendung sowie die Sammelbarkeit bieten: Projekte werden immer gesammelt (und bestehen Tests). </p><br><p>  Als Ergebnis des Projekts entstand ein einziger Stapel von Infrastrukturtechnologien f√ºr das Unternehmen: Quellcode-Speicher, Code-√úberpr√ºfungssystem, Build-System, kontinuierliches Integrationssystem, Bereitstellung, √úberwachung. </p><br><p>  Jetzt wird der gr√∂√üte Teil des Quellcodes f√ºr Yandex-Projekte in einem einzelnen Repository gespeichert oder wird gerade verschoben: </p><br><ul><li>  √úber 2000 Entwickler arbeiten an Projekten. </li><li>  mehr als 50.000 Projekte und Bibliotheken. </li><li>  Die Repository-Gr√∂√üe √ºberschreitet 25 GB. </li><li>  Mehr als 3.000.000 Commits wurden bereits f√ºr das Repository festgeschrieben. </li></ul><br><p>  Pluspunkte f√ºr das Unternehmen: </p><br><ul><li>  Jedes Projekt aus dem Repository erh√§lt eine vorgefertigte Infrastruktur: <br><ul><li>  ein System zum Anzeigen und Navigieren des Quellcodes und ein Code√ºberpr√ºfungssystem. </li><li>  Montagesystem und verteilte Montage.  Dies ist ein separates gro√ües Thema, das wir in den folgenden Artikeln auf jeden Fall behandeln werden. </li><li>  kontinuierliches Integrationssystem. </li><li>  Bereitstellung, Integration in das √úberwachungssystem. </li></ul></li><li>  Code-Sharing, aktive Teaminteraktion. </li><li>  Der gesamte Code ist √ºblich. Sie k√∂nnen zu einem anderen Projekt kommen und dort die erforderlichen √Ñnderungen vornehmen.  Dies ist besonders wichtig in einem gro√üen Unternehmen, da ein anderes Team, von dem Sie etwas ben√∂tigen, m√∂glicherweise nicht √ºber die Ressourcen verf√ºgt.  Mit dem allgemeinen Code haben Sie die M√∂glichkeit, einen Teil der Arbeit selbst zu erledigen und die √Ñnderungen zu ‚Äûunterst√ºtzen‚Äú, die Sie ben√∂tigen. </li><li>  Es besteht die M√∂glichkeit, ein globales Refactoring durchzuf√ºhren.  Sie m√ºssen keine alten Versionen Ihrer API oder Bibliothek unterst√ºtzen. Sie k√∂nnen sie √§ndern und die Stellen √§ndern, an denen sie in anderen Projekten verwendet werden. </li><li>  Der Code wird weniger "vielf√§ltig".  Sie haben eine Reihe von M√∂glichkeiten, um Probleme zu l√∂sen, und es ist nicht erforderlich, eine andere M√∂glichkeit hinzuzuf√ºgen, die ungef√§hr dasselbe bewirkt, jedoch mit geringf√ºgigen Unterschieden. </li><li>  In dem Projekt neben Ihnen wird es h√∂chstwahrscheinlich keine absolut exotischen Sprachen und Bibliotheken geben. </li></ul><br><p>  Es versteht sich auch, dass ein solches Entwicklungsmodell Nachteile aufweist, die ber√ºcksichtigt werden m√ºssen: </p><br><ul><li>  Ein gemeinsam genutztes Repository erfordert eine separate, spezifische Infrastruktur. </li><li>  Die Bibliothek, die Sie ben√∂tigen, befindet sich m√∂glicherweise nicht im Repository, ist jedoch Open Source.  Das Hinzuf√ºgen und Aktualisieren ist kostenpflichtig.  Stark abh√§ngig von Sprache und Bibliothek, irgendwo fast kostenlos, irgendwo sehr teuer. </li><li>  Sie m√ºssen st√§ndig an der "Gesundheit" des Codes arbeiten.  Dies beinhaltet zumindest den Kampf gegen unn√∂tige Abh√§ngigkeiten und toten Code. </li></ul><br><p>  Unser Ansatz f√ºr ein gemeinsames Repository legt allgemeine Regeln fest, die jeder befolgen muss.  Bei Verwendung eines einzelnen Repositorys gelten Einschr√§nkungen f√ºr die verwendeten Sprachen, Bibliotheken und Bereitstellungsmethoden.  Aber im benachbarten Projekt wird alles gleich oder sehr √§hnlich zu Ihrem sein, und Sie k√∂nnen dort sogar etwas reparieren. </p><br><p>  Das Modell eines gemeinsamen Endlagers gilt f√ºr alle gro√üen Unternehmen.  Das monolithische Repository ist ein gro√ües, gut untersuchtes und diskutiertes Thema, daher werden wir jetzt nicht mehr viel darauf eingehen.  Wenn Sie mehr wissen m√∂chten, finden Sie am Ende des Artikels mehrere n√ºtzliche Links, die dieses Thema ausf√ºhrlicher behandeln. </p><br><h3 id="usloviya-v-kotoryh-rabotaet-sistema-nepreryvnoy-integracii">  Bedingungen, unter denen das kontinuierliche Integrationssystem arbeitet </h3><br><p>  Die Entwicklung erfolgt nach dem Trunk-basierten Entwicklungsmodell.  Die meisten Benutzer arbeiten mit HEAD oder der neuesten Kopie des Repositorys, die aus dem Hauptzweig Trunk stammt, in dem die Entwicklung l√§uft.  Das Festschreiben von √Ñnderungen am Repository erfolgt nacheinander.  Unmittelbar nach dem Festschreiben ist der neue Code sichtbar und kann von allen Entwicklern verwendet werden.  Die Entwicklung in separaten Filialen wird nicht gef√∂rdert, obwohl Filialen f√ºr Releases verwendet werden k√∂nnen. </p><br><p>  Projekte h√§ngen vom Quellcode ab.  Projekte und Bibliotheken bilden ein komplexes Abh√§ngigkeitsdiagramm.  Dies bedeutet, dass √Ñnderungen, die in einem Projekt vorgenommen wurden, m√∂glicherweise Auswirkungen auf den Rest des Repositorys haben. </p><br><p>  Ein gro√üer Strom von Commits geht an das Repository: </p><br><ul><li>  mehr als 2000 Commits pro Tag. </li><li>  Bis zu 10 √Ñnderungen pro Minute w√§hrend der Hauptverkehrszeiten. </li></ul><br><p>  Die Codebasis enth√§lt √ºber 500.000 Build-Ziele und Tests. </p><br><p>  Ohne ein spezielles System der kontinuierlichen Integration unter solchen Bedingungen w√§re es sehr schwierig, schnell voranzukommen. </p><br><h3 id="sistema-nepreryvnoy-integracii">  Kontinuierliches Integrationssystem </h3><br><p>  Das kontinuierliche Integrationssystem startet Baugruppen und Tests f√ºr jede √Ñnderung: </p><br><ul><li>  Vorabpr√ºfungen.  Sie erm√∂glichen das √úberpr√ºfen des Codes vor dem Festschreiben und das Vermeiden von Unterbrechungstests im Kofferraum.  Baugruppen und Tests werden dann auf HEAD ausgef√ºhrt.  Derzeit werden freiwillige √úberpr√ºfungen vor dem Audit gestartet.  F√ºr kritische Projekte sind Vorpr√ºfungen erforderlich. </li><li>  √úberpr√ºfungen nach dem Festschreiben nach dem Festschreiben im Repository. </li></ul><br><p>  Builds und Tests werden parallel auf gro√üen Clustern von Hunderten von Servern ausgef√ºhrt.  Builds und Tests werden auf verschiedenen Plattformen ausgef√ºhrt.  Unter der Hauptplattform (Linux) werden alle Projekte zusammengestellt und alle Tests unter den anderen Plattformen ausgef√ºhrt - eine Teilmenge der vom Benutzer konfigurierbaren. </p><br><p>  Nach dem Empfang und der Analyse der Ergebnisse von Baugruppen und dem Ausf√ºhren der Tests erh√§lt der Benutzer eine R√ºckmeldung, z. B. wenn √Ñnderungen Tests unterbrechen. </p><br><img src="https://habrastorage.org/webt/kr/7s/re/kr7srek9pwwq-88vz8b3orjmtqc.png"><br><br><p>  Bei neuen Montagefehlern oder Tests senden wir eine Benachrichtigung an die Testbesitzer und den Autor der √Ñnderungen.  Das System speichert und zeigt die Ergebnisse von Pr√ºfungen auch in einer speziellen Schnittstelle an.  Die Weboberfl√§che des Integrationssystems zeigt den Fortschritt und das Ergebnis des Tests an, aufgeschl√ºsselt nach Testtyp.  Der Bildschirm mit den Scanergebnissen sieht nun folgenderma√üen aus: </p><br><img src="https://habrastorage.org/webt/c_/p-/p3/c_p-p3pb17bzgmefh0-su2gmrnc.png"><br><br><h3 id="osobennosti-i-vozmozhnosti-sistemy-nepreryvnoy-integracii">  Merkmale und F√§higkeiten des kontinuierlichen Integrationssystems </h3><br><p>  Um verschiedene Probleme von Entwicklern und Testern zu l√∂sen, haben wir unser System der kontinuierlichen Integration entwickelt.  Das System l√∂st bereits viele Probleme, aber es bleibt noch viel zu verbessern. </p><br><h4 id="tipy-i-razmery-testov">  Arten und Gr√∂√üen von Tests </h4><br><p>  Es gibt verschiedene Arten von Zielen, die ein kontinuierliches Integrationssystem ausl√∂sen kann: </p><br><ul><li>  konfigurieren.  Die vom Build-System durchgef√ºhrte Konfigurationsphase.  Die Konfiguration umfasst eine Analyse der Konfigurationsdateien des Baugruppensystems, die Ermittlung der Abh√§ngigkeiten zwischen Projekten und den Parametern der Baugruppe und die Ausf√ºhrung der Tests. </li><li>  bauen.  Zusammenstellung von Bibliotheken und Projekten. </li><li>  Stil.  Zu diesem Zeitpunkt entspricht der Codestil den angegebenen Anforderungen. </li><li>  Test.  Die Tests sind entsprechend ihrer Arbeitszeit und den Anforderungen an die Rechenressourcen in Phasen unterteilt. <br><ul><li>  klein.  &lt;1 min </li><li>  mittel.  &lt;10 min </li><li>  gro√ü.  &gt; 10 min  Dar√ºber hinaus k√∂nnen spezielle Anforderungen an die Rechenressourcen gestellt werden. </li><li>  extra gro√ü.  Dies ist eine spezielle Art von Test.  Solche Tests zeichnen sich durch eine Reihe der folgenden Merkmale aus: eine lange Betriebszeit, ein hoher Ressourcenverbrauch, eine gro√üe Menge an Eingabedaten, sie erfordern m√∂glicherweise spezielle Zugriffe und vor allem Unterst√ºtzung f√ºr die nachstehend beschriebenen komplexen Testszenarien.  Es gibt weniger solche Tests als andere Arten von Tests, aber sie sind sehr wichtig. </li></ul></li></ul><br><h4 id="chastota-zapuska-testov-i-binarnyy-poisk-polomok">  Teststartfrequenz und bin√§re Fehlererkennung </h4><br><p>  In Yandex werden riesige Ressourcen f√ºr Tests bereitgestellt - Hunderte leistungsstarker Server.  Aber selbst mit einer gro√üen Anzahl von Ressourcen k√∂nnen wir nicht alle Tests f√ºr jede √Ñnderung ausf√ºhren, die sie betrifft.  Gleichzeitig ist es f√ºr uns sehr wichtig, dem Entwickler immer dabei zu helfen, den Ort zu lokalisieren, an dem der Test unterbrochen wird, insbesondere in einem so gro√üen Repository. </p><br><p>  Was machen wir  F√ºr jede √Ñnderung f√ºr alle betroffenen Projekte werden Baugruppen, Stilpr√ºfungen und Tests mit kleinen und mittleren Gr√∂√üen ausgef√ºhrt.  Der Rest der Tests wird nicht f√ºr jedes beeinflussende Commit ausgef√ºhrt, sondern mit einer gewissen Periodizit√§t, wenn Commits die Tests beeinflussen.  In einigen F√§llen k√∂nnen Benutzer die Starth√§ufigkeit steuern, in anderen F√§llen wird die Starth√§ufigkeit vom System festgelegt.  Wenn ein Testfehler erkannt wird, beginnt der Prozess der Suche nach einem Testunterbrechungs-Commit.  Je seltener der Test ausgef√ºhrt wird, desto l√§nger suchen wir nach einem fehlerhaften Commit, nachdem ein Fehler erkannt wurde. </p><br><img width="700" src="https://habrastorage.org/webt/1b/7r/hg/1b7rhgcpvzuuqnkue2cmn8yytam.png"><br><br><p>  Beim Starten von Pre-Audit-Pr√ºfungen f√ºhren wir auch nur Baugruppen und Lichttests durch.  Anschlie√üend kann der Benutzer den Start umfangreicher Tests manuell einleiten, indem er aus der Liste der Tests ausw√§hlt, die von den vom System bereitgestellten √Ñnderungen betroffen sind. </p><br><h4 id="obnaruzhenie-migayuschih-testov">  Blinkende Testerkennung </h4><br><p>  Blinktests sind Tests, deren Laufergebnisse (bestanden / fehlgeschlagen) mit demselben Code von verschiedenen Faktoren abh√§ngen k√∂nnen.  Die Ursachen f√ºr das Flashen von Tests k√∂nnen unterschiedlich sein: Ruhezustand im Testcode, Fehler bei der Arbeit mit Multithreading, Infrastrukturprobleme (Nichtverf√ºgbarkeit von Systemen) usw.  Blinktests stellen ein ernstes Problem dar: </p><br><ul><li>  Sie f√ºhren dazu, dass das System der kontinuierlichen Integration falsche Warnungen √ºber Testfehler versendet. </li><li>  Testergebnisse kontaminieren.  Es wird immer schwieriger, √ºber den Erfolg der Verifizierungsergebnisse zu entscheiden. </li><li>  Produktfreigaben verz√∂gern. </li><li>  Schwer zu erkennen.  Tests k√∂nnen sehr selten blinken. <br>  Entwickler k√∂nnen blinkende Tests bei der Analyse der Testergebnisse ignorieren.  Manchmal falsch. <br>  Es ist unm√∂glich, Blinktests vollst√§ndig zu eliminieren, dies sollte in einem kontinuierlichen Integrationssystem ber√ºcksichtigt werden. </li></ul><br><p>  Derzeit f√ºhren wir f√ºr jeden Test alle Tests zweimal durch, um blinkende Tests zu erkennen.  Wir ber√ºcksichtigen auch Beschwerden von Nutzern (Empf√§nger von Benachrichtigungen).  Wenn wir ein Blinken feststellen, markieren wir den Test mit einem speziellen Flag (stummgeschaltet) und informieren den Besitzer des Tests.  Danach erhalten nur Testbesitzer Benachrichtigungen √ºber Testfehler.  Als N√§chstes f√ºhren wir den Test im normalen Modus weiter aus, w√§hrend wir den Verlauf seiner Starts analysieren.  Wenn der Test in einem bestimmten Zeitfenster nicht blinkt, entscheidet die Automatisierung m√∂glicherweise, dass der Test nicht mehr blinkt, und Sie k√∂nnen das Flag l√∂schen. </p><br><p>  Unser aktueller Algorithmus ist recht einfach und an dieser Stelle sind viele Verbesserungen geplant.  Zun√§chst m√∂chten wir viel n√ºtzlichere Signale verwenden. </p><br><h4 id="avtomaticheskoe-obnovlenie-vhodnyh-dannyh-testov">  Automatische Aktualisierung der Testeingabe </h4><br><p>  Beim Testen der komplexesten Yandex-Systeme werden neben anderen Testmethoden h√§ufig <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Black-Box-Strategietests</a> + <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">datengesteuerte Tests</a> verwendet.  Um eine gute Abdeckung zu gew√§hrleisten, erfordern solche Tests einen gro√üen Satz von Eingabedaten.  Daten k√∂nnen aus Produktionsclustern ausgew√§hlt werden.  Es gibt jedoch ein Problem mit der Tatsache, dass die Daten schnell veraltet sind.  Die Welt steht nicht still, unsere Systeme entwickeln sich st√§ndig weiter.  Veraltete Testdaten im Laufe der Zeit bieten keine gute Testabdeckung und f√ºhren dann vollst√§ndig zu einem Testausfall, da Programme beginnen, neue Daten zu verwenden, die in veralteten Testdaten nicht verf√ºgbar sind. </p><br><p>  Damit die Daten nicht veraltet sind, kann das kontinuierliche Integrationssystem sie automatisch aktualisieren.  Wie funktioniert es </p><br><ol><li>  Testdaten werden in einem speziellen Speicher von Ressourcen gespeichert. </li><li>  Der Test enth√§lt Metadaten, die die erforderliche Eingabe beschreiben. </li><li>  Die Entsprechung zwischen der erforderlichen Testeingabe und den Ressourcen wird in einem kontinuierlichen Integrationssystem gespeichert. </li><li>  Der Entwickler liefert regelm√§√üig frische Daten an den Ressourcenspeicher. </li><li>  Das kontinuierliche Integrationssystem sucht im Ressourcen-Repository nach neuen Versionen von Testdaten und wechselt die Eingabedaten. </li></ol><br><p>  Es ist wichtig, die Daten zu aktualisieren, damit der falsche Test nicht auftritt.  Sie k√∂nnen nicht einfach ab einem bestimmten Commit neue Daten verwenden, weil  Im Falle eines Testausfalls ist nicht klar, wer schuld ist - Commit oder neue Daten.  Au√üerdem werden Diff-Tests (unten beschrieben) au√üer Betrieb gesetzt. </p><br><img width="600" src="https://habrastorage.org/webt/yz/xq/ew/yzxqew6kgfu-irgksx-mbgejtz8.png"><br><p>  Daher machen wir es so, dass es ein kleines Intervall von Commits gibt, in denen der Test sowohl mit der alten als auch mit der neuen Version der Eingabedaten gestartet wird. </p><br><img width="700" src="https://habrastorage.org/webt/r1/zr/j8/r1zrj8e-kxo8bmnd0evq6tgzktg.png"><br><br><h4 id="diff-testy">  Diff Tests </h4><br><p>  Diff-Tests nennen wir eine spezielle Art von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">datengesteuerten Tests</a> , die sich vom allgemein akzeptierten Ansatz dadurch unterscheiden, dass der Test kein Referenzergebnis hat, aber gleichzeitig m√ºssen wir herausfinden, in welchen Commits der Test sein Verhalten ge√§ndert hat. </p><br><p>  Der Standardansatz beim datengesteuerten Testen lautet wie folgt.  Der Test hat ein Referenzergebnis, das erhalten wurde, als der Test zum ersten Mal durchgef√ºhrt wurde.  Das Referenzergebnis kann im Repository neben dem Test gespeichert werden.  Nachfolgende Testl√§ufe sollten das gleiche Ergebnis liefern. </p><br><img width="600" src="https://habrastorage.org/webt/gj/bq/gx/gjbqgx1rtrgb1lwxhih01ojki3k.png"><br><p>  Wenn das Ergebnis von der Referenz abweicht, muss der Entwickler entscheiden, ob diese erwartete √Ñnderung oder ein Fehler vorliegt.  Wenn die √Ñnderung erwartet wird, sollte der Entwickler das Referenzergebnis gleichzeitig mit dem Festschreiben der √Ñnderungen an das Repository aktualisieren. </p><br><p>  Es gibt Schwierigkeiten bei der Verwendung dieses Ansatzes in einem gro√üen Repository mit gro√üen Commit-Flows: </p><br><ol><li>  Es kann viele Tests geben und Tests k√∂nnen sehr schwierig sein.  Der Entwickler kann nicht alle betroffenen Tests in einer Arbeitsumgebung ausf√ºhren. </li><li>  Nach dem Vornehmen von √Ñnderungen kann der Test unterbrochen werden, wenn das Referenzergebnis nicht gleichzeitig mit den √Ñnderungen am Code aktualisiert wurde.  Dann kann ein anderer Entwickler √Ñnderungen an derselben Komponente vornehmen, und das Testergebnis √§ndert sich erneut.  Wir bekommen die Auferlegung eines Fehlers auf einen anderen.  Es ist sehr schwierig, mit solchen Problemen umzugehen, es braucht Zeit von Entwicklern. </li></ol><br><p>  Was machen wir  Diff-Tests bestehen aus 2 Teilen: </p><br><ul><li>  Komponente pr√ºfen. <br><ul><li>  Wir starten den Test und speichern das Ergebnis bei der Speicherung von Ressourcen. </li><li>  Vergleichen Sie das Ergebnis nicht mit der Referenz. </li><li>  Wir k√∂nnen einige der Fehler abfangen, zum Beispiel, das Programm startet nicht / endet nicht, st√ºrzt ab, das Programm reagiert nicht.  Die Validierung des Ergebnisses kann auch durchgef√ºhrt werden: Vorhandensein von Feldern in der Antwort usw. </li></ul></li><li>  Diff-Komponente. <br><ul><li>  Vergleichen Sie die Ergebnisse verschiedener Starts und bauen Sie diff.  Im einfachsten Fall ist dies eine Funktion, die 2 Parameter akzeptiert und diff zur√ºckgibt. </li><li>  Das Aussehen von diff h√§ngt vom Test ab, aber es sollte f√ºr jemanden verst√§ndlich sein, der sich mit diff befasst.  Normalerweise ist diff eine HTML-Datei. </li></ul></li></ul><br><p>  Der Start von Check- und Diff-Komponenten wird durch ein kontinuierliches Integrationssystem gesteuert. </p><br><img width="600" src="https://habrastorage.org/webt/jp/g2/2z/jpg22zjvje4rqvytyy8-qlrf-yo.png"><br><br><p>  Wenn das kontinuierliche Integrationssystem diff erkennt, wird zuerst eine bin√§re Suche nach dem Commit durchgef√ºhrt, das die √Ñnderung verursacht hat.  Nachdem Sie eine Benachrichtigung vom Entwickler erhalten haben, k√∂nnen Sie diff untersuchen und entscheiden, was als n√§chstes zu tun ist: erkennen Sie diff wie erwartet (hierf√ºr m√ºssen Sie eine spezielle Aktion ausf√ºhren) oder reparieren / "rollen" Sie Ihre √Ñnderungen zur√ºck. </p><br><h3 id="prodolzhenie-sleduet">  Fortsetzung folgt </h3><br><p>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">n√§chsten Artikel werden</a> wir dar√ºber sprechen, wie das System der kontinuierlichen Integration funktioniert. </p><br><h3 id="ssylki">  Referenzen </h3><br><p>  Monolithisches Repository, Trunk-basierte Entwicklung </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Monorepo - Wikipedia</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://trunkbaseddevelopment.com</a> </li></ul><br><p>  Datengesteuertes Testen </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datengesteuertes Testen - Wikipedia</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428972/">https://habr.com/ru/post/de428972/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428954/index.html">Wie wir uns ins Bein geschossen haben und versucht haben herauszufinden, was genau</a></li>
<li><a href="../de428956/index.html">Drohnen auf der ISS</a></li>
<li><a href="../de428960/index.html">Bericht des Club of Rome 2018, Kapitel 1.5: Climate Challenge</a></li>
<li><a href="../de428962/index.html">Umzug in Luxoft: Wie bleibt das Leben?</a></li>
<li><a href="../de428964/index.html">Hardware-verschl√ºsselte SSD-Sicherheitsl√ºcken erm√∂glichen es Angreifern, die Sicherheit einfach zu umgehen</a></li>
<li><a href="../de428974/index.html">Interessant bei Interlight 2018</a></li>
<li><a href="../de428976/index.html">Ameisenh√ºgel oder Festung? Ich baue ein Haus zum Preis einer Wohnung. Teil 2: Heizen</a></li>
<li><a href="../de428980/index.html">Offline JavaScript Broker</a></li>
<li><a href="../de428982/index.html">Wie schreibe ich D auf ARM</a></li>
<li><a href="../de428984/index.html">Julia und Phasenportr√§ts dynamischer Systeme</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>