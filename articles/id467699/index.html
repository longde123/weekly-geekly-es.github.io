<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçù üëí ‚õπüèª Bagaimana tidak, membuat strlen tercepat dan menemukan kekurangan di Visual Studio 2019 Community üë©üèæ‚Äçü§ù‚Äçüë®üèø üïë ‚úùÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya diminta oleh sebuah artikel tentang menggunakan instruksi popcount "aneh" dalam prosesor modern . Ini bukan tentang menghitung jumlah unit, tetap...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana tidak, membuat strlen tercepat dan menemukan kekurangan di Visual Studio 2019 Community</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467699/">  Saya diminta oleh sebuah artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tentang menggunakan instruksi popcount "aneh" dalam prosesor modern</a> .  Ini bukan tentang menghitung jumlah unit, tetapi tentang mendeteksi tanda akhir garis C (garis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">putus-nol</a> ). <br><blockquote>  String null-terminated adalah cara untuk mewakili string dalam bahasa pemrograman, di mana alih-alih memperkenalkan tipe string khusus, array karakter digunakan, dan ujung string adalah karakter null khusus pertama yang ditemui (NUL dari kode ASCII, dengan nilai 0). </blockquote><br>  Untuk menentukan panjang istilah seperti itu, fungsi standar diterapkan. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> __<span class="hljs-function"><span class="hljs-function">cdecl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">strlen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* str)</span></span></span></span></code> </pre> <br>  Algoritma operasi yang dapat dijelaskan dalam C sebagai: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> strlen_algo(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* str) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (*str++) length++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length; }</code> </pre> <br>  Mari kita lihat apa yang kompiler komunitas MS Visual Studio 2019 (Rilis, x86) mengubahnya menjadi: <br><br><pre> <code class="plaintext hljs">08811F7h: mov al,byte ptr [ecx] inc ecx test al,al jne main+0D7h (08811F7h)</code> </pre><a name="habracut"></a><br>  Artinya, satu byte dimuat dari memori dan dibandingkan dengan nol.  Kode yang sama diganti untuk panggilan strlen jika Anda membangun proyek di Release, algoritmenya benar, tetapi kecepatannya, menurut saya, tidak cukup.  Apa yang terjadi jika Anda mengkompilasi kode dengan panggilan ke strlen standar di Debug?  - Fungsi pustaka strlen akan dipanggil, seperti yang diharapkan, tetapi ditulis oleh seseorang secara manual pada assembler. <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler kode fungsi strlen standar di MS Visual Studio</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">;strlen.asm - contains strlen() routine ; ; Copyright (c) Microsoft Corporation. All rights reserved. ; ;Purpose: ; strlen returns the length of a null-terminated string, ; not including the null byte itself. ; ;******************************************************************************* .xlist include cruntime.inc .list page ;*** ;strlen - return the length of a null-terminated string ; ;Purpose: ; Finds the length in bytes of the given string, not including ; the final null character. ; ; Algorithm: ; int strlen (const char * str) ; { ; int length = 0; ; ; while( *str++ ) ; ++length; ; ; return( length ); ; } ; ;Entry: ; const char * str - string whose length is to be computed ; ;Exit: ; EAX = length of the string "str", exclusive of the final null byte ; ;Uses: ; EAX, ECX, EDX ; ;Exceptions: ; ;******************************************************************************* CODESEG public strlen strlen proc \ buf:ptr byte OPTION PROLOGUE:NONE, EPILOGUE:NONE .FPO ( 0, 1, 0, 0, 0, 0 ) string equ [esp + 4] mov ecx,string ; ecx -&gt; string test ecx,3 ; test if string is aligned on 32 bits je short main_loop str_misaligned: ; simple byte loop until string is aligned mov al,byte ptr [ecx] add ecx,1 test al,al je short byte_3 test ecx,3 jne short str_misaligned add eax,dword ptr 0 ; 5 byte nop to align label below align 16 ; should be redundant main_loop: mov eax,dword ptr [ecx] ; read 4 bytes mov edx,7efefeffh add edx,eax xor eax,-1 xor eax,edx add ecx,4 test eax,81010100h je short main_loop ; found zero byte in the loop mov eax,[ecx - 4] test al,al ; is it byte 0 je short byte_0 test ah,ah ; is it byte 1 je short byte_1 test eax,00ff0000h ; is it byte 2 je short byte_2 test eax,0ff000000h ; is it byte 3 je short byte_3 jmp short main_loop ; taken if bits 24-30 are clear and bit ; 31 is set byte_3: lea eax,[ecx - 1] mov ecx,string sub eax,ecx ret byte_2: lea eax,[ecx - 2] mov ecx,string sub eax,ecx ret byte_1: lea eax,[ecx - 3] mov ecx,string sub eax,ecx ret byte_0: lea eax,[ecx - 4] mov ecx,string sub eax,ecx ret strlen endp end</code> </pre><br></div></div><br>  Tabel 1 - runtime dari tolok ukur strlen dalam hitungan detik (komunitas MS VS 2019, versi C ++ cl: 19.22.27905) <br><br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Blok besar, 1K </th><th>  Blok besar, 1K, * panggilan strlen </th><th>  Blok kecil, 10 elemen </th><th>  Blok kecil, 10 elemen, * panggilan strlen </th></tr><tr><td>  <b>Debug, x86</b> </td><td>  7.25 </td><td>  7.25 </td><td>  3.06 </td><td>  3.06 </td></tr><tr><td>  <b>Rilis, x86</b> </td><td>  9.0 </td><td>  3.9 </td><td>  0,15 </td><td>  0,12 </td></tr><tr><td>  <b>Debug, x64</b> </td><td>  6.0 </td><td>  6.0 </td><td>  3.4 </td><td>  3.4 </td></tr><tr><td>  <b>Rilis, x64</b> </td><td>  8.5 </td><td>  2.3 </td><td>  0,15 </td><td>  0,11 </td></tr></tbody></table></div><br>  * memaksa kompiler untuk memanggil fungsi pustaka strlen <br><br>  Dengan demikian, kita dapat menyimpulkan bahwa substitusi perbandingan byte oleh kompiler MS tidak efisien bahkan pada string kecil, dan pada string besar, Debug berada di depan Release! <br><br><div class="spoiler">  <b class="spoiler_title">Kode Bench</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;chrono&gt; #include &lt;nmmintrin.h&gt; inline size_t strlen_algo(const char* str) { size_t length = 0; while (*str++) length++; return length; } inline size_t strlen_sse4(const char* str) { size_t length = 0; int res = 0; //align to 16 bytes while (((size_t(str+length)) &amp; (sizeof(__m128i) - 1)) != 0) { if (str[length] == 0) return length; length++; } __m128i z128 = _mm_setzero_si128(); for(; ; length += 16) { __m128i data = _mm_load_si128((__m128i*)(str + length)); if ((res = _mm_cmpistri(z128, data, _SIDD_CMP_EQUAL_EACH)) != 16) break; } /*while (str[length]) length++;*/ return length + res; } #define _DISABLE_ASM_BSF //https://www.strchr.com/sse2_optimised_strlen #ifndef WORDS_BIGENDIAN #if 0 #elif 0 #else static inline int count_bits_to_0(unsigned int x) // counting trailing zeroes, by Nazo, post: 2009/07/20 03:40 { // this is current winner for speed static const unsigned char table[256] = { 7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, }; if ((unsigned char)x) return table[(unsigned char)x]; return table[x &gt;&gt; 8] + 8; // t[x / 256] + 8 } #endif #else #if 0 static inline int count_bits_to_0(unsigned int x) // counting trailing zeroes { register int i = 0; if (!(x &amp; (1 &lt;&lt; 15))) i++; else return i; if (!(x &amp; (1 &lt;&lt; 14))) i++; else return i; if (!(x &amp; (1 &lt;&lt; 13))) i++; else return i; if (!(x &amp; (1 &lt;&lt; 12))) i++; else return i; if (!(x &amp; (1 &lt;&lt; 11))) i++; else return i; if (!(x &amp; (1 &lt;&lt; 10))) i++; else return i; if (!(x &amp; (1 &lt;&lt; 9))) i++; else return i; if (!(x &amp; (1 &lt;&lt; 8))) i++; else return i; if (!(x &amp; (1 &lt;&lt; 7))) i++; else return i; if (!(x &amp; (1 &lt;&lt; 6))) i++; else return i; if (!(x &amp; (1 &lt;&lt; 5))) i++; else return i; if (!(x &amp; (1 &lt;&lt; 4))) i++; else return i; if (!(x &amp; (1 &lt;&lt; 3))) i++; else return i; if (!(x &amp; (1 &lt;&lt; 2))) i++; else return i; if (!(x &amp; (1 &lt;&lt; 1))) i++; else return i; if (!(x &amp; (1 &lt;&lt; 0))) i++; return i; } #else static inline int count_bits_to_0(unsigned int x) // counting trailing zeroes { // http://www.hackersdelight.org/: nlz1() shortened for 16-bit mask register int n = 0; if (x &lt;= 0x000000FFU) { n = n + 8; x = x &lt;&lt; 8; } if (x &lt;= 0x00000FFFU) { n = n + 4; x = x &lt;&lt; 4; } if (x &lt;= 0x00003FFFU) { n = n + 2; x = x &lt;&lt; 2; } if (x &lt;= 0x00007FFFU) { n = n + 1; } return n; } #endif #endif size_t strlen2(const char* str) { register size_t len = 0; // align to 16 bytes while ((((intptr_t)str) &amp; (sizeof(__m128i) - 1)) != 0) { if (*str++ == 0) return len; ++len; } // search for 0 __m128i xmm0 = _mm_setzero_si128(); __m128i xmm1; int mask = 0; for (;;) { xmm1 = _mm_load_si128((__m128i*)str); xmm1 = _mm_cmpeq_epi8(xmm1, xmm0); if ((mask = _mm_movemask_epi8(xmm1)) != 0) { // got 0 somewhere within 16 bytes in xmm1, or within 16 bits in mask // find index of first set bit #ifndef _DISABLE_ASM_BSF // define it to disable ASM #if (_MSC_VER &gt;= 1300) // make sure &lt;intrin.h&gt; is included unsigned long pos; _BitScanForward(&amp;pos, mask); len += (size_t)pos; #elif defined(_MSC_VER) // earlier MSVC's do not have _BitScanForward, use inline asm __asm bsf edx, mask; edx = bsf(mask) __asm add edx, len; edx += len __asm mov len, edx; len = edx #elif ((__GNUC__ &gt;= 4) || ((__GNUC__ == 3) &amp;&amp; (__GNUC_MINOR__ &gt;= 4))) // modern GCC has built-in __builtin_ctz len += __builtin_ctz(mask); #elif defined(__GNUC__) // older GCC shall use inline asm unsigned int pos; asm("bsf %1, %0" : "=r" (pos) : "rm" (mask)); len += (size_t)pos; #else // none of choices exist, use local BSF implementation len += count_bits_to_0(mask); #endif #else len += count_bits_to_0(mask); #endif break; } str += sizeof(__m128i); len += sizeof(__m128i); } return len; } int main() { std::vector&lt;std::string&gt; vstr; const int str_num = 1024; const int str_size = 1024; size_t len_result = 0; srand(0); for (int i = 0; i &lt; str_num; i++) { std::string str1; for (int j = 0; j &lt; str_size; j++) { str1.push_back('0' + rand() % 78); } vstr.push_back(std::move(str1)); } auto strlen_func = strlen; //auto strlen_func = strlen_algo; //auto strlen_func = strlen_sse4; //auto strlen_func = strlen2; auto time_std = std::chrono::steady_clock::now(); for (int k = 0; k &lt; 10*1000; k++) { for (int i = 0; i &lt; str_num; i++) { const char* str_for_test = vstr[i].c_str(); len_result += strlen_func(str_for_test); //len_result += strlen(str_for_test); } for (int i = 0; i &lt; str_num; i++) { const char* str_for_test = vstr[i].c_str(); len_result -= strlen_func(str_for_test); //len_result -= strlen(str_for_test); } } auto finish = std::chrono::steady_clock::now(); double elapsed_seconds = std::chrono::duration_cast&lt;std::chrono::duration&lt;double&gt;&gt;(finish - time_std).count(); std::cout &lt;&lt; "\n" &lt;&lt; len_result; std::cout &lt;&lt; "\n\nTime: " &lt;&lt; elapsed_seconds; return 0; }</span></span></span></span></code> </pre><br></div></div><br>  Tali <pre> <code class="cpp hljs">len_result += <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(str_for_test);</code> </pre>  kompilasi <br>  Debug di: memanggil fungsi perpustakaan strlen; <br>  Rilis dalam: perbandingan byte. <br><br>  Jika Anda berkomentar dan menulisnya <br><br><pre> <code class="cpp hljs">len_result += strlen_func(str_for_test);</code> </pre> <br>  dimana <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> strlen_func = <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>;</code> </pre> <br>  kami akan memaksa kompiler untuk selalu memanggil fungsi perpustakaan. <br><br>  Karena apa percepatan fungsi perpustakaan dicapai sebelum perbandingan byte sebesar 2,3 kali (untuk Rilis, x86, 1k)? <br><br>  Karena perbandingan tidak dengan satu byte, tetapi langsung oleh 4. Semua keajaiban di sini: <br><br><pre> <code class="plaintext hljs">main_loop: mov eax,dword ptr [ecx] ; read 4 bytes mov edx,7efefeffh add edx,eax xor eax,-1 xor eax,edx add ecx,4 test eax,81010100h je short main_loop</code> </pre><br>  Apakah mungkin melakukan lebih cepat menggunakan instruksi vektor prosesor modern?  Ayo kita coba. <br><br>  Menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">panduan Intel Intrinsics</a> , kami menemukan _mm_cmpistri SSE4.2 intrinsik, yang dirancang hanya untuk bekerja dengan string.  Dua vektor dengan panjang 128 bit dan penutup operasi diumpankan ke input.  Sebagai mask, kami menggunakan: _SIDD_UBYTE_OPS = 0 - tipe data, _SIDD_CMP_EQUAL_EACH = 8 - operasi perataan byte, dan kami akan membandingkan dengan vektor nol.  Nilai yang dikembalikan akan menjadi jumlah elemen tidak sama berpasangan pertama (yaitu, jika elemen cocok dari kiri ke kanan, penghitungan berhenti, saya akan senang jika seseorang mengkonfirmasi perilaku). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> res = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//align to 16 bytes while (((size_t(str+length)) &amp; (sizeof(__m128i) - 1)) != 0) { if (str[length] == 0) return length; length++; } __m128i z128 = _mm_setzero_si128(); for(; ; length += 16) { __m128i data = _mm_load_si128((__m128i*)(str + length)); if ((res = _mm_cmpistri(z128, data, _SIDD_CMP_EQUAL_EACH)) != 16) break; } /*while (str[length]) length++;*/ return length + res;</span></span></code> </pre><br>  Kode <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>(str+length)) &amp; (<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(__m128i) - <span class="hljs-number"><span class="hljs-number">1</span></span>)) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str[length] == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length; length++; }</code> </pre><br>  Berfungsi untuk menyamakan alamat jalur yang dimuat, alamat tersebut diperlukan dalam kelipatan 16 agar sebagian besar instruksi SSE dapat berfungsi.  Untuk instruksi pcmpistri yang digunakan oleh kami, penyelarasan benar-benar tidak diperlukan, pengecualian akses tidak akan dibuang. <br>  Intrinsik <br><pre> <code class="cpp hljs">__m128i data = _mm_load_si128((__m128i*)(str + length)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((res = _mm_cmpistri(z128, data, _SIDD_CMP_EQUAL_EACH)) != <span class="hljs-number"><span class="hljs-number">16</span></span>)</code> </pre> <br>  Dikompilasi menjadi: <br><pre> <code class="plaintext hljs">pcmpistri xmm1,xmmword ptr [eax+edx],8</code> </pre> <br>  Namun, menyelaraskan ke 16 juga berguna dalam kasus kami, ini memberikan sedikit peningkatan dalam kecepatan, dan jadi kami yakin bahwa siklus baca 16 byte tidak akan pergi ke halaman yang berpotensi tidak dialokasikan ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman memori 4K</a> ). <br><br>  Siklus: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (str[length]) length++;</code> </pre><br>  <s>"Mendapat" ukuran string jika ujungnya terdeteksi (karena saya tidak sepenuhnya yakin tentang algoritma operasi _mm_cmpistri).</s> <br>  dihapus setelah komentar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">picul</a> , yang memberi peningkatan pada baris kecil. <br><br>  Apakah kami membuat strlen tercepat?  - Sayangnya, tidak, orang-orang dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.strchr.com/sse2_optimised_strlen</a> bahkan lebih cepat dan tanpa menggunakan SSE4.2. <br><br>  Tabel 2 - runtime dari tolok ukur strlen dalam hitungan detik (Rilis) <br><div class="scrollable-table"><table><tbody><tr><th>  Jumlah karakter </th><th>  Perbandingan MS byte </th><th>  Ms strlen </th><th>  SSE 4.2 </th><th>  SSE 2 </th></tr><tr><td>  <b>10, x86</b> </td><td>  0,15 </td><td>  0,12 </td><td>  0,12 </td><td>  0,125 </td></tr><tr><td>  <b>1 r, x86</b> </td><td>  9.0 </td><td>  3.9 </td><td>  1.65 </td><td>  1.42 </td></tr><tr><td>  <b>10, x64</b> </td><td>  0,15 </td><td>  0,11 </td><td>  0,08 </td><td>  0,1 </td></tr><tr><td>  <b>1 rb, x64</b> </td><td>  8.5 </td><td>  2.3 </td><td>  1.6 </td><td>  1.32 </td></tr></tbody></table></div><br>  Kesimpulan: <br><br>  Sepertinya saya bahwa MS selalu perlu memanggil library strlen, dan tidak melakukan perbandingan byte substitusi. <br><br>  UPD <br>  Menambahkan tes x64. <br>  Menghapus loop terakhir di strlen_SSE4 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467699/">https://habr.com/ru/post/id467699/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467683/index.html">Mencoba menyusun skema docking yang tidak dapat dikomposisikan</a></li>
<li><a href="../id467689/index.html">Gambaran kecil tentang SIMD di .NET / C #</a></li>
<li><a href="../id467691/index.html">Intel Nervana NNP-T dan NNP-I - chip khusus untuk AI</a></li>
<li><a href="../id467693/index.html">September Digest Event TI (Bagian Dua)</a></li>
<li><a href="../id467697/index.html">Benarkah GOPATH dan GOROOT tidak lagi dibutuhkan?</a></li>
<li><a href="../id467701/index.html">Kategori bukan direktori. Alat untuk penyimpanan file yang nyaman</a></li>
<li><a href="../id467703/index.html">IT Afrika: Perusahaan dan Startup Teknologi Paling Menarik di Benua</a></li>
<li><a href="../id467705/index.html">Paramagnon dan magnon: energi dari panas</a></li>
<li><a href="../id467707/index.html">Cara mengkonfigurasi Linux untuk memasuki domain menggunakan algoritma GOST</a></li>
<li><a href="../id467711/index.html">IOT, kabut dan awan: bicara tentang teknologi?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>