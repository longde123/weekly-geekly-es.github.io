<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßñ ‚ö†Ô∏è üï∫üèø Tic Tac Toe "Sin Fronteras" ‚òπÔ∏è üöï üë®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tic-tac-toe ... todos los jugaron, estoy seguro. El juego es atractivo en su simplicidad, especialmente cuando arrastra el reloj a alg√∫n lugar de la l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tic Tac Toe "Sin Fronteras"</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430708/"> Tic-tac-toe ... todos los jugaron, estoy seguro.  El juego es atractivo en su simplicidad, especialmente cuando arrastra el reloj a alg√∫n lugar de la lecci√≥n, un par, y no hay nada a mano excepto una hoja de cuaderno y un simple l√°piz.  No s√© qui√©n fue el primero en adivinar que dibuj√≥ cruces y c√≠rculos en 9 casillas, pero desde entonces el juego no ha perdido demanda en absoluto, especialmente desde que la gente present√≥ muchas de sus variaciones. <br><br><img src="https://habrastorage.org/webt/pd/gx/-c/pdgx-cibc6880fmwfxt90nxmi-k.jpeg"><br><br>  Este art√≠culo trata sobre el proceso de desarrollo de IA en javascript para reproducir una de estas variaciones de tic-tac-toe: obtuve mucho material, pero lo dilu√≠ con animaci√≥n e im√°genes.  En cualquier caso, al menos vale la pena intentarlo. <br>  Las diferencias entre esta versi√≥n del juego y la original son las siguientes: <br><br><ol><li>  <b>El campo</b> puede ser arbitrariamente <b>grande</b> (¬øCu√°nto durar√° la computadora port√°til?) </li><li>  El ganador es el que pone <b>5 piezas</b> (si puede llamarlas as√≠) en una fila. </li></ol><br>  Todo es simple ... y al mismo tiempo complicado: el resultado del juego no se puede calcular de antemano, como en el an√°logo cl√°sico.  Esta "peque√±a proyecci√≥n" me quit√≥ mucho tiempo y nervios.  Espero que lo encuentres interesante. <a name="habracut"></a><br><br><h3>  Antes de comenzar </h3><br>  Obligado a pedir disculpas de antemano por el volumen del art√≠culo y, en algunos lugares, la presentaci√≥n de pensamiento no del todo inteligible, sin embargo, no pude exprimir al reba√±o sin p√©rdida de contenido y calidad. <br>  Le recomiendo que primero se familiarice con el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">resultado</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥digo</a> <br><br>  Teclas de acceso r√°pido y comandos: <br><br><ul><li>  <b>D</b> - AI har√° un movimiento por ti </li><li>  <b>T</b> - ver peso celular </li><li>  Escriba <b>SHOW_WEIGHTS = true</b> en la consola para ver los pesos de todas las celdas analizadas. </li></ul><br><h3>  Empecemos </h3><br>  Debes comenzar con la implementaci√≥n del juego en s√≠, es decir  escribe una aplicaci√≥n para dos jugadores, hasta ahora sin bot.  Para mis prop√≥sitos, decid√≠ usar javascript + jquery + bootstrap4, aunque pr√°cticamente no se usa all√≠, pero es mejor dejarlo, o la tabla flotar√°.  No hay nada especial que contar, hay mucho material sobre js, jquery y bootstrap.  Solo puedo decir que us√© MVC.  De todos modos, no explicar√© absolutamente todo el c√≥digo, ya ha habido mucho material. <br><br>  Entonces, el campo de juego estaba listo.  Puede establecer formas en celdas.  Pero la victoria de cualquiera de los jugadores no fue arreglada de ninguna manera. <br><br><h3>  Fin del escaneo del juego </h3><br>  El juego termina cuando uno de los jugadores pone <b>5 piezas</b> seguidas.  "¬°Es simple!"  Pens√©  Y comenz√≥ a escanear absolutamente todas las celdas del campo: primero todas las horizontales, luego las verticales y finalmente las diagonales. <br><br>  Esta es una manera tonta, pero funcion√≥.  Sin embargo, podr√≠a mejorarse significativamente, lo cual hice: la mayor√≠a de las celdas permanecer√°n vac√≠as durante todo el juego; el campo de juego es demasiado grande para llenarse por completo.  Como era necesario escanearlo en cada movimiento, y solo se coloca una pieza en un movimiento, puede enfocarse solo en esta pieza (celda): escanee solo una horizontal, vertical y dos diagonales de la celda que posee la misma celda. <br><br>  Adem√°s, no necesita escanear todas las l√≠neas celulares.  Como el final del juego es de 5 piezas seguidas, las piezas que est√°n separadas por 6 celdas no nos interesan.  Es suficiente escanear cinco celdas en cada lado.  No entiendo?  Vea la animaci√≥n a continuaci√≥n. <br><br><img src="https://habrastorage.org/webt/nt/fj/wu/ntfjwuj6nfabfj2qtedcs4g-fp0.gif"><br><br><div class="spoiler">  <b class="spoiler_title">Ver c√≥digo</b> <div class="spoiler_text"><pre><code class="javascript hljs">checkWin( cellX, cellY ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newFig = getFig(cellX,cellY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ! newFig ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res; res = res || checkLine( cellX, cellY, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ); <span class="hljs-comment"><span class="hljs-comment">//horizontal res = res || checkLine( cellX, cellY, 0, 1 ); //vertical res = res || checkLine( cellX, cellY, 1, 1 ); //diagonal 45 res = res || checkLine( cellX, cellY, 1, -1 ); //diagonal 135 return res; function getFig( x, y ){ return Model.Field[x] &amp;&amp; Model.Field[x][y] ? Model.Field[x][y] : 'b'; } function checkLine( x, y, dx, dy ){ x = +x; y = +y; var score = 0; while( getFig( x - dx, y - dy ) == newFig ){ x -= dx; y -= dy; } while( getFig( x, y ) == newFig ){ x += dx; y += dy; score++; } if( score &gt;= 5 ) return true; return false; } }</span></span></code> </pre> <br></div></div><br><h3>  Vamos al bot mismo </h3><br>  Entonces, ya hemos escrito una p√°gina con tres en raya.  Pasamos a la tarea principal: AI. <br>  No puede simplemente tomar y escribir c√≥digo si no sabe c√≥mo: debe pensar en la l√≥gica del bot. <br><br>  La conclusi√≥n es analizar el campo de juego, al menos parte de √©l, y calcular el <b>precio (peso) de</b> cada celda en el campo.  La celda con el peso m√°s alto, la m√°s prometedora, el bot pondr√° una cifra all√≠.  La principal dificultad est√° en calcular el peso de una celda. <br><br><h3>  Terminolog√≠a </h3><br>  <b>Las cruces y los dedos</b> son figuras. <br>  <b>Un ataque</b> se llamar√° varias figuras id√©nticas de pie lado a lado en la misma l√≠nea.  De hecho, esto es mucho.  El n√∫mero de piezas en un ataque es su <b>poder</b> .  Una pieza separada tambi√©n es un ataque (potencia 1). <br><br>  En las celdas de ataque adyacentes (en los extremos) puede haber celdas vac√≠as o piezas enemigas.  Es l√≥gico pensar que un ataque con dos celdas vac√≠as en los "extremos" se puede desarrollar en dos direcciones, lo que lo hace m√°s prometedor.  El n√∫mero de celdas vac√≠as en los "extremos" del ataque se denominar√° <b>potencial</b> .  El potencial puede ser 0, 1 o 2. <br>  Denotamos los ataques de la siguiente manera: <b>[poder de ataque, potencial]</b> .  Por ejemplo, un <b>ataque [4: 1]</b> . <br><br><img src="https://habrastorage.org/webt/1_/pk/e3/1_pke3kve1yjbf6cjjzg3hnnzvm.jpeg"><br>  <i>Figura 1. Ataque [4: 1]</i> <br><br>  En el curso del an√°lisis, evaluaremos todas las celdas que ingresan a un √°rea espec√≠fica.  Cada celda calcular√° su <b>peso</b> .  Se calcula en funci√≥n de los pesos de todos los ataques que afecta esta c√©lula. <br><br><h3>  La esencia del an√°lisis. </h3><br>  Imagine que en el campo de juego ya hay varios ataques de uno y el segundo jugador.  Uno de los jugadores hace un movimiento (deja los cruces).  Naturalmente, se muda a una celda vac√≠a y, por lo tanto, puede: <br><br><ol><li>  Desarrolla tu ataque, y quiz√°s m√°s de uno, aumentando su poder.  Puede lanzar un nuevo ataque, etc. </li><li>  Prevenir el desarrollo de un ataque enemigo o bloquearlo por completo. </li></ol><br>  Es decir, nuestro protagonista puede atacar y defender.  O tal vez todo de una vez.  Para √©l, tanto el primero como el segundo son importantes. <br><br>  La esencia del an√°lisis es la siguiente: <br><br><ol><li>  El bot sustituye las cifras en la celda marcada: primero una cruz, luego un cero. </li><li>  Luego busca todos los ataques que fueron recibidos por tales movimientos y resume sus pesos. </li><li>  La cantidad recibida es el peso de la celda. </li><li>  Se realiza un algoritmo similar para todas las celdas del campo de juego. </li></ol><br><img src="https://habrastorage.org/webt/ur/rc/qz/urrcqzyrjrnp9oupxjoqc1iu6wg.gif"><br><br>  De hecho, verificamos con tal algoritmo qu√© suceder√° si vamos por este camino ... y qu√© suceder√° si el oponente va por ese camino.  Esperamos un paso y seleccionamos la celda m√°s adecuada, con el mayor peso. <br><br>  Si una c√©lula tiene m√°s peso que otra, entonces conduce a la creaci√≥n de ataques m√°s peligrosos o a bloquear fuertes ataques enemigos.  Todo es l√≥gico ... me parece a m√≠. <br>  Si va a la p√°gina y escribe en la consola SHOW_WEIGHTS = true, puede sentir visualmente el funcionamiento del algoritmo (se mostrar√°n los pesos de las celdas). <br><br><h3>  Pesos de ataque </h3><br>  Revis√© mis cerebros y traje tal correspondencia de ataques y pesos: <br><br><pre> <code class="javascript hljs">ATTACK_WEIGHT = [[],[],[],[],[],[]]; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0.1</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">4</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">4</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">6</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">5</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">200</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">0.25</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">5</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">7</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">4</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">100</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">5</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">200</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">5</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">200</span></span>;</code> </pre><br>  Seleccionado emp√≠ricamente, quiz√°s esta no sea la mejor opci√≥n. <br><br>  Agregu√© un poder de ataque de 5 con un peso prohibitivamente grande a la matriz.  Esto puede explicarse por el hecho de que el bot analiza el juego, mirando un paso adelante (sustituyendo la figura en la celda).  Omitir tal ataque no es m√°s que una derrota.  Bueno, o victoria ... dependiendo de qui√©n. <br><br>  Los ataques con alto potencial se valoran m√°s alto. <br><br>  El ataque [4: 2] en la mayor√≠a de los casos decide el resultado del juego.  Si el jugador logr√≥ crear dicho ataque, entonces el oponente ya no podr√° bloquearlo.  Sin embargo, esto no es una victoria.  El enemigo puede terminar el juego m√°s r√°pido, incluso si tenemos un ataque [4: 2] en el campo, por lo que su peso es menor que el de los ataques con una potencia de 5. Vea un ejemplo a continuaci√≥n. <br><br><img src="https://habrastorage.org/webt/pk/4u/mm/pk4ummarchcw9j4lpkujlmj_iig.jpeg"><br>  <i>Figura 2. Ataque [4: 2]</i> <br><br><h3>  Ataques rotos </h3><br>  El c√≥digo no se presenta en este p√°rrafo.  Aqu√≠ presentamos el concepto de un divisor de ataques y explicamos la esencia de los <b>"ataques desgarrados"</b> . <br><br>  Considere la siguiente situaci√≥n: al sustituir una figura para eliminar varias celdas vac√≠as, pero no m√°s de 5, se ubica una m√°s. <br><br>  Y, al parecer, dos figuras id√©nticas, en la misma l√≠nea ... visualmente parece un ataque, pero en realidad no.  No es una orden, ya que tales ataques "desgarrados" tambi√©n conllevan una amenaza potencial. <br><br>  Especialmente para tales casos, para cada ataque calcularemos el divisor.  Inicialmente, su valor es 1. <br><br><ol><li>  Presentamos el ataque "desgarrado" como varios ordinarios </li><li>  Contamos el n√∫mero de celdas vac√≠as entre el ataque central y el lateral. </li><li>  Para cada celda vac√≠a, el divisor se incrementa en 1 </li><li>  Calculamos el peso del ataque central como de costumbre, el peso de los ataques laterales, dividido por el divisor </li></ol><br><img src="https://habrastorage.org/webt/dc/w9/62/dcw9629rd4zdhomn6q2uwi5yxkg.jpeg"><br>  <i>Fig. 3. An√°lisis del "ataque rasgado".</i>  <i>Se escanea una celda con una cruz amarilla.</i> <br><br>  Por lo tanto, los ataques desgarrados tambi√©n ser√°n tomados en cuenta por AI.  De hecho, estos ser√°n ataques ordinarios, pero cuanto m√°s lejos est√©n de la celda escaneada, menos influencia tendr√°n sobre ella y, en consecuencia, tendr√°n menos peso (gracias al divisor). <br><br><h3>  Algoritmo de b√∫squeda de ataque </h3><br>  Primero, crea <b>una clase de</b> ataque.  El ataque tendr√° 3 atributos, sobre los que escrib√≠ anteriormente: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Attack</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( cap = 0, pot = 0, div = 1 ){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.capability = cap; <span class="hljs-comment"><span class="hljs-comment">// this.potential = pot; // this.divider = div; // }</span></span></code> </pre><br>  Y un <b>m√©todo</b> que devolver√° el peso de un ataque dado: <br><br><pre> <code class="javascript hljs">countWeigth(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ATTACK_WEIGHT[ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.capability, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.potential ] / <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.divider } }</code> </pre><br>  Siguiente  Dividiremos la b√∫squeda de todos los ataques para una c√©lula en: <br><br><ol><li>  B√∫squeda horizontal </li><li>  B√∫squeda vertical </li><li>  B√∫squeda diagonal de 45 grados </li><li>  B√∫squeda diagonal de 135 grados </li></ol><br>  Todas estas son <b>l√≠neas</b> , y el algoritmo para buscar ataques en estas l√≠neas puede generalizarse: <b>la clase checkLine</b> . <br><br>  Sin embargo, no necesitamos verificar toda la l√≠nea.  El poder de ataque m√°ximo que nos interesa es 5. Por supuesto, es posible crear un ataque con un poder de, digamos, 6.  Pero para una IA que analiza la situaci√≥n del juego del pr√≥ximo movimiento, es lo mismo que 6 o 5. La posibilidad de recibir uno de estos ataques indica el final del juego en el siguiente movimiento.  En consecuencia, el peso de la celda analizada ser√° el mismo en ambos casos. <br><br>  Atributos de clase: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">checkLine</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ <span class="hljs-comment"><span class="hljs-comment">//,        this.subFig = "√ó"; //     .    ¬´0¬ª - . this.Attacks = []; //  this.curAttack = new Attack; // (      ) this.iter = 1; //,     this.checkEdge = false;</span></span></code> </pre><br>  Es necesario detenerse aqu√≠, ya que puede surgir la pregunta: ¬øpor qu√© verificar la sexta celda si la potencia m√°xima de ataque es 5. La respuesta es determinar el potencial remoto desde el centro de ataque. <br><br>  Aqu√≠ hay un ejemplo: un ataque con un poder de 1 en la imagen se encuentra en el borde del √°rea escaneada.  Para descubrir el potencial de este ataque, debe "mirar al extranjero". <br><br><img src="https://habrastorage.org/webt/cg/hb/0r/cghb0ryfnk7kgmaqhw-67emn0qc.jpeg"><br>  <i>Fig.</i>  <i>3. Escaneo de 6tas celdas.</i>  <i>Si no escanea la sexta celda, puede determinar incorrectamente el potencial de ataque.</i> <br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//   this.attackplace = 1; }</span></span></code> </pre><br>  Puede que simplemente no haya suficiente espacio para completar algunos ataques.  Habiendo contado el lugar del ataque, podemos entender de antemano cu√°l de los ataques es poco prometedor. <br><br><img src="https://habrastorage.org/webt/ww/fy/n4/wwfyn4tolymet3ylnf53hax6gju.jpeg"><br>  <i>Fig.</i>  <i>4. Lugar para atacar</i> <br><br>  El algoritmo es el siguiente: <br><br>  1) Comencemos con la celda central.  Debe estar vac√≠o (vamos a hacer un movimiento hacia √©l, ¬øverdad? Pero no olvidamos que nuestra IA debe sustituir figuras en esta celda para el an√°lisis del pr√≥ximo movimiento. La figura que sustituimos es <b>this.subfig</b> : el valor predeterminado es una cruz. Dado que la celda central inicialmente contendr√° alguna forma despu√©s de la sustituci√≥n, pertenecer√° a alg√∫n ataque <b>this.curAttack</b> : <br><br><ul><li>  su potencia no ser√° inferior a 1 (una cifra en la celda central) </li><li>  divisor - 1, porque  es un ataque central (pertenece a la celda escaneada); </li><li>  el potencial a√∫n no se conoce: el valor predeterminado es 0; </li></ul><br><br>  Mostramos todos estos puntos en los valores predeterminados del constructor; consulte el c√≥digo anterior. <br><br>  2) A continuaci√≥n, reduciendo el iterador, itera m√°s de 5 celdas en un lado del escaneado.  La funci√≥n <b>getAttacks (cellX, cellY, subFig, dx, dy)</b> es responsable de esto, donde: <br><br>  <b>cellX, cellY</b> : coordenadas de la celda marcada <br>  <b>subFig</b> : la figura que sustituimos en la celda marcada <br>  <b>dx, dy</b> - cambios en las coordenadas x e y en ciclos - as√≠ es como establecemos la direcci√≥n de b√∫squeda: <br><br><ul><li>  Horizontal (dx = 1, dy = 0) </li><li>  Vertical (dx = 0, dy = 1) </li><li>  Diagonal 45 (dx = 1, dy = -1) </li><li>  Diagonal 135 (dx = 1, dy = 1) </li></ul><br>  En cierto sentido, este es un vector paralelo a la l√≠nea de b√∫squeda.  Por lo tanto, una funci√≥n podr√° buscar en 4 direcciones y no volveremos a violar el principio DRY. <br><br>  C√≥digo de funci√≥n: <br><br><pre> <code class="javascript hljs">getAttacks( cellX, cellY, subFig, dx, dy ){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.substitudeFigure( subFig ); <span class="hljs-comment"><span class="hljs-comment">//  ‚Äì  ... for( var x = cellX - dx, y = cellY - dy; Math.abs( x - cellX ) &lt;= 5 &amp;&amp; Math.abs( y - cellY ) &lt;= 5; x -= dx, y -= dy ) if( this.checkCell( x, y ) ) break; //: //    (  ) this.turnAround(); //  -    ... for( var x = cellX + dx, y = cellY + dy; Math.abs( x - cellX ) &lt;= 5 &amp;&amp; Math.abs( y - cellY ) &lt;= 5; x += dx, y += dy ) if( this.checkCell( x, y ) ) break; return this.Attacks; }</span></span></code> </pre><br>  Tenga en cuenta que si checkCell () devuelve algo, entonces el ciclo se detiene. <br><br>  3) Verificamos las cifras de estas celdas. <br>  La funci√≥n <b>checkCell (x, y)</b> es responsable de esto: <br><br>  Primero, escriba la forma en la variable <b>fig</b> : <br>  <b>Model.Field</b> es nuestro campo de juego. <br><br><pre> <code class="javascript hljs">checkCell( x, y ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fig = Model.Field[x] &amp;&amp; Model.Field[x][y] !== <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> ? Model.Field[x][y] : <span class="hljs-string"><span class="hljs-string">'b'</span></span>;</code> </pre><br>  <b>fig</b> puede ser 'x', 'o', 'b' (borde), 0 (celda vac√≠a). <br><br><ul><li>  Si dicha cifra coincide con la figura de la celda central ( <b>this.subFig</b> ), entonces continuamos con el algoritmo, eso significa que continuamos escaneando el ataque, todo est√° bien, continuamos con el mismo esp√≠ritu.  Una pieza extra en el ataque es una ventaja para su poder ( <b>this.curAttack.capability</b> ) y lugar ( <b>this.attackplace</b> ). <br><br>  (Ver c√≥digo en el siguiente p√°rrafo) </li><li>  Si esta es una figura diferente, entonces el ataque que escaneamos antes (this.curAttack) est√° bloqueado desde este lado.  No cambiamos nada en los par√°metros de ataque, lo escribimos en la matriz de ataques y nos salimos del ciclo. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( fig == <span class="hljs-string"><span class="hljs-string">'‚óã'</span></span> || fig == <span class="hljs-string"><span class="hljs-string">'√ó'</span></span> ){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.subFig != fig ){ <span class="hljs-comment"><span class="hljs-comment">//  this.Attacks.push( this.curAttack ); //  return fig; //      } else{ //    this.curAttack.capability++; // +   this.attackplace++; // +   } }</span></span></code> </pre><br></li><li>  Si no existe tal celda, significa que se cay√≥ del l√≠mite del campo, lo que significa que el ataque est√° bloqueado.  Lo escribimos en una matriz de todos los ataques y salimos del bucle. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( fig == <span class="hljs-string"><span class="hljs-string">'b'</span></span> ){ <span class="hljs-comment"><span class="hljs-comment">// this.Attacks.push( this.curAttack ); return 'b'; }</span></span></code> </pre><br></li><li>  Si atrapa una jaula vac√≠a, significa que el ataque actual ha terminado o que estamos lidiando con un "ataque desgarrado".  Adem√°s del potencial y el lugar para atacar (porque el ataque no est√° bloqueado).  Sin embargo, no salimos del bucle, tal vez este es un "ataque desgarrado", simplemente escriba this.curAttack en la matriz de todos los ataques de la l√≠nea this.Attacks [].  Crea un nuevo ataque "actual" y aumenta su divisor en 1 (este es un ataque lateral). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  if( this.curAttack.capability ){ this.curAttack.potential++; this.Attacks.push( this.curAttack ); this.curAttack = new Attack; this.curAttack.potential++; } this.curAttack.divider++; this.attackplace++; }</span></span></code> </pre><br></li></ul><br><br>  4) Si en la quinta celda la figura coincide con la celda central, entonces el ataque "descans√≥" contra el borde y para determinar el potencial de ataque tendr√° que "verificar el borde" ( <b>this.checkEdge = true</b> ). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.iter == <span class="hljs-number"><span class="hljs-number">4</span></span> &amp;&amp; fig == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.subFig ) <span class="hljs-comment"><span class="hljs-comment">// 5-  this.checkEdge = true; else if( this.iter == 5 ){ if( this.checkEdge ){ if( fig == this.curFig || fig == 0 ) this.curAttack.potential++; this.Attacks.push( this.curAttack ) } return 0; } this.iter++</span></span></code> </pre><br>  La funci√≥n <b>checkCell</b> est√° lista.  Sin embargo, seguimos trabajando en la clase <b>checkLine</b> . <br><br>  5) Despu√©s de completar el primer ciclo, debe "dar la vuelta".  Traducimos el iterador al centro y al ataque central, con el √≠ndice 0, lo eliminamos de la matriz de ataques y lo configuramos como el actual. <br><br><pre> <code class="javascript hljs">turnAround(){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.iter = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.checkEdge = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.curAttack = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Attacks[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Attacks.splice(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) }</code> </pre><br>  6) A continuaci√≥n, vaya al otro lado de la celda actual, aumentando el iterador. <br>  Absolutamente el mismo cheque de cifras.  (C√≥digo ya escrito - funci√≥n <b>getAttacks</b> ) <br><br>  7) Todo, reunimos todos los ataques que estaban en la l√≠nea en una matriz. <br>  Eso es todo con la clase <b>checkLine ...</b> todo est√° hecho. <br><br>  Bueno, entonces todo es simple: cree un objeto <b>checkLine</b> para cada una de las l√≠neas (2 diagonales, horizontal y vertical) y llame a la funci√≥n <b>getAttacks</b> .  Es decir, para cada l√≠nea: su propio objeto <b>checkLine</b> y, en consecuencia, su propio conjunto de ataques. <br><br>  Deje que la funci√≥n <b>getAllAttacks ()</b> sea ‚Äã‚Äãresponsable de todo esto, ya por separado de las clases descritas anteriormente; <br><br><pre> <code class="javascript hljs">getAllAttacks( cellX, cellY ){ <span class="hljs-comment"><span class="hljs-comment">// ,  , //       if( Model.Field[ cellX ][ cellY ] ) return false var cX = []; var cO = []; //   ... cX['0'] = this.getAttacksLine( cellX, cellY, '√ó', 1, 0 ); cX['90'] = this.getAttacksLine( cellX, cellY, '√ó', 0, 1 ); cX['45'] = this.getAttacksLine( cellX, cellY, '√ó', 1, -1 ); cX['135'] = this.getAttacksLine( cellX, cellY, '√ó', 1, 1 ); //  ... cO['0'] = this.getAttacksLine( cellX, cellY, '‚óã', 1, 0 ); cO['90'] = this.getAttacksLine( cellX, cellY, '‚óã', 0, 1 ); cO['45'] = this.getAttacksLine( cellX, cellY, '‚óã', 1, -1 ); cO['135'] = this.getAttacksLine( cellX, cellY, '‚óã', 1, 1 ); return { //     'x': cX, 'o': cO } } getAttacksLine( cellX, cellY, subFig, dx, dy ){ //      var C = new checkLine; C.getAttacks( cellX, cellY, subFig, dx, dy ); return this.filterAttacks( C ) //   }</span></span></code> </pre><br>  En la salida, tenemos un objeto con todos los ataques para la celda probada <br><br>  Sin embargo, es posible que haya notado alg√∫n tipo de funci√≥n de filtro.  Su tarea es tamizar ataques "in√∫tiles": <br><br><ul><li>  Con potencia cero (nunca se sabe si entran en la matriz) </li><li>  Ataques que carecen de espacio (lugar de ataque &lt;5) </li><li>  Con cero potencial. </li></ul><br>  Sin embargo, si el ataque tiene un poder superior a 5, entonces el filtro lo omitir√°.  El bot debe ver tales ataques, su detecci√≥n conducir√° a jambas al final del juego. <br><br><pre> <code class="javascript hljs">filterAttacks( attackLine ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( attackLine.attackplace &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span> ) attackLine.Attacks.forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.capability &amp;&amp; a.potential || a.capability &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span> ) res.push( a ) }) attackLine.Attacks = res; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res }</code> </pre><br><h3>  Puntos de corte </h3><br>  S√≠ ... otra vez, lo siento!  Entonces llamaremos a la situaci√≥n en el juego, cuando un movimiento incorrecto decide el resultado del juego. <br><br>  Por ejemplo, un ataque [3: 2] es un punto de interrupci√≥n.  Si el oponente no lo bloquea colocando una pieza al lado, entonces el siguiente movimiento, ya tenemos un ataque [4: 2] en el campo de juego, bueno, el resultado del juego se decide, lo que sea que se diga (en la gran mayor√≠a de los casos). <br><br>  O un ataque [4: 1].  Un bostezo, y el juego se puede completar f√°cilmente. <br><br><img src="https://habrastorage.org/webt/bd/vc/d0/bdvcd0jzf2wiiqqm9wupccpgmn4.jpeg"><br>  <i>Figura 5. Punto de interrupci√≥n</i> <br><br>  Todo es claro y comprensible, y el algoritmo descrito anteriormente ya puede tener en cuenta los puntos de interrupci√≥n y bloquearlos de manera oportuna.  El bot mira hacia adelante.  Ver√° que en el pr√≥ximo turno el oponente puede crear un ataque [5: 1], por ejemplo, cuyo peso es 200, lo que significa que el astuto nerd ir√° aqu√≠. <br><br>  Sin embargo, imagina una situaci√≥n en la que uno de los jugadores consigue 2 puntos de quiebre en el campo.  Y esto, obviamente, no deja ninguna posibilidad para el oponente, porque  en un movimiento podemos bloquear solo un punto de interrupci√≥n.  ¬øC√≥mo ense√±ar a nuestra IA a bloquear tales ataques? <br><br><img src="https://habrastorage.org/webt/bh/qu/79/bhqu79lupldi6d3pshuan0lxcmg.jpeg"><br>  <i>Figura 6. 2 puntos de corte</i> <br><br>  Todo es simple, al analizar una celda, al sustituir una pieza en ella, contaremos el n√∫mero de puntos de interrupci√≥n que obtendremos en el pr√≥ximo movimiento (el bot mira el movimiento hacia adelante, no lo olvide).  Al contar 2 puntos de interrupci√≥n, aumentamos el peso celular en 100. <br><br>  Y ahora, el bot no solo evitar√° tales situaciones de juego, sino que tambi√©n podr√° crearlas, lo que lo convierte en un oponente m√°s formidable. <br><br><h3>  C√≥mo entender que un ataque es un punto de quiebre </h3><br>  Comencemos con lo obvio: cualquier ataque con una potencia de 4 es un punto de quiebre.  Solo un movimiento perdido nos da la oportunidad de completar el juego, es decir  poner 5 piezas en una fila. <br><br>  Adem√°s, si el potencial de ataque es 2, gastaremos 1 turno m√°s para bloquear dicho ataque, lo que significa que hay un punto de interrupci√≥n con un poder de 3. Pero solo hay un punto de interrupci√≥n: este es un ataque [3: 2]. <br><br>  Y a√∫n m√°s dif√≠cil: <b>"ataques desgarrados"</b> . <br>  Solo consideraremos ataques con una celda vac√≠a en el medio, no m√°s.  Esto se debe a que para completar el ataque con dos celdas vac√≠as en el medio, debes gastar al menos 2 movimientos; esto claramente no es un punto de interrupci√≥n. <br><br>  Como recordamos, consideramos los ataques rotos como varios convencionales: un ataque central y ataques secundarios.  El ataque central pertenece a la celda escaneada, el divisor lateral tiene m√°s de 1, esto se describi√≥ anteriormente. <br><br>  Algoritmo para encontrar un punto de interrupci√≥n (m√°s f√°cil, lea a continuaci√≥n): <br><br><ol><li>  Introducimos el <b>puntaje</b> variable </li><li>  Tomamos el ataque central, consideramos el poder </li><li>  Tomamos uno de los secundarios si su divisor no es m√°s de 2x. </li><li>  <b>Puntuaci√≥n</b> : la suma del poder de los ataques centrales y secundarios </li><li>  Si los potenciales de los ataques centrales y laterales son 2, entonces para bloquear dicho ataque necesitas pasar un turno m√°s.  Por lo tanto, la puntuaci√≥n se incrementa en 1 </li><li>  Si <b>puntaje</b> &gt; = 4, entonces este es un punto de interrupci√≥n <br>  De hecho, los puntos de interrupci√≥n podr√≠an enumerarse simplemente, no hay muchos de ellos, pero no entend√≠ esto de inmediato. </li></ol><br><pre> <code class="javascript hljs">isBreakPoint( attackLine ){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ! attackLine || ! attackLine.length ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> centAtk; attackLine.forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.divider == <span class="hljs-number"><span class="hljs-number">1</span></span> ) centAtk = a; }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( centAtk.capability &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( centAtk.potential == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; centAtk.capability &gt;= <span class="hljs-number"><span class="hljs-number">3</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; attackLine.forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> score = centAtk.capability; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.divider == <span class="hljs-number"><span class="hljs-number">2</span></span> ){ <span class="hljs-comment"><span class="hljs-comment">//side attack if( centAtk.potential == 2 &amp;&amp; a.potential == 2 ) score++; if( score + a.capability &gt;= 4 ){ res = true; return; } } }) return res; }</span></span></code> </pre><br><h3>  S√≠, finalmente lo juntaremos todo </h3><br>  Entonces, el infierno principal detr√°s se describe arriba.  Es hora de moldear algo que funcione a partir de eso.  Funci√≥n <b>countWeight (x, y)</b> : toma las coordenadas de la celda como entrada y devuelve su peso.  ¬øQu√© hay debajo de su capucha? <br><br>  Primero, obtenemos una serie de todos los ataques a los que pertenece la c√©lula.  ( <b>getAllAttacks (x, y)</b> ).  Al pasar por todas las l√≠neas, contamos el n√∫mero de puntos de interrupci√≥n.  Si hay 2 puntos de interrupci√≥n, recordamos que tal situaci√≥n puede decidir el resultado del juego y aumentar el peso celular en 100. <br>  Sin embargo, todos los puntos de interrupci√≥n deben pertenecer a un jugador, por lo que tuve que implementar una verificaci√≥n en 2 pasos: primero cruces, luego ceros. <br><br>  Dado que en el conjunto de pesos de ataque ( <b>ATTACK_WEIGHTS []</b> ) no proporcion√© ataques con un poder de 6 o m√°s, tuve que reemplazarlos con ataques con un poder de 5. No hay diferencia: todos conducen al final del juego. <br><br>  Bueno, resumimos los pesos de ataque, eso es todo. <br><br>  Otro peque√±o punto: para que el bot no sea est√∫pido al final del juego, cuando ya ha construido un ataque con un poder de 4 y piensa en el movimiento actual, es necesario aumentar significativamente el peso de la celda para completar dicho ataque.  Sin esto, la IA, simplemente, puede comenzar a defenderse de los ataques "peligrosos" del oponente, aunque el juego parece estar ganado.  El √∫ltimo movimiento es importante. <br><br><pre> <code class="javascript hljs">countWeight( x, y ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> attacks = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getAttacks( x, y ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ! attacks ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; sum += count.call( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, attacks.x, <span class="hljs-string"><span class="hljs-string">'√ó'</span></span> ); sum += count.call( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, attacks.o, <span class="hljs-string"><span class="hljs-string">'‚óã'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> atks, curFig </span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> weight = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> breakPoints = <span class="hljs-number"><span class="hljs-number">0</span></span>; [ <span class="hljs-string"><span class="hljs-string">"0"</span></span>, <span class="hljs-string"><span class="hljs-string">"45"</span></span>, <span class="hljs-string"><span class="hljs-string">"90"</span></span>, <span class="hljs-string"><span class="hljs-string">"135"</span></span> ].forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> p </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isBreakPoint( atks[p] ) ){ debug( <span class="hljs-string"><span class="hljs-string">"Break point"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ++breakPoints == <span class="hljs-number"><span class="hljs-number">2</span></span> ){ weight += <span class="hljs-number"><span class="hljs-number">100</span></span>; debug( <span class="hljs-string"><span class="hljs-string">"Good cell"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } atks[p].forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.capability &gt; <span class="hljs-number"><span class="hljs-number">5</span></span> ) a.capability = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.capability == <span class="hljs-number"><span class="hljs-number">5</span></span> &amp;&amp; curFig == Model.whoPlays.char ) weight += <span class="hljs-number"><span class="hljs-number">100</span></span>; weight += a.getWeight(); }); }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> weight } }</code> </pre><br>  Ahora, al llamar a esta funci√≥n para una celda espec√≠fica, obtendremos su peso.  Realizamos esta operaci√≥n para todas las celdas y seleccionamos la mejor (con el mayor peso).  Ah√≠ y ve) <br><br>  Puedes encontrar el resto del c√≥digo en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github</a> .  Ya hay mucho material y su presentaci√≥n, como no lo he probado, deja mucho que desear.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pero si pudieras leer hasta este punto, querido lector, entonces te estoy agradecido. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mi opinion sobre el resultado </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Baja! </font><font style="vertical-align: inherit;">S√≠, puedes vencerlo, pero hacerlo es un poco problem√°tico para m√≠ personalmente. </font><font style="vertical-align: inherit;">Quiz√°s no soy lo suficientemente cuidadoso. </font><font style="vertical-align: inherit;">Prueba tu fuerza tambi√©n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S√© que es m√°s f√°cil, pero no s√© c√≥mo. </font><font style="vertical-align: inherit;">Me gustar√≠a escuchar a las personas que conocen o observan otras implementaciones de tal bot. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S√© lo que puede ser mejor. </font><font style="vertical-align: inherit;">S√≠ ... puedes usar algoritmos bien conocidos, como minimax, pero para esto necesitas tener una base de conocimiento en el campo de la teor√≠a de juegos, que desafortunadamente no puedo presumir. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el futuro planeo agregar an√°lisis de puntos de corte varios pasos adelante, lo que har√° que el bot sea un rival a√∫n m√°s serio. </font><font style="vertical-align: inherit;">Sin embargo, ahora no tengo una idea clara sobre la implementaci√≥n de esto; </font><font style="vertical-align: inherit;">Solo tengo la pr√≥xima sesi√≥n y un diploma incompleto, lo que me entristece. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gracias si lees hasta el final.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es430708/">https://habr.com/ru/post/es430708/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es430694/index.html">Una breve gu√≠a para aprender C ++: qu√©, cu√°ndo y qu√© crear</a></li>
<li><a href="../es430700/index.html">Un sistema unificado para grabar vistas de pel√≠culas en l√≠nea comenzar√° a funcionar en Rusia</a></li>
<li><a href="../es430702/index.html">Entrenamiento muy extra√±o</a></li>
<li><a href="../es430704/index.html">C√≥mo las tecnolog√≠as de inteligencia artificial ayudan a Aviasales a crecer: siete ejemplos</a></li>
<li><a href="../es430706/index.html">Nueva teor√≠a de la evoluci√≥n</a></li>
<li><a href="../es430710/index.html">Qu√© hacer si Black Friday es ma√±ana y sus servidores no est√°n listos</a></li>
<li><a href="../es430712/index.html">NeurIPS: C√≥mo conquistar la mejor conferencia de ML</a></li>
<li><a href="../es430714/index.html">VMware compra Heptio: ¬øqu√© significa para Kubernetes?</a></li>
<li><a href="../es430718/index.html">¬øPara qu√© objetos vale la pena usar la videovigilancia en la nube?</a></li>
<li><a href="../es430720/index.html">Intel RealSense D435i: peque√±a actualizaci√≥n y breve digresi√≥n hist√≥rica</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>