<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧖 ⚠️ 🕺🏿 Tic Tac Toe "Sin Fronteras" ☹️ 🚕 👨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tic-tac-toe ... todos los jugaron, estoy seguro. El juego es atractivo en su simplicidad, especialmente cuando arrastra el reloj a algún lugar de la l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tic Tac Toe "Sin Fronteras"</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430708/"> Tic-tac-toe ... todos los jugaron, estoy seguro.  El juego es atractivo en su simplicidad, especialmente cuando arrastra el reloj a algún lugar de la lección, un par, y no hay nada a mano excepto una hoja de cuaderno y un simple lápiz.  No sé quién fue el primero en adivinar que dibujó cruces y círculos en 9 casillas, pero desde entonces el juego no ha perdido demanda en absoluto, especialmente desde que la gente presentó muchas de sus variaciones. <br><br><img src="https://habrastorage.org/webt/pd/gx/-c/pdgx-cibc6880fmwfxt90nxmi-k.jpeg"><br><br>  Este artículo trata sobre el proceso de desarrollo de IA en javascript para reproducir una de estas variaciones de tic-tac-toe: obtuve mucho material, pero lo diluí con animación e imágenes.  En cualquier caso, al menos vale la pena intentarlo. <br>  Las diferencias entre esta versión del juego y la original son las siguientes: <br><br><ol><li>  <b>El campo</b> puede ser arbitrariamente <b>grande</b> (¿Cuánto durará la computadora portátil?) </li><li>  El ganador es el que pone <b>5 piezas</b> (si puede llamarlas así) en una fila. </li></ol><br>  Todo es simple ... y al mismo tiempo complicado: el resultado del juego no se puede calcular de antemano, como en el análogo clásico.  Esta "pequeña proyección" me quitó mucho tiempo y nervios.  Espero que lo encuentres interesante. <a name="habracut"></a><br><br><h3>  Antes de comenzar </h3><br>  Obligado a pedir disculpas de antemano por el volumen del artículo y, en algunos lugares, la presentación de pensamiento no del todo inteligible, sin embargo, no pude exprimir al rebaño sin pérdida de contenido y calidad. <br>  Le recomiendo que primero se familiarice con el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">resultado</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Código</a> <br><br>  Teclas de acceso rápido y comandos: <br><br><ul><li>  <b>D</b> - AI hará un movimiento por ti </li><li>  <b>T</b> - ver peso celular </li><li>  Escriba <b>SHOW_WEIGHTS = true</b> en la consola para ver los pesos de todas las celdas analizadas. </li></ul><br><h3>  Empecemos </h3><br>  Debes comenzar con la implementación del juego en sí, es decir  escribe una aplicación para dos jugadores, hasta ahora sin bot.  Para mis propósitos, decidí usar javascript + jquery + bootstrap4, aunque prácticamente no se usa allí, pero es mejor dejarlo, o la tabla flotará.  No hay nada especial que contar, hay mucho material sobre js, jquery y bootstrap.  Solo puedo decir que usé MVC.  De todos modos, no explicaré absolutamente todo el código, ya ha habido mucho material. <br><br>  Entonces, el campo de juego estaba listo.  Puede establecer formas en celdas.  Pero la victoria de cualquiera de los jugadores no fue arreglada de ninguna manera. <br><br><h3>  Fin del escaneo del juego </h3><br>  El juego termina cuando uno de los jugadores pone <b>5 piezas</b> seguidas.  "¡Es simple!"  Pensé  Y comenzó a escanear absolutamente todas las celdas del campo: primero todas las horizontales, luego las verticales y finalmente las diagonales. <br><br>  Esta es una manera tonta, pero funcionó.  Sin embargo, podría mejorarse significativamente, lo cual hice: la mayoría de las celdas permanecerán vacías durante todo el juego; el campo de juego es demasiado grande para llenarse por completo.  Como era necesario escanearlo en cada movimiento, y solo se coloca una pieza en un movimiento, puede enfocarse solo en esta pieza (celda): escanee solo una horizontal, vertical y dos diagonales de la celda que posee la misma celda. <br><br>  Además, no necesita escanear todas las líneas celulares.  Como el final del juego es de 5 piezas seguidas, las piezas que están separadas por 6 celdas no nos interesan.  Es suficiente escanear cinco celdas en cada lado.  No entiendo?  Vea la animación a continuación. <br><br><img src="https://habrastorage.org/webt/nt/fj/wu/ntfjwuj6nfabfj2qtedcs4g-fp0.gif"><br><br><div class="spoiler">  <b class="spoiler_title">Ver código</b> <div class="spoiler_text"><pre><code class="javascript hljs">checkWin( cellX, cellY ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newFig = getFig(cellX,cellY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ! newFig ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res; res = res || checkLine( cellX, cellY, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ); <span class="hljs-comment"><span class="hljs-comment">//horizontal res = res || checkLine( cellX, cellY, 0, 1 ); //vertical res = res || checkLine( cellX, cellY, 1, 1 ); //diagonal 45 res = res || checkLine( cellX, cellY, 1, -1 ); //diagonal 135 return res; function getFig( x, y ){ return Model.Field[x] &amp;&amp; Model.Field[x][y] ? Model.Field[x][y] : 'b'; } function checkLine( x, y, dx, dy ){ x = +x; y = +y; var score = 0; while( getFig( x - dx, y - dy ) == newFig ){ x -= dx; y -= dy; } while( getFig( x, y ) == newFig ){ x += dx; y += dy; score++; } if( score &gt;= 5 ) return true; return false; } }</span></span></code> </pre> <br></div></div><br><h3>  Vamos al bot mismo </h3><br>  Entonces, ya hemos escrito una página con tres en raya.  Pasamos a la tarea principal: AI. <br>  No puede simplemente tomar y escribir código si no sabe cómo: debe pensar en la lógica del bot. <br><br>  La conclusión es analizar el campo de juego, al menos parte de él, y calcular el <b>precio (peso) de</b> cada celda en el campo.  La celda con el peso más alto, la más prometedora, el bot pondrá una cifra allí.  La principal dificultad está en calcular el peso de una celda. <br><br><h3>  Terminología </h3><br>  <b>Las cruces y los dedos</b> son figuras. <br>  <b>Un ataque</b> se llamará varias figuras idénticas de pie lado a lado en la misma línea.  De hecho, esto es mucho.  El número de piezas en un ataque es su <b>poder</b> .  Una pieza separada también es un ataque (potencia 1). <br><br>  En las celdas de ataque adyacentes (en los extremos) puede haber celdas vacías o piezas enemigas.  Es lógico pensar que un ataque con dos celdas vacías en los "extremos" se puede desarrollar en dos direcciones, lo que lo hace más prometedor.  El número de celdas vacías en los "extremos" del ataque se denominará <b>potencial</b> .  El potencial puede ser 0, 1 o 2. <br>  Denotamos los ataques de la siguiente manera: <b>[poder de ataque, potencial]</b> .  Por ejemplo, un <b>ataque [4: 1]</b> . <br><br><img src="https://habrastorage.org/webt/1_/pk/e3/1_pke3kve1yjbf6cjjzg3hnnzvm.jpeg"><br>  <i>Figura 1. Ataque [4: 1]</i> <br><br>  En el curso del análisis, evaluaremos todas las celdas que ingresan a un área específica.  Cada celda calculará su <b>peso</b> .  Se calcula en función de los pesos de todos los ataques que afecta esta célula. <br><br><h3>  La esencia del análisis. </h3><br>  Imagine que en el campo de juego ya hay varios ataques de uno y el segundo jugador.  Uno de los jugadores hace un movimiento (deja los cruces).  Naturalmente, se muda a una celda vacía y, por lo tanto, puede: <br><br><ol><li>  Desarrolla tu ataque, y quizás más de uno, aumentando su poder.  Puede lanzar un nuevo ataque, etc. </li><li>  Prevenir el desarrollo de un ataque enemigo o bloquearlo por completo. </li></ol><br>  Es decir, nuestro protagonista puede atacar y defender.  O tal vez todo de una vez.  Para él, tanto el primero como el segundo son importantes. <br><br>  La esencia del análisis es la siguiente: <br><br><ol><li>  El bot sustituye las cifras en la celda marcada: primero una cruz, luego un cero. </li><li>  Luego busca todos los ataques que fueron recibidos por tales movimientos y resume sus pesos. </li><li>  La cantidad recibida es el peso de la celda. </li><li>  Se realiza un algoritmo similar para todas las celdas del campo de juego. </li></ol><br><img src="https://habrastorage.org/webt/ur/rc/qz/urrcqzyrjrnp9oupxjoqc1iu6wg.gif"><br><br>  De hecho, verificamos con tal algoritmo qué sucederá si vamos por este camino ... y qué sucederá si el oponente va por ese camino.  Esperamos un paso y seleccionamos la celda más adecuada, con el mayor peso. <br><br>  Si una célula tiene más peso que otra, entonces conduce a la creación de ataques más peligrosos o a bloquear fuertes ataques enemigos.  Todo es lógico ... me parece a mí. <br>  Si va a la página y escribe en la consola SHOW_WEIGHTS = true, puede sentir visualmente el funcionamiento del algoritmo (se mostrarán los pesos de las celdas). <br><br><h3>  Pesos de ataque </h3><br>  Revisé mis cerebros y traje tal correspondencia de ataques y pesos: <br><br><pre> <code class="javascript hljs">ATTACK_WEIGHT = [[],[],[],[],[],[]]; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0.1</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">4</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">4</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">6</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">5</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">200</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">0.25</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">5</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">7</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">4</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">100</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">5</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">200</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">5</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">200</span></span>;</code> </pre><br>  Seleccionado empíricamente, quizás esta no sea la mejor opción. <br><br>  Agregué un poder de ataque de 5 con un peso prohibitivamente grande a la matriz.  Esto puede explicarse por el hecho de que el bot analiza el juego, mirando un paso adelante (sustituyendo la figura en la celda).  Omitir tal ataque no es más que una derrota.  Bueno, o victoria ... dependiendo de quién. <br><br>  Los ataques con alto potencial se valoran más alto. <br><br>  El ataque [4: 2] en la mayoría de los casos decide el resultado del juego.  Si el jugador logró crear dicho ataque, entonces el oponente ya no podrá bloquearlo.  Sin embargo, esto no es una victoria.  El enemigo puede terminar el juego más rápido, incluso si tenemos un ataque [4: 2] en el campo, por lo que su peso es menor que el de los ataques con una potencia de 5. Vea un ejemplo a continuación. <br><br><img src="https://habrastorage.org/webt/pk/4u/mm/pk4ummarchcw9j4lpkujlmj_iig.jpeg"><br>  <i>Figura 2. Ataque [4: 2]</i> <br><br><h3>  Ataques rotos </h3><br>  El código no se presenta en este párrafo.  Aquí presentamos el concepto de un divisor de ataques y explicamos la esencia de los <b>"ataques desgarrados"</b> . <br><br>  Considere la siguiente situación: al sustituir una figura para eliminar varias celdas vacías, pero no más de 5, se ubica una más. <br><br>  Y, al parecer, dos figuras idénticas, en la misma línea ... visualmente parece un ataque, pero en realidad no.  No es una orden, ya que tales ataques "desgarrados" también conllevan una amenaza potencial. <br><br>  Especialmente para tales casos, para cada ataque calcularemos el divisor.  Inicialmente, su valor es 1. <br><br><ol><li>  Presentamos el ataque "desgarrado" como varios ordinarios </li><li>  Contamos el número de celdas vacías entre el ataque central y el lateral. </li><li>  Para cada celda vacía, el divisor se incrementa en 1 </li><li>  Calculamos el peso del ataque central como de costumbre, el peso de los ataques laterales, dividido por el divisor </li></ol><br><img src="https://habrastorage.org/webt/dc/w9/62/dcw9629rd4zdhomn6q2uwi5yxkg.jpeg"><br>  <i>Fig. 3. Análisis del "ataque rasgado".</i>  <i>Se escanea una celda con una cruz amarilla.</i> <br><br>  Por lo tanto, los ataques desgarrados también serán tomados en cuenta por AI.  De hecho, estos serán ataques ordinarios, pero cuanto más lejos estén de la celda escaneada, menos influencia tendrán sobre ella y, en consecuencia, tendrán menos peso (gracias al divisor). <br><br><h3>  Algoritmo de búsqueda de ataque </h3><br>  Primero, crea <b>una clase de</b> ataque.  El ataque tendrá 3 atributos, sobre los que escribí anteriormente: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Attack</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( cap = 0, pot = 0, div = 1 ){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.capability = cap; <span class="hljs-comment"><span class="hljs-comment">// this.potential = pot; // this.divider = div; // }</span></span></code> </pre><br>  Y un <b>método</b> que devolverá el peso de un ataque dado: <br><br><pre> <code class="javascript hljs">countWeigth(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ATTACK_WEIGHT[ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.capability, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.potential ] / <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.divider } }</code> </pre><br>  Siguiente  Dividiremos la búsqueda de todos los ataques para una célula en: <br><br><ol><li>  Búsqueda horizontal </li><li>  Búsqueda vertical </li><li>  Búsqueda diagonal de 45 grados </li><li>  Búsqueda diagonal de 135 grados </li></ol><br>  Todas estas son <b>líneas</b> , y el algoritmo para buscar ataques en estas líneas puede generalizarse: <b>la clase checkLine</b> . <br><br>  Sin embargo, no necesitamos verificar toda la línea.  El poder de ataque máximo que nos interesa es 5. Por supuesto, es posible crear un ataque con un poder de, digamos, 6.  Pero para una IA que analiza la situación del juego del próximo movimiento, es lo mismo que 6 o 5. La posibilidad de recibir uno de estos ataques indica el final del juego en el siguiente movimiento.  En consecuencia, el peso de la celda analizada será el mismo en ambos casos. <br><br>  Atributos de clase: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">checkLine</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ <span class="hljs-comment"><span class="hljs-comment">//,        this.subFig = "×"; //     .    «0» - . this.Attacks = []; //  this.curAttack = new Attack; // (      ) this.iter = 1; //,     this.checkEdge = false;</span></span></code> </pre><br>  Es necesario detenerse aquí, ya que puede surgir la pregunta: ¿por qué verificar la sexta celda si la potencia máxima de ataque es 5. La respuesta es determinar el potencial remoto desde el centro de ataque. <br><br>  Aquí hay un ejemplo: un ataque con un poder de 1 en la imagen se encuentra en el borde del área escaneada.  Para descubrir el potencial de este ataque, debe "mirar al extranjero". <br><br><img src="https://habrastorage.org/webt/cg/hb/0r/cghb0ryfnk7kgmaqhw-67emn0qc.jpeg"><br>  <i>Fig.</i>  <i>3. Escaneo de 6tas celdas.</i>  <i>Si no escanea la sexta celda, puede determinar incorrectamente el potencial de ataque.</i> <br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//   this.attackplace = 1; }</span></span></code> </pre><br>  Puede que simplemente no haya suficiente espacio para completar algunos ataques.  Habiendo contado el lugar del ataque, podemos entender de antemano cuál de los ataques es poco prometedor. <br><br><img src="https://habrastorage.org/webt/ww/fy/n4/wwfyn4tolymet3ylnf53hax6gju.jpeg"><br>  <i>Fig.</i>  <i>4. Lugar para atacar</i> <br><br>  El algoritmo es el siguiente: <br><br>  1) Comencemos con la celda central.  Debe estar vacío (vamos a hacer un movimiento hacia él, ¿verdad? Pero no olvidamos que nuestra IA debe sustituir figuras en esta celda para el análisis del próximo movimiento. La figura que sustituimos es <b>this.subfig</b> : el valor predeterminado es una cruz. Dado que la celda central inicialmente contendrá alguna forma después de la sustitución, pertenecerá a algún ataque <b>this.curAttack</b> : <br><br><ul><li>  su potencia no será inferior a 1 (una cifra en la celda central) </li><li>  divisor - 1, porque  es un ataque central (pertenece a la celda escaneada); </li><li>  el potencial aún no se conoce: el valor predeterminado es 0; </li></ul><br><br>  Mostramos todos estos puntos en los valores predeterminados del constructor; consulte el código anterior. <br><br>  2) A continuación, reduciendo el iterador, itera más de 5 celdas en un lado del escaneado.  La función <b>getAttacks (cellX, cellY, subFig, dx, dy)</b> es responsable de esto, donde: <br><br>  <b>cellX, cellY</b> : coordenadas de la celda marcada <br>  <b>subFig</b> : la figura que sustituimos en la celda marcada <br>  <b>dx, dy</b> - cambios en las coordenadas x e y en ciclos - así es como establecemos la dirección de búsqueda: <br><br><ul><li>  Horizontal (dx = 1, dy = 0) </li><li>  Vertical (dx = 0, dy = 1) </li><li>  Diagonal 45 (dx = 1, dy = -1) </li><li>  Diagonal 135 (dx = 1, dy = 1) </li></ul><br>  En cierto sentido, este es un vector paralelo a la línea de búsqueda.  Por lo tanto, una función podrá buscar en 4 direcciones y no volveremos a violar el principio DRY. <br><br>  Código de función: <br><br><pre> <code class="javascript hljs">getAttacks( cellX, cellY, subFig, dx, dy ){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.substitudeFigure( subFig ); <span class="hljs-comment"><span class="hljs-comment">//  –  ... for( var x = cellX - dx, y = cellY - dy; Math.abs( x - cellX ) &lt;= 5 &amp;&amp; Math.abs( y - cellY ) &lt;= 5; x -= dx, y -= dy ) if( this.checkCell( x, y ) ) break; //: //    (  ) this.turnAround(); //  -    ... for( var x = cellX + dx, y = cellY + dy; Math.abs( x - cellX ) &lt;= 5 &amp;&amp; Math.abs( y - cellY ) &lt;= 5; x += dx, y += dy ) if( this.checkCell( x, y ) ) break; return this.Attacks; }</span></span></code> </pre><br>  Tenga en cuenta que si checkCell () devuelve algo, entonces el ciclo se detiene. <br><br>  3) Verificamos las cifras de estas celdas. <br>  La función <b>checkCell (x, y)</b> es responsable de esto: <br><br>  Primero, escriba la forma en la variable <b>fig</b> : <br>  <b>Model.Field</b> es nuestro campo de juego. <br><br><pre> <code class="javascript hljs">checkCell( x, y ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fig = Model.Field[x] &amp;&amp; Model.Field[x][y] !== <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> ? Model.Field[x][y] : <span class="hljs-string"><span class="hljs-string">'b'</span></span>;</code> </pre><br>  <b>fig</b> puede ser 'x', 'o', 'b' (borde), 0 (celda vacía). <br><br><ul><li>  Si dicha cifra coincide con la figura de la celda central ( <b>this.subFig</b> ), entonces continuamos con el algoritmo, eso significa que continuamos escaneando el ataque, todo está bien, continuamos con el mismo espíritu.  Una pieza extra en el ataque es una ventaja para su poder ( <b>this.curAttack.capability</b> ) y lugar ( <b>this.attackplace</b> ). <br><br>  (Ver código en el siguiente párrafo) </li><li>  Si esta es una figura diferente, entonces el ataque que escaneamos antes (this.curAttack) está bloqueado desde este lado.  No cambiamos nada en los parámetros de ataque, lo escribimos en la matriz de ataques y nos salimos del ciclo. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( fig == <span class="hljs-string"><span class="hljs-string">'○'</span></span> || fig == <span class="hljs-string"><span class="hljs-string">'×'</span></span> ){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.subFig != fig ){ <span class="hljs-comment"><span class="hljs-comment">//  this.Attacks.push( this.curAttack ); //  return fig; //      } else{ //    this.curAttack.capability++; // +   this.attackplace++; // +   } }</span></span></code> </pre><br></li><li>  Si no existe tal celda, significa que se cayó del límite del campo, lo que significa que el ataque está bloqueado.  Lo escribimos en una matriz de todos los ataques y salimos del bucle. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( fig == <span class="hljs-string"><span class="hljs-string">'b'</span></span> ){ <span class="hljs-comment"><span class="hljs-comment">// this.Attacks.push( this.curAttack ); return 'b'; }</span></span></code> </pre><br></li><li>  Si atrapa una jaula vacía, significa que el ataque actual ha terminado o que estamos lidiando con un "ataque desgarrado".  Además del potencial y el lugar para atacar (porque el ataque no está bloqueado).  Sin embargo, no salimos del bucle, tal vez este es un "ataque desgarrado", simplemente escriba this.curAttack en la matriz de todos los ataques de la línea this.Attacks [].  Crea un nuevo ataque "actual" y aumenta su divisor en 1 (este es un ataque lateral). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  if( this.curAttack.capability ){ this.curAttack.potential++; this.Attacks.push( this.curAttack ); this.curAttack = new Attack; this.curAttack.potential++; } this.curAttack.divider++; this.attackplace++; }</span></span></code> </pre><br></li></ul><br><br>  4) Si en la quinta celda la figura coincide con la celda central, entonces el ataque "descansó" contra el borde y para determinar el potencial de ataque tendrá que "verificar el borde" ( <b>this.checkEdge = true</b> ). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.iter == <span class="hljs-number"><span class="hljs-number">4</span></span> &amp;&amp; fig == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.subFig ) <span class="hljs-comment"><span class="hljs-comment">// 5-  this.checkEdge = true; else if( this.iter == 5 ){ if( this.checkEdge ){ if( fig == this.curFig || fig == 0 ) this.curAttack.potential++; this.Attacks.push( this.curAttack ) } return 0; } this.iter++</span></span></code> </pre><br>  La función <b>checkCell</b> está lista.  Sin embargo, seguimos trabajando en la clase <b>checkLine</b> . <br><br>  5) Después de completar el primer ciclo, debe "dar la vuelta".  Traducimos el iterador al centro y al ataque central, con el índice 0, lo eliminamos de la matriz de ataques y lo configuramos como el actual. <br><br><pre> <code class="javascript hljs">turnAround(){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.iter = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.checkEdge = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.curAttack = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Attacks[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Attacks.splice(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) }</code> </pre><br>  6) A continuación, vaya al otro lado de la celda actual, aumentando el iterador. <br>  Absolutamente el mismo cheque de cifras.  (Código ya escrito - función <b>getAttacks</b> ) <br><br>  7) Todo, reunimos todos los ataques que estaban en la línea en una matriz. <br>  Eso es todo con la clase <b>checkLine ...</b> todo está hecho. <br><br>  Bueno, entonces todo es simple: cree un objeto <b>checkLine</b> para cada una de las líneas (2 diagonales, horizontal y vertical) y llame a la función <b>getAttacks</b> .  Es decir, para cada línea: su propio objeto <b>checkLine</b> y, en consecuencia, su propio conjunto de ataques. <br><br>  Deje que la función <b>getAllAttacks ()</b> sea ​​responsable de todo esto, ya por separado de las clases descritas anteriormente; <br><br><pre> <code class="javascript hljs">getAllAttacks( cellX, cellY ){ <span class="hljs-comment"><span class="hljs-comment">// ,  , //       if( Model.Field[ cellX ][ cellY ] ) return false var cX = []; var cO = []; //   ... cX['0'] = this.getAttacksLine( cellX, cellY, '×', 1, 0 ); cX['90'] = this.getAttacksLine( cellX, cellY, '×', 0, 1 ); cX['45'] = this.getAttacksLine( cellX, cellY, '×', 1, -1 ); cX['135'] = this.getAttacksLine( cellX, cellY, '×', 1, 1 ); //  ... cO['0'] = this.getAttacksLine( cellX, cellY, '○', 1, 0 ); cO['90'] = this.getAttacksLine( cellX, cellY, '○', 0, 1 ); cO['45'] = this.getAttacksLine( cellX, cellY, '○', 1, -1 ); cO['135'] = this.getAttacksLine( cellX, cellY, '○', 1, 1 ); return { //     'x': cX, 'o': cO } } getAttacksLine( cellX, cellY, subFig, dx, dy ){ //      var C = new checkLine; C.getAttacks( cellX, cellY, subFig, dx, dy ); return this.filterAttacks( C ) //   }</span></span></code> </pre><br>  En la salida, tenemos un objeto con todos los ataques para la celda probada <br><br>  Sin embargo, es posible que haya notado algún tipo de función de filtro.  Su tarea es tamizar ataques "inútiles": <br><br><ul><li>  Con potencia cero (nunca se sabe si entran en la matriz) </li><li>  Ataques que carecen de espacio (lugar de ataque &lt;5) </li><li>  Con cero potencial. </li></ul><br>  Sin embargo, si el ataque tiene un poder superior a 5, entonces el filtro lo omitirá.  El bot debe ver tales ataques, su detección conducirá a jambas al final del juego. <br><br><pre> <code class="javascript hljs">filterAttacks( attackLine ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( attackLine.attackplace &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span> ) attackLine.Attacks.forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.capability &amp;&amp; a.potential || a.capability &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span> ) res.push( a ) }) attackLine.Attacks = res; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res }</code> </pre><br><h3>  Puntos de corte </h3><br>  Sí ... otra vez, lo siento!  Entonces llamaremos a la situación en el juego, cuando un movimiento incorrecto decide el resultado del juego. <br><br>  Por ejemplo, un ataque [3: 2] es un punto de interrupción.  Si el oponente no lo bloquea colocando una pieza al lado, entonces el siguiente movimiento, ya tenemos un ataque [4: 2] en el campo de juego, bueno, el resultado del juego se decide, lo que sea que se diga (en la gran mayoría de los casos). <br><br>  O un ataque [4: 1].  Un bostezo, y el juego se puede completar fácilmente. <br><br><img src="https://habrastorage.org/webt/bd/vc/d0/bdvcd0jzf2wiiqqm9wupccpgmn4.jpeg"><br>  <i>Figura 5. Punto de interrupción</i> <br><br>  Todo es claro y comprensible, y el algoritmo descrito anteriormente ya puede tener en cuenta los puntos de interrupción y bloquearlos de manera oportuna.  El bot mira hacia adelante.  Verá que en el próximo turno el oponente puede crear un ataque [5: 1], por ejemplo, cuyo peso es 200, lo que significa que el astuto nerd irá aquí. <br><br>  Sin embargo, imagina una situación en la que uno de los jugadores consigue 2 puntos de quiebre en el campo.  Y esto, obviamente, no deja ninguna posibilidad para el oponente, porque  en un movimiento podemos bloquear solo un punto de interrupción.  ¿Cómo enseñar a nuestra IA a bloquear tales ataques? <br><br><img src="https://habrastorage.org/webt/bh/qu/79/bhqu79lupldi6d3pshuan0lxcmg.jpeg"><br>  <i>Figura 6. 2 puntos de corte</i> <br><br>  Todo es simple, al analizar una celda, al sustituir una pieza en ella, contaremos el número de puntos de interrupción que obtendremos en el próximo movimiento (el bot mira el movimiento hacia adelante, no lo olvide).  Al contar 2 puntos de interrupción, aumentamos el peso celular en 100. <br><br>  Y ahora, el bot no solo evitará tales situaciones de juego, sino que también podrá crearlas, lo que lo convierte en un oponente más formidable. <br><br><h3>  Cómo entender que un ataque es un punto de quiebre </h3><br>  Comencemos con lo obvio: cualquier ataque con una potencia de 4 es un punto de quiebre.  Solo un movimiento perdido nos da la oportunidad de completar el juego, es decir  poner 5 piezas en una fila. <br><br>  Además, si el potencial de ataque es 2, gastaremos 1 turno más para bloquear dicho ataque, lo que significa que hay un punto de interrupción con un poder de 3. Pero solo hay un punto de interrupción: este es un ataque [3: 2]. <br><br>  Y aún más difícil: <b>"ataques desgarrados"</b> . <br>  Solo consideraremos ataques con una celda vacía en el medio, no más.  Esto se debe a que para completar el ataque con dos celdas vacías en el medio, debes gastar al menos 2 movimientos; esto claramente no es un punto de interrupción. <br><br>  Como recordamos, consideramos los ataques rotos como varios convencionales: un ataque central y ataques secundarios.  El ataque central pertenece a la celda escaneada, el divisor lateral tiene más de 1, esto se describió anteriormente. <br><br>  Algoritmo para encontrar un punto de interrupción (más fácil, lea a continuación): <br><br><ol><li>  Introducimos el <b>puntaje</b> variable </li><li>  Tomamos el ataque central, consideramos el poder </li><li>  Tomamos uno de los secundarios si su divisor no es más de 2x. </li><li>  <b>Puntuación</b> : la suma del poder de los ataques centrales y secundarios </li><li>  Si los potenciales de los ataques centrales y laterales son 2, entonces para bloquear dicho ataque necesitas pasar un turno más.  Por lo tanto, la puntuación se incrementa en 1 </li><li>  Si <b>puntaje</b> &gt; = 4, entonces este es un punto de interrupción <br>  De hecho, los puntos de interrupción podrían enumerarse simplemente, no hay muchos de ellos, pero no entendí esto de inmediato. </li></ol><br><pre> <code class="javascript hljs">isBreakPoint( attackLine ){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ! attackLine || ! attackLine.length ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> centAtk; attackLine.forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.divider == <span class="hljs-number"><span class="hljs-number">1</span></span> ) centAtk = a; }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( centAtk.capability &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( centAtk.potential == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; centAtk.capability &gt;= <span class="hljs-number"><span class="hljs-number">3</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; attackLine.forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> score = centAtk.capability; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.divider == <span class="hljs-number"><span class="hljs-number">2</span></span> ){ <span class="hljs-comment"><span class="hljs-comment">//side attack if( centAtk.potential == 2 &amp;&amp; a.potential == 2 ) score++; if( score + a.capability &gt;= 4 ){ res = true; return; } } }) return res; }</span></span></code> </pre><br><h3>  Sí, finalmente lo juntaremos todo </h3><br>  Entonces, el infierno principal detrás se describe arriba.  Es hora de moldear algo que funcione a partir de eso.  Función <b>countWeight (x, y)</b> : toma las coordenadas de la celda como entrada y devuelve su peso.  ¿Qué hay debajo de su capucha? <br><br>  Primero, obtenemos una serie de todos los ataques a los que pertenece la célula.  ( <b>getAllAttacks (x, y)</b> ).  Al pasar por todas las líneas, contamos el número de puntos de interrupción.  Si hay 2 puntos de interrupción, recordamos que tal situación puede decidir el resultado del juego y aumentar el peso celular en 100. <br>  Sin embargo, todos los puntos de interrupción deben pertenecer a un jugador, por lo que tuve que implementar una verificación en 2 pasos: primero cruces, luego ceros. <br><br>  Dado que en el conjunto de pesos de ataque ( <b>ATTACK_WEIGHTS []</b> ) no proporcioné ataques con un poder de 6 o más, tuve que reemplazarlos con ataques con un poder de 5. No hay diferencia: todos conducen al final del juego. <br><br>  Bueno, resumimos los pesos de ataque, eso es todo. <br><br>  Otro pequeño punto: para que el bot no sea estúpido al final del juego, cuando ya ha construido un ataque con un poder de 4 y piensa en el movimiento actual, es necesario aumentar significativamente el peso de la celda para completar dicho ataque.  Sin esto, la IA, simplemente, puede comenzar a defenderse de los ataques "peligrosos" del oponente, aunque el juego parece estar ganado.  El último movimiento es importante. <br><br><pre> <code class="javascript hljs">countWeight( x, y ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> attacks = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getAttacks( x, y ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ! attacks ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; sum += count.call( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, attacks.x, <span class="hljs-string"><span class="hljs-string">'×'</span></span> ); sum += count.call( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, attacks.o, <span class="hljs-string"><span class="hljs-string">'○'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> atks, curFig </span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> weight = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> breakPoints = <span class="hljs-number"><span class="hljs-number">0</span></span>; [ <span class="hljs-string"><span class="hljs-string">"0"</span></span>, <span class="hljs-string"><span class="hljs-string">"45"</span></span>, <span class="hljs-string"><span class="hljs-string">"90"</span></span>, <span class="hljs-string"><span class="hljs-string">"135"</span></span> ].forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> p </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isBreakPoint( atks[p] ) ){ debug( <span class="hljs-string"><span class="hljs-string">"Break point"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ++breakPoints == <span class="hljs-number"><span class="hljs-number">2</span></span> ){ weight += <span class="hljs-number"><span class="hljs-number">100</span></span>; debug( <span class="hljs-string"><span class="hljs-string">"Good cell"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } atks[p].forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.capability &gt; <span class="hljs-number"><span class="hljs-number">5</span></span> ) a.capability = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.capability == <span class="hljs-number"><span class="hljs-number">5</span></span> &amp;&amp; curFig == Model.whoPlays.char ) weight += <span class="hljs-number"><span class="hljs-number">100</span></span>; weight += a.getWeight(); }); }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> weight } }</code> </pre><br>  Ahora, al llamar a esta función para una celda específica, obtendremos su peso.  Realizamos esta operación para todas las celdas y seleccionamos la mejor (con el mayor peso).  Ahí y ve) <br><br>  Puedes encontrar el resto del código en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github</a> .  Ya hay mucho material y su presentación, como no lo he probado, deja mucho que desear.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pero si pudieras leer hasta este punto, querido lector, entonces te estoy agradecido. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mi opinion sobre el resultado </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¡Baja! </font><font style="vertical-align: inherit;">Sí, puedes vencerlo, pero hacerlo es un poco problemático para mí personalmente. </font><font style="vertical-align: inherit;">Quizás no soy lo suficientemente cuidadoso. </font><font style="vertical-align: inherit;">Prueba tu fuerza también. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sé que es más fácil, pero no sé cómo. </font><font style="vertical-align: inherit;">Me gustaría escuchar a las personas que conocen o observan otras implementaciones de tal bot. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sé lo que puede ser mejor. </font><font style="vertical-align: inherit;">Sí ... puedes usar algoritmos bien conocidos, como minimax, pero para esto necesitas tener una base de conocimiento en el campo de la teoría de juegos, que desafortunadamente no puedo presumir. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el futuro planeo agregar análisis de puntos de corte varios pasos adelante, lo que hará que el bot sea un rival aún más serio. </font><font style="vertical-align: inherit;">Sin embargo, ahora no tengo una idea clara sobre la implementación de esto; </font><font style="vertical-align: inherit;">Solo tengo la próxima sesión y un diploma incompleto, lo que me entristece. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gracias si lees hasta el final.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es430708/">https://habr.com/ru/post/es430708/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es430694/index.html">Una breve guía para aprender C ++: qué, cuándo y qué crear</a></li>
<li><a href="../es430700/index.html">Un sistema unificado para grabar vistas de películas en línea comenzará a funcionar en Rusia</a></li>
<li><a href="../es430702/index.html">Entrenamiento muy extraño</a></li>
<li><a href="../es430704/index.html">Cómo las tecnologías de inteligencia artificial ayudan a Aviasales a crecer: siete ejemplos</a></li>
<li><a href="../es430706/index.html">Nueva teoría de la evolución</a></li>
<li><a href="../es430710/index.html">Qué hacer si Black Friday es mañana y sus servidores no están listos</a></li>
<li><a href="../es430712/index.html">NeurIPS: Cómo conquistar la mejor conferencia de ML</a></li>
<li><a href="../es430714/index.html">VMware compra Heptio: ¿qué significa para Kubernetes?</a></li>
<li><a href="../es430718/index.html">¿Para qué objetos vale la pena usar la videovigilancia en la nube?</a></li>
<li><a href="../es430720/index.html">Intel RealSense D435i: pequeña actualización y breve digresión histórica</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>