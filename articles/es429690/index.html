<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•É üòµ üë©üèø‚Äçü§ù‚Äçüë©üèª Errorx: biblioteca para trabajar con errores en Go üë®üèæ‚Äçüè≠ üñäÔ∏è üî©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬øQu√© es Errorx y c√≥mo es √∫til? 


 Errorx es una biblioteca para manejar errores en Go. Proporciona herramientas para resolver problemas asociados con...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Errorx: biblioteca para trabajar con errores en Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/joom/blog/429690/"><h1 id="chto-takoe-errorx-i-chem-on-polezen">  ¬øQu√© es Errorx y c√≥mo es √∫til? </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Errorx</a> es una biblioteca para manejar errores en Go.  Proporciona herramientas para resolver problemas asociados con el mecanismo de error en proyectos grandes y una sintaxis √∫nica para trabajar con ellos. </p><br><p><img src="https://habrastorage.org/webt/wq/c2/aw/wqc2awx3pmke-loujb4ea0yngya.jpeg" alt="imagen"></p><br><p>  La mayor√≠a de los componentes del servidor Joom se han escrito en Go desde que se fund√≥ la empresa.  Esta elecci√≥n vali√≥ la pena en las etapas iniciales de desarrollo y la vida √∫til del servicio, y a la luz de los <a href="">anuncios</a> sobre las perspectivas de Go 2, estamos seguros de que no nos arrepentiremos en el futuro.  Una de las principales virtudes de Go es la simplicidad, y el enfoque de los errores demuestra este principio como nada m√°s.  No todos los proyectos alcanzan una escala suficiente para que las capacidades de la biblioteca est√°ndar no sean suficientes, lo que le lleva a buscar sus propias soluciones en esta √°rea.  Sucedimos que experimentamos cierta evoluci√≥n en los enfoques para trabajar con errores, y la biblioteca errorx refleja el resultado de esta evoluci√≥n.  Estamos convencidos de que puede ser √∫til para muchas personas, incluidas aquellas que a√∫n no sienten una gran incomodidad al trabajar con errores en sus proyectos. </p><a name="habracut"></a><br><h2 id="oshibki-v-go">  Errores en Go </h2><br><p>  Antes de pasar a la historia sobre errorx, se deben hacer algunas aclaraciones.  Al final, ¬øqu√© hay de malo con los errores? </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> error <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Error() <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> }</code> </pre> <br><p>  Muy simple, verdad?  En la pr√°ctica, una implementaci√≥n a menudo no lleva nada m√°s que una descripci√≥n de cadena del error.  Tal minimalismo est√° conectado con el enfoque seg√∫n el cual un error no necesariamente significa algo "excepcional".  Los errores m√°s utilizados. New () de la biblioteca est√°ndar es fiel a esta idea: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">New</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(text </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;errorString{text} }</code> </pre> <br><p>  Si recordamos que los errores en un idioma no tienen un estado especial y son objetos comunes, surge la pregunta: ¬øcu√°l es la peculiaridad de trabajar con ellos? </p><br><p>  Los errores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no</a> son la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">excepci√≥n</a> .  No es ning√∫n secreto que muchos, cuando se familiarizan con Go, encuentran esta diferencia con cierta resistencia.  Hay muchas publicaciones, tanto explicativas como de apoyo, y critican el enfoque elegido en Go.  De una forma u otra, los errores en Go sirven para muchos prop√≥sitos, y al menos uno de ellos es exactamente el mismo que las excepciones en algunos otros idiomas: soluci√≥n de problemas.  Como resultado, es natural esperar de ellos el mismo poder expresivo, incluso si el enfoque y la sintaxis asociados con su uso son muy diferentes. </p><br><h3 id="chto-ne-tak">  Que esta mal </h3><br><p>  Muchos proyectos aprovechan los errores en Go, tal como est√°n, y no tienen la menor dificultad al respecto.  Sin embargo, a medida que crece la complejidad del sistema, comienzan a aparecer una serie de problemas que llaman la atenci√≥n incluso en ausencia de altas expectativas.  Una buena ilustraci√≥n es una l√≠nea similar en el registro de su servicio: </p><br><p> <code>Error: duplicate key</code> </p> <br><p>  Aqu√≠, el primer problema se vuelve obvio de inmediato: si no se ocupa de esto a prop√≥sito, en un sistema de alguna manera grande es casi imposible entender qu√© sali√≥ mal, solo por el mensaje inicial.  Esta publicaci√≥n carece de detalles y un contexto m√°s amplio del problema.  Este es un error del programador, pero sucede con demasiada frecuencia para descuidarlo.  El c√≥digo dedicado a las ramas "positivas" del gr√°fico de control siempre merece m√°s atenci√≥n en la pr√°ctica y est√° mejor cubierto por las pruebas que el c√≥digo "negativo" asociado con la interrupci√≥n de la ejecuci√≥n o problemas externos.  Con qu√© frecuencia el mantra <code>if err != nil {return err}</code> repite en los programas Go hace que esta supervisi√≥n sea a√∫n m√°s probable. </p><br><p>  Como una peque√±a digresi√≥n, considere este ejemplo: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *Manager)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplyToUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(User)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*Data, error)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ids</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UserID</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { users, err := m.LoadUsers(ids) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> actionData []*Data <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, user := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> users { data, err := action(user) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } ok, err := m.validateData(data) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { log.Error(<span class="hljs-string"><span class="hljs-string">"Validation failed for %v"</span></span>, data) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> } actionData = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(actionData, data) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m.Apply(actionData) }</code> </pre> <br><p>  ¬øQu√© tan r√°pido vio el error en este c√≥digo?  Pero se hizo al menos una vez, probablemente por cualquier programador de Go.  Sugerencia: error en la expresi√≥n <code>if err != nil { return nil }</code> . </p><br><p>  Si volvemos al problema con un mensaje borroso en el registro, entonces, en esta situaci√≥n, por supuesto, todos tambi√©n sucedieron.  Comenzar a corregir el c√≥digo de manejo de errores ya en el momento en que ocurre el problema es muy desagradable;  Adem√°s, de acuerdo con los datos iniciales del registro, no est√° completamente claro de qu√© lado comenzar a buscar esa parte del c√≥digo que, de hecho, debe mejorarse.  Esto puede parecer una complejidad exagerada para proyectos que son peque√±os en c√≥digo y en la cantidad de dependencias externas.  Sin embargo, para proyectos a gran escala, este es un problema completamente real y doloroso. </p><br><p>  Supongamos que un programador de experiencia amarga quiere agregar contexto por adelantado al error que regresa.  La manera ingenua de hacer esto es algo como esto: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InsertUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { err := usersTable.Insert(u) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.New(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"failed to insert user %s: %v"</span></span>, u.Name, err) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p>  Se puso mejor.  El contexto m√°s amplio a√∫n no est√° claro, pero ahora es mucho m√°s f√°cil encontrar al menos en qu√© c√≥digo se produjo el error.  Sin embargo, habiendo resuelto un problema, sin querer creamos otro.  El error creado aqu√≠ mantuvo el mensaje de diagn√≥stico original, pero todo lo dem√°s, incluido su tipo y contenido adicional, se perdi√≥. </p><br><p>  Para ver por qu√© esto es peligroso, considere un c√≥digo similar en el controlador de la base de datos: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ErrDuplicateKey = errors.New(<span class="hljs-string"><span class="hljs-string">"duplicate key"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *Table)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(entity </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// returns ErrDuplicateKey if a unique constraint is violated by insert } func IsDuplicateKeyError(err error) bool { return err == ErrDuplicateKey }</span></span></code> </pre> <br><p>  Ahora la comprobaci√≥n <code>IsDuplicateKeyError()</code> est√° destruida, aunque en el momento en que agregamos nuestro texto al error, no ten√≠amos intenci√≥n de cambiar su sem√°ntica.  Esto, a su vez, romper√° el c√≥digo que se basa en esta verificaci√≥n: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { err := InsertUser(u) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> db.IsDuplicateKeyError(err) { <span class="hljs-comment"><span class="hljs-comment">// find existing user, handle conflict } else { return err } }</span></span></code> </pre> <br><p>  Si queremos hacerlo de manera m√°s inteligente y agregar nuestro propio tipo de error, que almacenar√° el error original y podr√° devolverlo, digamos, a trav√©s del m√©todo de <code>Cause() error</code> , entonces tambi√©n resolveremos el problema solo parcialmente. </p><br><ol><li>  Ahora, en lugar del procesamiento de errores, debe saber que la verdadera raz√≥n radica en <code>Cause()</code> </li><li>  No hay forma de ense√±ar este conocimiento a las bibliotecas externas, y las funciones auxiliares escritas en ellas seguir√°n siendo in√∫tiles </li><li>  Nuestra implementaci√≥n puede esperar que <code>Cause()</code> devuelva la causa inmediata del error (o nula si no es as√≠), mientras que la implementaci√≥n en otra biblioteca esperar√° que el m√©todo devuelva no nil la causa ra√≠z;  la falta de herramientas est√°ndar o un contrato generalmente aceptado amenaza con sorpresas muy desagradables </li></ol><br><p>  Sin embargo, esta soluci√≥n parcial se utiliza en muchas bibliotecas de errores, incluida, en cierta medida, la nuestra.  Hay planes en Go 2 para popularizar este enfoque; si esto sucede, ser√° m√°s f√°cil lidiar con los problemas descritos anteriormente. </p><br><h2 id="errorx">  Errorx </h2><br><p>  A continuaci√≥n hablaremos sobre lo que ofrece errorx, pero primero intente formular las consideraciones que subyacen a la biblioteca. </p><br><ul><li>  <strong>Los diagn√≥sticos son m√°s importantes que ahorrar recursos.</strong>  El rendimiento de crear y mostrar errores es importante.  Sin embargo, representan un camino negativo en lugar de positivo, y en la mayor√≠a de los casos sirven como se√±al de un problema, por lo tanto, la presencia de informaci√≥n de diagn√≥stico en un error es a√∫n m√°s importante. </li><li>  <strong>Seguimiento de pila por defecto.</strong>  Para que el error desaparezca con la totalidad del diagn√≥stico, no se requiere ning√∫n esfuerzo.  Por el contrario, es precisamente para excluir parte de la informaci√≥n (por brevedad o por razones de rendimiento) que se pueden requerir acciones adicionales. </li><li>  <strong>Sem√°ntica de errores.</strong>  Debe haber una forma simple y confiable de verificar el significado del error: su tipo, variedad, propiedades. </li><li>  <strong>Facilidad de adici√≥n.</strong>  Agregar informaci√≥n de diagn√≥stico a un error de aprobaci√≥n deber√≠a ser simple y no deber√≠a arruinar la verificaci√≥n de su sem√°ntica. </li><li>  <strong>Simplicidad</strong>  El c√≥digo dedicado a los errores se escribe a menudo y de manera rutinaria, por lo que la sintaxis de las manipulaciones b√°sicas con ellos debe ser simple y concisa.  Esto reduce la cantidad de errores y facilita la lectura. </li><li>  <strong>Menos es m√°s.</strong>  La comprensibilidad y uniformidad del c√≥digo es m√°s importante que las caracter√≠sticas opcionales y las opciones de expansi√≥n (que, probablemente, nadie usar√°). </li><li>  <strong>La sem√°ntica de error es parte de la API.</strong>  Los errores que requieren un procesamiento separado en el c√≥digo de llamada son de facto parte del paquete API p√∫blico.  No necesita tratar de ocultarlo o hacerlo menos expl√≠cito, pero puede hacer que el procesamiento sea m√°s conveniente y las dependencias externas sean menos fr√°giles. </li><li>  <strong>La mayor√≠a de los errores son opacos.</strong>  Cuantos m√°s tipos de errores para un usuario externo no se puedan distinguir entre s√≠, mejor.  La carga de los tipos de errores API que requieren un manejo especial, as√≠ como la carga de los propios errores con los datos necesarios para procesarlos es un defecto de dise√±o que debe evitarse. </li></ul><br><p>  La pregunta m√°s dif√≠cil para nosotros fue la extensibilidad: ¬ødebe errorx proporcionar primitivas para instituir tipos personalizados de errores que sean arbitrariamente diferentes en el comportamiento, o hay una implementaci√≥n que le permita obtener todo lo que necesita de la caja?  Hemos elegido la segunda opci√≥n.  En primer lugar, errorx resuelve un problema muy pr√°ctico, y nuestra experiencia al usarlo muestra que para este prop√≥sito es mejor tener una soluci√≥n, en lugar de piezas de repuesto para crearla.  En segundo lugar, la consideraci√≥n con respecto a la simplicidad es muy significativa: dado que se presta menos atenci√≥n a los errores, el c√≥digo debe dise√±arse de tal manera que sea dif√≠cil trabajar con ellos.  La pr√°ctica ha demostrado que para esto es importante que todo ese c√≥digo se vea y funcione igual. </p><br><h4 id="tldr-po-osnovnym-ficham-biblioteki">  TL; DR por caracter√≠sticas principales de la biblioteca: </h4><br><ul><li>  Pila de ubicaciones de creaci√≥n de rastreo en todos los errores de forma predeterminada </li><li>  Verificaciones de errores, varias variedades. </li><li>  La capacidad de agregar informaci√≥n a un error existente sin romper nada </li><li>  Escriba control de visibilidad si desea ocultar el motivo original de la persona que llama </li><li>  Error al manejar el mecanismo de generalizaci√≥n del c√≥digo (jerarqu√≠a de tipos, rasgos) </li><li>  Error de personalizaci√≥n por propiedades din√°micas </li><li>  Tipos de error est√°ndar </li><li>  Utilidades de sintaxis para mejorar la legibilidad del c√≥digo de manejo de errores </li></ul><br><h3 id="vvedenie">  Introduccion </h3><br><p>  Si reelaboramos el ejemplo que analizamos anteriormente usando errorx, obtenemos lo siguiente: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( DBErrors = errorx.NewNamespace(<span class="hljs-string"><span class="hljs-string">"db"</span></span>) ErrDuplicateKey = DBErrors.NewType(<span class="hljs-string"><span class="hljs-string">"duplicate_key"</span></span>) ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *Table)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(entity </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... return ErrDuplicateKey.New("violated constraint %s", details) } func IsDuplicateKeyError(err error) bool { return errorx.IsOfType(err, ErrDuplicateKey) }</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InsertUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { err := usersTable.Insert(u) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorx.Decorate(err, <span class="hljs-string"><span class="hljs-string">"failed to insert user %s"</span></span>, u.Name) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p>  El c√≥digo de la persona que <code>IsDuplicateKeyError()</code> usando <code>IsDuplicateKeyError()</code> no cambiar√°. </p><br><p>  ¬øQu√© ha cambiado en este ejemplo? </p><br><ul><li>  <code>ErrDuplicateKey</code> convirti√≥ en un tipo, no en una instancia de error;  comprobarlo es resistente a los errores de copia; no existe una dependencia fr√°gil de la igualdad exacta </li><li>  Hay un espacio de nombres para los errores de la base de datos;  lo m√°s probable es que tenga otros errores, y dicha agrupaci√≥n es √∫til para facilitar la lectura y, en algunos casos, puede usarse en el c√≥digo </li><li>  Insert devuelve un nuevo error para cada llamada: <br><ul><li>  El error contiene m√°s detalles;  esto, por supuesto, es posible sin errorx, pero es imposible si se devuelve la misma instancia de error cada vez, que anteriormente se requer√≠a para <code>IsDuplicateKeyError()</code> </li><li>  Estos errores pueden llevar un seguimiento de pila diferente, lo cual es √∫til porque  no para todas las llamadas a la funci√≥n Insertar, esta situaci√≥n es aceptable </li></ul></li><li>  <code>InsertUser()</code> complementa el texto de error, pero aplica el error original, que se conserva en su totalidad para las operaciones posteriores </li><li>  <code>IsDuplicateKeyError()</code> ahora funciona: no se puede estropear ni copiando el error, ni por tantas capas como desee con Decorate () </li></ul><br><p>  No es necesario seguir siempre tal esquema: </p><br><ul><li>  El tipo de error est√° lejos de ser siempre √∫nico: se pueden usar los mismos tipos en muchos lugares </li><li>  Si lo desea, la colecci√≥n de seguimiento de la pila se puede deshabilitar, y no puede crear un nuevo error cada vez, sino devolver el mismo que en el ejemplo original;  estos son los llamados errores centinela, y no recomendamos su uso, pero puede ser √∫til si el error se usa solo como un marcador en el c√≥digo, y desea guardar en la creaci√≥n de objetos </li><li>  Hay una manera de hacer que la <code>errorx.IsOfType(err, ErrDuplicateKey)</code> deje de funcionar si desea ocultar la sem√°ntica de la causa ra√≠z de miradas indiscretas </li><li>  Hay otras formas de comprobar el tipo, adem√°s de comparar con el tipo exacto. </li></ul><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Godoc</a> contiene informaci√≥n detallada sobre todo esto.  A continuaci√≥n, profundizaremos un poco en las caracter√≠sticas principales, que son suficientes para el trabajo diario. </p><br><h3 id="tipy">  Tipos </h3><br><p>  Cualquier errorx error pertenece a alg√∫n tipo.  El tipo importa porque  las propiedades de error heredadas pueden pasarse a trav√©s de √©l;  es a trav√©s de √©l o de sus rasgos que se realizar√°n pruebas sem√°nticas si es necesario.  Adem√°s, el nombre expresivo del tipo complementa el mensaje de error y en algunos casos puede reemplazarlo. </p><br><pre> <code class="go hljs">AuthErrors = errorx.NewNamespace(<span class="hljs-string"><span class="hljs-string">"auth"</span></span>) ErrInvalidToken = AuthErrors.NewType(<span class="hljs-string"><span class="hljs-string">"invalid_token"</span></span>)</code> </pre> <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ErrInvalidToken.NewWithNoMessage()</code> </pre> <br><p>  El mensaje de error contendr√° <code>auth.invalid_token</code> .  La declaraci√≥n de error puede verse diferente: </p><br><pre> <code class="go hljs">ErrInvalidToken = AuthErrors.NewType(<span class="hljs-string"><span class="hljs-string">"invalid_token"</span></span>).ApplyModifiers(errorx.TypeModifierOmitStackTrace)</code> </pre> <br><p>  En esta realizaci√≥n, usando el modificador de tipo, se deshabilita la recopilaci√≥n de rastreo de pila.  El error tiene sem√°ntica de marcador: su tipo se le da al usuario externo del servicio, y una pila de llamadas en los registros no ser√≠a √∫til, porque  Esto no es un problema para ser reparado. </p><br><p>  Aqu√≠ podemos hacer una reserva de que los errores tienen una naturaleza dual en varios de sus aspectos.  El contenido del error se usa tanto para el diagn√≥stico y, a veces, como informaci√≥n para un usuario externo: cliente API, usuario de biblioteca, etc.  Los errores se usan en el c√≥digo tanto como un medio de transmitir la sem√°ntica de lo que sucedi√≥, como un mecanismo para transferir el control.  Cuando se utilizan tipos de error, esto debe tenerse en cuenta. </p><br><h3 id="sozdanie-oshibki">  Error al crear </h3><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyType.New(<span class="hljs-string"><span class="hljs-string">"fail"</span></span>)</code> </pre> <br><p>  Obtener su propio tipo para cada error es completamente opcional.  Cualquier proyecto puede tener su propio paquete de errores de uso general, y algunos conjuntos se proporcionan como parte del espacio de nombres com√∫n junto con errorx.  Contiene errores que en la mayor√≠a de los casos no implican procesamiento en el c√≥digo y son adecuados para situaciones "excepcionales" cuando algo sali√≥ mal. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorx.IllegalArgument.New(<span class="hljs-string"><span class="hljs-string">"negative value %d"</span></span>, value)</code> </pre> <br><p>  En un caso t√≠pico, una cadena de llamadas est√° dise√±ada para que se cree un error al final de la cadena y se procese desde el principio.  En Go, no es sin raz√≥n que se considere una mala forma procesar un error dos veces, es decir, escribir un error en el registro y devolverlo m√°s arriba en la pila.  Sin embargo, puede agregar informaci√≥n al error en s√≠ mismo antes de revelarlo: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorx.Decorate(err, <span class="hljs-string"><span class="hljs-string">"failed to upload '%s' to '%s'"</span></span>, filename, location)</code> </pre> <br><p>  El texto agregado al error aparecer√° en el registro, pero no har√° da√±o verificar el tipo del error original. </p><br><p>  A veces surge la necesidad opuesta: cualquiera que sea la naturaleza del error, el usuario externo del paquete no debe saberlo.  Si tuviera esa oportunidad, podr√≠a crear una dependencia fr√°gil de parte de la implementaci√≥n. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> service.ErrBadRequest.Wrap(err, <span class="hljs-string"><span class="hljs-string">"failed to load user data"</span></span>)</code> </pre> <br><p>  Una diferencia importante que hace que Wrap sea la alternativa preferida a Nuevo es que el error original se refleja completamente en los registros.  Y, en particular, traer√° consigo una √∫til pila de llamadas iniciales. </p><br><p>  Otro truco √∫til que le permite guardar toda la informaci√≥n posible sobre la pila de llamadas se ve as√≠: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorx.EnhanceStackTrace(err, <span class="hljs-string"><span class="hljs-string">"operation fail"</span></span>)</code> </pre> <br><p>  Si el error original provino de otra goroutina, el resultado de dicha llamada contendr√° un rastro de pila de ambas goroutinas, lo que aumenta inusualmente su utilidad.  La necesidad de hacer una llamada de este tipo se debe claramente a problemas de rendimiento: este caso es relativamente raro, y la ergonom√≠a que lo detectar√≠a por s√≠ solo ralentizar√≠a la envoltura habitual, donde no es necesario en absoluto. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Godoc</a> contiene m√°s informaci√≥n y tambi√©n describe caracter√≠sticas adicionales como DecorateMany. </p><br><h3 id="obrabotka-oshibok">  Manejo de errores </h3><br><p>  Mejor si el manejo de errores se reduce a lo siguiente: </p><br><pre> <code class="go hljs">log.Error(<span class="hljs-string"><span class="hljs-string">"Error: %+v"</span></span>, err)</code> </pre> <br><p>  Cuanto menos error tenga que cometer, excepto para imprimirlo en el registro en la capa del sistema del proyecto, mejor.  En realidad, esto a veces no es suficiente, y tienes que hacer esto: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errorx.IsOfType(err, MyType) { <span class="hljs-comment"><span class="hljs-comment">/* handle */</span></span> }</code> </pre> <br><p>  Esta comprobaci√≥n tendr√° √©xito tanto en un error de tipo <code>MyType</code> como en sus tipos secundarios, y es resistente a <code>errorx.Decorate()</code> .  Aqu√≠, sin embargo, existe una dependencia directa del tipo de error, que es bastante normal dentro del paquete, pero puede ser desagradable si se usa fuera de √©l.  En algunos casos, el tipo de dicho error es parte de una API externa estable, y a veces nos gustar√≠a reemplazar esta verificaci√≥n con una verificaci√≥n de propiedad, y no el tipo exacto de error. </p><br><p>  En los errores cl√°sicos de Go, esto se har√≠a a trav√©s de una interfaz, tipo de conversi√≥n que servir√≠a como indicador del tipo de error.  Los tipos de errorx no son compatibles con esta extensi√≥n, pero puede utilizar el mecanismo de <code>Trait</code> lugar.  Por ejemplo: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsTemporary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HasTrait(err, Temporary()) }</code> </pre> <br><p>  Esta funci√≥n integrada en errorx verifica si el error tiene la propiedad est√°ndar <code>Temporary</code> , es decir  si es temporal  Marcar los tipos de errores con rasgos es responsabilidad de la fuente del error, y a trav√©s de ellos puede transmitir una se√±al √∫til sin hacer que los tipos internos espec√≠ficos formen parte de la API externa. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorx.IgnoreWithTrait(err, errorx.NotFound())</code> </pre> <br><p>  Esta sintaxis es √∫til cuando se necesita un cierto tipo de error para interrumpir el flujo de control, pero no debe pasarse a la funci√≥n de llamada. </p><br><p>  A pesar de la abundancia de herramientas de procesamiento, no todas se enumeran aqu√≠, es importante recordar que trabajar con errores debe ser lo m√°s simple posible.  Un ejemplo de las reglas que tratamos de cumplir: </p><br><ul><li>  El c√≥digo que recibe un error siempre debe registrarlo en su totalidad;  si parte de la informaci√≥n es superflua, deje que el c√≥digo que produce el error se encargue de esto </li><li>  Nunca debe usar el texto de error o el resultado de la funci√≥n <code>Error()</code> para procesarlo en c√≥digo;  solo las verificaciones de tipo / rasgo son adecuadas para esto, o la aserci√≥n de tipo en caso de errores que no sean errorx </li><li>  El c√≥digo de usuario no debe romperse debido a que alg√∫n tipo de error no se procesa de una manera especial, incluso si dicho procesamiento es posible y le da caracter√≠sticas adicionales </li><li>  Los errores que son verificados por las propiedades son mejores que los llamados errores centinela, porque  tales controles son menos fr√°giles </li></ul><br><h3 id="vne-errorx">  Error exteriorx </h3><br><p>  Aqu√≠ describimos lo que est√° disponible para el usuario de la biblioteca fuera de la caja, pero en Joom la penetraci√≥n del c√≥digo relacionado con errores es muy grande.  El m√≥dulo de registro acepta expl√≠citamente errores en su firma y se imprime para eliminar la posibilidad de formateo incorrecto, as√≠ como extraer informaci√≥n contextual disponible opcionalmente de la cadena de errores.  El m√≥dulo responsable del trabajo seguro contra el p√°nico con goroutins desempaqueta el error si llega con p√°nico, y tambi√©n sabe c√≥mo presentar el p√°nico utilizando la sintaxis de error sin perder el rastro original de la pila.  Algo de esto, quiz√°s tambi√©n lo publicaremos. </p><br><h2 id="voprosy-sovmestimosti">  Problemas de compatibilidad </h2><br><p>  A pesar del hecho de que estamos muy satisfechos con la forma en que errorx nos permite trabajar con errores, la situaci√≥n con el c√≥digo de la biblioteca dedicada a este tema est√° lejos de ser ideal.  En Joom resolvemos problemas pr√°cticos bastante espec√≠ficos con errorx, pero desde el punto de vista del ecosistema Go, ser√≠a preferible tener todo este conjunto de herramientas en la biblioteca est√°ndar.  El error, cuya fuente pertenece real o potencialmente a otro paradigma, debe considerarse como extra√±o, es decir.  potencialmente no llevar informaci√≥n en la forma que se acepta en el proyecto. </p><br><p>  Sin embargo, se han hecho algunas cosas para no entrar en conflicto con otras soluciones existentes. </p><br><p>  El formato <code>'%+v'</code> usa para imprimir un error junto con el seguimiento de la pila, si est√° presente.  Este es el est√°ndar de facto en el ecosistema Go e incluso se incluye en el dise√±o preliminar para Go 2. </p><br><p>  <code>Cause() error</code>  errorx ,  ,   ,    Causer,       errorx      Wrap(). </p><br><h2 id="buduschee">  </h2><br><p>  <a href=""></a>   ,    Go 2,      .  <a href="">   </a>       . </p><br><p> ,    errorx     Go 1.      ,    Go 2,     .       ,            ,        errorx. </p><br><p> Check-handle      ,   errorx , a <code>Unwrap() error</code>       <code>Wrap()</code>  errorx (.. ,        ,    <code>Wrap</code> ),    .     ,      ,  . </p><br><p>     design draft   Go 2,    <code>errorx.Is()</code>  <code>errorx.As()</code>   ,      errors   . </p><br><h2 id="zaklyuchenie">  Conclusi√≥n </h2><br><p>   ,   ,   ,    -      ,        .      ,      API     :  ,   ,       .  1.0      ,           Joom. ,  -       . </p><br><p> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/joomcode/errorx</a> </p><br><p>   ,    ! </p><br><p><img src="https://habrastorage.org/webt/nk/hv/el/nkhvelss5upmybktmbpy68ozo_a.jpeg" alt="imagen"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es429690/">https://habr.com/ru/post/es429690/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es429680/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 17: Autenticaci√≥n de usuario, Parte 1</a></li>
<li><a href="../es429682/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 17: Autenticaci√≥n de usuario, Parte 2</a></li>
<li><a href="../es429684/index.html">Firebase Summit 2018: brevemente sobre lo principal</a></li>
<li><a href="../es429686/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 17: "Autenticaci√≥n de usuario", parte 3</a></li>
<li><a href="../es429688/index.html">C√≥mo crear un h√©roe que se cree</a></li>
<li><a href="../es429692/index.html">Optimizaci√≥n de manejo de eventos en Angular</a></li>
<li><a href="../es429694/index.html">Mail.Ru calific√≥ las clasificaciones de Yandex como "absurdas" y exige eliminar sus marcas.</a></li>
<li><a href="../es429696/index.html">Informes en video con MOSDROID # 13 Aluminio</a></li>
<li><a href="../es429698/index.html">C√≥mo trabajar con Lebedev Studio: experiencia Tutu.ru</a></li>
<li><a href="../es429700/index.html">Definici√≥n de n√∫meros por o√≠do</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>