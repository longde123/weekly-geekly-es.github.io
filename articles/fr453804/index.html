<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèæ‚Äçü§ù‚Äçüßëüèæ ‚ò∏Ô∏è üßïüèø Le livre "Comp√©titivit√© et concurrence sur la plate-forme .NET. Mod√®les de conception efficaces " ü¶Ü üíÜüèº üÄÑÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut, habrozhiteli! Le livre de Riccardo Terrell fournit des conseils sur la fa√ßon de cr√©er des programmes comp√©titifs et √©volutifs dans .NET, soulig...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Le livre "Comp√©titivit√© et concurrence sur la plate-forme .NET. Mod√®les de conception efficaces "</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/453804/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/xh/fk/az/xhfkazyaueuwhx3c7cjwt5ohyea.jpeg" align="left" alt="image"></a>  Salut, habrozhiteli!  Le livre de Riccardo Terrell fournit des conseils sur la fa√ßon de cr√©er des programmes comp√©titifs et √©volutifs dans .NET, soulignant les avantages d'un paradigme fonctionnel et fournissant les outils et principes appropri√©s pour maintenir la concurrence de mani√®re comp√©titive et facile.  En cons√©quence, arm√© de nouvelles comp√©tences, vous recevrez les connaissances n√©cessaires pour devenir un expert dans la fourniture de solutions performantes performantes. <br><br>  Si vous √©crivez du code multithread dans .NET, ce livre peut vous aider.  Si vous souhaitez utiliser un paradigme fonctionnel pour simplifier la programmation comp√©titive et maximiser les performances des applications, ce livre sera un guide important pour vous.  Il b√©n√©ficiera √† tout d√©veloppeur .NET qui souhaite √©crire des applications comp√©titives, r√©actives et asynchrones qui √©voluent et s'adaptent automatiquement aux ressources mat√©rielles existantes partout o√π de tels programmes fonctionnent. <br><a name="habracut"></a><br><h3>  Structure de publication: feuille de route </h3><br>  Les quatorze chapitres de ce livre sont divis√©s en trois parties.  La partie I pr√©sente les concepts fonctionnels de la programmation comp√©titive et d√©crit les comp√©tences n√©cessaires pour comprendre les aspects fonctionnels de la r√©daction de programmes multithread. <br><br><ul><li>  Le chapitre 1 d√©crit les concepts et objectifs de base de la programmation comp√©titive, ainsi que les raisons d'utiliser la programmation fonctionnelle pour √©crire des applications multithreads. </li><li>  Le chapitre 2 explore une gamme de technologies de programmation fonctionnelle pour am√©liorer les performances des applications multithread.  Le but de ce chapitre est de fournir au lecteur les concepts utilis√©s dans le reste du livre et d'introduire des id√©es puissantes qui d√©coulent d'un paradigme fonctionnel. </li><li>  Le chapitre 3 donne un aper√ßu du concept fonctionnel d'immuabilit√©.  Il explique comment l'immuabilit√© est utilis√©e pour √©crire des programmes comp√©titifs pr√©visibles et corrects et pour mettre en ≈ìuvre des structures de donn√©es fonctionnelles qui sont de nature s√©curis√©e pour les threads. </li></ul><br>  Dans la partie II, divers mod√®les de programmation comp√©titive dans un paradigme fonctionnel sont examin√©s en profondeur.  Nous explorerons des sujets tels que la biblioth√®que parall√®le de t√¢ches (TPL) et impl√©menterons des mod√®les parall√®les tels que Fork / Join, diviser et conqu√©rir et MapReduce.  Cette section traite √©galement de la pr√©sentation d√©clarative, des abstractions de haut niveau dans les op√©rations asynchrones, de la programmation des agents et de la s√©mantique de transfert de messages. <br><br><ul><li>  Le chapitre 4 d√©crit les bases du traitement parall√®le de grandes quantit√©s de donn√©es, y compris des mod√®les tels que Fork / Join. </li><li>  Le chapitre 5 pr√©sente des m√©thodes plus sophistiqu√©es pour le traitement parall√®le de grandes quantit√©s d'informations, telles que l'agr√©gation parall√®le, la r√©duction des donn√©es et la mise en ≈ìuvre d'un mod√®le MapReduce parall√®le. </li><li>  Le chapitre 6 fournit des informations d√©taill√©es sur les m√©thodes fonctionnelles de traitement des flux d'√©v√©nements (donn√©es) en temps r√©el √† l'aide des op√©rateurs fonctionnels de haut niveau dans .NET Reactive Extensions pour former des combinateurs d'√©v√©nements asynchrones.  Les m√©thodes √©tudi√©es seront ensuite utilis√©es pour impl√©menter un mod√®le r√©actif √©diteur-abonn√© comp√©titif. </li><li> Le chapitre 7 fournit une explication du mod√®le de programmation bas√© sur les t√¢ches appliqu√© √† la programmation fonctionnelle pour la mise en ≈ìuvre d'op√©rations concurrentielles √† l'aide du mod√®le Monadic.  Ensuite, cette m√©thode est utilis√©e pour construire un pipeline comp√©titif bas√© sur un paradigme de programmation fonctionnelle. </li><li>  Le chapitre 8 est consacr√© √† l'impl√©mentation de l'informatique parall√®le illimit√©e √† l'aide du mod√®le de programmation asynchrone C #.  Ce chapitre traite √©galement des m√©thodes de gestion des erreurs et des m√©thodes de construction d'op√©rations asynchrones. </li><li>  Le chapitre 9 d√©crit le flux de travail asynchrone en F #.  Il montre comment une √©valuation diff√©r√©e et explicite dans ce mod√®le permet une s√©mantique de composition plus √©lev√©e.  Ensuite, nous apprendrons comment impl√©menter des expressions de calcul personnalis√©es pour √©lever le niveau d'abstraction √† la programmation d√©clarative. </li><li>  Le chapitre 10 montre comment, sur la base des connaissances acquises dans les chapitres pr√©c√©dents, des combinateurs et des mod√®les, tels que Functor, Monad et Applicative, peuvent √™tre impl√©ment√©s pour composer et ex√©cuter plusieurs op√©rations asynchrones et g√©rer les erreurs sans effets secondaires. </li><li>  Le chapitre 11 analyse la programmation r√©active √† l'aide d'un mod√®le de messagerie logicielle.  Il r√©v√®le le concept d'isolement naturel en tant que technologie qui compl√®te l'immuabilit√© et permet la cr√©ation de programmes comp√©titifs.  Ce chapitre se concentre sur la classe MailboxProcessor utilis√©e en F # pour distribuer le travail parall√®le √† l'aide de la programmation d'agent et d'une approche sans ressources. </li><li>  Le chapitre 12 d√©crit la programmation d'agent √† l'aide de la biblioth√®que de flux de donn√©es TPL de .NET avec des exemples en C #.  Il montre comment impl√©menter des agents sans √©tat et avec √©tat en C #, ainsi que comment effectuer plusieurs calculs en parall√®le qui √©changent des donn√©es entre eux, en utilisant (envoyant) des messages dans le style d'un pipeline. </li></ul><br>  La partie III montre comment mettre en pratique toutes les m√©thodes fonctionnelles de programmation comp√©titive √©tudi√©es dans les chapitres pr√©c√©dents. <br><br><ul><li>  Le chapitre 13 pr√©sente un ensemble de recettes utiles pour r√©soudre des probl√®mes de concurrence complexes, tir√©es de la pratique r√©elle.  Ces recettes utilisent tous les mod√®les fonctionnels d√©crits dans ce livre. </li><li>  Le chapitre 14 d√©crit une application √† part enti√®re d√©velopp√©e et mise en ≈ìuvre √† l'aide de mod√®les et de m√©thodes comp√©titifs fonctionnels √©tudi√©s dans ce livre.  Vous allez cr√©er une application serveur hautement √©volutive et r√©active et un programme client r√©actif.  Le livre contient deux versions: une pour iOS (iPad), cr√©√©e √† l'aide de Xamarin Visual Studio, et la seconde - cr√©√©e √† l'aide de Windows Presentation Foundation (WPF).  Pour garantir une √©volutivit√© maximale dans l'application serveur, une combinaison de divers mod√®les de programmation, tels que asynchrone, agent et r√©actif, est utilis√©e. </li></ul><br>  Le livre contient √©galement trois applications. <br><br><ul><li>  L'annexe A d√©crit bri√®vement les concepts de base de la programmation fonctionnelle et pr√©sente la th√©orie de base des m√©thodes fonctionnelles utilis√©es dans ce livre. </li><li>  L'annexe B pr√©sente les concepts de base du langage F #.  Il s'agit d'une revue de base de F #, qui vous permettra de vous familiariser avec cette langue et de vous sentir √† l'aise lors de la lecture d'un livre. </li><li>  L'annexe B illustre plusieurs m√©thodes qui simplifient l'interaction entre un flux de travail asynchrone en F # et une t√¢che .NET en C #. </li></ul><br><h3>  Extrait.  11.6.  F # MailboxProcessor: 10 000 agents pour Game of Life </h3><br>  Compar√© aux threads, MailboxProcessor en combinaison avec des workflows asynchrones est une simple unit√© informatique (primitive).  Les agents peuvent appara√Ætre et √™tre d√©truits √† un co√ªt minime.  Vous pouvez r√©partir le travail entre plusieurs objets MailboxProcessor de la m√™me mani√®re que vous pouvez utiliser des threads, sans la surcharge suppl√©mentaire associ√©e √† la cr√©ation d'un nouveau thread.  Gr√¢ce √† cela, il est tout √† fait possible de cr√©er des applications compos√©es de centaines de milliers d'agents travaillant en parall√®le avec une charge minimale sur les ressources informatiques. <br><br>  Dans cette section, nous utiliserons plusieurs instances de MailboxProcessor pour impl√©menter le jeu Game of Life (le jeu "Life") ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wiki-eng</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wiki-eng</a> ).  Selon Wikipedia, le Game of Life, en termes simples, est un automate cellulaire.  Il s'agit d'un jeu sans joueurs - en d'autres termes, lorsqu'un jeu d√©marre avec une configuration initiale al√©atoire, il s'ex√©cute sans aucune autre entr√©e.  Le jeu consiste en un ensemble de cellules formant une grille;  dans chaque cellule, plusieurs r√®gles math√©matiques sont remplies.  Les cellules peuvent vivre, mourir et se multiplier.  Chaque cellule interagit avec huit voisins (cellules voisines).  Pour d√©placer les cellules conform√©ment √† ces r√®gles, il est n√©cessaire de calculer en permanence le nouvel √©tat du maillage. <br><br>  Game of Life a les r√®gles suivantes: <br><br><ul><li>  si une cellule n'a qu'un seul voisin ou aucun voisin, alors elle meurt "de solitude"; </li><li>  si quatre voisins ou plus d'une cellule meurent, elle meurt ¬´√† cause de la surpopulation¬ª; </li><li>  si la cellule a deux ou trois voisins, elle reste √† vivre; </li><li>  si une cellule a trois voisins, elle se multiplie. </li></ul><br>  Selon les conditions initiales, les cellules forment des structures caract√©ristiques tout au long du jeu.  Gr√¢ce √† l'application r√©p√©t√©e des r√®gles, les g√©n√©rations de cellules suivantes sont cr√©√©es jusqu'√† ce que les cellules atteignent un √©tat stable (Fig. 11.12). <br><br>  Le Listing 11.9 montre l'impl√©mentation de la cellule Game of Life AgentCell, bas√©e sur les types F # de MailboxProcessor.  Chaque cellule d'agent interagit avec les cellules voisines via une messagerie asynchrone, cr√©ant ainsi un jeu de vie enti√®rement parall√©lis√©.  Par souci de concision, j'ai omis certaines parties du code, car elles ne sont pas li√©es au sujet principal de l'exemple.  Vous trouverez l'impl√©mentation compl√®te dans le code source de ce livre, publi√© sur le site Web de l'√©diteur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/si/qb/jp/siqbjpp_zc4oqi7dgpk032_8xe8.png" alt="image"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2d/j9/u2/2dj9u2y7qplsftitwupamkmaji0.png" alt="image"></div><br>  AgentCell d√©crit une cellule de la grille Game of Life.  Le concept de base est que chaque agent √©change des informations avec les cellules voisines sur son √©tat actuel via la messagerie asynchrone.  Ce mod√®le cr√©e une cha√Æne de communications parall√®les interconnect√©es qui implique que toutes les cellules envoient leur √©tat mis √† jour √† l'agent de mise √† jour MailboxProcessor.  Apr√®s avoir re√ßu ces donn√©es, updateAgent met √† jour les graphiques dans l'interface utilisateur (extrait 11.10). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1a/qy/j2/1aqyj2_ar1ua7a4mjylo8gxdqgg.png" alt="image"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l4/wr/jx/l4wrjxuth4-3quliytnseqegjw8.png" alt="image"></div><br>  updateAgent, comme son nom l'indique, met √† jour l'√©tat de chaque pixel en fonction de la valeur de cellule re√ßue dans le message de mise √† jour.  L'agent maintient l'√©tat des pixels et l'utilise pour cr√©er une nouvelle image lorsque toutes les cellules transmettent leur nouvel √©tat.  UpdateAgent met ensuite √† jour l'interface graphique WPF en utilisant cette nouvelle image qui correspond √† la grille Game of Life actuelle: <br><br><pre><code class="plaintext hljs">do! Async.SwitchToContext ctx image.Source &lt;- createImage pixels do! Async.SwitchToThreadPool()</code> </pre> <br>  Il est important de noter que le updateAgent utilise le contexte de synchronisation actuel pour mettre correctement √† jour le contr√¥leur WPF.  Le thread actuel est bascul√© vers le thread d'interface utilisateur √† l'aide de la fonction Async.SwitchToContext (d√©crite au chapitre 9). <br><br>  Le dernier morceau de code pour ex√©cuter Game of Life g√©n√®re une grille qui sert de terrain de jeu pour les cellules, puis le chronom√®tre informe les cellules de la n√©cessit√© d'effectuer une mise √† jour (extrait 11.11).  Dans cet exemple, la grille est un carr√© de 100 √ó 100 cellules, soit un total de 10 000 cellules (objets MailboxProcessor), qui sont calcul√©es en parall√®le avec un temporisateur toutes les 50 ms, comme le montre la Fig.  11.13.  Dix mille objets MailboxProcessor interagissent et mettent √† jour l'interface utilisateur 20 fois par seconde (le code auquel vous devez faire attention est affich√© en gras). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ue/px/jw/uepxjwb4re6grfx1wqbmp4rx6pq.png" alt="image"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eq/cg/tx/eqcgtxipd3wr4kipmnbpqj0-rjm.png" alt="image"></div><br>  Les notifications √† toutes les cellules (agents) sont envoy√©es en parall√®le √† l'aide de PLINQ.  Les cellules sont des s√©quences F # qui sont trait√©es comme .NET IEnumerable, ce qui facilite l'int√©gration de LINQ / PLINQ. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rc/9u/wl/rc9uwlhsymr64zmqrffpte7gqcc.png" alt="image"></div><br>  Lorsque le code est ex√©cut√©, le programme g√©n√®re 10 000 objets F # de type MailboxProcessor en moins de 1 ms, tandis que les agents occupent moins de 25 Mo de m√©moire.  Impressionnant! <br><br><h3>  R√©sum√© </h3><br><ul><li>  Le mod√®le de programmation bas√© sur les agents offre naturellement l'immuabilit√© et l'isolement lors de l'√©criture de syst√®mes concurrents, ce qui facilite encore plus la discussion sur les syst√®mes complexes, car les agents sont encapsul√©s dans des objets actifs. </li><li>  Un manifeste r√©actif d√©finit les propri√©t√©s de mise en ≈ìuvre d'un syst√®me r√©actif qui est flexible, faiblement coupl√© et √©volutif. </li><li>  L'isolement naturel est important pour √©crire du code concurrentiel sans bloquer.  Dans un programme multi-thread, l'isolement r√©sout le probl√®me des √©tats partag√©s en fournissant √† chaque thread une donn√©e copi√©e pour effectuer des calculs locaux.  Lors de l'utilisation d'isolant, il n'y a pas de condition de concurrence. </li><li>  √âtant asynchrones, les agents sont simples car ils ne bloquent pas les threads en attendant les messages.  Par cons√©quent, vous pouvez utiliser des centaines de milliers d'agents dans une seule application sans beaucoup d'impact sur la taille de la m√©moire. </li><li>  Un objet MailboxProcessor F # fournit une communication bidirectionnelle: un agent peut utiliser un canal asynchrone pour renvoyer (r√©pondre) le r√©sultat du calcul √† l'objet appelant. </li><li>  Le mod√®le de programmation d'agent en F # via MailboxProcessor est un excellent outil pour r√©soudre les goulots d'√©tranglement dans les applications, comme l'acc√®s simultan√© √† plusieurs bases de donn√©es.  En fait, avec l'aide d'agents, vous pouvez acc√©l√©rer consid√©rablement l'application, tout en conservant la r√©activit√© du serveur. </li><li>  D'autres langages de programmation .NET vous permettent d'utiliser le MailboxProcessor de type F #, fournissant des m√©thodes utilisant le mod√®le de programmation TPL pratique bas√© sur les t√¢ches. </li></ul><br>  ¬ªPlus d'informations sur le livre sont disponibles sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le site Web de l'√©diteur</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Contenu</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Extrait</a> <br><br>  Coupon de 20% sur les colporteurs - <b>Concurrence dans .NET</b> <br><br>  Lors du paiement de la version papier du livre, une version √©lectronique du livre est envoy√©e par e-mail. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr453804/">https://habr.com/ru/post/fr453804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr453788/index.html">Les r√©seaux de neurones pr√©f√®rent les textures et comment y faire face.</a></li>
<li><a href="../fr453790/index.html">"Le client est parti - est-ce pour toujours?" Comment compter le taux de d√©sabonnement des clients en SaaS et ce qui ne va pas avec les mesures de base</a></li>
<li><a href="../fr453792/index.html">Syst√®mes de recommandation: id√©es, approches, t√¢ches</a></li>
<li><a href="../fr453796/index.html">Les gens ont-ils besoin de math√©matiques?</a></li>
<li><a href="../fr453800/index.html">Comment r√©soudre "D√©mineur" (et le rendre meilleur)</a></li>
<li><a href="../fr453806/index.html">Gestion des erreurs dans Go</a></li>
<li><a href="../fr453808/index.html">Nous d√©montons le mod√®le √©conomique Viking</a></li>
<li><a href="../fr453810/index.html">Retour biom√©trique</a></li>
<li><a href="../fr453812/index.html">Th√®mes, styles et autres</a></li>
<li><a href="../fr453816/index.html">Enc√©phalite √† tiques: un danger n√©glig√©</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>