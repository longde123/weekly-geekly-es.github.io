<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>âœŒğŸ¾ ğŸ”… ğŸ‘“ Fitur menggunakan perpustakaan RxJs dalam sistem perbankan online â›°ï¸ ğŸ¥› ğŸ§”ğŸ¿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Merancang sistem perbankan online modern adalah tugas yang agak rumit. Pada saat yang sama, sejumlah tugas untuk mengembangkan bagian kl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fitur menggunakan perpustakaan RxJs dalam sistem perbankan online</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/simbirsoft/blog/425897/"><h3>  Pendahuluan </h3><br>  Merancang sistem perbankan online modern adalah tugas yang agak rumit.  Pada saat yang sama, sejumlah tugas untuk mengembangkan bagian klien dari aplikasi dikaitkan dengan proses pemrosesan sejumlah besar data yang datang hampir bersamaan dari beberapa sumber informasi.  Data dari sistem perbankan jarak jauh (RBS), layanan pesan instan, berbagai layanan informasi harus diterima dan diproses secara real time di sini dan sekarang.  Untuk mengatasi masalah seperti ini, metode pemrograman reaktif banyak digunakan saat ini. <br><a name="habracut"></a><br>  Istilah "pemrograman reaktif" dalam arti luas berarti organisasi aplikasi, di mana penyebaran perubahan dalam sistem terjadi sebagai hasil dari pemrosesan status aliran data.  Masalah penting dengan metode ini adalah kesederhanaan penyajian arus informasi dan kemungkinan merespons kesalahan yang terjadi selama pemrosesan hasil presentasi yang tidak sinkron. <br><br>  Dalam arti sempit, pemrograman UI web reaktif dapat berarti menggunakan alat pengembang yang tidak tersedia, seperti perpustakaan RxJs.  Perpustakaan ini menyediakan representasi diskrit dari urutan data menggunakan objek yang dapat diobservasi, yang berfungsi sebagai sumber informasi memasuki aplikasi pada interval tertentu. <br><br>  Pertimbangkan fitur menggunakan perpustakaan pada contoh merancang antarmuka web bank online untuk bisnis kecil.  Saat mengembangkan UI, kami menggunakan platform Google Angular 6 dengan pustaka RxJs bawaan versi 6. <br><br><h3>  Tugas Desain UI Reaktif </h3><br>  Untuk pengguna, sebagian besar operasi di Internet Bank sering turun ke tiga tahap: <br><br><ul><li>  memilih operasi yang diperlukan dari daftar, misalnya, membayar pinjaman atau mengisi kembali akun; </li><li>  penyelesaian sebagian dari formulir yang sesuai (perincian pembayaran diisi secara otomatis dengan nama organisasi atau nama penerima pembayaran yang dimasukkan oleh pengguna); </li><li>  konfirmasi operasi secara otomatis menggunakan pesan SMS atau tanda tangan elektronik. </li></ul><br>  Dari sudut pandang pengembang, implementasi tahapan ini mencakup solusi dari tugas-tugas berikut: <br><br><ul><li>  memeriksa keadaan sistem RB, memastikan relevansi data tentang operasi dalam daftar; </li><li>  pemrosesan arus data yang tidak sinkron ketika mengisi formulir, termasuk data yang dimasukkan oleh pengguna dan diterima dari layanan pesan informasi (misalnya, TIN dan BIC bank, misalnya); </li><li>  validasi formulir yang sudah diisi; </li><li>  otomatis menyimpan data dalam bentuk. </li></ul><br><h3>  Memeriksa status sistem RBS </h3><br>  Proses memperoleh data yang relevan dari sistem RB, misalnya, informasi tentang batas kredit atau status pesanan pembayaran, mencakup dua tahap: <br><br><ul><li>  memeriksa status ketersediaan data; </li><li>  menerima data yang diperbarui. </li></ul><br>  Untuk memeriksa keadaan data saat ini, permintaan diajukan ke API sistem dengan periode waktu tertentu dan hingga tanggapan diterima tentang kesiapan data. <br><br>  Ada beberapa kemungkinan jawaban untuk sistem RB: <br><br><ul><li>  {empty: true} - data belum siap; </li><li>  data yang diperbarui dapat diterima oleh klien; </li></ul><br><pre><code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">empty</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-comment"><span class="hljs-comment">// -   }</span></span></code> </pre> <br><ul><li>  sebuah kesalahan. </li></ul><br>  Akibatnya, penerimaan data yang relevan dilakukan dalam bentuk: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MIN_TIME = <span class="hljs-number"><span class="hljs-number">2000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MAX_TIME = <span class="hljs-number"><span class="hljs-number">60000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> EXP_BASE = <span class="hljs-number"><span class="hljs-number">1.4</span></span>; request() <span class="hljs-comment"><span class="hljs-comment">//     .pipe( expand((response, index) =&gt; { const delayTime = Math.min(MIN_TIME * Math.pow(EXP_BASE, index), MAX_TIME); return response.empty ? request().pipe(delay(delayTime)) : EMPTY; }), last() ) .subscribe((response) =&gt; { /** -  */ });</span></span></code> </pre><br><br>  Mari kita menganalisis langkah demi langkah: <br><br><ol><li>  Kami mengirim permintaan.  permintaan () </li><li>  Jawabannya berkembang.  Expand adalah pernyataan RxJS yang secara berulang mengulang kode dalam bloknya untuk setiap peringatan berikutnya untuk Pengamatan internal dan eksternal, hingga utas mengumumkan penyelesaiannya yang berhasil.  Oleh karena itu, untuk menyelesaikan streaming, perlu untuk mengembalikan Observable sedemikian sehingga tidak ada satu berikutnya - KOSONG. </li><li>  Jika tanggapan datang {kosong: true}, maka kami membuat permintaan kedua setelah penundaan waktu tertentu (delayTime).  Agar tidak membebani server dengan permintaan, kami menambah interval waktu untuk ping dengan setiap permintaan baru. </li><li>  Jika selama permintaan berikutnya datang sesuatu yang lain sebagai respons, maka berhentilah melakukan ping (kembalikan KOSONG) dan kembalikan hasil dari permintaan terakhir ke pelanggan (terakhir () operator). </li><li>  Setelah menerima jawabannya, kami mengambil hasilnya dan memprosesnya.  Objek formulir akan berlangganan: </li></ol><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">empty</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-comment"><span class="hljs-comment">// -   }</span></span></code> </pre><br><br><h3>  Bentuk reaktif </h3><br>  Pertimbangkan tugas merancang formulir web reaktif dari dokumen pembayaran menggunakan pustaka ReactiveForms dari kerangka kerja Angular. <br><br>  Tiga kelas dasar pustaka FormControl, FormGroup, dan FormArray memungkinkan Anda untuk menggunakan deskripsi deklaratif bidang formulir, mengatur nilai awal bidang, dan menetapkan aturan validasi untuk setiap bidang: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.myForm = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FormGroup({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FormControl(<span class="hljs-string"><span class="hljs-string">''</span></span>, Validators.required), <span class="hljs-comment"><span class="hljs-comment">//          surname: new FormControl('') });</span></span></code> </pre><br><br>  Untuk formulir dengan sejumlah besar bidang, biasanya menggunakan layanan FormBuilder, yang memungkinkan Anda untuk membuatnya menggunakan kode yang lebih ringkas <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.myForm = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fb.group({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: [<span class="hljs-string"><span class="hljs-string">''</span></span>, Validators.required], <span class="hljs-attr"><span class="hljs-attr">surname</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> });</code> </pre><br><br>  Setelah membuat formulir di templat halaman pesanan pembayaran, cukup untuk menentukan tautan ke formulir MyForm, serta nama-nama nama dan nama bidangnya. <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">form</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">formGroup</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"myForm"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">label</span></span></span><span class="hljs-tag">&gt;</span></span>Name: <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">formControlName</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"name"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">label</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">label</span></span></span><span class="hljs-tag">&gt;</span></span>Surname: <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">formControlName</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"surname"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">label</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">form</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  Desain yang dihasilkan memungkinkan Anda untuk membuat dan melacak setiap aliran informasi yang melewati bidang formulir sebagai hasil dari input pengguna, dan berdasarkan pada logika bisnis aplikasi.  Untuk melakukan ini, cukup berlangganan acara yang dihasilkan oleh pengamat asinkron formulir ValueChanges <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.myForm.valueChanges .subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> { â€¦ <span class="hljs-comment"><span class="hljs-comment">//     })</span></span></code> </pre><br><br>  Misalkan logika bisnis mendefinisikan persyaratan untuk secara otomatis mengisi rincian tujuan pembayaran ketika pengguna memasukkan NPWP penerima atau nama organisasi.  Kode untuk memproses data yang dimasukkan oleh pengguna dalam TIN / nama organisasi akan terlihat seperti: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.payForm.valueChanges .pipe( mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getRequisites(value)) <span class="hljs-comment"><span class="hljs-comment">//       ) .subscribe(requisites =&gt; { this.patchFormByRequisites(requisites) //        })</span></span></code> </pre><br><br><h3>  Validasi </h3><br>  Validator datang dalam dua bentuk: <br><br><ul><li>  sinkron; </li><li>  tidak sinkron. </li></ul><br>  Kami menjumpai validator sinkron secara teratur - ini adalah fungsi yang memeriksa data yang dimasukkan saat bekerja dengan bidang.  Dalam hal bentuk reaktif: <br>  "Validator sinkron adalah fungsi yang mengambil bentuk kontrol dan mengembalikan nilai kebenaran jika ada kesalahan dan kesalahan sebaliknya." <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">customValidator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">control</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isInvalid(control.value) ? { <span class="hljs-attr"><span class="hljs-attr">code</span></span>: <span class="hljs-string"><span class="hljs-string">"mistake"</span></span>, <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">"smth wents wrong"</span></span> } : <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre><br><br>  Kami akan menerapkan validator yang akan memeriksa apakah pengguna ditunjukkan dalam bentuk serangkaian dokumen, jika paspor sebelumnya ditentukan sebagai jenis dokumen identifikasi: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requredSeria</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">control</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> docType = control.parent.get(<span class="hljs-string"><span class="hljs-string">"docType"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (docType &amp;&amp; docType.value === <span class="hljs-string"><span class="hljs-string">"passport"</span></span> &amp;&amp; !control.value) { error = { <span class="hljs-attr"><span class="hljs-attr">code</span></span>: <span class="hljs-string"><span class="hljs-string">"wrongSeria"</span></span>, <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">"  "</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error; }</code> </pre><br><br>  Di sini kita juga merujuk ke formulir induk dan menggunakannya kita mendapatkan nilai dari bidang lain.  Dimungkinkan untuk mengembalikan benar hanya sebagai kesalahan, tetapi dalam kasus ini diputuskan untuk melakukan sebaliknya.  Anda bisa menangkap pesan kesalahan ini di bidang kesalahan kontrol atau formulir.  Jika bidang memiliki beberapa validator, Anda dapat menentukan dengan tepat mana validator yang gagal menampilkan pesan kesalahan yang diinginkan atau menyesuaikan validasi bidang lain. <br><br>  Validator akan ditambahkan ke formulir sebagai berikut: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.documentForm = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fb.group({ <span class="hljs-attr"><span class="hljs-attr">docType</span></span>: [<span class="hljs-string"><span class="hljs-string">''</span></span>, Validators.required], <span class="hljs-attr"><span class="hljs-attr">seria</span></span>: [<span class="hljs-string"><span class="hljs-string">''</span></span>, requredSeria], <span class="hljs-attr"><span class="hljs-attr">number</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> });</code> </pre><br><br>  Di luar kotak, beberapa validator yang sering ditemui juga tersedia.  Semuanya diwakili oleh metode statis dari kelas Validator.  Ada juga metode untuk menyusun validator. <br>  Ketidaktepatan satu bidang langsung mengarah ke ketidakabsahan seluruh formulir.  Ini dapat digunakan ketika Anda perlu menonaktifkan tombol OK tertentu, jika formulir memiliki setidaknya satu bidang yang tidak valid.  Kemudian semuanya turun untuk memeriksa satu syarat "myform.invalid", yang akan mengembalikan true jika formulir tidak valid. <br><br>  Validator asinkron memiliki satu perbedaan - tipe nilai pengembalian.  Nilai kebenaran atau kepalsuan harus diberikan dalam janji atau dalam Pengamatan. <br><br>  Setiap kontrol atau setiap formulir memiliki status (mySuperForm.status), yang dapat berupa "VALID", "INVALID", "DISABLED".  Karena ketika menggunakan validator asinkron, mungkin tidak jelas dalam kondisi apa formulir saat ini, ada status khusus "PENDING".  Berkat kondisi ini (mySuperForm.status === "PENDING"), Anda dapat menampilkan preloader atau membuat style styling lainnya. <br><br><h3>  Simpan otomatis </h3><br>  Pengembangan perangkat lunak perbankan (software) melibatkan bekerja dengan berbagai dokumen standar.  Sebagai contoh, ini adalah formulir aplikasi atau kuesioner, yang dapat terdiri dari puluhan bidang yang diperlukan.  Saat bekerja dengan dokumen yang sangat banyak, dukungan penyimpanan otomatis diperlukan untuk kenyamanan pengguna tambahan, sehingga jika Anda kehilangan koneksi Internet atau masalah teknis lainnya, data yang dimasukkan pengguna sebelumnya tetap dalam versi konsep di server. <br><br>  Berikut adalah aspek utama dari prosedur penyimpanan otomatis untuk arsitektur client-server: <br><br><ol><li>  Simpan permintaan harus diproses oleh server sesuai urutan perubahan dilakukan.  Jika Anda segera mengirim permintaan ke setiap perubahan, Anda tidak dapat menjamin bahwa permintaan sebelumnya tidak akan datang berikutnya dan tidak akan menimpa perubahan baru. </li><li>  Tidak perlu mengirim sejumlah besar permintaan ke server sampai pengguna selesai memasukkan, cukup dengan melakukan ini berdasarkan waktu. </li><li>  Jika beberapa perubahan telah dilakukan dengan penundaan yang relatif besar, dan permintaan untuk perubahan pertama belum dikembalikan, maka tidak perlu mengirim permintaan untuk setiap perubahan selanjutnya segera setelah kembalinya permintaan pertama.  Anda hanya dapat mengambil yang terakhir, agar tidak mengirim data yang tidak relevan. </li></ol><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kasing</a> pertama dapat dengan mudah ditangani dengan menggunakan operator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">concatMap</a> .  Kasus kedua akan diselesaikan tanpa masalah menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">debounceTime</a> .  Logika yang ketiga dapat digambarkan sebagai: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lastRequest$ = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BehaviorSubject(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   queue$.subscribe(lastRequest$); queue$ .pipe( debounceTime(1000), exaustMap(request$ =&gt; request$.pipe( //  ,     map(response =&gt; ({request$, response})), //       catchError(() =&gt; of(null) //   ) ) .subscribe(({request$, response}) =&gt; { if (lastRequest$.value !== request$) { queue$.next(lastRequest$.value); //     } });</span></span></code> </pre><br><br>  Tetap di saveQueue $ untuk mengirim permintaan.  Catat keberadaan operator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">exaustMap</a> alih-alih concatMap.  Operator ini perlu mengabaikan semua pemberitahuan Observable eksternal sampai internal telah menyelesaikan pengamatannya ("dikompilasi").  Namun dalam kasus kami, jika selama permintaan akan ada antrian pemberitahuan baru, kami harus mengambil yang terakhir dan membuang sisanya.  exaustMap akan menghapus semuanya, termasuk yang terakhir.  Oleh karena itu, kami menyimpan pemberitahuan terakhir di BehaviorSubject, dan dalam berlangganan, jika permintaan yang diselesaikan saat ini berbeda dari yang terakhir, kami akan melemparkan permintaan terakhir ke dalam antrian lagi. <br><br>  Perlu juga diperhatikan untuk mengabaikan kesalahan selama permintaan, diimplementasikan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pernyataan catchError</a> .  Anda dapat menulis penanganan kesalahan yang lebih kompleks dengan pemberitahuan untuk pengguna bahwa terjadi kesalahan saat menyimpan.  Tetapi intinya adalah bahwa ketika kesalahan terjadi dalam aliran, aliran tidak boleh ditutup, seperti halnya dengan kesalahan dan pemberitahuan lengkap. <br><br><h3>  Kesimpulan </h3><br>  Tingkat perkembangan hari ini dari teknologi pemrograman reaktif menggunakan perpustakaan RxJS memungkinkan Anda untuk membuat aplikasi klien lengkap untuk sistem perbankan online tanpa biaya tenaga kerja tambahan untuk mengatur interaksi dengan antarmuka sistem perbankan jarak jauh yang sangat banyak dimuat. <br><br>  Kenalan pertama dengan RxJS dapat menakut-nakuti bahkan seorang pengembang berpengalaman yang dihadapkan dengan "seluk-beluk" perpustakaan yang menerapkan pola desain "Pengamat".  Tapi, mungkin mengatasi kesulitan ini, di masa depan, RxJS akan menjadi alat yang sangat diperlukan dalam menyelesaikan masalah pemrosesan asinkron aliran data heterogen secara real time. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425897/">https://habr.com/ru/post/id425897/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425883/index.html">Penuh waktu</a></li>
<li><a href="../id425887/index.html">Dan inilah generasi kesembilan Intel Core</a></li>
<li><a href="../id425889/index.html">Oktober Intisari Acara TI (Bagian Dua)</a></li>
<li><a href="../id425891/index.html">3D-bus - arsitektur sistem komputasi yang menjanjikan</a></li>
<li><a href="../id425893/index.html">"Flutter mulai menarik masyarakat, tetapi belum ke pelanggan": Wawancara dengan Paulina Szklarska</a></li>
<li><a href="../id425899/index.html">Bukit atau benteng semut? Saya sedang membangun rumah untuk harga sebuah apartemen. 1 bagian</a></li>
<li><a href="../id425901/index.html">Stasiun cuaca di Arduino dari A hingga Z. Bagian 1</a></li>
<li><a href="../id425903/index.html">Holiday datang kepada kami: SCRF menggandakan pita ISM 868 MHz</a></li>
<li><a href="../id425905/index.html">Cara menulis kode assembler dengan instruksi yang tumpang tindih (teknik lain untuk mengaburkan bytecode)</a></li>
<li><a href="../id425907/index.html">Kami sedang melakukan proyek pembelajaran mesin dengan Python. Bagian 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>