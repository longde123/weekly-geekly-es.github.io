<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙅🏻 💉 🦋 Tingkatkan kinerja SPA dengan memecah perpustakaan Angular Anda menjadi beberapa bagian 🙂 ✍🏿 👩🏽‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya mempersembahkan kepada Anda terjemahan artikel “Tingkatkan kinerja SPA dengan membagi perpustakaan Angular Anda menjadi beberapa bagi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tingkatkan kinerja SPA dengan memecah perpustakaan Angular Anda menjadi beberapa bagian</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482646/"><p>  <i>Halo, Habr!</i>  <i>Saya mempersembahkan kepada Anda terjemahan artikel <a href="https://medium.com/angular-in-depth/improve-spa-performance-by-splitting-your-angular-libraries-in-multiple-chunks-8c68103692d0">“Tingkatkan kinerja SPA dengan membagi perpustakaan Angular Anda menjadi beberapa bagian”</a> oleh <a href="https://medium.com/%40kevinkreuzer">Kevin Kreuzer</a> .</i> </p><br><p>  Sudut adalah kerangka kerja yang bagus.  Kita semua mencintainya &lt;3. </p><br><p>  Salah satu hal yang membuat Angular sukses dan cantik pada saat yang sama adalah komunitas luas dan nilai yang dibawanya.  Ada banyak pertemuan, blog, konferensi, dan, tentu saja, perpustakaan Angular. </p><br><p>  Berkat Angular CLI, perpustakaan mudah dibuat hari ini.  Mereka bagus untuk berbagi kode antara beberapa aplikasi. </p><br><p>  Karena mereka dapat digunakan di banyak tempat, kinerja adalah aspek penting.  Perpustakaan yang kinerjanya buruk dapat memperlambat banyak aplikasi! </p><br><p>  Frontend memiliki berbagai jenis kinerja.  runtime - kinerja dan beban awal.  Pada artikel ini, kami akan fokus pada pemuatan awal. </p><br><p>  Dengan menyediakan dan mendukung berbagai pustaka dan kerangka kerja antarmuka pengguna untuk perusahaan besar, saya menemukan beberapa jebakan yang tidak begitu jelas dan cara untuk memperbaikinya.  Saya pikir ada baiknya berbagi beberapa dari mereka. </p><a name="habracut"></a><br><h3 id="eto-takaya-prostaya-biblioteka-ona-ne-mozhet-povliyat-na-proizvoditelnost-verno">  "Ini perpustakaan yang sederhana. Itu tidak bisa memengaruhi kinerja, kan?" </h3><br><p>  Mari kita mulai dengan perpustakaan sederhana yang akan kita buat menggunakan Angular CLI.  Jika Anda belum pernah membuat perpustakaan Angular, mungkin bermanfaat bagi Anda untuk membaca artikel berikut: </p><br><p> <a href="https://medium.com/angular-in-depth/the-ultimate-guide-to-set-up-your-angular-library-project-399d95b63500%3F"><img src="https://habrastorage.org/getpro/habr/post_images/ea9/10e/e94/ea910ee94b4ae1fb97629d1992986f07.png" alt="gambar"></a> </p><br><p>  Segera setelah kami menggunakan CLI untuk mengkonfigurasi banyak ruang kerja proyek, kami dapat mulai menambahkan kode. </p><br><p>  Perpustakaan disebut <em>howdy</em> dan tujuan utamanya adalah untuk menyambut Anda dengan nama Anda atau memberi tahu Anda waktu setempat.  Ini berisi dua modul dengan masing-masing komponen.  Satu model menyambut, yang lain berbicara waktu. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1f4/e9d/462/1f4e9d4625a98a62e53a92a01d734011.png" alt="gambar"></p><br><p>  Hanya modul Angular dan Komponen biasa yang mengambil properti nama di atas bindings Input dan menampilkannya. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/54c/962/78a/54c96278a3e56081b10523c38ee9b5ca.png" alt="gambar"></p><br><p>  <em>HowdyTimeComponent</em> bertanggung jawab untuk menampilkan waktu menggunakan perpustakaan <em>momen</em> pihak ketiga. </p><br><p>  Hebat!  Perpustakaan <em>howdy</em> kami siap untuk dipublikasikan!  Ini adalah perpustakaan yang sederhana;  dia tidak akan dapat mempengaruhi kinerja, bukan? </p><br><h3 id="potreblenie-biblioteki-howdy">  Konsumsi perpustakaan Howdy </h3><br><p>  Sekarang kami memiliki perpustakaan <em>howdy</em> !  Sayang sekali tidak memanfaatkan ini.  Untuk menggunakan perpustakaan <em>howdy</em> , kami membuat SPA baru dengan Angular CLI. </p><br><pre><code class="javascript hljs">ng <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> greeting-app</code> </pre> <br><p>  Karena kami tertarik pada kinerja, mari kita juga menginstal dependensi dev yang disebut <em>webpack-bundle-analyzer</em> . </p><br><pre> <code class="javascript hljs">npm i -D webpack-bundle-analyzer</code> </pre> <br><p>  <em>Webpack-bundle-analyzer</em> memungkinkan Anda untuk memvisualisasikan ukuran file output webpack Anda menggunakan peta pohon interaktif yang dapat diskalakan. </p><br><p>  Cara terbaik untuk menganalisis paket kami adalah dengan menambahkan skrip analisis berikut ke <em>package.json</em> kami. </p><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"analyze"</span></span>: <span class="hljs-string"><span class="hljs-string">"ng build --prod --stats-json &amp;&amp; webpack-bundle-analyzer ./dist/greeting-app/stats-es2015.json"</span></span></code> </pre> <br><p>  Jika kita menjalankan perintah ini, Angular akan melakukan build produksi dan juga output <em>stats-es2015.json</em> , yang kemudian akan dipilih dan diberikan oleh <em>webpack-bundle-anlyzer</em> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2a2/fea/202/2a2fea202a8def6d1aba232ad3dafa1e.png" alt="gambar"></p><br><p>  Karena kami belum menulis kode apa pun, paket utama kami sebagian besar terdiri dari Angular.  Kita juga dapat melihat bahwa <em>zone.js</em> termasuk dalam paket <em>polyfill</em> kami. </p><br><p>  Secara umum, ukuran aplikasi kita sekarang <em>207 KB</em> . </p><br><p>  Tapi kami belum memasukkan perpustakaan Howdy kami!  Ayo maju dan lakukan itu. </p><br><pre> <code class="javascript hljs">npm i howdy</code> </pre> <br><p>  Kami memasang pustaka <em>howdy</em> karena kami ingin menjadi tuan rumah salam dengan nama.  Kami tidak tertarik dengan demonstrasi waktu.  Oleh karena itu, kami hanya akan menggunakan modul <em>HowdyNameModule</em> dan tidak akan menyertakan <em>HowdyTimeModule</em> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/377/046/8cf/3770468cf443e8bcdc4a34012f4807be.png" alt="gambar"></p><br><p>  <strong>Penting untuk dicatat di sini bahwa kami hanya mengimpor</strong> <em>HowdyNameModule</em> .  Mari kita jalankan skrip analisis analisis lagi. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f12/152/3d6/f121523d6ca2c14dcc8ec7c57ca77527.png" alt="gambar"></p><br><p>  Wow!  Sangat keren!  Kami beralih dari 207 KB ke 511,15 KB.  Ukurannya lebih dari dua kali lipat.  Apa ...! </p><br><p>  Satu lirikan saja sudah cukup untuk menemukan pelakunya.  <em>momen sangat</em> besar!  Ini membawa kode implementasi utama dan semua pengaturan regional. </p><br><p>  Tentu saja, <em>moment</em> dapat diganti dengan paket lain, seperti <em>date-fns</em> atau <em>moment-mini</em> .  Tetapi pertanyaannya berbeda;  Kenapa dia ada di sana?  Ingat bahwa kami hanya mengimpor <em>HowdyNameModule</em> , bukan <em>HodwyTimeModule</em> .  Saya pikir ketika <em>Tree shaking terjadi</em> , hanya modul yang tidak digunakan yang terlepas?  Apa yang sedang terjadi </p><br><h3 id="tree-shaking-mozhet-ubrat-ne-vse">  Pohon goyang mungkin tidak menghilangkan semuanya </h3><br><p>  Agar <em>Pohon bergetar</em> terjadi, bangunan Angular meluncurkan sekelompok optimisasi canggih.  Tapi tetap saja, <em>saat ini</em> hadir dalam kit, meskipun <em>HowdyTimeModule</em> tidak. <br>  Masalahnya adalah bagaimana momen itu dikemas.  Mari kita cepat melihat file <em>moment.js</em> di folder <em>node_modules</em> kami. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0b9/6e2/4c6/0b96e24c644878e7e722500fd719fea9.png" alt="gambar"></p><br><p>  Karena <em>momen</em> dapat digunakan di banyak tempat, seperti backend Node JS, aplikasi Angular, atau JavaScript biasa, ia dibundel dalam <em>UMD</em> dan bukan sebagai modul <em>ES</em> . </p><br><p>  Pustaka <em>UMD yang</em> tertaut dibungkus dalam fungsi IFFE, yang berarti bahwa <em>ModuleConcatenation</em> tidak dapat digunakan. Alat optimisasi perakitan tidak dapat <em>mengetahui</em> apakah kode ini akan digunakan atau jika memiliki efek samping. </p><br><p>  Singkatnya, modul jenis ini mencegah Angular meluncurkan kit optimisasi yang lebih canggih. </p><br><p>  Sayangnya, kami tidak dapat mengontrol bagaimana <em>momen itu</em> selesai.  Apakah ini berarti kita harus tahan dengan ukuran paket yang tipis? </p><br><h3 id="vtorichnye-tochki-vhoda-dlya-pobedy">  Titik masuk sekunder untuk kemenangan </h3><br><p>  Kami tidak dapat mengontrol bagaimana <em>momen</em> dibuat.  Tetapi kita dapat mengelola perpustakaan kita.  Memang, ada cara untuk mencegah skenario seperti itu.  Titik masuk sekunder! </p><br><p>  Hampir semua perpustakaan Angular saat ini dikemas menggunakan <em>ng-packagr</em> .  <em>ng-packagr</em> memungkinkan Anda untuk menggunakan <em>ng-package.json</em> dalam kombinasi dengan <em>public-api</em> , yang pada akhirnya akan menjadi titik masuk ke aplikasi Anda. </p><br><p>  Sesuai namanya, titik masuk tambahan memungkinkan Anda menentukan beberapa titik masuk untuk aplikasi Anda. </p><br><p>  Kedengarannya bagus!  Bagaimana cara mengaktifkan titik masuk sekunder? </p><br><p>  Titik masuk sekunder terdeteksi secara dinamis menggunakan <em>ng-packagr</em> .  <em>ng-packagr</em> mencari file <em>package.json</em> di subdirektori dari folder utama file <em>package.json</em> </p><br><p>  Keren!  Mari manfaatkan titik masuk sekunder di pustaka <em>howdy</em> kami dengan menambahkan file berikut. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e6d/7b1/64a/e6d7b164afbe291983055aea26a808bc.png" alt="gambar"></p><br><p>  Untuk setiap modul, kami menambahkan <em>index.ts</em> , <em>package.json</em> dan <em>public_api.ts</em> . </p><br><ul><li>  <em>index.ts</em> ada di sana, hanya untuk menunjuk ke <em>public_api</em> , yang berguna selama impor. </li><li>  <em>public_api</em> mengekspor semua modul dan komponen dari modul kami. </li><li>  <em>package.json</em> berisi <em>konfigurasi ng-packagr tertentu</em> .  Dalam kasus kami, ini cukup untuk menentukan <em>entryFile</em> . </li></ul><br><blockquote>  <em>Package.json</em> juga dapat berisi properti lain, seperti <em>cssUrl</em> , dll. Perhatikan bahwa ruang lingkup properti ini hanya sub-item saat ini. </blockquote><p>  Jika kita menjalankan perakitan sekarang, kita mendapatkan tiga blok.  <em>howdy.js</em> , <em>howdy-src-lib-name.js</em> dan <em>howdy-src-lib-time.js</em> . </p><br><p>  <em>Howdy-src-lib-name.js</em> sekarang hanya berisi kode yang terkait dengan <em>HowdyNameModule</em> , dan <em>howdy-src-lib-time.js</em> sekarang hanya berisi kode khusus untuk <em>HowdyTimeModule</em> . </p><br><p>  Tapi mari kita lihat sepotong <em>howdy.js</em> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e41/e81/9b1/e41e819b1fa5c3ea4cb7d6f897aa4b65.png" alt="gambar"></p><br><p>  Bagian <em>howdy.js</em> masih mengandung <em>HowdyNameComponent</em> dan <em>HowdyTimeComponent</em> .  Ini berarti bahwa kami masih mendapatkan <em>momen,</em> bahkan jika kami hanya mengimpor <em>HowdyNameModule</em> . </p><br><blockquote>  Jika kita ingin menyingkirkan <em>HowdyTimeModule</em> dengan pendekatan ini, kita perlu menggunakan impor mendalam.  Jadi kami mengimpor bukan dari <em>howdy.js</em> , tetapi langsung dari <em>howdy-src-lib-time.js</em> <br>  <strong>Apa yang tidak direkomendasikan!</strong>  <strong>Impor dalam sangat berbahaya dan harus selalu dihindari!</strong> </blockquote><p>  Bagaimana kita bisa menyelesaikan masalah ini?  Bagaimana kami dapat menjamin bahwa <em>HowdyTimeModule</em> juga akan dihapus bahkan jika kami menggunakan impor standar?  Nah, kita perlu mengatur cara untuk membuat sepotong <em>howdy.js</em> . </p><br><h3 id="ispolzuyte-signpost">  Gunakan "plang" </h3><br><p>  Idenya adalah untuk menghapus kode dari blok <em>howdy.js</em> dan sebagai gantinya memungkinkannya untuk bertindak sebagai semacam "penunjuk arah" "pointer" yang mengarahkan Anda ke blok lain. </p><br><p>  Jadi mari kita lihat lebih dekat <em>src / public_api.ts</em> . </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Public API Surface of howdy */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./lib/name/howdy-name.component'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./lib/name/howdy-name.module'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./lib/time/howdy-time.component'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./lib/time/howdy-time.module'</span></span>;</code> </pre> <br><p>  Baris-baris ini bertanggung jawab untuk memasukkan semuanya dari <em>nama</em> dan <em>waktu</em> di blok <em>howdy.js</em> .  Kita perlu menghapus kode dari <em>howdydy.js</em> dan membiarkannya menunjuk ke fragmen lain yang berisi implementasi.  Mari kita ubah isinya. </p><br><pre> <code class="javascript hljs">/ * Public API Surface <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> howdy *<span class="hljs-regexp"><span class="hljs-regexp">/ export * from 'howdy/</span></span>src/lib/name<span class="hljs-string"><span class="hljs-string">'; export * from '</span></span>howdy/src/lib/time<span class="hljs-string"><span class="hljs-string">';</span></span></code> </pre> <br><p>  Alih-alih mengekspor implementasi yang sebenarnya, kami menunjukkan jalur relatif ke berbagai bagian.  Dengan perubahan ini, <em>howdy.js</em> hanya menunjuk ke paket lain dan tidak mengandung kode "nyata". <br>  Ayo jalankan <em>ng build</em> dan analisis folder <em>dist</em> kami. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/7fa/cdd/771/7facdd77175baa79d8f7200b0ec7a224.png" alt="gambar"></p><br><p>  <em>Howdy.js</em> sekarang bertindak sebagai "penunjuk arah" "penunjuk" yang menunjuk ke fragmen yang berisi implementasi.  Blok howdy-src-lib-name.js hanya berisi kode dari folder <em>nama</em> , dan file <em>howdy-src-lib-time.js</em> hanya berisi kode dari folder <em>waktu</em> . </p><br><h3 id="zavershit-paket-s-podstatyami">  Lengkapi paket dengan pengganti </h3><br><p>  Mari kita perbarui paket <em>howdy</em> dalam aplikasi selamat datang kami dan jalankan kembali skrip analisis. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/975/fdf/a2f/975fdfa2fb79a01af0bf5937af75bc60.png" alt="gambar"></p><br><p>  Keren  Ukuran paket sekarang <em>170,94 KB</em> .  Sedikit lebih tinggi dari aslinya.  Mari kita lihat bagaimana modul <em>Howdy</em> terlihat di bundel terakhir. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f6d/7e5/e86/f6d7e5e860609add4fddc0b13640d5a5.png" alt="gambar"></p><br><p>  Hebat!  Penyesuaian ini memungkinkan kami untuk menjaga ukuran paket yang memakan SPA kecil.  SPA hanya mendapatkan apa yang mereka butuhkan! </p><br><blockquote>  Titik masuk sekunder sangat baik bila Anda menggunakannya bersamaan dengan pemuatan malas.  Jika kita menggunakan <em>HowdyTimeModule</em> dalam modul yang malas, <em>momen</em> akan <em>berakhir</em> menjadi bagian malas, dan tidak pada dasarnya. </blockquote><br><h3 id="realnyy-opyt">  Pengalaman nyata </h3><br><p>  Contoh di atas sangat sederhana. </p><br><p>  Namun, setelah pengenalan titik masuk sekunder ke proyek perusahaan yang ada, semuanya akan berbeda.  Anda harus berurusan dengan kompleksitas yang jauh lebih besar, sementara pesan kesalahan dari <em>ng-packagr</em> tidak selalu berguna. </p><br><p>  Kemungkinan besar, Anda perlu mengkonfigurasi beberapa jalur impor atau menentukan beberapa jalur di file <em>tsconfig.json</em> Anda.  Dan Anda juga akan menemukan modul dari satu blok yang menggunakan modul dari blok lain. </p><br><p>  Tapi percayalah, begitu Anda mengelola beban ini, itu sepadan. </p><br><p>  Dalam lingkungan perusahaan yang luas, kami menemukan bahwa ukuran paket SPA yang baru dibuat meledak setelah kami memasukkan beberapa perpustakaan yang kami sediakan. </p><br><p>  Pada titik tertentu, bahkan mencapai <em>5 MB</em> .  Setiap SPA menerima <em>momen</em> , <em>@swimlane / datatable,</em> dan hal-hal lain yang bahkan tidak ia gunakan.  Kami mulai fokus untuk mengoptimalkan ukuran paket ini. </p><br><p>  Kami menghapus <em>momen</em> dari <em>date-fns</em> dan mulai menggunakan titik masuk sekunder.  Saat ini, kami telah menerima unit utama 662KB untuk SPA yang baru dibuat, yang mencakup beberapa perpustakaan.  Ini masih banyak, tetapi kita belum selesai.  Optimalisasi belum selesai - kami dapat mengurangi ukuran paket lebih jauh. </p><br><p>  Sangat keren melihat di mana kita berada dan dari mana kita berasal. </p><br><p>  Namun, terlepas dari kenyataan bahwa dalam contoh di atas cukup mudah untuk menggunakan titik masuk tambahan, itu bisa sangat sulit untuk membayangkan mereka dalam proyek yang lebih signifikan. </p><br><h3 id="zaklyuchenie">  Kesimpulan </h3><br><p>  Angular melakukan pekerjaan yang baik dalam hal mengoptimalkan ukuran paket.  Meskipun langkah-langkah perakitan untuk optimasi sangat kompleks, mereka tidak dapat mengguncang pohon bergetar. </p><br><p>  Modul yang dikemas dalam format selain <em>ESModules</em> tidak dapat <em>diguncang</em> pohon. </p><br><p>  Oleh karena itu, sebagai pencipta perpustakaan, kita harus hati-hati memantau dampak perpustakaan kita pada ukuran paket ketika kita memasukkan perpustakaan pihak ketiga. <br>  Kami tidak dapat mengontrol pengemasan perpustakaan pihak ketiga.  Tapi kami memiliki kontrol yang sangat baik atas pengemasan perpustakaan kami. </p><br><p>  Sub-bagian menawarkan kepada kami cara yang bagus untuk mengirimkan perpustakaan kami di beberapa bagian.  Potongan-potongan ini dapat dikocok (pohon goyang) selama optimalisasi perakitan Angulars.  Dengan pendekatan ini, bahkan pustaka pihak ketiga yang dikemas secara salah dimasukkan dalam paket akhir hanya jika digunakan. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id482646/">https://habr.com/ru/post/id482646/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id482628/index.html">Tonton "Laba-laba Kecil Hijau"</a></li>
<li><a href="../id482634/index.html">Tetapi esensinya adalah sesuatu, atau Meminimalkan kode sumber lebih mudah daripada kedengarannya.</a></li>
<li><a href="../id482636/index.html">Pengalaman dalam masuk ke magistrasi di Jerman (analisis rinci)</a></li>
<li><a href="../id482642/index.html">OSCD: Sprint Detection Ancaman # 1, hasil</a></li>
<li><a href="../id482644/index.html">Keylogger untuk Windows dengan perubahan hak di DACL</a></li>
<li><a href="../id482648/index.html">Arthur Khachuyan: "Data Besar Nyata dalam periklanan"</a></li>
<li><a href="../id482650/index.html">Menghubungkan Sistem IP-DECT Yealink W80B Mikro-Seluler ke 3CX</a></li>
<li><a href="../id482652/index.html">Mempetisi ke pemula untuk mempelajari Ilmu Data</a></li>
<li><a href="../id482656/index.html">Jet sayap Yves Rossi: lepas landas dan mendarat vertikal otonom</a></li>
<li><a href="../id482664/index.html">Tampak teknologi dekade terakhir</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>