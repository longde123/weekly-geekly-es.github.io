<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✳️ 👨‍💻 🎮 PVS-Studio访问Apache Hive 💮 🔝 ♣️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在过去的十年中，开源运动一直是IT行业发展的关键因素之一，也是其中的重要组成部分。 定量指标的增长不仅增强了开源的作用和地位，而且其定性在整个IT市场中的定位也发生了变化。 不用袖手旁观，PVS-Studio的勇敢团队会积极地巩固开源项目的位置，在厚厚的代码库中发现隐藏的错误，并为这些项目提供免费许...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PVS-Studio访问Apache Hive</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/463759/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ad/2d0/eb3/0ad2d0eb30d726eefba9c913edaa346a.png" alt="图1"></div><br> 在过去的十年中，开源运动一直是IT行业发展的关键因素之一，也是其中的重要组成部分。 定量指标的增长不仅增强了开源的作用和地位，而且其定性在整个IT市场中的定位也发生了变化。 不用袖手旁观，PVS-Studio的勇敢团队会积极地巩固开源项目的位置，在厚厚的代码库中发现隐藏的错误，并为这些项目提供免费许可证。 本文也不例外！ 今天我们将讨论Apache Hive！ 报告已收到-值得一看！ <br><a name="habracut"></a><br><h2> 关于PVS-Studio </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PVS-Studio</a>静态代码分析器在IT市场中已经存在了10多年，它是一种多功能且易于实施的软件解决方案。 目前，分析仪支持C，C ++，C＃，Java语言，并且可以在Windows，Linux和macOS平台上运行。 <br><br>  PVS-Studio是一种付费的B2B解决方案，已被各公司的众多团队使用。 如果要查看分析仪的功能，请下载分发套件并<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>索取试用密钥。 <br><br> 如果您是开源怪胎，或者例如您是学生，则可以使用PVS-Studio的免费许可<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">选项之一</a> 。 <br><br><h2> 关于Apache Hive </h2><br> 近年来，数据量正在高速增长。 标准数据库再也无法以这样的速度保持可操作性，而信息量的增长正是术语“大数据”及其相关事物的出现（处理，存储以及随之而来的大量数据）。 <br><br> 当前， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Apache Hadoop</a>被认为是大数据的基本技术之一。 该技术的主要目标是存储，处理和管理大量数据。 该框架的主要组件是Hadoop Common， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">HDFS</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Hadoop MapReduce</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Hadoop YARN</a> 。 随着时间的流逝，围绕Hadoop形成了一个完整的相关项目和技术生态系统，其中许多项目最初是作为项目的一部分开发的，后来成为独立的。 这些项目之一是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Apache Hive</a> 。 <br><br>  Apache Hive是一个分布式数据仓库。 它管理存储在HDFS中的数据，并提供基于SQL的查询语言（HiveQL）来处理这些数据。 要详细了解此项目，可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>学习信息。 <br><br><h2> 关于分析 </h2><br> 分析步骤的顺序非常简单，不需要很多时间： <br><br><ul><li> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub上</a>获得Apache Hive; </li><li> 我按照<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">说明</a>启动了Java分析器并开始了分析。 </li><li> 我收到了分析器报告，对其进行了分析并重点介绍了一些有趣的案例。 </li></ul><br> 分析结果：对6500多个文件发出了1456个高和中置信度警告（分别为602和854）。 <br><br> 并非所有警告都是错误。 这是正常情况，在定期使用分析仪之前，需要对其进行配置。 然后，我们可以预期误报的百分比会非常低（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">例如</a> ）。 <br><br> 在警告中，未考虑每个测试文件的407警告（177高和230中）。 没有考虑诊断规则<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6022</a> （很难用不熟悉的代码将错误的情况与正确的情况分开），该规则有多达482个警告。 也未考虑带有179个警告的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6021</a> 。 <br><br> 最后，尽管如此，仍然有足够数量的警告。 而且由于我没有配置分析仪，因此其中还有一些误报。 在文章中描述大量警告是没有意义的：）。 考虑一下引起我注意并看起来很有趣的东西。 <br><br><h2> 预定条件 </h2><br> 诊断规则<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6007</a>是所有其余分析器警告中的记录保存者。 刚刚超过200条警告！ 有些，例如无害，有些是可疑的，而有些则完全是真正的错误！ 让我们看看其中的一些。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6007</a>表达式'key.startsWith（“ hplsql。”）'始终为true。 执行Java（675） <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initOptions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key == null || value == null || !key.startsWith(<span class="hljs-string"><span class="hljs-string">"hplsql."</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= continue; } else if (key.compareToIgnoreCase(Conf.CONN_DEFAULT) == 0) { .... } else if (key.startsWith("hplsql.conn.init.")) { .... } else if (key.startsWith(Conf.CONN_CONVERT)) { .... } else if (key.startsWith("hplsql.conn.")) { .... } else if (key.startsWith("hplsql.")) { // &lt;= .... } }</span></span></code> </pre> <br> 一个相当长的if-else-if构造！ 分析器最后发誓<i>if（key.startsWith（“ hplsql。”））</i> ，如果程序到达此代码段，则表明其真相。 确实，如果您查看if-else-if构造的最开始，则检查已经完成。 并且如果我们的行不是以子字符串<i>“ hplsql”开头。</i>  ，那么代码的执行立即跳到了下一个迭代。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6007</a>表达式'columnNameProperty.length（）== 0'始终为false。  OrcRecordUpdater.java（238） <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TypeDescription </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTypeDescriptionFromTableProperties</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tableProperties != null) { final String columnNameProperty = ....; final String columnTypeProperty = ....; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !Strings.isNullOrEmpty(columnNameProperty) &amp;&amp; !Strings.isNullOrEmpty(columnTypeProperty)) { List&lt;String&gt; columnNames = columnNameProperty.length() == <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;String&gt;() : ....; List&lt;TypeInfo&gt; columnTypes = columnTypeProperty.length() == <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;TypeInfo&gt;() : ....; .... } } } .... }</code> </pre> <br> 将<i>columnNameProperty的</i>字符串长度与零进行比较将始终返回<i>false</i> 。 这是因为我们的比较正在测试中<i>！Strings.isNullOrEmpty（columnNameProperty）</i> 。 如果程序的状态达到了我们所讨论的条件，则<i>columnNameProperty</i>行将保证为非零且不为空。 <br><br> 对于<i>columnTypeProperty</i>行也是如此。 以下警告线： <br><br><ul><li>  V6007表达式'columnTypeProperty.length（）== 0'始终为false。  OrcRecordUpdater.java（239） </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6007</a>表达式'colOrScalar1.equals（“ Column”）'始终为false。  GenVectorCode.java（3469） <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateDateTimeArithmeticIntervalYearMonth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] tdesc)</span></span></span><span class="hljs-function"> throws Exception </span></span>{ .... String colOrScalar1 = tdesc[<span class="hljs-number"><span class="hljs-number">4</span></span>]; .... String colOrScalar2 = tdesc[<span class="hljs-number"><span class="hljs-number">6</span></span>]; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colOrScalar1.equals(<span class="hljs-string"><span class="hljs-string">"Col"</span></span>) &amp;&amp; colOrScalar1.equals(<span class="hljs-string"><span class="hljs-string">"Column"</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { .... } else if (colOrScalar1.equals("Col") &amp;&amp; colOrScalar1.equals("Scalar")) { .... } else if (colOrScalar1.equals("Scalar") &amp;&amp; colOrScalar1.equals("Column")) { .... }</span></span></code> </pre> <br>  } <br><br> 这是一个琐碎的复制粘贴。 原来， <i>colOrScalar1</i>行应同时等于不同的值，这是不可能的。 显然，应在左侧检查变量<i>colOrScalar1</i> ，在<i>右侧</i>检查<i>colOrScalar2</i> 。 <br><br> 以下各行中的更多类似警告： <br><br><ul><li>  V6007表达式'colOrScalar1.equals（“ Scalar”）'始终为false。  GenVectorCode.java（3475） </li><li>  V6007表达式'colOrScalar1.equals（“ Column”）'始终为false。  GenVectorCode.java（3486） </li></ul><br> 结果，if-else-if构造中的任何操作都不会执行。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6007的</a>其他一些警告： <br><br><ul><li>  V6007表达式'characters == null'始终为false。  RandomTypeUtil.java（43） </li><li>  V6007表达式'writeIdHwm&gt; 0'始终为false。  TxnHandler.java（1603） </li><li>  V6007表达式'fields.equals（“ *”）'始终为true。  Server.java（983） </li><li>  V6007表达式“ currentGroups！= Null”始终为true。  GenericUDFCurrentGroups.java（90） </li><li>  V6007表达式'this.wh == null'始终为false。 新的返回非空引用。  StorageBasedAuthorizationProvider.java（93），StorageBasedAuthorizationProvider.java（92） </li><li> 等等... </li></ul><br><h2>  NPE </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6008</a>可能会取消引用“ dagLock”。  QueryTracker.java（557），QueryTracker.java（553） <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleFragmentCompleteExternalQuery</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QueryInfo queryInfo)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (queryInfo.isExternalQuery()) { ReadWriteLock dagLock = getDagLock(queryInfo.getQueryIdentifier()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dagLock == null) { LOG.warn(<span class="hljs-string"><span class="hljs-string">"Ignoring fragment completion for unknown query: {}"</span></span>, queryInfo.getQueryIdentifier()); } boolean locked = dagLock.writeLock().tryLock(); ..... } }</code> </pre> <br> 抓住了零目标，保证并继续工作。 这导致以下事实：在检查对象后，将发生零对象取消引用的情况。 悲伤！ <br><br> 如果引用为空，则很可能应该立即退出该函数或引发一些特殊异常。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6008</a>函数“ unlockSingleBuffer”中对“ buffer”的空引用。  MetadataCache.java（410），MetadataCache.java（465） <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lockBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LlapBufferOrBuffers buffers, ....)</span></span></span><span class="hljs-function"> </span></span>{ LlapAllocatorBuffer buffer = buffers.getSingleLlapBuffer(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer != null) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= return lockOneBuffer(buffer, doNotifyPolicy); } LlapAllocatorBuffer[] bufferArray = buffers.getMultipleLlapBuffers(); for (int i = 0; i &lt; bufferArray.length; ++i) { if (lockOneBuffer(bufferArray[i], doNotifyPolicy)) continue; for (int j = 0; j &lt; i; ++j) { unlockSingleBuffer(buffer, true); // &lt;= } .... } .... } .... private void unlockSingleBuffer(LlapAllocatorBuffer buffer, ....) { boolean isLastDecref = (buffer.decRef() == 0); // &lt;= if (isLastDecref) { .... } }</span></span></code> </pre> <br> 再次是潜在的NPE。 如果程序到达<i>unlockSingleBuffer</i>方法，则<i>缓冲区</i>对象将为零。 假设发生了！ 让我们看一下<i>unlockSingleBuffer</i>方法，并在第一行中立即看到我们的对象已被取消引用。 我们到了！ <br><br><h2> 没有跟随转变 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6034</a>按“ bitShiftsInWord-1”的值进行移位可能与以下类型的大小不一致：“ bitShiftsInWord-1” = [-1 ... 30]。  UnsignedInt128.java（1791） <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shiftRightDestructive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wordShifts, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bitShiftsInWord, boolean roundUp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wordShifts == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; bitShiftsInWord == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } assert (wordShifts &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>); assert (bitShiftsInWord &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>); assert (bitShiftsInWord &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wordShifts &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>) { zeroClear(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } final <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> shiftRestore = <span class="hljs-number"><span class="hljs-number">32</span></span> - bitShiftsInWord; <span class="hljs-comment"><span class="hljs-comment">// check this because "123 &lt;&lt; 32" will be 123. final boolean noRestore = bitShiftsInWord == 0; final int roundCarryNoRestoreMask = 1 &lt;&lt; 31; final int roundCarryMask = (1 &lt;&lt; (bitShiftsInWord - 1)); // &lt;= .... }</span></span></code> </pre> <br> 可能的偏移量为-1。 例如，如果<i>wordShifts == 3</i>和<i>bitShiftsInWord == 0</i>进入相关方法的输入，则在指定的行中将出现1 &lt;&lt; -1。 这有计划吗？ <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6034</a>移位'j'的值可能与类型的大小不一致：'j'= [0 ... 63]。  IoTrace.java（272） <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logSargResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> stripeIx, boolean[] rgsToRead)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, valOffset = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; elements; ++i, valOffset += <span class="hljs-number"><span class="hljs-number">64</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> val = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">64</span></span>; ++j) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ix = valOffset + j; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rgsToRead.length == ix) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!rgsToRead[ix]) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; val = val | (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; j); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } .... } .... }</span></span></code> </pre> <br> 在指定的行中，变量<i>j</i>可以采用[0 ... 63]范围内的值。 因此，循环中<i>val</i>值的计算可能不会像开发人员预期的那样发生。 在表达式<i>（1 &lt;&lt; j）中，该</i>单位的类型为<i>int</i> ，并且将其从32或更大范围移开，我们超出了允许范围。 要纠正这种情况，您必须写出<i>（（long）1 &lt;&lt; j）</i> 。 <br><br><h2> 热衷于伐木 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6046</a>格式错误。 预计会有不同数量的格式项。 未使用的参数：1、2。StatsSources.java（89） <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ImmutableList&lt;PersistedRuntimeStats&gt; extractStatsFromPlanMapper (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stat.size() &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> || sig.size() &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { StringBuffer sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuffer(); sb.append(String.format( <span class="hljs-string"><span class="hljs-string">"expected(stat-sig) 1-1, got {}-{} ;"</span></span>, <span class="hljs-comment"><span class="hljs-comment">// &lt;= stat.size(), sig.size() )); .... } .... if (e.getAll(OperatorStats.IncorrectRuntimeStatsMarker.class).size() &gt; 0) { LOG.debug( "Ignoring {}, marked with OperatorStats.IncorrectRuntimeStatsMarker", sig.get(0) ); continue; } .... }</span></span></code> </pre> <br> 通过<i>String.format（）</i>格式化字符串时<i>，</i>开发人员混淆了语法。 底线：传递的参数未进入结果字符串。 我可以假设开发人员在上一个任务中是从日志借用语法的地方开始进行日志记录的。 <br><br><h2> 偷了例外 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6051</a>在“ finally”块中使用“ return”语句可能会导致丢失未处理的异常。  ObjectStore.java（9080） <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;MPartitionColumnStatistics&gt; getMPartitionColumnStatistics(....) throws NoSuchObjectException, MetaException { boolean committed = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... <span class="hljs-comment"><span class="hljs-comment">/*some actions*/</span></span> committed = commitTransaction(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { LOG.error(<span class="hljs-string"><span class="hljs-string">"Error retrieving statistics via jdo"</span></span>, ex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ex instanceof MetaException) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> (MetaException) ex; } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MetaException(ex.getMessage()); } finally { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!committed) { rollbackTransaction(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Lists.newArrayList(); } } }</code> </pre> <br> 从finally块返回一些东西是很不好的做法，在这个示例中，我们将看到这一点。 <br><br> 在<i>try</i>块中，形成请求并访问存储。  <i>提交的</i>变量默认为<i>false，</i>并且仅在<i>try</i>块中所有成功完成的操作之后才更改其状态。 这意味着，如果发生异常，我们的变量将始终为<i>false</i> 。  <i>捕获</i>块捕获到异常，对其进行了更正并进一步抛出。 并且，当到了<i>finally</i>块的时间到了<i>，</i>执行将进入一个条件，我们从该条件向外返回空列表。 此退货给我们带来了什么费用？ 但是值得一提的是，所有捕获的异常都不会以适当的方式抛出和处理。 方法签名中指示的所有那些异常将永远不会被扔掉，而只会令人困惑。 <br><br> 类似的警告： <br><br><ul><li>  V6051在“ finally”块中使用“ return”语句可能会导致丢失未处理的异常。  ObjectStore.java（808） </li></ul><br><h2>  ...其他 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6009</a>函数'compareTo'收到一个奇数参数。 对象'o2.getWorkerIdentity（）'用作其自身方法的参数。  LlapFixedRegistryImpl.java（244） <br><br><pre> <code class="cpp hljs">@Override <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;LlapServiceInstance&gt; getAllInstancesOrdered(....) { .... Collections.sort(<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Comparator&lt;LlapServiceInstance&gt;() { @Override <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> compare(LlapServiceInstance o1, LlapServiceInstance o2) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o2.getWorkerIdentity().compareTo(o2.getWorkerIdentity()); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } }); .... }</span></span></code> </pre> <br> 复制粘贴，粗心，仓促和许多其他原因导致此愚蠢的错误。 在检查开源项目时，这种错误非常普遍。 甚至有整篇<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a> 。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6020</a>除以零。  “除数”分母值的范围包括零。  SqlMathUtil.java（265） <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divideUnsignedLong</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dividend, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> divisor)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (divisor &lt; <span class="hljs-number"><span class="hljs-number">0L</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*some comments*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (compareUnsignedLong(dividend, divisor)) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">0L</span></span> : <span class="hljs-number"><span class="hljs-number">1L</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dividend &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Both inputs non-negative return dividend / divisor; // &lt;= } else { .... } }</span></span></code> </pre> <br> 这里的一切都很简单。 多项检查并未警告不要除以0。 <br><br> 更多警告： <br><br><ul><li>  V6020 Mod归零。  “除数”分母值的范围包括零。  SqlMathUtil.java（309） </li><li>  V6020除以零。  “除数”分母值的范围包括零。  SqlMathUtil.java（276） </li><li>  V6020除以零。  “除数”分母值的范围包括零。  SqlMathUtil.java（312） </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6030</a>该方法位于“ |”右侧 无论左操作数的值如何，都会调用操作符。 也许最好使用“ ||”。  OperatorUtils.java（573） <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Operator&lt;? extends OperatorDesc&gt; findSourceRS(....) { .... List&lt;Operator&lt;? extends OperatorDesc&gt;&gt; parents = ....; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parents == null | parents.isEmpty()) { <span class="hljs-comment"><span class="hljs-comment">// reached end eg TS operator return null; } .... }</span></span></code> </pre> <br> 代替逻辑运算符|| 写了一个按位运算符|。 这意味着无论左侧结果如何，都将执行右侧。 在<i>父母== null</i>的情况下，这样的错字将立即导致下一个逻辑子表达式中的NPE。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6042</a>已检查表达式是否与类型'A'兼容，但将其<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">强制转换</a>为类型'B'。  VectorColumnAssignFactory.java（347） <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> VectorColumnAssign </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildObjectAssign</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VectorizedRowBatch outputBatch, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> outColIndex, PrimitiveCategory category)</span></span></span><span class="hljs-function"> throws HiveException </span></span>{ VectorColumnAssign outVCA = null; ColumnVector destCol = outputBatch.cols[outColIndex]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (destCol == null) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (destCol instanceof LongColumnVector) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(category) { .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> LONG: outVCA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VectorLongColumnAssign() { .... } .init(.... , (LongColumnVector) destCol); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TIMESTAMP: outVCA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VectorTimestampColumnAssign() { .... }.init(...., (TimestampColumnVector) destCol); <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; case DATE: outVCA = new VectorLongColumnAssign() { .... } .init(...., (LongColumnVector) destCol); break; case INTERVAL_YEAR_MONTH: outVCA = new VectorLongColumnAssign() { .... }.init(...., (LongColumnVector) destCol); break; case INTERVAL_DAY_TIME: outVCA = new VectorIntervalDayTimeColumnAssign() { .... }.init(...., (IntervalDayTimeColumnVector) destCol);// &lt;= break; default: throw new HiveException(....); } } else if (destCol instanceof DoubleColumnVector) { .... } .... else { throw new HiveException(....); } return outVCA; }</span></span></code> </pre> <br> 有<i>问题</i>的类<i>是LongColumnVector扩展ColumnVector</i>和<i>TimestampColumnVector扩展ColumnVector</i> 。 检查我们的<i>destCol</i>对象是否具有<i>LongColumnVector</i>所有权可以清楚地告诉我们，此类的对象将在条件语句中。 尽管如此，我们还是强制转换为<i>TimestampColumnVector</i> ！ 如您所见，这些类是不同的，不包括它们的公共父类。 结果是<i>ClassCastException</i> 。 <br><br> 关于将类型转换为<i>IntervalDayTimeColumnVector的说明</i>可以全部相同： <br><br><ul><li>  V6042已检查表达式是否与类型'A'兼容，但将其强制转换为类型'B'。  VectorColumnAssignFactory.java（390） </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V6060</a>在对null进行验证之前，已使用'var'参考。  Var.java（402），Var.java（395） <br><br><pre> <code class="cpp hljs">@<span class="hljs-function"><span class="hljs-function">Override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getClass() != obj.getClass()) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= return false; } Var var = (Var)obj; if (this == var) { return true; } else if (var == null || // &lt;= var.value == null || this.value == null) { return false; } .... }</span></span></code> </pre> <br> 解引用后，将<i>var</i>对象与<i>null</i>进行了奇怪的比较。 在这种情况下， <i>var</i>和<i>obj</i>是同一个对象（ <i>var =（Var）obj</i> ）。 检查<i>null</i>意味着可能会出现null对象。 在<i>equals（null）</i>的情况下<i>，</i>我们立即获得第一行NPE而不是预期的<i>false</i> 。  las，有支票，但没有。 <br><br> 在检查发生之前，使用该对象的类似可疑时刻： <br><br><ul><li>  V6060在验证是否为空之前，已使用“值”参考。  ParquetRecordReaderWrapper.java（168），ParquetRecordReaderWrapper.java（166） </li><li>  V6060在对null进行验证之前，已使用'defaultConstraintCols'引用。  HiveMetaStore.java（2539），HiveMetaStore.java（2530） </li><li>  V6060在对null进行验证之前，已使用'projIndxLst'引用。  RelOptHiveTable.java（683），RelOptHiveTable.java（682） </li><li>  V6060在对null进行验证之前使用了“ oldp”参考。  ObjectStore.java（4343），ObjectStore.java（4339） </li><li> 等等... </li></ul><br><h2> 结论 </h2><br> 任何对大数据感兴趣的人都不会错过Apache Hive的意义。 该项目非常受欢迎，而且规模很大，其组成中有6500多个源代码文件（* .java）。 该代码已经由许多开发人员编写了很多年，因此，静态分析器可以找到一些东西。 这再次证实了静态分析在大中型项目的开发中非常重要和有用！ <br><br> 注意事项 这样的一次性检查演示了静态代码分析器的功能，但是使用它是完全错误的方式。 这个想法在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>都有更详细的介绍。 定期使用分析！ <br><br> 检查蜂巢时，检测到足够数量的缺陷和可疑时刻。 如果本文引起了Apache Hive开发团队的注意，我们将很高兴为这项艰巨的任务做出贡献。 <br><br> 无法想象没有Apache Hadoop的Apache Hive，因此PVS-Studio的独角兽也可能会出现在那。 但这就是今天的全部，但现在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">下载</a>分析器并检查您自己的项目。 <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png" align="left"></a> </p><br><br> 如果您想与讲英语的人分享这篇文章，请使用以下链接：Maxim Stefanov。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PVS-Studio访问Apache Hive</a> 。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN463759/">https://habr.com/ru/post/zh-CN463759/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN463747/index.html">访问Jsonb字段内的Npgsql属性</a></li>
<li><a href="../zh-CN463749/index.html">Scrum vs看板：保持冷静并选择更适合自己的</a></li>
<li><a href="../zh-CN463751/index.html">iOS 13：在开发新操作系统时需要做的事情和绝对不需要做的事情</a></li>
<li><a href="../zh-CN463753/index.html">PVS-Studio访问Apache Hive</a></li>
<li><a href="../zh-CN463755/index.html">“ June”，“ Middle”和“ Senior”之间的区别。 而该怎么做才能上一个台阶</a></li>
<li><a href="../zh-CN463761/index.html">PHP微服务框架-Swoft</a></li>
<li><a href="../zh-CN463763/index.html">简化从OpenShift 3到OpenShift 4的迁移</a></li>
<li><a href="../zh-CN463765/index.html">Slurm DevOps：为什么我们不讨论DevOps的原理以及将会发生什么</a></li>
<li><a href="../zh-CN463769/index.html">Mitap Netologii“数据科学职业：从初学者到中级”</a></li>
<li><a href="../zh-CN463771/index.html">[Peter]与Sebastian Dashner会面JUG.ru-使编写企业测试更加愉快</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>