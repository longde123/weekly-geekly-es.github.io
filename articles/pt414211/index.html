<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì∂ üòò üê∫ Desenvolvimento de um servidor TELNET baseado em W5500 e ATMEGA8 üì≠ üå∫ üöÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recentemente, o complexo de software e hardware do Arduino se tornou muito popular, projetado para desenvolver v√°rios projetos eletr√¥nicos interessant...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desenvolvimento de um servidor TELNET baseado em W5500 e ATMEGA8</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414211/">  Recentemente, o complexo de software e hardware do Arduino se tornou muito popular, projetado para desenvolver v√°rios projetos eletr√¥nicos interessantes.  Os projetos s√£o feitos ao conectar o rodap√© do Arduino com os m√≥dulos adicionais necess√°rios.  No rodap√© do Arduino, h√° um microcontrolador, firmware para o qual est√° escrito em um ambiente de desenvolvimento especial para o Arduino, usando, como regra, bibliotecas prontas para um ou outro m√≥dulo. <br><br>  Um dos m√≥dulos - W5500 - destina-se √† fabrica√ß√£o de estruturas eletr√¥nicas que ser√£o conectadas √† Internet.  Nesse caso, na maioria das vezes, implica controle remoto de sua estrutura.  Por exemplo, pode ser uma ‚Äúcasa inteligente‚Äù, um rob√¥ e similares.  O projeto mais trivial (exceto o Hello world) √© a inclus√£o remota de LEDs atrav√©s de um navegador da Web (Fig. 1).  Se, em vez de LEDs, comutadores de transistor e rel√©s estiverem conectados, cargas mais poderosas poder√£o ser comutadas.  Portanto, em ess√™ncia, o programa (firmware) desse design √© um servidor da web que processa solicita√ß√µes HTTP de um usu√°rio remoto. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qj/xj/w5/qjxjw5zozlcgxty2zaxpld3tfow.jpeg"></div>  <i>Fig.</i>  <i>1. Gerenciamento de LEDs atrav√©s de um navegador.</i> <br><br>  O m√≥dulo W5500 √© baseado no pr√≥prio chip W5500 com seu kit de corpo, al√©m de um conector BLS para MK via SPI, um conector RJ-45 para conex√£o a uma rede de computadores e um regulador de tens√£o linear para 3,3 V (Fig. 2). <br><br><img src="https://habrastorage.org/webt/ta/sd/nz/tasdnz169igf5gzmdd6geetdsc4.jpeg" width="375" height="375"><br><br>  <i>Fig.</i>  <i>2. O m√≥dulo W5500.</i> <br><br>  O chip W5500 √© um controlador completo com processamento integrado de toda uma pilha de protocolos de rede, da Ethernet ao TCP (Fig. 3).  Ao implementar um design baseado nesse chip, o programador n√£o precisa escrever o c√≥digo de processamento do protocolo TCP / IP, basta implementar apenas o protocolo da camada de aplica√ß√£o, que ser√° incorporado ao TCP.  No exemplo acima (no Arduino), http √© usado como protocolo de aplica√ß√£o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5n/a0/dx/5na0dx-_xgs06can1rxipmlul7y.jpeg"></div>  <i>Fig.</i>  <i>3. A estrutura do chip W5500.</i> <br><br>  Sem fazer o Arduino, decidi estudar a documenta√ß√£o do chip W5500 em detalhes e implementar de forma independente o programa baseado no microcontrolador Atmega8.  Este programa n√£o incluir√° um manipulador http.  √â necess√°rio implementar a troca de dados mais simples (RAW) via protocolo TCP usando um terminal remoto.  N√£o √© inteiramente exato falar sobre o protocolo Telnet, como diz o t√≠tulo deste artigo.  Possui caracter√≠sticas pr√≥prias, baseadas na troca de informa√ß√µes adicionais sobre os par√¢metros dos terminais.  No entanto, a maioria dos clientes de telnet suporta RAW e n√£o requer o acima.  Portanto, o programa Atmega8 MK n√£o incluir√° um manipulador de protocolo no n√≠vel do aplicativo.  Ela lidar√° apenas com a inicializa√ß√£o do W5500, gerenciamento de soquete, recep√ß√£o e transmiss√£o de dados. <br><br>  A principal aplica√ß√£o desse design √© o gerenciamento de dispositivos atrav√©s de um terminal remoto.  Nesse caso, o design √© conectado ao dispositivo gerenciado pela interface UART (tr√™s fios GND, TxD, RxD).  A gest√£o atrav√©s do terminal √© uma abordagem profissional cl√°ssica em uma √°rea espec√≠fica na aus√™ncia de uma interface gr√°fica.  Por exemplo, uma linha de comando do Windows ou Linux ou uma maneira de configurar um roteador atrav√©s de um terminal usando o protocolo Telnet.  O √∫ltimo exemplo √© realmente equivalente √† id√©ia discutida neste artigo. <br><br>  Ao desenvolver este ou aquele dispositivo, se necess√°rio, pretendo control√°-lo com comandos de texto atrav√©s de um terminal conectado via interface UART.  Pode ser uma conex√£o com um PC comum na porta COM RS-232 via chip adaptador MAX232 ou no USB (porta COM virtual) atrav√©s do chip PL2303.  Voc√™ pode usar o programa HyperTerminal padr√£o como um terminal.  Com a expans√£o dos smartphones Android, tornou-se conveniente conectar-se via Bluetooth: um m√≥dulo Bluetooth (por exemplo, HC-06) √© conectado √† interface UART do dispositivo e um smartphone √© conectado ao m√≥dulo sem fio.  Existem muitos aplicativos na Internet que implementam o terminal via Bluetooth.  Assim, voc√™ pode controlar o dispositivo atrav√©s do terminal a partir de um telefone celular via Bluetooth em um curto alcance.  O design discutido neste artigo permite implementar o controle atrav√©s do terminal usando a Internet.  O terminal pode ser o HyperTerminal padr√£o, fornecido com o Windows XP, ou voc√™ pode executar o utilit√°rio telnet na linha de comando do Windows e trabalhar nele.  Se estamos falando de um smartphone, voc√™ pode escolher um dos aplicativos no Android (tamb√©m h√° um grande n√∫mero deles) (Fig. 4). <br><br><img src="https://habrastorage.org/webt/4g/ia/x7/4giax7dezsah7q-pjb5eso6tftm.jpeg" width="400" height="640"><br><br>  <i>Fig.</i>  <i>4. Aplicativos para "terminal TCP" no Google Play.</i> <br><br>  O chip W5500 possui 8 soquetes independentes, cada um com uma mem√≥ria para receber e transmitir informa√ß√µes com mais de 2 KB.  Total, a mem√≥ria total √© de 16 KB para recebimento e 16 KB para transmiss√£o de informa√ß√µes.  Esses par√¢metros s√£o usados ‚Äã‚Äãpor padr√£o, mas, se necess√°rio, no est√°gio de inicializa√ß√£o do chip, a mem√≥ria pode ser realocada pelos soquetes.  O aplicativo descrito aqui utilizar√° as configura√ß√µes de mem√≥ria padr√£o e todos os 8 soquetes est√£o envolvidos.  Cada soquete no est√°gio de sua inicializa√ß√£o recebe muitos par√¢metros, sendo os principais o modo de opera√ß√£o e a porta TCP.  O modo de opera√ß√£o de todos os oito soquetes que precisamos √© o modo de servidor TCP.  Voc√™ deve atribuir portas diferentes para cada soquete.  Tomei oito portas consecutivas, come√ßando, por exemplo, a partir de 4000. No est√°gio de inicializa√ß√£o do m√≥dulo W5500, s√£o atribu√≠dos par√¢metros de rede conectados ao programa Atmega8 MK: endere√ßo IP, m√°scara de sub-rede, endere√ßo IP do gateway e at√© o endere√ßo MAC f√≠sico.  As configura√ß√µes de rede do W5500 devem corresponder √†s configura√ß√µes da rede dom√©stica √† qual ele se conecta.  Ao conectar remotamente ao dispositivo descrito, as configura√ß√µes do terminal indicam o endere√ßo do host (endere√ßo IP ou nome de dom√≠nio) e porta.  O endere√ßo do host refere-se ao dispositivo W5500 e a porta refere-se ao soquete no dispositivo.  Um soquete pode funcionar com apenas uma conex√£o.  Portanto, √© poss√≠vel fazer oito conex√µes simult√¢neas independentes.  A Figura 5 mostra os par√¢metros de conex√£o no programa HyperTerminal padr√£o para o W5500 com o endere√ßo IP 192.168.0.111 no soquete 0 (porta 4000).  Para se conectar √† Internet global (de fora), voc√™ precisa configurar corretamente o seu roteador dom√©stico. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gl/xf/dt/glxfdtxvfstq3pbj0_bguqpusm8.jpeg"></div>  <i>Fig.</i>  <i>5. Conex√£o via TCP / IP no HyperTerminal.</i> <br><br>  Eu tentei muitas aplica√ß√µes de terminal TCP diferentes, cada uma com suas pr√≥prias vantagens e desvantagens.  Primeiro de tudo, pelo m√©todo de empacotar um pacote TCP, dois casos podem ser distinguidos.  No primeiro caso, um pacote TCP √© gerado e enviado ao servidor imediatamente quando um caractere √© inserido no terminal.  Assim, o campo de dados de cada pacote leva 1 byte e cont√©m o caractere inserido pelo usu√°rio.  O programa HyperTerminal funciona exatamente nesse modo.  No segundo caso, o conjunto de caracteres (comando) √© inserido em um campo de texto separado e, quando voc√™ clica no bot√£o "Enviar", apenas um pacote com um campo de dados √© formado, cujo conte√∫do √© um conjunto de caracteres inserido pelo usu√°rio.  O tamanho do campo de dados desse pacote em bytes coincide com o n√∫mero de caracteres digitados.  O segundo caso √© o mais prefer√≠vel e conveniente, al√©m de econ√¥mico no tr√¢nsito.  Nosso design funciona com os dois casos, transferindo para a sa√≠da (TxD) do UART MK Atmega8 todos os caracteres inseridos pelo usu√°rio remoto a partir de qualquer soquete. <br><br>  Quanto √† organiza√ß√£o da transfer√™ncia de informa√ß√µes do servidor para o cliente, aqui tamb√©m t√™m suas pr√≥prias caracter√≠sticas.  √â poss√≠vel fazer com que o programa MK gere um pacote TCP de um byte tamb√©m diretamente, ap√≥s o recebimento de um byte (caractere) na perna do RxD UART MK.  Voc√™ pode criar um pacote TCP a partir de um conjunto de bytes de entrada para o MK pela presen√ßa de um sinal adicional especial, presente apenas durante a transmiss√£o da sequ√™ncia do dispositivo conectado (sinal de embalagem).  A prop√≥sito, esse sinal √© usado para alternar o MAX485 para transmiss√£o no caso de converter a interface RS-232 em interface RS-485 half-duplex.  No entanto, como eu estava convencido, √© mais conveniente usar um timer, ou seja,  um pequeno atraso durante o qual a recep√ß√£o de caracteres e a forma√ß√£o do pacote TCP ser√° realizada.  Este √© o m√©todo que eu implementei na constru√ß√£o descrita.  Funciona da seguinte maneira.  O temporizador (o tempo √© definido aproximadamente 0,3 seg.) Inicia quando o primeiro caractere chega e √© redefinido quando cada pr√≥ximo caractere chega no UART MK.  Se nenhum caractere chegar dentro de um tempo especificado, um pacote com os caracteres recebidos ser√° formado e enviado ao cliente e o cron√¥metro ser√° interrompido.  No meu caso particular, h√° uma correspond√™ncia em massa em todos os soquetes aos quais os clientes est√£o conectados. <br><br>  Agora ser√° sobre privacidade.  O terminal remoto descrito n√£o est√° protegido contra escutas usando analisadores de tr√°fego.  At√© o pr√≥prio protocolo Telnet n√£o fornece autentica√ß√£o e criptografia de senha.  Para isso, existem outros protocolos de terminal remoto modernos.  E, no caso do Telnet, bem como no caso do RAW (sem um protocolo de aplicativo), voc√™ pode implementar um m√©todo indireto de autentica√ß√£o de senha, que s√≥ ser√° ineficaz com a interven√ß√£o intencional intencional.  No entanto, esse m√©todo de autoriza√ß√£o proteger√° contra tr√°fego "esquerdo" n√£o controlado.  Pode ser proveniente de spyware, que, classificando o intervalo de endere√ßos IP de provedores conhecidos e o intervalo de portas, pode se conectar repentinamente ao nosso dispositivo (se "escutar" as conex√µes da Internet).  No meu firmware, implementei uma p√°gina de boas-vindas do cliente, se conectada ao servidor, ou seja,  para o design baseado no m√≥dulo W5500. <br><br>  A p√°gina de boas-vindas cont√©m informa√ß√µes sobre o endere√ßo IP do cliente, n√∫mero do soquete (para monitoramento) e uma solicita√ß√£o para inserir uma senha (Fig. 6). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ea/nw/2q/eanw2qiq7wtm974w7brndgscqja.jpeg"></div>  <i>Fig.</i>  <i>6. P√°gina de boas-vindas do servidor W5500.</i> <br><br>  Ap√≥s conectar-se dentro do programa MK, um timer inicia (por aproximadamente 18 segundos), durante o qual o usu√°rio deve ter tempo para inserir uma senha espec√≠fica (a mesma em todos os soquetes).  Se a senha for digitada incorretamente, ap√≥s o tempo definido, o usu√°rio informa a mensagem correspondente e o servidor desconecta (Fig. 7). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qi/i5/rh/qii5rh4vsutckz8oyinxlurdsv8.jpeg"></div>  <i>Fig.</i>  <i>7. Relatar uma senha incorreta.</i> <br><br>  No caso de uma senha digitada corretamente, o usu√°rio tamb√©m recebe a mensagem correspondente (Fig. 8).  Depois disso, uma ponte "transparente" √© estabelecida entre o terminal remoto e a interface UART do MK, √† qual o m√≥dulo W5500 est√° conectado via SPI.  A opera√ß√£o dessa ponte foi testada apenas no n√≠vel das equipes de usu√°rios.  Uma troca de dados de alta velocidade de pleno direito pode n√£o ser garantida se, em alguns casos, o aplicativo cliente n√£o for um terminal de usu√°rio, mas algum outro programa.  E ainda mais, o design descrito n√£o garante (mais precisamente, n√£o √© fornecido) a troca de dados full-duplex. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9j/lx/4c/9jlx4c2o2sjavhkdq2gut43oo7m.jpeg"></div>  <i>Fig.</i>  <i>8. Mensagem sobre a senha correta.</i> <br><br>  Quando uma senha √© digitada, o usu√°rio n√£o retorna os caracteres digitados no terminal e tamb√©m ‚ÄúBackspace‚Äù n√£o funciona (retrocesso com um caractere digitado incorretamente).  O tamanho da senha √© de 8 caracteres.  O programa MK verifica os 8 primeiros caracteres recebidos do cliente, independentemente de sua distribui√ß√£o nos pacotes TCP.  Mas qualquer pacote n√£o deve exceder 10 bytes.  A prop√≥sito, a fun√ß√£o "Enviar arquivo de texto" no HyperTerminal funciona de maneira bastante interessante.  Como foi verificado usando um analisador de tr√°fego, quando essa fun√ß√£o √© executada, dois pacotes TCP s√£o formados: o primeiro pacote com dados de 1 byte cont√©m o primeiro caractere do arquivo de texto transmitido e o segundo pacote cont√©m o restante do conte√∫do. <br><br>  O servidor fornece duas senhas diferentes.  Uma senha √© usada para estabelecer a ponte TCP-UART (uso normal), conforme descrito acima, e a segunda senha √© usada para controlar o m√≥dulo W5500 ou outros par√¢metros de design.  Se essa senha for digitada, o usu√°rio ver√° outra p√°gina de boas-vindas e ele entrar√° no modo de controle.  Eu intencionalmente desde que esse modo fosse poss√≠vel apenas em um dos soquetes livres.  Se um soquete com esse modo estiver ocupado e for feita uma tentativa de efetuar logon nesse modo em outro soquete, a conex√£o ser√° desconectada imediatamente pelo servidor.  Antes do intervalo, ser√° exibida uma mensagem sobre o n√∫mero do soquete que j√° est√° funcionando (ocupado) no modo de controle (Fig. 9). <br><br>  O modo de controle fornece os comandos que defini, cuja lista pode ser vista digitando o comando help.  O comando deve terminar com um caractere de nova linha (tecla Enter).  Al√©m disso, se o modo de controle estiver ativo, o servidor W5500 envia mensagens de servi√ßo ao terminal, por exemplo, sobre como conectar clientes a outros soquetes com seus endere√ßos IP ou sobre um soquete livre.  A Figura 10 demonstra o acima.  A lista de equipes ainda n√£o est√° completa, ser√° reabastecida ao longo do tempo. <br><br><img src="https://habrastorage.org/webt/mb/bu/v_/mbbuv_bfry1kuj83z8wgwzxwbqm.jpeg" width="400" height="340"><br><br>  <i>Fig.</i>  <i>9. Uma mensagem sobre um soquete ocupado ao inserir a senha do modo de controle.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/es/dk/sn/esdksn_il5ajj_btzatrxlaxeb4.jpeg"></div>  <i>Fig.</i>  <i>10. modo de controle W5500.</i> <br><br>  O comando echo desativa ou ativa o retorno do caractere impresso ao terminal (auto-monitoramento).  Os dois comandos a seguir s√£o para leitura e grava√ß√£o do registro de endere√ßo do chip W5500.  Os valores dos registradores para os endere√ßos est√£o indicados na documenta√ß√£o do chip W5500.  Eu introduzi esses comandos universais, principalmente para depura√ß√£o.  O comando rl reinicia imediatamente o n√∫mero do soquete indicado depois.  Da mesma forma, o comando sr l√™ o status do soquete, fornecendo seu valor como um n√∫mero HEX.  O comando "ens" fornece uma tabela de estados para cada soquete: estado "0" - o soquete est√° livre, aguardando o cliente, estado "1" - o soquete em uso normal, estado "2" - o soquete no modo de controle.  Voc√™ pode inserir um n√∫mero muito maior de comandos.  Ser√° √∫til alterar os par√¢metros que se encaixam no chip no est√°gio de inicializa√ß√£o quando o dispositivo √© ligado (por exemplo, par√¢metros de rede), armazenando-os na mem√≥ria n√£o vol√°til do MK.  Tamb√©m pode ser √∫til inserir comandos especiais que controlam pinos MK adicionais gratuitos.  Por exemplo, "PC0 = 1", "PC2 = 0" etc.  Certifique-se de precisar do comando de configura√ß√£o UART interface MK. <br><br>  Considere os detalhes mais sutis do trabalho do programa MK.  Al√©m dos temporizadores mencionados acima, um temporizador √© ativado, gra√ßas ao qual, a cada meio minuto, os chamados  Pacotes de controle TCP "keep-alive".  Isso √© necess√°rio para verificar a conex√£o na aus√™ncia de troca de dados do usu√°rio.  Se, por qualquer motivo, n√£o houver confirma√ß√£o do cliente dentro de um determinado per√≠odo definido dentro do W5500, o chamado  timeout e o soquete ser√° reiniciado.  A conex√£o pode ser repentinamente perdida, por exemplo, devido a uma interrup√ß√£o no link de dados ou na camada f√≠sica: eles puxaram um cabo Ethernet, desconectaram a Internet ou perderam uma conex√£o Wi-Fi, etc. <br><br>  Com base na documenta√ß√£o do chip W5500 (folha de dados), as seguintes fun√ß√µes s√£o implementadas no c√≥digo do programa.  Primeiramente, as fun√ß√µes b√°sicas de escrever e ler o W5500 s√£o registradas nos endere√ßos.  Fun√ß√µes de n√≠vel superior - redefini√ß√£o de hardware, inicializa√ß√£o de chip, inicializa√ß√£o de soquete, abertura de um soquete, soquete de escuta, desconex√£o e fechamento do soquete, envio do comando ‚Äúkeep_alive‚Äù, reinicializa√ß√£o do soquete.  A √∫ltima fun√ß√£o √© uma composi√ß√£o das fun√ß√µes acima: fechar, abrir, ouvir.  A maioria das fun√ß√µes retorna um valor de status do soquete ap√≥s serem executadas.  Finalmente, as fun√ß√µes mais b√°sicas s√£o processar as informa√ß√µes recebidas (ler no buffer RX) e processar as informa√ß√µes enviadas (gravar no buffer TX).  Fiz recomenda√ß√µes sobre a implementa√ß√£o dessas fun√ß√µes no site oficial do fabricante do chip W5500 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a> ).  A fun√ß√£o de recebimento substitui os dados recebidos do buffer RX em seu pr√≥prio buffer n√£o anel de 128 bytes.  Esse tamanho √© suficiente para aplica√ß√µes simples e voc√™ n√£o pode obter muito do microcontrolador Atmega8.  O buffer TX do W5500 tamb√©m transfere dados do buffer intermedi√°rio, que tamb√©m √© pequeno em tamanho.  E, por sua vez, os dados do buffer de anel UART entram nele.  O √∫ltimo √© implementado automaticamente no ambiente de desenvolvimento do CVAVR usando o utilit√°rio CodeWizardAVR no est√°gio de cria√ß√£o do projeto. <br><br>  O W5500 est√° conectado √† interface MKI SPI (MOSI, MISO, SCK, SCLK).  Al√©m disso, o pino RST (reset de hardware) √© conectado a uma sa√≠da MK espec√≠fica e o pino INT correspondente √© conectado √† entrada de interrup√ß√£o externa INT0.  Este √∫ltimo √© usado para a finalidade a que se destina: Quando um evento ocorre no m√≥dulo W5500, ele gera um pulso no pino INT, que √© processado pelo controlador no corpo da interrup√ß√£o externa.  O MK aprende em quais soquetes o evento ocorreu e, em seguida, reescreve os c√≥digos de eventos para cada soquete em uma matriz espec√≠fica.  O processamento adicional da interrup√ß√£o ocorre dentro do loop principal do programa.  No total, cinco eventos foram documentados: o cliente conectado, o cliente desconectado (mais precisamente, registrou uma solicita√ß√£o de desconex√£o), os dados foram recebidos do cliente, o tempo limite funcionou e os dados foram enviados com sucesso.  No loop principal, todos os eventos, exceto o √∫ltimo, s√£o processados.  A instru√ß√£o switch-case √© colocada nesse processamento.  A maior parte do c√≥digo C √© encontrada na se√ß√£o de processamento do terceiro evento (recep√ß√£o de dados).  Nele, ap√≥s a fun√ß√£o de processar as informa√ß√µes recebidas, o operador de caixa de comuta√ß√£o tamb√©m √© colocado, mas neste caso, essa ‚Äúchave‚Äù √© associada a uma vari√°vel respons√°vel pelo estado do soquete mencionado acima (valores 0, 1, 2).  A primeira se√ß√£o √© respons√°vel pelo procedimento de reconhecimento de senha.  Os caracteres recebidos s√£o substitu√≠dos em um buffer de senha separado.  Sob certas condi√ß√µes, as fun√ß√µes de comparar a cadeia recebida com cadeias constantes contendo senhas funcionam.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No caso de uma coincid√™ncia, o estado correspondente √© atribu√≠do. A segunda se√ß√£o √© a mais simples - o conte√∫do de seu pr√≥prio buffer de informa√ß√µes recebidas √© redirecionado para o UART do microcontrolador. Este √© um modo de uso normal. A terceira se√ß√£o (a maior) √© respons√°vel pelo processamento de comandos - modo de controle do dispositivo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m de continuar o manipulador de interrup√ß√µes, o loop principal do programa cont√©m manipuladores de timer virtual - um tempo limite para desconectar a conex√£o quando a senha n√£o √© bem-sucedida, enviando "keep-alive" periodicamente e enviando um pacote formado pelo timer TCP para o cliente. A fun√ß√£o de leitura do UART tamb√©m √© colocada no corpo do loop principal, dentro do qual os caracteres recebidos pelo controlador s√£o transferidos para seu pr√≥prio buffer de transmiss√£o (intermedi√°rio) e o timer √© redefinido, respons√°vel pela forma√ß√£o do pacote TCP.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todos os procedimentos do soquete s√£o colocados em um ciclo de 0 a 7, cujo iterador √© vinculado ao n√∫mero do soquete. Assim, ocorre o processamento seq√ºencial de todos os soquetes. Inicialmente, quis dizer que, se voc√™ atribuir o mesmo n√∫mero de porta a cada um dos oito soquetes, poder√° conectar at√© oito usu√°rios na mesma porta. No entanto, essa configura√ß√£o n√£o funcionou e esse problema foi adiado para o futuro.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao projetar o design da placa de circuito, forneci um rel√≥gio em tempo real (RTC) no chip DS1307. O Atmega8 MK, quartzo para a frequ√™ncia 11.0592 MHz (frequ√™ncia selecionada para precis√£o UART), um conector para o m√≥dulo W5500, conectores de porta MK (incluindo SPI para firmware, UART), RTC com seu pr√≥prio quartzo e compartimento de bateria CR2032 est√£o localizados em uma placa de circuito impresso de dois lados , Regulador linear de 5 V (7805), conector de alimenta√ß√£o e muito mais. O esbo√ßo da placa de circuito impresso no programa Sprint Layout √© mostrado na Figura 11. O √∫nico elemento mostrado em vermelho √© soldado na parte traseira, mas eu o soltei na parte frontal.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/za/po/fd/zapofdoavvxgcamlagyghd_zkae.jpeg"></div>  <i>Fig.</i> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11. Esbo√ßo da placa de circuito.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As fotos da constru√ß√£o finalizada s√£o apresentadas na Figura 12. Um rel√≥gio nesta constru√ß√£o ser√° usado para marcar o tempo durante v√°rios eventos dos soquetes do W5500, e esse tempo ser√° atribu√≠do ao usu√°rio no terminal pr√≥ximo √† mensagem, se o usu√°rio estiver conectado no modo de controle. Al√©m disso, o rel√≥gio ser√° √∫til no futuro para experimentos com o protocolo de hora NTP ou para qualquer outro prop√≥sito.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hf/fv/_r/hffv_rfjm1svqdgzmvmauahrmw0.jpeg"></div>  <i>Fig.</i> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12. Fotos da estrutura acabada.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Concluindo, vale a pena notar que o design interno justifica, em grande parte, dispositivos similares de n√≠vel industrial. A principal vantagem √© o pre√ßo. Acabou sendo muito mais barato fabricar do que o pre√ßo de um dispositivo similar acabado. E uma desvantagem como funcionalidade limitada √© inevit√°vel. Nesse caso, foi utilizado um controlador Atmega8 simplificado, uma vez que o objetivo simplificado correspondente foi definido.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hy/ko/fx/hykofxdictcvxijma6idea8hczq.jpeg"></div>  <i>Fig.</i> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13. Conversor industrial TCP / IP - RS-232.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A Figura 13 mostra um exemplo de um conversor industrial de TCP / IP para RS-232 baseado no chip W5100, muito semelhante ao W5500. Al√©m de sua interface de gerenciamento flex√≠vel, possui mais uma vantagem. Al√©m de trabalhar com um terminal TCP / IP, √© poss√≠vel usar um driver especial que acompanha o dispositivo para instalar uma porta COM virtual no lado do cliente. Atrav√©s dele, voc√™ pode conectar usando um terminal comum que n√£o possui o modo de conex√£o TCP / IP. Al√©m disso, o dispositivo pode oferecer suporte √† troca de dados completa do RS-232 se houver algum programa conectado ao inv√©s do terminal atrav√©s de uma porta COM virtual. Ou seja, o dispositivo representado na Figura 13 √© uma ponte RS-232 completa atrav√©s da infraestrutura de rede.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt414211/">https://habr.com/ru/post/pt414211/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt414199/index.html">Skynet, oi: intelig√™ncia artificial aprendeu a ver as pessoas atrav√©s das paredes</a></li>
<li><a href="../pt414201/index.html">C√≥digo Divino (c√≥digo de DEUS)</a></li>
<li><a href="../pt414203/index.html">Fraude ou n√£o fraude? Verificamos a OIC por cinco m√©todos</a></li>
<li><a href="../pt414207/index.html">O problema do inovador, ou por que voc√™ precisa recorrer √† experi√™ncia de outras pessoas</a></li>
<li><a href="../pt414209/index.html">IGNG - Algoritmo Incremental de G√°s Neural Incremental</a></li>
<li><a href="../pt414213/index.html">Um, dois, tr√™s! Chatbot do Planilhas Google usando o exemplo de um jogo PvP para Alice</a></li>
<li><a href="../pt414215/index.html">Blocos personalizados em chips (Silicon IP): como funciona</a></li>
<li><a href="../pt414217/index.html">Smartphones locais da Vertex: primeiro em qualidade, primeiro em chips, primeiro em design</a></li>
<li><a href="../pt414219/index.html">A experi√™ncia de usar energia solar na regi√£o de Moscou: a favor, contra e quem precisa</a></li>
<li><a href="../pt414221/index.html">Analisando e trabalhando com Codable no Swift 4</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>