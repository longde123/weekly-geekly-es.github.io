<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ÜîÔ∏è üëºüèæ üöà Fonctionnement de la cryptographie √† courbe elliptique dans TLS 1.3 üçº üíÖüèΩ üë®üèº‚Äçüîß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quelques alertes aux lecteurs: 

 Afin de simplifier (quelque peu) le processus de description et de resserrer le volume de l'article que nous allons ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fonctionnement de la cryptographie √† courbe elliptique dans TLS 1.3</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/qrator/blog/474810/"><img src="https://hsto.org/webt/qy/r5/a6/qyr5a6ywaf8vbc2kxtaazdmvgz8.png" alt="image"><br><br>  Quelques alertes aux lecteurs: <br><br>  Afin de simplifier (quelque peu) le processus de description et de resserrer le volume de l'article que nous allons √©crire, il est essentiel de faire une remarque significative et d'√©noncer tout de suite la contrainte principale - tout ce que nous allons vous dire aujourd'hui sur la pratique c√¥t√© de la probl√©matique n'est viable qu'en termes de TLS 1.3.  Cela signifie que, m√™me si votre certificat ECDSA fonctionnerait toujours dans TLS 1.2 si vous le souhaitiez, offrant une compatibilit√© descendante, la description du processus de prise de contact r√©el, des combinaisons de chiffrement et des benchmarks client-serveur ne couvre que TLS 1.3.  Bien s√ªr, cela ne concerne pas la description math√©matique des algorithmes derri√®re les syst√®mes de cryptage modernes. <br><br>  Cet article n'a √©t√© √©crit ni par un math√©maticien ni par un ing√©nieur - bien que ceux-ci aient aid√© √† trouver un moyen de contourner les math√©matiques effrayantes et aient examin√© cet article.  Un grand merci aux employ√©s de Qrator Labs. <br><br><h3>  (Courbe elliptique) <b>D</b> iffie- <b>H</b> ellman (Eph√©m√®re) </h3> <b>L'h√©ritage Diffie - Hellman au 21e si√®cle</b> <br><br>  Bien s√ªr, cela n'a commenc√© ni avec Diffie ni Hellman.  Mais pour fournir un calendrier correct, nous devons souligner les dates et √©v√©nements principaux. <br><br>  Il y avait plusieurs personnages majeurs dans le d√©veloppement de la cryptographie moderne.  Plus particuli√®rement, Alan Turing et Claud Shannon ont tous deux consacr√© une quantit√© incroyable de travail au domaine de la th√©orie du calcul et de la th√©orie de l'information ainsi qu'√† la cryptanalyse g√©n√©rale, et Diffie et Hellman sont officiellement reconnus pour avoir propos√© l'id√©e de cl√© publique (ou soi-disant asym√©trique) (bien que l'on sache qu'au Royaume-Uni, des avanc√©es importantes en cryptographie sont rest√©es secr√®tes pendant tr√®s longtemps), faisant de ces deux messieurs des pionniers. <br><br>  Dans quoi exactement? <br><a name="habracut"></a><br>  Eh bien, cela peut sembler particulier;  cependant, avant le 6 novembre 1976, le public ne connaissait pas les syst√®mes de chiffrement √† cl√© publique.  Whitfield Diffie et Martin Hellman (et, en fait, Ralph Merkle) - les math√©maticiens, les informaticiens et les passionn√©s, ainsi que les cryptologues ont √©t√© les premiers. <br><br>  Pour ceux qui ne le savent pas - en raison du r√¥le que la cryptanalyse a pris pendant la Seconde Guerre mondiale et de son √©norme impact sur la confidentialit√© des informations, les deux pays qui pensaient avoir les connaissances les plus avanc√©es en cryptographie - les √âtats-Unis et le Royaume-Uni ont inclus le cryptage dans leurs listes de munitions et ont exploit√© une interdiction d'exportation s√©v√®re (affaiblissant simultan√©ment la mise en ≈ìuvre du cryptage pour un usage domestique priv√© et commercial).  Pour cette raison, les chercheurs britanniques travaillant sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://web.archive.org/web/20141030210530/">technique d'√©change de cl√©s asym√©triques</a> au si√®ge des communications gouvernementales et d√©veloppant un sch√©ma analogue n'ont √©t√© reconnus pour cette invention qu'en 1997, lorsque les restrictions sur les algorithmes de cryptographie et leur description ont √©t√© rendues inefficaces. <br><br>  Revenons √† nos deux inventeurs - qu'est-ce qui a particuli√®rement r√©volutionn√© Diffie et Hellman? <br><br>  Jetons un coup d'≈ìil √† leur article original, illustrant parfaitement le saut g√©ant qu'ils ont introduit (m√™me th√©oriquement avec leur document de recherche): <br><img src="https://habrastorage.org/webt/tt/rb/ig/ttrbigv4-qiw2ugkittwgox65se.png" alt="image"><br>  Et le suivant: <br><img src="https://habrastorage.org/webt/3c/n5/6g/3cn56g2moitap1tsu-dpsnspfc4.png" alt="image"><br>  Ces deux images illustrent parfaitement l'√©norme changement que Whitfield Diffie et Martin Hellman ont introduit apr√®s des si√®cles d'√©volution de la cryptographie et de la cryptanalyse - l'√©tablissement d'une cl√© secr√®te partag√©e √† la suite d'un calcul cryptographique. <br><br>  Jetons un coup d'≈ìil √† une autre bonne image avec des couleurs: <br><br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/46/Diffie-Hellman_Key_Exchange.svg/375px-Diffie-Hellman_Key_Exchange.svg.png" alt="image"><br><br>  Il explique ce qui se passe.  Avant l'invention de l'accord de cl√© Diffie et Hellman, il n'y avait qu'une seule cl√© sym√©trique - elle √©tait utilis√©e √† la fois pour crypter et d√©crypter le message.  Si vous voulez donner √† quelqu'un une telle ¬´cl√©¬ª, elle doit √™tre transf√©r√©e sur un canal ¬´s√©curis√©¬ª.  Vous pouvez imaginer imm√©diatement toutes les restrictions d'un tel sch√©ma de g√©n√©ration pr√©c√©dente - vous avez besoin d'un canal s√©curis√© d√©j√† √©tabli, vous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ne pouvez pas r√©utiliser la cl√©</a> et, id√©alement, la longueur de la cl√© devrait √™tre la m√™me que la longueur du message. <br><br>  Claude Shannon dans son ouvrage class√© en temps de guerre ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Communication Theory of Secrecy Systems</a> ¬ª a prouv√© que tous les chiffrements th√©oriquement incassables doivent avoir les m√™mes exigences que le pav√© √† usage unique - connu sous le nom de chiffrement Vernam, par l'auteur de ce chiffrement sym√©trique √† flux polyalphab√©tique. <br><br>  Encore une fois, nous allons jeter un ≈ìil au document original: <br><img src="https://habrastorage.org/webt/p1/p0/yf/p1p0yfmprijaobfof3kb2lu4bpk.png" alt="image"><br><br>  Avant d'aller plus loin, posons-nous la question suivante: comment deux √™tres humains, m√™me brillants, ont-ils trouv√© une am√©lioration aussi significative dans un domaine appliqu√© avec une telle histoire, en particulier en temps de guerre? <br>  Eh bien, √† cause de: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Th√©orie de l'information</a> , formul√©e par Claude Shannon; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Th√©orie du calcul</a> influenc√©e notamment par Alonzo Church, John von Neumann et Alan Turing; </li><li>  Et, plus important encore, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la th√©orie de la calculabilit√©</a> bas√©e principalement sur le travail de Turing, que nous pourrions dire tous d√©velopp√© et m√ªri √† la m√™me p√©riode du 20e si√®cle.  Diffie et Hellman ont tous deux mentionn√© Claude Shannon comme l'influenceur le plus important de leur travail. </li></ul><br>  La ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">s√©curit√© universelle</a> ¬ª de Lenstra illustre la quantit√© d'√©nergie n√©cessaire pour ¬´casser¬ª le cryptosyst√®me sym√©trique avec diff√©rentes longueurs de cl√©.  Il s'est av√©r√© que briser une cl√© de courbe elliptique de 228 bits n√©cessiterait la m√™me quantit√© d'√©nergie n√©cessaire pour faire bouillir toute l'eau sur Terre.  Il n'est cependant valable que si l'on consid√®re les algorithmes et le mat√©riel connus, car √† strictement parler, personne ne sait s'il existe des algorithmes ou du mat√©riel beaucoup plus efficaces.  La cl√© EC 228 bits est comparable √† la cl√© RSA longue de 2380 bits, plus √† ce sujet plus tard.  Bien que dans cette estimation, les cl√©s RSA et EC soient utilis√©es dans un sch√©ma de chiffrement asym√©trique, ces longueurs de cl√© sont quelque peu √©quivalentes √† une cl√© de chiffrement sym√©trique √† 128 bits. <br><br>  Il est facile d'imaginer que quelque chose de ¬´difficile √† calculer¬ª n√©cessiterait beaucoup d'√©nergie et / ou de temps pour le calcul.  Nous avons tendance √† penser que les ordinateurs peuvent ¬´tout calculer¬ª, mais il s'av√®re que ce n'est pas vrai.  Premi√®rement, il existe des exemples ind√©cidables, comme le probl√®me d'arr√™t, bien que dans le domaine de la cryptographie, nous puissions √©viter cet √©cueil.  Deuxi√®mement, si nous consid√©rons le temps n√©cessaire √† l'ex√©cution d'un algorithme particulier, il peut √™tre arbitrairement √©lev√©.  C'est ce que nous exploitons en cryptographie.  Un probl√®me est consid√©r√© comme ¬´facile¬ª √† calculer si le temps requis pour ex√©cuter l'algorithme respectif d√©pend de la taille d'entr√©e (mesur√©e en bits) comme un polyn√¥me: <math> </math> $ en ligne $ T (n) = O (n ^ k) $ en ligne $   , pour une constante positive <math> </math> $ en ligne $ k $ en ligne $   .  Dans le domaine de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">th√©orie de la complexit√© informatique</a> , ces probl√®mes forment la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">classe de complexit√© P.</a> <br><br>  La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">classe de complexit√© P</a> est presque centrale, car elle repr√©sente le probl√®me pour lequel il existe un algorithme de temps polynomial d√©terministe.  Une autre classe de complexit√© est le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NP</a> (les probl√®mes ¬´difficiles¬ª √† calculer), repr√©sentant un ensemble de probl√®mes de d√©cision, c'est-√†-dire des probl√®mes n√©cessitant une r√©ponse ¬´oui¬ª ou ¬´non¬ª, qui ont une preuve v√©rifiable en temps polynomial.  Vous voyez le mot ¬´preuve¬ª ici?  C'est l√† que nous arrivons aux fonctions de trappe, appartenant √† la classe de complexit√© NP. <br><br><img src="https://imgs.xkcd.com/comics/travelling_salesman_problem.png" alt="image"><br>  Cr√©dits: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">xkcd</a> <br><br><h3>  Fonctions unidirectionnelles;  Fonctions de trappe </h3><br>  Par d√©finition, une fonction unidirectionnelle est une fonction qui est facile √† calculer sur chaque entr√©e mais qui est difficile √† inverser, c'est-√†-dire √† calculer l'entr√©e d'origine uniquement pour la sortie.  ¬´Facile¬ª et ¬´difficile¬ª font r√©f√©rence aux d√©finitions de la th√©orie de la complexit√© de calcul ci-dessus.  Il est int√©ressant de noter que l'existence de fonctions unidirectionnelles n'est pas (math√©matiquement) prouv√©e car leur existence prouverait que les classes de complexit√© P et NP ne sont pas √©gales, alors que P √©gal NP ou non est de nos jours un probl√®me ouvert.  Donc, gardez √† l'esprit que toute la cryptographie moderne repose sur des hypoth√®ses non prouv√©es. <br><br>  Maintenant, dans leur article original, Diffie et Hellman pr√©sentent une autre g√©n√©ration des fonctions √† sens unique qu'ils appelaient ¬´fonctions de trappe¬ª.  En quoi diff√®rent-ils? <br>  Comme ils l'expliquent dans leur document historique: <blockquote>  Dans un cryptosyst√®me √† cl√© publique, le chiffrement et le d√©chiffrement sont r√©gis par des cl√©s distinctes, E et D, de sorte que le calcul de D √† partir de E est impossible √† calculer (par exemple, n√©cessitant <math> </math> $ en ligne $ 10 ^ {100} $ en ligne $   instructions).  La cl√© de chiffrement E peut √™tre divulgu√©e [dans un r√©pertoire] sans compromettre la cl√© de d√©chiffrement D. Cela permet √† tout utilisateur du syst√®me d'envoyer un message √† tout autre utilisateur chiffr√© de telle sorte que seul le destinataire pr√©vu est capable de le d√©chiffrer. .. Le probl√®me de l'authentification est peut-√™tre un obstacle encore plus s√©rieux √† l'adoption universelle des t√©l√©communications pour les transactions commerciales que les probl√®mes de distribution des cl√©s ... [il] ... est au c≈ìur de tout syst√®me de contrats et de facturation. </blockquote>  Par convention, les caract√®res de cryptographie ¬´Alice¬ª et ¬´Bob¬ª (√† la recherche d'une communication s√©curis√©e) sont fr√©quemment utilis√©s pour expliquer le concept de cl√© publique.  Alice et Bob s'entendent sur de grands nombres entiers <math> </math> $ en ligne $ n $ en ligne $   et <math> </math> $ en ligne $ g $ en ligne $   avec <math> </math> $ en ligne $ 1 &lt;g &lt;n $ en ligne $   .  La s√©lection a un impact sur la s√©curit√© du syst√®me.  ¬´Le module <math> </math> $ en ligne $ n $ en ligne $   devrait √™tre un premier choix;  plus important encore <math> </math> $ en ligne $ (n-1) / 2 $ en ligne $   devrait √©galement √™tre un premier &lt;...&gt; et <math> </math> $ en ligne $ g $ en ligne $   devrait √™tre une racine modulo primitive <math> </math> $ en ligne $ n $ en ligne $   &lt;...&gt; [et] <math> </math> $ en ligne $ n $ en ligne $   doit √™tre &lt;...&gt; d'au moins 512 bits. ¬ªLe protocole Diffie - Hellman peut √™tre √©nonc√© sous forme √©l√©mentaire en 5 √©tapes. <br><br><ol><li>  Alice choisit <math> </math> $ en ligne $ x $ en ligne $   (un grand nombre al√©atoire) et calcule <math> </math> $ inline $ X = g ^ x \ bmod n $ inline $ </li><li>  Bob choisit <math> </math> $ en ligne $ y $ en ligne $   (un grand nombre al√©atoire) et calcule <math> </math> $ inline $ Y = g ^ y \ bmod n $ inline $ </li><li>  Alice envoie <math> </math> $ en ligne $ X $ en ligne $   √† Bob, tandis que Bob envoie <math> </math> $ en ligne $ Y $ en ligne $   √† Alice (ils gardent <math> </math> $ en ligne $ x $ en ligne $   et <math> </math> $ en ligne $ y $ en ligne $   secret les uns des autres) </li><li>  Alice calcule <math> </math> $ inline $ k = Y ^ x \ bmod n $ inline $ </li><li>  Bob calcule <math> </math> $ inline $ k '= X ^ y \ bmod n $ inline $ </li></ol><br>  En cons√©quence, Alice et Bob ont la m√™me valeur <math> </math> $ inline $ k = k '$ inline $   qui sert de secret partag√©. <br><br>  La fonction de trappe est une fonction unidirectionnelle qui permet de trouver son inverse si l'on dispose d'une information sp√©ciale appel√©e ¬´trappe¬ª.  Cela semble facile, mais il √©tait plut√¥t difficile de trouver de telles fonctions - la premi√®re m√©thode possible a √©t√© trouv√©e dans la mise en ≈ìuvre d'un algorithme de chiffrement asym√©trique par cryptographie √† cl√© publique nomm√© RSA d'apr√®s ses cr√©ateurs: Ron Rivest, Adi Shamir et Leonard Adleman. <br><br><h3>  RSA </h3><br>  Dans RSA, la duret√© de l'inversion de la fonction est bas√©e sur le fait que l'affacturage (trouver les multiplicateurs premiers d'un nombre) prend beaucoup plus de temps que la multiplication, ou devrions-nous dire ici qu'aucune m√©thode en temps polynomial pour factoriser de grands entiers sur un ordinateur classique Cependant, il n'a pas √©t√© prouv√© qu'il n'en existe pas. <br><br>  Dans RSA, comme dans tout autre syst√®me de chiffrement √† cl√© publique, il existe deux cl√©s: publique et priv√©e.  RSA prend le message d'entr√©e (repr√©sent√© sous la forme d'une cha√Æne de bits) et lui applique une op√©ration math√©matique (exponentiation modulo un grand entier) pour obtenir un r√©sultat qui ne se distingue pas du hasard.  Le d√©chiffrement prend ce r√©sultat et applique une op√©ration similaire pour r√©cup√©rer le message d'origine.  En cryptographie asym√©trique, le cryptage est effectu√© avec la cl√© publique et le d√©cryptage avec la cl√© priv√©e. <br><br>  Comment?  Parce que les op√©randes appartiennent √† un groupe cyclique fini (un ensemble d'entiers avec multiplication en arithm√©tique modulaire).  Les ordinateurs ne traitent pas tr√®s bien les nombres arbitrairement grands, mais, heureusement, notre groupe cyclique d'entiers consiste √† effectuer une op√©ration appel√©e ¬´boucler¬ª - un nombre sup√©rieur au maximum autoris√© est enroul√© autour d'un nombre dans la plage valide que nous exploitons .  Cela nous permet de fonctionner avec des touches de longueur ¬´pas plus longue que¬ª.  Dans la cryptographie √† courbe elliptique, des groupes cycliques (multiplicatifs) sont √©galement utilis√©s mais construits un peu diff√©remment comme nous le verrons plus loin. <br><br>  Fondamentalement, RSA prend deux grands nombres premiers et les multiplie pour obtenir le soi-disant module.  Tous les autres nombres √† traiter r√©sident entre z√©ro et le module.  Le module doit faire partie de la cl√© publique et sa longueur en bits d√©termine la longueur de la cl√©.  La deuxi√®me partie de la cl√© publique est un nombre choisi entre z√©ro et le totient d'Euler (l'impl√©mentation RSA moderne prend le totient de Carmichael au lieu d'Euler) du module avec quelques restrictions suppl√©mentaires.  Enfin, la cl√© priv√©e doit √™tre calcul√©e en r√©solvant une √©quation modulaire.  Pour crypter un nombre, nous l'√©l√©vons simplement √† la puissance √©gale √† la cl√© publique, et pour d√©crypter un nombre, nous l'√©l√©vons √† la puissance √©gale √† la cl√© priv√©e.  Gr√¢ce √† la nature cyclique du groupe, nous r√©cup√©rons le nombre initial. <br><br>  Il y a deux probl√®mes importants avec le RSA de nos jours, l'un √©tant une cons√©quence de l'autre.  Au fur et √† mesure que la longueur d'une cl√© (c'est-√†-dire le nombre de ses bits) augmente, le facteur de complexit√© ne cro√Æt pas aussi vite qu'on pourrait s'y attendre.  En effet, il existe un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">algorithme de</a> factorisation sous-exponentiel (mais toujours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">super-polynomial</a> ).  Ainsi, afin de maintenir un niveau de s√©curit√© appropri√©, la longueur de la cl√© RSA doit augmenter un peu plus rapidement que la longueur de la cl√© ECC.  C'est pourquoi les cl√©s RSA les plus r√©pandues de nos jours ont une longueur de 2048 ou 3072 bits. <br><br>  Un peu plus tard, nous verrons en chiffres comment la longueur de la cl√© affecte l'efficacit√© globale du cryptosyst√®me en comparant les certificats RSA et ECDSA sign√©s avec l'autorit√© Let's Encrypt. <br><br><h3>  ( <b>C</b> urve elliptique) Algorithme de <b>S</b> ignature num√©rique </h3><br>  La recherche d'une meilleure fonction de trappe a finalement conduit les cryptographes √† √©voluer activement dans la branche des math√©matiques du milieu des ann√©es 80 d√©di√©e aux courbes elliptiques. <br><br>  Ce serait la t√¢che ultime de d√©crire la cryptographie √† courbe elliptique dans un article, nous ne le ferons donc pas.  Examinons plut√¥t une fonction de trappe √† courbe elliptique bas√©e sur le probl√®me du logarithme discret. <br><br>  Il existe de nombreuses amorces et des introductions plus approfondies dans la cryptographie √† courbe elliptique, et nous recommandons particuli√®rement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"ECC: une introduction douce" d'Andrea Corbellini</a> si vous √™tes int√©ress√© par les math√©matiques. <br><br>  Ce qui nous int√©resse, ce sont des param√®tres plut√¥t ¬´simples¬ª. <br><br>  La courbe elliptique est d√©finie par une √©quation comme celle-ci: <math> </math> $ inline $ y ^ 2 = x ^ 3 + ax + b $ inline $ <br>  Une telle courbe est n√©cessaire pour construire un sous-groupe cyclique sur un champ fini.  Par cons√©quent, les param√®tres suivants sont utilis√©s: <br><br><ul><li>  Le <b>premier</b> <math> </math> <b>$ inline $ p $ inline $</b>   qui sp√©cifie la taille du champ fini; </li><li>  Les <b>coefficients</b> <math> </math> <b>$ inline $ a $ inline $</b>   <b>et</b> <math> </math> <b>$ en ligne $ b $ en ligne $</b>   de l'√©quation de la courbe elliptique; </li><li>  Le <b>point de base</b> <math> </math> <b>$ en ligne $ g $ en ligne $</b>   qui g√©n√®re le sous-groupe mentionn√©; </li><li>  La <b>commande</b> <math> </math> <b>$ en ligne $ n $ en ligne $</b>   du sous-groupe; </li><li>  Le <b>cofacteur</b> <math> </math> <b>$ en ligne $ h $ en ligne $</b>   du sous-groupe. </li></ul><br>  En conclusion, les <b>param√®tres de domaine</b> de nos algorithmes sont le <b>sextuplet</b> <math> </math> $ inline $ (p, a, b, G, n, h) $ inline $   . <br>  Ces courbes elliptiques fonctionnent sur le champ fini <math> </math> $ inline $ \ mathbb {F} _p $ inline $   , o√π <math> </math> $ inline $ p $ inline $   est un nombre premier assez grand.  Nous avons donc un ensemble d'entiers modulo <math> </math> $ inline $ p $ inline $   , o√π des op√©rations telles que l'addition, la soustraction, la multiplication, l'inverse additif, l'inverse multiplicatif sont possibles.  L'addition et la multiplication fonctionnent de mani√®re similaire √† l'arithm√©tique modulaire ou dite ¬´d'horloge¬ª que nous avons vue dans les ¬´enveloppements¬ª RSA. <br>  √âtant donn√© que la courbe est sym√©trique par rapport √† l'axe des x, √©tant donn√© n'importe quel point <math> </math> $ en ligne $ P $ en ligne $   , nous pouvons prendre <math> </math> $ inline $ ‚àíP $ inline $   √™tre le point en face d'elle.  Nous prenons <math> </math> $ inline $ ‚àíO $ inline $   √™tre juste <math> </math> $ en ligne $ O $ en ligne $   . <br>  L'addition pour les points de courbe est d√©finie de mani√®re √† ce que les points donn√©s <math> </math> $ en ligne $ P $ en ligne $   et <math> </math> $ en ligne $ Q $ en ligne $   , nous pouvons tracer une ligne coupant ces deux points et une courbe entrecrois√©e dans un troisi√®me point <math> </math> $ en ligne $ R $ en ligne $   pour que <math> </math> $ en ligne $ P + Q = -R $ en ligne $   et <math> </math> $ en ligne $ P + Q + R = 0 $ en ligne $   . <br><br>  Jetons un coup d'≈ìil √† l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">explication de Marc Hughes</a> : <br><blockquote><img src="https://www.allaboutcircuits.com/uploads/articles/Curve_Cryptography_fig09.jpg" alt="image"><br><br>  Une ligne de pente constante qui se d√©place le long de la surface du tore est montr√©e ci-dessus.  Cette ligne passe par deux points entiers s√©lectionn√©s au hasard sur la courbe. <br><br><img src="https://www.allaboutcircuits.com/uploads/articles/Curve_Cryptography_fig10.gif" alt="image"><br><br>  Pour ajouter deux points sur le graphique, tracez une ligne √† partir du premier point s√©lectionn√© <math> </math> $ en ligne $ P $ en ligne $   au deuxi√®me point s√©lectionn√© <math> </math> $ en ligne $ Q $ en ligne $   et prolonger la ligne jusqu'√† ce qu'elle coupe un autre point du graphique <math> </math> $ en ligne $ -R $ en ligne $   , en l'√©tendant au-del√† des limites de la parcelle si n√©cessaire. <br><br>  Une fois que vous avez intercept√© un point entier, r√©fl√©chissez le point verticalement au milieu du graphique (une ligne pointill√©e orange) pour trouver le nouveau point <math> </math> $ en ligne $ R $ en ligne $   sur le graphique.  Par cons√©quent <math> </math> $ en ligne $ P + Q = R $ en ligne $   . </blockquote>  La multiplication par un scalaire est d√©sormais triviale: <math> </math> $ en ligne $ n \ cdot P = P + P + P + \ points + P $ en ligne $   (voici <math> </math> $ en ligne $ n $ en ligne $   summands). <br><br>  La fonction de trappe se situe ici dans le probl√®me du logarithme discret (pour les courbes elliptiques), et non dans la factorisation que nous avons examin√©e dans la section RSA.  Le probl√®me est: si nous savons <math> </math> $ en ligne $ P $ en ligne $   et <math> </math> $ en ligne $ Q $ en ligne $   , c'est quoi <math> </math> $ en ligne $ k $ en ligne $   , que <math> </math> $ en ligne $ Q = k \ cdot P $ en ligne $   ? <br><br>  Le probl√®me de factorisation (sous-jacent au RSA) et le logarithme discret pour les courbes elliptiques (qui est la base de l'ECDSA et de l'ECDH) sont cens√©s √™tre difficiles, c'est-√†-dire qu'il n'y a pas d'algorithmes connus pour r√©soudre ce probl√®me en temps polynomial pour une cl√© donn√©e longueur. <br><br>  Alors que, g√©n√©ralement, tout le monde aurait honte de m√©langer l'√©change de cl√©s (ECDH) avec l'algorithme de signature (ECDSA), nous devons expliquer comment ils fonctionnent ensemble.  Un certificat TLS moderne contient une cl√© publique, dans notre cas, de la paire de cl√©s g√©n√©r√©e par l'algorithme de courbe elliptique, g√©n√©ralement sign√©e par une autorit√© de niveau sup√©rieur.  Le client v√©rifie la signature du serveur et obtient le secret partag√©.  Le secret partag√© est utilis√© dans un algorithme de chiffrement sym√©trique, tel que AES ou ChaCha20.  Cependant, le principe reste le m√™me: convenir de param√®tres de domaine (le sextuplet), obtenir la paire de cl√©s, o√π la cl√© priv√©e est un entier s√©lectionn√© au hasard (le multiplicande de <math> </math> $ en ligne $ Q = k \ cdot P $ en ligne $   ), et la cl√© publique est un point sur la courbe.  Les algorithmes de signature utilisent le point de base <math> </math> $ en ligne $ g $ en ligne $   , qui est un g√©n√©rateur pour un sous-groupe de grand ordre premier <math> </math> $ en ligne $ n $ en ligne $   , de telle sorte que <math> </math> $ inline $ n \ cdot G = 0 $ inline $   , o√π 0 est l'√©l√©ment d'identit√©.  La signature prouve que la connexion s√©curis√©e est √©tablie avec la partie authentique - un serveur qui a le certificat TLS (cl√© publique) sign√© par une autorit√© de certification pour le nom de serveur donn√©. <br><br><h3>  (EC) DH (E) + ECDSA = Forme de prise de contact actuelle </h3><br>  Dans TLS moderne (1.3), le client et le serveur g√©n√®rent leur paire de cl√©s publique-priv√©e √† la vol√©e, tout en √©tablissant la connexion, cela s'appelle la version √©ph√©m√®re de l'√©change de cl√©s.  Les biblioth√®ques TLS de navigateur les plus populaires le prennent en charge.  La plupart du temps, ils utilisent la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">courbe elliptique Edwards 25519</a> , introduite par Daniel J. Bernstein (djb), offrant une s√©curit√© de 128 bits.  Depuis 2014, openssh utilise cette courbe pour la cr√©ation de paires de cl√©s.  En 2019 cependant, les navigateurs ne prennent toujours pas en charge les sessions TLS avec des serveurs ayant un certificat avec une cl√© publique EdDSA. <br><br>  Mais revenons √† la fa√ßon dont les choses fonctionnent √† la fin de 2019 avec TLS 1.3. <br><br>  Les m√©canismes d'√©change de cl√©s dans TLS 1.3 sont limit√©s aux bases (EC) DH (E) (avec le x25519 est celui pris en charge dans les biblioth√®ques TLS c√¥t√© client des navigateurs les plus populaires ainsi que dans les biblioth√®ques TLS c√¥t√© serveur, comme OpenSSL, que nous inspecterons un peu plus tard), et la liste des suites de chiffrement ne contient que trois entr√©es: TLS_AES_128_GCM_SHA256, TLS_AES_256_GCM_SHA384 et TLS_CHACHA20_POLY1305_SHA256.  Pour ceux d'entre vous qui savent comment les suites de chiffrement ont √©t√© nomm√©es dans la version TLS 1.2, il est √©vident que le m√©canisme d'√©change de cl√©s est d√©sormais ¬´d√©tach√©¬ª du nom de la suite de chiffrement, les modes d'√©change RSA statique et Diffie - Hellman statique √©tant √©galement supprim√©s de la sp√©cification enti√®rement.  M√™me la reprise de session bas√©e sur PSK est effectu√©e via ECDHE dans TLS 1.3.  Cela est √©galement vrai pour les param√®tres DH personnalis√©s, qui ne sont pas autoris√©s pour le moment, ne laissant que ceux g√©n√©ralement accept√©s comme √©tant s√©curis√©s dans la sp√©cification de protocole finale. <br><br>  Il est int√©ressant de noter qu'il existe une diff√©rence assez importante dans le fonctionnement actuel des algorithmes de chiffrement asym√©triques.  Avec les certificats ECC (et ECDSA en particulier), nous utilisons des cl√©s plus petites pour atteindre des niveaux de s√©curit√© ¬´pratiques¬ª, par rapport √† RSA.  Cela permet d'utiliser un algorithme de chiffrement asym√©trique plus fort et des m√©canismes d'√©change de cl√©s sur les petits appareils et parfois m√™me dans des choses qui ne sont g√©n√©ralement pas consid√©r√©es comme un appareil (carte √† puce). <br><br>  Tout d'abord, il faut mentionner ce que signifie ¬´cryptosyst√®me hybride¬ª en termes de TLS 1.3. <br>  Un cryptosyst√®me hybride est celui qui utilise un cryptage asym√©trique (cl√© publique) pour √©tablir un secret partag√©, qui est en outre utilis√© comme cl√© dans un flux sym√©trique ou un chiffrement par bloc. <br><br>  Deuxi√®mement, l'infrastructure √† cl√© publique et les certificats.  Il est int√©ressant de noter que dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">son interview de 2004,</a> Martin Hellman a mentionn√© un ¬´h√©ros m√©connu¬ª Loren Kohnfelder, dont la th√®se de baccalaur√©at du MIT a introduit une structure arborescente de ce que nous connaissons aujourd'hui sous le nom d'infrastructure √† cl√© publique.  N√©anmoins, revenons aux certificats. <br><br>  Le fait que le serveur poss√®de r√©ellement la cl√© priv√©e est assur√© par sa signature, qui peut √™tre v√©rifi√©e avec la cl√© publique du serveur.  Et le certificat garantit qu'une certaine cl√© publique appartient √† un serveur sp√©cifique.  Cela signifie que vous √©tablissez une communication s√©curis√©e avec la partie sp√©cifique et non avec un imposteur.  Votre banque, pas un cybercriminel.  Dans TLS 1.3, il y a une am√©lioration significative par rapport au format de n√©gociation pr√©c√©dent - le serveur signe toutes les informations dont il dispose jusqu'√† pr√©sent: le bonjour du client et le bonjour du serveur, y compris le chiffrement n√©goci√©.  Jetons un coup d'≈ìil √† la section correspondante du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RFC 8446</a> : <br><br><pre><code class="plaintext hljs">Client Server Key ^ ClientHello Exch | + key_share* | + signature_algorithms* | + psk_key_exchange_modes* v + pre_shared_key* --------&gt; ServerHello ^ Key + key_share* | Exch + pre_shared_key* v {EncryptedExtensions} ^ Server {CertificateRequest*} v Params {Certificate*} ^ {CertificateVerify*} | Auth {Finished} v &lt;-------- [Application Data*] ^ {Certificate*} Auth | {CertificateVerify*} v {Finished} --------&gt; [Application Data] &lt;-------&gt; [Application Data]</code> </pre> <br>  Dans TLS 1.3, le client envoie imm√©diatement le partage de cl√© (avec les param√®tres n√©cessaires), les algorithmes de signature dans le premier message (Client Hello).  Les cl√©s n√©cessaires pour √©changer avec le serveur sont cr√©√©es en arri√®re-plan, sans que l'utilisateur ne s'en aper√ßoive.  Ils sont ensuite √©chang√©s avec le serveur pour cr√©er un secret commun, √† partir de cl√©s secr√®tes pr√©-ma√Ætre qui ont √©t√© √©tablies lorsque le serveur a envoy√© son message (Server Hello) r√©pondant au client. <br>  Du c√¥t√© ¬´Server Hello¬ª, vous pouvez voir le certificat * transf√©r√© au client, ainsi que la partie Certificate Verify * qui v√©rifie que la partie poss√®de la cl√© priv√©e pour l'entr√©e de cl√© publique correspondante et cr√©e la cl√© de session (sym√©trique) si tout se passe comme pr√©vu - ce qui signifie que la partie qui demande les donn√©es (client) a v√©rifi√© avec succ√®s la partie r√©pondante (serveur), cr√©ant ainsi un secret commun. <br><br>  Il y a deux op√©rations essentielles cach√©es dans ces transmissions - la cr√©ation de signature et la v√©rification de signature.  Celles-ci sont faites des deux c√¥t√©s de la communication, car la ¬´signature¬ª est essentiellement une preuve que la partie a effectivement la cl√© priv√©e correspondant √† la cl√© publique, que les donn√©es proviennent du signataire et que le message n'a pas √©t√© modifi√© en transit. <br><br>  Avec RSA, comme nous le verrons plus loin, l'op√©ration de signature est la plus co√ªteuse.  Puisque nous signons avec une cl√© longue de 2048 ou 3072 bits, une telle op√©ration charge le serveur de mani√®re significative, bien plus qu'elle ne charge le client v√©rifiant une telle signature. <br><br>  Avec ECDSA, nous avons des cl√©s plus petites (nous allons regarder l'ECDSA avec NIST P-256 (ou secp256v1)) mais des op√©rations plus complexes.  En cons√©quence, il pourrait √™tre consid√©r√© comme le RSA ¬´√† l'envers¬ª - le client est le plus charg√©, par le calcul de v√©rification de signature, tandis que le serveur g√®re facilement la cr√©ation de signature.  Les mesures le v√©rifient, voir la section ¬´Un peu de r√©f√©rence¬ª. <br><br>  Cet effet fait √©voluer facilement Internet de nos jours - car les clients modernes sont presque aussi puissants que les serveurs (en ne tenant compte que de la fr√©quence centrale du processeur), de sorte qu'ils pourraient effectivement prendre √† nu l'op√©ration co√ªteuse.  Le serveur, √† son tour, peut utiliser les capacit√©s lib√©r√©es pour cr√©er plus de signatures et √©tablir plus de sessions. <br><br><h3>  Encryptons la signature du certificat </h3><br>  Donc, afin de fournir au lecteur un peu d'instructions pratiques et pratiques sur la fa√ßon de cr√©er un serveur compatible TLS avec la paire de cl√©s ECDSA sign√©e par l'autorit√© Let's Encrypt, nous avons d√©cid√© d'illustrer un processus complet de cr√©ation d'une paire de cl√©s n√©cessaire pour cr√©er une CSR (demande de signature de certificat) pour Let's Encrypt et, par cons√©quent, obtenir le certificat ECDSA n√©cessaire pour notre serveur. <br><br>  Nous devons g√©n√©rer une cl√© priv√©e pour continuer.  Nous utiliserons la biblioth√®que OpenSSL. <br>  Le manuel OpenSSL d√©crit la g√©n√©ration de toutes les cl√©s EC via une commande sp√©ciale, d√©sign√©e sp√©cialement pour la branche de courbe elliptique de l'algorithme de g√©n√©ration. <br><br><pre> <code class="plaintext hljs">openssl ecparam -genkey -name -secp256v1 -out privatekey.pem</code> </pre> <br>  Pour v√©rifier que la biblioth√®que OpenSSL a tout fait correctement, nous pouvons ex√©cuter la commande <code>ec</code> . <br><br><pre> <code class="plaintext hljs">openssl ec -in privatekey.pem -noout -text</code> </pre> <br>  La sortie nous montrera la courbe sp√©cifi√©e avec laquelle la cl√© a √©t√© cr√©√©e. <br><br>  La prochaine √©tape est tout √† fait essentielle √† la cr√©ation de la CSR - afin d'ignorer le processus de remplissage de tous les d√©tails n√©cessaires √† l'obtention du certificat, nous avons besoin du fichier de configuration.  Heureusement, Mozilla a fait tout le travail pour nous, en introduisant le ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">g√©n√©rateur de configuration SSL</a> ¬ª.  L√†, vous pouvez choisir parmi toutes les options de serveur disponibles.  La pure configuration OpenSSL, particuli√®rement absente de la page du g√©n√©rateur, ressemblerait √† ceci: <br><br><pre> <code class="plaintext hljs">[ req ] prompt = no encrypt_key = no default_md = sha256 distinguished_name = dname req_extensions = reqext [ dname ] CN = example.com emailAddress = admin@example.com [ reqext ] subjectAltName = DNS:example.com, DNS:*.example.com</code> </pre> <br>  <i>Remarque: il n'est pas n√©cessaire d'avoir le CNF - si vous ne le faites pas, il vous sera demand√© de remplir ces d√©tails dans la ligne de commande.</i> <br><br>  Maintenant, suivez la cr√©ation d'une RSE elle-m√™me.  Ici, nous avons une commande OpenSSL pratique. <br><br><pre> <code class="plaintext hljs">openssl req -new -config -pathtoconfigfile.cnf -key privatekey.pem -out csr.pem</code> </pre> <br>  Nous pouvons √©galement v√©rifier l'exactitude d'un CSR nouvellement cr√©√©. <br><br><pre> <code class="plaintext hljs">openssl req -in csr.pem -noout -text -verify</code> </pre> <br>  Ici, nous sommes arriv√©s √† une phase finale - en utilisant un client ACME, certbot, pour transmettre notre demande de signature de certificat √† Let's Encrypt. <br><br>  Certbot vous aide √† obtenir le certificat n√©cessaire et propose de nombreuses options.  Ici, si vous √™tes nouveau dans le cryptage √† cl√© publique et l'infrastructure PKI que nous avons en 2019, vous feriez mieux d'utiliser <code>--dry-run</code> avant d'essayer d'obtenir le certificat pour n'importe quel domaine de la v√¥tre. <br><br><pre> <code class="plaintext hljs">certbot certonly --dry-run --dns-somednsprovider --domain ‚Äúexample.com‚Äù --domain ‚Äú*.example.com‚Äù --csr csr.pem</code> </pre> <br>  Dans ce cas, le client certbot v√©rifie que la liste des domaines demand√©s (dans la ligne de commande) correspond aux domaines r√©pertori√©s dans la demande de signature de certificat.  Dans la commande <code>--dns-somednsprovider</code> se trouve un peu un mensonge, car il existe de nombreuses fa√ßons de prouver √† Let's Encrypt que vous √™tes en possession d'une partie particuli√®re du trafic Internet.  Cependant, si vous utilisez un fournisseur d'h√©bergement cloud public, par exemple DigitalOcean, Hetzner, Amazon, Azure, n'importe quoi - il y aurait probablement un moyen plus naturel de fournir les informations n√©cessaires, car votre fournisseur a d√©j√† cr√©√© un outil d'int√©gration. <br><br>  Apr√®s, si vous √™tes s√ªr de l'exactitude des param√®tres que vous utilisez pour transmettre votre CSR √† Let's Encrypt via un client certbot - excluez le param√®tre <code>--dry-run</code> de votre commande et continuez. <br><br>  En cas de succ√®s, le client produirait plusieurs certificats en sortie: le certificat sign√© lui-m√™me, les certificats racine et interm√©diaire, et la combinaison de ces derniers en tant que derni√®re cha√Æne de certificats nomm√©s, le tout au format de fichier .pem. <br><br>  OpenSSL a une commande que nous pourrions utiliser pour inspecter les certificats: <br><br><pre> <code class="plaintext hljs">openssl x509 -in chainfilepath.pem -noout -text</code> </pre> <br>  √Ä ce stade, il devient √©vident que Let's Encrypt a sign√© le certificat √† l'aide du r√©sum√© SHA256.  De plus, la signature ECDSA Root et Intermediates rel√®ve de la section ¬´Fonctionnalit√©s √† venir¬ª, ce qui signifie que vous n'obtiendrez actuellement que des interm√©diaires RSA.  Mais √ßa va puisque vous utilisez toujours la cl√© publique ECDSA. <br><br>  √Ä la fin de cette section, nous aimerions dire quelque chose √† propos de la longueur des cl√©s.  En s√©curit√© de l'information, il est courant de dire que le niveau de s√©curit√© est 2 ^ x, o√π x est la longueur de bit (RSA est un peu une exception ici, car il se d√©veloppe un peu plus lentement qu'exponentiellement).  Pour approximer la fa√ßon dont les cl√©s utilis√©es pour les diff√©rents algorithmes se correspondent, nous nous r√©f√©rons √† la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">page wiki</a> OpenSSL. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Longueur de cl√© sym√©trique</b> <br></td><td>  <b>Longueur de cl√© RSA</b> <br></td><td>  <b>Longueur de cl√© de courbe elliptique</b> <br></td></tr><tr><td>  80 <br></td><td>  1024 <br></td><td>  160 <br></td></tr><tr><td>  112 <br></td><td>  2048 <br></td><td>  224 <br></td></tr><tr><td>  128 <br></td><td>  3072 <br></td><td>  256 <br></td></tr><tr><td>  192 <br></td><td>  7680 <br></td><td>  384 <br></td></tr><tr><td>  256 <br></td><td>  15360 <br></td><td>  512 <br></td></tr></tbody></table></div>  Comme vous pouvez le voir, les diff√©rences sont assez marqu√©es.  Bien qu'avec Let's Encrypt, nous n'avons pu obtenir aucun certificat sign√© en dehors des cl√©s de courbe elliptique 256 (secp256v1) et 384 (secp384r1). <br><br><h3>  Probl√®mes connus et exceptions, et LA NSA </h3><br><img src="https://imgs.xkcd.com/comics/random_number.png" alt="image"><br>  Cr√©dits: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">xkcd</a> <br><br>  Le probl√®me central de l'utilisation de la cryptographie √† courbe elliptique au fil des ans √©tait probablement la n√©cessit√© d'un g√©n√©rateur de nombres al√©atoires tr√®s soigneusement con√ßu, afin de cr√©er des cl√©s de niveau de s√©curit√© requis. <br><br>  Il y a eu un √©norme scandale autour de l'algorithme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dual_EC_DRBG</a> (g√©n√©rateur de bits al√©atoires d√©terministes √† courbe elliptique double), qui a mis plusieurs ann√©es √† se r√©soudre.  En outre, il existe une incertitude concernant les brevets ECC, car il est connu que beaucoup d'entre eux appartenaient √† la soci√©t√© Certicom, qui a √©t√© acquise par Blackberry.  Il existe √©galement des entreprises connues pour √™tre certifi√©es pour l'utilisation de l'ECC de Blackberry.  Bien s√ªr, il existe une simple m√©fiance √† l'√©gard de certaines normes du NIST, qui pourraient ou non √™tre affect√©es par la NSA ou toute autre institution de contr√¥le et de surveillance des √âtats-Unis. <br><br>  Le c√¥t√© de la mise en ≈ìuvre d'un probl√®me est une question enti√®rement diff√©rente.  En 2010, la console PlayStation 3 a subi une r√©cup√©ration de cl√© priv√©e Sony en raison d'une mauvaise mise en ≈ìuvre de l'algorithme ECDSA - elles avaient un al√©atoire statique qui rendait la fonction de trappe r√©soluble.  OpenSSL a √©galement souffert l'ann√©e suivante, cependant, corrigeant rapidement la vuln√©rabilit√© qui permettait la r√©cup√©ration d'une cl√© priv√©e √† l'aide d'une attaque temporelle, pour plus d'informations, consultez le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">document d'origine</a> . <br><br>  En 2013, lors de la conf√©rence RSA, un groupe de chercheurs a pr√©sent√© leur ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Randomly Failed!</a>  ¬ªDocument sur les vuln√©rabilit√©s de la classe Java SecureRandom.  Un an et demi plus tard, il s'agissait de portefeuilles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bitcoin</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Android</a> , cr√©√©s en utilisant pas assez de PRNG s√©curis√© cryptographiquement. <br><br>  En raison de graves vuln√©rabilit√©s en s√©rie d√©couvertes, le m√™me ao√ªt 2013, l'IETF a publi√© un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RFC 6979</a> , d√©crivant une g√©n√©ration d√©terministe de k utilis√©e dans la cr√©ation de la cl√©.  Nous pourrions dire qu'une telle mesure a r√©solu le probl√®me, mais nous ne le ferons pas - √† chaque fois que les chercheurs pourraient trouver des probl√®mes dans de nombreuses impl√©mentations en raison d'une d√©viation inutile des sp√©cifications du protocole. <br><br>  √Ä propos de la NSA.  Si vous n'avez pas entendu parler de l'histoire de Dual_EC_DRBG - r√©servez un peu de temps et lisez les articles correspondants, vous ne regretterez pas d'entrer dans les d√©tails.  Edward Snowden fait partie de cette histoire car les r√©v√©lations de 2013 ont prouv√© les soup√ßons ant√©rieurs.  Cela a entra√Æn√© la perte de confiance de nombreux cryptographes √©minents envers le NIST depuis que cette organisation a con√ßu et d√©crit de nombreuses courbes et d'autres algorithmes, sous-jacents √† l'ECDSA. <br><br>  La courbe 25519 et la fonction DH de Daniel Bernstein sont la r√©ponse √† ces deux probl√®mes et, comme nous l'avons d√©crit plus haut, une transition vers EdDSA est lente mais √©vidente.  M√™me avec les courbes NIST, aucune preuve de leur vuln√©rabilit√© n'a encore √©t√© trouv√©e et, comme nous l'avons d√©j√† mentionn√©, l'exp√©rience li√©e au hasard a √©t√© assez instructive. <br><br>  Pour conclure cette partie, nous voulons donner la citation de John von Neumann: "Quiconque tente de g√©n√©rer des nombres al√©atoires par des moyens d√©terministes vit, bien s√ªr, dans un √©tat de p√©ch√©." <br><br><h3>  Un peu de r√©f√©rence </h3><br>  Nous avons utilis√© un serveur NGINX 1.16.0 avec OpenSSL 1.1.1d pour ex√©cuter ces tests avec divers certificats.  Comme nous l'avons mentionn√© pr√©c√©demment, Let's Encrypt n'autorise actuellement que les algorithmes prime256v1 et secp384r1 pour les demandes de signature de certificat et ne fournit pas de certificats ECDSA racine et interm√©diaire, travaillant probablement sur cette fonctionnalit√© au moment o√π nous √©crivons cet article. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Type de signature</b> </td><td>  <b>Poign√©es de main par seconde</b> </td></tr><tr><td>  <b>ECDSA (prime256v1 / nistp256)</b> </td><td>  3358,6 </td></tr><tr><td>  <b>RSA 2048</b> </td><td>  972,5 </td></tr></tbody></table></div>  Comme vous pouvez le voir, pour un seul c≈ìur du processeur Intel¬Æ Xeon¬Æ Silver 4114 √† 2,20 GHz (lanc√© au troisi√®me trimestre 2017), la diff√©rence globale des performances ECDSA par rapport au RSA 2048 largement adopt√© est de 3,5x. <br><br>  Jetons maintenant un coup d'≈ìil aux r√©sultats de vitesse OpenSSL du m√™me processeur avec ECDSA et RSA. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Type de signature</b> <br></td><td>  <b>signe</b> <br></td><td>  <b>v√©rifier</b> <br></td><td>  <b>signe / sec</b> <br></td><td>  <b>v√©rifier / sec</b> <br></td></tr><tr><td>  <b>RSA 2048 bits</b> <br></td><td>  717 Œºs <br></td><td>  20,2 Œºs <br></td><td>  1393,9 <br></td><td>  49458.2 <br></td></tr><tr><td>  <b>ECDSA 256 bits (nistp256)</b> <br></td><td>  25,7 Œºs <br></td><td>  81,8 Œºs <br></td><td>  38971.6 <br></td><td>  12227.1 <br></td></tr></tbody></table></div>  Ici, nous pouvons voir une confirmation pour la th√®se donn√©e pr√©c√©demment des diff√©rents co√ªts de calcul pour les op√©rations de signe et de v√©rification d'ECC et de RSA.  Par cons√©quent, actuellement √©quip√© de TLS 1.3 ECC offre une am√©lioration significative des performances au niveau de s√©curit√© plus √©lev√©, par rapport √† RSA.  C'est la raison la plus importante pour laquelle nous, chez Qrator Labs, encourageons nos clients √† adopter ECDSA.  Avec les processeurs modernes, vous obtenez presque la diff√©rence de 5 fois en faveur de l'ECDSA. <br><br>  Si vous √™tes int√©ress√© par la fa√ßon dont votre CPU effectue des calculs cryptographiques, vous pouvez ex√©cuter une simple commande de <code>openssl speed</code> .  Les <code>-rsa</code> , <code>-ecdsa</code> et <code>-eddsa</code> vous donneraient des r√©sultats de r√©f√©rence pour les algorithmes de signature correspondants. <br><br><h3>  (Superpos√©) Futur </h3><br><img src="https://pbs.twimg.com/media/CB4sHACVEAAYMyZ?format=jpg&amp;name=large" alt="image"><br>  Cr√©dits: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">djb</a> <br><br>  Il est ironique de constater que pendant que nous pr√©parions cet article, Google a annonc√© ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">atteindre la supr√©matie quantique</a> ¬ª.  Cela signifie-t-il que nous sommes en danger en ce moment et que tout ce qui s'est d√©velopp√© jusqu'√† pr√©sent ne fournit aucun secret? <br><br>  Et bien non. <br><br>  Comme Bruce Schneier l'a √©crit dans son essai pour IEEE Security and Privacy ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cryptography after the Aliens Lands</a> ¬ª, un √©norme coup avec un ordinateur quantique suffisamment puissant pourrait √™tre port√© √† la cryptographie √† cl√© publique (asym√©trique).  La cryptographie sym√©trique serait toujours forte. <br><br>  Nous voulons citer Bruce Schneier avec ce qui suit: <br><blockquote>  Il y a un autre sc√©nario futur √† consid√©rer, un qui ne n√©cessite pas d'ordinateur quantique.  Bien qu'il existe plusieurs th√©ories math√©matiques qui sous-tendent le caract√®re unidirectionnel que nous utilisons en cryptographie, prouver la validit√© de ces th√©ories est en fait l'un des grands probl√®mes ouverts en informatique.  Tout comme il est possible pour un cryptographe intelligent de trouver une nouvelle astuce qui facilite la rupture d'un algorithme particulier, nous pourrions imaginer des extraterrestres avec une th√©orie math√©matique suffisante pour briser tous les algorithmes de cryptage.  Pour nous, aujourd'hui, c'est ridicule.  La cryptographie √† cl√© publique est une th√©orie enti√®rement num√©rique, et potentiellement vuln√©rable √† des extraterrestres plus enclins aux math√©matiques.  La cryptographie sym√©trique est tellement confuse non lin√©aire, si facile √† rendre plus complexe, et si facile √† augmenter la longueur de cl√©, que cet avenir est inimaginable.  Consid√©rez une variante AES avec un bloc de 512 bits et une taille de cl√©, et 128 tours.  √Ä moins que les math√©matiques ne soient fondamentalement diff√©rentes de notre compr√©hension actuelle, cela sera s√©curis√© jusqu'√† ce que les ordinateurs soient faits d'autre chose que de la mati√®re et occupent autre chose que de l'espace. <br><br>  Mais si l'inimaginable se produit, cela nous laisserait une cryptographie bas√©e uniquement sur la th√©orie de l'information: les blocs uniques et leurs variantes. </blockquote><br>  C'est le domaine o√π, √† l'exception de la recherche de d√©fauts de mise en ≈ìuvre, la plupart des probl√®mes peuvent √™tre trouv√©s.  S'il y a un groupe de math√©maticiens, cryptanalystes / cryptographes et ing√©nieurs informatiques bien financ√©s qui travaillent √† prouver ou √† r√©futer certains probl√®mes math√©matiques complexes extraordinaires (comme le P? = NP) et √† obtenir des r√©sultats substantiels jusqu'√† ce moment, nous pourrions avoir des ennuis.  Cependant, de telles avanc√©es dans les th√©ories de l'informatique, de l'information et de la calculabilit√© sont peu susceptibles d'√™tre cach√©es, car ce fait √©crirait les noms de leurs cr√©ateurs sur les pages de l'Histoire et, en particulier, de l'Histoire des manuels Internet, qui n'a pas de prix pour quiconque est intelligent .  Ainsi, un tel sc√©nario pourrait √™tre consid√©r√© comme presque impossible. <br><br>  Il n'est pas clair si, dans les 5 prochaines ann√©es, il y aura des succ√®s avec l'informatique quantique, bien qu'il existe d√©j√† plusieurs primitives de cryptographie consid√©r√©es comme adapt√©es au monde post-quantique: r√©seaux, bas√©s sur l'isogen√®se de la courbe elliptique supersingulaire, hachages et codes.  Pour l'instant, les sp√©cialistes de la s√©curit√© ne font que les exp√©rimenter.  Cependant, il ne fait aucun doute qu'en cas de besoin, l'humanit√© utiliserait rapidement de tels algorithmes √† grande √©chelle. <br><br>  Pour l'instant, la cryptographie bas√©e sur la courbe elliptique semble √™tre un ajustement parfait pour la prochaine d√©cennie, offrant s√©curit√© et performances. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr474810/">https://habr.com/ru/post/fr474810/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr474796/index.html">Qu'est-ce que l'Internet des objets et comment aidera-t-il les entreprises √† gagner plus?</a></li>
<li><a href="../fr474800/index.html">Performances dans .NET Core</a></li>
<li><a href="../fr474804/index.html">Progr√®s technologique russe dans le sport: interfaces neuronales, cam√©ras IP, CRM sportif et BigData √† partir d'une voiture de course</a></li>
<li><a href="../fr474806/index.html">UDP Flood de Google ou comment ne pas priver tout Youtube</a></li>
<li><a href="../fr474808/index.html">Version Rust 1.39.0: asynchrone / attente, attributs pour les param√®tres de fonction, nouvelles fonctions constantes</a></li>
<li><a href="../fr474812/index.html">Shader n'est pas magique. √âcriture de shaders dans Unity. Vertex Shaders</a></li>
<li><a href="../fr474814/index.html">Antiquit√©s: le messager de la d√©cadence ou de l'obsolescence non planifi√©e</a></li>
<li><a href="../fr474816/index.html">Projets pour animaux de compagnie - petite vie</a></li>
<li><a href="../fr474818/index.html">Y a-t-il des nombres al√©atoires dans CSS?</a></li>
<li><a href="../fr474822/index.html">WISE-PaaS - une plateforme cloud pour l'Internet industriel des objets</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>