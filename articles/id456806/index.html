<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💨 ◼️ 🎊 Satu bot dari semua kekhawatiran 🌐 👩🏿‍🤝‍👩🏾 🧓🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sampai konvensi "Tentang Perlindungan Hak-Hak Orang Tidak Manusiawi" telah diadopsi, Anda perlu menggunakan ini dan memberikan rutinitas kerja kepada ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Satu bot dari semua kekhawatiran</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dodopizzadev/blog/456806/">  Sampai konvensi "Tentang Perlindungan Hak-Hak Orang Tidak Manusiawi" telah diadopsi, Anda perlu menggunakan ini dan memberikan rutinitas kerja kepada bot.  Masuk akal untuk memulai sekarang, atau setelah 5 tahun, pemberontakan mobil akan dimulai, gugatan massal untuk menghina perasaan bot dengan tugas-tugas membosankan akan mengisi pengadilan untuk mengatur hubungan manusia-mesin.  Jadi cepatlah. <br><img src="https://habrastorage.org/webt/og/rl/mo/ogrlmoadcpzks4cxhqcjncpweyc.png"><br><blockquote>  Rutin konservatif dan metode kerja, kepatuhan pada pola yang telah mapan, berubah menjadi kebiasaan mekanis.  6 huruf. <br></blockquote><a name="habracut"></a><br>  Ada pekerjaan yang tidak ingin Anda lakukan, tetapi Anda harus melakukannya.  Artikel ini tidak akan memiliki sisipan besar dengan kode dan instruksi tentang cara membuat bot Anda dari awal.  Saya lebih baik memberi tahu Anda bagaimana proses rilis bekerja di Pizza Dodo kami, bagaimana kami mengotomatisasi dan mempercepatnya, memberikan beberapa rutinitas yang membosankan ke bot kami yang ditulis dalam C #.  Saya akan memperhatikan fungsionalitas dan logika bot.  Ini akan keren jika materi ini menginspirasi Anda untuk menulis asisten Anda yang akan membuat hidup lebih mudah bagi Anda dan kolega Anda. <br><br>  Beberapa tahun yang lalu kami merilis satu rilis sekali seminggu.  Pada Mei 2018, memiliki tingkat maksimum 147 jam untuk rilis, kami menetapkan tujuan untuk rilis setiap hari.  Sekarang minimum kami: empat jam untuk rilis, tetapi ini tidak sering terjadi.  Kami ingin memperbaiki catatan dan dapat mengurangi seluruh proses dengan menekan satu tombol. <br><br><h2>  Siklus rilis </h2><br>  Sekarang di Dodo IS, tujuh tim bergiliran merilis rilis.  Satu orang dari tim menjadi "beruntung" - relizmen.  Relizmen sebagai pilot pesawat terbang: dia memiliki banyak tuas dan perangkat yang harus dia pakai dengan terampil untuk meluncurkan pembaruan berikutnya.  Kami berpikir dan memutuskan: "Sudah waktunya untuk melakukan autopilot, dan kami lebih baik menghabiskan waktu kami pada sesuatu yang lebih menarik daripada mengisi tabel membosankan dengan statistik dan melacak uji coba otomatis." <br><br>  Jadi, untuk menjadi relisman, penting bahwa giliran datang ke tim Anda.  Agar semuanya jelas dan tidak ada yang bingung, kami menempelkan stiker dengan nama-nama tim di dinding.  Tim pelepasliaran menerima mahkota kehormatan, yang kami bergerak dengan pegangan setiap waktu. <br><br>  Setelah menerima <s>tanda</s> mahkota <s>hitam,</s> Relismain harus ingat di mana daftar langkah pelepasan berada.  Selanjutnya: diingat -&gt; ditemukan -&gt; membuat salinan dari templat dan, akhirnya, membuka daftar periksa dalam sistem Kaiten.  Kaiten adalah papan elektronik di mana dalam bentuk kartu kami menempatkan dan memantau status tugas dalam pengembangan.  Untuk pengembang baru, prosedur ini secara keseluruhan sangat tidak terlihat.  Dan bagaimana Anda tahu ke mana harus mencari lembar cek ini dan dari mana harus memulai ketika tidak ada petunjuk? <br><br>  Setelah mengumpulkan tekad kami, kami memutuskan bahwa itu sudah cukup untuk menanggungnya.  Sudah waktunya untuk memberikan beberapa rutinitas yang membosankan ke bot.  Siapa kalau bukan kita?  Kapan, jika tidak sekarang? <br><br><h2>  Apa yang berhasil kami lakukan secara otomatis </h2><br>  Keputusan telah dibuat, saatnya untuk mulai merancang autopilot kami!  Setelah menemukan API Kaiten di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://faq.kaiten.io/docs/api</a> , dengan hanya satu permintaan, kami membuat kartu untuk relizmen baru. <br><br><pre><code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//  POST     var createCardRequest = new RestRequest("https://&lt;domain&gt;.kaiten.io/api/latest/cards/", Method.POST); //     AddBasicAuth(createCardRequest); //        -      createCardRequest.AddJsonBody( new { board_id = _kaitenSettings.ReleasesBoardId, column_id = _kaitenSettings.ReleasesColumnId, lane_id = _kaitenSettings.ReleasesLaneId, title = $"release-{nextReleaseNumber}" } );</span></span></code> </pre> <br>  Sekarang kartu ini harus diserahkan kepada tim yang akan merilis kartu berikutnya. <br><br><blockquote>  Logikanya di sini adalah: <br><br><ol><li>  Rilis sebelumnya menyelesaikan rilis dengan mengetikkan perintah untuk bot di Slack. </li><li>  Bot mengambil ID Relisman di Slack dan mencari tim pengembang yang beruntung.  Untuk melakukan ini, bot berjalan melalui kelompok-kelompok pengguna Slack dan melihat di mana mereka terdiri dari yang dirilis oleh kami. </li><li>  Setelah menemukan grup, bot melihat tim mana yang akan rilis berikutnya dan mengirimkan peringatan ke obrolan umum.  Dalam pesan, bot dengan hati-hati memberikan tautan ke daftar periksa yang sudah dibuat sehingga Anda tidak pergi ke mana pun untuk itu. </li></ol></blockquote><br><img src="https://habrastorage.org/webt/ap/wh/ru/apwhrub9rb0yyjd8ypnutxgqlli.png"><br><br><img src="https://habrastorage.org/webt/1y/sb/0i/1ysb0iyt7rvotwmgeedjp82tkm8.png"><br><br>  Hebat!  Sekarang kita memiliki petunjuk apa yang harus dilakukan selanjutnya.  Kami membuka daftar periksa, lihat itu: "Buat saluran untuk rilis di Slack, undang semua tim yang perubahannya ada di rilis di sana dan cari tahu apakah mereka akan memerlukan pengujian manual."  Masih mengajarkan ini ke bot kami. <br><br>  Buka dokumentasi Slack API di sini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://api.slack.com</a> dan cari metode untuk membuat saluran di sana. <br><br><img src="https://habrastorage.org/webt/4s/pq/nj/4spqnjtah8zglsoss4xtqbp-lzq.png"><br><br>  Seperti yang Anda lihat, di Slack, seperti pada alat lain, tidak ada yang rumit.  Itu semua bermuara pada mengirim satu permintaan POST dengan dua parameter yang diperlukan (ini adalah yang berlawanan yang dikatakan diperlukan).  Dalam permintaan itu, kita perlu memberikan nama saluran yang dibuat (nama parameter) dan token otorisasi (token parameter).  Perhatikan baris "Bekerja dengan: tipe Token - pengguna, cakupan yang diperlukan - saluran: tulis". <br><br>  Slack memiliki dua jenis token: dikeluarkan pengguna untuk pengguna dan bot dikeluarkan untuk aplikasi.  Saat mengeluarkan token, kami menentukan hak apa yang akan diberikan kepada pemiliknya.  Untuk membuat saluran, kita memerlukan token pengguna (token type - user), yang memiliki hak untuk menulis saluran (saluran: tulis). <br><br><blockquote>  Saya ingin mencatat satu nuansa dari pengiriman pesan kami ke Slack.  Awalnya, kami tidak memikirkan apa yang akan kami lakukan jika terjadi kesalahan.  Kami merekrut tim di Slack, dan melakukan semua tugas yang kami masukkan ke dalamnya.  Dan apa yang akan terjadi jika pada salah satu tugas tim jatuh?  Dalam kasus kami, jawabannya adalah: "tidak ada."  Dan ini buruk.  Solusinya bagi kami adalah menulis dalam rilis obrolan tindakan apa yang saat ini dilakukan, dan jika perintah tidak selesai, laporkan kesalahan ke obrolan dan catat kesalahan tersebut. </blockquote><br>  Solusi kedua yang berhasil adalah menghubungkan database tempat kami menyimpan status eksekusi dari tindakan perintah.  Sekarang, setelah memulai rilis baru menggunakan perintah "/ startregress", kami tidak takut bahwa sesuatu akan jatuh, dan ketika Anda menyebutnya lagi, perintah akan dieksekusi dari awal untuk kedua kalinya.  Kami tidak perlu membuat saluran baru di Slack setiap kali, melakukan permintaan tarik, dll.  Kami membuat saluran di Slack - kami mencatat status eksekusi yang sukses di database dan tidak akan lagi kembali ke tindakan ini. <br><br><img src="https://habrastorage.org/webt/hb/qa/cn/hbqacnv-qupq_tztgccgathkyri.png"><br><br>  Jadi, sekarang dengan mengklik satu tombol kami membuat saluran rilis dan mengundang semua orang di sana yang tugasnya akan dirilis. <br><br>  Berikutnya adalah integrasi dengan Github dan TeamCity.  Kami bekerja di Gitflow.  Ketika kami ingin merilis, kami mengambil cabang DEV, yang berfungsi = hijau = di mana tes lulus, dan dari sana kami membuat cabang rilis. <br><br>  Untuk melakukan ini, bot kami pergi ke TeamCity, terlihat di sana untuk meluncurkan uji coba untuk cabang DEV.  Jika tesnya hijau, seperti rumput di dekat rumah, maka lanjutkan ke GitHub, buat cabang rilis dan permintaan tarik! <br><br>  Saat membuat permintaan tarik, kami perlu menambahkan deskripsi tentang perubahan yang kami lakukan.  Lalu Kaiten datang membantu kami.  Bot kami membuat kolom dengan nama rilis, mengambil tugas dari kolom DEV dan memindahkannya ke rilis.  Jadi kita tahu dan melihat apa yang akan terjadi dengan kita.  Setelah bergerak, bot menyalin nama-nama kartu dan menambahkannya ke deskripsi permintaan tarik dengan mengacu pada kartu itu sendiri.  Sekarang kita dapat melihat untuk setiap rilis tugas apa yang keluar dan, dengan membuka kartu melalui tautan, cari tahu semua detail pada tugas-tugas ini. <br><br><img src="https://habrastorage.org/webt/x3/0x/-k/x30x-klbu6uiajhs9bipupayflc.png"><br><br>  Hampir mungkin untuk dirilis, hanya untuk menguji perubahan kami secara menyeluruh.  Untuk melakukan ini, cabang rilis disebarkan ke lingkungan yang dekat dengan produksi (kami menyebutnya tahap), dan diuji setelah rilis.  Penempatan dan pengujian dirakit dalam satu pipa di TeamCity, dan tugas kami adalah meluncurkannya dan menunggu, dengan jari-jari, bahwa tes akan bekerja dengan baik.  Bot meluncurkan pipa selama dimulainya regresi. <br><br>  Biarkan saya mengingatkan Anda bahwa kami mulai dengan fakta bahwa semua ini dilakukan secara manual.  Sambil mengepalkan tinjunya, Relizmen menyalakan tautan dan alat: TeamCity, Kaiten, Slack, Github dan bukan itu saja!  Dan sekarang kami memiliki seluruh rangkaian aksi dari mana tim pertama untuk bot sudah terbentuk.  Si pembebas mengetik "/ startregress" dan, bersandar di kursinya, melihat bot kami: <br><br><ul><li>  membuat saluran di messenger </li><li>  menelepon ke sana semua orang yang Anda butuhkan </li><li>  memeriksa apakah permintaan tarik dapat dibuat </li><li>  membuat permintaan tarik dan mengisi uraiannya </li><li>  membuat kolom rilis di papan elektronik dan memindahkan kartu tugas di sana </li><li>  meluncurkan pipa yang akan melepaskan cabang rilis ke lingkungan dan menjalankan tes di sana </li></ul><br>  Kami menganalisis seluruh proses rilis, menuliskan berapa banyak waktu yang dibutuhkan setiap tahap rilis.  Ini memberikan pengembangan dan bisnis pemahaman tentang waktu yang terbuang dan apa yang menghambat kami dalam memberikan fitur baru kepada pengguna.  Kami duduk selama dua hari dan tidak bisa menjalankan tes ?!  Jadi ada yang salah dengan tes kami, Anda harus memberi mereka lebih banyak waktu dan perhatian.  Sebelumnya, melakukan tindakan daftar periksa kami, kami mengunjungi Google Sheets setidaknya 5 kali.  Setiap kali Anda memasukkan satu tanggal di sana dan mengatur waktu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mu/fq/6d/mufq6drstsaqsbrb3m6mme6piei.png"></div><br>  Oke Google, kami akan mengotomatiskan Anda juga!  Untuk bekerja dengan mudah dan mudah dengan tabel, kami menghubungkan paket nuget Google.Apis.Sheets.v4 ke proyek bot kami.  Dan kemudian semuanya terjadi dengan cara yang mirip dengan layanan lain sesuai dengan skema: kami mengirim permintaan di mana kami mengatakan apa nilai untuk dimasukkan ke sel mana.  Kueri ini terlihat seperti ini: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> void <span class="hljs-type"><span class="hljs-type">InsertEntry</span></span>(string cellAddress, string value) { <span class="hljs-comment"><span class="hljs-comment">//          - _googleSettings.SheetName        - cellAddress var range = $"{_googleSettings.SheetName}!{cellAddress}"; var valueRange = new ValueRange(); //        - value var objectsList = new List&lt;object&gt; {$"{value}"}; valueRange.Values = new List&lt;IList&lt;object&gt;&gt; {objectsList}; //    Google.Apis.Sheets.v4           SpreadsheetId var insertEntryRequest = _service.Spreadsheets.Values.Update(valueRange, _googleSettings.SpreadsheetId, range); insertEntryRequest.ValueInputOption = SpreadsheetsResource.ValuesResource.UpdateRequest.ValueInputOptionEnum.USERENTERED; insertEntryRequest.Execute(); }</span></span></code> </pre> <br>  Setelah mengatur integrasi dengan Google, kami menyiapkan perintah kedua bot "/ pembaruan" kami dan inilah fungsinya: <br><br><ul><li>  menambahkan string kosong untuk memasukkan nilai ke dalamnya </li><li>  pergi ke GitHub, terlihat ketika mereka membuat cabang rilis dan menambahkan tanggal pembuatannya ke tablet </li><li>  dari TeamCity mengambil data tentang permulaan pipa pertama dan informasi kapan pipa berhasil diselesaikan </li></ul><br>  Langkah selanjutnya adalah releaseman memutar rilis.  Sekarang perhitungannya dilakukan secara manual.  Setelah meletakkan satu negara, kami menyaksikan bagaimana pembebasan berperilaku dalam pertempuran.  Setelah memastikan bahwa semuanya baik menurut log dan alat pemantauan Kibana dan Grafana, kami mengirim negara berikutnya.  Proses ini tidak mudah untuk diotomatisasi.  Tapi di sini ada sesuatu untuk diperbaiki, meskipun tidak dengan bantuan bot.  Misalnya, sebelumnya, setiap kali kami bertanya kepada tim infrastruktur apakah mungkin untuk dirilis.  Karena ketika kami akan melakukan ini, pekerjaan lain dapat terjadi di server kami dan rilis kami akan datang dengan tidak tepat. <br><br>  Kami telah mengumpulkan rapat untuk mengoptimalkan proses rilis.  Salah satu solusinya adalah bahwa sekarang pemberi kebebasan hanya melihat status di salah satu saluran Slack, di mana infrastruktur mengirimkan izin untuk lepas landas.  Ini lebih nyaman daripada terus-menerus menanyakan hal yang sama dan dalam 90% kasus mendapatkan jawaban "Anda bisa." <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tf/mi/dc/tfmidcakdy0dn1m2q9ywvgqb9g4.png"></div><br>  Untuk beberapa alasan, hal-hal yang tampaknya elementer seperti itu tidak langsung terlintas dalam pikiran.  Terima kasih khusus harus disampaikan kepada pengembang baru di perusahaan.  Setelah datang kepada kami, cepat atau lambat mereka menjadi relismen.  Bagi orang-orang yang bekerja dengan kami untuk waktu yang lama, prosesnya tampaknya bukan sesuatu yang rumit, melainkan sesuatu yang akrab.  Anggota tim baru mengalihkan perhatian kami ke poin pertumbuhan dan mengambil bagian aktif dalam mengorganisir pekerjaan untuk perbaikan. <br><br>  Sementara itu, kita telah sampai pada tahap terakhir.  Liner rilis kami telah mendarat, hanya satu tim "/ releasecomplete" yang memisahkan kami dari yang terakhir.  Apa yang dia lakukan: <br><br><ul><li>  mergit tarik permintaan dengan rilis ke cabang utama </li><li>  menghapus cabang rilis </li><li>  membuat deskripsi rilis di github </li><li>  arsipkan saluran rilis di Slack </li><li>  memindahkan kartu-kartu di Kaiten dari kolom "release -..." ke kolom "Done" dan menghapus kolom rilis </li><li>  melewati tongkat, mengundang untuk melepaskan perintah berikutnya </li></ul><br>  Sebagai rangkuman, saya ingin Anda bertanya pada diri sendiri pertanyaan: apakah Anda memiliki proses rutin yang membosankan?  Apakah Anda masih melakukannya dengan tangan Anda?  Apa yang mencegah Anda mengakhiri ini sekali dan untuk semua?  Kumpulkan rapat, tinjau proses, buang semua yang tidak Anda butuhkan dan itu hanya menjadi ritual.  Dengan mengotomatiskan semua yang Anda butuhkan, Anda akan mulai mendapatkan kesenangan dari apa yang sakit sebelumnya, dan menabung hingga tumpukan dengan mempercepat rilis atau proses lainnya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456806/">https://habr.com/ru/post/id456806/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456790/index.html">Intisari berita PostgreSQL. Edisi No.16</a></li>
<li><a href="../id456792/index.html">Sebarkan Cluster Kubernetes di OpenStack dengan Kubespray</a></li>
<li><a href="../id456794/index.html">Arsitektur Web UI: Masa Lalu dari Kayu, Hadiah yang Aneh, dan Masa Depan yang Cerah</a></li>
<li><a href="../id456796/index.html">Svalbard - nama baru untuk proyek Have I Been Pwned sebelum dijual</a></li>
<li><a href="../id456804/index.html">Ikuti uang: bagaimana grup RTM mulai menyembunyikan alamat server C & C di dompet crypto</a></li>
<li><a href="../id456808/index.html">Cara Meningkatkan Kinerja Aplikasi Web Front-End: Lima Tips</a></li>
<li><a href="../id456810/index.html">Yang pertama. Kisah Bebas Tesla</a></li>
<li><a href="../id456812/index.html">Apa yang ada di ITMO University - festival IT, hackathons, konferensi, dan seminar terbuka</a></li>
<li><a href="../id456814/index.html">Pelajari Pemrograman Fungsional dalam Python dalam 10 Menit</a></li>
<li><a href="../id456818/index.html">Administrator sistem di perusahaan yang tidak dapat didekati. Beban makhluk yang tak tertahankan?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>