<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï° üë©üèª‚Äçüé® ‚ú® Interfaz Berkeley DB STL üâë üë∞üèº ü§ûüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr No hace mucho tiempo, para uno de mis proyectos, necesitaba una base de datos integrada que almacenara elementos clave-valor, proporcionara ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interfaz Berkeley DB STL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459862/"><p>  Hola Habr  No hace mucho tiempo, para uno de mis proyectos, necesitaba una base de datos integrada que almacenara elementos clave-valor, proporcionara soporte de transacciones y, opcionalmente, datos cifrados.  Despu√©s de una breve b√∫squeda, me encontr√© con un proyecto de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Berkeley DB</a> .  Adem√°s de las caracter√≠sticas que necesito, esta base de datos proporciona una interfaz compatible con STL que le permite trabajar con la base de datos como con un contenedor STL normal (casi normal).  En realidad, esta interfaz se discutir√° a continuaci√≥n. </p><a name="habracut"></a><br><h2 id="berkeley-db">  Berkeley db </h2><br><p>  <strong>Berkeley DB</strong> es una base de datos de c√≥digo abierto incrustada, escalable y de alto rendimiento.  Est√° disponible de forma gratuita para su uso en proyectos de <strong>c√≥digo</strong> abierto, pero para los propietarios existen limitaciones significativas.  Caracter√≠sticas soportadas: </p><br><ul><li>  transacciones </li><li>  registro de falla para la conmutaci√≥n por error </li><li>  <strong>Cifrado de</strong> datos <strong>AES</strong> </li><li>  replicaci√≥n </li><li>  √≠ndices </li><li>  herramientas de sincronizaci√≥n para aplicaciones multiproceso </li><li>  pol√≠tica de acceso: un escritor, muchos lectores </li><li>  almacenamiento en cach√© </li></ul><br><p>  As√≠ como muchos otros. </p><br><p>  Cuando se inicializa el sistema, el usuario puede especificar qu√© subsistemas usar.  Esto elimina el desperdicio de recursos en operaciones como transacciones, registros, bloqueos cuando no son necesarios. </p><br><p>  La opci√≥n de estructura de almacenamiento y acceso a datos est√° disponible: </p><br><ul><li>  <strong>Btree</strong> - implementaci√≥n de √°rbol balanceado ordenado </li><li>  <strong>Hash</strong> : implementaci√≥n de hash lineal </li><li>  <strong>Mont√≥n</strong> : utiliza un <em>archivo de mont√≥n</em> l√≥gicamente paginado para almacenamiento.  Cada entrada se identifica mediante una p√°gina y un desplazamiento dentro de ella.  El almacenamiento est√° organizado de tal manera que eliminar un registro no requiere compactaci√≥n.  Esto le permite usarlo con falta de espacio f√≠sico. </li><li>  <strong>Cola</strong> : una cola que almacena registros de una longitud fija con un n√∫mero l√≥gico como clave.  Est√° dise√±ado para una inserci√≥n r√°pida al final y es compatible con una operaci√≥n especial que elimina y devuelve una entrada del encabezado de la cola en una sola llamada. </li><li>  <strong>Recno</strong> : le permite guardar registros de longitudes fijas y variables con un n√∫mero l√≥gico como clave.  Proporciona acceso a un elemento por su √≠ndice. </li></ul><br><p>  Para evitar la ambig√ºedad, es necesario definir varios conceptos que se utilizan para describir el trabajo de <strong>Berkeley DB</strong> . </p><br><p>  <em>La base de datos</em> es un almacenamiento de <em>datos de</em> valor clave.  Un an√°logo de <em>la</em> base de datos de <strong>Berkeley DB</strong> en otros DBMS puede ser una tabla. </p><br><p>  <em>Un entorno de base de datos</em> es un contenedor para una o m√°s <em>bases de datos</em> .  Define la configuraci√≥n general para todas las <em>bases de datos</em> , como el tama√±o de la memoria cach√©, las rutas de almacenamiento de archivos, el uso y la configuraci√≥n de los subsistemas de bloqueo, transacci√≥n y registro. </p><br><p>  En un caso de uso t√≠pico, se crea y configura un <em>entorno</em> y tiene una o m√°s <em>bases de datos</em> . </p><br><h2 id="stl-interfeys">  Interfaz STL </h2><br><p>  <strong>Berkeley DB</strong> es una biblioteca escrita en <strong>C.</strong>  Tiene carpetas para lenguajes como <strong>Perl</strong> , <strong>Java</strong> , <strong>PHP</strong> y otros.  La interfaz para <strong>C ++</strong> es un contenedor sobre c√≥digo <strong>C</strong> con objetos y herencia.  Para poder acceder a la base de datos de manera similar a las operaciones con contenedores <strong>STL</strong> , hay una interfaz <strong>STL</strong> como complemento sobre <strong>C ++</strong> .  En forma gr√°fica, las capas de interfaz se ven as√≠: </p><br><p><img src="https://habrastorage.org/webt/k9/0u/gw/k90ugwajcb5xsts9zxn7e6urjew.png"></p><br><p> Entonces, la interfaz <strong>STL le</strong> permite recuperar un elemento de la base de datos por clave (para <strong>Btree</strong> o <strong>Hash</strong> ) o por √≠ndice (para <strong>Recno</strong> ) de manera similar a los contenedores <code>std::map</code> o <code>std::vector</code> , encuentre un elemento en la base de datos a trav√©s del <code>std::find_if</code> est√°ndar <code>std::find_if</code> , iterar sobre toda la base de datos a trav√©s del <code>foreach</code> .  Todas las clases y funciones de la interfaz <strong>Berkeley DB</strong> <strong>STL</strong> est√°n en el espacio de nombres <strong>dbstl</strong> , para abreviar, <strong>dbstl</strong> tambi√©n significar√° la interfaz <strong>STL</strong> . </p><br><h2 id="ustanovka">  Instalaci√≥n </h2><br><p>  La base de datos es compatible con la mayor√≠a de <strong>las</strong> <strong>plataformas</strong> <strong>Linux</strong> , <strong>Windows</strong> , <strong>Android</strong> , <strong>Apple iOS</strong> , etc. </p><br><p>  Para <strong>Ubuntu 18.04,</strong> solo instale los paquetes: </p><br><ul><li>  libdb5.3-stl-dev </li><li>  libdb5.3 ++ - dev </li></ul><br><p>  Para construir desde fuentes <strong>Linux</strong> , necesita instalar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">autoconf</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">libtool</a> .  El √∫ltimo c√≥digo fuente se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . </p><br><p>  Por ejemplo, descargu√© el archivo con la versi√≥n <strong>18.1.32</strong> - db-18.1.32.zip.  Necesita descomprimir el archivo e ir a la carpeta de origen: </p><br><pre> <code class="plaintext hljs">unzip db-18.1.32.zip cd db-18.1.32</code> </pre> <br><p>  A continuaci√≥n, nos movemos al directorio <strong>build_unix</strong> y ejecutamos el ensamblaje y la instalaci√≥n: </p><br><pre> <code class="plaintext hljs">cd build_unix ../dist/configure --enable-stl --prefix=/home/user/libraries/berkeley-db make make install</code> </pre> <br><h2 id="dobavlenie-v-cmake-proekt">  Agregando al proyecto cmake </h2><br><p>  El proyecto <strong>BerkeleyDBSamples</strong> se utiliza para ilustrar ejemplos con <strong>Berkeley DB</strong> . </p><br><p>  La estructura del proyecto es la siguiente: </p><br><pre> <code class="plaintext hljs">+-- CMakeLists.txt +-- sample-usage | +-- CMakeLists.txt | +-- sample-map-usage.cpp | +-- submodules | +-- cmake | | +-- FindBerkeleyDB</code> </pre> <br><p>  La ra√≠z <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CMakeLists.txt</a> describe los par√°metros generales del proyecto.  Los archivos fuente de muestra est√°n en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">uso de muestra</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sample-use / CMakeLists.txt</a> busca bibliotecas, define el conjunto de ejemplos. </p><br><p>  En ejemplos, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FindBerkeleyDB</a> se utiliza para conectar la biblioteca al proyecto <strong>cmake</strong> .  Se agrega como un subm√≥dulo <strong>git</strong> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">submodules / cmake</a> .  Durante el ensamblaje, es posible que deba especificar <code>BerkeleyDB_ROOT_DIR</code> .  Por ejemplo, para la biblioteca anterior instalada desde las fuentes, debe especificar el indicador <strong>cmake</strong> <code>-DBerkeleyDB_ROOT_DIR=/home/user/libraries/berkeley-db</code> . </p><br><p>  En el archivo ra√≠z <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CMakeLists.txt</a> , agregue la ruta al m√≥dulo <strong>FindBerkeleyDB</strong> a <strong>CMAKE_MODULE_PATH</strong> : </p><br><pre> <code class="plaintext hljs">list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/submodules/cmake/FindBerkeleyDB")</code> </pre> <br><p>  Despu√©s de eso, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sample-use / CMakeLists.txt</a> realiza una b√∫squeda en la biblioteca de la manera est√°ndar: </p><br><pre> <code class="plaintext hljs">find_package(BerkeleyDB REQUIRED)</code> </pre> <br><p>  A continuaci√≥n, agregue el archivo ejecutable y vinc√∫lelo a la biblioteca <strong>Oracle :: BerkeleyDB</strong> : </p><br><pre> <code class="plaintext hljs">add_executable(sample-map-usage "sample-map-usage.cpp") target_link_libraries(sample-map-usage PRIVATE Oracle::BerkeleyDB ${CMAKE_THREAD_LIBS_INIT} stdc++fs)</code> </pre> <br><h2 id="prakticheskiy-primer">  Ejemplo pr√°ctico </h2><br><p>  Para demostrar el uso de <strong>dbstl,</strong> examinemos un ejemplo simple del archivo <a href="">sample-map-use.cpp</a> .  Esta aplicaci√≥n demuestra trabajar con el <code>dbstl::db_map</code> en un programa de subproceso √∫nico.  El contenedor en s√≠ es similar a <code>std::map</code> y almacena datos como un par clave / valor.  La estructura de la base de datos subyacente puede ser <strong>Btree</strong> o <strong>Hash</strong> .  A diferencia de <code>std::map</code> , para el <code>dbstl::db_map&lt;std::string, TestElement&gt;</code> tipo de valor real es <code>dbstl::ElementRef&lt;TestElement&gt;</code> .  Este tipo se devuelve, por ejemplo, para <code>dbstl::db_map&lt;std::string, TestElement&gt;::operator[]</code> .  Define m√©todos para almacenar un objeto de tipo <code>TestElement</code> en la base de datos.  Uno de estos m√©todos es <code>operator=</code> . </p><br><p>  En el ejemplo, el trabajo con la base de datos es el siguiente: </p><br><ul><li>  la aplicaci√≥n llama a los m√©todos de <strong>Berkeley DB</strong> para acceder a los datos </li><li>  estos m√©todos acceden al cach√© para leer o escribir </li><li>  si es necesario, el acceso es directamente al archivo de datos </li></ul><br><p>  Gr√°ficamente, este proceso se muestra en la figura: </p><br><p><img src="https://habrastorage.org/webt/xm/em/or/xmemorwh73yw9mnue-h1lp0gmbo.png"></p><br><p>  Para reducir la complejidad del ejemplo, no utiliza el manejo de excepciones.  Algunos <strong>m√©todos de</strong> contenedor <strong>dbstl</strong> pueden <strong>generar</strong> excepciones cuando se producen errores. </p><br><h2 id="razbor-koda">  An√°lisis de c√≥digo </h2><br><p>  Para trabajar con <strong>Berkeley DB,</strong> debe conectar dos archivos de encabezado: </p><br><pre> <code class="plaintext hljs">#include &lt;db_cxx.h&gt; #include &lt;dbstl_map.h&gt;</code> </pre> <br><p>  El primero agrega primitivas de interfaz <strong>C ++</strong> , y el segundo define clases y funciones para trabajar con la base de datos, como con un contenedor asociativo, as√≠ como muchos m√©todos de utilidad.  <strong>La</strong> interfaz <strong>STL</strong> se encuentra en el espacio de nombres <strong>dbstl</strong> . </p><br><p>  Para el almacenamiento, se <strong>utiliza la</strong> estructura <strong>Btree</strong> , <code>std::string</code> act√∫a como la clave y el valor es la estructura de usuario <code>TestElement</code> : </p><br><pre> <code class="plaintext hljs">struct TestElement{ std::string id; std::string name; };</code> </pre> <br><p>  En la funci√≥n <code>main</code> , inicialice la biblioteca llamando a <code>dbstl::dbstl_startup()</code> .  Debe ubicarse antes del primer uso de las primitivas de la interfaz <strong>STL</strong> . </p><br><p>  Despu√©s de eso, inicializamos y abrimos <em>el entorno de la base de datos</em> en el directorio que establece la variable <code>ENV_FOLDER</code> : </p><br><pre> <code class="plaintext hljs">auto penv = dbstl::open_env(ENV_FOLDER, 0u, DB_INIT_MPOOL | DB_CREATE);</code> </pre> <br><p>  El indicador <code>DB_INIT_MPOOL</code> responsable de inicializar el subsistema de almacenamiento en cach√©, <code>DB_CREATE</code> , para crear todos los archivos necesarios para el entorno.  El equipo tambi√©n registra este objeto en el administrador de recursos.  Es responsable de cerrar todos los objetos registrados (los objetos de la base de datos, cursores, transacciones, etc. tambi√©n est√°n registrados en √©l) y borrar la memoria din√°mica.  Si ya tiene un objeto de <em>entorno de base de datos</em> y solo necesita registrarlo con el administrador de recursos, puede usar la funci√≥n <code>dbstl::register_db_env</code> . </p><br><p>  Se realiza una operaci√≥n similar con <em>la base de datos</em> : </p><br><pre> <code class="plaintext hljs">auto db = dbstl::open_db(penv, "sample-map-usage.db", DB_BTREE, DB_CREATE, 0u);</code> </pre> <br><p>  Los datos en el disco se escribir√°n en el <strong>archivo sample-map-use.db</strong> , que se crear√° en ausencia (gracias al indicador <code>DB_CREATE</code> ) en el directorio <code>ENV_FOLDER</code> .  Se utiliza un √°rbol para el almacenamiento (par√°metro <code>DB_BTREE</code> ). </p><br><p>  En <strong>Berkeley DB, las</strong> claves y los valores se almacenan como una matriz de bytes.  Para usar un tipo personalizado (en nuestro caso <code>TestElement</code> ), debe definir funciones para: </p><br><ul><li>  recibir el n√∫mero de bytes para almacenar el objeto; </li><li>  ordenar un objeto en una matriz de bytes; </li><li>  desordenar. </li></ul><br><p>  En el ejemplo, esta funcionalidad se realiza mediante los m√©todos est√°ticos de la clase <code>TestMarshaller</code> .  <code>TestElement</code> objetos <code>TestElement</code> en la memoria de la siguiente manera: </p><br><ul><li>  la longitud del campo <code>id</code> se copia al comienzo del b√∫fer </li><li>  siguiente byte se colocan los contenidos del campo <code>id</code> </li><li>  despu√©s, se copia el tama√±o del campo de <code>name</code> </li><li>  entonces el contenido en s√≠ se coloca desde el campo de <code>name</code> </li></ul><br><p><img src="https://habrastorage.org/webt/ko/ad/ul/koaduleknjbnfvapxlo6wff4qvm.png"></p><br><p>  Describimos las funciones de <code>TestMarshaller</code> : </p><br><ul><li>  <code>TestMarshaller::restore</code> - llena el objeto <code>TestElement</code> con datos del b√∫fer </li><li>  <code>TestMarshaller::size</code> : devuelve el tama√±o del b√∫fer que se necesita para guardar el objeto especificado. </li><li>  <code>TestMarshaller::store</code> - guarda el objeto en el b√∫fer. </li></ul><br><p>  Para registrar funciones <code>dbstl::DbstlElemTraits</code> / <code>dbstl::DbstlElemTraits</code> , use <code>dbstl::DbstlElemTraits</code> : </p><br><pre> <code class="plaintext hljs">dbstl::DbstlElemTraits&lt;TestElement&gt;::instance()-&gt;set_size_function(&amp;TestMarshaller::size); dbstl::DbstlElemTraits&lt;TestElement&gt;::instance()-&gt;set_copy_function(&amp;TestMarshaller::store); dbstl::DbstlElemTraits&lt;TestElement&gt;::instance()-&gt;set_restore_function( &amp;TestMarshaller::restore );</code> </pre> <br><p>  Inicializar el contenedor: </p><br><pre> <code class="plaintext hljs">dbstl::db_map&lt;std::string, TestElement&gt; elementsMap(db, penv);</code> </pre> <br><p>  As√≠ es como se ve copiar elementos de <code>std::map</code> al contenedor creado: </p><br><pre> <code class="plaintext hljs">std::copy( std::cbegin(inputValues), std::cend(inputValues), std::inserter(elementsMap, elementsMap.begin()) );</code> </pre> <br><p>  Pero de esta manera puede imprimir el contenido de la base de datos a la salida est√°ndar: </p><br><pre> <code class="plaintext hljs">std::transform( elementsMap.begin(dbstl::ReadModifyWriteOption::no_read_modify_write(), true), elementsMap.end(), std::ostream_iterator&lt;std::string&gt;(std::cout, "\n"), [](const auto data) -&gt; std::string { return data.first + "=&gt; { id: " + data.second.id + ", name: " + data.second.name + "}"; });</code> </pre> <br><p>  Llamar al m√©todo <code>begin</code> en el ejemplo anterior parece un poco inusual: <code>elementsMap.begin(dbstl::ReadModifyWriteOption::no_read_modify_write(), true)</code> . <br>  Este dise√±o se utiliza para obtener <em>un</em> iterador de <em>solo lectura</em> .  <strong>dbstl</strong> no define el m√©todo <code>cbegin</code> ; en su lugar, se utiliza el par√°metro de <code>readonly</code> (el segundo) en el m√©todo de <code>begin</code> .  Tambi√©n puede usar una <em>referencia constante</em> al contenedor para obtener <em>un</em> iterador de <em>solo lectura</em> .  Tal iterador solo permite una operaci√≥n de lectura; al escribir, arrojar√° una excepci√≥n. </p><br><p>  ¬øPor qu√© se usa el iterador de <em>solo lectura</em> en el c√≥digo anterior?  En primer lugar, <em>solo</em> realiza una operaci√≥n de lectura a trav√©s de un iterador.  En segundo lugar, la documentaci√≥n dice que tiene un <em>mejor</em> rendimiento en comparaci√≥n con la versi√≥n normal. </p><br><p>  Agregar un nuevo par clave / valor o, si la clave ya existe, actualizar el valor es tan simple como en <code>std::map</code> : </p><br><pre> <code class="plaintext hljs">elementsMap["added key 1"] = {"added id 1", "added name 1"};</code> </pre> <br><p>  Como se mencion√≥ anteriormente, la instrucci√≥n <code>elementsMap["added key 1"]</code> devuelve una clase contenedora con <code>operator=</code> redefined, cuya llamada posterior almacena directamente el objeto en la base de datos. </p><br><p>  Si necesita insertar un art√≠culo en un contenedor: </p><br><pre> <code class="plaintext hljs">auto [iter, res] = elementsMap.insert( std::make_pair(std::string("added key 2"), TestElement{"added id 2", "added name 2"}) );</code> </pre> <br><p>  La llamada a <code>elementsMap.insert</code> devuelve <code>std::pair&lt;,  &gt;</code> .  Si el objeto no se puede insertar, el <em>indicador de √©xito</em> ser√° <strong>falso</strong> .  De lo contrario, <em>el indicador de √©xito</em> contiene <strong>verdadero</strong> , y el <em>iterador</em> apunta al objeto insertado. </p><br><p>  Otra forma de encontrar el valor por clave es usar el <code>dbstl::db_map::find</code> , similar a <code>std::map::find</code> : </p><br><pre> <code class="plaintext hljs">auto findIter = elementsMap.find("test key 1");</code> </pre> <br><p>  A trav√©s del iterador obtenido, puede acceder a la clave - <code>findIter-&gt;first</code> , a los campos del elemento <code>findIter-&gt;second.id</code> - <code>findIter-&gt;second.id</code> y <code>findIter-&gt;second.name</code> .  Para extraer un par <em>clave</em> / <em>valor</em> , se utiliza el operador de referencia: <code>auto iterPair = *findIter;</code>  . </p><br><p>  Cuando el operador de desreferenciaci√≥n ( <strong>*</strong> ) o el acceso a un miembro de la clase ( <strong>-&gt;</strong> ) se aplica al iterador, se accede a la base de datos y se extraen los datos de ella.  Adem√°s, los datos extra√≠dos previamente, incluso si fueron modificados, se borran.  Esto significa que en el siguiente ejemplo, los cambios realizados en el iterador se descartar√°n y el valor almacenado en la base de datos se mostrar√° en la consola. </p><br><pre> <code class="plaintext hljs">findIter-&gt;second.id = "skipped id"; findIter-&gt;second.name = "skipped name"; std::cout &lt;&lt; "Found elem for key " &lt;&lt; "test key 1" &lt;&lt; ": id: " &lt;&lt; findIter-&gt;second.id &lt;&lt; ", name: " &lt;&lt; findIter-&gt;second.name &lt;&lt; std::endl;</code> </pre> <br><p>  Para evitar esto, debe obtener el contenedor del objeto almacenado del iterador llamando a <code>findIter-&gt;second</code> y guardarlo en una variable.  A continuaci√≥n, realice todos los cambios sobre este contenedor y escriba el resultado en la base de datos llamando al m√©todo de contenedor <code>_DB_STL_StoreElement</code> : </p><br><pre> <code class="plaintext hljs">auto ref = findIter-&gt;second; ref.id = "new test id 1"; ref.name = "new test name 1"; ref._DB_STL_StoreElement();</code> </pre> <br><p>  Actualizar los datos puede ser a√∫n m√°s f√°cil: solo obtenga el contenedor con la instrucci√≥n <code>findIter-&gt;second</code> y as√≠gnele el objeto <code>TestElement</code> deseado, como en el ejemplo: </p><br><pre> <code class="plaintext hljs">if(auto findIter = elementsMap.find("test key 2"); findIter != elementsMap.end()){ findIter-&gt;second = {"new test id 2", "new test name 2"}; }</code> </pre> <br><p>  Antes de finalizar el programa, debe llamar a <code>dbstl::dbstl_exit();</code>  para cerrar y eliminar todos los objetos registrados en el administrador de recursos. </p><br><h2 id="v-zaklyuchenii">  En conclusi√≥n </h2><br><p>  Este art√≠culo proporciona una breve descripci√≥n de las caracter√≠sticas principales de los contenedores <strong>dbstl</strong> que <strong>usan</strong> <code>dbstl::db_map</code> como <code>dbstl::db_map</code> en un programa simple de subproceso √∫nico.  Esta es solo una peque√±a introducci√≥n y no ha cubierto caracter√≠sticas como la transaccionalidad, el bloqueo, la administraci√≥n de recursos, el manejo de excepciones y la ejecuci√≥n multiproceso. </p><br><p>  No pretend√≠a describir en detalle los m√©todos y sus par√°metros, para esto es mejor consultar la documentaci√≥n correspondiente en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">interfaz C ++</a> y en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">interfaz STL</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/459862/">https://habr.com/ru/post/459862/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459844/index.html">Ping√ºino en la ventana: sobre el potencial y las perspectivas de WSL2</a></li>
<li><a href="../459850/index.html">Tecnolog√≠a de radioaficionados: c√≥mo orden√© la instalaci√≥n de una placa de circuito impreso en una f√°brica china</a></li>
<li><a href="../459852/index.html">La pr√°ctica de usar la biblioteca de loter√≠a en la aplicaci√≥n m√≥vil del banco</a></li>
<li><a href="../459858/index.html">Explorando el moderno malware Cerberus para Android</a></li>
<li><a href="../459860/index.html">Configuraci√≥n de ClickHouse para pruebas de integraci√≥n en gitlab-ci</a></li>
<li><a href="../459866/index.html">Resoluci√≥n de problemas con pwnable.kr 02 - colisi√≥n. Hash Collision</a></li>
<li><a href="../459870/index.html">Ejemplo de arquitectura Modelo-Vista-Actualizaci√≥n en F #</a></li>
<li><a href="../459872/index.html">Patton Jeff. Historias personalizadas. El arte del desarrollo √°gil de software</a></li>
<li><a href="../459874/index.html">Tienes algo que esconder</a></li>
<li><a href="../459878/index.html">7 consejos de optimizaci√≥n CSS para acelerar la carga de la p√°gina</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>