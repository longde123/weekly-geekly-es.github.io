<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ”  ğŸ™ŒğŸ¼ ğŸšŠ Panduan Kelangsungan Hidup MongoDB ğŸ“° ğŸŒ‰ ğŸ§›ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Semua startup yang baik mati dengan cepat atau tumbuh sesuai skala. Kami akan membuat model startup seperti itu, yang pertama tentang fitur, dan kemud...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Panduan Kelangsungan Hidup MongoDB</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/454748/">  Semua startup yang baik mati dengan cepat atau tumbuh sesuai skala.  Kami akan membuat model startup seperti itu, yang pertama tentang fitur, dan kemudian tentang kinerja.  Kami akan meningkatkan kinerja dengan MongoDB, solusi penyimpanan data NoSQL yang populer.  MongoDB mudah untuk memulai, dan banyak masalah memiliki solusi di luar kotak.  Namun, ketika beban meningkat, garu keluar yang tidak ada yang memperingatkan Anda tentang sebelumnya ... sampai hari ini! <br><br><img src="https://habrastorage.org/webt/oh/rq/ua/ohrquayfyh04hfgs-gareddfzlk.gif" alt="gambar"><br><br>  Pemodelan dilakukan oleh <strong>Sergey Zagursky</strong> , yang bertanggung jawab atas infrastruktur backend pada umumnya, dan MongoDB pada khususnya, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Joom</a> .  Itu juga terlihat di sisi server pengembangan MMORPG Skyforge.  Seperti yang dideskripsikan oleh Sergei sendiri, ia adalah "seorang pembuat kerucut profesional dengan dahi dan penggaruknya sendiri."  Di bawah mikroskop, sebuah proyek yang menggunakan strategi akumulasi untuk mengelola utang teknis.  Dalam versi teks <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan ini</a> di HighLoad ++, kami akan bergerak dalam urutan kronologis dari terjadinya masalah ke solusi menggunakan MongoDB. <br><a name="habracut"></a><br><h2>  Kesulitan pertama </h2><br>  Kami memodelkan sebuah startup yang membuat masalah.  Tahap pertama kehidupan - fitur diluncurkan di startup kami dan, tanpa diduga, pengguna datang.  Server MongoDB kecil-kecil kami memiliki beban yang tidak pernah kami impikan.  Tapi kami ada di cloud, kami startup!  Kami melakukan hal yang paling sederhana: lihat permintaan - oh, dan di sini kami memiliki seluruh koreksi dikurangi untuk setiap pengguna, di sini kami akan membuat indeks, kami akan menambahkan perangkat keras di sana, dan di sini kami menyimpan cache. <br>  Semuanya - kita hidup terus! <br><br><blockquote>  Jika masalah dapat diselesaikan dengan cara sederhana seperti itu, mereka harus diselesaikan dengan cara ini. </blockquote><br>  Tetapi jalur masa depan dari sebuah startup yang sukses adalah penundaan lambat dan menyakitkan dari penskalaan horizontal.  Saya akan mencoba memberikan saran tentang bagaimana cara bertahan periode ini, mendapatkan scaling dan tidak menginjak menyapu. <br><br><h2>  Perekaman lambat </h2><br>  Ini adalah salah satu masalah yang mungkin Anda temui.  Apa yang harus dilakukan jika Anda bertemu dengannya, dan metode di atas tidak membantu?  Jawab: <strong>mode jaminan</strong> <strong>daya tahan</strong> <strong>dalam MongoDB secara default</strong> .  Dalam tiga kata kerjanya seperti ini: <br><br><ul><li>  Kami sampai pada baris utama dan berkata: "Tulis!". <br></li><li>  Replika primer direkam. <br></li><li>  Setelah itu, replika sekunder dibacakan darinya dan mereka berkata primer: "Kami merekam!" <br></li></ul><br>  Pada saat sebagian besar replika sekunder melakukan ini, permintaan dianggap lengkap dan kontrol kembali ke driver dalam aplikasi.  Jaminan semacam itu memungkinkan kami untuk memastikan bahwa ketika kontrol telah kembali ke aplikasi, daya tahan tidak akan pergi ke mana pun, bahkan jika MongoDB berbaring, kecuali untuk bencana yang benar-benar mengerikan. <br><br><blockquote>  Untungnya, MongoDB adalah basis data yang memungkinkan Anda mengurangi jaminan daya tahan untuk setiap permintaan individu. </blockquote><br>  Untuk permintaan penting, kami dapat membiarkan jaminan daya tahan maksimum secara default, dan untuk beberapa permintaan kami dapat menguranginya. <br><br><h3>  Kelas Permintaan </h3><br>  Lapisan pertama jaminan yang dapat kita hapus adalah <strong>tidak menunggu konfirmasi catatan oleh sebagian besar replika</strong> .  Ini menghemat latensi, tetapi tidak menambah bandwidth.  Tetapi kadang-kadang latensi adalah yang Anda butuhkan, terutama jika cluster sedikit kelebihan beban dan replika sekunder tidak berfungsi secepat yang kami inginkan. <br><br><pre><code class="javascript hljs">{<span class="hljs-attr"><span class="hljs-attr">w</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">j</span></span>:<span class="hljs-literal"><span class="hljs-literal">true</span></span>}</code> </pre> <br>  Jika kita menulis catatan dengan jaminan seperti itu, maka pada saat kita mendapatkan kendali dalam aplikasi, kita tidak lagi tahu apakah catatan itu akan hidup setelah beberapa jenis kecelakaan.  Tapi biasanya, dia masih hidup. <br><br>  Jaminan berikutnya, yang juga memengaruhi bandwidth dan latensi, adalah <strong>menonaktifkan konfirmasi logging</strong> .  Entri jurnal tetap ditulis.  Majalah adalah salah satu mekanisme fundamental.  Jika kami mematikan konfirmasi penulisan untuk itu, maka kami tidak melakukan dua hal: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u><strong>fsync</strong></u></a> <strong>pada log</strong> dan <strong>jangan menunggu sampai selesai</strong> .  Ini dapat <strong>menghemat banyak sumber daya disk</strong> dan mendapatkan <strong>peningkatan banyak dalam throughput</strong> hanya <strong>dengan</strong> mengubah daya tahan jaminan. <br><br><pre> <code class="javascript hljs">{<span class="hljs-attr"><span class="hljs-attr">w</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">j</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span>}</code> </pre> <br>  Jaminan daya tahan yang paling ketat adalah <strong>menonaktifkan segala pengakuan</strong> .  Kami hanya akan menerima konfirmasi bahwa permintaan telah mencapai replika utama.  Ini akan menghemat latensi dan tidak meningkatkan throughput dengan cara apa pun. <br><br><pre> <code class="javascript hljs">{<span class="hljs-attr"><span class="hljs-attr">w</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">j</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span>} â€”   .</code> </pre> <br>  Kami juga akan menerima berbagai hal lain, misalnya, rekaman gagal karena konflik dengan kunci unik. <br><br><h3>  Operasi apa yang berlaku untuk ini? </h3><br>  Saya akan memberi tahu Anda tentang aplikasi ke pengaturan di Joom.  Selain beban dari pengguna, di mana tidak ada konsesi daya tahan, ada beban yang dapat digambarkan sebagai beban batch latar belakang: memperbarui, menghitung kembali peringkat, mengumpulkan data analitik. <br><br>  Operasi latar belakang ini bisa memakan waktu berjam-jam, tetapi dirancang sedemikian rupa sehingga jika istirahat, misalnya, backend macet, mereka tidak akan kehilangan hasil dari semua pekerjaan mereka, tetapi akan dilanjutkan dari titik di masa lalu.  Mengurangi jaminan daya tahan berguna untuk tugas-tugas seperti itu, terutama karena fsync dalam log, seperti operasi lainnya, akan meningkatkan latensi juga untuk membaca. <br><br><h2>  Baca penskalaan </h2><br>  Masalah selanjutnya adalah <strong>bandwidth membaca tidak cukup</strong> .  Ingatlah bahwa di cluster kami tidak hanya replika primer, tetapi juga replika sekunder <strong>yang dapat Anda baca</strong> .  Ayo lakukan. <br><br>  Anda bisa membaca, tetapi ada nuansa.  Data sedikit usang akan datang dari replika sekunder - dengan 0,5-1 detik.  Dalam kebanyakan kasus, ini normal, tetapi perilaku replika sekunder berbeda dari perilaku replika primer. <br><br>  Pada sekunder, ada proses menggunakan oplog, yang bukan pada replika primer.  Proses ini tidak dirancang untuk latensi rendah - hanya pengembang MongoDB tidak peduli dengan ini.  Dalam kondisi tertentu, proses penggunaan oplog dari primer ke sekunder dapat menyebabkan keterlambatan hingga 10 detik. <br><br><blockquote>  Replika sekunder tidak cocok untuk permintaan pengguna - pengalaman pengguna mengambil langkah cepat ke tempat sampah. </blockquote><br>  Pada cluster yang tidak diarsir, paku ini kurang terlihat, tetapi masih ada.  Cluster shard menderita karena oplog sangat dipengaruhi oleh penghapusan, dan <strong>penghapusan adalah bagian dari pekerjaan penyeimbang</strong> .  Penyeimbang andal, dengan penuh rasa menghapus dokumen oleh puluhan ribu dalam waktu singkat. <br><br><h2>  Jumlah koneksi </h2><br>  Faktor selanjutnya yang harus dipertimbangkan adalah <strong>batas jumlah koneksi pada instance MongoDB</strong> .  Secara default, tidak ada batasan, <strong>kecuali sumber daya OS -</strong> Anda dapat terhubung saat memungkinkan. <br><br>  Namun, semakin banyak permintaan bersamaan, semakin lambat mereka berjalan.  <strong>Kinerja menurun secara nonlinier</strong> .  Karena itu, jika lonjakan permintaan datang kepada kami, lebih baik melayani 80% daripada tidak melayani 100%.  Jumlah koneksi harus dibatasi langsung ke MongoDB. <br><br>  Tetapi ada bug yang dapat menyebabkan masalah karena ini.  Secara khusus, <strong>kumpulan koneksi di sisi MongoDB adalah umum untuk koneksi intracluster pengguna dan layanan</strong> .  Jika aplikasi "memakan" semua koneksi dari kumpulan ini, maka integritas dapat dilanggar di cluster. <br><br>  Kami belajar tentang ini ketika kami akan membangun kembali indeks, dan karena kami perlu menghapus keunikan dari indeks, prosedur melewati beberapa tahap.  Di MongoDB, Anda tidak dapat membangun di sebelah indeks sama, tetapi tanpa keunikan.  Karena itu, kami ingin: <br><br><ul><li>  Bangun indeks serupa tanpa keunikan <br></li><li>  hapus indeks dengan keunikan; <br></li><li>  Buat indeks tanpa keunikan alih-alih jarak jauh; <br></li><li>  hapus sementara. <br></li></ul><br>  Ketika indeks sementara masih diselesaikan pada urutan kedua, kami mulai menghapus indeks unik.  Pada titik ini, MongoDB sekunder mengumumkan kuncinya.  Beberapa metadata diblokir, dan sebagian besar semua catatan berhenti: mereka menggantung di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>kolam koneksi</u></a> dan menunggu mereka untuk mengonfirmasi bahwa catatan telah berlalu.  Semua bacaan di sekunder juga berhenti karena log global ditangkap. <br><br>  Cluster dalam keadaan yang menarik juga kehilangan konektivitasnya.  Kadang-kadang muncul dan ketika dua komentar saling terhubung, mereka mencoba membuat pilihan di negara mereka yang tidak bisa mereka buat, karena mereka memiliki kunci global. <br><br><blockquote>  Moral cerita: jumlah koneksi harus dipantau. </blockquote><br>  Ada penyapu MongoDB yang terkenal, yang masih sering diserang sehingga saya memutuskan untuk berjalan-jalan di atasnya. <br><br><h2>  Jangan kehilangan dokumen </h2><br>  Jika Anda mengirim permintaan dengan indeks ke MongoDB, maka <strong>permintaan tersebut mungkin tidak mengembalikan semua dokumen</strong> yang memenuhi syarat, dan dalam kasus yang sama sekali tidak terduga.  Hal ini disebabkan oleh fakta bahwa ketika kita pergi ke awal indeks, dokumen, yang pada akhirnya, pindah ke awal untuk dokumen-dokumen yang kami lewati.  Ini semata <strong>-</strong> mata disebabkan <strong>oleh mutabilitas indeks</strong> .  Untuk iterasi yang andal, gunakan <strong>indeks pada bidang yang</strong> tidak <strong>stabil</strong> dan tidak akan ada kesulitan. <br>  MongoDB memiliki pandangan sendiri tentang indeks mana yang akan digunakan.  Solusinya sederhana - <strong>dengan bantuan $ hint, kami memaksa MongoDB untuk menggunakan indeks yang kami tentukan</strong> . <br><br><h2>  Ukuran Koleksi </h2><br>  Startup kami sedang berkembang, ada banyak data, tetapi saya tidak ingin menambahkan disk - kami telah menambahkan tiga kali dalam sebulan terakhir.  Mari kita lihat apa yang disimpan dalam data kita, lihat ukuran dokumen.  Bagaimana memahami di mana dalam koleksi Anda dapat mengurangi ukuran?  Menurut dua parameter. <br><br><ul><li>  <strong>Ukuran</strong> <strong>dokumen tertentu</strong> untuk dimainkan dengan panjangnya: <code>Object.bsonsize()</code> ; <br></li><li>  <strong>Menurut</strong> <strong>ukuran</strong> <strong>rata-rata</strong> <strong>dokumen dalam</strong> <strong>koleksi</strong> : <code>db.c.stats().avgObjectSize</code> . <br></li></ul><br><h3>  Bagaimana cara memengaruhi ukuran dokumen? </h3><br>  Saya punya jawaban tidak spesifik untuk pertanyaan ini.  Pertama, <strong>nama bidang yang panjang menambah ukuran dokumen.</strong>  Di setiap dokumen, semua nama bidang disalin, jadi jika dokumen memiliki nama bidang yang panjang, maka ukuran nama harus ditambahkan ke ukuran setiap dokumen.  Jika Anda memiliki koleksi dengan sejumlah besar dokumen kecil di beberapa bidang, maka beri nama bidang dengan nama pendek: "A", "B", "CD" - maksimal dua huruf.  <strong>Pada disk, ini diimbangi dengan kompresi</strong> , tetapi semuanya disimpan dalam cache apa adanya. <br><br>  Kiat kedua adalah bahwa kadang-kadang <strong>beberapa bidang dengan kardinalitas rendah dapat ditempatkan atas nama koleksi</strong> .  Misalnya, bidang seperti itu mungkin bahasa.  Jika kami memiliki koleksi dengan terjemahan ke dalam bahasa Rusia, Inggris, Prancis, dan bidang dengan informasi tentang bahasa yang disimpan, nilai bidang ini dapat dimasukkan dalam nama koleksi.  Jadi kita akan <strong>mengurangi ukuran dokumen</strong> dan dapat <strong>mengurangi jumlah dan ukuran indeks</strong> - penghematan <strong>semata</strong> !  Ini tidak selalu dapat dilakukan, karena kadang-kadang ada indeks di dalam dokumen yang tidak akan berfungsi jika koleksi dibagi menjadi koleksi yang berbeda. <br><br>  Kiat terakhir pada ukuran dokumen - <strong>gunakan bidang _id</strong> .  Jika data Anda memiliki kunci unik alami, letakkan langsung di id_field.  Bahkan jika kuncinya adalah komposit - gunakan id komposit.  Itu diindeks sempurna.  Hanya ada satu penggaruk kecil - jika marshaller Anda kadang-kadang mengubah urutan bidang, maka id dengan nilai bidang yang sama, tetapi dengan urutan yang berbeda akan dianggap id berbeda dalam hal indeks unik di MongoDB.  Dalam beberapa kasus, ini bisa terjadi di Go. <br><br><h2>  Ukuran Indeks </h2><br>  <strong>Indeks menyimpan salinan bidang yang disertakan di dalamnya</strong> .  Ukuran indeks terdiri dari data yang diindeks.  Jika kami mencoba untuk mengindeks bidang yang besar, maka bersiaplah untuk ukuran indeks menjadi besar. <br><br>  Momen kedua sangat mengembang indeks: <strong>bidang array dalam indeks kalikan bidang lain dari dokumen dalam indeks ini</strong> .  Hati-hati dengan array besar dalam dokumen: jangan mengindeks sesuatu yang lain ke array, atau bermain-main dengan urutan bidang dalam indeks terdaftar. <br><br>  <strong>Urutan bidang penting</strong> , <strong>terutama jika salah satu bidang indeks adalah array</strong> .  Jika bidang berbeda dalam kardinalitas, dan dalam satu bidang jumlah nilai yang mungkin sangat berbeda dari jumlah nilai yang mungkin di bidang lain, maka masuk akal untuk membangunnya dengan meningkatkan kardinalitas.  <strong>Anda dapat dengan mudah menyimpan 50% dari ukuran indeks jika Anda bertukar bidang dengan kardinalitas berbeda.</strong>  Permutasi bidang dapat memberikan pengurangan ukuran yang lebih signifikan. <br><br>  Terkadang, ketika bidang berisi nilai yang besar, kita tidak perlu membandingkan nilai ini lebih atau kurang, melainkan perbandingan kesetaraan yang jelas.  Kemudian <strong>indeks pada bidang dengan konten berat</strong> dapat <strong>diganti dengan indeks pada hash dari bidang ini</strong> .  Salinan hash akan disimpan dalam indeks, bukan salinan dari bidang ini. <br><br><h2>  Hapus dokumen </h2><br>  Saya sudah menyebutkan bahwa menghapus dokumen adalah operasi yang tidak menyenangkan dan <strong>lebih baik tidak menghapus jika memungkinkan.</strong>  Saat merancang skema data, cobalah untuk mempertimbangkan meminimalkan penghapusan data individual atau menghapus seluruh koleksi.  mereka dapat dihapus dengan seluruh koleksi.  Menghapus koleksi adalah operasi yang murah, dan menghapus ribuan dokumen individual adalah operasi yang sulit. <br><br>  Jika Anda masih perlu menghapus banyak dokumen, pastikan untuk <strong>melakukan pembatasan</strong> , jika tidak, penghapusan massal dokumen akan memengaruhi latensi pembacaan dan itu akan menjadi tidak menyenangkan.  Ini sangat buruk untuk latensi pada tingkat menengah. <br><br>  Layak untuk membuat semacam "pena" untuk mengaktifkan pelambatan - sangat sulit untuk mengambil level pertama kali.  Kami telah melaluinya berkali-kali sehingga pelambatan diperkirakan dari ketiga, keempat kalinya.  Awalnya, pertimbangkan kemungkinan pengetatan itu. <br><br>  <strong>Jika Anda menghapus lebih dari 30% dari koleksi besar, maka transfer dokumen langsung ke koleksi tetangga</strong> , dan hapus koleksi lama secara keseluruhan.  Jelas bahwa ada nuansa, karena beban dialihkan dari yang lama ke koleksi baru, tetapi bergeser jika mungkin. <br><br>  Cara lain untuk menghapus dokumen adalah indeks <strong>TTL</strong> , yang merupakan indeks yang mengindeks bidang yang berisi cap waktu Mongo, yang berisi tanggal dokumen meninggal.  Saat ini tiba, MongoDB akan menghapus dokumen ini secara otomatis. <br><br>  Indeks TTL nyaman, tetapi <strong>tidak ada pelambatan dalam implementasi.</strong>  MongoDB tidak peduli tentang cara menghapus penghapusan ini.  Jika Anda mencoba untuk menghapus sejuta dokumen secara bersamaan, selama beberapa menit Anda akan memiliki sebuah cluster yang tidak dapat dioperasi yang hanya berurusan dengan penghapusan dan tidak lebih.  Untuk mencegah hal ini terjadi, tambahkan beberapa <strong>keacakan</strong> , <strong>sebarkan TTL</strong> sebanyak logika bisnis Anda dan efek khusus pada latensi memungkinkan.  Mengolesi TTL sangat penting jika Anda memiliki alasan logika bisnis alami yang memusatkan penghapusan pada satu titik waktu. <br><br><h2>  Sharding </h2><br>  Kami mencoba menunda saat ini, tetapi itu telah datang - kami masih harus skala secara horizontal.  Untuk MongoDB, ini sangat buruk. <br><br><blockquote>  Jika Anda ragu perlu sharding, maka Anda tidak membutuhkannya. </blockquote><br>  Sharding memperumit kehidupan pengembang dan devops dalam berbagai cara.  Dalam sebuah perusahaan, kami menyebutnya pajak sharding.  Ketika kami membuang koleksi, <strong>kinerja spesifik dari koleksi berkurang</strong> : MongoDB membutuhkan indeks terpisah untuk sharding, dan parameter tambahan harus diteruskan ke permintaan sehingga dapat dieksekusi lebih efisien. <br><br>  Beberapa hal beling tidak berfungsi dengan baik.  Misalnya, adalah ide yang buruk untuk menggunakan kueri dengan <code>skip</code> , terutama jika Anda memiliki banyak dokumen.  Anda memberi perintah: "Lewati 100.000 dokumen." <br><br>  MongoDB berpikir seperti ini: "Pertama, kedua, ketiga ... seratus ribu, mari kita melangkah lebih jauh.  Dan kami akan mengembalikan ini kepada pengguna. " <br><br>  Dalam koleksi yang tidak dibagi, MongoDB akan melakukan operasi di suatu tempat di dalam dirinya sendiri.  Dalam shard-like - dia benar-benar membaca dan mengirim semua 100.000 dokumen ke proxy sharding - dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><u>mongo</u></a> , yang sudah di sisinya entah bagaimana akan menyaring dan membuang 100.000 yang pertama. Fitur yang tidak menyenangkan untuk diingat. <br><br>  <strong>Kode pasti akan menjadi lebih rumit dengan sharding - Anda</strong> harus menyeret kunci sharding ke banyak tempat.  Ini tidak selalu nyaman, dan tidak selalu mungkin.  Beberapa pertanyaan akan disiarkan atau multicast, yang juga tidak menambah skalabilitas.  Datanglah ke pilihan kunci di mana sharding akan lebih akurat. <br><br>  <strong>Dalam koleksi beling, operasi <code>count</code> rusak</strong> .  Dia mulai mengembalikan nomor lebih banyak daripada kenyataan - dia bisa berbohong 2 kali.  Alasannya terletak pada proses penyeimbangan, ketika dokumen dituangkan dari satu beling ke beling yang lain.  Ketika dokumen-dokumen dituangkan ke beling tetangga, tetapi belum dihapus pada yang asli, <code>count</code> tetap <code>count</code> .  Pengembang MongoDB tidak menyebut ini bug - ini adalah fitur seperti itu.  Saya tidak tahu apakah mereka akan memperbaikinya atau tidak. <br><br>  <strong>Cluster yang dikocok jauh lebih sulit untuk dikelola</strong> .  Devops akan berhenti menyapa Anda, karena proses menghapus cadangan menjadi lebih rumit.  Ketika beling, kebutuhan untuk otomatisasi infrastruktur berkedip seperti alarm kebakaran - sesuatu yang bisa Anda lakukan tanpa sebelumnya. <br><br><h3>  Cara kerja sharding di MongoDB </h3><br>  Ada koleksi, kami ingin entah bagaimana menyebarkannya di sekitar pecahan.  Untuk melakukan ini, <strong>MongoDB membagi koleksi menjadi potongan</strong> menggunakan kunci beling, mencoba untuk membaginya menjadi potongan yang sama di ruang kunci beling.  Berikutnya adalah penyeimbang, yang rajin <strong>memetakan potongan-potongan ini sesuai dengan pecahan di cluster</strong> .  Selain itu, penyeimbang tidak peduli berapa berat potongan-potongan ini dan berapa banyak dokumen di dalamnya, karena penyeimbangan dilakukan sepotong demi sepotong. <br><br><h2>  Kunci Sharding </h2><br>  Apakah Anda masih memutuskan apa yang harus beling?  Nah, pertanyaan pertama adalah bagaimana memilih kunci sharding.  Kunci yang baik memiliki beberapa parameter: <strong>kardinalitas tinggi</strong> , <strong>tidak stabil</strong> dan <strong>cocok dengan permintaan yang sering</strong> . <br><br>  Pilihan alami dari kunci sharding adalah kunci utama - bidang id.  Jika bidang id cocok untuk sharding, maka lebih baik untuk shard langsung di atasnya.  Ini adalah pilihan yang sangat baik - ia memiliki kardinalitas yang baik, ia tidak stabil, tetapi seberapa baik ia cocok dengan permintaan yang sering adalah kekhasan bisnis Anda.  Bangun situasi Anda. <br><br>  Saya akan memberikan contoh kunci sharding yang gagal.  Saya sudah menyebutkan koleksi terjemahan - terjemahan.  Ini memiliki bidang bahasa yang menyimpan bahasa.  Sebagai contoh, koleksi mendukung 100 bahasa dan kami shard bahasa.  Ini buruk - kardinalitas, jumlah nilai yang mungkin hanya 100 buah, yang kecil.  Tapi ini bukan yang terburuk - mungkin kardinalitas sudah cukup untuk tujuan ini.  Lebih buruk lagi, segera setelah kami beralih ke bahasa lain, kami segera mengetahui bahwa kami memiliki pengguna yang berbahasa Inggris 3 kali lebih banyak daripada yang lain.  Tiga kali lebih banyak permintaan datang ke pecahan malang di mana bahasa Inggris berada daripada gabungan semua yang lain. <br><br>  Oleh karena itu, harus diingat bahwa kadang-kadang kunci beling secara alami cenderung distribusi beban yang tidak merata. <br><br><h3>  Menyeimbangkan </h3><br>  Kami datang ke sharding ketika kebutuhan telah matang untuk kami - MongoDB cluster kami berderit, berderak dengan disk, prosesor - dengan segala yang kami bisa.  Kemana harus pergi?  Tidak ada tempat, dan kami dengan gagah mengocok tumit koleksi.  Kami pecahan, peluncuran, dan tiba-tiba mengetahui bahwa <strong>menyeimbangkan tidak gratis</strong> . <br><br>  Penyeimbangan melewati beberapa tahap.  Penyeimbang memilih potongan dan pecahan, dari mana dan di mana ia akan ditransfer.  Pekerjaan lebih lanjut berjalan dalam dua fase: pertama, <strong>dokumen disalin</strong> dari sumber ke target, dan kemudian dokumen yang disalin <strong>dihapus</strong> . <br><br>  Shard kami kelebihan beban, berisi semua koleksi, tetapi bagian pertama dari operasi mudah baginya.  Tapi yang kedua - penghapusan - cukup tidak menyenangkan, karena akan membuat beling di bahu dan sudah menderita beban. <br><br>  Masalahnya diperparah oleh fakta bahwa jika kita menyeimbangkan banyak potongan, misalnya ribuan, maka dengan pengaturan default semua potongan ini pertama kali disalin, dan kemudian sebuah remover masuk dan mulai menghapusnya secara massal.  Pada titik ini, prosedur tidak lagi terpengaruh dan Anda hanya perlu menonton dengan sedih apa yang terjadi. <br><br>  Oleh karena itu, jika Anda mendekati untuk beling cluster yang kelebihan beban, Anda perlu merencanakan, karena <strong>menyeimbangkan membutuhkan waktu.</strong>  Dianjurkan untuk mengambil waktu ini bukan pada waktu prime time, tetapi pada periode beban rendah.  Balancer - suku cadang terputus.  Anda dapat mendekati penyeimbang utama dalam mode manual, mematikan penyeimbang di waktu tayang utama, dan menyalakannya ketika beban telah menurun untuk memungkinkan Anda lebih banyak. <br><br>  Jika kemampuan cloud masih memungkinkan Anda untuk skala secara vertikal, yang terbaik adalah meningkatkan sumber beling terlebih dahulu untuk sedikit mengurangi semua efek khusus ini. <br><br>  <b>Sharding harus disiapkan dengan hati-hati.</b> <br><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HighLoad ++ Siberia 2019</a> akan hadir di Novosibirsk pada 24 dan 25 Juni.  HighLoad ++ Siberia adalah kesempatan bagi pengembang dari Siberia untuk mendengarkan laporan, berbicara tentang topik-topik yang penuh muatan dan terjun ke lingkungan "di mana setiap orang memiliki milik mereka sendiri", tanpa terbang lebih dari tiga ribu kilometer ke Moskow atau St. Petersburg.  Dari 80 aplikasi, Komite Program menyetujui 25, dan kami memberi tahu tentang semua perubahan lain dalam program, pengumuman laporan dan berita lainnya di milis kami.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berlangganan</a> untuk tetap mendapat informasi. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id454748/">https://habr.com/ru/post/id454748/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id454736/index.html">Dukungan Visual Studio 2019 di PVS-Studio</a></li>
<li><a href="../id454738/index.html">Dukungan Visual Studio 2019 dalam PVS-Studio</a></li>
<li><a href="../id454740/index.html">Mei 2019 Pencernaan Joomla</a></li>
<li><a href="../id454742/index.html">Setidaknya satu trik Vim yang tidak Anda ketahui</a></li>
<li><a href="../id454744/index.html">Tinjauan Java Track Reports dari RigaDevDays Conference</a></li>
<li><a href="../id454750/index.html">UI cepat - berlari kencang di seluruh Eropa</a></li>
<li><a href="../id454754/index.html">Kapan perlu memeriksa hipotesis efektivitas yang tidak kalah pentingnya?</a></li>
<li><a href="../id454756/index.html">Memeriksa efektivitas pengaturan situs dan iklan, biaya menarik pelanggan dari perusahaan grosir</a></li>
<li><a href="../id454758/index.html">Bepergian Windows Defender dengan murah dan ceria: mengaburkan Mimikatz</a></li>
<li><a href="../id454760/index.html">Intel Optane Memory M15 - Lebih Cepat Dari M10</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>