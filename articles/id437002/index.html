<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍⚕️ 🎿 🍐 Inti ASP.NET yang valid 🙇🏻 ⏲️ 🤙🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Khusus untuk pecinta buku dari seri "C ++ dalam 24 jam", saya memutuskan untuk menulis artikel tentang ASP.NET Core. 


 Jika Anda belum mengembangkan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Inti ASP.NET yang valid</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437002/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/sy/y_/ph/syy_ph0f1cwt9upm9frbr6z5ggi.jpeg" alt="Inti ASP.NET yang valid"></a> </p><br><p>  Khusus untuk pecinta buku dari seri "C ++ dalam 24 jam", saya memutuskan untuk menulis artikel tentang ASP.NET Core. </p><br><p>  Jika Anda belum mengembangkan di bawah. NET atau di bawah platform serupa sebelumnya, maka tidak masuk akal untuk memotong Anda.  Tetapi jika Anda tertarik untuk mempelajari apa yang IoC, DI, DIP, Interseptors, Middleware, Filter (yaitu, segala sesuatu yang berbeda dari Core dari .NET klasik), maka Anda pasti perlu mengklik "Baca lebih lanjut", karena Anda sedang mengembangkan Tanpa memahami semua ini, itu jelas tidak benar. </p><a name="habracut"></a><br><h2 id="ioc-di-dip">  IoC, DI, DIP </h2><br><p>  Jika teater dimulai dengan gantungan, maka ASP.NET Core mulai dengan Injeksi Ketergantungan.  Untuk menghadapi DI, Anda perlu memahami apa itu IoC. </p><br><p>  Berbicara tentang IoC, orang sering mengingat prinsip Hollywood, "Jangan panggil kami, kami akan menghubungi Anda."  Yang berarti "Tidak perlu memanggil kami, kami akan memanggil Anda sendiri." </p><br><p> Sumber yang berbeda memberikan pola yang berbeda di mana IoC dapat diterapkan.  Dan kemungkinan besar mereka baik-baik saja dan hanya saling melengkapi.  Berikut adalah beberapa pola ini: pabrik, pencari lokasi, metode templat, pengamat, strategi. </p><br><p>  Mari kita lihat IoC menggunakan aplikasi konsol sederhana sebagai contoh. </p><br><p>  Misalkan kita memiliki dua kelas sederhana yang mengimplementasikan antarmuka dengan satu metode: </p><br><pre><code class="plaintext hljs">class ConsoleLayer : ILayer { public void Write(string text) { Console.WriteLine(text); } } class DebugLayer : ILayer { public void Write(string text) { Debug.WriteLine(text); } } interface ILayer { void Write(string text); }</code> </pre> <br><p>  Keduanya bergantung pada abstraksi (dalam hal ini, antarmuka bertindak sebagai abstraksi). </p><br><p>  Dan katakanlah kita memiliki objek level yang lebih tinggi menggunakan kelas-kelas ini: </p><br><pre> <code class="plaintext hljs"> class Logging : ILayer { private ILayer _instance; public Logging(int i) { if (i == 1) { _instance = new ConsoleLayer(); } else { _instance = new DebugLayer(); } } public void Write(string text) { _instance.Write(text); } }</code> </pre> <br><p>  Bergantung pada parameter konstruktor, variabel _instance diinisialisasi oleh kelas tertentu.  Baik dan selanjutnya, saat memanggil Write, output ke konsol atau ke Debug akan selesai.  Segalanya tampak cukup baik dan bahkan, tampaknya, sesuai dengan bagian pertama dari prinsip Ketergantungan Inversi </p><br><blockquote>  Objek tingkat tinggi tidak tergantung pada objek tingkat bawah.  Baik itu dan mereka tergantung pada abstraksi. </blockquote><p>  Dalam kasus kami, ILayer bertindak sebagai abstraksi. </p><br><p>  Tetapi kita juga harus memiliki objek yang levelnya lebih tinggi.  Salah satu yang menggunakan kelas Logging </p><br><pre> <code class="plaintext hljs"> static void Main(string[] args) { var log = new Logging(1); log.Write("Hello!"); Console.Read(); }</code> </pre> <br><p>  Dengan menginisialisasi Logging dengan 1, kita mendapatkan kelas Logging sebuah instance dari kelas yang menampilkan data ke konsol.  Jika kita menginisialisasi Pencatatan dengan nomor lain, maka log. Menulis akan menampilkan data ke Debug.  Segala sesuatu, tampaknya, berfungsi, tetapi itu bekerja dengan buruk.  Objek tingkat tinggi kami Utama tergantung pada detail kode objek tingkat bawah - kelas Logging.  Jika kita mengubah sesuatu di kelas ini, maka kita perlu mengubah kode kelas Utama.  Untuk mencegah hal ini terjadi, kami akan membuat inversi kontrol - Pembalikan Kontrol.  Mari kita buat kontrol kelas Utama apa yang terjadi di kelas Logging.  Kelas Logging akan menerima, sebagai parameter konstruktor, instance dari kelas yang mengimplementasikan antarmuka ILayer </p><br><pre> <code class="plaintext hljs"> class Logging { private ILayer _instance; public Logging(ILayer instance) { _instance = instance; } public void Write(string text) { _instance.Write(text); } }</code> </pre> <br><p>  Dan sekarang, kelas Utama kita akan terlihat seperti ini: </p><br><pre> <code class="plaintext hljs"> static void Main(string[] args) { var log = new Logging(new DebugLayer()); log.Write("Hello!"); Console.Read(); }</code> </pre> <br><p>  Faktanya, kita menghias objek Logging kita dengan objek yang diperlukan untuk kita. </p><br><p>  Sekarang aplikasi kita mematuhi bagian kedua dari prinsip Ketergantungan Inversi: </p><br><blockquote>  Abstraksi tidak tergantung pada detail.  Detail tergantung pada abstraksi.  Yaitu  kami tidak tahu detail tentang apa yang terjadi di kelas Penebangan, kami hanya melewati kelas di sana yang mengimplementasikan abstraksi yang diperlukan. </blockquote><p>  Ada istilah kopling ketat - koneksi ketat.  Semakin lemah koneksi antara komponen-komponen dalam aplikasi, semakin baik.  Saya ingin mencatat bahwa contoh aplikasi sederhana ini tidak mencapai yang ideal sedikit pun.  Mengapa  Ya, karena di kelas level tertinggi di Utama, kami dua kali menggunakan pembuatan instance kelas menggunakan yang baru.  Dan ada ungkapan mnemonik seperti "Baru adalah petunjuk" - yang berarti semakin sedikit Anda menggunakan yang baru, koneksi komponen yang kurang ketat dalam aplikasi dan semakin baik.  Idealnya, kita tidak boleh menggunakan DebugLayer baru, tetapi harus mendapatkan DebugLayer dengan cara lain.  Yang mana  Misalnya, dari wadah IoC atau menggunakan refleksi dari parameter yang diteruskan ke Utama. </p><br><p>  Sekarang kami telah menemukan apa Inversion of Control (IoC) itu dan apa Dependency Inversion (DIP) itu.  Masih memahami apa Injeksi Ketergantungan (DI).  IoC adalah paradigma desain.  Ketergantungan Injeksi adalah sebuah pola.  Inilah yang sekarang kita miliki dalam konstruktor kelas Logging.  Kami mendapatkan contoh ketergantungan tertentu.  Kelas Logging tergantung pada instance kelas yang mengimplementasikan ILayer.  Dan contoh ini disuntikkan melalui konstruktor. </p><br><h2 id="ioc-container">  Wadah IOC </h2><br><p>  Kontainer IoC adalah objek yang mengandung banyak dependensi spesifik (dependensi).  Ketergantungan dapat disebut layanan - sebagai aturan itu adalah kelas dengan fungsi tertentu.  Jika perlu, ketergantungan dari jenis yang diperlukan dapat diperoleh dari wadah.  Menyuntikkan ketergantungan ke wadah adalah Menyuntikkan.  Ekstrak - Putuskan.  Berikut adalah contoh wadah IoC yang ditulis sendiri paling sederhana: </p><br><pre> <code class="plaintext hljs"> public static class IoCContainer { private static readonly Dictionary&lt;Type, Type&gt; _registeredObjects = new Dictionary&lt;Type, Type&gt;(); public static dynamic Resolve&lt;TKey&gt;() { return Activator.CreateInstance(_registeredObjects[typeof(TKey)]); } public static void Register&lt;TKey, TConcrete&gt;() where TConcrete : TKey { _registeredObjects[typeof(TKey)] = typeof(TConcrete); } }</code> </pre> <br><p>  Hanya selusin baris kode, tetapi Anda sudah dapat menggunakannya (bukan untuk produksi, tentu saja, tetapi untuk tujuan pendidikan). </p><br><p>  Anda dapat mendaftarkan dependensi (misalnya, ConsoleLayer atau DebugLayer yang kami gunakan dalam contoh sebelumnya) seperti ini: </p><br><pre> <code class="plaintext hljs"> IoCContainer.Register&lt;ILayer, ConsoleLayer&gt;();</code> </pre> <br><p>  Dan ekstrak dari wadah di tempat yang diperlukan dari program seperti ini: </p><br><pre> <code class="plaintext hljs"> ILayer layer = IoCContainer.Resolve&lt;ILayer&gt;(); layer.Write("Hello from IoC!");</code> </pre> <br><p>  Dalam wadah nyata, Buang () juga diterapkan, yang memungkinkan Anda untuk menghancurkan sumber daya yang telah menjadi tidak perlu. </p><br><p>  By the way, nama wadah IoC tidak persis menyampaikan artinya, karena istilah IoC jauh lebih luas dalam aplikasi.  Oleh karena itu, baru-baru ini istilah wadah DI telah semakin sering digunakan (karena injeksi ketergantungan masih diterapkan). </p><br><h2 id="service-lifetimes--various-extension-methods-in-composition-root">  Umur layanan + berbagai metode ekstensi di Root Komposisi </h2><br><p>  Aplikasi Core ASP.NET berisi file Startup.cs, yang merupakan titik awal aplikasi untuk mengkonfigurasi DI.  Mengkonfigurasi DI dalam metode ConfigureServices. </p><br><pre> <code class="plaintext hljs"> public void ConfigureServices(IServiceCollection services) { services.AddScoped&lt;ISomeRepository, SomeRepository&gt;(); }</code> </pre> <br><p>  Kode ini akan menambahkan kelas SomeRepository ke wadah DI, yang mengimplementasikan antarmuka ISomeRepository.  Fakta bahwa layanan ditambahkan ke wadah menggunakan AddScoped berarti bahwa instance kelas akan dibuat setiap kali halaman diminta. <br>  Anda dapat menambahkan layanan ke sebuah wadah tanpa menentukan antarmuka. </p><br><pre> <code class="plaintext hljs"> services.AddScoped&lt;SomeRepository&gt;();</code> </pre> <br><p>  Tetapi metode ini tidak disarankan, karena aplikasi Anda kehilangan fleksibilitasnya dan koneksi yang dekat muncul.  Disarankan agar Anda selalu menentukan antarmuka, karena dalam hal ini, kapan saja, Anda dapat mengganti satu implementasi antarmuka dengan lainnya.  Dan jika implementasi mendukung prinsip substitusi Liskov, maka dengan mengubah nama kelas implementasi dengan "jentikan tangan" Anda akan mengubah fungsionalitas seluruh aplikasi. </p><br><p>  Ada 2 opsi lagi untuk menambahkan layanan - AddSingleton dan AddTransient. <br>  Saat menggunakan AddSingleton, layanan dibuat sekali, dan saat menggunakan aplikasi, panggilan masuk ke instance yang sama.  Gunakan metode ini terutama dengan hati-hati, karena kebocoran memori dan masalah multithreading mungkin terjadi. </p><br><p>  AddSingleton memiliki sedikit fitur.  Ini dapat diinisialisasi baik pada akses pertama ke sana </p><br><pre> <code class="plaintext hljs"> services.AddSingleton&lt;IYourService, YourService&gt;();</code> </pre> <br><p>  baik segera ketika ditambahkan ke konstruktor </p><br><pre> <code class="plaintext hljs"> services.AddSingleton&lt;IYourService&gt;(new YourService(param));</code> </pre> <br><p>  Dengan cara kedua, Anda bahkan dapat menambahkan parameter ke konstruktor. <br>  Jika Anda ingin menambahkan parameter ke konstruktor layanan yang ditambahkan tidak hanya menggunakan AddSingleton, tetapi juga menggunakan AddTransient / AddScoped, maka Anda dapat menggunakan ekspresi lambda: </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;IYourService&gt;(o =&gt; new YourService(param));</code> </pre> <br><p>  Dan akhirnya, ketika menggunakan AddTransient, sebuah layanan dibuat setiap kali Anda mengaksesnya.  Bagus untuk layanan ringan yang tidak menghabiskan memori dan sumber daya. </p><br><p>  Jika dengan AddSingleton dan AddScoped semuanya harus lebih atau kurang jelas, maka AddTransient perlu klarifikasi.  Dokumentasi resmi memberikan contoh di mana layanan tertentu ditambahkan ke wadah DI baik sebagai parameter pembangun layanan lain dan secara terpisah secara terpisah.  Dan jika ditambahkan secara terpisah menggunakan AddTransient, ia membuat instance-nya 2 kali.  Saya akan memberikan contoh yang sangat, sangat sederhana.  Dalam kehidupan nyata, itu tidak dianjurkan untuk digunakan, karena  kelas untuk kesederhanaan tidak mewarisi antarmuka.  Katakanlah kita memiliki kelas sederhana: </p><br><pre> <code class="plaintext hljs"> public class Operation { public Guid OperationId { get; private set; } public Operation() { OperationId = Guid.NewGuid(); } }</code> </pre> <br><p>  Dan ada kelas kedua yang berisi yang pertama sebagai layanan dependen dan menerima dependensi ini sebagai parameter konstruktor: </p><br><pre> <code class="plaintext hljs"> public class OperationService { public Operation Operation { get; } public OperationService (Operation operation) { Operation = operation; } }</code> </pre> <br><p>  Sekarang kami menyuntikkan dua layanan: </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;Operation&gt;(); services.AddScoped&lt;OperationService&gt;();</code> </pre> <br><p>  Dan di beberapa controller dalam Action, tambahkan tanda terima dari dependensi kami dan tampilkan nilai-nilai di jendela Debug. </p><br><pre> <code class="plaintext hljs"> public IActionResult Index([FromServices] Operation operation, [FromServices] OperationService operationService) { Debug.WriteLine(operation.OperationId); Debug.WriteLine(operationService.Operation.OperationId); return View(); }</code> </pre> <br><p>  Jadi, sebagai hasilnya, kami mendapatkan 2 nilai Guid yang berbeda.  Tetapi jika kita mengganti AddTransient dengan AddScoped, maka sebagai hasilnya kita mendapatkan 2 nilai identik. </p><br><p>  Wadah IoC aplikasi Core ASP.NET berisi beberapa layanan secara default.  Misalnya, IConfiguration adalah layanan yang dengannya Anda bisa mendapatkan pengaturan aplikasi dari file appsettings.json dan appsettings.Development.json.  IHostingEnvironment dan ILoggerFactory yang dengannya Anda bisa mendapatkan konfigurasi saat ini dan kelas pembantu yang memungkinkan logging. </p><br><p>  Kelas diambil dari wadah menggunakan konstruksi khas berikut (contoh paling umum): </p><br><pre> <code class="plaintext hljs"> private readonly IConfiguration _configuration; public SomePageController(IConfiguration configuration) { _configuration = configuration; } public async Task&lt;IActionResult&gt; Index() { string connectionString = _configuration["connectionString"]; }</code> </pre> <br><p>  Variabel dengan pengubah akses readonly pribadi dibuat dalam lingkup controller.  Ketergantungan diperoleh dari wadah di konstruktor kelas dan ditugaskan ke variabel pribadi.  Lebih lanjut, variabel ini dapat digunakan dalam metode atau pengontrol tindakan apa pun. <br>  Terkadang Anda tidak ingin membuat variabel untuk menggunakannya hanya dalam satu Tindakan.  Kemudian Anda dapat menggunakan atribut [FromServices].  Contoh: </p><br><pre> <code class="plaintext hljs"> public IActionResult About([FromServices] IDateTime dateTime) { ViewData["Message"] = «  " + dateTime.Now; return View(); }</code> </pre> <br><p>  Itu terlihat aneh, tetapi agar tidak memanggil metode kelas DateTime.Now () dalam kode, kadang-kadang dilakukan sehingga nilai waktu diperoleh dari layanan sebagai parameter.  Dengan demikian, menjadi mungkin untuk melewatkan setiap saat sebagai parameter, yang berarti menjadi lebih mudah untuk menulis tes dan, sebagai aturan, menjadi lebih mudah untuk membuat perubahan pada aplikasi. <br>  Ini bukan untuk mengatakan bahwa statis itu jahat.  Metode statis lebih cepat.  Dan kemungkinan besar statis dapat digunakan di suatu tempat di wadah IoC itu sendiri.  Tetapi jika kita menyimpan aplikasi kita dari semua yang statis dan baru, maka kita akan mendapatkan lebih banyak fleksibilitas. </p><br><h2 id="storonnie-di-konteynery">  Kontainer DI Pihak Ketiga </h2><br><p>  Apa yang kami lihat dan apa yang sebenarnya diterapkan oleh ASP.NET Core DI container adalah injeksi konstruktor.  Masih ada kesempatan untuk menyuntikkan ketergantungan ke properti menggunakan apa yang disebut injeksi properti, tetapi fitur ini tidak tersedia dalam wadah yang dibangun ke dalam ASP.NET Core.  Sebagai contoh, kami mungkin memiliki beberapa kelas yang Anda terapkan sebagai dependensi, dan kelas ini memiliki beberapa jenis properti publik.  Sekarang bayangkan bahwa selama atau setelah kita menyuntikkan dependensi, kita perlu mengatur nilai properti.  Mari kita kembali ke contoh yang mirip dengan contoh yang baru saja kita periksa. <br>  Jika kita memiliki kelas seperti itu: </p><br><pre> <code class="plaintext hljs"> public class Operation { public Guid OperationId { get; set; } public Operation() {} }</code> </pre> <br><p>  yang bisa kita perkenalkan sebagai kecanduan, </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;Operation&gt;();</code> </pre> <br><p>  kemudian menggunakan wadah standar, kami tidak dapat menetapkan nilai untuk properti. <br>  Jika Anda ingin menggunakan kesempatan ini untuk menetapkan nilai untuk properti OperationId, maka Anda dapat menggunakan beberapa jenis wadah DI pihak ketiga yang mendukung injeksi properti.  Omong-omong, injeksi properti tidak sangat dianjurkan.  Namun, masih ada Metode Injeksi dan Metode Setter Injeksi, yang mungkin berguna bagi Anda dan yang juga tidak didukung oleh wadah standar. </p><br><p>  Wadah pihak ketiga mungkin memiliki fitur lain yang sangat berguna.  Misalnya, menggunakan wadah pihak ketiga, Anda hanya bisa menambahkan ketergantungan ke pengontrol yang memiliki kata tertentu dalam namanya.  Dan cukup sering digunakan kasing - wadah DI, dioptimalkan untuk kinerja. <br>  Berikut adalah daftar beberapa kontainer DI pihak ketiga yang didukung oleh ASP.NET Core: Autofac, Castle Windsor, LightInject, DryIoC, StructureMap, Unity </p><br><p>  Meskipun menggunakan wadah DI standar, Anda tidak dapat menggunakan injeksi properti / metode, tetapi Anda dapat menerapkan layanan dependen sebagai parameter konstruktor dengan menerapkan pola Pabrik sebagai berikut: </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;IDataService, DataService&gt;((dsvc) =&gt; { IOtherService svc = dsvc.GetService&lt;IOtherService&gt;(); return new DataService(svc); });</code> </pre> <br><p>  Dalam hal ini, GetService akan mengembalikan nol jika layanan dependen tidak ditemukan.  Ada variasi GetRequiredService yang akan melempar pengecualian jika layanan dependen tidak ditemukan. <br>  Proses mendapatkan layanan dependen menggunakan GetService sebenarnya menerapkan pola pencari lokasi Layanan. </p><br><h2 id="autofac">  Autofac </h2><br><p>  Mari kita lihat Autofac dengan contoh praktis.  Dengan mudah, layanan dari wadah dapat didaftarkan dan diterima, baik dengan cara default maupun menggunakan Autofac. </p><br><p>  Instal paket NuGet Autofac.Extensions.DependencyInjection. <br>  Ubah nilai yang dikembalikan oleh metode ConfigureServices dari void ke IServiceProvider.  Dan tambahkan properti </p><br><pre> <code class="plaintext hljs"> public IContainer ApplicationContainer { get; private set; }</code> </pre> <br><p>  Setelah itu, menjadi mungkin untuk menambahkan kode seperti berikut ke akhir metode ConfigureServices dari kelas Startup (ini hanya salah satu opsi untuk mendaftar layanan): </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;ISomeRepository, SomeRepository&gt;(); var builder = new ContainerBuilder(); builder.Populate(services); builder.RegisterType&lt;AnotherRepository&gt;().As&lt;IAnotherRepository&gt;(); this.ApplicationContainer = builder.Build(); return new AutofacServiceProvider(this.ApplicationContainer);</code> </pre> <br><p>  Sini builder. Populasi (layanan);  Menambahkan layanan dari IServiceCollection ke wadah.  Yah dan selanjutnya sudah dimungkinkan untuk mendaftar layanan dengan builder.RegisterType.  Oh ya  Saya hampir lupa.  Anda harus mengubah dari membatalkan ke IServiceProvider nilai kembali metode ConfigureServices. </p><br><h2 id="aop-s-pomoschyu-aspnet-core---autofac-interseptors">  AOP dengan ASP.NET Core - Autofac Interseptor </h2><br><p>  Berbicara tentang pemrograman berorientasi aspek, mereka menyebutkan istilah lain - keprihatinan lintas sektoral.  Kepedulian adalah beberapa informasi yang mempengaruhi kode.  Dalam versi Rusia mereka menggunakan kata tanggung jawab.  Masalah lintas sektoral adalah tanggung jawab yang memengaruhi tanggung jawab lain.  Tapi idealnya, mereka seharusnya tidak saling mempengaruhi, kan?  Ketika mereka saling mempengaruhi, menjadi lebih sulit untuk mengubah program.  Lebih nyaman ketika kita memiliki semua operasi secara terpisah.  Logging, transaksi, caching dan banyak lagi dapat dilakukan dengan menggunakan AOP tanpa mengubah kode dari kelas dan metode itu sendiri. </p><br><p>  Di dunia .NET, metode sering digunakan ketika kode AOP disematkan menggunakan prosesor pos ke dalam kode aplikasi yang sudah dikompilasi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PostSharp</a> ). Atau sebagai alternatif, Anda dapat menggunakan pencegat - ini adalah pengait acara yang dapat ditambahkan ke kode aplikasi.  Pencegat ini, sebagai suatu peraturan, menggunakan dekorator yang telah kita periksa untuk pekerjaan mereka. </p><br><p>  Mari buat pencegat Anda sendiri.  Contoh paling sederhana dan paling umum yang paling mudah direproduksi adalah pencatatan. <br>  Selain paket Autofac.Extensions.DependencyInjection, kami juga akan menginstal paket Autofac.Extras.DynamicProxy <br>  Diinstal?  Tambahkan kelas log sederhana yang akan dipanggil saat mengakses layanan tertentu. </p><br><pre> <code class="plaintext hljs"> public class Logger : IInterceptor { public void Intercept(IInvocation invocation) { Debug.WriteLine($"Calling {invocation.Method.Name} from Proxy"); invocation.Proceed(); } }</code> </pre> <br><p>  Tambahkan ke registrasi Autofac kami pendaftaran interseptor: </p><br><pre> <code class="plaintext hljs"> builder.Register(i =&gt; new Logger()); builder.RegisterType&lt;SomeRepository &gt;() .As&lt;ISomeRepository &gt;() .EnableInterfaceInterceptors() .InterceptedBy(typeof(Logger));</code> </pre> <br><p>  Dan sekarang, dengan setiap panggilan ke kelas, metode Intercept dari kelas Logger akan dipanggil. <br>  Dengan demikian, kita dapat menyederhanakan hidup kita dan tidak menulis entri log di awal setiap metode.  Kami akan memilikinya secara otomatis.  Dan jika diinginkan, akan mudah bagi kita untuk mengubah atau menonaktifkannya untuk seluruh aplikasi. </p><br><p>  Kami juga dapat menghapus .InterceptedBy (typeof (Logger));  dan tambahkan intersepsi panggilan hanya untuk layanan aplikasi spesifik menggunakan atribut [Intercept (typeof (Logger))] - Anda harus menentukannya sebelum header kelas. </p><br><h2 id="middleware">  Middleware </h2><br><p>  ASP.NET memiliki rantai panggilan kode tertentu yang terjadi pada setiap permintaan.  Bahkan sebelum UI / MVC dimuat, tindakan tertentu dilakukan. </p><br><p>  Itu, misalnya, jika kita menambahkan di awal metode Konfigurasi kelas Startup.cs kode </p><br><pre> <code class="plaintext hljs"> app.Use(async (context, next) =&gt; { Debug.WriteLine(context.Request.Path); await next.Invoke(); });</code> </pre> <br><p>  lalu kita bisa melihat di konsol debug file apa yang diminta aplikasi kita.  Bahkan, kami mendapatkan kemampuan AOP "out of box" <br>  Sebagai contoh yang tidak berguna, tetapi jelas dan informatif tentang penggunaan middleware, saya akan menunjukkan kepada Anda sekarang: </p><br><pre> <code class="plaintext hljs"> public void Configure(IApplicationBuilder app) { app.Use(async (context, next) =&gt; { await context.Response.WriteAsync("Hello!" + Environment.NewLine); await next.Invoke(); }); app.Run(async context =&gt; { await context.Response.WriteAsync("Hello again."); }); }</code> </pre> <br><p>  Dengan setiap permintaan, serangkaian panggilan dimulai.  Dari setiap aplikasi. Gunakan, setelah memanggil next.invoke (), transisi ke panggilan berikutnya dilakukan.  Dan semuanya berakhir setelah aplikasi. Berjalan berfungsi. <br>  Anda dapat menjalankan beberapa kode hanya ketika mengakses rute tertentu. <br>  Anda dapat melakukan ini menggunakan aplikasi. Peta: </p><br><pre> <code class="plaintext hljs"> private static void Goodbye(IApplicationBuilder app) { app.Run(async context =&gt; { await context.Response.WriteAsync("Goodbye!"); }); } public void Configure(IApplicationBuilder app) { app.Map("/goodbye", Goodbye); app.Run(async context =&gt; { await context.Response.WriteAsync("Hello!"); }); }</code> </pre> <br><p>  Sekarang, jika Anda hanya pergi ke halaman situs, Anda dapat melihat teks "Halo!", Dan jika Anda menambahkan / Selamat tinggal ke bilah alamat, Anda akan melihat Selamat tinggal. </p><br><p>  Selain Penggunaan dan Peta, Anda dapat menggunakan UseWhen atau MapWhen untuk menambahkan kode ke rantai middleware hanya dalam kondisi tertentu tertentu. </p><br><p>  Sejauh ini masih ada contoh yang tidak berguna, kan?  Ini adalah contoh normal: </p><br><pre> <code class="plaintext hljs"> app.Use(async (context, next) =&gt; { context.Response.Headers.Add("X-Frame-Options", "DENY"); context.Response.Headers.Add("X-Content-Type-Options", "nosniff"); context.Response.Headers.Add("X-Xss-Protection", "1"); await next(); });</code> </pre> <br><p>  Di sini kami menambahkan header ke setiap permintaan untuk membantu melindungi halaman dari serangan peretas. </p><br><p>  Atau di sini adalah contoh lokalisasi: </p><br><pre> <code class="plaintext hljs"> var supportedCultures = new[] { new CultureInfo("ru"), new CultureInfo("fr") }; app.UseRequestLocalization(new RequestLocalizationOptions { DefaultRequestCulture = new RequestCulture("ru"), SupportedCultures = supportedCultures, SupportedUICultures = supportedCultures });</code> </pre> <br><p>  Sekarang jika Anda menambahkan parameter? Culture = fr ke alamat halaman, maka Anda dapat mengganti bahasa aplikasi ke bahasa Prancis (jika lokalisasi ditambahkan ke aplikasi Anda, maka semuanya akan berfungsi) </p><br><h2 id="filters">  Filter </h2><br><p>  Jika rantai middleware mengacu pada proses sebelum MVC, maka filter bekerja bersama dengan MVC. <br>  Diagram skematik berikut menunjukkan cara kerja filter. </p><br><p><img src="https://habrastorage.org/webt/jz/n1/hv/jzn1hvufowfcck24q1-nnl-xbx8.png" alt="Filter"></p><br><p>  Pertama, filter otorisasi berhasil.  Yaitu  Anda dapat membuat beberapa jenis filter atau beberapa filter dan memasukkan beberapa jenis kode otorisasi yang akan berfungsi berdasarkan permintaan. </p><br><p>  Kemudian mereka memenuhi filter sumber daya.  Dengan menggunakan filter ini, Anda dapat, misalnya, mengembalikan beberapa informasi dari cache. </p><br><p>  Kemudian terjadi pengikatan data dan filter Tindakan dijalankan.  Dengan bantuan mereka, Anda dapat memanipulasi parameter yang dikirimkan ke Aksi dan hasil yang dikembalikan. </p><br><p>  Filter pengecualian sebagai petunjuk namanya memungkinkan Anda menambahkan semacam penanganan kesalahan umum untuk aplikasi.  Seharusnya cukup nyaman untuk menangani kesalahan di tempat yang sama.  Semacam AOP-shny plus. </p><br><p>  Filter hasil memungkinkan Anda untuk melakukan beberapa tindakan sebelum mengeksekusi Action controller atau sesudahnya.  Mereka sangat mirip dengan filter Tindakan, tetapi dieksekusi hanya jika tidak ada kesalahan.  Cocok untuk logika yang terkait dengan View. </p><br><p>       .            : </p><br><pre> <code class="plaintext hljs"> public class YourCustomFilter : Attribute, IAuthorizationFilter { public async void OnAuthorization(AuthorizationFilterContext context) { // -    ,     ,    context.Result = new ContentResult() { Content = "        " }; } }</code> </pre> <br><p>     DI  (   Startup.cs) </p><br><pre> <code class="plaintext hljs"> services.AddScoped&lt;YourCustomFilter&gt;();</code> </pre> <br><p>      -    Action    </p><br><pre> <code class="plaintext hljs"> [ServiceFilter(typeof(YourCustomFilter))]</code> </pre> <br><p>   –    middleware    - action   .              Configure </p><br><pre> <code class="plaintext hljs"> public class MyMiddlewareFilter { public void Configure(IApplicationBuilder applicationBuilder) { applicationBuilder.Use(async (context, next) =&gt; { Debug.WriteLine("  middleware!"); await next.Invoke(); }); } }</code> </pre> <br><p>      Action-     </p><br><pre> <code class="plaintext hljs"> [MiddlewareFilter(typeof(MyMiddlewareFilter))]</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/BRKPP1NYCu4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id437002/">https://habr.com/ru/post/id437002/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436992/index.html">Trial and error saat memilih HTTP Reverse Proxy</a></li>
<li><a href="../id436994/index.html">Liquibase dan Maven</a></li>
<li><a href="../id436996/index.html">Kursus Final Spesialisasi Python dari Mail.ru Group</a></li>
<li><a href="../id436998/index.html">Perlindungan microchip dari rekayasa terbalik dan entri tidak sah</a></li>
<li><a href="../id437000/index.html">Bagaimana cara mengajar orang menggunakan git</a></li>
<li><a href="../id437004/index.html">Apakah pemrogram YML memimpikan pengujian yang mungkin dilakukan?</a></li>
<li><a href="../id437006/index.html">Review Printer 3D Wanhao Duplicator 10</a></li>
<li><a href="../id437008/index.html">NLP. Dasar-dasarnya. Teknik Pengembangan diri. Bagian 1</a></li>
<li><a href="../id437010/index.html">Gaung Masa Lalu: Pengalaman Muda di Dasar Metode Spektroskopi X-Ray Baru</a></li>
<li><a href="../id437014/index.html">Tugas tubuh N atau cara meledakkan galaksi tanpa meninggalkan dapur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>