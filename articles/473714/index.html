<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📋 🛂 👐🏾 Cómo llegué a la especificación formal de un procesador RISC-V en F # 🗾 👆 👊🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En las lánguidas noches de invierno, cuando el sol pasaba perezosamente a través del velo de los días, encontraba la fuerza para enfrentar la realizac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cómo llegué a la especificación formal de un procesador RISC-V en F #</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473714/"><p>  En las lánguidas noches de invierno, cuando el sol pasaba perezosamente a través del velo de los días, encontraba la fuerza para enfrentar la realización de un sueño de larga data: descubrir cómo están dispuestos los procesadores.  Este sueño me llevó a escribir una especificación formal del procesador RISC-V.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Proyecto Github</a> </p><br><p><img src="https://habrastorage.org/webt/03/pg/3p/03pg3piapm7id4gahgq28ramnyc.png" alt="imagen"><a name="habracut"></a></p><br><h2 id="kak-eto-bylo">  Como fue </h2><br><p> Tenía ese deseo hace mucho tiempo, cuando hace 20 años comencé a participar en mis primeros proyectos.  En su mayor parte, se trataba de investigación científica, modelado matemático en el marco de trabajos y artículos científicos.  Estos fueron los días de Pascal y Delfos.  Sin embargo, incluso entonces, Haskell y la programación funcional atrajeron mi interés.  Pasó el tiempo, cambiaron los idiomas de los proyectos y las tecnologías en las que estuve involucrado.  Pero desde entonces, el interés en los lenguajes de programación funcionales ha sido un hilo común, y se han convertido en: Haskell, Idris, Agda.  Recientemente, sin embargo, mis proyectos han estado en Rust.  Una inmersión más profunda en Rust me llevó a estudiar dispositivos integrados. </p><br><h3 id="ot-rust-k-embedded">  De óxido a incrustado </h3><br><p>  Las capacidades de Rust son tan amplias y la comunidad es tan activa que el desarrollo integrado ha comenzado a admitir una amplia gama de dispositivos.  Y este fue mi primer paso hacia una comprensión más baja de los procesadores. </p><br><p>  Mi primer tablero fue: <strong>STM32F407VET6</strong> .  Fue una inmersión en el mundo de los microcontroladores, de los cuales en ese momento estaba muy lejos, y entendí aproximadamente lo suficiente como se hacía el trabajo en un nivel bajo. </p><br><p>  Poco a poco, <strong>esp32</strong> , <strong>ATmega328</strong> juntas (representadas por la junta de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ucrania UNO</a> ) se agregaron aquí.  La inmersión en stm32 resultó ser bastante dolorosa: la información es abundante y, a menudo, no es la que necesito.  Y resultó que desarrollar, por ejemplo, en Assembler es una tarea bastante rutinaria e ingrata, con su subconjunto de más de 1000 instrucciones.  Sin embargo, Rust enfrentó esto alegremente, aunque a veces hubo dificultades con la integración de juntas chinas específicas. </p><br><p>  La arquitectura AVR resultó ser notablemente más simple y más transparente.  Los abundantes manuales me dieron una comprensión suficiente de cómo trabajar con un conjunto de instrucciones tan limitado y, sin embargo, ser capaz de crear soluciones muy interesantes.  Sin embargo, el camino de Arduino no me complació en absoluto, pero escribir en Asm / C / Rust resultó ser mucho más interesante. </p><br><h2 id="a-gde-zhe-risc-v">  ¿Dónde está el RISC-V? </h2><br><p>  Y en ese momento surge una pregunta lógica: ¿dónde está la <strong>CPU RISC-V</strong> ? <br>  Debido a la naturaleza minimalista de AVR y su documentación suficiente, volví a mi sueño anterior para descubrir cómo funciona el procesador.  En este momento, tenía una placa FPGA y las primeras implementaciones para ella en forma de interacción con dispositivos VGA, salida de gráficos, interacción con periféricos. </p><br><p>  Los libros fueron mis guías para la arquitectura del procesador: </p><br><ul><li>  John L. Hennessy y David A. Patterson - Arquitectura de computadoras: un enfoque cuantitativo (Serie Morgan Kaufmann en Arquitectura y diseño de computadoras) </li><li>  John L. Hennessy y David A. Patterson - Organización y diseño de computadoras.  La interfaz hardware / software: Edición RISC-V </li><li>  David M. Harris y Sarah L. Harris - Circuitos digitales y arquitectura de computadoras </li><li>  El manual del conjunto de instrucciones RISC-V </li></ul><br><h3 id="zachem-eto-nuzhno">  Porque es necesario </h3><br><p>  Parece que todo ya se ha escrito e implementado durante mucho tiempo. </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Descripción general de núcleos RISC-V y SoC</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Verificación formal RISC-V</a> </li></ul><br><p>  diversas implementaciones en HDL y lenguajes de programación.  Por cierto, una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">implementación</a> bastante interesante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de RISC-V en Rust</a> . </p><br><p>  Sin embargo, qué podría ser más interesante que descubrirlo usted mismo y crear el suyo propio.  Tu <em>bici</em>  ¿O contribuir a <em>la construcción de bicicletas</em> ?  Además del profundo interés personal, tuve una idea: cómo tratar de popularizar, interesar.  Y encuentre su forma, su enfoque.  Y eso significa presentar la documentación <strong>RISC-V ISA</strong> bastante aburrida en forma de una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">especificación oficial</a> en una forma diferente.  Y me parece que el camino de la <em>formalización</em> en este sentido es bastante interesante. </p><br><p>  ¿Qué quiero decir con formalización?  Un concepto bastante amplio.  Representación de un conjunto de datos específico en forma formal.  En este caso, a través de una descripción de estructuras y una descripción funcional.  Y en este sentido, los lenguajes de programación funcionales tienen su propio encanto.  Además, la tarea es que una persona que no esté muy inmersa en la programación pueda leer el código como una especificación, si es posible, comprender mínimamente los detalles del lenguaje en el que se describe. <br>  Un enfoque declarativo, por así decirlo.  Hay una declaración, pero cómo funciona exactamente ya no es esencial.  Lo principal es la legibilidad, la visibilidad y, por supuesto, la corrección.  Correspondencia de <em>las declaraciones formales</em> con el significado incrustado en ellas. <br><img src="https://habrastorage.org/webt/px/1j/ng/px1jngd3zy0gq3vtpknqxut5y1q.png" alt="imagen"><br>  Total: tengo mucha curiosidad por transmitir mi interés a los demás.  Existe una cierta ilusión de que el interés es la fuerza impulsora de las acciones.  A través del cual la individualidad se vuelve y se manifiesta  Y esto es parte de la autorrealización, la encarnación de la creatividad. <br>  Ambicioso y un poco de letra.  Que sigue </p><br><h3 id="suschestvuyuschie-realizacii">  Implementaciones existentes </h3><br><p>  Existen y actualmente están siendo agregados por el proyecto: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Verificación formal RISC-V</a> . <br>  Lista de especificaciones formales (incluido mi trabajo): <a href="">https://github.com/SymbioticEDA/riscv-formal/blob/master/docs/references.md</a> </p><br><p>  Como puede ver, en su mayor parte se trata de formalizaciones en el idioma Haskell.  Este fue el punto de partida para elegir un lenguaje funcional diferente.  Y mi elección recayó en <strong>F #</strong> . </p><br>
<h3 id="pochemu-f">  ¿Por qué <code>F#</code> </h3><br><p>  Dio la casualidad de que he sabido sobre <strong>F #</strong> durante mucho tiempo, pero de alguna manera en el ajetreo de la vida cotidiana no tuve la oportunidad de conocernos mejor.  Otro factor fue la plataforma <strong>.NET</strong> .  Teniendo en cuenta que estoy bajo Linux, durante mucho tiempo no estaba contento con el IDE, y <code>mono</code> parecía lo suficientemente crudo.  Y regresar a Windows solo por MS Visual Studio es una idea bastante dudosa. </p><br><p>  Sin embargo, el tiempo no se detiene, y las estrellas en el cielo no tienen prisa por cambiar.  Pero en este momento, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Jetbrains Rider se había</a> convertido en una herramienta completa y conveniente, y <code>.NET Core</code> para Linux no trae dolor de un vistazo. </p><br><p>  La pregunta era: qué lenguaje funcional elegir.  El hecho de que debería ser solo un lenguaje funcional, en una forma algo patética, discutí anteriormente. <br>  <code>Haskell, Idris, Agda</code> ?  <code>F#</code> - No estoy familiarizado con él.  Una gran ocasión para aprender nuevos colores del mundo de los lenguajes funcionales. </p><br><p>  Sí, <code>F#</code> no <code>F#</code> puramente funcional.  Pero, ¿qué impide adherirse a la " <em>pureza</em> "?  Y luego resultó que la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación de F # es</a> bastante detallada y completa.  Legible, e incluso diría interesante. </p><br><p>  ¿Qué es <code>F#</code> para mí ahora?  Un lenguaje bastante flexible, con IDEs muy convenientes (Rider, Visual Studio).  Tipos completamente desarrollados (aunque, por supuesto, <code>Idris</code> muy lejos).  Y en general bastante <em>dulce</em> en términos de legibilidad.  Sin embargo, como resultó, su " <em>no limpieza</em> " funcional puede llevar el código a una forma completamente loca, tanto en términos de legibilidad como de lógica.  El análisis de paquetes en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nuget</a> demuestra esto. </p><br><p>  Otra característica interesante y misteriosa para mí fue el descubrimiento de que nadie estaba interesado en escribir la formalización <strong>RISC-V ISA</strong> en <strong>F #</strong> antes (oficialmente o en forma de búsqueda).  Y esto significa que tengo la oportunidad de introducir una nueva transmisión en esta comunidad, idioma y " <em>ecosistema</em> ". </p><br><h3 id="podvodnye-kamni-s-kotorymi-ya-stolknulsya">  Los escollos que encontré </h3><br><p>  La parte más difícil fue la implementación del flujo de ejecución.  A menudo resultó que no estaba del todo claro cómo debería funcionar la instrucción.  Desafortunadamente, un amigo confiable que podría ser llamado a las 3 en punto de la mañana y preguntado con una voz excitada y aspirada: "Sabes, la instrucción BLTU probablemente no se extienda de manera diferente ..." - No lo sé.  En este sentido, tener compañeros calificados que ayuden con una palabra amable y un asesoramiento calificado apropiado es muy bienvenido. </p><br><p>  Cuáles fueron las dificultades y dificultades.  Probaré la tesis: </p><br><ul><li>  ELF: una tarea curiosa era descubrir cómo trabajar con él, leer secciones e instrucciones.  Lo más probable es que esta historia en el marco del proyecto actual no esté terminada. </li><li>  instrucciones sin firmar periódicamente condujeron a errores que detecté durante las pruebas unitarias </li><li>  La implementación del trabajo con memoria requiere pensar en algoritmos de composición de bytes hermosos y legibles. </li><li>  no había un paquete adecuado para trabajar con bits en <code>int32, int64</code> .  Me tomó tiempo escribir mi paquete y probarlo. <br>  <em>Aquí quiero señalar que trabajar con bits en F # es mucho más conveniente que en Haskell con sus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">datos.</a></em> </li><li>  soporte adecuado para bits de registro, con la capacidad de soportar <code>x32</code> y <code>x64</code> al mismo tiempo.  La <code>int64</code> de <code>int64</code> me llevó a usar <code>int64</code> en algunos lugares.  Las pruebas unitarias me ayudaron a identificar esto.  Pero tomó un tiempo. </li><li>  No encontré un paquete CLI F # simple, conciso y personalmente conveniente para mí personalmente.  Un efecto secundario fue escribir una versión minimalista en un estilo funcional. </li><li>  Por el momento, sigue siendo un misterio cómo implementar correctamente las instrucciones del sistema: FENCE, ECALL, BREAK </li><li>  lejos de todo el conjunto de extensiones (extensiones ISA) de la lista: <code>[A, M, C, F, D]</code> actualmente obvias.  En particular, la implementación de <code>[F,D]</code> no se realiza mediante <code>soft float</code> . </li><li>  Por el momento, no hay una comprensión clara de las instrucciones privilegiadas, Mod de usuario, trabajo con periféricos, por desgracia.  Y esta es la forma de investigación, ensayo y error. </li><li>  No hay <em>cinturón negro</em> para escribir programas Assembler <strong>bajo RISC-V.</strong>  Quizás, lejos de ser frecuente, esto sea una necesidad, dada la cantidad de idiomas que ya se han portado para escribir bajo RISC-V. </li><li>  el factor tiempo también fue significativo: es bastante pequeño en la vorágine del trabajo básico, las necesidades cotidianas y el océano de la vida.  Y hay mucho trabajo, y la mayor parte no se trata tanto de " <em>codificar</em> " - escribir el código en sí, sino de aprender, dominar los materiales. </li></ul><br><h3 id="kak-eto-rabotaet-i-kakie-vozmozhnosti">  Cómo funciona y qué características tiene </h3><br><p>  Ahora quizás la parte más <em>técnica</em> .  ¿Cuáles son las características en este momento? </p><br><ul><li>  <code>rv32i</code> conjunto de instrucciones <code>rv32i</code> </li><li>  la capacidad de ejecutar el programa como un simulador RISC-V: la ejecución de archivos ELF. </li><li>  soporte de línea de comando (CLI): selección de arquitectura ejecutable, conjunto de instrucciones, archivos ELF ejecutables, modo de registro, ayuda de línea de comando. </li><li>  la capacidad de mostrar el registro de instrucciones ejecutables, cerca de la vista <code>objdump</code> al desmontar. </li><li>  la capacidad de ejecutar pruebas que cubren todo el conjunto de instrucciones implementadas. </li></ul><br><p>  El programa se divide en tales etapas y ciclos: </p><br><ul><li>  leer la línea de comando </li><li>  leer instrucciones de un archivo ELF </li><li>  leer una instrucción específica de acuerdo con el contador actual de PC (Contador de programas) </li><li>  instrucciones de decodificación </li><li>  ejecución de instrucciones </li><li>  En caso de situaciones imprevistas, se configuran trampas, lo que le permite completar el proceso de ejecución, señalar un problema y proporcionar los datos necesarios </li><li>  Si el programa no está en un bucle infinito, muestre el estado de los registros y finalice el programa de simulación. </li></ul><br><p>  Lo que está incluido en los planes: </p><br><ul><li>  Base estándar 64i (casi completa) </li><li>  Extensión estándar M (multiplicación / división de enteros) </li><li>  Extensión estándar A (operaciones de memoria atómica) </li><li>  Extensión estándar C (instrucciones comprimidas de 16 bits) </li><li>  Extensión estándar F (coma flotante de precisión simple) </li><li>  Extensión estándar D (coma flotante de precisión doble * Nivel de privilegio M (máquina) </li><li>  Nivel de privilegio U (usuario) </li><li>  Nivel de privilegio S (Supervisor) </li><li>  Esquemas de memoria virtual SV32, SV39 y SV48 </li><li>  programas de acogida </li><li>  GPIO - trabaja con periféricos </li></ul><br><h3 id="kak-zapustit">  Como correr </h3><br><p>  Para ejecutar el programa, debe tener <code>.NET Core</code> .  Si no lo tiene instalado, entonces, por ejemplo, en <code>Ubuntu 16.04</code> debe ejecutar el siguiente conjunto de comandos: </p><br><pre> <code class="plaintext hljs">$ wget -q https://packages.microsoft.com/config/ubuntu/16.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb $ sudo dpkg -i packages-microsoft-prod.deb $ sudo apt-get update $ sudo apt-get install apt-transport-https $ sudo apt-get update $ sudo apt-get install dotnet-sdk-3.0</code> </pre> <br><p>  Para verificar que algo en la vida ha cambiado, ejecute: </p><br><pre> <code class="plaintext hljs">$ dotnet --version</code> </pre> <br><p>  ¡Y la vida debería brillar con nuevos colores! </p><br><p>  Ahora intenta correr.  Para hacer esto, almacene su té o café favorito, chocolate con bollos, encienda su música favorita y siga este conjunto de comandos: </p><br><pre> <code class="plaintext hljs">$ cd some/my/dev/dir $ git clone https://github.com/mrLSD/riscv-fs $ cd riscv-fs $ dotnet build $ dotnet run -- --help</code> </pre> <br><p>  y tu consola debería hacerte un guiño juguetón con un mensaje de ayuda. <br>  El lanzamiento es: </p><br><pre> <code class="plaintext hljs">$ dotnet run</code> </pre> <br><p>  En un tono estricto, dirá que se necesitan parámetros.  Por lo tanto, ejecute: </p><br><pre> <code class="plaintext hljs">$ dotnet run -- -A rv32i -v myapp.elf</code> </pre> <br><p>  Este es el mismo momento incómodo cuando resulta que todavía necesitamos un programa <em>listo para ejecutar</em> para RISC-V.  Y hay algo en lo que te puedo ayudar.  Sin embargo, necesitará la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cadena de herramientas GNU para RISC-V</a> .  Debe instalarse la tarea: la descripción del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">repositorio</a> describe con suficiente detalle cómo hacer esto. </p><br><p>  Luego, para obtener el codiciado archivo ELF de prueba, realizamos las siguientes acciones: </p><br><pre> <code class="plaintext hljs">$ cd Tests/asm/ $ make build32</code> </pre> <br><p>  Si tiene una <em>cadena de herramientas RISC-V</em> , todo debería funcionar sin problemas.  Y los archivos deberían mostrarse en el directorio: </p><br><pre> <code class="plaintext hljs">$ ls Tests/asm/build/ add32 alu32 alui32 br32 j32 mem32 sys32 ui32</code> </pre> <br><p>  y ahora audazmente, sin mirar atrás, probamos el comando: </p><br><pre> <code class="plaintext hljs">$ dotnet run -- -A rv32i -v Tests/asm/build/ui32</code> </pre> <br><p>  <strong>Es importante tener en cuenta</strong> que <code>Tests/asm</code> no <code>Tests/asm</code> un programa de prueba, pero su propósito principal son las instrucciones de prueba y sus códigos para escribir pruebas.  Por lo tanto, si le gusta algo más grande y más heroico, entonces cambiar el mundo en su testamento es encontrar un archivo ELF de 32 bits ejecutable independientemente que solo <code>rv32i</code> instrucciones <code>rv32i</code> . </p><br><p>  Sin embargo, el conjunto de instrucciones y extensiones se repondrán, ganarán impulso y aumentarán de peso. </p><br><h2 id="rezyume-i-ssylki">  Resumen y enlaces </h2><br><p>  Resultó ser una narración patética con sabor a historia personal.  A veces técnico, a veces subjetivo.  Sin embargo entusiasta y con un toque de entusiasmo. </p><br><p>  Por mi parte, me interesa saber de usted: comentarios, impresiones, buenas palabras de despedida.  Y para los más atrevidos: ayuda para apoyar el proyecto. </p><br><p>  ¿Está interesado en un formato tan narrativo y le gustaría continuar? </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el proyecto en sí</a> </li><li>  <a href="">Lista RISC-V de especificaciones formales (incluido mi proyecto)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Especificaciones RISC-V</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cadena de herramientas RISC-V</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Awesome F # (mi proyecto también está incluido)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ariane: una CPU RISC-V de 6 etapas basada en Verilog</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/473714/">https://habr.com/ru/post/473714/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../473702/index.html">¿Qué se está fragmentando en la cadena de bloques terahash?</a></li>
<li><a href="../473704/index.html">Bro vs. no hermano</a></li>
<li><a href="../473706/index.html">Zoia: CMS reactivo ligero para el desarrollo rápido de sitios web</a></li>
<li><a href="../473708/index.html">Coche eléctrico hecho en casa: no todo es lo que piensas</a></li>
<li><a href="../473710/index.html">Los principios de documentación y localización, o cómo obtener una buena localización a un costo mínimo.</a></li>
<li><a href="../473716/index.html">Widgets accionados por mouse. Arrastra y suelta dentro de la ventana</a></li>
<li><a href="../473718/index.html">Cómo agregar cheques a NoVerify sin escribir una sola línea de código Go</a></li>
<li><a href="../473720/index.html">Dos formas de hacer pruebas unitarias confiables</a></li>
<li><a href="../473722/index.html">Aislamiento remoto, ansiedad y depresión.</a></li>
<li><a href="../473726/index.html">No es suficiente saber qué son Mutex, Semaphore y async / await. Necesitas saber todo de quanta</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>