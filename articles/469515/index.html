<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌼 🏂🏼 🏂 Preparando la aplicación para Istio 🦕 🤴🏾 🦍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Istio es una herramienta conveniente para conectar, proteger y monitorear aplicaciones distribuidas. Istio utiliza una variedad de tecnologías para la...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Preparando la aplicación para Istio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/469515/"><p><img src="https://habrastorage.org/webt/qy/yw/v1/qyywv1qmzphh1svbblasrxjc6ym.jpeg"></p><br><p>  Istio es una herramienta conveniente para conectar, proteger y monitorear aplicaciones distribuidas.  Istio utiliza una variedad de tecnologías para lanzar y administrar software a gran escala, incluidos contenedores para empaquetar código de aplicación y dependencias para la implementación, y Kubernetes para administrar estos contenedores.  Por lo tanto, para trabajar con Istio, debe saber cómo funciona una aplicación con varios servicios basados ​​en estas tecnologías <em>sin</em> Istio.  Si ya conoce estas herramientas y conceptos, no dude en omitir esta guía e ir directamente a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Instalar Istio en Google Kubernetes Engine (GKE)</a> o instalar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Istio en la</a> extensión <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GKE</a> . </p><br><p>  Esta es una guía paso a paso donde veremos todo el proceso desde el código fuente hasta un contenedor en GKE para que pueda obtener una idea básica de estas tecnologías usando un ejemplo.  También verá cómo Istio aprovecha estas tecnologías.  Se supone que no sabe nada sobre contenedores, Kubernetes, servicio de malla o Istio. </p><a name="habracut"></a><br><h3 id="zadachi">  Las tareas </h3><br><p>  En esta guía, completará las siguientes tareas: </p><br><ol><li>  Explorando una aplicación sencilla de hello world con varios servicios. </li><li>  Ejecutando la aplicación desde el código fuente. </li><li> Embalaje de la aplicación en contenedores. </li><li>  Crear un clúster de Kubernetes </li><li>  Implemente contenedores en un clúster. </li></ol><br><h3 id="prezhde-chem-nachat">  Antes de empezar </h3><br><p>  Siga las instrucciones para habilitar la API de Kubernetes Engine: </p><br><ol><li>  Vaya a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la página de Kubernetes Engine</a> en la consola de Google Cloud Platform. </li><li>  Crea o selecciona un proyecto. </li><li>  Espere a que se activen la API y los servicios relacionados.  Esto puede tomar varios minutos. </li><li>  Asegúrese de que la facturación esté configurada para el proyecto Google Cloud Platform.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Obtenga información sobre cómo habilitar la facturación</a> . </li></ol><br><p>  En esta guía, puede usar Cloud Shell, que prepara la máquina virtual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pequeña g1 en Google Compute Engine</a> con Linux basado en Debian, o una computadora Linux o macOS. </p><br><h3 id="variant-a-ispolzovanie-cloud-shell">  Opción A: uso de Cloud Shell </h3><br><p>  Beneficios de usar Cloud Shell: </p><br><ul><li>  Los entornos de desarrollo Python 2 y Python 3 (incluido <strong>virtualenv</strong> ) están totalmente personalizados. </li><li>  Las <strong>herramientas de</strong> línea de <strong>comandos gcloud</strong> , <strong>docker</strong> , <strong>git</strong> y <strong>kubectl</strong> que usaremos ya están instaladas. </li><li>  Tiene varios <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">editores de texto</a> para elegir: <br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El editor de código</a> que se abre con el icono de edición en la parte superior de la ventana de Cloud Shell. </li><li>  Emacs, Vim o Nano que se abren desde la línea de comandos en Cloud Shell. </li></ol></li></ul><br><p>  Para usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cloud Shell</a> : </p><br><ol><li>  Vaya a la consola de GCP. </li><li>  Haga clic en el botón <strong>Activar Cloud Shell</strong> en la parte superior de la ventana de la consola GCP. </li></ol><br><p><img src="https://habrastorage.org/webt/yu/sh/9x/yush9xie9_peummad02lgu2n5x8.png"></p><br><p>  En la parte inferior de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la consola GCP,</a> en una nueva ventana, se abre una sesión de Cloud Shell con una línea de comando. </p><br><p><img src="https://habrastorage.org/webt/yi/no/-q/yino-qj5bwaluwxlo3xtf0yr7ty.png"></p><br><h3 id="variant-b-ispolzovanie-instrumentov-komandnoy-stroki-lokalno">  Opción B: uso local de herramientas de línea de comando </h3><br><p>  Si va a trabajar en una computadora con Linux o macOS, debe configurar e instalar los siguientes componentes: </p><br><ol><li><p>  Configure <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">su entorno de desarrollo Python 3 y Python 2</a> . </p><br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Instale Cloud SDK</a> con la <strong>herramienta de</strong> línea de comandos <strong>gcloud</strong> . </p><br></li><li><p>  Instale <strong>kubectl</strong> , una herramienta de línea de comandos para trabajar con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kubernetes</a> . </p><br><pre><code class="plaintext hljs">gcloud components install kubectl</code> </pre> <br></li><li><p>  Instale <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Docker Community Edition (CE)</a> .  Utilizará la herramienta de línea de comandos de Docker para crear imágenes de contenedor para una aplicación de muestra. </p><br></li><li><p>  Instale la herramienta de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">control de versiones de Git</a> para obtener una aplicación de muestra con GitHub. </p><br></li></ol><br><h3 id="zagruzka-primera-koda">  Descargar código de muestra </h3><br><ol><li><p>  Descargue el código fuente de <strong>helloserver</strong> : </p><br><pre> <code class="plaintext hljs">git clone https://github.com/GoogleCloudPlatform/istio-samples</code> </pre> <br></li><li><p>  Vaya al directorio del código de muestra: </p><br><pre> <code class="plaintext hljs">cd istio-samples/sample-apps/helloserver</code> </pre> <br></li></ol><br><h3 id="izuchenie-prilozheniya-s-neskolkimi-servisami">  Explorando una aplicación multiservicio </h3><br><p>  La aplicación de muestra está escrita en Python y consta de dos componentes que interactúan con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">REST</a> : </p><br><ul><li>  <strong>servidor</strong> : un servidor simple con un punto final <strong>GET, /</strong> , que muestra "hello world" en la consola. </li><li>  <strong>loadgen</strong> : un script que envía tráfico al <strong>servidor</strong> , con un número configurable de solicitudes por segundo. </li></ul><br><p><img src="https://habrastorage.org/webt/b1/ky/lj/b1kyljxdkjdci12qtle2w3dmtjw.png"></p><br><h3 id="zapusk-prilozheniya-iz-ishodnogo-koda">  Ejecutar una aplicación desde el origen </h3><br><p>  Para aprender una aplicación de muestra, ejecútela en Cloud Shell o en una computadora. <br>  1) En el <strong>directorio istio-samples / sample-apps / helloserver</strong> , ejecute el <strong>servidor</strong> : </p><br><pre> <code class="plaintext hljs">python3 server/server.py</code> </pre> <br><p>  Cuando se inicia el <strong>servidor</strong> , se muestra lo siguiente: </p><br><pre> <code class="plaintext hljs">INFO:root:Starting server...</code> </pre> <br><p>  2) Abra otra ventana de terminal para enviar solicitudes al <strong>servidor</strong> .  Si está utilizando Cloud Shell, haga clic en el icono Agregar para abrir otra sesión. <br>  3) Enviar una solicitud al <strong>servidor</strong> : </p><br><pre> <code class="plaintext hljs">curl http://localhost:8080</code> </pre> <br><p>  respuestas del servidor: </p><br><pre> <code class="plaintext hljs">Hello World!</code> </pre> <br><p>  4) Desde el directorio donde descargó el código de muestra, vaya al directorio que contiene <strong>loadgen</strong> : </p><br><pre> <code class="plaintext hljs">cd YOUR_WORKING_DIRECTORY/istio-samples/sample-apps/helloserver/loadgen</code> </pre> <br><p>  5) Cree las siguientes variables de entorno: </p><br><pre> <code class="plaintext hljs">export SERVER_ADDR=http://localhost:8080 export REQUESTS_PER_SECOND=5</code> </pre> <br><p>  6) Ejecute <strong>virtualenv</strong> : </p><br><pre> <code class="plaintext hljs">virtualenv --python python3 env</code> </pre> <br><p>  7) Activar el entorno virtual: </p><br><pre> <code class="plaintext hljs">source env/bin/activate</code> </pre> <br><p>  8) Establecer requisitos para <strong>loadgen</strong> : </p><br><pre> <code class="plaintext hljs">pip3 install -r requirements.txt</code> </pre> <br><p>  9) Ejecute <strong>loadgen</strong> : </p><br><pre> <code class="plaintext hljs">python3 loadgen.py</code> </pre> <br><p>  Cuando se inicia, <strong>loadgen</strong> muestra el siguiente mensaje: </p><br><pre> <code class="plaintext hljs">Starting loadgen: 2019-05-20 10:44:12.448415 5 request(s) complete to http://localhost:8080</code> </pre> <br><p>  En otra ventana de terminal, el <strong>servidor</strong> muestra los siguientes mensajes a la consola: </p><br><pre> <code class="plaintext hljs">127.0.0.1 - - [21/Jun/2019 14:22:01] "GET / HTTP/1.1" 200 - INFO:root:GET request, Path: / Headers: Host: localhost:8080 User-Agent: python-requests/2.22.0 Accept-Encoding: gzip, deflate Accept: */*</code> </pre> <br><p>  Desde una perspectiva de red, toda la aplicación se ejecuta en el mismo host (computadora local o máquina virtual Cloud Shell).  Por lo tanto, puede usar <strong>localhost</strong> para enviar solicitudes al <strong>servidor</strong> . <br>  10) Para detener <strong>loadgen</strong> y el <strong>servidor</strong> , ingrese <strong>Ctrl-c</strong> en cada ventana de terminal. <br>  11) En la <strong>ventana del</strong> terminal <strong>loadgen,</strong> desactive el entorno virtual: </p><br><pre> <code class="plaintext hljs">deactivate</code> </pre> <br><h3 id="upakovka-prilozheniya-v-konteynery">  Empaquetar la aplicación en contenedores </h3><br><p>  Para ejecutar la aplicación en GKE, debe empaquetar la aplicación de muestra ( <strong>servidor</strong> y <strong>loadgen</strong> ) en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">contenedores</a> .  Un contenedor es una forma de empaquetar una aplicación para aislarla del entorno. </p><br><p>  Para empacar la aplicación en un contenedor, necesita un <strong>Dockerfile</strong> .  <strong>Un Dockerfile</strong> es un archivo de texto que define comandos para construir el código fuente de una aplicación y sus dependencias en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una imagen Docker.</a>  Después de la compilación, carga la imagen en el registro de contenedores, por ejemplo, Docker Hub o el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Registro de contenedores</a> . </p><br><p>  El ejemplo ya tiene un <strong>Dockerfile</strong> para <strong>server</strong> y <strong>loadgen</strong> con todos los comandos necesarios para ensamblar las imágenes.  A continuación se muestra el <strong>Dockerfile</strong> para <strong>servidor</strong> : </p><br><pre> <code class="plaintext hljs">FROM python:3-slim as base FROM base as builder RUN apt-get -qq update \ &amp;&amp; apt-get install -y --no-install-recommends \ g++ \ &amp;&amp; rm -rf /var/lib/apt/lists/* # Enable unbuffered logging FROM base as final ENV PYTHONUNBUFFERED=1 RUN apt-get -qq update \ &amp;&amp; apt-get install -y --no-install-recommends \ wget WORKDIR /helloserver # Grab packages from builder COPY --from=builder /usr/local/lib/python3.7/ /usr/local/lib/python3.7/ # Add the application COPY . . EXPOSE 8080 ENTRYPOINT [ "python", "server.py" ]</code> </pre> <br><ul><li>  El comando <strong>FROM python: 3-slim as base</strong> le dice a Docker que use la última <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">imagen de Python 3</a> como base. </li><li>  <strong>COPIA del</strong> equipo <strong>.</strong>  <strong>.</strong>  copia los archivos de origen en el directorio de trabajo actual (en nuestro caso, solo <strong>server.py</strong> ) en el sistema de archivos del contenedor. </li><li>  <strong>ENTRYPOINT</strong> define el comando que se utiliza para iniciar el contenedor.  En nuestro caso, este comando es casi el mismo que usó para ejecutar <strong>server.py</strong> desde el código fuente. </li><li>  El comando <strong>EXPOSE</strong> indica que el <strong>servidor</strong> está escuchando en el puerto <strong>8080</strong> .  Este comando no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">proporciona puertos</a> .  Este es algún tipo de documentación que se necesita para abrir el puerto <strong>8080</strong> cuando se inicia el contenedor. </li></ul><br><h3 id="podgotovka-k-konteynerizacii-prilozheniya">  Preparación para la aplicación de contenedores </h3><br><p>  1) Establezca las siguientes variables de entorno.  Reemplace <strong>PROJECT_ID</strong> con su identificador de proyecto GCP. </p><br><pre> <code class="plaintext hljs">export PROJECT_ID="PROJECT_ID"</code> </pre> <br><pre> <code class="plaintext hljs">export GCR_REPO="preparing-istio"</code> </pre> <br><p>  Usando los <strong>valores</strong> <strong>PROJECT_ID</strong> y <strong>GCR_REPO,</strong> etiqueta la imagen de Docker cuando la recopila y la envía al Registro de Contenedores privado. </p><br><p>  2) Establezca el proyecto GCP predeterminado para la <strong>herramienta de</strong> línea de comando <strong>gcloud</strong> . </p><br><pre> <code class="plaintext hljs">gcloud config set project $PROJECT_ID</code> </pre> <br><p>  3) Establezca la zona predeterminada para la <strong>herramienta de</strong> línea de comando <strong>gcloud</strong> . </p><br><pre> <code class="plaintext hljs">gcloud config set compute/zone us-central1-b</code> </pre> <br><p>  4) Asegúrese de que el servicio de registro de contenedores esté incluido en el proyecto GCP. </p><br><pre> <code class="plaintext hljs">gcloud services enable containerregistry.googleapis.com</code> </pre> <br><h3 id="konteynerizaciya-server">  Servidor de contenedores </h3><br><ol><li><p>  Cambie al directorio donde se encuentra el ejemplo del <strong>servidor</strong> : </p><br><pre> <code class="plaintext hljs">cd YOUR_WORKING_DIRECTORY/istio-samples/sample-apps/helloserver/server/</code> </pre> <br></li><li><p>  Cree la imagen utilizando el <strong>Dockerfile</strong> y las variables de entorno que definió anteriormente: </p><br><pre> <code class="plaintext hljs">docker build -t gcr.io/$PROJECT_ID/$GCR_REPO/helloserver:v0.0.1 .</code> </pre> <br></li></ol><br><p>  La <strong>opción -t</strong> representa la etiqueta Docker.  Este es el nombre de la imagen que utiliza al implementar el contenedor. </p><br><ol><li>  Envíe la imagen al Registro de contenedores: <br><pre> <code class="plaintext hljs">docker push gcr.io/$PROJECT_ID/$GCR_REPO/helloserver:v0.0.1</code> </pre> </li></ol><br><h3 id="konteynerizaciya-loadgen">  Containerization loadgen </h3><br><p>  1) Vaya al directorio donde se encuentra el ejemplo de <strong>loadgen</strong> : </p><br><pre> <code class="plaintext hljs">cd ../loadgen</code> </pre> <br><p>  2) Montar la imagen: </p><br><pre> <code class="plaintext hljs">docker build -t gcr.io/$PROJECT_ID/$GCR_REPO/loadgen:v0.0.1 .</code> </pre> <br><p>  3) Enviar la imagen al Registro de contenedores: </p><br><pre> <code class="plaintext hljs">docker push gcr.io/$PROJECT_ID/$GCR_REPO/loadgen:v0.0.1</code> </pre> <br><h3 id="prosmotr-spiska-obrazov">  Ver una lista de imágenes </h3><br><p>  Explore la lista de imágenes en el repositorio y asegúrese de enviar las imágenes: </p><br><pre> <code class="plaintext hljs">gcloud container images list --repository gcr.io/$PROJECT_ID/preparing-istio</code> </pre> <br><p>  El comando muestra los nombres de las imágenes que acabamos de enviar: </p><br><pre> <code class="plaintext hljs">NAME gcr.io/PROJECT_ID/preparing-istio/helloserver gcr.io/PROJECT_ID/preparing-istio/loadgen</code> </pre> <br><h3 id="sozdanie-klastera-gke">  Crear un clúster GKE </h3><br><p>  Estos contenedores se pueden ejecutar en la máquina virtual Cloud Shell o en la computadora con el <strong>comando docker run</strong> .  Pero en un entorno de producción, necesita una forma de orquestar los contenedores de forma centralizada.  Por ejemplo, necesitamos un sistema que garantice que los contenedores siempre funcionen, y necesitamos una forma de acercar y lanzar instancias adicionales de contenedores si aumenta el tráfico. </p><br><p>  Puede usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GKE</a> para ejecutar aplicaciones de contenedor.  GKE es una plataforma de orquestación de contenedores que agrupa máquinas virtuales.  Cada máquina virtual se llama host.  Los clústeres GKE se basan en el sistema de gestión de clústeres de código abierto Kubernetes.  Kubernetes proporciona mecanismos para interactuar con el clúster. </p><br><p>  Crear un clúster GKE: </p><br><p>  1) Crear un clúster: </p><br><pre> <code class="plaintext hljs">gcloud container clusters create istioready \ --cluster-version latest \ --machine-type=n1-standard-2 \ --num-nodes 4</code> </pre> <br><p>  El comando <strong>gcloud</strong> crea un clúster <strong>istioready</strong> en el proyecto GCP y la zona predeterminada que especificó.  Para iniciar Istio, le recomendamos que tenga al menos 4 nodos y una máquina virtual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">n1-standard-2</a> . </p><br><p>  El equipo crea un clúster durante varios minutos.  Cuando el clúster está listo, el comando emite un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mensaje</a> similar. </p><br><p>  2) Especifique las credenciales en la <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">herramienta de</a></strong> línea de comandos <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">kubectl</a></strong> para usarla para administrar el clúster: </p><br><pre> <code class="plaintext hljs">gcloud container clusters get-credentials istioready</code> </pre> <br><p>  3) Ahora puedes comunicarte con Kubernetes a través de <strong>kubectl</strong> .  Por ejemplo, con el siguiente comando puede averiguar el estado de los nodos: </p><br><pre> <code class="plaintext hljs">kubectl get nodes</code> </pre> <br><p>  El comando muestra una lista de nodos: </p><br><pre> <code class="plaintext hljs">NAME STATUS ROLES AGE VERSION gke-istoready-default-pool-dbeb23dc-1vg0 Ready &lt;none&gt; 99s v1.13.6-gke.13 gke-istoready-default-pool-dbeb23dc-36z5 Ready &lt;none&gt; 100s v1.13.6-gke.13 gke-istoready-default-pool-dbeb23dc-fj7s Ready &lt;none&gt; 99s v1.13.6-gke.13 gke-istoready-default-pool-dbeb23dc-wbjw Ready &lt;none&gt; 99s v1.13.6-gke.13</code> </pre> <br><h3 id="klyuchevye-ponyatiya-kubernetes">  Conceptos clave de Kubernetes </h3><br><p>  El diagrama muestra la aplicación en GKE: </p><br><p><img src="https://habrastorage.org/webt/-s/x2/uj/-sx2ujtlifvzdtixzdqpnr9jzva.png"></p><br><p>  Antes de implementar contenedores en GKE, observe los conceptos clave de Kubernetes.  Hay enlaces al final si quieres saber más. </p><br><ul><li>  <strong>Nodos y agrupaciones</strong> .  En GKE, un nodo es una máquina virtual.  En otras plataformas de Kubernetes, el host puede ser una computadora o una máquina virtual.  Un clúster es una colección de nodos que se pueden considerar como un todo y donde se implementa una aplicación en contenedores. </li><li>  <strong>Vainas</strong>  En Kubernetes, los contenedores corren en vainas.  Una vaina en Kubernetes es una unidad indivisible.  Una vaina contiene uno o más contenedores.  <strong>Implemente</strong> el servidor y los <strong>contenedores loadgen</strong> en pods separados.  Cuando hay varios contenedores en un pod (por ejemplo, un servidor de aplicaciones y un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">servidor proxy</a> ), los contenedores se administran como un solo objeto y comparten los recursos del pod. </li><li>  <strong>Despliegue</strong>  En Kubernetes, la implementación es un objeto que es una colección de pods idénticos.  La implementación ejecuta varias réplicas de pods distribuidos en los nodos del clúster.  La implementación reemplaza automáticamente los pods que fallan o no responden. </li><li>  <strong>Servicio de kubernetes</strong> .  Cuando ejecuta el código de la aplicación en GKE, la conexión entre <strong>loadgen</strong> y el <strong>servidor</strong> cambia.  Cuando inició los servicios en la máquina virtual Cloud Shell o en la computadora, envió solicitudes al <strong>servidor</strong> en <strong>localhost: 8080</strong> .  Después de la implementación en GKE, los pods se ejecutan en los nodos disponibles.  De forma predeterminada, no puede controlar en qué host se está ejecutando, por lo que los pod no tienen direcciones IP permanentes. <br>  Para obtener la dirección IP del <strong>servidor</strong> , debe definir la abstracción de red en la parte superior de los pods.  Este es el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">servicio de Kubernetes</a> .  El servicio Kubernetes proporciona un punto final permanente para un conjunto de pods.  Existen varios <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tipos de servicios</a> .  <strong>El servidor</strong> utiliza un <strong>LoadBalancer</strong> , que proporciona una dirección IP externa para contactar con el <strong>servidor</strong> desde fuera del clúster. <br>  Kubernetes también tiene un sistema DNS integrado que asigna nombres DNS (por ejemplo, <strong>helloserver.default.cluster.local</strong> ) a los servicios.  Gracias a esto, los pods dentro del clúster se comunican con otros pods en el clúster en una dirección fija.  El nombre DNS no se puede usar fuera del clúster, como en Cloud Shell o en una computadora. </li></ul><br><h3 id="manifesty-kubernetes">  Manifiestos de Kubernetes </h3><br><p>  Cuando inició la aplicación desde el código fuente, utilizó el imperativo comando <strong>python3</strong> </p><br><p>  <strong>server.py</strong> </p><br><p>  Imperativo implica el verbo: "hazlo". </p><br><p>  Kubernetes usa un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">modelo declarativo</a> .  Esto significa que no le decimos a Kubernetes qué debe hacerse exactamente, sino que describimos el estado deseado.  Por ejemplo, Kubernetes inicia y detiene los pods según sea necesario, para que el estado real del sistema sea el deseado. </p><br><p>  Usted especifica el estado deseado en manifiestos o archivos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">YAML</a> .  El archivo YAML contiene especificaciones para uno o más objetos de Kubernetes. </p><br><p>  El ejemplo contiene el archivo YAML para <strong>servidor</strong> y <strong>loadgen</strong> .  Cada archivo YAML indica el estado deseado del objeto de implementación y el servicio Kubernetes. </p><br><p>  <strong>server.yaml</strong> </p><br><pre> <code class="plaintext hljs">apiVersion: apps/v1 kind: Deployment metadata: name: helloserver spec: selector: matchLabels: app: helloserver replicas: 1 template: metadata: labels: app: helloserver spec: terminationGracePeriodSeconds: 5 restartPolicy: Always containers: - name: main image: gcr.io/google-samples/istio/helloserver:v0.0.1 imagePullPolicy: Always</code> </pre> <br><ul><li>  <strong>kind</strong> indica el tipo de objeto. </li><li>  <strong>metadata.name</strong> indica el nombre de la implementación. </li><li>  La primera <strong>especificación de</strong> campo contiene una descripción del estado deseado. </li><li>  <strong>spec.replicas</strong> indica el número deseado de pods. </li><li>  La sección <strong>spec.template</strong> define la plantilla de <strong>pod</strong> .  En la especificación de pods hay un campo de <strong>imagen</strong> donde se indica el nombre de la imagen que se extraerá del Registro de contenedores. </li></ul><br><p>  El servicio se define de la siguiente manera: </p><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Service metadata: name: hellosvc spec: type: LoadBalancer selector: app: helloserver ports: - name: http port: 80 targetPort: 8080</code> </pre> <br><ul><li>  <strong>LoadBalancer</strong> : los clientes envían solicitudes a la dirección IP del equilibrador de carga, que tiene una dirección IP fija y a la que se puede acceder desde fuera del clúster. </li><li>  <strong>targetPort</strong> : como recordará, el comando <strong>EXPOSE 8080</strong> en el <strong>Dockerfile</strong> no proporcionó puertos.  Proporciona el puerto <strong>8080</strong> para que pueda llegar al contenedor del <strong>servidor</strong> desde fuera del clúster.  En nuestro caso, <strong>hellosvc.default.cluster.local: 80</strong> (nombre corto: <strong>hellosvc</strong> ) corresponde al puerto <strong>8080 de la</strong> dirección IP del pod <strong>helloserver</strong> . </li><li>  <strong>puerto</strong> : este es el número de puerto donde otros servicios en el clúster enviarán solicitudes. </li></ul><br><p>  <strong>loadgen.yaml</strong> </p><br><p>  El objeto de implementación en <strong>loadgen.yaml</strong> es similar a <strong>server.yaml</strong> .  La diferencia es que el objeto de implementación contiene una sección <strong>env</strong> .  Define las variables de entorno que necesita <strong>loadgen</strong> y que establece cuando inicia la aplicación desde el código fuente. </p><br><pre> <code class="plaintext hljs">apiVersion: apps/v1 kind: Deployment metadata: name: loadgenerator spec: selector: matchLabels: app: loadgenerator replicas: 1 template: metadata: labels: app: loadgenerator spec: terminationGracePeriodSeconds: 5 restartPolicy: Always containers: - name: main image: gcr.io/google-samples/istio/loadgen:v0.0.1 imagePullPolicy: Always env: - name: SERVER_ADDR value: "http://hellosvc:80/" - name: REQUESTS_PER_SECOND value: "10" resources: requests: cpu: 300m memory: 256Mi limits: cpu: 500m memory: 512Mi</code> </pre> <br><p>  Como <strong>loadgen</strong> no acepta solicitudes entrantes, <strong>ClusterIP se</strong> especifica para el campo de <strong>tipo</strong> .  Este tipo proporciona una dirección IP fija que los servicios en el clúster pueden usar, pero esta dirección IP no se proporciona a clientes externos. </p><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Service metadata: name: loadgensvc spec: type: ClusterIP selector: app: loadgenerator ports: - name: http port: 80 targetPort: 8080</code> </pre> <br><h3 id="razvertyvanie-konteynerov-v-gke">  Implementar contenedores en GKE </h3><br><p>  1) Vaya al directorio donde se encuentra el ejemplo del <strong>servidor</strong> : </p><br><pre> <code class="plaintext hljs">cd YOUR_WORKING_DIRECTORY/istio-samples/sample-apps/helloserver/server/</code> </pre> <br><p>  2) Abra <strong>server.yaml</strong> en un editor de texto. <br>  3) Reemplace el nombre en el campo de <strong>imagen</strong> con el nombre de su imagen Docker. </p><br><pre> <code class="plaintext hljs">image: gcr.io/PROJECT_ID/preparing-istio/helloserver:v0.0.1</code> </pre> <br><p>  Reemplace <strong>PROJECT_ID</strong> con el identificador de su proyecto GCP. <br>  4) Guarde y cierre <strong>server.yaml</strong> . <br>  5) Expande el archivo YAML en Kubernetes: </p><br><pre> <code class="plaintext hljs">kubectl apply -f server.yaml</code> </pre> <br><p>  Después de completar con éxito, el comando emite el siguiente código: </p><br><pre> <code class="plaintext hljs">deployment.apps/helloserver created service/hellosvc created</code> </pre> <br><p>  6) Vaya al directorio donde se encuentra <strong>loadgen</strong> : </p><br><pre> <code class="plaintext hljs">cd ../loadgen</code> </pre> <br><p>  7) Abra <strong>loadgen.yaml</strong> en un editor de texto. <br>  8) Reemplace el nombre en el campo de <strong>imagen</strong> con el nombre de su imagen Docker. </p><br><pre> <code class="plaintext hljs">image: gcr.io/PROJECT_ID/preparing-istio/loadgenv0.0.1</code> </pre> <br><p>  Reemplace <strong>PROJECT_ID</strong> con el identificador de su proyecto GCP. <br>  9) Guarde y cierre <strong>loadgen.yaml</strong> , cierre el editor de texto. <br>  10) Expanda el archivo YAML en Kubernetes: </p><br><pre> <code class="plaintext hljs">kubectl apply -f loadgen.yaml</code> </pre> <br><p>  Después de completar con éxito, el comando emite el siguiente código: </p><br><pre> <code class="plaintext hljs">deployment.apps/loadgenerator created service/loadgensvc created</code> </pre> <br><p>  11) Verifique el estado de los hogares: </p><br><pre> <code class="plaintext hljs">kubectl get pods</code> </pre> <br><p>  El comando muestra el estado: </p><br><pre> <code class="plaintext hljs">NAME READY STATUS RESTARTS AGE helloserver-69b9576d96-mwtcj 1/1 Running 0 58s loadgenerator-774dbc46fb-gpbrz 1/1 Running 0 57s</code> </pre> <br><p>  12) Extraiga los registros de la aplicación de la cápsula <strong>loadgen</strong> .  Reemplace <strong>POD_ID</strong> con el identificador de la respuesta anterior. </p><br><pre> <code class="plaintext hljs">kubectl logs loadgenerator-POD_ID</code> </pre> <br><p>  13) Obtenga las <strong>IP</strong> externas de <strong>hellosvc</strong> : </p><br><pre> <code class="plaintext hljs">kubectl get service</code> </pre> <br><p>  La respuesta del comando se parece a esto: </p><br><pre> <code class="plaintext hljs">NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE hellosvc LoadBalancer 10.81.15.158 192.0.2.1 80:31127/TCP 33m kubernetes ClusterIP 10.81.0.1 &lt;none&gt; 443/TCP 93m loadgensvc ClusterIP 10.81.15.155 &lt;none&gt; 80/TCP 4m52s</code> </pre> <br><p>  14) Enviar una solicitud a <strong>hellosvc</strong> : reemplace <strong>EXTERNAL_IP</strong> con la dirección IP externa de <strong>hellosvc</strong> . </p><br><pre> <code class="plaintext hljs">curl http://EXTERNAL_IP</code> </pre> <br><h3 id="beremsya-za-istio">  Tackle Istio </h3><br><p>  Ya tiene una aplicación implementada en GKE.  <strong>loadgen</strong> puede usar Kubernetes DNS ( <strong>hellosvc: 80</strong> ) para enviar solicitudes al <strong>servidor</strong> , y usted puede enviar solicitudes al <strong>servidor</strong> en una dirección IP externa.  Aunque Kubernetes tiene muchas características, falta información sobre los servicios: </p><br><ul><li>  <strong>¿Cómo interactúan los servicios?</strong>  ¿Cuál es la relación entre los servicios?  ¿Cómo es el tráfico entre servicios?  Sabe que <strong>loadgen</strong> envía solicitudes al <strong>servidor</strong> , pero imagine que no sabe nada sobre la aplicación.  Para responder a estas preguntas, miramos la lista de hogares en funcionamiento en GKE. </li><li>  <strong>Métricas</strong>  ¿Cuánto tiempo responde el <strong>servidor</strong> a una solicitud entrante?  ¿Cuántas solicitudes por segundo van al servidor?  ¿Da mensajes de error? </li><li>  <strong>Información de seguridad</strong> .  <strong>¿Es el</strong> tráfico entre <strong>loadgen</strong> y el <strong>servidor</strong> simplemente a través de <strong>HTTP</strong> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mTLS</a> ? </li></ul><br><p>  Todas estas preguntas son respondidas por Istio.  Para hacer esto, Istio coloca un proxy de sidecar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Envoy</a> en cada pod.  El proxy de envío intercepta todo el tráfico entrante y saliente a los contenedores de aplicaciones.  Esto significa que el <strong>servidor</strong> y <strong>loadgen</strong> reciben proxies de sidecar de Envoy, y todo el tráfico desde <strong>loadgen</strong> al <strong>servidor</strong> pasa por proxies de Envoy. </p><br><p>  Las conexiones entre los representantes de Envoy forman una malla de servicio.  La arquitectura de malla de servicio proporciona una capa de control sobre Kubernetes. </p><br><p><img src="https://habrastorage.org/webt/7n/sk/z-/7nskz-5os2onyoaaf5kz5x38ve4.png"></p><br><p>  Una vez que los servidores proxy de Envoy se ejecutan en sus contenedores, Istio se puede instalar en la parte superior del clúster GKE, casi sin cambiar el código de la aplicación.  Pero trabajó un poco para preparar la aplicación para la administración con Istio: </p><br><ul><li>  Servicios para todos los contenedores.  Las <strong>implementaciones de</strong> <strong>servidor</strong> y <strong>loadgen están</strong> vinculadas por el servicio Kubernetes.  Incluso <strong>loadgen</strong> , que no recibe solicitudes entrantes, tiene un servicio. </li><li>  Los puertos en los servicios deben tener nombres.  Aunque los puertos de servicio pueden dejarse sin nombre en GKE, Istio requiere un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nombre de puerto</a> de acuerdo con su protocolo.  En el archivo YAML, el puerto para el <strong>servidor</strong> se llama <strong>http</strong> porque el servidor usa el <strong>protocolo HTTP</strong> .  Si el <strong>servicio</strong> usara <strong>gRPC</strong> , usted nombraría el puerto <strong>grpc</strong> . </li><li>  Las implementaciones están marcadas.  Por lo tanto, puede usar las funciones de administración de tráfico de Istio, por ejemplo, compartir tráfico entre versiones del mismo servicio. </li></ul><br><h3 id="ustanovka-istio">  Instalar Istio </h3><br><p>  Hay dos formas de instalar Istio.  Puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">habilitar la extensión Istio en GKE</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">instalar la versión de código abierto de Istio</a> en un clúster.  Con Istio en GKE, puede administrar fácilmente la instalación y actualización de Istio como parte del ciclo de vida del clúster GKE.  Si necesita la última versión de Istio o más control sobre la configuración del panel de control de Istio, instale la versión de código abierto en lugar de la extensión Istio en GKE.  Para decidir sobre el enfoque, lea el artículo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¿Necesito Istio en GKE?</a>  . </p><br><p>  Seleccione una opción, estudie el manual apropiado y siga las instrucciones para instalar Istio en el clúster.  Si desea usar Istio con su aplicación recién implementada, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">habilite la incrustación de sidecar</a> para el espacio de nombres <strong>predeterminado</strong> . </p><br><h3 id="ochistka">  Limpieza </h3><br><p>  Para asegurarse de que los recursos para los recursos que utilizó en esta guía no se debiten de su cuenta de Google Cloud Platform, elimine el clúster de contenedores cuando instale Istio y juegue con la aplicación de muestra.  Esto eliminará todos los recursos del clúster, como instancias de cómputo, discos y recursos de red. </p><br><h3 id="chto-dalshe">  Que sigue </h3><br><ul><li><p>  Aprende las siguientes tecnologías: </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Docker</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Contenedores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Registro de contenedores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kubernetes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gke</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Servicio de malla</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Isstio</a> </li></ol><br></li><li><p>  Aprende las siguientes herramientas: </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cloud sdk</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>Referencia de gcloud</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>kubectl</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>acoplador</strong></a> </li></ol><br></li><li><p>  Aprende los conceptos de Kubernetes: </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Racimos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nudos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Vainas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Servicios</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Despliegue</a> </li></ol><br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/469515/">https://habr.com/ru/post/469515/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../469499/index.html">Cómo conquistamos Parallels Inicie sesión con Apple</a></li>
<li><a href="../469503/index.html">Ciberseguridad: protegemos los datos de suscriptores de fugas en 2019</a></li>
<li><a href="../469505/index.html">3 formas prácticas de llevar negocios a los mercados extranjeros: enfoques y técnicas de compañías reales</a></li>
<li><a href="../469507/index.html">Tercera vulnerabilidad del cliente de Windows Steam, pero no 0 días</a></li>
<li><a href="../469509/index.html">Esquemas angulares, o cómo escribí mi plantilla para cli angular</a></li>
<li><a href="../469521/index.html">Compré una motocicleta para andar, no para caer</a></li>
<li><a href="../469523/index.html">Dependencia del rendimiento del código en el contexto de la declaración de variables en JavaScript</a></li>
<li><a href="../469525/index.html">Sistema de control automatizado para una excavadora minera.</a></li>
<li><a href="../469527/index.html">¿El intercomunicador es un oído espía?</a></li>
<li><a href="../469529/index.html">La representación de texto te odia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>