<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>   Preparando la aplicaci贸n para Istio  ご </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Istio es una herramienta conveniente para conectar, proteger y monitorear aplicaciones distribuidas. Istio utiliza una variedad de tecnolog铆as para la...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Preparando la aplicaci贸n para Istio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/469515/"><p><img src="https://habrastorage.org/webt/qy/yw/v1/qyywv1qmzphh1svbblasrxjc6ym.jpeg"></p><br><p>  Istio es una herramienta conveniente para conectar, proteger y monitorear aplicaciones distribuidas.  Istio utiliza una variedad de tecnolog铆as para lanzar y administrar software a gran escala, incluidos contenedores para empaquetar c贸digo de aplicaci贸n y dependencias para la implementaci贸n, y Kubernetes para administrar estos contenedores.  Por lo tanto, para trabajar con Istio, debe saber c贸mo funciona una aplicaci贸n con varios servicios basados en estas tecnolog铆as <em>sin</em> Istio.  Si ya conoce estas herramientas y conceptos, no dude en omitir esta gu铆a e ir directamente a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Instalar Istio en Google Kubernetes Engine (GKE)</a> o instalar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Istio en la</a> extensi贸n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GKE</a> . </p><br><p>  Esta es una gu铆a paso a paso donde veremos todo el proceso desde el c贸digo fuente hasta un contenedor en GKE para que pueda obtener una idea b谩sica de estas tecnolog铆as usando un ejemplo.  Tambi茅n ver谩 c贸mo Istio aprovecha estas tecnolog铆as.  Se supone que no sabe nada sobre contenedores, Kubernetes, servicio de malla o Istio. </p><a name="habracut"></a><br><h3 id="zadachi">  Las tareas </h3><br><p>  En esta gu铆a, completar谩 las siguientes tareas: </p><br><ol><li>  Explorando una aplicaci贸n sencilla de hello world con varios servicios. </li><li>  Ejecutando la aplicaci贸n desde el c贸digo fuente. </li><li> Embalaje de la aplicaci贸n en contenedores. </li><li>  Crear un cl煤ster de Kubernetes </li><li>  Implemente contenedores en un cl煤ster. </li></ol><br><h3 id="prezhde-chem-nachat">  Antes de empezar </h3><br><p>  Siga las instrucciones para habilitar la API de Kubernetes Engine: </p><br><ol><li>  Vaya a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la p谩gina de Kubernetes Engine</a> en la consola de Google Cloud Platform. </li><li>  Crea o selecciona un proyecto. </li><li>  Espere a que se activen la API y los servicios relacionados.  Esto puede tomar varios minutos. </li><li>  Aseg煤rese de que la facturaci贸n est茅 configurada para el proyecto Google Cloud Platform.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Obtenga informaci贸n sobre c贸mo habilitar la facturaci贸n</a> . </li></ol><br><p>  En esta gu铆a, puede usar Cloud Shell, que prepara la m谩quina virtual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">peque帽a g1 en Google Compute Engine</a> con Linux basado en Debian, o una computadora Linux o macOS. </p><br><h3 id="variant-a-ispolzovanie-cloud-shell">  Opci贸n A: uso de Cloud Shell </h3><br><p>  Beneficios de usar Cloud Shell: </p><br><ul><li>  Los entornos de desarrollo Python 2 y Python 3 (incluido <strong>virtualenv</strong> ) est谩n totalmente personalizados. </li><li>  Las <strong>herramientas de</strong> l铆nea de <strong>comandos gcloud</strong> , <strong>docker</strong> , <strong>git</strong> y <strong>kubectl</strong> que usaremos ya est谩n instaladas. </li><li>  Tiene varios <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">editores de texto</a> para elegir: <br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El editor de c贸digo</a> que se abre con el icono de edici贸n en la parte superior de la ventana de Cloud Shell. </li><li>  Emacs, Vim o Nano que se abren desde la l铆nea de comandos en Cloud Shell. </li></ol></li></ul><br><p>  Para usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cloud Shell</a> : </p><br><ol><li>  Vaya a la consola de GCP. </li><li>  Haga clic en el bot贸n <strong>Activar Cloud Shell</strong> en la parte superior de la ventana de la consola GCP. </li></ol><br><p><img src="https://habrastorage.org/webt/yu/sh/9x/yush9xie9_peummad02lgu2n5x8.png"></p><br><p>  En la parte inferior de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la consola GCP,</a> en una nueva ventana, se abre una sesi贸n de Cloud Shell con una l铆nea de comando. </p><br><p><img src="https://habrastorage.org/webt/yi/no/-q/yino-qj5bwaluwxlo3xtf0yr7ty.png"></p><br><h3 id="variant-b-ispolzovanie-instrumentov-komandnoy-stroki-lokalno">  Opci贸n B: uso local de herramientas de l铆nea de comando </h3><br><p>  Si va a trabajar en una computadora con Linux o macOS, debe configurar e instalar los siguientes componentes: </p><br><ol><li><p>  Configure <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">su entorno de desarrollo Python 3 y Python 2</a> . </p><br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Instale Cloud SDK</a> con la <strong>herramienta de</strong> l铆nea de comandos <strong>gcloud</strong> . </p><br></li><li><p>  Instale <strong>kubectl</strong> , una herramienta de l铆nea de comandos para trabajar con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kubernetes</a> . </p><br><pre><code class="plaintext hljs">gcloud components install kubectl</code> </pre> <br></li><li><p>  Instale <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Docker Community Edition (CE)</a> .  Utilizar谩 la herramienta de l铆nea de comandos de Docker para crear im谩genes de contenedor para una aplicaci贸n de muestra. </p><br></li><li><p>  Instale la herramienta de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">control de versiones de Git</a> para obtener una aplicaci贸n de muestra con GitHub. </p><br></li></ol><br><h3 id="zagruzka-primera-koda">  Descargar c贸digo de muestra </h3><br><ol><li><p>  Descargue el c贸digo fuente de <strong>helloserver</strong> : </p><br><pre> <code class="plaintext hljs">git clone https://github.com/GoogleCloudPlatform/istio-samples</code> </pre> <br></li><li><p>  Vaya al directorio del c贸digo de muestra: </p><br><pre> <code class="plaintext hljs">cd istio-samples/sample-apps/helloserver</code> </pre> <br></li></ol><br><h3 id="izuchenie-prilozheniya-s-neskolkimi-servisami">  Explorando una aplicaci贸n multiservicio </h3><br><p>  La aplicaci贸n de muestra est谩 escrita en Python y consta de dos componentes que interact煤an con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">REST</a> : </p><br><ul><li>  <strong>servidor</strong> : un servidor simple con un punto final <strong>GET, /</strong> , que muestra "hello world" en la consola. </li><li>  <strong>loadgen</strong> : un script que env铆a tr谩fico al <strong>servidor</strong> , con un n煤mero configurable de solicitudes por segundo. </li></ul><br><p><img src="https://habrastorage.org/webt/b1/ky/lj/b1kyljxdkjdci12qtle2w3dmtjw.png"></p><br><h3 id="zapusk-prilozheniya-iz-ishodnogo-koda">  Ejecutar una aplicaci贸n desde el origen </h3><br><p>  Para aprender una aplicaci贸n de muestra, ejec煤tela en Cloud Shell o en una computadora. <br>  1) En el <strong>directorio istio-samples / sample-apps / helloserver</strong> , ejecute el <strong>servidor</strong> : </p><br><pre> <code class="plaintext hljs">python3 server/server.py</code> </pre> <br><p>  Cuando se inicia el <strong>servidor</strong> , se muestra lo siguiente: </p><br><pre> <code class="plaintext hljs">INFO:root:Starting server...</code> </pre> <br><p>  2) Abra otra ventana de terminal para enviar solicitudes al <strong>servidor</strong> .  Si est谩 utilizando Cloud Shell, haga clic en el icono Agregar para abrir otra sesi贸n. <br>  3) Enviar una solicitud al <strong>servidor</strong> : </p><br><pre> <code class="plaintext hljs">curl http://localhost:8080</code> </pre> <br><p>  respuestas del servidor: </p><br><pre> <code class="plaintext hljs">Hello World!</code> </pre> <br><p>  4) Desde el directorio donde descarg贸 el c贸digo de muestra, vaya al directorio que contiene <strong>loadgen</strong> : </p><br><pre> <code class="plaintext hljs">cd YOUR_WORKING_DIRECTORY/istio-samples/sample-apps/helloserver/loadgen</code> </pre> <br><p>  5) Cree las siguientes variables de entorno: </p><br><pre> <code class="plaintext hljs">export SERVER_ADDR=http://localhost:8080 export REQUESTS_PER_SECOND=5</code> </pre> <br><p>  6) Ejecute <strong>virtualenv</strong> : </p><br><pre> <code class="plaintext hljs">virtualenv --python python3 env</code> </pre> <br><p>  7) Activar el entorno virtual: </p><br><pre> <code class="plaintext hljs">source env/bin/activate</code> </pre> <br><p>  8) Establecer requisitos para <strong>loadgen</strong> : </p><br><pre> <code class="plaintext hljs">pip3 install -r requirements.txt</code> </pre> <br><p>  9) Ejecute <strong>loadgen</strong> : </p><br><pre> <code class="plaintext hljs">python3 loadgen.py</code> </pre> <br><p>  Cuando se inicia, <strong>loadgen</strong> muestra el siguiente mensaje: </p><br><pre> <code class="plaintext hljs">Starting loadgen: 2019-05-20 10:44:12.448415 5 request(s) complete to http://localhost:8080</code> </pre> <br><p>  En otra ventana de terminal, el <strong>servidor</strong> muestra los siguientes mensajes a la consola: </p><br><pre> <code class="plaintext hljs">127.0.0.1 - - [21/Jun/2019 14:22:01] "GET / HTTP/1.1" 200 - INFO:root:GET request, Path: / Headers: Host: localhost:8080 User-Agent: python-requests/2.22.0 Accept-Encoding: gzip, deflate Accept: */*</code> </pre> <br><p>  Desde una perspectiva de red, toda la aplicaci贸n se ejecuta en el mismo host (computadora local o m谩quina virtual Cloud Shell).  Por lo tanto, puede usar <strong>localhost</strong> para enviar solicitudes al <strong>servidor</strong> . <br>  10) Para detener <strong>loadgen</strong> y el <strong>servidor</strong> , ingrese <strong>Ctrl-c</strong> en cada ventana de terminal. <br>  11) En la <strong>ventana del</strong> terminal <strong>loadgen,</strong> desactive el entorno virtual: </p><br><pre> <code class="plaintext hljs">deactivate</code> </pre> <br><h3 id="upakovka-prilozheniya-v-konteynery">  Empaquetar la aplicaci贸n en contenedores </h3><br><p>  Para ejecutar la aplicaci贸n en GKE, debe empaquetar la aplicaci贸n de muestra ( <strong>servidor</strong> y <strong>loadgen</strong> ) en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">contenedores</a> .  Un contenedor es una forma de empaquetar una aplicaci贸n para aislarla del entorno. </p><br><p>  Para empacar la aplicaci贸n en un contenedor, necesita un <strong>Dockerfile</strong> .  <strong>Un Dockerfile</strong> es un archivo de texto que define comandos para construir el c贸digo fuente de una aplicaci贸n y sus dependencias en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una imagen Docker.</a>  Despu茅s de la compilaci贸n, carga la imagen en el registro de contenedores, por ejemplo, Docker Hub o el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Registro de contenedores</a> . </p><br><p>  El ejemplo ya tiene un <strong>Dockerfile</strong> para <strong>server</strong> y <strong>loadgen</strong> con todos los comandos necesarios para ensamblar las im谩genes.  A continuaci贸n se muestra el <strong>Dockerfile</strong> para <strong>servidor</strong> : </p><br><pre> <code class="plaintext hljs">FROM python:3-slim as base FROM base as builder RUN apt-get -qq update \ &amp;&amp; apt-get install -y --no-install-recommends \ g++ \ &amp;&amp; rm -rf /var/lib/apt/lists/* # Enable unbuffered logging FROM base as final ENV PYTHONUNBUFFERED=1 RUN apt-get -qq update \ &amp;&amp; apt-get install -y --no-install-recommends \ wget WORKDIR /helloserver # Grab packages from builder COPY --from=builder /usr/local/lib/python3.7/ /usr/local/lib/python3.7/ # Add the application COPY . . EXPOSE 8080 ENTRYPOINT [ "python", "server.py" ]</code> </pre> <br><ul><li>  El comando <strong>FROM python: 3-slim as base</strong> le dice a Docker que use la 煤ltima <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">imagen de Python 3</a> como base. </li><li>  <strong>COPIA del</strong> equipo <strong>.</strong>  <strong>.</strong>  copia los archivos de origen en el directorio de trabajo actual (en nuestro caso, solo <strong>server.py</strong> ) en el sistema de archivos del contenedor. </li><li>  <strong>ENTRYPOINT</strong> define el comando que se utiliza para iniciar el contenedor.  En nuestro caso, este comando es casi el mismo que us贸 para ejecutar <strong>server.py</strong> desde el c贸digo fuente. </li><li>  El comando <strong>EXPOSE</strong> indica que el <strong>servidor</strong> est谩 escuchando en el puerto <strong>8080</strong> .  Este comando no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">proporciona puertos</a> .  Este es alg煤n tipo de documentaci贸n que se necesita para abrir el puerto <strong>8080</strong> cuando se inicia el contenedor. </li></ul><br><h3 id="podgotovka-k-konteynerizacii-prilozheniya">  Preparaci贸n para la aplicaci贸n de contenedores </h3><br><p>  1) Establezca las siguientes variables de entorno.  Reemplace <strong>PROJECT_ID</strong> con su identificador de proyecto GCP. </p><br><pre> <code class="plaintext hljs">export PROJECT_ID="PROJECT_ID"</code> </pre> <br><pre> <code class="plaintext hljs">export GCR_REPO="preparing-istio"</code> </pre> <br><p>  Usando los <strong>valores</strong> <strong>PROJECT_ID</strong> y <strong>GCR_REPO,</strong> etiqueta la imagen de Docker cuando la recopila y la env铆a al Registro de Contenedores privado. </p><br><p>  2) Establezca el proyecto GCP predeterminado para la <strong>herramienta de</strong> l铆nea de comando <strong>gcloud</strong> . </p><br><pre> <code class="plaintext hljs">gcloud config set project $PROJECT_ID</code> </pre> <br><p>  3) Establezca la zona predeterminada para la <strong>herramienta de</strong> l铆nea de comando <strong>gcloud</strong> . </p><br><pre> <code class="plaintext hljs">gcloud config set compute/zone us-central1-b</code> </pre> <br><p>  4) Aseg煤rese de que el servicio de registro de contenedores est茅 incluido en el proyecto GCP. </p><br><pre> <code class="plaintext hljs">gcloud services enable containerregistry.googleapis.com</code> </pre> <br><h3 id="konteynerizaciya-server">  Servidor de contenedores </h3><br><ol><li><p>  Cambie al directorio donde se encuentra el ejemplo del <strong>servidor</strong> : </p><br><pre> <code class="plaintext hljs">cd YOUR_WORKING_DIRECTORY/istio-samples/sample-apps/helloserver/server/</code> </pre> <br></li><li><p>  Cree la imagen utilizando el <strong>Dockerfile</strong> y las variables de entorno que defini贸 anteriormente: </p><br><pre> <code class="plaintext hljs">docker build -t gcr.io/$PROJECT_ID/$GCR_REPO/helloserver:v0.0.1 .</code> </pre> <br></li></ol><br><p>  La <strong>opci贸n -t</strong> representa la etiqueta Docker.  Este es el nombre de la imagen que utiliza al implementar el contenedor. </p><br><ol><li>  Env铆e la imagen al Registro de contenedores: <br><pre> <code class="plaintext hljs">docker push gcr.io/$PROJECT_ID/$GCR_REPO/helloserver:v0.0.1</code> </pre> </li></ol><br><h3 id="konteynerizaciya-loadgen">  Containerization loadgen </h3><br><p>  1) Vaya al directorio donde se encuentra el ejemplo de <strong>loadgen</strong> : </p><br><pre> <code class="plaintext hljs">cd ../loadgen</code> </pre> <br><p>  2) Montar la imagen: </p><br><pre> <code class="plaintext hljs">docker build -t gcr.io/$PROJECT_ID/$GCR_REPO/loadgen:v0.0.1 .</code> </pre> <br><p>  3) Enviar la imagen al Registro de contenedores: </p><br><pre> <code class="plaintext hljs">docker push gcr.io/$PROJECT_ID/$GCR_REPO/loadgen:v0.0.1</code> </pre> <br><h3 id="prosmotr-spiska-obrazov">  Ver una lista de im谩genes </h3><br><p>  Explore la lista de im谩genes en el repositorio y aseg煤rese de enviar las im谩genes: </p><br><pre> <code class="plaintext hljs">gcloud container images list --repository gcr.io/$PROJECT_ID/preparing-istio</code> </pre> <br><p>  El comando muestra los nombres de las im谩genes que acabamos de enviar: </p><br><pre> <code class="plaintext hljs">NAME gcr.io/PROJECT_ID/preparing-istio/helloserver gcr.io/PROJECT_ID/preparing-istio/loadgen</code> </pre> <br><h3 id="sozdanie-klastera-gke">  Crear un cl煤ster GKE </h3><br><p>  Estos contenedores se pueden ejecutar en la m谩quina virtual Cloud Shell o en la computadora con el <strong>comando docker run</strong> .  Pero en un entorno de producci贸n, necesita una forma de orquestar los contenedores de forma centralizada.  Por ejemplo, necesitamos un sistema que garantice que los contenedores siempre funcionen, y necesitamos una forma de acercar y lanzar instancias adicionales de contenedores si aumenta el tr谩fico. </p><br><p>  Puede usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GKE</a> para ejecutar aplicaciones de contenedor.  GKE es una plataforma de orquestaci贸n de contenedores que agrupa m谩quinas virtuales.  Cada m谩quina virtual se llama host.  Los cl煤steres GKE se basan en el sistema de gesti贸n de cl煤steres de c贸digo abierto Kubernetes.  Kubernetes proporciona mecanismos para interactuar con el cl煤ster. </p><br><p>  Crear un cl煤ster GKE: </p><br><p>  1) Crear un cl煤ster: </p><br><pre> <code class="plaintext hljs">gcloud container clusters create istioready \ --cluster-version latest \ --machine-type=n1-standard-2 \ --num-nodes 4</code> </pre> <br><p>  El comando <strong>gcloud</strong> crea un cl煤ster <strong>istioready</strong> en el proyecto GCP y la zona predeterminada que especific贸.  Para iniciar Istio, le recomendamos que tenga al menos 4 nodos y una m谩quina virtual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">n1-standard-2</a> . </p><br><p>  El equipo crea un cl煤ster durante varios minutos.  Cuando el cl煤ster est谩 listo, el comando emite un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mensaje</a> similar. </p><br><p>  2) Especifique las credenciales en la <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">herramienta de</a></strong> l铆nea de comandos <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">kubectl</a></strong> para usarla para administrar el cl煤ster: </p><br><pre> <code class="plaintext hljs">gcloud container clusters get-credentials istioready</code> </pre> <br><p>  3) Ahora puedes comunicarte con Kubernetes a trav茅s de <strong>kubectl</strong> .  Por ejemplo, con el siguiente comando puede averiguar el estado de los nodos: </p><br><pre> <code class="plaintext hljs">kubectl get nodes</code> </pre> <br><p>  El comando muestra una lista de nodos: </p><br><pre> <code class="plaintext hljs">NAME STATUS ROLES AGE VERSION gke-istoready-default-pool-dbeb23dc-1vg0 Ready &lt;none&gt; 99s v1.13.6-gke.13 gke-istoready-default-pool-dbeb23dc-36z5 Ready &lt;none&gt; 100s v1.13.6-gke.13 gke-istoready-default-pool-dbeb23dc-fj7s Ready &lt;none&gt; 99s v1.13.6-gke.13 gke-istoready-default-pool-dbeb23dc-wbjw Ready &lt;none&gt; 99s v1.13.6-gke.13</code> </pre> <br><h3 id="klyuchevye-ponyatiya-kubernetes">  Conceptos clave de Kubernetes </h3><br><p>  El diagrama muestra la aplicaci贸n en GKE: </p><br><p><img src="https://habrastorage.org/webt/-s/x2/uj/-sx2ujtlifvzdtixzdqpnr9jzva.png"></p><br><p>  Antes de implementar contenedores en GKE, observe los conceptos clave de Kubernetes.  Hay enlaces al final si quieres saber m谩s. </p><br><ul><li>  <strong>Nodos y agrupaciones</strong> .  En GKE, un nodo es una m谩quina virtual.  En otras plataformas de Kubernetes, el host puede ser una computadora o una m谩quina virtual.  Un cl煤ster es una colecci贸n de nodos que se pueden considerar como un todo y donde se implementa una aplicaci贸n en contenedores. </li><li>  <strong>Vainas</strong>  En Kubernetes, los contenedores corren en vainas.  Una vaina en Kubernetes es una unidad indivisible.  Una vaina contiene uno o m谩s contenedores.  <strong>Implemente</strong> el servidor y los <strong>contenedores loadgen</strong> en pods separados.  Cuando hay varios contenedores en un pod (por ejemplo, un servidor de aplicaciones y un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">servidor proxy</a> ), los contenedores se administran como un solo objeto y comparten los recursos del pod. </li><li>  <strong>Despliegue</strong>  En Kubernetes, la implementaci贸n es un objeto que es una colecci贸n de pods id茅nticos.  La implementaci贸n ejecuta varias r茅plicas de pods distribuidos en los nodos del cl煤ster.  La implementaci贸n reemplaza autom谩ticamente los pods que fallan o no responden. </li><li>  <strong>Servicio de kubernetes</strong> .  Cuando ejecuta el c贸digo de la aplicaci贸n en GKE, la conexi贸n entre <strong>loadgen</strong> y el <strong>servidor</strong> cambia.  Cuando inici贸 los servicios en la m谩quina virtual Cloud Shell o en la computadora, envi贸 solicitudes al <strong>servidor</strong> en <strong>localhost: 8080</strong> .  Despu茅s de la implementaci贸n en GKE, los pods se ejecutan en los nodos disponibles.  De forma predeterminada, no puede controlar en qu茅 host se est谩 ejecutando, por lo que los pod no tienen direcciones IP permanentes. <br>  Para obtener la direcci贸n IP del <strong>servidor</strong> , debe definir la abstracci贸n de red en la parte superior de los pods.  Este es el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">servicio de Kubernetes</a> .  El servicio Kubernetes proporciona un punto final permanente para un conjunto de pods.  Existen varios <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tipos de servicios</a> .  <strong>El servidor</strong> utiliza un <strong>LoadBalancer</strong> , que proporciona una direcci贸n IP externa para contactar con el <strong>servidor</strong> desde fuera del cl煤ster. <br>  Kubernetes tambi茅n tiene un sistema DNS integrado que asigna nombres DNS (por ejemplo, <strong>helloserver.default.cluster.local</strong> ) a los servicios.  Gracias a esto, los pods dentro del cl煤ster se comunican con otros pods en el cl煤ster en una direcci贸n fija.  El nombre DNS no se puede usar fuera del cl煤ster, como en Cloud Shell o en una computadora. </li></ul><br><h3 id="manifesty-kubernetes">  Manifiestos de Kubernetes </h3><br><p>  Cuando inici贸 la aplicaci贸n desde el c贸digo fuente, utiliz贸 el imperativo comando <strong>python3</strong> </p><br><p>  <strong>server.py</strong> </p><br><p>  Imperativo implica el verbo: "hazlo". </p><br><p>  Kubernetes usa un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">modelo declarativo</a> .  Esto significa que no le decimos a Kubernetes qu茅 debe hacerse exactamente, sino que describimos el estado deseado.  Por ejemplo, Kubernetes inicia y detiene los pods seg煤n sea necesario, para que el estado real del sistema sea el deseado. </p><br><p>  Usted especifica el estado deseado en manifiestos o archivos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">YAML</a> .  El archivo YAML contiene especificaciones para uno o m谩s objetos de Kubernetes. </p><br><p>  El ejemplo contiene el archivo YAML para <strong>servidor</strong> y <strong>loadgen</strong> .  Cada archivo YAML indica el estado deseado del objeto de implementaci贸n y el servicio Kubernetes. </p><br><p>  <strong>server.yaml</strong> </p><br><pre> <code class="plaintext hljs">apiVersion: apps/v1 kind: Deployment metadata: name: helloserver spec: selector: matchLabels: app: helloserver replicas: 1 template: metadata: labels: app: helloserver spec: terminationGracePeriodSeconds: 5 restartPolicy: Always containers: - name: main image: gcr.io/google-samples/istio/helloserver:v0.0.1 imagePullPolicy: Always</code> </pre> <br><ul><li>  <strong>kind</strong> indica el tipo de objeto. </li><li>  <strong>metadata.name</strong> indica el nombre de la implementaci贸n. </li><li>  La primera <strong>especificaci贸n de</strong> campo contiene una descripci贸n del estado deseado. </li><li>  <strong>spec.replicas</strong> indica el n煤mero deseado de pods. </li><li>  La secci贸n <strong>spec.template</strong> define la plantilla de <strong>pod</strong> .  En la especificaci贸n de pods hay un campo de <strong>imagen</strong> donde se indica el nombre de la imagen que se extraer谩 del Registro de contenedores. </li></ul><br><p>  El servicio se define de la siguiente manera: </p><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Service metadata: name: hellosvc spec: type: LoadBalancer selector: app: helloserver ports: - name: http port: 80 targetPort: 8080</code> </pre> <br><ul><li>  <strong>LoadBalancer</strong> : los clientes env铆an solicitudes a la direcci贸n IP del equilibrador de carga, que tiene una direcci贸n IP fija y a la que se puede acceder desde fuera del cl煤ster. </li><li>  <strong>targetPort</strong> : como recordar谩, el comando <strong>EXPOSE 8080</strong> en el <strong>Dockerfile</strong> no proporcion贸 puertos.  Proporciona el puerto <strong>8080</strong> para que pueda llegar al contenedor del <strong>servidor</strong> desde fuera del cl煤ster.  En nuestro caso, <strong>hellosvc.default.cluster.local: 80</strong> (nombre corto: <strong>hellosvc</strong> ) corresponde al puerto <strong>8080 de la</strong> direcci贸n IP del pod <strong>helloserver</strong> . </li><li>  <strong>puerto</strong> : este es el n煤mero de puerto donde otros servicios en el cl煤ster enviar谩n solicitudes. </li></ul><br><p>  <strong>loadgen.yaml</strong> </p><br><p>  El objeto de implementaci贸n en <strong>loadgen.yaml</strong> es similar a <strong>server.yaml</strong> .  La diferencia es que el objeto de implementaci贸n contiene una secci贸n <strong>env</strong> .  Define las variables de entorno que necesita <strong>loadgen</strong> y que establece cuando inicia la aplicaci贸n desde el c贸digo fuente. </p><br><pre> <code class="plaintext hljs">apiVersion: apps/v1 kind: Deployment metadata: name: loadgenerator spec: selector: matchLabels: app: loadgenerator replicas: 1 template: metadata: labels: app: loadgenerator spec: terminationGracePeriodSeconds: 5 restartPolicy: Always containers: - name: main image: gcr.io/google-samples/istio/loadgen:v0.0.1 imagePullPolicy: Always env: - name: SERVER_ADDR value: "http://hellosvc:80/" - name: REQUESTS_PER_SECOND value: "10" resources: requests: cpu: 300m memory: 256Mi limits: cpu: 500m memory: 512Mi</code> </pre> <br><p>  Como <strong>loadgen</strong> no acepta solicitudes entrantes, <strong>ClusterIP se</strong> especifica para el campo de <strong>tipo</strong> .  Este tipo proporciona una direcci贸n IP fija que los servicios en el cl煤ster pueden usar, pero esta direcci贸n IP no se proporciona a clientes externos. </p><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Service metadata: name: loadgensvc spec: type: ClusterIP selector: app: loadgenerator ports: - name: http port: 80 targetPort: 8080</code> </pre> <br><h3 id="razvertyvanie-konteynerov-v-gke">  Implementar contenedores en GKE </h3><br><p>  1) Vaya al directorio donde se encuentra el ejemplo del <strong>servidor</strong> : </p><br><pre> <code class="plaintext hljs">cd YOUR_WORKING_DIRECTORY/istio-samples/sample-apps/helloserver/server/</code> </pre> <br><p>  2) Abra <strong>server.yaml</strong> en un editor de texto. <br>  3) Reemplace el nombre en el campo de <strong>imagen</strong> con el nombre de su imagen Docker. </p><br><pre> <code class="plaintext hljs">image: gcr.io/PROJECT_ID/preparing-istio/helloserver:v0.0.1</code> </pre> <br><p>  Reemplace <strong>PROJECT_ID</strong> con el identificador de su proyecto GCP. <br>  4) Guarde y cierre <strong>server.yaml</strong> . <br>  5) Expande el archivo YAML en Kubernetes: </p><br><pre> <code class="plaintext hljs">kubectl apply -f server.yaml</code> </pre> <br><p>  Despu茅s de completar con 茅xito, el comando emite el siguiente c贸digo: </p><br><pre> <code class="plaintext hljs">deployment.apps/helloserver created service/hellosvc created</code> </pre> <br><p>  6) Vaya al directorio donde se encuentra <strong>loadgen</strong> : </p><br><pre> <code class="plaintext hljs">cd ../loadgen</code> </pre> <br><p>  7) Abra <strong>loadgen.yaml</strong> en un editor de texto. <br>  8) Reemplace el nombre en el campo de <strong>imagen</strong> con el nombre de su imagen Docker. </p><br><pre> <code class="plaintext hljs">image: gcr.io/PROJECT_ID/preparing-istio/loadgenv0.0.1</code> </pre> <br><p>  Reemplace <strong>PROJECT_ID</strong> con el identificador de su proyecto GCP. <br>  9) Guarde y cierre <strong>loadgen.yaml</strong> , cierre el editor de texto. <br>  10) Expanda el archivo YAML en Kubernetes: </p><br><pre> <code class="plaintext hljs">kubectl apply -f loadgen.yaml</code> </pre> <br><p>  Despu茅s de completar con 茅xito, el comando emite el siguiente c贸digo: </p><br><pre> <code class="plaintext hljs">deployment.apps/loadgenerator created service/loadgensvc created</code> </pre> <br><p>  11) Verifique el estado de los hogares: </p><br><pre> <code class="plaintext hljs">kubectl get pods</code> </pre> <br><p>  El comando muestra el estado: </p><br><pre> <code class="plaintext hljs">NAME READY STATUS RESTARTS AGE helloserver-69b9576d96-mwtcj 1/1 Running 0 58s loadgenerator-774dbc46fb-gpbrz 1/1 Running 0 57s</code> </pre> <br><p>  12) Extraiga los registros de la aplicaci贸n de la c谩psula <strong>loadgen</strong> .  Reemplace <strong>POD_ID</strong> con el identificador de la respuesta anterior. </p><br><pre> <code class="plaintext hljs">kubectl logs loadgenerator-POD_ID</code> </pre> <br><p>  13) Obtenga las <strong>IP</strong> externas de <strong>hellosvc</strong> : </p><br><pre> <code class="plaintext hljs">kubectl get service</code> </pre> <br><p>  La respuesta del comando se parece a esto: </p><br><pre> <code class="plaintext hljs">NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE hellosvc LoadBalancer 10.81.15.158 192.0.2.1 80:31127/TCP 33m kubernetes ClusterIP 10.81.0.1 &lt;none&gt; 443/TCP 93m loadgensvc ClusterIP 10.81.15.155 &lt;none&gt; 80/TCP 4m52s</code> </pre> <br><p>  14) Enviar una solicitud a <strong>hellosvc</strong> : reemplace <strong>EXTERNAL_IP</strong> con la direcci贸n IP externa de <strong>hellosvc</strong> . </p><br><pre> <code class="plaintext hljs">curl http://EXTERNAL_IP</code> </pre> <br><h3 id="beremsya-za-istio">  Tackle Istio </h3><br><p>  Ya tiene una aplicaci贸n implementada en GKE.  <strong>loadgen</strong> puede usar Kubernetes DNS ( <strong>hellosvc: 80</strong> ) para enviar solicitudes al <strong>servidor</strong> , y usted puede enviar solicitudes al <strong>servidor</strong> en una direcci贸n IP externa.  Aunque Kubernetes tiene muchas caracter铆sticas, falta informaci贸n sobre los servicios: </p><br><ul><li>  <strong>驴C贸mo interact煤an los servicios?</strong>  驴Cu谩l es la relaci贸n entre los servicios?  驴C贸mo es el tr谩fico entre servicios?  Sabe que <strong>loadgen</strong> env铆a solicitudes al <strong>servidor</strong> , pero imagine que no sabe nada sobre la aplicaci贸n.  Para responder a estas preguntas, miramos la lista de hogares en funcionamiento en GKE. </li><li>  <strong>M茅tricas</strong>  驴Cu谩nto tiempo responde el <strong>servidor</strong> a una solicitud entrante?  驴Cu谩ntas solicitudes por segundo van al servidor?  驴Da mensajes de error? </li><li>  <strong>Informaci贸n de seguridad</strong> .  <strong>驴Es el</strong> tr谩fico entre <strong>loadgen</strong> y el <strong>servidor</strong> simplemente a trav茅s de <strong>HTTP</strong> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mTLS</a> ? </li></ul><br><p>  Todas estas preguntas son respondidas por Istio.  Para hacer esto, Istio coloca un proxy de sidecar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Envoy</a> en cada pod.  El proxy de env铆o intercepta todo el tr谩fico entrante y saliente a los contenedores de aplicaciones.  Esto significa que el <strong>servidor</strong> y <strong>loadgen</strong> reciben proxies de sidecar de Envoy, y todo el tr谩fico desde <strong>loadgen</strong> al <strong>servidor</strong> pasa por proxies de Envoy. </p><br><p>  Las conexiones entre los representantes de Envoy forman una malla de servicio.  La arquitectura de malla de servicio proporciona una capa de control sobre Kubernetes. </p><br><p><img src="https://habrastorage.org/webt/7n/sk/z-/7nskz-5os2onyoaaf5kz5x38ve4.png"></p><br><p>  Una vez que los servidores proxy de Envoy se ejecutan en sus contenedores, Istio se puede instalar en la parte superior del cl煤ster GKE, casi sin cambiar el c贸digo de la aplicaci贸n.  Pero trabaj贸 un poco para preparar la aplicaci贸n para la administraci贸n con Istio: </p><br><ul><li>  Servicios para todos los contenedores.  Las <strong>implementaciones de</strong> <strong>servidor</strong> y <strong>loadgen est谩n</strong> vinculadas por el servicio Kubernetes.  Incluso <strong>loadgen</strong> , que no recibe solicitudes entrantes, tiene un servicio. </li><li>  Los puertos en los servicios deben tener nombres.  Aunque los puertos de servicio pueden dejarse sin nombre en GKE, Istio requiere un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nombre de puerto</a> de acuerdo con su protocolo.  En el archivo YAML, el puerto para el <strong>servidor</strong> se llama <strong>http</strong> porque el servidor usa el <strong>protocolo HTTP</strong> .  Si el <strong>servicio</strong> usara <strong>gRPC</strong> , usted nombrar铆a el puerto <strong>grpc</strong> . </li><li>  Las implementaciones est谩n marcadas.  Por lo tanto, puede usar las funciones de administraci贸n de tr谩fico de Istio, por ejemplo, compartir tr谩fico entre versiones del mismo servicio. </li></ul><br><h3 id="ustanovka-istio">  Instalar Istio </h3><br><p>  Hay dos formas de instalar Istio.  Puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">habilitar la extensi贸n Istio en GKE</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">instalar la versi贸n de c贸digo abierto de Istio</a> en un cl煤ster.  Con Istio en GKE, puede administrar f谩cilmente la instalaci贸n y actualizaci贸n de Istio como parte del ciclo de vida del cl煤ster GKE.  Si necesita la 煤ltima versi贸n de Istio o m谩s control sobre la configuraci贸n del panel de control de Istio, instale la versi贸n de c贸digo abierto en lugar de la extensi贸n Istio en GKE.  Para decidir sobre el enfoque, lea el art铆culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">驴Necesito Istio en GKE?</a>  . </p><br><p>  Seleccione una opci贸n, estudie el manual apropiado y siga las instrucciones para instalar Istio en el cl煤ster.  Si desea usar Istio con su aplicaci贸n reci茅n implementada, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">habilite la incrustaci贸n de sidecar</a> para el espacio de nombres <strong>predeterminado</strong> . </p><br><h3 id="ochistka">  Limpieza </h3><br><p>  Para asegurarse de que los recursos para los recursos que utiliz贸 en esta gu铆a no se debiten de su cuenta de Google Cloud Platform, elimine el cl煤ster de contenedores cuando instale Istio y juegue con la aplicaci贸n de muestra.  Esto eliminar谩 todos los recursos del cl煤ster, como instancias de c贸mputo, discos y recursos de red. </p><br><h3 id="chto-dalshe">  Que sigue </h3><br><ul><li><p>  Aprende las siguientes tecnolog铆as: </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Docker</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Contenedores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Registro de contenedores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kubernetes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gke</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Servicio de malla</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Isstio</a> </li></ol><br></li><li><p>  Aprende las siguientes herramientas: </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cloud sdk</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>Referencia de gcloud</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>kubectl</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>acoplador</strong></a> </li></ol><br></li><li><p>  Aprende los conceptos de Kubernetes: </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Racimos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nudos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Vainas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Servicios</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Despliegue</a> </li></ol><br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/469515/">https://habr.com/ru/post/469515/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../469499/index.html">C贸mo conquistamos Parallels Inicie sesi贸n con Apple</a></li>
<li><a href="../469503/index.html">Ciberseguridad: protegemos los datos de suscriptores de fugas en 2019</a></li>
<li><a href="../469505/index.html">3 formas pr谩cticas de llevar negocios a los mercados extranjeros: enfoques y t茅cnicas de compa帽铆as reales</a></li>
<li><a href="../469507/index.html">Tercera vulnerabilidad del cliente de Windows Steam, pero no 0 d铆as</a></li>
<li><a href="../469509/index.html">Esquemas angulares, o c贸mo escrib铆 mi plantilla para cli angular</a></li>
<li><a href="../469521/index.html">Compr茅 una motocicleta para andar, no para caer</a></li>
<li><a href="../469523/index.html">Dependencia del rendimiento del c贸digo en el contexto de la declaraci贸n de variables en JavaScript</a></li>
<li><a href="../469525/index.html">Sistema de control automatizado para una excavadora minera.</a></li>
<li><a href="../469527/index.html">驴El intercomunicador es un o铆do esp铆a?</a></li>
<li><a href="../469529/index.html">La representaci贸n de texto te odia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>