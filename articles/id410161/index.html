<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚯 👩🏽‍🤝‍👨🏿 👩🏼‍🍳 Pengembangan Perangkat Lunak untuk kontrol motor DSP TMS320F28 🖖🏾 👩‍👩‍👦 🧙🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel pertama saya , saya berbicara tentang keluarga pengendali ini, lebih dari selusin orang menulis kepada saya di PM dengan pertanyaan tent...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengembangan Perangkat Lunak untuk kontrol motor DSP TMS320F28</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/410161/">  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel pertama</a> saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,</a> saya berbicara tentang keluarga pengendali ini, lebih dari selusin orang menulis kepada saya di PM dengan pertanyaan tentang hal itu, meskipun ini bukan topik artikel.  Orang-orang pasti tidak mau pergi ke Google, berbicara tentang kurangnya informasi.  Saya sedikit terkejut dan memutuskan untuk memeriksa - memang, di Rusia, praktis tidak ada pada keluarga C2000 (dengan latar belakang AVR, STM), dan yang paling penting tidak ada panduan awal yang jelas.  Informasi dapat ditemukan dalam bahasa Inggris, tetapi sekali lagi itu tidak cukup.  Bagi saya, ini agak mengejutkan, mengingat keluarga ini belum berumur beberapa tahun.  Oleh karena itu, diputuskan untuk kemampuan mereka yang terbaik untuk mempengaruhi situasi. <br><br>  Siapa yang butuh pengontrol ini pada prinsipnya ... Apakah Anda ingin memasang inverter pengelasan?  Catu daya yang tidak pernah terputus?  Pelurus mandi Electroplating?  Frekuensi?  Inverter untuk energi alternatif?  Mesin CNC?  Jika setidaknya satu poin tentang Anda, maka artikel ini didedikasikan untuk Anda! <br><br>  Pembaca lain juga akan tertarik untuk belajar tentang pengontrol "baru-lama", mengapa itu diperlukan dan cara bekerja dengannya.  Keluarga ini sangat sederhana (jauh lebih sederhana daripada STM, LPC dan Cortex lainnya), batu-batu itu mudah dibeli (ada juga Ali), mereka memungkinkan Anda untuk menerapkan solusi industri yang sangat andal, atas dasar itu Anda dapat membangun hampir semua sistem kontrol industri. <br><br>  Sudahkah Anda memutuskan bahwa pengontrol ini adalah impian Anda dan siap untuk bertempur?  Kemudian kami membeli $ 17 debugging F28027-LaunchPad berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ed/cd/cv/edcdcvjwp5ewu_jl0jbnwwzsfyc.png"></div><br>  Sudahkah kamu membeli?  Sekarang kamu bisa berperang.  Jika muncul pertanyaan di mana membeli "lebih baik" dan "lebih murah", maka kita pergi ke toko resmi.  Kami pergi di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan melihat label harga $ 17.  Untuk jumlah ini, Anda akan menerima biaya debug asli dan pengiriman kurir ke pintu.  Saya memesan sekali di China untuk pengiriman, ternyata $ 16 dan dengan diskon dan kupon, serta perjalanan "bonus" ke kantor pos.  Karena itu, saya sarankan itu resmi.  Ayo pergi! <br><a name="habracut"></a><br><h2>  Tinjauan Seri C2000 </h2><br>  Anda dapat membaca paling detail tentang segala hal di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web resmi</a> , tentu saja, dalam bahasa Inggris.  Saya akan membicarakannya secara singkat dan mengungkapkan pemikiran saya tentang aplikasi tersebut.  Harap dicatat bahwa ini hanya spekulasi saya dan mereka tidak mengklaim kebenaran. <br><br>  Pertama, beberapa kata tentang C2000 secara umum.  Fitur khas keluarga, yang terkait dengan tujuan utama kontrol motor, adalah kehadiran HRPWM (PWM presisi tinggi) dan CLA (coprocessor).  Yang terakhir ini benar-benar tidak ada di Piccolo TMS320F2802x termuda, tetapi tidak diperlukan di sana, hal utama adalah HRPWM di tempat.  Apa itu ... HRPWM sendiri adalah PWM biasa, hanya sangat akurat dan waktu perekaman dan pengaturan untuk siklus tugas baru secara signifikan lebih cepat.  Ini memungkinkan untuk memperoleh, misalnya, sinus berbentuk sempurna dalam inverter DC / AC atau untuk mengendalikan motor stepper dalam mesin CNC dengan akurasi yang sangat tinggi. <br><br>  CLA pada dasarnya adalah inti yang lengkap, tetapi tidak memiliki akses ke periferal, hanya ke inti dan memori utama.  Ini berfungsi untuk melepaskan inti utama dari komputasi.  Coprocessor ini sangat mudah dan alami mencerna data float, yang penting ketika mengimplementasikan berbagai algoritma, filter, dan banyak lagi. <br><br><img src="https://habrastorage.org/webt/5o/ui/lh/5ouilh691kdhoflkcrtcs4tmwqy.png"><br><br>  Saya akan berbicara tentang dua keluarga utama yang mungkin akan Anda temui: <br><br><ul><li>  <b>Piccolo.</b>  Kontroler termuda, tetapi juga yang termurah.  TMS320F28027 saya berasal dari keluarga ini.  Jika Anda memutuskan untuk mengembangkan elektronika daya untuk tujuan komersial, ini akan menjadi batu utama Anda - harganya cukup murah, dibayar (LQFP, QFN, TSSOP) dan memungkinkan Anda untuk menerapkan hampir semua hal.  Misalnya, kinerjanya cukup untuk PFC dua fase, inverter untuk panel surya, konverter frekuensi hingga 10 kW dengan kontrol vektor, dll.  Seperti yang Anda lihat, ini adalah segmen produk yang dibeli oleh orang biasa dan perusahaan, yang artinya sangat diminati.  Keterbatasan utama adalah frekuensi 60 MHz, sejumlah saluran PWM terbatas. </li><li>  <b>Delfino.</b>  Secara ideologis, ini semua adalah Piccolo yang sama, hanya dipompa dengan meldonium.  Apa ini dinyatakan dalam - frekuensi hingga 200 MHz, di batu yang lebih tua sudah ada 2 core penuh + 2 coprocessor, kasing besar, dan karenanya, banyak kaki, banyak kanal PWM, banyak ADC dan, secara umum, banyak.  Artinya, pada batu yang lebih tua kita memiliki 4 core dengan frekuensi 200 MHz, kinerja 800 MIPS, yang cukup mengesankan.  Kekuatan semacam itu dapat digunakan dengan cara yang berbeda, tetapi aplikasi utamanya adalah sistem algoritmik yang kompleks, misalnya penyearah Vienne atau yang lainnya.  Juga pada satu pengontrol seperti itu, Anda dapat menerapkan seluruh sistem kontrol untuk mesin CNC, misalnya, penggilingan atau pemotongan nyala logam. </li></ul><br><h2>  Finalisasi papan debug </h2><br>  Saat Anda menerima sebuah kotak dengan papan debug, Anda akan menemukan kuarsa dan kapasitor yang hilang.  Mereka tidak perlu, tetapi disarankan untuk menggunakan obat bius.  Saya tidak lagi memiliki kuarsa di HC-49, jadi saya harus meminjam dari seorang teman.  Dia memilih AVR dan STM, jadi dia hanya menemukan 8 MHz.  Disolder.  Saya menambahkan 22 pF kapasitor dari memori lama, seperti yang saya lakukan pada mega di sekolah. <br><br>  Solusi ini bukan yang terbaik dan terhubung dengan konfigurasi PLL.  Pengganda maksimum untuk PLL adalah x12 (lebih banyak yang bisa, tetapi tidak disarankan, dan bekerja dengan bengkok).  Frekuensi maksimum adalah 60 MHz.  Nilai maksimum pembagi pada output PLL adalah 3. Frekuensi kuarsa adalah 8 MHz.  Saya tidak dapat mengalikan 8 dengan integer dan mendapatkan 60. Kami mencari nilai total terdekat, dalam hal ini 240. Yaitu, kalikan 8 dengan 30, dan kemudian bagi dengan 4, saya mendapatkan 60 MHz yang didambakan, tetapi masalahnya adalah bahwa pengali xL PLL x30 tidak dapat diterima , pembagi / 4 juga tidak tersedia.  Ada 2 jalan keluar: <br><br><ul><li>  <b>Buruk:</b> kalikan frekuensi 8 MHz dengan 7 dan bagi dengan 1 dan dapatkan 56 MHz.  Anda dapat mengalikan 8 dan mendapatkan 64 MHz, itu akan bekerja secara stabil, tetapi dalam kedua kasus frekuensinya tidak maksimal 60 MHz.  Sayangnya, perfeksionisme tidak cukup.  Saya baru saja opsi seperti itu, disolder 8 MHz dan membuat frekuensi 56 MHz. </li><li>  <b>Bagus:</b> pergi dan beli kuarsa pada 10 atau 20 MHz (lebih baik dari 10) dan kalikan dengan 6, well, bagi dengan 1, kita dapatkan 60 MHz yang dihargai.  Saya tinggal di luar kota dan jujur ​​itu terlalu malas untuk pergi ke toko lokal, di mana itu bukan fakta bahwa ada kuarsa 10 MHz.  Tentu saja, sirkuit RC internal dan kuarsa 8 MHz akan digunakan untuk pelatihan, tetapi dalam proyek mendatang, masukkan kuarsa 10 MHz, bukan mutan raksasa dalam paket HC-49. </li></ul><br><h2>  Arsitektur dan fitur periferal </h2><br>  Segala sesuatu yang akan terjadi selanjutnya berlaku untuk pengontrol TMS320F28027.  Untuk memulai, mari kita lihat struktur yang diambil dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">datasheet</a> : <br><br> <a href=""><img src="https://habrastorage.org/webt/sr/da/hb/srdahbswvkrs9zjzbnvevwgqvho.png"></a> <br><br>  Hal pertama yang harus Anda perhatikan adalah bahwa RAM dibagi menjadi 3 sektor: M0, M1 dan SARAM.  Volume sektor memori ini dalam kasus kami adalah 1k, 1k dan 4k.  Perlu dicatat bahwa dalam hal ini kata itu bukan 8 bit, tetapi 16 bit, yaitu, dalam bentuk yang lebih akrab adalah 2 kB + 2 kB + 8 kB.  Kekhasan modul ini adalah bahwa sektor M0 dan M1 lebih cepat dari sisa 8 kB RAM.  Secara formal, Anda dapat menganggap ini sebagai cache.  Sektor M0 dan M1 biasanya menyimpan data yang paling sering digunakan, serta data yang paling penting untuk kinerja memori.  Secara default, kita dapat menggunakan tautan untuk menentukan apa dan di mana disimpan, tetapi saya tidak akan mengangkat topik ini dalam artikel ini, setidaknya di sini artikel terpisah diperlukan. <br><br>  Fitur penting kedua adalah bahwa semua periferal clock dari bus sistem, yaitu dari 60 MHz (dalam kasus saya, 56 MHz).  Sebagai contoh, saya akan memberikan mikrokontroler STM32, di mana frekuensi inti adalah, misalnya, 180 MHz untuk F4, tetapi periferal clocked melalui serangkaian pembagi.  Saya menyebut pendekatan ini "palsu megahertz" untuk saya sendiri, meskipun ini sangat dibesar-besarkan.  Oleh karena itu, 60 MHz untuk TMS320F28 dan 180 MHz untuk stm32 tidak begitu berbeda, dan jika Anda mengingat keberadaan CLA, maka 60 + 60 MHz setidaknya sebanding.  Jelas bahwa perbandingan semacam itu tidak benar, tetapi jelas membuatnya jelas bahwa tidak hanya megahertz yang muak. <br><br>  Juga merupakan hal yang menarik - perhatikan struktur umum: HRPWM, ADCs, komparator dengan DAC internal, modul pemrosesan encoder (eCAP) ... Konverter frekuensi yang siap pakai dengan kontrol vektor dalam bentuk murni!  Ini adalah esensi seluruh keluarga ini - minimalis.  Di satu sisi, pinggiran agak buruk dibandingkan dengan Cortex, tetapi di sisi lain, cukup memadai untuk menerapkan konverter frekuensi, dc / dc, dc / ac, dan driver motor stepper.  Karena itu, bekerja dengan pengontrol TMS320F28 sangat sederhana, dapat dimengerti dan tidak kelebihan dengan tindakan yang tidak perlu.  Tetapi jika Anda tiba-tiba membutuhkan 3 UART, dan bagi mereka sepasang i2c dan 3 lebih banyak SPI, maka pengendali ini jelas bukan untuk Anda - mereka memiliki tugas yang berbeda. <br><br><h2>  Lingkungan Pengembangan </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5v/vc/iv/5vvcivdcbwzulr9uocxmccv-ba0.png"></div><br>  Sudahkah Anda melihat logo splash?  Ingat dia.  Jika Anda memutuskan untuk mulai menggunakan artikel dalam pengembangan pahlawan artikel, maka perangkat lunak ini adalah milik Anda, dan seperti yang Anda lihat, <b>perangkat lunak</b> ini <b>disebut controlSUITE</b> . <br><br>  Aplikasi ini adalah kumpulan dan pustaka dari semua yang Anda butuhkan untuk mengembangkan perangkat lunak untuk keluarga pengendali C2000.  Menginstal aplikasi ini adalah hal pertama yang harus dilakukan dan melihat komposisinya, itu berisi: <br><br><ul><li>  Deskripsi semua pengontrol dan papan debug yang ada berdasarkan pada mereka.  Sumber sirkuit, papan sirkuit cetak, BOM terutama di Altium Designer </li><li>  Contoh sirkuit dan desain papan sirkuit cetak </li><li>  Pustaka inti untuk pengembangan firmware </li><li>  Perpustakaan Matematika dan DSP, termasuk untuk digunakan dengan CLA </li><li>  Contoh proyek perangkat lunak untuk setiap jenis perangkat </li><li>  Sejumlah besar celah untuk penerapan sebagian besar algoritma untuk mengendalikan mesin, konverter dc / dc, pengontrol MPPT dan sistem lainnya </li><li>  Seperangkat program yang memungkinkan Anda membuat sistem manajemen engine tanpa pemrograman sama sekali, cukup menggunakan lingkungan grafis </li><li>  IDE itu sendiri, yang akan dikembangkan </li></ul><br>  Semua yang saya jelaskan di atas sangat singkat dan sederhana.  Anda perlu beberapa minggu untuk melihat dan menggulir setidaknya secara diagonal.  Tentu saja, Anda tidak akan membutuhkan sebagian besar dari jumlah data ini pada awalnya, tetapi Anda harus mengingat ke mana harus pergi jika ada sesuatu yang tidak dapat dipahami oleh Anda dan aneh. <br><br>  Sekarang yang akan kita kerjakan hari ini adalah IDE, bagian grafisnya didasarkan pada Eclipse yang terkenal.  Kompilernya bukan GCC, tetapi miliknya sendiri dari Texas, yang menurut pendapat subjektif saya jelas lebih baik daripada yang pertama.  Meskipun ada kecurigaan bahwa ini benar-benar didoping semua gcc yang sama.  Lingkungan pengembangan disebut <b>Code Composer Studio</b> , versi saat ini 7.4. <br><br><h2>  Pembuatan proyek </h2><br>  Pada awalnya, saya ingin mengimplementasikan tugas yang identik dengan artikel pertama, yaitu menggambar sinus.  Pada prinsipnya, dalam kerangka satu artikel, ini bisa dilakukan meninggalkan bingkai volume yang sangat besar dari hal-hal kecil, tetapi seperti yang Anda tahu, esensi tepatnya dalam hal-hal kecil.  Ada beberapa artikel tentang TMS di Internet, tetapi mereka semua sangat dangkal dan turun ke jenis "salin ini dan semuanya berfungsi", yaitu, proses itu sendiri dan ideologi tidak dianggap sama sekali.  Oleh karena itu, dalam kerangka artikel ini, kami akan membuat proyek, membersihkannya dari komponen yang tidak perlu, mengkonfigurasi firmware dalam memori flash controller dan mempelajari cara bekerja dengan GPIO, dan mereka sangat menarik di sini. <br><br>  Unduh CCS7 dari situs web pabrikan, instal dan mulailah membuat proyek dengan cara biasa: <i>File → Baru → Proyek CCS ...</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wb/v0/jy/wbv0jyccatp8jysn2nckh7qaooc.png"></div><br>  Kita melihat jendela ini dan di dalamnya kita perlu memilih controller yang menarik minat kita, dalam kasus saya itu adalah TMS320F28027, menunjukkan nama proyek dan menentukan jalan di mana ia akan disimpan.  Pertama, Anda perlu membuat folder tempat proyek akan disimpan.  Nama proyek dan nama folder mungkin tidak cocok.  Klik tombol <i>Selesai</i> dan proyek kami dibuat. <br><br>  Sekarang Anda perlu mengisi proyek kami dengan konten dan menghubungkannya.  Sebelum itu, untuk meningkatkan struktur proyek, buat set folder ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ee/cg/er/eecgerskm0jeso2ocebvaheeyrc.png"></div><br><ul><li>  <i>inc</i> - folder yang berisi semua file header </li><li>  <i>system_inc</i> - bagian ini akan menyimpan file header dari perpustakaan standar, file yang akan kita buat sendiri, misalnya, main.c ada di folder inc.  Ini tidak akan merusak sesuatu tanpa berpikir atau menghapus yang tidak perlu </li><li>  <i>src</i> - folder dengan semua sumber </li><li>  <i>system_src</i> - folder dengan file sumber untuk pustaka standar </li></ul><br>  Harap dicatat bahwa struktur ini bukan semacam dogma, tetapi hanya ide saya untuk memesan.  Meskipun saya akan merekomendasikan ini kepada orang-orang dengan pengalaman minimal, seiring waktu Anda akan mengubahnya agar sesuai dengan pandangan dunia Anda, tetapi untuk sekarang ini akan meminimalkan jumlah tiang tembok. <br><br>  Sekarang buat file main.h di folder inc dan hubungkan ke main.c.  Melalui itu akan menghubungkan pustaka dasar.  Dan sebelum Anda mulai mentransfer pustaka dan file lainnya, mari kita tulis path ke folder tempat file header masa depan kita akan disimpan dalam pengaturan proyek.  Untuk melakukan ini, klik kanan pada proyek (Uji) di pohon proyek dan klik <i>Properti</i> di bagian bawah atau cukup tekan <i>Alt + Enter</i> .  Di jendela yang terbuka, pergi ke <i>Build → C2000 Compiler → Include Options</i> dan di sini kita perlu dua path yang ada - daftarkan path ke folder inc dan system_inc.  Klik <i>Tambah</i> , kemudian <i>Workspace</i> dan kemudian ke folder inc yang diinginkan, kemudian lakukan hal yang sama dan berpegang pada folder kedua.  Dengan demikian, kami menetapkan jalur relatif, saat mentransfer proyek, Anda tidak perlu mengonfigurasi ulang apa pun.  Hasilnya, kami mendapatkan gambar seperti itu dan klik <i>Ok</i> : <br><br><img src="https://habrastorage.org/webt/2x/nd/ql/2xndqlhcm5szyalytbw6oeseyka.png"><br><br>  Sekarang kami memiliki proyek kosong dengan jalur yang ditentukan dan pengaturan lainnya, hanya tinggal mengisinya dengan perpustakaan.  Satu-satunya hal yang harus dilakukan adalah memeriksa apakah semuanya terhubung.  Secara teori, Anda harus mendapatkan kode dan gambar seperti itu, kompilasi proyek.  Untuk melakukan ini, tekan <i>CTRL + B</i> atau pergi ke <i>Project → Build All</i> di atas.  Proyek harus dikompilasi tanpa kesalahan dan terlihat seperti ini (gambar dapat diklik): <br><br> <a href=""><img src="https://habrastorage.org/webt/0b/hv/ur/0bhvurabfuhr1-6lqjgzn4svzp0.png"></a> <br><br>  Sekarang mari kita bicara sedikit tentang tautannya.  Awalnya, ketika membuat proyek, IDE menghasilkan file <i>28027_RAM_lnk.cmd</i> , itu menempatkan program kami dalam RAM selama debugging dan firmware.  Ini nyaman ketika kita melakukan debug, karena  Sumber daya memori flash tidak terbuang dan memasukkan debugging dalam RAM secara signifikan lebih cepat.  Tetapi bagaimana jika kita ingin menjahit dengan cepat?  Untuk melakukan ini, ada file tautan lain yang akan menempatkan program kami dalam sekejap.  Saya akan menunjukkan opsi ini. <br><br>  Pertama-tama, hapus file <i>28027_RAM_lnk.cmd</i> .  Seperti yang saya katakan - <b>controlSUITE adalah</b> segalanya bagi kami.  Kami membukanya.  Sekarang buka <i>Bahasa Inggris → Perangkat → Piccolo F2802x → Perpustakaan Pendukung → File Header untuk F28027x</i> .  Di sebelah kanan kita melihat folder - ini adalah perpustakaan standar dan semua yang diperlukan, termasuk tautan.  Sekarang kita pergi ke folder <i>f2802x_common → cmd</i> dan di sini kita melihat satu set linker untuk semua batu di baris tersebut.  Tidak sulit menebak file _RAM untuk mengunggah kode ke RAM, dan tanpa tag ini untuk mengunggah melalui flash.  Kami mengambil file <i>F28027.cmd</i> dan menyalinnya ke proyek kami alih-alih tautan jauh yang lama. <br><br>  Sekarang saatnya memigrasi perpustakaan itu sendiri.  Kami pergi ke folder <i>f2802x_common → sumber</i> dan melihat banyak file.  Ada dua jenis perpustakaan: register standar (mirip dengan CMSIS) dan beberapa jenis SPL.  Dalam hal ini, kami hanya tertarik pada tampilan pertama, yaitu file dengan awalan <i>f2802x_</i> .  Tentu saja, Anda dapat menyeret semuanya ke dalam proyek kami, tetapi mengapa menyumbatnya jika kami tidak menggunakan semuanya?  Jika Anda membutuhkan sesuatu, maka di masa depan kami hanya menambahkannya.  Untuk saat ini, kami membatasi diri pada set file berikut: <br><br><ul><li>  <i>f2802x_codestartbranch.asm</i> </li><li>  <i>f2802x_defaultisr.c</i> </li><li>  <i>f2802x_piectrl.c</i> </li><li>  <i>f2802x_pievect.c</i> </li><li>  <i>f2802x_sysctrl.c</i> </li></ul><br>  Kami menyalin file data dan menempelkannya ke folder <i>system_src</i> kami.  Sekarang kita pergi ke folder <i>f2802x_headers → sumber</i> dan <i>mengambil</i> file <i>F2802x_GlobalVariableDefs.c</i> dari sana dan menyalinnya ke folder <i>system_src</i> kami <i>lagi</i> .  Selanjutnya, buka folder <i>f2802x_headers → cmd</i> dan salin file <i>F2802x_Headers_nonBIOS.cmd</i> dari sana ke folder yang sama.  Ini melengkapi pengisian folder <i>system_src</i> dan melanjutkan ke header. <br><br>  Kami pergi ke folder <i>f2802x_headers → sertakan</i> dan salin semua file dari sana ke folder <i>system_inc</i> kami.  Sekarang kita pergi ke folder <i>f2802x_common → sumber</i> dan salin file dari sana: <br><br><ul><li>  <i>f2802x_examples.h</i> </li><li>  <i>f2802x_globalprototypes.h</i> </li><li>  <i>f2802x_i2c_defines.h</i> </li><li>  <i>f2802x_epwm_defines</i> </li><li>  <i>f2802x_swprioritizedisrlevels.h</i> </li><li>  <i>f2802x_defaultisr.h</i> </li></ul><br>  Kita harus mendapatkan gambar ini di pohon proyek: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jw/tu/h-/jwtuh-pssz-pn5_ynxlxugmijtw.png"></div><br>  Sekarang Anda perlu menghubungkan perpustakaan dasar, file <i>main.h</i> mengambil bentuk berikut: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"F2802x_Device.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"F2802x_examples.h"</span></span></span></span></code> </pre> <br>  Kami mencoba mengkompilasi.  Jika proyek dikompilasi tanpa kesalahan dan peringatan, maka semuanya terhubung dengan benar.  Jika ini tidak terjadi, periksa kembali 10 kali, dan jika tidak berhasil sama sekali, maka tulislah kepada PM - saya akan membantu, seperti yang dikatakan Owl: <i>"Baz-woz-mEz-bottom, artinya, tidak ada apa-apa</i> . <i>"</i> <br><br><h2>  Inisialisasi sistem pengontrol dan jam </h2><br>  Di bagian ini, kita akan menulis fungsi yang menginisialisasi pengawas waktu dan vektor interupsi, dan mengatur bendera interupsi ke nol.  Kami juga mengatur sistem jam, sebagai akibatnya kuarsa eksternal daripada rantai RC internal akan menjadi sumber jam, konfigurasikan PLL dan aktifkan pencatatan jam kerja untuk semua periferal. <br><br>  Untuk keakuratan kode, saya mengusulkan untuk meletakkan semua inisialisasi dasar ke dalam file terpisah, yang bagian <i>depannya</i> akan menjadi fungsi <i>void InitStartSystem (void)</i> .  Untuk melakukan ini, buat file <i>systemInitStart.h</i> dan <i>systemInitStart.c</i> .  Saya akan segera menulis fungsi dan kemudian kita cukup menganalisis isinya: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitStartSystem</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ DisableDog(); XtalOscSel(); InitPll(TMS320_PLLCR, TMS320_DIVSEL); InitPeripheralClocks(); InitPieCtrl(); InitPieVectTable(); }</code> </pre><br>  Semua fungsi yang dipanggil di <i>InitStartSystem ()</i> adalah standar.  Saya menyarankan Anda untuk melihat secara terperinci bagaimana penerapannya, untuk ini Anda dapat menekan CTRL dan mengklik fungsi yang diinginkan.  Apakah kamu sudah melihat?  Sekarang pergi sebentar ... <br><br><ul><li>  <i>DisableDog ()</i> - fungsi mematikan "anjing".  Ini adalah langkah wajib ketika mengatur bagian utama peripheral kritis, misalnya, sistem jam.  Dalam kode perpustakaan Anda sering melihat ini, itu akan digandakan dan digandakan </li><li>  <i>XtalOscSel ()</i> - fungsi ini mengimplementasikan peralihan dari sumber jam internal ke kuarsa eksternal.  <b>Poin penting!</b>  Ada kesalahan di perpustakaan standar dengan fungsi ini - tidak dideklarasikan.  Kami pergi ke file <i>f2802x_globalprototypes.h</i> dan di antara yang lainnya, kami menambahkan baris <i>extern void XtalOscSel (void)</i> <br><br><img src="https://habrastorage.org/webt/3l/vv/yv/3lvvyvwdfpwbqpek6bphfkheapu.png"><br><br>  <b>Poin penting kedua!</b>  Pergi ke fungsi XtalOscSel dan hapus fungsi penundaan. <br><br><img src="https://habrastorage.org/webt/ve/iq/iw/veiqiwa2locaclbj2-xfbpiakpe.png"><br><br>  <b>Poin penting ketiga!</b>  Kami pergi ke file <i>f28027x_exmaples.h</i> dan mengomentari fungsi implementasi penundaan. <br><br><img src="https://habrastorage.org/webt/t7/jk/jp/t7jkjpu3nbgcqlqt5aolaniwqxg.png"><br></li><li>  <i>InitPll (TMS320_PLLMUL, TMS320_DIVSEL)</i> - fungsi mengkonfigurasi PLL.  2 nilai ditransfer ke sana: pengganda dan pembagi.  Nilai mereka ditentukan dalam file header.  <b>Poin penting!</b>  Kami membuka fungsi ini di perpustakaan dan Anda perlu mengomentari keterlambatan di bagian paling bawah <br><br><img src="https://habrastorage.org/webt/mg/up/gi/mgupgi_vhx8hvcvg3tgaqsxaxas.png"></li><li>  <i>InitPll (TMS320_PLLMUL, TMS320_DIVSEL)</i> - fungsi mengkonfigurasi PLL.  2 nilai ditransfer ke sana: pengganda dan pembagi.  Nilai mereka ditentukan dalam file header.  <b>Poin penting!</b>  Kami membuka fungsi ini di perpustakaan dan Anda perlu mengomentari keterlambatan di bagian paling bawah </li><li>  <i>InitPeripheralClocks ()</i> - fungsi ini hanya memungkinkan pencatatan jam kerja untuk seluruh perangkat.  Ya, untuk semua.  C2000 bukan solusi untuk kelenjar bertenaga baterai, <br>  solusi unit-puluhan-ratusan kilowatt dan 2-3 mA yang menyedihkan ini tidak akan berperan di sini.  Nah, Anda tidak perlu mengingat setiap kali Anda menyalakan jam untuk beberapa jenis SPI atau tidak </li><li>  <i>InitPieCtrl ()</i> - fungsi mematikan semua interupsi dan me-reset flag interrupt </li><li>  <i>InitPieVectTable ()</i> - fungsi mengisi tabel dengan vektor interupsi </li></ul><br>  Sebenarnya, ini dia inisialisasi.  Saya pikir banyak yang memperhatikan "poin penting" yang terkait dengan fungsi <i>Delay</i> .  Mengapa kami memotongnya pada pokok anggur?  Ya, semuanya sederhana - itu penopang. <br><br>  Insinyur TI menambahkan penundaan yang sama sekali tidak perlu ini pada beberapa fungsi, ditambahkan dalam pembaruan terkini.  Mengapa - sebuah misteri bukan hanya untuk saya.  Register dan entri penting lainnya sudah dilindungi, jadi itu tidak akan membuat pengontrol kami bodoh.  Ngomong-ngomong, ketika menginisialisasi dalam elektronika daya, mustahil untuk "tumpul" sama sekali, kalau tidak akan banci.  Karena itu, lupakan fungsi <i>penundaan</i> dan iblis lainnya selamanya, hanya penghitung waktu!  Penundaan hanya diizinkan untuk beberapa tujuan pendidikan, misalnya, berkedip cepat dengan LED. <br><br>  Untuk memverifikasi bahwa kodenya berfungsi, kami memanggil fungsi inisialisasi di main, compile, flash dan <b>hook</b> ke osiloskop <b>GPIO18</b> .  Pin ini mirip dengan MCO dari STM32, artinya output frekuensi sistem.  Osiloskop akan melihat sinyal dengan frekuensi 56 MHz.  Jika osiloskop bagus, maka Anda akan melihat berliku-liku, jika Cina (bahkan bagus), maka kemungkinan besar itu akan menjadi sesuatu yang lebih dekat ke sinus.  Pengaturan GPIO18 untuk menghasilkan frekuensi sistem dapat dilihat pada fungsi <i>InitPeripheralClocks ()</i> .  Pertama, Anda perlu "menghubungkan" gpio ke output frekuensi, dan kemudian mengatur pembagi menjadi 1: <br><br><pre> <code class="cpp hljs"> GpioCtrlRegs.GPAMUX2.bit.GPIO18 = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// GPIO18 = XCLKOUT SysCtrlRegs.XCLK.bit.XCLKOUTDIV=2; // Set XCLKOUT = SYSCLKOUT/1</span></span></code> </pre><br><h2>  Pengaturan GPIO </h2><br>  Untuk bekerja dengan keluarga ini, kita hanya memerlukan manual referensi, yang telah dibagi oleh pengembang TI menjadi beberapa file, yang masing-masing menggambarkan pinggiran tertentu, yang sangat nyaman.  Unduh lembar data di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan buka bagian <i>Dukungan Dokumentasi</i> di halaman 126. Di sini kita melihat serangkaian tautan ke dokumentasi dengan uraian singkatnya: errata, panduan untuk memulai manajemen mesin dan panduan di setiap periferal.  Kami tertarik pada dokumen yang disebut <b>TMS320F2802x / TMS320F2802xx Pedoman Sistem Piccolo dan Panduan Referensi Terputus</b> , ini berisi deskripsi GPIO dan pengaturan sistem dasar lainnya yang menarik bagi kami.  Kami melihat diagram blok GPIO: <br><br> <a href=""><img src="https://habrastorage.org/webt/vp/uu/29/vpuu29qhryyngpm2thgtvtquoeo.png"></a> <br><br>  Kami melihat gambar yang cukup akrab tentang port input / output perangkat.  Di sini dan kemampuan untuk mengaktifkan suspender internal, dan penggunaan sinyal dengan GPIO untuk gangguan dan kesenangan lainnya.  Fitur utama perangkat ini dalam C2000 adalah kemungkinan penindasan gangguan perangkat keras, misalnya, derak kontak mekanis tombol.  Mari kita lihat diagram yang menarik: <br><br><img src="https://habrastorage.org/webt/gu/zj/ym/guzjymm5gq08m1gar1284zobjx8.png"><br><br>  Ini menunjukkan prinsip membaca status input.  Pada sebagian besar pengendali, keadaan input dibaca dengan frekuensi clock periferal ini, yaitu, secara default dengan frekuensi 56 MHz dalam kasus kami, dan untuk stm yang sama di keluarga yang lebih tua, frekuensi ini bahkan lebih tinggi.  Saya pikir semua orang mengerti bahwa pada frekuensi seperti itu controller punya waktu untuk "melihat" gangguan dan kebisingan.  Terkadang frekuensi seperti itu diperlukan, dan terkadang tidak, misalnya, jika kita perlu memilih tombol.  Mengapa kita mewawancarainya setiap 18 ns?  Oleh karena itu, kami menyadari kemungkinan mengurangi frekuensi clock port tertentu menggunakan register <i>CTRL</i> dan bit <i>QUALPRDx</i> , di mana X mengambil nilai dari 0 menjadi 3: QUALPRD0 bertanggung jawab untuk GPIO0 ... 7, QUALPRD1 bertanggung jawab untuk GPIO8 ... 15 dan seterusnya.  Sebenarnya, ini adalah pembagi frekuensi biasa dengan koefisien dari 1 hingga 510. <br><br><img src="https://habrastorage.org/webt/a5/ro/9e/a5ro9eq9hvvmomonnkm8ggkxzcq.png"><br><br>  Sering kali tidak masuk akal untuk menginterogasi tombol, jadi kami akan menyesuaikan pembagi menjadi 510, yaitu maksimum.  Kami melihat kembali pada diagram dan melihat bahwa sinyal dianggap stabil hanya ketika levelnya tidak berubah untuk 6 ticks.  Jumlah langkah yang diperlukan untuk fiksasi dapat 1, 3 atau 6. <b>Semakin besar pembagi dan semakin banyak siklus yang kita perbaiki, semakin stabil perlindungan dari obrolan.</b>  Ketika ada obrolan kontak, pada awalnya itu akan menjadi transisi kacau dari 0 ke 1 dan sebaliknya, ketika obrolan berlalu dan sinyal berhenti dan tidak berubah selama 6 jam, ini berarti bahwa tombol ditekan.  Semuanya cerdik itu sederhana. <br><br>  Sekarang mari kita lihat register utama, kita tidak akan menyentuh interupsi - hanya pengaturan port itu sendiri.  Pertama, Anda perlu mengatakan bahwa register dibagi menjadi 2 jenis: <b>register</b> <b>pengaturan</b> dan <b>register data</b> .  Yang pertama bertanggung jawab untuk konfigurasi properti, misalnya, input atau output ini.  Grup kedua bertanggung jawab untuk menulis dan membaca status port. <br><br>  <u>Setup Register:</u> <br><br><ul><li>  <i>GPxCTRL</i> - daftar untuk menulis pembagi jam.  Alih-alih "x" kita mengganti huruf "A" - jika kita memiliki GPIO0 ... 31, "B" - jika kita menggunakan GPIO32 ... 63 dan seterusnya </li><li>  <i>GPAQSELx</i> - daftar untuk mengatur jumlah kutu untuk memperbaiki nilai pada input </li><li>  <i>GPAMUX1</i> adalah register untuk memilih periferal yang terhubung, misalnya, ini menunjukkan bahwa GPIO atau UART, atau mungkin PWM, hadir. </li><li>  <i>GPADIR</i> - register pemilihan arah GPIO: input atau output.  Secara default, semua port dikonfigurasikan untuk input. </li><li>  <i>GPAPUD</i> adalah register yang bertanggung jawab untuk menghubungkan suspender internal ke VCC. <br>  Perlu dicatat bahwa untuk beberapa port, secara default, pull-up dimatikan, dan sebagian diaktifkan. <br>  Ini penting untuk diingat! </li></ul><br>  <u>Registrasi Data:</u> <br><br><ul><li>  <i>GPADAT</i> - register status keluaran.  Jika output dikonfigurasi untuk input, maka dari itu kita membaca status input.  Jika dikonfigurasi untuk suatu output, maka kita dapat menuliskan nilai yang harus diambil oleh output ini, yaitu 0 atau 1 </li><li>  <i>GPASET</i> - register mengatur output ke "1".  Untuk mengatur ke "1", Anda harus menulis "1", ketika menulis "0" perintah diabaikan </li><li>  <i>GPACLEAR</i> - register mengatur output ke "0".  Untuk mengatur ke "0", Anda harus menulis "1", ketika menulis "0" perintah diabaikan </li><li>  <i>GPATOGGLE</i> adalah register yang membalikkan nilai saat ini dari status output.  Untuk membalikkan nilainya, tulis “1”; saat menulis “0”, perintahnya diabaikan </li></ul><br>  Berikut adalah set register yang sederhana.  Bahkan dari uraian di atas Anda sudah dapat memahami apa yang perlu dilakukan untuk mengkonfigurasi port, tetapi insinyur atau penulis teknis yang bijaksana dari TI membuat instruksi langkah-demi-langkah: <br><br><img src="https://habrastorage.org/webt/ly/tx/mk/lytxmkk_nwnp8qzigdzblyywwx8.png"><br><br>  Saya akan mengatakan segera bahwa langkah 6 dan 7 tidak perlu bagi kita, karena  baik anjing maupun interupsi tidak digunakan dalam artikel ini.  Saya akan menjelaskan langkah-langkah yang tersisa secara singkat untuk orang-orang yang belajar bahasa Jerman di sekolah: <br><br><ul><li>  <i>Langkah 1</i> - tentukan fungsi output: bahwa itu akan menjadi input atau output, <br>  gpio atau output ke periferal dan barang lainnya </li><li>  <i>Langkah 2</i> - aktifkan atau nonaktifkan pull-up internal </li><li>  <i>Langkah 3</i> - mengonfigurasi perlindungan pencatatan jam kerja dan pentalan untuk port tertentu </li><li>  <i>Langkah 4</i> - pilih fungsi yang diinginkan: gpio atau periferal </li><li>  <i>Langkah 5</i> - mengatur arah output: input atau output </li></ul><br>  Itu seluruh pengaturan, seperti yang Anda lihat, itu dasar dan jelas secara logis.  Saya ingin segera mencatat bahwa tidak perlu dalam urutan ini untuk melakukan pengaturan, misalnya, Anda dapat mengatur arah (input atau output) dengan langkah pertama.  Itu tidak masalah. <br><br>  <b>Sangat penting!</b> <br><br>  Ketika bekerja dengan register dalam keluarga C2000, perlu untuk mempertimbangkan saat mereka dilindungi.  Segala sesuatu yang diuraikan di bawah ini terutama berlaku untuk register dari grup konfigurasi.  Jika Anda hati-hati melihat fungsi standar, Anda mungkin melihat perintah aneh di sana: <b>EALLOW;</b>  dan <b>EDIS;</b>  .  Perintah <i>EALLOW</i> - menghapus perlindungan dan menyediakan akses untuk bekerja dengan register sistem.  Perintah <i>EDIS</i> - memungkinkan perlindungan balik dan menyediakan akses untuk bekerja dengan register sistem.  Artinya, semua pekerjaan dengan register sistem harus SELALU terlihat seperti ini: <br><br><pre> <code class="cpp hljs">EALLOW; <span class="hljs-comment"><span class="hljs-comment">//    ,   ,  EDIS;</span></span></code> </pre><br>  Operasi semacam itu tidak diperlukan jika kita bekerja dengan register data, misalnya, jika kita menetapkan output ke "1" menggunakan register <i>GPxSET</i> , maka kita tidak perlu menghapus perlindungan darinya dan, karenanya, hidupkan kembali.  Dokumentasi di mana-mana mengatakan apa yang perlu dilindungi dan apa yang tidak, misalnya, seperti ini: <br><br><img src="https://habrastorage.org/webt/ly/tx/mk/lytxmkk_nwnp8qzigdzblyywwx8.png"><br><br>  Berdasarkan semua hal di atas, mari kita mengkonfigurasi GPIO0 ... 3 dengan LED ke output.  Saya sarankan menempatkan semua pengaturan GPIO dalam fungsi <i>InitLEDgpio</i> dan menulisnya: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitLEDgpio</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ EALLOW; GpioCtrlRegs.GPADIR.bit.GPIO0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO3 = <span class="hljs-number"><span class="hljs-number">1</span></span>; EDIS; }</code> </pre><br>  Secara default, GPIO kami sudah dikonfigurasi sebagai GPIO, seperti  semua nilai register dihapus, yang berarti bahwa "0" sudah ditulis ke register GPAMUX1.  Untuk GPIO0 ... 11, pull-up dinonaktifkan secara default, jadi kami hanya dapat mengambil dan menentukan arah pekerjaan ke output menggunakan GPADIR.  Jika Anda ingat, LED terhubung ke controller dengan katoda, yang berarti bahwa segera setelah inisialisasi mereka akan menyala.  Mari kita atur kesimpulan ini secara langsung dalam fungsi inisialisasi menjadi "1": <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitLEDgpio</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ EALLOW; GpioCtrlRegs.GPADIR.bit.GPIO0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO3 = <span class="hljs-number"><span class="hljs-number">1</span></span>; EDIS; GpioDataRegs.GPASET.bit.GPIO0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioDataRegs.GPASET.bit.GPIO1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioDataRegs.GPASET.bit.GPIO2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioDataRegs.GPASET.bit.GPIO3 = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br>  Seperti yang Anda lihat, saya tidak menggunakan register <i>GPADAT</i> untuk menulis, tetapi gunakan <i>SET, CLEAR, TOGGLE</i> .  Perhatikan juga bahwa saya membuat entri ini di luar zona yang dilindungi, yaitu, setelah perintah <i>EDIS</i> .  Sekarang, dalam fungsi yang sama, konfigurasikan GPIO12 agar berfungsi dengan tombol dan tambahkan fungsi kami: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitLEDgpio</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ EALLOW; GpioCtrlRegs.GPADIR.bit.GPIO0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO3 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPAPUD.bit.GPIO12 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPACTRL.bit.QUALPRD1 = <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; GpioCtrlRegs.GPAQSEL1.bit.GPIO12 = <span class="hljs-number"><span class="hljs-number">2</span></span>; EDIS; GpioDataRegs.GPASET.bit.GPIO0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioDataRegs.GPASET.bit.GPIO1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioDataRegs.GPASET.bit.GPIO2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioDataRegs.GPASET.bit.GPIO3 = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br>  Pertama-tama, saya mematikan pengetatan internal dengan menulis "1" ke register <i>GPAPUD</i> , karena  ini diaktifkan oleh GPIO12 secara default.  Seperti yang saya tulis sebelumnya, semua port setelah inisialisasi dikonfigurasi untuk input, sebagai  nol ditulis dalam register <i>GPADIR</i> , kami tidak mengonfigurasinya di sini. <br><br>  Masih mengkonfigurasi perlindungan terhadap bouncing, untuk ini kami membagi <i>0xFF</i> pembagi, yang sesuai dengan nilai / 510.  Dalam register <i>GPAQSEL1</i> kita menulis nilai "10" atau 2, yang menetapkan nilai ke sampel 6 langkah.  Selesai!  Untuk membaca nilai input tertentu, Anda hanya perlu membaca nilai dari register <i>GPADAT</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GpioDataRegs.GPADAT.bit.GPIO12) { <span class="hljs-comment"><span class="hljs-comment">//      +3.3 (. 1)  ,     }</span></span></code> </pre><br>  Inilah cara kami menginterogasi kesimpulan yang diperlukan.  Sekarang mari kita panggil fungsi konfigurasi gpio di fungsi utama kita dan dapatkan bentuk akhirnya: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitStartSystem</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ DisableDog(); XtalOscSel(); InitPll(TMS320_PLLMUL, TMS320_DIVSEL); InitPeripheralClocks(); InitPieCtrl(); InitPieVectTable(); <span class="hljs-comment"><span class="hljs-comment">/*********************************/</span></span> InitLEDgpio(); }</code> </pre><br>  Sekarang kita memanggil fungsi <i>InitStartSystem</i> di badan utama program di main dan ini menyelesaikan konfigurasi.  Kami mendapatkan kode berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main (void) { InitStartSystem(); while(1) { } }</span></span></code> </pre><br>  Inilah saatnya untuk menulis program uji pertama kami dan menguji semua ini.  Algoritmanya adalah ini: LED yang berada pada GPIO3 berkedip, dan ketika Anda menekan tombol pada GPIO12, kami cukup menyalakan LED GPIO0.  Dengan demikian, kami akan memeriksa pengoperasian port untuk input dan output.  Kami menulis kode berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main (void) { InitStartSystem(); while(1) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (GpioDataRegs.GPADAT.bit.GPIO12) { GpioDataRegs.GPACLEAR.bit.GPIO0 = 1; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { GpioDataRegs.GPASET.bit.GPIO0 = 1; } GpioDataRegs.GPATOGGLE.bit.GPIO3 = 1; delay(100000); } }</span></span></code> </pre><br>  Kami mengkompilasi, pergi ke debugger, mulai dan lihat bagaimana satu LED terus berkedip, dan ketika Anda menekan tombol, yang lain menyala.  Di akhir bagian saya akan melampirkan proyek dengan kode ini, jika ada sesuatu yang tidak berhasil, maka selidiki.  Khususnya bagi mereka yang keras pada teks atau belum memahami semua poin, saya sarankan menonton video ini bekerja dengan GPIO, semuanya terjadi di sana, seperti di bagian "GPIO".  Saya memperingatkan Anda bahwa video selama satu jam, suram, panjang, tetapi serinci mungkin dan semuanya terlihat: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/jlyVy73pa98" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  File dari artikel </h2><br><ul><li>  Arsipkan dengan proyek untuk unduhan CCS7 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di sini</a> </li><li>  Anda dapat melihat kode di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a> </li></ul><br><h2>  Ringkasan </h2><br>  Pada tahap ini, saya sedang menyelesaikan artikel hari ini.  Saya pikir Anda mengerti bahwa jika saya segera memutuskan untuk menunjukkan implementasi DC / AC dari inverter, artikelnya akan beberapa kali lebih besar atau banyak detail penting akan tetap ada di belakang layar, yang menurut saya tidak dapat diterima. <br><br>  Saya harap artikel saya akan membantu semua orang untuk memulai pengembangan keluarga pengendali ini dan memulai pengembangan di bidang elektronik dan peralatan mesin.  Di masa depan, saya mungkin akan menulis sesuatu yang lain tentang topik ini, misalnya, saya ingin mempertimbangkan bekerja dengan PWM atau mengimplementasikan beberapa jenis algoritma.  Yang utama adalah punya waktu. <br><br>  Jika Anda memiliki pertanyaan atau jika sesuatu tidak berhasil, Anda dapat menulis saya di pesan pribadi dan saya akan mencoba menjawab pertanyaan Anda dan memberikan semua bantuan yang mungkin dalam penelitian ini.  Semoga sukses dalam pelatihan! <br><br>  <b>UPD</b>  Terima kasih atas tip dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">BelerafonL</a> pada buku <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">“Sistem Kontrol Digital Kinerja Tinggi Tertanam”</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id410161/">https://habr.com/ru/post/id410161/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id410149/index.html">Cara bernegosiasi di Skype dan telepon dalam bahasa Inggris: instruksi dan frasa yang berguna</a></li>
<li><a href="../id410153/index.html">Abad Pertengahan Slutty</a></li>
<li><a href="../id410155/index.html">Perban yang memberi hidup tidak bisa dilepas</a></li>
<li><a href="../id410157/index.html">Intel menunjukkan kacamata pintar tempat gambar dikirimkan ke retina</a></li>
<li><a href="../id410159/index.html">Bagaimana smartphone dapat menguping, mengintip, dan melacak</a></li>
<li><a href="../id410163/index.html">[KASUS] Pencetakan 3D dalam industri ringan pada contoh FullPower</a></li>
<li><a href="../id410167/index.html">Bagaimana kotoran dapat menyelamatkan umat manusia dari kiamat yang menular</a></li>
<li><a href="../id410169/index.html">[KASUS] Bagaimana kami melakukan tata letak bangunan Novo Nordisk</a></li>
<li><a href="../id410171/index.html">Robot DNA virus telah diprogram untuk memblokir pembuluh darah manusia dan membunuh tumor kanker.</a></li>
<li><a href="../id410173/index.html">Yandex bias menyusun berita utamanya, kata pengaduan yang dikirim ke FAS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>