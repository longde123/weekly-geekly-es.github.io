<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ö´Ô∏è üõ•Ô∏è ü¶ç Comprender los corredores de mensajes. Aprendiendo la mec√°nica de la mensajer√≠a a trav√©s de ActiveMQ y Kafka. Cap√≠tulo 2. ActiveMQ üë®üèª‚Äçüíª ü§º ü•ë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuaci√≥n de la traducci√≥n de un peque√±o libro: 
 "Comprender los corredores de mensajes", 
 autor: Jakub Korab, editor: O'Reilly Media, Inc., fech...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comprender los corredores de mensajes. Aprendiendo la mec√°nica de la mensajer√≠a a trav√©s de ActiveMQ y Kafka. Cap√≠tulo 2. ActiveMQ</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471268/">  Continuaci√≥n de la traducci√≥n de un peque√±o libro: <br>  "Comprender los corredores de mensajes", <br>  autor: Jakub Korab, editor: O'Reilly Media, Inc., fecha de publicaci√≥n: junio de 2017, ISBN: 9781492049296. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Traducci√≥n completada</a></b> <br><br>  Parte anterior: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Comprender los corredores de mensajes.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aprendiendo la mec√°nica de la mensajer√≠a a trav√©s de ActiveMQ y Kafka.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cap√≠tulo 1. Introducci√≥n</a> <br><a name="habracut"></a><br><h2>  CAPITULO 2 </h2><br><h2>  Activemq </h2><br>  ActiveMQ se describe mejor como un sistema de mensajer√≠a cl√°sico.  Fue escrito en 2004 para satisfacer la necesidad de un agente de mensajes de c√≥digo abierto.  En ese momento, si deseaba utilizar la mensajer√≠a en sus aplicaciones, la √∫nica opci√≥n eran los productos comerciales caros. <br><br>  ActiveMQ se desarroll√≥ como una implementaci√≥n de la especificaci√≥n Java Message Service (JMS).  Esta decisi√≥n se tom√≥ para cumplir con los requisitos para implementar la mensajer√≠a compatible con JMS en el proyecto Apache Geronimo, un servidor de aplicaciones J2EE de c√≥digo abierto. <br>  Un sistema de mensajer√≠a (o middleware orientado a mensajes, como a veces se le llama) que implementa la especificaci√≥n JMS consta de los siguientes componentes: <br><br>  <b>Corredor</b> <br><br>  Una pieza central de middleware que distribuye mensajes. <br><br>  <b>Cliente</b> <br><br>  El software que env√≠a mensajes a trav√©s de un corredor.  A su vez, consta de los siguientes artefactos: <br><br><ul><li>  C√≥digo usando la API JMS. </li><li>  La API JMS es un conjunto de interfaces para interactuar con un agente de acuerdo con las garant√≠as establecidas en la especificaci√≥n JMS. </li><li>  La biblioteca del cliente del sistema que proporciona la implementaci√≥n de la API e interact√∫a con el intermediario. </li></ul><br>  El cliente y el agente se comunican entre s√≠ a trav√©s del protocolo de capa de aplicaci√≥n, tambi√©n conocido como <i>protocolo de interacci√≥n</i> <a href="">(Figura 2-1)</a> .  La especificaci√≥n JMS dej√≥ los detalles de este protocolo a implementaciones espec√≠ficas. <br><br><img src="https://habrastorage.org/webt/u1/wi/za/u1wiza7rupveiqnyqktuqsa-mvs.png"><br>  <i>Figura 2-1.</i>  <i>Revisi√≥n de JMS</i> <br><br>  JMS utiliza el t√©rmino <i>proveedor</i> para describir la implementaci√≥n del proveedor del sistema de mensajer√≠a subyacente a la API de JMS, que incluye el intermediario, as√≠ como sus bibliotecas cliente. <br><br>  La elecci√≥n a favor de implementar JMS tuvo consecuencias de largo alcance para las decisiones de implementaci√≥n tomadas por los autores de ActiveMQ.  La especificaci√≥n en s√≠ misma proporciona una gu√≠a clara sobre las responsabilidades del cliente del sistema de mensajer√≠a y el agente con el que se comunica, dando preferencia a la obligaci√≥n del agente de distribuir y entregar mensajes.  La responsabilidad principal del cliente es interactuar con el destinatario (cola o tema) de los mensajes enviados por √©l.  La especificaci√≥n en s√≠ est√° destinada a hacer que la interacci√≥n de la API con el intermediario sea relativamente simple. <br><br>  Esta √°rea, como veremos m√°s adelante, tuvo un impacto significativo en el rendimiento de ActiveMQ.  Adem√°s de las complejidades del corredor, el paquete de compatibilidad para la especificaci√≥n proporcionada por Sun Microsystems ten√≠a muchos matices, con su propio impacto en el rendimiento.  Todos estos matices deber√≠an haberse tenido en cuenta para que ActiveMQ se considere compatible con JMS. <br><br><h3>  Comunicaci√≥n </h3><br>  Aunque la API y el comportamiento esperado estaban bien definidos en la especificaci√≥n JMS, el protocolo de comunicaci√≥n cliente-intermediario real se excluy√≥ deliberadamente de la especificaci√≥n para que los intermediarios existentes pudieran cumplir con JMS.  Por lo tanto, ActiveMQ era libre de definir su propio protocolo de interacci√≥n, OpenWire.  OpenWire es utilizado por la implementaci√≥n de la biblioteca de cliente ActiveMQ JMS, as√≠ como sus contrapartes en .Net y C ++: NMS y CMS, que son subproyectos de ActiveMQ alojados por Apache Software Foundation. <br><br>  Con el tiempo, se agreg√≥ soporte para otros protocolos de interacci√≥n a ActiveMQ, lo que aument√≥ la capacidad de interactuar con otros lenguajes y entornos: <br><br>  <b>AMQP 1.0</b> <br><br>  El Protocolo avanzado de colas de mensajes (ISO / IEC 19464: 2014) no debe confundirse con su predecesor 0.X, que se implementa en otros sistemas de mensajer√≠a, en particular RabbitMQ, usando 0.9.1.  AMQP 1.0 es un protocolo binario de prop√≥sito general para intercambiar mensajes entre dos nodos.  No tiene ning√∫n concepto de clientes o intermediarios e incluye funciones como control de flujo, transacciones y varias QoS (no m√°s de una vez, al menos una vez y exactamente una vez). <br><br>  <b>Pisar</b> <br><br>  Protocolo de mensajer√≠a orientado a texto simple / continuo, un protocolo f√°cil de implementar que tiene docenas de implementaciones de clientes en diferentes idiomas. <br><br>  <b>Xmpp</b> <br><br>  Mensajer√≠a extensible y protocolo de presencia.  (Protocolo extensible de mensajer√≠a y presencia).  Anteriormente llamado Jabber, este protocolo basado en XML se desarroll√≥ originalmente para sistemas de chat, pero se ha extendido m√°s all√° de sus casos de uso originales para incluir mensajes de publicaci√≥n-suscripci√≥n. <br><br>  <b>MQTT</b> <br><br>  El protocolo ligero de publicaci√≥n-suscripci√≥n (ISO / IEC 20922: 2016) utilizado para aplicaciones de m√°quina a m√°quina (M2M) e Internet de las cosas (IoT). <br><br>  ActiveMQ tambi√©n admite la imposici√≥n de los protocolos anteriores en WebSockets, que proporciona el intercambio de datos full-duplex entre aplicaciones en un navegador web y destinos en el intermediario. <br><br>  Dado esto, ahora cuando hablamos de ActiveMQ, ya no nos referimos exclusivamente a la pila de interacci√≥n basada en las bibliotecas JMS / NMS / CMS y el protocolo OpenWire.  La combinaci√≥n y selecci√≥n de idiomas, plataformas y bibliotecas externas que mejor se adaptan a esta aplicaci√≥n se est√° volviendo cada vez m√°s popular.  Por ejemplo, es posible que una aplicaci√≥n de JavaScript se ejecute en un navegador usando la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Eclipse Paho</a> MQTT para enviar mensajes a ActiveMQ a trav√©s de sockets web, y estos mensajes son le√≠dos por un proceso de servidor C ++ que usa AMQP a trav√©s de la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Apache Qpid Proton</a> .  Desde esta perspectiva, el panorama de los mensajes se est√° volviendo m√°s diverso. <br><br>  Mirando hacia el futuro, AMQP, en particular, tendr√° muchas m√°s oportunidades de las que tiene ahora, ya que los componentes que no son clientes ni corredores se est√°n convirtiendo en una parte m√°s familiar del panorama de la mensajer√≠a.  Por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Apache Qpid Dispatch Router</a> act√∫a como un enrutador de mensajes, al que los clientes se conectan directamente, permitiendo que diferentes destinos procesen diferentes direcciones, adem√°s de proporcionar la posibilidad de fragmentaci√≥n (separaci√≥n). <br><br>  Cuando trabaje con bibliotecas de terceros y componentes externos, tenga en cuenta que tienen una calidad variable y pueden no ser compatibles con las funciones proporcionadas en ActiveMQ.  Como un ejemplo muy simple: es imposible enviar mensajes a la cola a trav√©s de MQTT (sin configurar el enrutamiento en el intermediario).  Por lo tanto, necesitar√° pasar alg√∫n tiempo trabajando con las opciones para determinar la pila del sistema de mensajer√≠a m√°s adecuada para los requisitos de su aplicaci√≥n. <br><br><h3>  El compromiso entre rendimiento y confiabilidad </h3><br>  Antes de profundizar en los detalles de c√≥mo funciona la mensajer√≠a punto a punto en ActiveMQ, necesitamos hablar un poco sobre lo que enfrentan todos los sistemas con procesamiento de datos pesados: una compensaci√≥n entre rendimiento y confiabilidad. <br><br>  Cualquier sistema que acepte datos, ya sea un intermediario de mensajes o una base de datos, debe recibir instrucciones sobre c√≥mo procesar estos datos en caso de falla.  La falla puede tomar muchas formas, pero por simplicidad la reduciremos a una situaci√≥n en la que el sistema pierde energ√≠a y se apaga inmediatamente.  En esta situaci√≥n, debemos especular sobre lo que suceder√° con los datos que estaban en el sistema.  Si los datos (en este caso, mensajes) estaban en la memoria o en la parte vol√°til del hierro, por ejemplo, en el cach√©, entonces estos datos se perder√°n.  Sin embargo, si los datos se enviaron a un almacenamiento no vol√°til, por ejemplo, al disco, volver√°n a estar disponibles cuando el sistema vuelva a funcionar. <br><br>  Desde este punto de vista, tiene sentido que si no queremos perder mensajes en caso de falla de un corredor, necesitemos escribirlos en el almacenamiento permanente.  El costo de esta soluci√≥n en particular, desafortunadamente, es bastante alto. <br><br>  Tenga en cuenta que la diferencia entre escribir un megabyte de datos en el disco es 100-1000 veces m√°s lenta que escribir en la memoria.  Por lo tanto, el desarrollador de la aplicaci√≥n debe decidir si la confiabilidad del mensaje vale la p√©rdida de rendimiento.  Decisiones como estas deben hacerse en funci√≥n de un escenario de uso. <br><br>  La compensaci√≥n entre rendimiento y confiabilidad se basa en una gama de opciones.  Cuanto mayor es la fiabilidad, menor es el rendimiento.  Si decide hacer que el sistema sea menos confiable, por ejemplo, almacenando mensajes solo en la memoria, su productividad aumentar√° significativamente.  De manera predeterminada, JMS est√° configurado para tener ActiveMQ listo para usar para confiabilidad.  Existen muchos mecanismos que le permiten configurar el agente e interactuar con √©l en una posici√≥n en este espectro que sea m√°s adecuada para escenarios espec√≠ficos de uso del sistema de mensajer√≠a. <br><br>  Este compromiso se aplica a nivel de corredores individuales.  Sin embargo, al finalizar la configuraci√≥n de un agente individual, es posible escalar el sistema de mensajer√≠a m√°s all√° de este punto examinando cuidadosamente los flujos de mensajes y compartiendo el tr√°fico entre varios agentes.  Esto se puede lograr proporcionando a destinatarios espec√≠ficos sus propios intermediarios o dividiendo el flujo general de mensajes a nivel de aplicaci√≥n o utilizando un componente intermedio.  M√°s adelante, consideraremos con m√°s detalle c√≥mo tener en cuenta las topolog√≠as de los corredores. <br><br><h3>  Guardar mensajes </h3><br>  ActiveMQ viene con una serie de estrategias de retenci√≥n de mensajes conectables.  Vienen en forma de adaptadores de persistencia (persistencia), que pueden considerarse motores de almacenamiento de mensajes.  Estos incluyen soluciones basadas en disco como KahaDB y LevelDB, as√≠ como la capacidad de usar la base de datos a trav√©s de JDBC.  Como los primeros se usan con mayor frecuencia, centraremos nuestra discusi√≥n en ellos. <br><br>  Cuando un intermediario recibe mensajes persistentes, primero se escriben en el disco en un diario.  Un diario es una estructura de datos en disco en la que solo puede agregar datos y que consta de varios archivos.  El intermediario serializa los mensajes entrantes en una representaci√≥n independiente del protocolo del objeto, y luego se ordena en forma binaria, que luego se escribe al final del registro.  El registro contiene un registro de todos los mensajes entrantes, as√≠ como informaci√≥n sobre los mensajes que el cliente ha confirmado como le√≠dos. <br><br>  Los adaptadores de disco de persistencia admiten archivos de √≠ndice que rastrean d√≥nde se encuentran los siguientes mensajes reenviados en el registro.  Cuando se leen todos los mensajes del archivo de registro, el flujo de trabajo de fondo de ActiveMQ los eliminar√° o archivar√°.  Si este registro se da√±a durante la falla del agente, ActiveMQ lo reconstruir√° seg√∫n la informaci√≥n en los archivos de registro. <br><br>  Los mensajes de todas las colas se escriben en los mismos archivos de registro, lo que significa que si un mensaje no se lee, el archivo completo (generalmente el predeterminado es 32 MB o 100 MB, dependiendo del adaptador de persistencia) no se puede borrar.  Esto puede causar problemas con poco espacio en disco con el tiempo. <br><blockquote>  Los corredores de mensajes cl√°sicos no est√°n dise√±ados para el almacenamiento a largo plazo: ¬°lea sus mensajes! </blockquote>  Los registros son un mecanismo extremadamente eficiente para almacenar y recuperar mensajes, ya que el acceso al disco es secuencial para ambas operaciones.  En los discos duros convencionales, esto minimiza el n√∫mero de b√∫squedas de discos por cilindros, ya que las cabezas del disco simplemente contin√∫an leyendo o escribiendo sectores en el sustrato giratorio del disco.  Del mismo modo, en los SSD, el acceso secuencial es mucho m√°s r√°pido que el acceso aleatorio, ya que el primero hace un mejor uso de las p√°ginas de memoria del disco. <br><br><h3>  Factores de rendimiento del disco </h3><br>  Existen varios factores que determinan la velocidad a la que puede funcionar un disco.  Para comprender esto, considere el m√©todo de escribir en un disco a trav√©s de un modelo mental simplificado de una tuber√≠a ( <a href="">Figura 2-2</a> ). <br><br><img src="https://habrastorage.org/webt/kv/wx/j_/kvwxj_wqzdn772kf0lb5yttf4i8.png"><br>  <i>Figura 2-2.</i>  <i>Modelo de tubo de rendimiento de disco</i> <br><br>  Una tuber√≠a tiene tres dimensiones: <br><br>  <b>Longitud</b> <br><br>  Corresponde a la <i>latencia</i> esperada para completar una operaci√≥n.  Para la mayor√≠a de las unidades locales, es bastante bueno, pero puede convertirse en un factor limitante importante en entornos de nube donde la unidad local est√° realmente en l√≠nea.  Por ejemplo, al momento de escribir (abril de 2017), Amazon garantiza que la escritura en su almacenamiento EBS ser√° "en menos de 2 ms".  Si registramos secuencialmente, esto da un rendimiento m√°ximo de 500 registros por segundo. <br><br>  <b>Ancho</b> <br><br>  Determina la <i>capacidad de carga o el ancho de banda de una</i> sola operaci√≥n.  Los cach√©s del sistema de archivos utilizan esta propiedad combinando muchos registros peque√±os en un conjunto m√°s peque√±o de operaciones de escritura m√°s grandes realizadas en el disco. <br><br>  <b>Ancho de banda en el tiempo</b> <br><br>  La idea se presenta en forma de una serie de eventos que pueden estar en la tuber√≠a al mismo tiempo, expresados ‚Äã‚Äãpor una m√©trica llamada <i>IOPS (n√∫mero de operaciones de E / S por segundo)</i> .  IOPS es com√∫nmente utilizado por los fabricantes de almacenamiento y los proveedores de la nube para medir el rendimiento.  El disco duro tendr√° diferentes valores de IOPS en diferentes contextos: si la carga de trabajo consiste principalmente en lectura, escritura o una combinaci√≥n de ellos, y si estas operaciones son secuenciales, arbitrarias o mixtas.  Las mediciones de IOPS que son m√°s interesantes desde el punto de vista del corredor son operaciones de lectura y escritura secuenciales, ya que corresponden a la lectura y escritura de registros de un registro. <br><br>  El rendimiento m√°ximo de un intermediario de mensajes est√° determinado por el <i>logro de la primera de estas restricciones,</i> y la configuraci√≥n del intermediario depende en gran medida de la forma en que interact√∫a con los discos.  Esto no es solo un factor de c√≥mo, por ejemplo, se configura el corredor, sino que tambi√©n depende de c√≥mo los productores interact√∫an con el corredor.  Al igual que con todo lo relacionado con el rendimiento, es necesario probar el intermediario en una carga de trabajo representativa (es decir, lo m√°s cerca posible de mensajes reales) y en la configuraci√≥n de almacenamiento real que se utilizar√° en PROM.  Esto se hace para comprender c√≥mo se comportar√° el sistema en realidad. <br><br><h3>  API JMS </h3><br>  Antes de entrar en detalles sobre c√≥mo ActiveMQ se comunica con los clientes, primero debemos aprender la API de JMS.  La API define un conjunto de interfaces de programaci√≥n utilizadas por el c√≥digo del cliente: <br><br>  <b>ConnectionFactory</b> <br><br>  Esta es la interfaz de nivel superior que se utiliza para establecer conexiones con el intermediario.  En una aplicaci√≥n de mensajer√≠a t√≠pica, solo hay una instancia de esta interfaz.  En ActiveMQ, este es un ActiveMQConnectionFactory.  En el nivel superior, este dise√±o indica la ubicaci√≥n del agente de mensajes, junto con detalles de bajo nivel sobre c√≥mo interactuar con √©l.  Como su nombre lo indica, ConnectionFactory es el mecanismo por el cual se crean los objetos Connection. <br><br>  <b>Conexi√≥n</b> <br><br>  Este es un objeto de larga duraci√≥n que se asemeja m√°s o menos a una conexi√≥n TCP: despu√©s de la creaci√≥n, generalmente existe durante todo el ciclo de vida de la aplicaci√≥n hasta que se cierra.  La conexi√≥n es segura para subprocesos y puede funcionar con m√∫ltiples subprocesos simult√°neamente.  Los objetos de conexi√≥n le permiten crear objetos de sesi√≥n. <br><br>  <b>Sesi√≥n</b> <br><br>  Este es un identificador de flujo cuando interact√∫a con un corredor.  Los objetos de sesi√≥n no son seguros para subprocesos, lo que significa que varios subprocesos no pueden acceder a ellos al mismo tiempo.  La sesi√≥n es el descriptor transaccional principal con el que el programador puede confirmar y revertir los mensajes de reversi√≥n si est√° en modo transaccional.  Con este objeto, puede crear objetos Message, MessageConsumer y MessageProducer, y tambi√©n obtener punteros (descriptores) para objetos de Tema y Cola. <br><br>  <b>MessageProducer</b> <br><br>  Esta interfaz le permite enviar un mensaje al destinatario. <br><br>  <b>Mensajeconsumidor</b> <br><br>  Esta interfaz permite al desarrollador recibir mensajes.  Hay dos mecanismos de recuperaci√≥n de mensajes: <br><br><ul><li>  Registrar MessageListener.  Esta es la interfaz del manejador de mensajes que ha implementado, que procesar√° secuencialmente cualquier mensaje emitido por el intermediario utilizando una secuencia. </li><li>  Sondeo de mensajes utilizando el m√©todo de recepci√≥n (). </li></ul><br>  <b>Mensaje</b> <br><br>  Esta es probablemente la estructura m√°s importante ya que transfiere sus datos.  Los mensajes en JMS constan de dos aspectos: <br><br><ul><li>  Metadatos del mensaje.  El mensaje contiene encabezados y propiedades.  Tanto eso como eso pueden considerarse elementos de un mapa.  Los encabezados son elementos bien conocidos definidos por la especificaci√≥n JMS y disponibles directamente a trav√©s de la API, como JMSDestination y JMSTimestamp.  Las propiedades son piezas arbitrarias de informaci√≥n de mensajes que se configuran para simplificar el procesamiento o el enrutamiento de mensajes sin tener que leer la carga √∫til del mensaje.  Puede, por ejemplo, establecer el encabezado en AccountID o OrderType. </li><li>  Cuerpo del mensaje.  Desde la sesi√≥n, se pueden crear varios tipos diferentes de mensajes dependiendo del tipo de contenido que se enviar√° en el cuerpo, los m√°s comunes son TextMessage para cadenas y BytesMessage para datos binarios. </li></ul><br><h3>  C√≥mo funcionan las colas: una historia de dos cerebros </h3><br>  Un modelo de trabajo √∫til, aunque inexacto, de ActiveMQ es un modelo de dos mitades del cerebro.  Una parte es responsable de recibir mensajes del productor y la otra env√≠a estos mensajes a los consumidores.  Las relaciones son en realidad m√°s complejas para fines de optimizaci√≥n del rendimiento, pero el modelo es suficiente para una comprensi√≥n b√°sica. <br><br><h4>  Enviar mensajes a la cola </h4><br>  Veamos la interacci√≥n que ocurre al enviar un mensaje. <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La Figura 2-3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nos muestra un modelo simplificado del proceso mediante el cual el intermediario recibe los mensajes. No corresponde totalmente al comportamiento en cada caso, pero es bastante adecuado para obtener una comprensi√≥n b√°sica. </font></font><br><br><img src="https://habrastorage.org/webt/u9/tc/_p/u9tc_p1dznwdwdajfxt19fsoxva.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 2-3. Env√≠o de mensajes a JMS</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En una aplicaci√≥n cliente, un hilo recibe un puntero a un MessageProducer. Crea un mensaje con una carga √∫til estimada del mensaje y llama a MessageProducer.send ("pedidos", mensaje), con la cola como destino final del mensaje. Dado que el programador no quiere perder el mensaje si el intermediario se rompi√≥, el encabezado del mensaje JMSDeliveryMode se configur√≥ en PERSISTENT (comportamiento predeterminado).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este punto (1), la transmisi√≥n de env√≠o llama a la biblioteca del cliente y ordena el mensaje en el formato OpenWire. Entonces el mensaje se env√≠a al corredor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el intermediario, la secuencia receptora elimina el mensaje de la l√≠nea y lo desmarca al objeto interno. Luego, el objeto del mensaje se transmite al adaptador de persistencia, que ordena el mensaje utilizando el formato de Google Protocol Buffers y lo escribe en el almacenamiento (2). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de grabar el mensaje en el almacenamiento, el adaptador de persistencia deber√≠a recibir la confirmaci√≥n de que el mensaje fue realmente grabado (3). Esta suele ser la parte m√°s lenta de toda la interacci√≥n; M√°s sobre esto m√°s adelante.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tan pronto como el agente se asegure de que el mensaje se haya guardado, enviar√° una respuesta de confirmaci√≥n (4) al cliente. Despu√©s de eso, el hilo del cliente que originalmente llam√≥ a la operaci√≥n send () puede continuar su trabajo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta confirmaci√≥n pendiente de mensajes persistentes es la base de la garant√≠a proporcionada por la API de JMS: si desea que se guarde el mensaje, probablemente tambi√©n sea importante para usted si el intermediario recibi√≥ el mensaje en primer lugar. Existen varias razones por las cuales esto puede no ser posible, por ejemplo, se ha alcanzado un l√≠mite de memoria o disco. En lugar de fallar, el intermediario suspende la operaci√≥n de env√≠o, obligando al productor a esperar hasta que aparezcan suficientes recursos del sistema para procesar el mensaje (un proceso llamado Control de flujo del productor), o enviar√° una confirmaci√≥n negativa al productor, lanzando una excepci√≥n. El comportamiento exacto es personalizable para cada corredor.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta operaci√≥n simple, tiene lugar un n√∫mero significativo de interacciones de E / S: dos operaciones de red entre el productor y el intermediario, una operaci√≥n de guardar y un paso de confirmaci√≥n. La operaci√≥n de guardar puede ser una simple escritura en el disco u otra transici√≥n de red al servidor de almacenamiento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto plantea una pregunta importante sobre los corredores de mensajes: su trabajo est√° asociado con un flujo extremadamente intenso de operaciones de E / S y son muy sensibles a la infraestructura utilizada, especialmente a los discos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Echemos un vistazo m√°s de cerca al paso de confirmaci√≥n (3) en la interacci√≥n anterior. </font><font style="vertical-align: inherit;">Si el adaptador de persistencia est√° basado en archivos, almacenar el mensaje implica escribir en el sistema de archivos. </font><font style="vertical-align: inherit;">Si es as√≠, ¬øpor qu√© debo confirmar que la operaci√≥n de escritura se ha completado? </font><font style="vertical-align: inherit;">¬øEl hecho de completar una grabaci√≥n realmente significa que ha ocurrido una grabaci√≥n?</font></font><br>  En realidad no<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como suele suceder, cuanto m√°s profundo estudias algo, m√°s complejo resulta ser. </font><font style="vertical-align: inherit;">En este caso particular, el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">almacenamiento en cach√©</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es el culpable </font><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cach√©s, cach√©s en todas partes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando un proceso del sistema operativo, como un intermediario, escribe datos en el disco, interact√∫a con el sistema de archivos. Un sistema de archivos es un proceso que abstrae los detalles de la interacci√≥n con el medio de almacenamiento utilizado, proporcionando una API para operaciones de archivos como ABRIR, CERRAR, LEER y ESCRIBIR. Una de estas funciones es </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">minimizar el n√∫mero de operaciones de escritura</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> almacenando los datos escritos por el sistema operativo en bloques que se pueden guardar en el disco de una manera. Las operaciones de escritura del sistema de archivos que parecen interactuar con discos se escriben realmente en esta </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memoria cach√© de b√∫fer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por cierto, es por eso que su computadora se queja cuando expulsa inseguramente una unidad USB: ¬°los archivos que copi√≥ pueden no haberse escrito realmente! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tan pronto como los datos van m√°s all√° de la memoria cach√© del b√∫fer, pasan al siguiente nivel de almacenamiento en cach√©, esta vez a nivel de hardware: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la memoria cach√© del controlador de disco</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Son especialmente importantes para los sistemas basados ‚Äã‚Äãen RAID y realizan la misma funci√≥n que el almacenamiento en cach√© a nivel del sistema operativo: minimizar el n√∫mero de interacciones necesarias para las unidades en s√≠. Estas memorias cach√© se dividen en dos categor√≠as: las </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">escrituras escritas</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se transfieren al disco inmediatamente despu√©s de la recepci√≥n. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reescritura</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La grabaci√≥n se realiza en discos solo cuando el b√∫fer est√° lleno y alcanza un cierto valor umbral. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los datos almacenados en estas memorias cach√© se pueden perder f√°cilmente durante un corte de energ√≠a, porque la memoria que usan generalmente es </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vol√°til (vol√°til)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Las tarjetas m√°s caras tienen paquetes de bater√≠as redundantes (BBU) que admiten energ√≠a de cach√© hasta que todo el sistema pueda restaurar la energ√≠a, despu√©s de lo cual los datos se escribir√°n en el disco. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El √∫ltimo nivel de cach√© est√° en los discos mismos. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cach√©s de disco</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ubicado en discos duros (tanto en discos duros est√°ndar como en unidades de estado s√≥lido) y puede ser de escritura o reescritura. La mayor√≠a de las unidades comerciales utilizan cach√©s de reescritura y son vol√°tiles, lo que nuevamente significa que los datos pueden perderse en caso de una falla de energ√≠a.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al volver al intermediario de mensajes, debe completar el paso de confirmaci√≥n para asegurarse de que los datos realmente hayan llegado al disco. Desafortunadamente, la interacci√≥n con estos b√∫feres de hardware depende del sistema de archivos, por lo que todo lo que puede hacer un proceso como ActiveMQ es enviar una se√±al al sistema de archivos de que desea sincronizar todos los b√∫feres del sistema con el dispositivo en uso. Para hacer esto, el intermediario llama al m√©todo java.io.FileDescriptor.sync (), que, a su vez, inicia la operaci√≥n POSIX fsync ().</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este comportamiento de sincronizaci√≥n es un requisito del JMS para garantizar que todos los mensajes marcados como persistentes se guarden realmente en el disco y, por lo tanto, se ejecuten despu√©s de recibir cada mensaje o conjunto de mensajes relacionados en una transacci√≥n. </font><font style="vertical-align: inherit;">Por lo tanto, la velocidad a la que un disco puede ejecutar sync () es cr√≠tica para el rendimiento del agente.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conflictos internos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El uso de un registro para todas las colas agrega complejidad adicional. En cualquier momento, puede haber varios productores enviando mensajes simult√°neamente. El intermediario tiene varias transmisiones que reciben estos mensajes de los sockets entrantes. Cada hilo debe guardar su mensaje en el registro. Dado que varios hilos no pueden escribir en el mismo archivo al mismo tiempo, porque los registros entrar√°n en conflicto entre s√≠, luego los registros deben colocarse en cola utilizando el mecanismo de exclusi√≥n mutua. Llamamos a este </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hilo conflicto</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada mensaje debe estar completamente grabado y sincronizado antes de procesar el siguiente mensaje. Esta restricci√≥n afecta a todas las colas en el intermediario al mismo tiempo. Por lo tanto, la velocidad de la rapidez con que se puede recibir un mensaje es el tiempo que lleva escribir en el disco, m√°s cualquier tiempo de espera para que otras transmisiones terminen de grabar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ActiveMQ incluye un b√∫fer de escritura, en el que las secuencias receptoras escriben sus mensajes, esperando la finalizaci√≥n de la grabaci√≥n anterior. Luego, el b√∫fer se escribe en una acci√≥n cuando el mensaje est√° disponible. Al finalizar, los hilos son notificados. Por lo tanto, el corredor maximiza el uso del ancho de banda de almacenamiento.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para minimizar el impacto del conflicto de subprocesos, a los conjuntos de colas se les pueden asignar sus propios registros utilizando el adaptador mKahaDB. </font><font style="vertical-align: inherit;">Este enfoque reduce la latencia de escritura, ya que en cualquier momento los hilos probablemente escribir√°n en diferentes registros y no tendr√°n que competir entre s√≠ para obtener acceso exclusivo a un archivo de registro.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transacciones </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La ventaja de usar una sola revista para todas las colas es que, desde el punto de vista de los autores del corredor, es mucho m√°s f√°cil implementar transacciones. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Veamos un ejemplo en el que un productor env√≠a varios mensajes a varias colas. El uso de una transacci√≥n significa que todo el conjunto de mensajes a enviar debe considerarse como una operaci√≥n at√≥mica. En esta interacci√≥n, la biblioteca del cliente ActiveMQ puede realizar algunas optimizaciones que aumentar√°n significativamente la velocidad de env√≠o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la operaci√≥n que se muestra en la </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 2-4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, el productor env√≠a tres mensajes, todos en diferentes colas. </font><font style="vertical-align: inherit;">En lugar de la interacci√≥n habitual con el intermediario, cuando se confirma cada mensaje, el cliente env√≠a los tres mensajes de forma asincr√≥nica, es decir, sin esperar una respuesta. </font><font style="vertical-align: inherit;">Estos mensajes se almacenan en la memoria del corredor. </font><font style="vertical-align: inherit;">Tan pronto como se completa la operaci√≥n, el productor informa a sus sesiones sobre la necesidad de comprometerse, lo que a su vez obliga al corredor a realizar un registro grande con una operaci√≥n de sincronizaci√≥n. </font></font><br><br><img src="https://habrastorage.org/webt/i0/gl/tu/i0gltuz_gqybny3uyjrtpiot5bg.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 2-4. </font><font style="vertical-align: inherit;">Env√≠o de mensajes en transacciones</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En este tipo de operaci√≥n, ActiveMQ utiliza dos optimizaciones para aumentar la velocidad:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eliminar el tiempo de espera antes de que sea posible el pr√≥ximo env√≠o del productor </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Combinando muchas operaciones de disco peque√±o en una grande, esto le permite usar todo el ancho de banda del bus de disco </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si comparamos esto con la situaci√≥n en la que cada cola se almacena en su propio registro, entonces el intermediario tendr√≠a que proporcionar algo como la coordinaci√≥n de transacciones entre todos los registros. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Restando mensajes de la cola </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El proceso de lectura de mensajes comienza cuando el consumidor expresa su disposici√≥n a aceptarlos configurando un MessageListener para procesar los mensajes a medida que llegan o llamando al m√©todo MessageConsumer.receive () ( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 2-5</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><img src="https://habrastorage.org/webt/eh/p7/-2/ehp7-2hesg0xjd1h4ynnqr46gqo.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 2-5. Lectura de mensajes a trav√©s de JMS</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cuando ActiveMQ se da cuenta de un consumidor, (ActiveMQ) lee (p√°ginas) mensajes p√°gina por p√°gina desde el almacenamiento a la memoria de distribuci√≥n (1). Luego, estos mensajes son redirigidos (enviados) al contador (2), a menudo en varias partes para reducir la cantidad de interacci√≥n de la red. El corredor realiza un seguimiento de qu√© mensajes se han redirigido y a qu√© consumidor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los mensajes recibidos por el consumidor no son procesados ‚Äã‚Äãinmediatamente por la aplicaci√≥n, sino que se colocan en un √°rea de memoria conocida como</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tamp√≥n de captaci√≥n previa (tamp√≥n de captaci√≥n previa)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . El prop√≥sito de este b√∫fer es agilizar el flujo de mensajes para que el agente pueda emitir mensajes al supervisor cuando est√©n disponibles para enviar, mientras que el consumidor puede recibirlos de manera ordenada, uno a la vez. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En alg√∫n momento despu√©s de ingresar al b√∫fer de captaci√≥n previa, la l√≥gica de la aplicaci√≥n (X) lee los mensajes y la confirmaci√≥n de la revisi√≥n se env√≠a al intermediario (3). El tiempo transcurrido entre el procesamiento del mensaje y la confirmaci√≥n se configura utilizando un par√°metro de sesi√≥n JMS denominado </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modo de reconocimiento</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que discutiremos m√°s adelante.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tan pronto como el intermediario acepta la confirmaci√≥n de entrega del mensaje, se elimina de la memoria y del almac√©n de mensajes (4). El t√©rmino "eliminaci√≥n" es algo enga√±oso, ya que en realidad se escribe un registro de confirmaci√≥n en la revista y el √≠ndice en el √≠ndice aumenta. La eliminaci√≥n real del archivo de registro que contiene el mensaje ser√° realizada por el recolector de basura en el hilo de fondo basado en esta informaci√≥n.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El comportamiento descrito anteriormente es una simplificaci√≥n para facilitar la comprensi√≥n. </font><font style="vertical-align: inherit;">De hecho, ActiveMQ no solo lee datos p√°gina por p√°gina del disco, sino que utiliza el mecanismo del cursor entre las partes receptoras y redireccionadoras del intermediario para minimizar la interacci√≥n con el repositorio del intermediario siempre que sea posible. </font><font style="vertical-align: inherit;">La paginaci√≥n, como se describi√≥ anteriormente, es uno de los modos utilizados en este mecanismo. </font><font style="vertical-align: inherit;">Los cursores se pueden ver como un cach√© de nivel de aplicaci√≥n que debe mantenerse sincronizado con el repositorio del intermediario. </font><font style="vertical-align: inherit;">El protocolo de coherencia utilizado es una parte importante de lo que hace que el mecanismo de env√≠o de ActiveMQ sea mucho m√°s complejo que el mecanismo de Kafka que se describe en el pr√≥ximo cap√≠tulo.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modos de confirmaci√≥n y transacci√≥n </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Varios modos de confirmaci√≥n, que determinan el orden entre la correcci√≥n de pruebas y la confirmaci√≥n, tienen un impacto significativo en la l√≥gica que debe implementarse en el cliente. Son los siguientes: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AUTO_ACKNOWLEDGE</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Este es el modo m√°s utilizado, posiblemente porque tiene la palabra AUTO. Este modo obliga a la biblioteca del cliente a reconocer el mensaje al mismo tiempo que el mensaje es le√≠do por la llamada a reciben (). Esto significa que si la l√≥gica empresarial iniciada por el mensaje arroja una excepci√≥n, entonces el mensaje se pierde porque ya se ha eliminado en el intermediario. Si el mensaje se lee a trav√©s del oyente, el mensaje se confirmar√° solo despu√©s de que el oyente haya completado con √©xito el trabajo. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CLIENT_ACKNOWLEDGE</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se enviar√° una confirmaci√≥n solo cuando el c√≥digo del consumidor llame expl√≠citamente al m√©todo Message.acknowledge (). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DUPS_OK_ACKNOWLEDGE</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aqu√≠ las confirmaciones ser√°n almacenadas en el consumidor antes de enviarlas simult√°neamente para reducir la cantidad de tr√°fico de red. Sin embargo, si el sistema del cliente se apaga, se perder√°n las confirmaciones y los mensajes se reenviar√°n y procesar√°n por segunda vez. Por lo tanto, el c√≥digo debe considerar la probabilidad de mensajes duplicados.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los modos de confirmaci√≥n se complementan con herramientas de lectura transaccional. </font><font style="vertical-align: inherit;">Al crear una sesi√≥n, se puede marcar como transaccional. </font><font style="vertical-align: inherit;">Esto significa que el programador debe llamar expl√≠citamente a Session.commit () o Session.rollback (). </font><font style="vertical-align: inherit;">En el lado del consumidor, las transacciones ampl√≠an el rango de interacciones que el c√≥digo puede realizar como una operaci√≥n at√≥mica. </font><font style="vertical-align: inherit;">Por ejemplo, puede leer y procesar m√∫ltiples mensajes como un todo, o restar un mensaje de una cola y luego enviarlo a otro usando el mismo objeto Session.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Despacho y varios consumidores </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasta ahora, hemos estado discutiendo el comportamiento de leer mensajes con un solo consumidor. Veamos ahora c√≥mo este modelo es aplicable a varios consumidores. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando varios consumidores se suscriben a la cola, el comportamiento predeterminado del corredor es enviar mensajes de ida y vuelta a aquellos consumidores que tienen un lugar en los b√∫feres de captaci√≥n previa. Los mensajes se enviar√°n en el orden en que llegaron a la cola: esta es la √∫nica garant√≠a FIFO proporcionada (primero en entrar, primero en salir; primero en entrar, primero en salir). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando el consumidor se apaga repentinamente, todos los mensajes que se le env√≠en, pero a√∫n no confirmados, se reenviar√°n a otro cliente disponible.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto plantea una pregunta importante: incluso cuando se utilizan transacciones de consumidores, no hay garant√≠a de que el mensaje no se procesar√° varias veces. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considere la siguiente l√≥gica de procesamiento dentro del consumidor:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El mensaje se resta de la cola. </font><font style="vertical-align: inherit;">La transacci√≥n comienza.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se llama a un servicio web con el contenido del mensaje. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La transacci√≥n est√° comprometida. </font><font style="vertical-align: inherit;">Se env√≠a una confirmaci√≥n al corredor.</font></font></li></ol><br>  Si el cliente completa entre los pasos 2 y 3, entonces la revisi√≥n del mensaje ya ha afectado a alg√∫n otro sistema al llamar al servicio web.  Las llamadas al servicio web son solicitudes HTTP y, como tales, no son transaccionales. <br><br>  Este comportamiento es cierto para todos los sistemas de colas, incluso si son transaccionales, no pueden garantizar que no habr√° efectos secundarios al procesar mensajes en ellos.  Habiendo examinado el procesamiento de mensajes en detalle, podemos decir con confianza que: <br><br>  <i>No existe la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">entrega de mensajes solo una vez</a> .</i> <br><br>  Las colas proporcionan una garant√≠a de entrega <i>al menos una vez,</i> y las partes sensibles del c√≥digo siempre deben considerar la posibilidad de recibir mensajes repetidos.  M√°s adelante discutiremos c√≥mo un cliente de mensajer√≠a puede usar la lectura idempotente para rastrear mensajes que ya han sido vistos y evitar duplicados. <br><br><h4>  Ordenar mensajes </h4><br>  Para un conjunto de mensajes que llegan en el orden de [A, B, C, D], y para dos consumidores C1 y C2, la distribuci√≥n normal de los mensajes ser√° la siguiente: <br><br> <code>C1: [A, C] <br> C2: [B, D]</code> <br>  Dado que el intermediario no controla el funcionamiento de los procesos de lectura y el orden de procesamiento es paralelo, no es determinista.  Si C1 es m√°s lento que C2, el conjunto inicial de mensajes puede procesarse como [B, D, A, C]. <br><br>  Este comportamiento puede sorprender a los principiantes que esperan que los mensajes se procesen en orden y, sobre esta base, est√°n desarrollando su propia aplicaci√≥n de mensajer√≠a.  El requisito de que los mensajes enviados por el mismo remitente se procesen en orden uno con respecto al otro, tambi√©n conocido como <i>ordenamiento causal</i> , es bastante com√∫n. <br><br>  Tomemos como ejemplo el siguiente caso de uso tomado de las apuestas en l√≠nea: <br><br><ol><li>  La cuenta de usuario est√° configurada. </li><li>  El dinero se acredita en la cuenta. </li><li>  Se realiza una apuesta que retira dinero de la cuenta. </li></ol><br>  Aqu√≠ tiene sentido que los mensajes se procesen en el orden en que fueron enviados, de modo que se tenga en cuenta el estado general de la cuenta.  Pueden suceder cosas extra√±as si el sistema intenta eliminar dinero de una cuenta que no tiene fondos.  Hay, por supuesto, formas de evitar esto. <br><br>  El modelo de <i>cliente exclusivo</i> incluye enviar todos los mensajes de la cola a un cliente.  Con este enfoque, cuando se conectan varias instancias de aplicaciones o subprocesos a la cola, se firman utilizando un par√°metro de destinatario especial: <code>my.queue?consumer.exclusive=true</code> .  Cuando conecta a un consumidor monopolista, √©l recibe todos los mensajes.  Cuando el segundo consumidor est√° conectado, no recibir√° ning√∫n mensaje hasta que el primero se desconecte.  Este segundo consumidor es en realidad una reserva activa, mientras que el primer consumidor ahora recibir√° mensajes exactamente en el orden en que fueron registrados en el diario, en un orden causal. <br>  La desventaja de este enfoque es que, aunque el procesamiento de mensajes es consistente, es un cuello de botella de rendimiento porque todos los mensajes deben ser procesados ‚Äã‚Äãpor un solo compilador. <br><br>  Para comprender este caso de uso de manera m√°s inteligente, debe reconsiderar el problema.  ¬øTodos los mensajes deben procesarse en orden?  En el caso de las ofertas de procesamiento descritas anteriormente, es necesario procesar solo los mensajes relacionados con una cuenta secuencialmente.  ActiveMQ proporciona un mecanismo para hacer frente a esta situaci√≥n llamada <i>grupos de mensajes JMS</i> . <br><br>  Los grupos de mensajes son un tipo de mecanismo de partici√≥n que permite a los productores distribuir mensajes en grupos que se procesar√°n secuencialmente de acuerdo con una clave comercial.  Esta clave comercial se establece en una propiedad de mensaje llamada <code>JMSXGroupID</code> . <br><br>  La clave natural en el caso de procesamiento de ofertas ser√° el identificador de la cuenta. <br>  Para ilustrar c√≥mo funciona el env√≠o, considere un conjunto de mensajes que llegan en el siguiente orden: <br><br><pre> <code class="plaintext hljs">[(A, Group1), (B, Group1), (C, Group2), (D, Group3), (E, Group2)]</code> </pre> <br>  Cuando el mecanismo de despacho procesa un mensaje en ActiveMQ y ve un <code>JMSXGroupID</code> que no exist√≠a antes, esta clave se asigna al consumidor de forma c√≠clica.  De ahora en adelante, todos los mensajes con esta clave se enviar√°n a este contador. <br><br>  Aqu√≠ los grupos se asignar√°n entre dos consumidores: C1 y C2, de la siguiente manera: <br><br><pre> <code class="plaintext hljs">C1: [Group1, Group3] C2: [Group2]</code> </pre> <br>  Los mensajes ser√°n redirigidos y procesados ‚Äã‚Äãde la siguiente manera: <br><br><pre> <code class="plaintext hljs">C2: [B, D] C2: [(C, Group2), (E, Group2)]</code> </pre> <br>  Si el consumidor se descompone, todos los grupos asignados a √©l ser√°n redistribuidos entre el resto de los consumidores y cualquier mensaje no confirmado ser√° redirigido nuevamente.  Por lo tanto, aunque podemos garantizar que todos los mensajes relacionados se procesar√°n en orden, no podemos afirmar que ser√°n procesados ‚Äã‚Äãpor el mismo consumidor. <br><br><h3>  Alta disponibilidad </h3><br>  ActiveMQ proporciona alta disponibilidad con un maestro-esclavo basado en almacenamiento compartido.  En este esquema, dos o m√°s corredores (aunque generalmente dos) se configuran en servidores separados, y sus mensajes se almacenan en un almac√©n de mensajes ubicado en una ubicaci√≥n externa.  Un almac√©n de mensajes no puede ser usado simult√°neamente por varias instancias de un intermediario, por lo tanto, su funci√≥n secundaria (almac√©n) es actuar como un mecanismo de bloqueo para determinar qu√© intermediario obtendr√° acceso exclusivo ( <a href="">Figura 2-6</a> ). <br><br><img src="https://habrastorage.org/webt/bn/yn/d5/bnynd5kctkhlomy5nb7-gmckrws.png"><br>  <i>Figura 2-6.</i>  <i>El corredor A es el l√≠der; el corredor B est√° en espera como esclavo</i> <br><br>  Para conectarse al repositorio, el primer intermediario (Broker A) asume el rol de l√≠der y abre sus puertos para el tr√°fico de mensajes.  Cuando el segundo corredor (Broker B) se conecta al repositorio, intenta obtener un bloqueo y, dado que no tiene √©xito, se detiene por un breve per√≠odo antes de intentar volver a bloquearlo.  Esto se llama contenci√≥n impulsada. <br><br>  Al mismo tiempo, el cliente alterna las direcciones de los dos intermediarios en un intento de conectarse al puerto de entrada, conocido como el conector de transporte.  Tan pronto como el corredor principal est√© disponible, el cliente se conecta a su puerto y puede enviar y leer mensajes. <br>  Cuando el Agente A, que act√∫a como l√≠der, falla debido a una falla del proceso ( <a href="">Figura 2-7</a> ), ocurren los siguientes eventos: <br><br><ol><li>  El cliente se desconecta e inmediatamente intenta reconectarse, alternando las direcciones de dos corredores. </li><li>  Se libera el bloqueo en el mensaje.  El momento de esto depende de la implementaci√≥n del almacenamiento. </li><li>  El corredor B, que estaba en modo esclavo, peri√≥dicamente tratando de obtener un bloqueo, finalmente tiene √©xito y asume el papel de maestro, abriendo sus puertos. </li><li>  El cliente se conecta al Broker B y contin√∫a su trabajo. </li></ol><br><img src="https://habrastorage.org/webt/ks/wi/yd/kswiydyc5bffutft06ck-1sm4zq.png"><br>  <i>Figura 2-7.</i>  <i>El intermediario A termina perdiendo la conexi√≥n al repositorio.</i>  <i>El corredor B toma la delantera</i> <br><blockquote>  No se garantiza que la l√≥gica de alternancia entre varias direcciones de intermediario se incorpore a la biblioteca del cliente, como es el caso en las implementaciones de JMS / NMS / CMS.  Si la biblioteca solo proporciona la reconexi√≥n a una sola direcci√≥n, es posible que deba colocar un par de intermediarios detr√°s de un equilibrador de carga, que tambi√©n deber√≠a estar altamente disponible. </blockquote>  La principal desventaja de este enfoque es que para simplificar el trabajo de un intermediario l√≥gico, se requieren varios servidores f√≠sicos.  En este caso, uno de los dos servidores del corredor est√° inactivo, esperando la desconexi√≥n de su socio antes de que pueda comenzar a funcionar. <br><br>  Este enfoque tambi√©n tiene la complejidad adicional que el almacenamiento de intermediario utilizado, ya sea un sistema de archivos de red compartido o una base de datos, tambi√©n debe ser altamente accesible.  Esto conlleva costos adicionales para el equipo y la administraci√≥n de la configuraci√≥n del agente.  En este escenario, es tentador reutilizar los repositorios de alta disponibilidad existentes utilizados por otras partes de la infraestructura, como una base de datos, pero esto es un error. <br><br>  Es importante recordar que el disco es el principal limitador del rendimiento general del corredor.  Si el disco mismo es utilizado simult√°neamente por un proceso que no sea el intermediario de mensajes, entonces la interacci√≥n de este proceso con el disco probablemente ralentiza la grabaci√≥n del intermediario y, por lo tanto, la velocidad a la que los mensajes pueden pasar por el sistema.  Tales ralentizaciones son dif√≠ciles de diagnosticar y la √∫nica forma de evitarlas es separar los dos procesos en diferentes vol√∫menes de almacenamiento. <br><br>  Para garantizar el funcionamiento estable del agente, se requiere un almacenamiento dedicado y exclusivo. <br><br><h3>  Escala vertical y horizontal </h3><br>  En alg√∫n momento de la vida del proyecto, puede encontrar una limitaci√≥n de rendimiento en el intermediario de mensajes.  Estas limitaciones generalmente se relacionan con los recursos, en particular las interacciones de ActiveMQ con el almacenamiento utilizado.  Estos problemas generalmente surgen debido a conflictos de volumen de mensajes o ancho de banda entre los destinatarios, por ejemplo, cuando una cola desborda al intermediario durante los per√≠odos pico. <br><br>  Hay varias formas de obtener m√°s rendimiento de la infraestructura del corredor: <br><br><ul><li>  No use persistencia si no es necesario.  Algunos escenarios de uso permiten la p√©rdida de mensajes durante bloqueos, especialmente cuando un sistema env√≠a otro estado de instant√°nea completo al otro a trav√©s de la cola, ya sea peri√≥dicamente o bajo demanda. </li><li>  Ejecute el corredor en unidades m√°s r√°pidas.  En condiciones reales, se observaron diferencias significativas en el ancho de banda de grabaci√≥n entre HDD est√°ndar y alternativas basadas en memoria. </li><li>  Aproveche al m√°ximo los tama√±os de disco.  Como se muestra en el modelo de interacci√≥n de canalizaci√≥n de disco descrito anteriormente, se puede lograr un mayor rendimiento mediante el uso de transacciones para enviar grupos de mensajes, combinando as√≠ varias operaciones de escritura en una m√°s grande. </li><li>  Usar particiones de tr√°fico.  Puede lograr un mayor rendimiento dividiendo los destinos de una de las siguientes maneras: </li></ul><br><ol><li>  Varios discos dentro de un intermediario, por ejemplo, utilizando el adaptador de persistencia mKahaDB para varios directorios, cada uno de los cuales est√° montado en un disco separado. </li><li>  Varios corredores, y la partici√≥n del tr√°fico se lleva a cabo manualmente por la aplicaci√≥n cliente.  ActiveMQ no proporciona ninguna funci√≥n nativa para este prop√≥sito. </li></ol><br>  Una de las causas m√°s comunes de los problemas de rendimiento del corredor es simplemente un intento de hacer demasiado con una instancia.  Como regla, esto ocurre en situaciones en las que el intermediario se divide ingenuamente entre varias aplicaciones sin tener en cuenta la carga existente en el intermediario o sin comprender los vol√∫menes.  Con el tiempo, un corredor se carga cada vez m√°s hasta que deja de comportarse adecuadamente. <br><br>  El problema a menudo surge durante la fase de dise√±o del sistema, cuando el arquitecto del sistema puede proponer un esquema como el de la <a href="">Figura 2-8</a> . <br><br><img src="https://habrastorage.org/webt/86/2g/9m/862g9malnlxd6k8ryettpya_dwu.png"><br>  <i>Figura 2-8.</i>  <i>Vista conceptual de la infraestructura de mensajer√≠a</i> <br><br>  El objetivo es que varias aplicaciones se comuniquen entre s√≠ de forma asincr√≥nica a trav√©s de ActiveMQ.  El objetivo ya no se especifica y luego el esquema determina la base de la configuraci√≥n real del agente.  Este enfoque se llama Universal Data Pipeline. <br><br>  No tiene en cuenta el paso fundamental de an√°lisis entre el dise√±o conceptual mencionado anteriormente y la implementaci√≥n f√≠sica.  Antes de continuar con la construcci√≥n de una configuraci√≥n espec√≠fica, es necesario realizar un an√°lisis, que luego se utilizar√° para justificar el proyecto f√≠sico.  El primer paso en este proceso es determinar qu√© sistemas interact√∫an entre s√≠: un diagrama bastante simple con rect√°ngulos y flechas ( <a href="">Figura 2-9</a> ). <br><br><img src="https://habrastorage.org/webt/v_/wz/cz/v_wzczik2oi-menqrxjenakhs1e.png"><br>  <i>Figura 2-9.</i>  <i>El mensaje de boceto fluye entre sistemas</i> <br><br>  Despu√©s de su aprobaci√≥n, puede ir a los detalles para responder las siguientes preguntas: <br><br><ul><li>  ¬øCu√°ntas colas y temas se usar√°n? </li><li>  ¬øQu√© vol√∫menes de mensajes se esperan para cada uno de ellos? </li><li>  ¬øQu√© tan grandes son los mensajes en cada destinatario?  Los mensajes grandes pueden causar problemas en el proceso de paginaci√≥n, lo que lleva a exceder los l√≠mites de memoria y bloquear el intermediario. </li><li>  ¬øEl flujo de mensajes ser√° uniforme durante todo el d√≠a o habr√° picos debido a los trabajos por lotes?  Grandes lotes en una cola menos utilizada pueden interferir con las escrituras oportunas del disco para destinos de alto rendimiento. </li><li>  ¬øEst√°n los sistemas en el mismo centro de datos o en diferentes?  La comunicaci√≥n remota involucra alg√∫n tipo de intermediarios de red. </li></ul><br>  La idea es definir escenarios de mensajer√≠a separados que puedan ser combinados o divididos por corredores individuales ( <a href="">Figura 2-10</a> ). <br>  Despu√©s de dicho desglose, los escenarios de uso se pueden simular combin√°ndose entre s√≠ mediante el M√≥dulo de rendimiento ActiveMQ para identificar cualquier problema. <br><br><img src="https://habrastorage.org/webt/nj/im/ry/njimryyhatcjfwhprygsdrrzqwc.png"><br>  <i>Figura 2-10.</i>  <i>Identificaci√≥n de corredores individuales.</i> <br><br>  Despu√©s de determinar el n√∫mero apropiado de intermediarios l√≥gicos, puede determinar c√≥mo implementarlos a nivel f√≠sico utilizando configuraciones y redes de intermediarios altamente accesibles. <br><br><h3>  Resumen </h3><br>  En este cap√≠tulo, examinamos el mecanismo por el cual ActiveMQ recibe y distribuye mensajes.  Discutimos las caracter√≠sticas que son compatibles con esta arquitectura, incluido el equilibrio de carga fijo de mensajes y transacciones relacionados.  Al mismo tiempo, presentamos un conjunto de conceptos comunes a todos los sistemas de mensajer√≠a, incluidos protocolos de comunicaci√≥n y revistas.  Tambi√©n examinamos en detalle las dificultades involucradas en la escritura en disco y c√≥mo los corredores pueden usar t√©cnicas como la escritura de paquetes para mejorar el rendimiento.  Finalmente, examinamos c√≥mo ActiveMQ puede estar altamente disponible y c√≥mo escalarlo m√°s all√° de las capacidades de un agente individual. <br><br>  En el pr√≥ximo cap√≠tulo, veremos Apache Kafka y c√≥mo su arquitectura redefine la relaci√≥n entre clientes y corredores para proporcionar una canalizaci√≥n de mensajes incre√≠blemente robusta con un ancho de banda que es muchas veces mayor que un corredor de mensajes normal.  Analizaremos la funcionalidad que utiliza para lograr este objetivo y consideraremos brevemente la arquitectura de las aplicaciones que proporcionan esta funcionalidad. <br><br>  Siguiente parte: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Comprender los corredores de mensajes.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aprendiendo la mec√°nica de la mensajer√≠a a trav√©s de ActiveMQ y Kafka.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cap√≠tulo 3. Kafka</a> <br><br>  <b>Traducci√≥n completada: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tele.gg/middle_java</a></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/471268/">https://habr.com/ru/post/471268/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../471258/index.html">Almacenamiento de datos / sistema de carga</a></li>
<li><a href="../471260/index.html">Kali Linux NetHunter en Android Parte 2: ataques en redes inal√°mbricas</a></li>
<li><a href="../471262/index.html">Holivar Historia de Runet. Parte 5. Trolls: Aprenda, impresora fren√©tica, cobre</a></li>
<li><a href="../471264/index.html">Elegir una alternativa a Mailchimp: por qu√© cambiar y qu√© producto elegir</a></li>
<li><a href="../471266/index.html">El futuro est√° aqu√≠ o codificado directamente en el navegador</a></li>
<li><a href="../471270/index.html">Automatizamos la recepci√≥n de datos sobre la velocidad de carga de un sitio desde Google PageSpeed ‚Äã‚ÄãInsights [plantilla]</a></li>
<li><a href="../471272/index.html">Los beneficios de escribir fuerte en C ++: experiencia pr√°ctica</a></li>
<li><a href="../471278/index.html">Generaci√≥n de texto en ruso por plantillas</a></li>
<li><a href="../471282/index.html">Buscando neumon√≠a en rayos X con Fast.ai</a></li>
<li><a href="../471288/index.html">Creando la cara de un personaje para el juego "OnAir"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>