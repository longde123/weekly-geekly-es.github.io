<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸš´ğŸ» ğŸ ğŸ‘‚ğŸ½ Pemikiran deklaratif ğŸ‘ˆğŸ½ ğŸ‘µğŸ¼ ğŸ¤µğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo pengembara. Kita, sebagai pengembara dalam pikiran kita, dan penganalisa kondisi kita, harus memahami di mana itu baik, dan di mana sebaliknya, d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pemikiran deklaratif</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430964/"><p> Halo pengembara.  Kita, sebagai pengembara dalam pikiran kita, dan penganalisa kondisi kita, harus memahami di mana itu baik, dan di mana sebaliknya, di mana tepatnya kita berada, dan saya ingin menarik pembaca untuk ini. </p><br><p>  Bagaimana kita menyatukan rantai pemikiran, secara berurutan, dengan mengasumsikan kesimpulan dari setiap langkah, mengendalikan aliran kontrol dan keadaan sel dalam memori?  Atau hanya dengan menggambarkan pernyataan masalah, beri tahu program tugas mana yang ingin Anda selesaikan, dan ini cukup untuk mengkompilasi semua program.  Jangan mengubah pengkodean menjadi aliran perintah yang akan mengubah keadaan internal sistem, tetapi nyatakan prinsip sebagai konsep pengurutan, karena Anda tidak perlu membayangkan algoritma apa yang disembunyikan di sana, Anda hanya perlu mendapatkan data yang diurutkan.  Bukanlah tidak berarti bahwa presiden Amerika dapat menyebutkan Bubble, dia mengungkapkan gagasan bahwa dia memahami sesuatu dalam pemrograman.  Dia baru saja menemukan bahwa ada algoritma pengurutan, dan data dalam tabel di desktopnya, dengan sendirinya, tidak dapat berbaris, dalam beberapa cara ajaib, dalam urutan abjad. </p><br><p>  Gagasan bahwa saya cenderung pada cara deklaratif untuk mengekspresikan pikiran, dan untuk mengekspresikan segala sesuatu dengan urutan perintah dan transisi di antara mereka, tampaknya kuno dan ketinggalan zaman, karena kakek kami melakukan ini, kakek menghubungkan kontak pada panel patch dan lampu berkedip, dan kami memiliki monitor dan pengenalan suara, karena pada tingkat evolusi ini Anda masih dapat berpikir tentang mengikuti perintah ... Menurut saya, jika Anda mengekspresikan program dalam bahasa yang logis, itu akan terlihat lebih dapat dimengerti, dan ini dapat dilakukan  dalam teknologi, taruhan dibuat kembali di tahun 80-an. </p><br><p>  Nah, pengantar diseret .... </p><a name="habracut"></a><br><p>  Saya akan mencoba, sebagai permulaan, untuk menceritakan kembali mekanisme penyortiran cepat.  <em>Untuk mengurutkan daftar, Anda perlu membaginya menjadi dua sub-daftar dan menggabungkan satu sub-daftar yang diurutkan dengan sub-daftar yang diurutkan lainnya</em> . </p><br><p>  Operasi pemisahan harus dapat mengubah daftar menjadi dua sublists, salah satunya berisi semua elemen yang kurang mendasar, dan daftar kedua hanya berisi elemen besar.  Mengekspresikan ini, hanya dua baris yang ditulis di Erlang: </p><br><pre><code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">qsort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([])</span></span></span><span class="hljs-function">-&gt;</span></span>[]; qsort([H|T])-&gt;qsort([X||X&lt;-T,X&lt;H])++[H|qsort([X||X&lt;-T,X&gt;=H])].</code> </pre> <br><p>  Ungkapan dari hasil proses pemikiran ini menarik bagi saya. </p><br><p>  Lebih sulit untuk memberikan deskripsi tentang prinsip penyortiran dalam bentuk imperatif.  Bagaimana mungkin ada keuntungan untuk metode pemrograman ini, dan kemudian Anda tidak menyebutnya, meskipun ada s-place-place, setidaknya fortran.  Apakah karena javascript, dan semua tren fungsi lambda dalam standar baru semua bahasa, merupakan konfirmasi dari ketidaknyamanan algoritme. </p><br><p>  Saya akan mencoba melakukan percobaan untuk memverifikasi manfaat dari satu pendekatan dan yang lain, untuk mengujinya.  Saya akan mencoba menunjukkan bahwa catatan deklaratif dari definisi penyortiran dan catatan algoritmiknya dapat dibandingkan dalam hal kinerja dan menyimpulkan bagaimana merumuskan program dengan lebih tepat.  Mungkin ini akan mendorong pemrograman ke rak melalui algoritma dan aliran perintah, sebagai pendekatan yang sudah ketinggalan zaman, yang sama sekali tidak relevan untuk digunakan, karena itu tidak kurang modis untuk mengekspresikan diri dalam Haskell atau dalam cross-section.  Dan mungkin bukan hanya peri-tajam yang dapat memberikan program tampilan yang jelas dan kompak? </p><br><p>  Saya akan menggunakan Python untuk demonstrasi, karena memiliki beberapa paradigma, dan ini bukan C ++ sama sekali dan tidak lagi cadel.  Anda dapat menulis program yang jelas dalam paradigma yang berbeda: </p><br><h1 id="sortirovka-1">  Sortir 1 </h1><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">qsort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> S==[]:<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [] H,T=S[<span class="hljs-number"><span class="hljs-number">0</span></span>],S[<span class="hljs-number"><span class="hljs-number">1</span></span>:] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> qsort([X <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> X <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> X&lt;T])+[H]+qsort([X <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> X <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> X&gt;=T])</code> </pre> <br><p>  Kata-kata dapat diucapkan seperti ini: <em>pengurutan mengambil elemen pertama sebagai basis, dan kemudian semua yang lebih kecil diurutkan dan dihubungkan ke semua yang lebih besar, sebelum diurutkan</em> . <br>  Atau mungkin ungkapan seperti itu bekerja lebih cepat daripada menyortir yang ditulis dalam bentuk permutasi dari beberapa elemen di sekitarnya atau tidak.  Apakah mungkin untuk mengungkapkan ini dengan lebih ringkas, dan tidak memerlukan banyak kata untuk ini.  Cobalah untuk merumuskan dengan keras prinsip penyortiran berdasarkan gelembung dan menyampaikannya kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Presiden Amerika Serikat</a> , karena dia mendapatkan data suci ini, dia belajar tentang algoritme dan meletakkannya, misalnya, seperti ini: <em>Untuk mengurutkan daftar, Anda perlu mengambil beberapa elemen, membandingkannya satu sama lain dan jika yang pertama lebih dari yang kedua, maka mereka harus ditukar, diatur ulang, dan kemudian Anda perlu mengulangi pencarian pasangan elemen tersebut dari awal daftar sampai permutasi selesai</em> . </p><br><p>  Ya, prinsip menyortir gelembung bahkan terdengar lebih lama dari versi pengurutan cepat, tetapi keunggulan kedua tidak hanya dalam singkatnya catatan, tetapi juga dalam kecepatannya, ekspresi dari pengurutan cepat yang sama yang dirumuskan oleh algoritma akankah ia lebih cepat daripada versi yang diungkapkan secara deklaratif?  Mungkin kita perlu mengubah pandangan kita tentang pemrograman pengajaran, perlu bagaimana orang Jepang mencoba memperkenalkan pengajaran Prolog dan pemikiran terkait di sekolah.  Anda dapat secara sistematis pindah ke jarak dari bahasa algoritmik ekspresi pikiran. </p><br><h1 id="sortirovka-2">  Sortir 2 </h1><br><p>  Untuk mereproduksi ini, saya harus beralih ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">literatur</a> , ini adalah pernyataan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hoar</a> , saya mencoba mengubahnya menjadi Python: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quicksort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A, lo, hi)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> lo &lt; hi: p = partition(A, lo, hi) quicksort(A, lo, p - <span class="hljs-number"><span class="hljs-number">1</span></span>) quicksort(A, p + <span class="hljs-number"><span class="hljs-number">1</span></span>, hi) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> A <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">partition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A, lo, hi)</span></span></span><span class="hljs-function">:</span></span> pivot = A[lo] i = lo - <span class="hljs-number"><span class="hljs-number">1</span></span> j = hi + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> do: i= i + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> A[i] &lt; pivot do : j= j - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> A[j] &gt; pivot <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= j: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> j A[i],A[j]=A[j],A[i]</code> </pre> <br><p>  Saya mengagumi pemikiran itu, sebuah siklus tak berujung diperlukan di sini, ia akan memasukkan pergi-yang ada)), ada beberapa pelawak. </p><br><h1 id="analiz">  Analisis </h1><br><p>  Sekarang mari kita membuat daftar panjang dan membuatnya mengurutkan berdasarkan kedua metode, dan memahami bagaimana mengekspresikan pikiran kita lebih cepat dan lebih efisien.  Pendekatan mana yang lebih mudah dilakukan? <br>  Membuat daftar angka acak sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah</a> terpisah, beginilah caranya untuk diungkapkan: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">qsort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> S==[]:<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [] H,T=S[<span class="hljs-number"><span class="hljs-number">0</span></span>],S[<span class="hljs-number"><span class="hljs-number">1</span></span>:] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> qsort([X <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> X <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> X&lt;H])+[H]+qsort([X <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> X <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> X&gt;=H]) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(len)</span></span></span><span class="hljs-function">:</span></span> list=[random.randint(<span class="hljs-number"><span class="hljs-number">-100</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>,len)] <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> monotonic start = monotonic() slist=qsort(list) print(<span class="hljs-string"><span class="hljs-string">'qsort='</span></span>+str(monotonic() - start)) <span class="hljs-comment"><span class="hljs-comment">##print(slist)</span></span></code> </pre> <br><p>  Berikut adalah pengukuran yang didapat: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; test(10000) qsort=0.046999999998661224 &gt;&gt;&gt; test(10000) qsort=0.0629999999946449 &gt;&gt;&gt; test(10000) qsort=0.046999999998661224 &gt;&gt;&gt; test(100000) qsort=4.0789999999979045 &gt;&gt;&gt; test(100000) qsort=3.6560000000026776 &gt;&gt;&gt; test(100000) qsort=3.7340000000040163 &gt;&gt;&gt;</code> </pre> <br><p>  Sekarang saya ulangi ini dalam formulasi algoritma: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quicksort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A, lo, hi)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> lo &lt; hi: p = partition(A, lo, hi) quicksort(A, lo, p ) quicksort(A, p + <span class="hljs-number"><span class="hljs-number">1</span></span>, hi) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> A <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">partition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A, lo, hi)</span></span></span><span class="hljs-function">:</span></span> pivot = A[lo] i = lo<span class="hljs-number"><span class="hljs-number">-1</span></span> j = hi+<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: i=i+<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(A[i]&gt;=pivot) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (i&gt;=hi): <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: j=j<span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(A[j]&lt;=pivot) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (j&lt;=lo): <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= j: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> max(j,lo) A[i],A[j]=A[j],A[i] <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(len)</span></span></span><span class="hljs-function">:</span></span> list=[random.randint(<span class="hljs-number"><span class="hljs-number">-100</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>,len)] <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> monotonic start = monotonic() slist=quicksort(list,<span class="hljs-number"><span class="hljs-number">0</span></span>,len<span class="hljs-number"><span class="hljs-number">-1</span></span>) print(<span class="hljs-string"><span class="hljs-string">'quicksort='</span></span>+str(monotonic() - start))</code> </pre> <br><p>  Saya harus bekerja mengubah contoh asli dari algoritma dari sumber kuno ke Wikipedia.  Jadi ini: <em>Anda perlu mengambil elemen pendukung dan mengatur elemen-elemen dalam subarray sehingga semuanya semakin sedikit di sebelah kiri, dan semakin banyak di sebelah kanan.</em>  <em>Untuk melakukan ini, tukar sisi kiri dengan elemen kanan.</em>  <em>Kami ulangi ini untuk setiap sublist dari elemen referensi dibagi dengan indeks, jika tidak ada yang berubah, kami selesai</em> . </p><br><h1 id="itogo">  Total </h1><br><p>  Mari kita lihat apa perbedaan waktu untuk daftar yang sama, yang diurutkan berdasarkan dua metode secara bergantian.  Kami akan melakukan 100 percobaan, dan membuat grafik: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(len)</span></span></span><span class="hljs-function">:</span></span> t1,t2=[],[] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span>): list=[random.randint(<span class="hljs-number"><span class="hljs-number">-100</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>,len)] list2=list[:] <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> monotonic start = monotonic() slist=qsort(list) t1+=[monotonic() - start] <span class="hljs-comment"><span class="hljs-comment">#print('qsort='+str(monotonic() - start)) start = monotonic() slist=quicksort(list2,0,len-1) t2+=[monotonic() - start] #print('quicksort='+str(monotonic() - start)) import matplotlib.pyplot as plt fig = plt.figure() ax = fig.add_subplot(111) ax.plot(range(1,100),t1,label='qsort') ax.plot(range(1,100),t2,label='quicksort') ax.legend() ax.grid(True) plt.show() test(10000)</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/k-/9c/gc/k-9cgcwk63v6bgvboi1xwwyrscu.png" alt="dijalankan waktu dtk."></p><br><p>  Apa yang bisa dilihat di sini - fungsi quicksort () bekerja <strong>lebih cepat</strong> , tetapi catatannya tidak begitu jelas, meskipun fungsinya rekursif, tetapi sama sekali tidak mudah untuk memahami pekerjaan permutasi yang dilakukan di dalamnya. </p><br><p>  Nah, ungkapan pemikiran menyortir apa yang lebih <strong>sadar?</strong> </p><br><p>  Dengan perbedaan kecil dalam kinerja, kami mendapatkan perbedaan volume dan kompleksitas kode tersebut. </p><br><p>  Mungkin kebenaran sudah cukup untuk mempelajari bahasa imperatif, tetapi apa yang lebih menarik bagi Anda? </p><br><h1 id="ps-a-vot-i-prolog">  PS.  Dan inilah Prolognya: </h1><br><pre> <code class="plaintext hljs">qsort([],[]). qsort([H|T],Res):- findall(X,(member(X,T),X&lt;H),L1), findall(X,(member(X,T),X&gt;=H),L2), qsort(L1,S1), qsort(L2,S2), append(S1,[H|S2],Res).</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430964/">https://habr.com/ru/post/id430964/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430954/index.html">Qt Everywhere: WebAssembly dan WebGL Streaming</a></li>
<li><a href="../id430956/index.html">Kami mengajar seekor babi pada monoids untuk percaya pada diri mereka sendiri dan terbang</a></li>
<li><a href="../id430958/index.html">Kami meluncurkan wadah dengan unit test di Azure DevOps (VSTS)</a></li>
<li><a href="../id430960/index.html">Tentang gamedev dari pameran desktop</a></li>
<li><a href="../id430962/index.html">Dukungan Razor dalam Visual Studio Code</a></li>
<li><a href="../id430966/index.html">Sprint umum di Perangkat Lunak Atlassian Jira</a></li>
<li><a href="../id430968/index.html">"Pikiran sedang online." Drone ada di mana-mana</a></li>
<li><a href="../id430970/index.html">Cloud pribadi</a></li>
<li><a href="../id430972/index.html">node.js serverside - bekerja pada bug. Bagian 1</a></li>
<li><a href="../id430974/index.html">Tur foto hebat dari cloud Moskow 1cloud</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>