<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍💻 🏍️ 👩🏿‍🤝‍👩🏾 Senden Sie h264-Videos ohne Transcodierung von einer Logitech C920-Kamera 🗡️ 👇🏽 🧓🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Verzögerung betrug nicht mehr als 0,3 Sekunden, da die Kamera an ein schwaches BeagleBone Blue mit einer Prozessorlast von nicht mehr als 30% ange...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Senden Sie h264-Videos ohne Transcodierung von einer Logitech C920-Kamera</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415567/"><img src="https://habrastorage.org/webt/dc/by/xs/dcbyxsicqllz2-jksmikcesodlu.jpeg"><br><br>  Die Verzögerung betrug nicht mehr als 0,3 Sekunden, da die Kamera an ein schwaches BeagleBone Blue mit einer Prozessorlast von nicht mehr als 30% angeschlossen ist und der Videostream über einen WLAN-Router an einen Laptop übertragen wird. <br><a name="habracut"></a><br>  Zunächst bestand die Aufgabe darin, Videos vom Roboter an einen großen Computer zu senden, ohne den Prozessor auf den Roboter zu laden und ohne Verzögerungen.  Beim Googeln von Kameras und Programmen für diese Aufgabe wurde festgestellt, dass sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kameras mit hardwarebasierter Videokodierung auf der Kamera selbst befinden.</a> Danach wurde die Logitech C920-Kamera gekauft.  Und es begannen Tests und Experimente, bei denen zwei Übersetzungsoptionen ohne Transcodierung gefunden wurden. <br><br>  Alle weiteren Aktionen werden unter Ubuntu 16.04 überprüft, die zweite Option funktioniert wahrscheinlich unter Windows <br><br><h3>  Übertragen Sie hardwarecodiertes Video von einer Logitech C920-Kamera über cvlc und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">v4l2</a> </h3><br>  clvc - Server sendet Video über vlc über die Befehlszeile. <br><br><h4>  Hardware, die einen Videostream codiert </h4><br>  Stellen Sie die Pixelformatkameras auf H264 ein <br><br><pre><code class="bash hljs">v4l2-ctl --device=/dev/video1 --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-fmt-video=width=800,height=600,pixelformat=1</code> </pre> <br>  Testen Sie H264 mit vlc, damit die Einstellungen nicht zurückgesetzt werden: <br><br><pre> <code class="bash hljs">cvlc v4l2:///dev/video1 --demux h264</code> </pre> <br>  Wenn Sie dies versuchen, setzt vlc die Einstellungen vor dem Spielen zurück: <br><br><pre> <code class="bash hljs">cvlc v4l2:///dev/video1:chroma=h264</code> </pre> <br>  Die Wiedergabe funktioniert.  Wir bekommen den H264-Stream von der Kamera.  Lassen Sie uns nun über HTTP über das Netzwerk gehen: <br><br><pre> <code class="bash hljs">cvlc v4l2:///dev/video1:chroma=h264:width=800:height=600 --sout <span class="hljs-string"><span class="hljs-string">'#standard{access=http,mux=ts,dst=localhost:8080,name=stream,mime=video/ts}'</span></span> -vvv</code> </pre> <br>  (Im Netzwerk müssen Sie anstelle von localhost die IP-Adresse Ihres lokalen Geräts verwenden.) <br><br>  Empfängerstart: <br><br><pre> <code class="bash hljs">mplayer http://localhost:8080/</code> </pre> <br>  Es stellt sich heraus, dass MPEG-TS es mplayer ermöglicht, jederzeit mit einer leichten Verzögerung eine Verbindung zum Stream herzustellen (wahrscheinlich auf einen Keyframe oder etw warten). <br><br>  Wenn Sie mux = avi, mime = video / avi verwenden, müssen Sie mplayer ausführen, sobald Sie vlc starten. Andernfalls wird mplayer nicht abgespielt. <br><br><h4>  Ffmpeg-Fehler </h4><br><ul><li>  Wenn Sie versuchen, ffmpeg anstelle von vlc zu spielen, werden Sie wahrscheinlich auf dieses Problem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">stoßen</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ffmpeg.org/trac/ffmpeg/ticket/1387</a> </li><li>  Sobald Sie ffmpeg ausführen, wird zu "Video: rawvideo (YUY2 / 0x32595559)" gewechselt. </li><li>  Während es MJPEG akzeptiert, funktioniert es nicht mit H.264 </li><li>  Dasselbe passiert bei Verwendung von qv4l2: Wenn Sie die Aufnahme im H264-Modus starten, erhalten Sie tatsächlich das YUY2-Videofenster </li></ul><br><h4>  Hardware-decodiertes Video abspielen </h4><br>  Mplayer kann Framebuffer spielen, stellen Sie sicher, dass X nicht funktioniert, und geben Sie Folgendes ein: <br><br><pre> <code class="bash hljs">mplayer http://192.168.1.100:8080/ -fs -framedrop -vo fbdev</code> </pre> <br>  Sie können auch im X-Fenster spielen, wenn Sie möchten: Führen Sie X über die Befehlszeile aus: <br><br><pre> <code class="bash hljs">Xorg -retro &amp;&gt; /dev/zero</code> </pre> <br>  Es gibt Unmengen von fbdev-Fehlermeldungen, die wir stillschweigend in / dev / zero ablegen <br><br>  Spielen Sie einen Videostream von einer LAN-VLC-Quelle ab (siehe Abschnitt oben): <br><br><pre> <code class="bash hljs">DISPLAY=<span class="hljs-string"><span class="hljs-string">":0"</span></span> mplayer http://192.168.1.100:8080/ -fs -framedrop</code> </pre> <br><ul><li>  Wenn wir dies tun, werden wir feststellen, dass wir noch kein Xvideo oder eine Hardwarebeschleunigung verwenden </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">linux-sunxi.org/CedarX</a> scheint uns eine VPU-Bibliothek zur Verfügung zu stellen, was leider eine unsichere Sache von Allwinner ist </li><li>  Aber es gibt einen gehackten VLC, der es verwenden kann: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">linux-sunxi.org/VLC</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erfolgreich kompiliert</a> </li></ul><br><h4>  Himbeer pi </h4><br>  Falls Sie Artefakte im Bild und Streams von Raspberry Pi bemerken, verwenden Sie: <br><br><pre> <code class="bash hljs">cvlc v4l2:///dev/video0:chroma=h264 ...</code> </pre> <br>  Möglicherweise müssen Sie die Firmware aktualisieren: <br><br><pre> <code class="bash hljs">apt-get install rpi-update raspi-config rpi-update reboot</code> </pre> <br><h4>  Broadcast-Zusammenfassung über cvlc und v4l2 </h4><br>  Tests haben gezeigt, dass die Prozessorlast auf Beaglebone Blue nicht mehr als 30% beträgt, was für einen schwachen Prozessor sehr gut ist, aber es ist nicht klar, wie dieses Video dann in ROS verschoben werden soll. <br><br>  Wenn die WLAN-Bandbreite nicht ausreicht, steigt die Videoverzögerung stark an. Theoretisch kann dies durch Umschalten von tcp auf udp gelöst werden. In der cvlc-Dokumentation wird die Möglichkeit der Übertragung über udp erwähnt. <br><br><h3>  Übertragen Sie hardwarecodiertes Video von einer Logitech C920-Kamera über Gstreamer </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ursprünglicher Entwicklerartikel, der diese Methode in Gstreamer unterstützt.</a> <br>  Installieren Sie gstreamer unter Ubuntu 16.04 <br><br><pre> <code class="bash hljs">sudo apt-get install libgstreamer1.0-0 gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav gstreamer1.0-doc gstreamer1.0-tools sudo apt-get install libgstreamer-plugins-base1.0-dev</code> </pre> <br><h4>  Mit der Quelle uvch264src können Sie: </h4><br><ul><li>  Erfassen Sie gleichzeitig einen h264-Hardware-codierten Videostream und einen Crawler-Videostream. </li><li>  Konfigurieren Sie die Hardware-Videokodierung (Bitrate, Keyframes und mehr). </li></ul><br>  Die sekundäre Sucherquelle ist ein interessantes Konzept.  Zusätzlich zum H.264-Hauptstrom erhalten Sie einen Sekundärstrom mit niedriger Auflösung im MJPG- oder YUV-Format.  Ich bin nicht sicher, ob dies eine Funktion der Gstreamer-Kamera, des Treibers oder des Quellblocks ist, aber ich hoffe, dass dies für unsere Beaglebone-Kameras nützlich ist, vorausgesetzt, die Funktion verwendet keinen zu großen Prozessor, um zwischen RAW und JPG zu konvertieren. <br><br>  Das folgende Beispiel zeigt eine Pipeline, die einen hochauflösenden H.264-Stream und einen Sucher-Stream anzeigt: <br><br><pre> <code class="bash hljs">gst-launch-1.0 -v -e uvch264src device=/dev/video0 name=src auto-start=<span class="hljs-literal"><span class="hljs-literal">true</span></span> src.vfsrc ! queue ! video/x-raw,format=YUY2,width=320,height=240,framerate=10/1 ! xvimagesink sync=<span class="hljs-literal"><span class="hljs-literal">false</span></span> src.vidsrc ! queue ! video/x-h264,width=1280,height=720,framerate=30/1 ! h264parse ! avdec_h264 ! xvimagesink sync=<span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br>  Der primäre H.264-Stream wird mit dem Block avdec_h264 dekodiert, auf den über das Paket gst-libav zugegriffen werden kann ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">siehe Hinweise im oz9aec-Wiki)</a> .  Das Sucherfeld kann mit dem Fakelink verbunden werden, wenn es nicht benötigt wird, aber ich glaube nicht, dass es deaktiviert werden kann (Sie können es trotzdem deaktivieren).  Zumindest ist dies der Eindruck, dass ich den originalen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">KaKaRoTo-Blogbeitrag lese</a> . <br><br>  Sie werden wahrscheinlich überlastet sein, wenn Sie eine große Anzahl von Parametern sehen, die für diesen Quellblock konfiguriert werden können: <br><br><pre> <code class="bash hljs">gst-inspect-1.0 uvch264src</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Uvch264src-Parameterliste</b> <div class="spoiler_text">  Fabrikdetails: <br>  Rang keine (0) <br>  Langname UVC H264 Quelle <br>  Klass Quelle / Video <br>  Beschreibung UVC H264 Codierungskameraquelle <br>  Autor Youness Alaoui &lt;youness.alaoui@collabora.co.uk&gt; <br><br>  Plugin Details: <br>  Nennen Sie uvch264 <br>  Beschreibung UVC-konformes Plugin für H264-Codierungskameras <br>  Dateiname /usr/lib/x86_64-linux-gnu/gstreamer-1.0/libgstuvch264.so <br>  Version 1.8.3 <br>  Lizenz LGPL <br>  Quellmodul gst-plugins-bad <br>  Erscheinungsdatum der Quelle 19.08.2016 <br>  Binärpaket GStreamer Bad Plugins (Ubuntu) <br>  Ursprungs-URL <a href="">launchpad.net/distros/ubuntu/+source/gst-plugins-bad1.0</a> <br><br>  GObject <br>  + ---- Ursprünglich nicht bekannt <br>  + ---- GstObject <br>  + ---- GstElement <br>  + ---- GstBin <br>  + ---- GstBaseCameraSrc <br>  + ---- GstUvcH264Src <br><br>  Implementierte Schnittstellen: <br>  Gstchildproxy <br><br>  Pad-Vorlagen: <br>  SRC-Vorlage: 'vidsrc' <br>  Verfügbarkeit: Immer <br>  Fähigkeiten: <br>  Video / X-Raw <br>  Format: {I420, YV12, YUY2, UYVY, AYUV, RGBx, BGRx, xRGB, xBGR, RGBA, BGRA, ARGB, ABGR, RGB, BGR, Y41B, Y42B, YVYU, Y444, v210, v216, NV12, NV21, NV21 , NV61, NV24, GREY8, GREY16_BE, GREY16_LE, v308, RGB16, BGR16, RGB15, BGR15, UYVP, A420, RGB8P, YUV9, YVU9, IYU1, ARGB64, AYUV64, r210, I420_1041010 , GBR, GBR_10LE, GBR_10BE, NV12_64Z32, A420_10LE, A420_10BE, A422_10LE, A422_10BE, A444_10LE, A444_10BE} <br>  Breite: [1, 2147483647] <br>  Höhe: [1, 2147483647] <br>  Framerate: [0/1, 2147483647/1] <br>  Bild / JPEG <br>  Breite: [1, 2147483647] <br>  Höhe: [1, 2147483647] <br>  Framerate: [0/1, 2147483647/1] <br>  Video / x-h264 <br>  Breite: [1, 2147483647] <br>  Höhe: [1, 2147483647] <br>  Framerate: [0/1, 2147483647/1] <br>  Stream-Format: {Byte-Stream, AVC} <br>  Ausrichtung: au <br>  Profil: {hoch, Haupt, Grundlinie, eingeschränkte Grundlinie} <br><br>  SRC-Vorlage: 'imgsrc' <br>  Verfügbarkeit: Immer <br>  Fähigkeiten: <br>  LEER <br><br>  SRC-Vorlage: 'vfsrc' <br>  Verfügbarkeit: Immer <br>  Fähigkeiten: <br>  Video / X-Raw <br>  Format: {I420, YV12, YUY2, UYVY, AYUV, RGBx, BGRx, xRGB, xBGR, RGBA, BGRA, ARGB, ABGR, RGB, BGR, Y41B, Y42B, YVYU, Y444, v210, v216, NV12, NV21, NV21 , NV61, NV24, GREY8, GREY16_BE, GREY16_LE, v308, RGB16, BGR16, RGB15, BGR15, UYVP, A420, RGB8P, YUV9, YVU9, IYU1, ARGB64, AYUV64, r210, I420_1041010 , GBR, GBR_10LE, GBR_10BE, NV12_64Z32, A420_10LE, A420_10BE, A422_10LE, A422_10BE, A444_10LE, A444_10BE} <br>  Breite: [1, 2147483647] <br>  Höhe: [1, 2147483647] <br>  Framerate: [0/1, 2147483647/1] <br>  Bild / JPEG <br>  Breite: [1, 2147483647] <br>  Höhe: [1, 2147483647] <br>  Framerate: [0/1, 2147483647/1] <br><br>  Elementflaggen: <br>  Keine Flags gesetzt <br><br>  Bin Flags: <br>  Keine Flags gesetzt <br><br>  Elementimplementierung: <br>  Hat die Funktion change_state (): 0x7ff438f22ba0 <br><br>  Element verfügt über keine Taktfunktionen. <br>  Element verfügt über keine URI-Verarbeitungsfunktionen. <br><br>  Pads: <br>  Src: 'vfsrc' <br>  Src: 'imgsrc' <br>  SRC: 'vidsrc' <br><br>  Elementeigenschaften: <br>  name: Der Name des Objekts <br>  Flags: lesen, schreiben <br>  String  Standard: "uvch264src0" <br>  parent: Das übergeordnete Objekt des Objekts <br>  Flags: lesen, schreiben <br>  Objekt vom Typ "GstObject" <br>  Async-Behandlung: Der Bin verarbeitet asynchrone Statusänderungen <br>  Flags: lesen, schreiben <br>  Boolescher Wert.  Standard: false <br>  Nachrichtenweiterleitung: Leitet alle untergeordneten Nachrichten weiter <br>  Flags: lesen, schreiben <br>  Boolescher Wert.  Standard: false <br>  Modus: Der Aufnahmemodus (Standbildaufnahme oder Videoaufnahme) <br>  Flags: lesen, schreiben <br>  Enum "GstCameraBin2Mode" Standard: 2, "mode-video" <br>  (1): Modusbild - Standbildaufnahme (Standard) <br>  (2): Modus-Video - Videoaufnahme <br>  Zoom: Digitaler Zoomfaktor (zB 1,5 bedeutet 1,5x) <br>  Flags: lesen, schreiben <br>  Float.  Bereich: 1 - 3.402823e + 38 Standard: 1 <br>  Max-Zoom: Digitaler Zoomfaktor (zB 1,5 bedeutet 1,5x) <br>  Flags: lesbar <br>  Float.  Bereich: 1 - 3.402823e + 38 Standard: 10 <br>  Bereit zur Erfassung: Informiert, dass dieses Element zum Starten einer weiteren Erfassung bereit ist <br>  Flags: lesbar <br>  Boolescher Wert.  Standard: true <br>  Post-Previews: Wenn Vorschaubilder für die Aufnahme in den Bus gestellt werden sollen <br>  Flags: lesen, schreiben <br>  Boolescher Wert.  Standard: true <br>  Vorschau-Caps: Die Caps des Vorschau-Bildes, das veröffentlicht werden soll (NULL bedeutet ANY) <br>  Flags: lesen, schreiben <br>  JEDER <br><br>  Vorschau-Filter: Ein benutzerdefinierter Vorschau-Filter zum Verarbeiten von Vorschaubilddaten <br>  Flags: lesen, schreiben <br>  Objekt vom Typ "GstElement" <br>  Autostart: Startet die Erfassung automatisch, wenn der Status PAUSED aktiviert wird <br>  Flags: lesen, schreiben <br>  Boolescher Wert.  Standard: false <br>  Farbraumname: Der Name des Farbraumelements <br>  Flags: Lesen, Schreiben, kann nur NULL oder BEREIT sein <br>  String  Standard: "Videokonvertierung" <br>  JPEG-Decoder-Name: Der Name des JPEG-Decoder-Elements <br>  Flags: Lesen, Schreiben, kann nur NULL oder BEREIT sein <br>  String  Standard: "jpegdec" <br>  num-clock-samples: Anzahl der für die PTS-Synchronisation zu sammelnden Clock-Samples (-1 = unbegrenzt) <br>  Flags: Lesen, Schreiben, kann NULL, READY, PAUSED oder PLAYING sein <br>  Ganzzahl  Bereich: 0 - 2147483647 Standard: 0 <br>  Anzahl Puffer: Anzahl der Puffer, die vor dem Senden der EOS ausgegeben werden sollen (-1 = unbegrenzt) <br>  Flags: lesen, schreiben <br>  Ganzzahl  Bereich: -1 - 2147483647 Standard: -1 <br>  Gerät: Gerätestandort <br>  Flags: lesen, schreiben <br>  String  Standard: "/ dev / video0" <br>  Gerätename: Name des Geräts <br>  Flags: lesbar <br>  String  Standard: "" <br>  Anfangsbitrate: Anfangsbitrate in Bit / Sekunde (statische Steuerung) <br>  Flags: Lesen, Schreiben, kann nur NULL oder BEREIT sein <br>  Ganzzahl ohne Vorzeichen.  Bereich: 0 - 4294967295 Standard: 3.000.000 <br>  Slice-Einheiten: Slice-Einheiten (statische Kontrolle) <br>  Flags: Lesen, Schreiben, kann nur NULL oder BEREIT sein <br>  Ganzzahl ohne Vorzeichen.  Bereich: 0 - 65535 Standard: 4 <br>  Slice-Modus: Definiert die Einheit der Slice-Units-Eigenschaft (statische Steuerung) <br>  Flags: Lesen, Schreiben, kann nur NULL oder BEREIT sein <br>  Enum "UvcH264SliceMode" Standard: 3, "Slice / Frame" <br>  (0): ignoriert - ignoriert <br>  (1): Bits / Slice - Bits pro Slice <br>  (2): MBs / Slice - MBs pro Slice <br>  (3): Slice / Frame - Slice Per Frame <br>  Iframe-Periode: Zeit zwischen IDR-Frames in Millisekunden (statische Kontrolle) <br>  Flags: Lesen, Schreiben, kann nur NULL oder BEREIT sein <br>  Ganzzahl ohne Vorzeichen.  Bereich: 0 - 65535 Standard: 10000 <br>  Verwendungsart: Die Verwendungsart (statische Kontrolle) <br>  Flags: Lesen, Schreiben, kann nur NULL oder BEREIT sein <br>  Enum "UvcH264UsageType" Standard: 1, "Echtzeit" <br>  (1): Echtzeit - Echtzeit (Videokonferenzen) <br>  (2): Rundfunk - Rundfunk <br>  (3): Lagerung - Lagerung <br>  (4): ucconfig0 - UCConfig 0 <br>  (5): ucconfig1 - UCConfig 1 <br>  (6): ucconfig2q - UCConfig 2Q <br>  (7): ucconfig2s - UCConfig 2S <br>  (8): ucconfig3 - UCConfig 3 <br>  Entropie: Entropie (statische Kontrolle) <br>  Flags: Lesen, Schreiben, kann nur NULL oder BEREIT sein <br>  Enum "UvcH264Entropy" Standard: 0, "cavlc" <br>  (0): cavlc - CAVLC <br>  (1): cabac - CABAC <br>  enable-sei: SEI-Bild-Timing aktivieren (statische Steuerung) <br>  Flags: Lesen, Schreiben, kann nur NULL oder BEREIT sein <br>  Boolescher Wert.  Standard: false <br>  num-reorder-frame: Anzahl der B-Frames zwischen den Referenzframes (statische Kontrolle) <br>  Flags: Lesen, Schreiben, kann nur NULL oder BEREIT sein <br>  Ganzzahl ohne Vorzeichen.  Bereich: 0 - 255 Standard: 0 <br>  Vorschau gespiegelt: Horizontal gespiegeltes Bild für Nicht-H.264-Streams (statische Kontrolle) <br>  Flags: Lesen, Schreiben, kann nur NULL oder BEREIT sein <br>  Boolescher Wert.  Standard: false <br>  Leaky-Bucket-Größe: Größe der Leaky-Bucket-Größe in Millisekunden (statische Kontrolle) <br>  Flags: Lesen, Schreiben, kann nur NULL oder BEREIT sein <br>  Ganzzahl ohne Vorzeichen.  Bereich: 0 - 65535 Standard: 1000 <br>  Ratensteuerung: Ratensteuerungsmodus (statische und dynamische Steuerung) <br>  Flags: Lesen, Schreiben, kann NULL, READY, PAUSED oder PLAYING sein <br>  Enum "UvcH264RateControl" Standard: 1, "cbr" <br>  (1): cbr - Konstante Bitrate <br>  (2): vbr - Variable Bitrate <br>  (3): qp - Konstante QP <br>  Feste Framerate: Feste Framerate (statische und dynamische Steuerung) <br>  Flags: Lesen, Schreiben, kann NULL, READY, PAUSED oder PLAYING sein <br>  Boolescher Wert.  Standard: false <br>  max-mbps: Die Anzahl der Makroblöcke pro Sekunde für die maximale Verarbeitungsrate <br>  Flags: lesbar <br>  Ganzzahl ohne Vorzeichen.  Bereich: 0 - 4294967295 Standard: 0 <br>  level-idc: Level IDC (dynamische Steuerung) <br>  Flags: Lesen, Schreiben, kann NULL, READY, PAUSED oder PLAYING sein <br>  Ganzzahl ohne Vorzeichen.  Bereich: 0 - 255 Standard: 40 <br>  Spitzenbitrate: Die Spitzenbitrate in Bit / Sekunde (dynamische Steuerung) <br>  Flags: Lesen, Schreiben, kann NULL, READY, PAUSED oder PLAYING sein <br>  Ganzzahl ohne Vorzeichen.  Bereich: 0 - 4294967295 Standard: 3.000.000 <br>  durchschnittliche Bitrate: Die durchschnittliche Bitrate in Bit / Sekunde (dynamische Steuerung) <br>  Flags: Lesen, Schreiben, kann NULL, READY, PAUSED oder PLAYING sein <br>  Ganzzahl ohne Vorzeichen.  Bereich: 0 - 4294967295 Standard: 3.000.000 <br>  min-iframe-qp: Die minimale Quantisierungsschrittgröße für I-Frames (dynamische Steuerung) <br>  Flags: Lesen, Schreiben, kann NULL, READY, PAUSED oder PLAYING sein <br>  Ganzzahl  Bereich: -127 - 127 Standard: 10 <br>  max-iframe-qp: Die minimale Quantisierungsschrittgröße für I-Frames (dynamische Steuerung) <br>  Flags: Lesen, Schreiben, kann NULL, READY, PAUSED oder PLAYING sein <br>  Ganzzahl  Bereich: -127 - 127 Standard: 46 <br>  min-pframe-qp: Die minimale Quantisierungsschrittgröße für P-Frames (dynamische Steuerung) <br>  Flags: Lesen, Schreiben, kann NULL, READY, PAUSED oder PLAYING sein <br>  Ganzzahl  Bereich: -127 - 127 Standard: 10 <br>  max-pframe-qp: Die minimale Quantisierungsschrittgröße für P-Frames (dynamische Steuerung) <br>  Flags: Lesen, Schreiben, kann NULL, READY, PAUSED oder PLAYING sein <br>  Ganzzahl  Bereich: -127 - 127 Standard: 46 <br>  min-bframe-qp: Die minimale Quantisierungsschrittgröße für B-Frames (dynamische Steuerung) <br>  Flags: Lesen, Schreiben, kann NULL, READY, PAUSED oder PLAYING sein <br>  Ganzzahl  Bereich: -127 - 127 Standard: 10 <br>  max-bframe-qp: Die minimale Quantisierungsschrittgröße für B-Frames (dynamische Steuerung) <br>  Flags: Lesen, Schreiben, kann NULL, READY, PAUSED oder PLAYING sein <br>  Ganzzahl  Bereich: -127 - 127 Standard: 46 <br>  ltr-buffer-size: Gesamtzahl der Langzeitreferenzrahmen (dynamische Steuerung) <br>  Flags: Lesen, Schreiben, kann NULL, READY, PAUSED oder PLAYING sein <br>  Ganzzahl  Bereich: 0 - 255 Standard: 0 <br>  ltr-Encoder-Steuerung: Anzahl der LTR-Frames, die das Gerät steuern kann (dynamische Steuerung) <br>  Flags: Lesen, Schreiben, kann NULL, READY, PAUSED oder PLAYING sein <br>  Ganzzahl  Bereich: 0 - 255 Standard: 0 <br><br>  Elementaktionen: <br>  "Get-enum-settings": gboolean user_function (GstElement * -Objekt, <br>  gchararray arg0, <br>  gpointer arg1, <br>  gpointer arg2); <br>  "Get-Boolean-Einstellung": gboolean user_function (GstElement * -Objekt, <br>  gchararray arg0, <br>  gpointer arg1, <br>  gpointer arg2); <br>  "Get-int-settings": gboolean user_function (GstElement * -Objekt, <br>  gchararray arg0, <br>  gpointer arg1, <br>  gpointer arg2, <br>  gpointer arg3); <br>  "Start-Capture": void user_function (GstElement * -Objekt); <br>  "Stop-Capture": void user_function (GstElement * -Objekt); <br></div></div><br>  Viele dieser Parameter können zum Konfigurieren von Parametern bei der H.264-Komprimierung verwendet werden.  Ich finde das ziemlich überraschend, da die Komprimierung durch den Chip in der Kamera erfolgt.  Im folgenden Beispiel wird die Standarddatenrate von 3 auf 5 Mbit / s erhöht und das Standard-Keyframe-Intervall von 10 auf 3 Sekunden verringert: <br><br><pre> <code class="bash hljs">gst-launch-1.0 -v -e uvch264src initial-bitrate=5000000 average-bitrate=5000000 iframe-period=3000 device=/dev/video0 name=src auto-start=<span class="hljs-literal"><span class="hljs-literal">true</span></span> src.vfsrc ! queue ! video/x-raw,format=YUY2,width=320,height=240,framerate=10/1 ! xvimagesink sync=<span class="hljs-literal"><span class="hljs-literal">false</span></span> src.vidsrc ! queue ! video/x-h264,width=1280,height=720,framerate=30/1 ! h264parse ! avdec_h264 ! xvimagesink sync=<span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br>  Andererseits gibt es keine Parameter zum Anpassen der üblichen Parameter der Webcam, wie z. B. Kontrast, Helligkeit, Fokus usw. Um sie zu konfigurieren, benötigen wir daher noch externe Tools wie v4l2.ctl oder die in nächster Abschnitt. <br><br><h4>  v4l2src </h4><br>  Es sieht so aus, als könnten wir auch das gute alte v4l2src verwenden, um H.264-codierte Streams vom Logitech C920 zu erfassen: <br><br><pre> <code class="bash hljs">gst-launch-1.0 -v -e v4l2src device=/dev/video1 ! queue ! video/x-h264,width=1280,height=720,framerate=30/1 ! h264parse ! avdec_h264 ! xvimagesink sync=<span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br>  Dies ist wahrscheinlich auf die Entwicklung von gstreamer und V4L2 zurückzuführen.  Diese Option sieht einfacher aus, wenn Sie die H.264-Komprimierungseinstellungen nicht ändern müssen. Dadurch erhalten wir Zugriff auf Kameraeinstellungen wie Helligkeit und Kontrast.  Es hat auch den Vorteil, dass es sich in einem guten Plugin-Paket befindet, das in Zukunft möglicherweise besser aufbewahrt wird. <br><br><h4>  Webcasting über Gstreamer </h4><br>  Starten Sie auf dem empfangenden Computer den Empfänger: <br><br><pre> <code class="bash hljs">gst-launch-1.0 -v udpsrc port=6666 ! application/x-rtp, encoding-name=H264 ! rtph264depay ! h264parse ! avdec_h264 ! videoconvert ! autovideosink</code> </pre> <br>  Auf einem Gerät mit einer Kamera starten wir die Übertragung von hardwarecodiertem Video: <br><br><pre> <code class="bash hljs">gst-launch-1.0 uvch264src name=src auto-start=<span class="hljs-literal"><span class="hljs-literal">true</span></span> src.vidsrc ! video/x-h264,width=160,height=120,framerate=30/1 ! h264parse ! rtph264pay ! udpsink host=192.168.1.196 port=6666</code> </pre> <br>  Besonderer Dank geht an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Amomum, die</a> mir beim Schreiben dieses Codes geholfen hat. <br><br><h4>  Zusammenfassung der Verzögerung der Videoübertragung über Gstreamer </h4><br>  Selbst mit einer Auflösung von 1920 * 1080 überschritt die Prozessorlast von Beaglebone Blue 30% nicht und die Videoverzögerung betrug nicht mehr als 0,3 Sekunden.  Ja, da das Video in dieser Version über udp gesendet wurde, fällt das Bild bei Verlust von Paketen zum nächsten Schlüsselbild auseinander, aber wir können es so konfigurieren, dass Schlüsselbilder häufiger gesendet werden. <br><br><h3>  ROS-Aufgaben </h3><br>  Es bleibt nur noch, das empfangene Video in ROS zu pushen, wenn jemand dabei helfen kann, schreiben Sie in einem persönlichen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415567/">https://habr.com/ru/post/de415567/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415557/index.html">Codec 2 + neuronales Netzwerk = ganzer Podcast auf einer Diskette</a></li>
<li><a href="../de415559/index.html">Die Geschichte der Entwicklung von Call Centern oder wie Technologien die Arbeit der Betreiber mit Kunden verändert haben</a></li>
<li><a href="../de415561/index.html">So übertragen Sie Ereignisse von Veeam Backup & Replication in Instant Messenger</a></li>
<li><a href="../de415563/index.html">Die Behandlung von "mechanischem" Scrum. Teil 2. Team</a></li>
<li><a href="../de415565/index.html">Warum (heute) 444 zurückgibt, ist nicht immer sinnvoll</a></li>
<li><a href="../de415569/index.html">HOWTO Setup Ubuntu 18.04 Sendmail + DKIM + SPF + DMARC oder wie ich es geschafft habe, in die Google Mail-Bastion zu gelangen</a></li>
<li><a href="../de415571/index.html">kaggle: IEEE-Kameramodellidentifikation</a></li>
<li><a href="../de415573/index.html">Optimierung eines Modells für den 3D-Druck am Beispiel der Blender-Software</a></li>
<li><a href="../de415575/index.html">Funktionen zum Dokumentieren von PostgreSQL-Datenbanken. Teil eins</a></li>
<li><a href="../de415577/index.html">Folien des Kurses "DBMS Technologies and Development"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>