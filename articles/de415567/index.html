<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüíª üèçÔ∏è üë©üèø‚Äçü§ù‚Äçüë©üèæ Senden Sie h264-Videos ohne Transcodierung von einer Logitech C920-Kamera üó°Ô∏è üëáüèΩ üßìüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Verz√∂gerung betrug nicht mehr als 0,3 Sekunden, da die Kamera an ein schwaches BeagleBone Blue mit einer Prozessorlast von nicht mehr als 30% ange...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Senden Sie h264-Videos ohne Transcodierung von einer Logitech C920-Kamera</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415567/"><img src="https://habrastorage.org/webt/dc/by/xs/dcbyxsicqllz2-jksmikcesodlu.jpeg"><br><br>  Die Verz√∂gerung betrug nicht mehr als 0,3 Sekunden, da die Kamera an ein schwaches BeagleBone Blue mit einer Prozessorlast von nicht mehr als 30% angeschlossen ist und der Videostream √ºber einen WLAN-Router an einen Laptop √ºbertragen wird. <br><a name="habracut"></a><br>  Zun√§chst bestand die Aufgabe darin, Videos vom Roboter an einen gro√üen Computer zu senden, ohne den Prozessor auf den Roboter zu laden und ohne Verz√∂gerungen.  Beim Googeln von Kameras und Programmen f√ºr diese Aufgabe wurde festgestellt, dass sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kameras mit hardwarebasierter Videokodierung auf der Kamera selbst befinden.</a> Danach wurde die Logitech C920-Kamera gekauft.  Und es begannen Tests und Experimente, bei denen zwei √úbersetzungsoptionen ohne Transcodierung gefunden wurden. <br><br>  Alle weiteren Aktionen werden unter Ubuntu 16.04 √ºberpr√ºft, die zweite Option funktioniert wahrscheinlich unter Windows <br><br><h3>  √úbertragen Sie hardwarecodiertes Video von einer Logitech C920-Kamera √ºber cvlc und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">v4l2</a> </h3><br>  clvc - Server sendet Video √ºber vlc √ºber die Befehlszeile. <br><br><h4>  Hardware, die einen Videostream codiert </h4><br>  Stellen Sie die Pixelformatkameras auf H264 ein <br><br><pre><code class="bash hljs">v4l2-ctl --device=/dev/video1 --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-fmt-video=width=800,height=600,pixelformat=1</code> </pre> <br>  Testen Sie H264 mit vlc, damit die Einstellungen nicht zur√ºckgesetzt werden: <br><br><pre> <code class="bash hljs">cvlc v4l2:///dev/video1 --demux h264</code> </pre> <br>  Wenn Sie dies versuchen, setzt vlc die Einstellungen vor dem Spielen zur√ºck: <br><br><pre> <code class="bash hljs">cvlc v4l2:///dev/video1:chroma=h264</code> </pre> <br>  Die Wiedergabe funktioniert.  Wir bekommen den H264-Stream von der Kamera.  Lassen Sie uns nun √ºber HTTP √ºber das Netzwerk gehen: <br><br><pre> <code class="bash hljs">cvlc v4l2:///dev/video1:chroma=h264:width=800:height=600 --sout <span class="hljs-string"><span class="hljs-string">'#standard{access=http,mux=ts,dst=localhost:8080,name=stream,mime=video/ts}'</span></span> -vvv</code> </pre> <br>  (Im Netzwerk m√ºssen Sie anstelle von localhost die IP-Adresse Ihres lokalen Ger√§ts verwenden.) <br><br>  Empf√§ngerstart: <br><br><pre> <code class="bash hljs">mplayer http://localhost:8080/</code> </pre> <br>  Es stellt sich heraus, dass MPEG-TS es mplayer erm√∂glicht, jederzeit mit einer leichten Verz√∂gerung eine Verbindung zum Stream herzustellen (wahrscheinlich auf einen Keyframe oder etw warten). <br><br>  Wenn Sie mux = avi, mime = video / avi verwenden, m√ºssen Sie mplayer ausf√ºhren, sobald Sie vlc starten. Andernfalls wird mplayer nicht abgespielt. <br><br><h4>  Ffmpeg-Fehler </h4><br><ul><li>  Wenn Sie versuchen, ffmpeg anstelle von vlc zu spielen, werden Sie wahrscheinlich auf dieses Problem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sto√üen</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ffmpeg.org/trac/ffmpeg/ticket/1387</a> </li><li>  Sobald Sie ffmpeg ausf√ºhren, wird zu "Video: rawvideo (YUY2 / 0x32595559)" gewechselt. </li><li>  W√§hrend es MJPEG akzeptiert, funktioniert es nicht mit H.264 </li><li>  Dasselbe passiert bei Verwendung von qv4l2: Wenn Sie die Aufnahme im H264-Modus starten, erhalten Sie tats√§chlich das YUY2-Videofenster </li></ul><br><h4>  Hardware-decodiertes Video abspielen </h4><br>  Mplayer kann Framebuffer spielen, stellen Sie sicher, dass X nicht funktioniert, und geben Sie Folgendes ein: <br><br><pre> <code class="bash hljs">mplayer http://192.168.1.100:8080/ -fs -framedrop -vo fbdev</code> </pre> <br>  Sie k√∂nnen auch im X-Fenster spielen, wenn Sie m√∂chten: F√ºhren Sie X √ºber die Befehlszeile aus: <br><br><pre> <code class="bash hljs">Xorg -retro &amp;&gt; /dev/zero</code> </pre> <br>  Es gibt Unmengen von fbdev-Fehlermeldungen, die wir stillschweigend in / dev / zero ablegen <br><br>  Spielen Sie einen Videostream von einer LAN-VLC-Quelle ab (siehe Abschnitt oben): <br><br><pre> <code class="bash hljs">DISPLAY=<span class="hljs-string"><span class="hljs-string">":0"</span></span> mplayer http://192.168.1.100:8080/ -fs -framedrop</code> </pre> <br><ul><li>  Wenn wir dies tun, werden wir feststellen, dass wir noch kein Xvideo oder eine Hardwarebeschleunigung verwenden </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">linux-sunxi.org/CedarX</a> scheint uns eine VPU-Bibliothek zur Verf√ºgung zu stellen, was leider eine unsichere Sache von Allwinner ist </li><li>  Aber es gibt einen gehackten VLC, der es verwenden kann: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">linux-sunxi.org/VLC</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erfolgreich kompiliert</a> </li></ul><br><h4>  Himbeer pi </h4><br>  Falls Sie Artefakte im Bild und Streams von Raspberry Pi bemerken, verwenden Sie: <br><br><pre> <code class="bash hljs">cvlc v4l2:///dev/video0:chroma=h264 ...</code> </pre> <br>  M√∂glicherweise m√ºssen Sie die Firmware aktualisieren: <br><br><pre> <code class="bash hljs">apt-get install rpi-update raspi-config rpi-update reboot</code> </pre> <br><h4>  Broadcast-Zusammenfassung √ºber cvlc und v4l2 </h4><br>  Tests haben gezeigt, dass die Prozessorlast auf Beaglebone Blue nicht mehr als 30% betr√§gt, was f√ºr einen schwachen Prozessor sehr gut ist, aber es ist nicht klar, wie dieses Video dann in ROS verschoben werden soll. <br><br>  Wenn die WLAN-Bandbreite nicht ausreicht, steigt die Videoverz√∂gerung stark an. Theoretisch kann dies durch Umschalten von tcp auf udp gel√∂st werden. In der cvlc-Dokumentation wird die M√∂glichkeit der √úbertragung √ºber udp erw√§hnt. <br><br><h3>  √úbertragen Sie hardwarecodiertes Video von einer Logitech C920-Kamera √ºber Gstreamer </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Urspr√ºnglicher Entwicklerartikel, der diese Methode in Gstreamer unterst√ºtzt.</a> <br>  Installieren Sie gstreamer unter Ubuntu 16.04 <br><br><pre> <code class="bash hljs">sudo apt-get install libgstreamer1.0-0 gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav gstreamer1.0-doc gstreamer1.0-tools sudo apt-get install libgstreamer-plugins-base1.0-dev</code> </pre> <br><h4>  Mit der Quelle uvch264src k√∂nnen Sie: </h4><br><ul><li>  Erfassen Sie gleichzeitig einen h264-Hardware-codierten Videostream und einen Crawler-Videostream. </li><li>  Konfigurieren Sie die Hardware-Videokodierung (Bitrate, Keyframes und mehr). </li></ul><br>  Die sekund√§re Sucherquelle ist ein interessantes Konzept.  Zus√§tzlich zum H.264-Hauptstrom erhalten Sie einen Sekund√§rstrom mit niedriger Aufl√∂sung im MJPG- oder YUV-Format.  Ich bin nicht sicher, ob dies eine Funktion der Gstreamer-Kamera, des Treibers oder des Quellblocks ist, aber ich hoffe, dass dies f√ºr unsere Beaglebone-Kameras n√ºtzlich ist, vorausgesetzt, die Funktion verwendet keinen zu gro√üen Prozessor, um zwischen RAW und JPG zu konvertieren. <br><br>  Das folgende Beispiel zeigt eine Pipeline, die einen hochaufl√∂senden H.264-Stream und einen Sucher-Stream anzeigt: <br><br><pre> <code class="bash hljs">gst-launch-1.0 -v -e uvch264src device=/dev/video0 name=src auto-start=<span class="hljs-literal"><span class="hljs-literal">true</span></span> src.vfsrc ! queue ! video/x-raw,format=YUY2,width=320,height=240,framerate=10/1 ! xvimagesink sync=<span class="hljs-literal"><span class="hljs-literal">false</span></span> src.vidsrc ! queue ! video/x-h264,width=1280,height=720,framerate=30/1 ! h264parse ! avdec_h264 ! xvimagesink sync=<span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br>  Der prim√§re H.264-Stream wird mit dem Block avdec_h264 dekodiert, auf den √ºber das Paket gst-libav zugegriffen werden kann ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">siehe Hinweise im oz9aec-Wiki)</a> .  Das Sucherfeld kann mit dem Fakelink verbunden werden, wenn es nicht ben√∂tigt wird, aber ich glaube nicht, dass es deaktiviert werden kann (Sie k√∂nnen es trotzdem deaktivieren).  Zumindest ist dies der Eindruck, dass ich den originalen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">KaKaRoTo-Blogbeitrag lese</a> . <br><br>  Sie werden wahrscheinlich √ºberlastet sein, wenn Sie eine gro√üe Anzahl von Parametern sehen, die f√ºr diesen Quellblock konfiguriert werden k√∂nnen: <br><br><pre> <code class="bash hljs">gst-inspect-1.0 uvch264src</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Uvch264src-Parameterliste</b> <div class="spoiler_text">  Fabrikdetails: <br>  Rang keine (0) <br>  Langname UVC H264 Quelle <br>  Klass Quelle / Video <br>  Beschreibung UVC H264 Codierungskameraquelle <br>  Autor Youness Alaoui &lt;youness.alaoui@collabora.co.uk&gt; <br><br>  Plugin Details: <br>  Nennen Sie uvch264 <br>  Beschreibung UVC-konformes Plugin f√ºr H264-Codierungskameras <br>  Dateiname /usr/lib/x86_64-linux-gnu/gstreamer-1.0/libgstuvch264.so <br>  Version 1.8.3 <br>  Lizenz LGPL <br>  Quellmodul gst-plugins-bad <br>  Erscheinungsdatum der Quelle 19.08.2016 <br>  Bin√§rpaket GStreamer Bad Plugins (Ubuntu) <br>  Ursprungs-URL <a href="">launchpad.net/distros/ubuntu/+source/gst-plugins-bad1.0</a> <br><br>  GObject <br>  + ---- Urspr√ºnglich nicht bekannt <br>  + ---- GstObject <br>  + ---- GstElement <br>  + ---- GstBin <br>  + ---- GstBaseCameraSrc <br>  + ---- GstUvcH264Src <br><br>  Implementierte Schnittstellen: <br>  Gstchildproxy <br><br>  Pad-Vorlagen: <br>  SRC-Vorlage: 'vidsrc' <br>  Verf√ºgbarkeit: Immer <br>  F√§higkeiten: <br>  Video / X-Raw <br>  Format: {I420, YV12, YUY2, UYVY, AYUV, RGBx, BGRx, xRGB, xBGR, RGBA, BGRA, ARGB, ABGR, RGB, BGR, Y41B, Y42B, YVYU, Y444, v210, v216, NV12, NV21, NV21 , NV61, NV24, GREY8, GREY16_BE, GREY16_LE, v308, RGB16, BGR16, RGB15, BGR15, UYVP, A420, RGB8P, YUV9, YVU9, IYU1, ARGB64, AYUV64, r210, I420_1041010 , GBR, GBR_10LE, GBR_10BE, NV12_64Z32, A420_10LE, A420_10BE, A422_10LE, A422_10BE, A444_10LE, A444_10BE} <br>  Breite: [1, 2147483647] <br>  H√∂he: [1, 2147483647] <br>  Framerate: [0/1, 2147483647/1] <br>  Bild / JPEG <br>  Breite: [1, 2147483647] <br>  H√∂he: [1, 2147483647] <br>  Framerate: [0/1, 2147483647/1] <br>  Video / x-h264 <br>  Breite: [1, 2147483647] <br>  H√∂he: [1, 2147483647] <br>  Framerate: [0/1, 2147483647/1] <br>  Stream-Format: {Byte-Stream, AVC} <br>  Ausrichtung: au <br>  Profil: {hoch, Haupt, Grundlinie, eingeschr√§nkte Grundlinie} <br><br>  SRC-Vorlage: 'imgsrc' <br>  Verf√ºgbarkeit: Immer <br>  F√§higkeiten: <br>  LEER <br><br>  SRC-Vorlage: 'vfsrc' <br>  Verf√ºgbarkeit: Immer <br>  F√§higkeiten: <br>  Video / X-Raw <br>  Format: {I420, YV12, YUY2, UYVY, AYUV, RGBx, BGRx, xRGB, xBGR, RGBA, BGRA, ARGB, ABGR, RGB, BGR, Y41B, Y42B, YVYU, Y444, v210, v216, NV12, NV21, NV21 , NV61, NV24, GREY8, GREY16_BE, GREY16_LE, v308, RGB16, BGR16, RGB15, BGR15, UYVP, A420, RGB8P, YUV9, YVU9, IYU1, ARGB64, AYUV64, r210, I420_1041010 , GBR, GBR_10LE, GBR_10BE, NV12_64Z32, A420_10LE, A420_10BE, A422_10LE, A422_10BE, A444_10LE, A444_10BE} <br>  Breite: [1, 2147483647] <br>  H√∂he: [1, 2147483647] <br>  Framerate: [0/1, 2147483647/1] <br>  Bild / JPEG <br>  Breite: [1, 2147483647] <br>  H√∂he: [1, 2147483647] <br>  Framerate: [0/1, 2147483647/1] <br><br>  Elementflaggen: <br>  Keine Flags gesetzt <br><br>  Bin Flags: <br>  Keine Flags gesetzt <br><br>  Elementimplementierung: <br>  Hat die Funktion change_state (): 0x7ff438f22ba0 <br><br>  Element verf√ºgt √ºber keine Taktfunktionen. <br>  Element verf√ºgt √ºber keine URI-Verarbeitungsfunktionen. <br><br>  Pads: <br>  Src: 'vfsrc' <br>  Src: 'imgsrc' <br>  SRC: 'vidsrc' <br><br>  Elementeigenschaften: <br>  name: Der Name des Objekts <br>  Flags: lesen, schreiben <br>  String  Standard: "uvch264src0" <br>  parent: Das √ºbergeordnete Objekt des Objekts <br>  Flags: lesen, schreiben <br>  Objekt vom Typ "GstObject" <br>  Async-Behandlung: Der Bin verarbeitet asynchrone Status√§nderungen <br>  Flags: lesen, schreiben <br>  Boolescher Wert.  Standard: false <br>  Nachrichtenweiterleitung: Leitet alle untergeordneten Nachrichten weiter <br>  Flags: lesen, schreiben <br>  Boolescher Wert.  Standard: false <br>  Modus: Der Aufnahmemodus (Standbildaufnahme oder Videoaufnahme) <br>  Flags: lesen, schreiben <br>  Enum "GstCameraBin2Mode" Standard: 2, "mode-video" <br>  (1): Modusbild - Standbildaufnahme (Standard) <br>  (2): Modus-Video - Videoaufnahme <br>  Zoom: Digitaler Zoomfaktor (zB 1,5 bedeutet 1,5x) <br>  Flags: lesen, schreiben <br>  Float.  Bereich: 1 - 3.402823e + 38 Standard: 1 <br>  Max-Zoom: Digitaler Zoomfaktor (zB 1,5 bedeutet 1,5x) <br>  Flags: lesbar <br>  Float.  Bereich: 1 - 3.402823e + 38 Standard: 10 <br>  Bereit zur Erfassung: Informiert, dass dieses Element zum Starten einer weiteren Erfassung bereit ist <br>  Flags: lesbar <br>  Boolescher Wert.  Standard: true <br>  Post-Previews: Wenn Vorschaubilder f√ºr die Aufnahme in den Bus gestellt werden sollen <br>  Flags: lesen, schreiben <br>  Boolescher Wert.  Standard: true <br>  Vorschau-Caps: Die Caps des Vorschau-Bildes, das ver√∂ffentlicht werden soll (NULL bedeutet ANY) <br>  Flags: lesen, schreiben <br>  JEDER <br><br>  Vorschau-Filter: Ein benutzerdefinierter Vorschau-Filter zum Verarbeiten von Vorschaubilddaten <br>  Flags: lesen, schreiben <br>  Objekt vom Typ "GstElement" <br>  Autostart: Startet die Erfassung automatisch, wenn der Status PAUSED aktiviert wird <br>  Flags: lesen, schreiben <br>  Boolescher Wert.  Standard: false <br>  Farbraumname: Der Name des Farbraumelements <br>  Flags: Lesen, Schreiben, kann nur NULL oder BEREIT sein <br>  String  Standard: "Videokonvertierung" <br>  JPEG-Decoder-Name: Der Name des JPEG-Decoder-Elements <br>  Flags: Lesen, Schreiben, kann nur NULL oder BEREIT sein <br>  String  Standard: "jpegdec" <br>  num-clock-samples: Anzahl der f√ºr die PTS-Synchronisation zu sammelnden Clock-Samples (-1 = unbegrenzt) <br>  Flags: Lesen, Schreiben, kann NULL, READY, PAUSED oder PLAYING sein <br>  Ganzzahl  Bereich: 0 - 2147483647 Standard: 0 <br>  Anzahl Puffer: Anzahl der Puffer, die vor dem Senden der EOS ausgegeben werden sollen (-1 = unbegrenzt) <br>  Flags: lesen, schreiben <br>  Ganzzahl  Bereich: -1 - 2147483647 Standard: -1 <br>  Ger√§t: Ger√§testandort <br>  Flags: lesen, schreiben <br>  String  Standard: "/ dev / video0" <br>  Ger√§tename: Name des Ger√§ts <br>  Flags: lesbar <br>  String  Standard: "" <br>  Anfangsbitrate: Anfangsbitrate in Bit / Sekunde (statische Steuerung) <br>  Flags: Lesen, Schreiben, kann nur NULL oder BEREIT sein <br>  Ganzzahl ohne Vorzeichen.  Bereich: 0 - 4294967295 Standard: 3.000.000 <br>  Slice-Einheiten: Slice-Einheiten (statische Kontrolle) <br>  Flags: Lesen, Schreiben, kann nur NULL oder BEREIT sein <br>  Ganzzahl ohne Vorzeichen.  Bereich: 0 - 65535 Standard: 4 <br>  Slice-Modus: Definiert die Einheit der Slice-Units-Eigenschaft (statische Steuerung) <br>  Flags: Lesen, Schreiben, kann nur NULL oder BEREIT sein <br>  Enum "UvcH264SliceMode" Standard: 3, "Slice / Frame" <br>  (0): ignoriert - ignoriert <br>  (1): Bits / Slice - Bits pro Slice <br>  (2): MBs / Slice - MBs pro Slice <br>  (3): Slice / Frame - Slice Per Frame <br>  Iframe-Periode: Zeit zwischen IDR-Frames in Millisekunden (statische Kontrolle) <br>  Flags: Lesen, Schreiben, kann nur NULL oder BEREIT sein <br>  Ganzzahl ohne Vorzeichen.  Bereich: 0 - 65535 Standard: 10000 <br>  Verwendungsart: Die Verwendungsart (statische Kontrolle) <br>  Flags: Lesen, Schreiben, kann nur NULL oder BEREIT sein <br>  Enum "UvcH264UsageType" Standard: 1, "Echtzeit" <br>  (1): Echtzeit - Echtzeit (Videokonferenzen) <br>  (2): Rundfunk - Rundfunk <br>  (3): Lagerung - Lagerung <br>  (4): ucconfig0 - UCConfig 0 <br>  (5): ucconfig1 - UCConfig 1 <br>  (6): ucconfig2q - UCConfig 2Q <br>  (7): ucconfig2s - UCConfig 2S <br>  (8): ucconfig3 - UCConfig 3 <br>  Entropie: Entropie (statische Kontrolle) <br>  Flags: Lesen, Schreiben, kann nur NULL oder BEREIT sein <br>  Enum "UvcH264Entropy" Standard: 0, "cavlc" <br>  (0): cavlc - CAVLC <br>  (1): cabac - CABAC <br>  enable-sei: SEI-Bild-Timing aktivieren (statische Steuerung) <br>  Flags: Lesen, Schreiben, kann nur NULL oder BEREIT sein <br>  Boolescher Wert.  Standard: false <br>  num-reorder-frame: Anzahl der B-Frames zwischen den Referenzframes (statische Kontrolle) <br>  Flags: Lesen, Schreiben, kann nur NULL oder BEREIT sein <br>  Ganzzahl ohne Vorzeichen.  Bereich: 0 - 255 Standard: 0 <br>  Vorschau gespiegelt: Horizontal gespiegeltes Bild f√ºr Nicht-H.264-Streams (statische Kontrolle) <br>  Flags: Lesen, Schreiben, kann nur NULL oder BEREIT sein <br>  Boolescher Wert.  Standard: false <br>  Leaky-Bucket-Gr√∂√üe: Gr√∂√üe der Leaky-Bucket-Gr√∂√üe in Millisekunden (statische Kontrolle) <br>  Flags: Lesen, Schreiben, kann nur NULL oder BEREIT sein <br>  Ganzzahl ohne Vorzeichen.  Bereich: 0 - 65535 Standard: 1000 <br>  Ratensteuerung: Ratensteuerungsmodus (statische und dynamische Steuerung) <br>  Flags: Lesen, Schreiben, kann NULL, READY, PAUSED oder PLAYING sein <br>  Enum "UvcH264RateControl" Standard: 1, "cbr" <br>  (1): cbr - Konstante Bitrate <br>  (2): vbr - Variable Bitrate <br>  (3): qp - Konstante QP <br>  Feste Framerate: Feste Framerate (statische und dynamische Steuerung) <br>  Flags: Lesen, Schreiben, kann NULL, READY, PAUSED oder PLAYING sein <br>  Boolescher Wert.  Standard: false <br>  max-mbps: Die Anzahl der Makrobl√∂cke pro Sekunde f√ºr die maximale Verarbeitungsrate <br>  Flags: lesbar <br>  Ganzzahl ohne Vorzeichen.  Bereich: 0 - 4294967295 Standard: 0 <br>  level-idc: Level IDC (dynamische Steuerung) <br>  Flags: Lesen, Schreiben, kann NULL, READY, PAUSED oder PLAYING sein <br>  Ganzzahl ohne Vorzeichen.  Bereich: 0 - 255 Standard: 40 <br>  Spitzenbitrate: Die Spitzenbitrate in Bit / Sekunde (dynamische Steuerung) <br>  Flags: Lesen, Schreiben, kann NULL, READY, PAUSED oder PLAYING sein <br>  Ganzzahl ohne Vorzeichen.  Bereich: 0 - 4294967295 Standard: 3.000.000 <br>  durchschnittliche Bitrate: Die durchschnittliche Bitrate in Bit / Sekunde (dynamische Steuerung) <br>  Flags: Lesen, Schreiben, kann NULL, READY, PAUSED oder PLAYING sein <br>  Ganzzahl ohne Vorzeichen.  Bereich: 0 - 4294967295 Standard: 3.000.000 <br>  min-iframe-qp: Die minimale Quantisierungsschrittgr√∂√üe f√ºr I-Frames (dynamische Steuerung) <br>  Flags: Lesen, Schreiben, kann NULL, READY, PAUSED oder PLAYING sein <br>  Ganzzahl  Bereich: -127 - 127 Standard: 10 <br>  max-iframe-qp: Die minimale Quantisierungsschrittgr√∂√üe f√ºr I-Frames (dynamische Steuerung) <br>  Flags: Lesen, Schreiben, kann NULL, READY, PAUSED oder PLAYING sein <br>  Ganzzahl  Bereich: -127 - 127 Standard: 46 <br>  min-pframe-qp: Die minimale Quantisierungsschrittgr√∂√üe f√ºr P-Frames (dynamische Steuerung) <br>  Flags: Lesen, Schreiben, kann NULL, READY, PAUSED oder PLAYING sein <br>  Ganzzahl  Bereich: -127 - 127 Standard: 10 <br>  max-pframe-qp: Die minimale Quantisierungsschrittgr√∂√üe f√ºr P-Frames (dynamische Steuerung) <br>  Flags: Lesen, Schreiben, kann NULL, READY, PAUSED oder PLAYING sein <br>  Ganzzahl  Bereich: -127 - 127 Standard: 46 <br>  min-bframe-qp: Die minimale Quantisierungsschrittgr√∂√üe f√ºr B-Frames (dynamische Steuerung) <br>  Flags: Lesen, Schreiben, kann NULL, READY, PAUSED oder PLAYING sein <br>  Ganzzahl  Bereich: -127 - 127 Standard: 10 <br>  max-bframe-qp: Die minimale Quantisierungsschrittgr√∂√üe f√ºr B-Frames (dynamische Steuerung) <br>  Flags: Lesen, Schreiben, kann NULL, READY, PAUSED oder PLAYING sein <br>  Ganzzahl  Bereich: -127 - 127 Standard: 46 <br>  ltr-buffer-size: Gesamtzahl der Langzeitreferenzrahmen (dynamische Steuerung) <br>  Flags: Lesen, Schreiben, kann NULL, READY, PAUSED oder PLAYING sein <br>  Ganzzahl  Bereich: 0 - 255 Standard: 0 <br>  ltr-Encoder-Steuerung: Anzahl der LTR-Frames, die das Ger√§t steuern kann (dynamische Steuerung) <br>  Flags: Lesen, Schreiben, kann NULL, READY, PAUSED oder PLAYING sein <br>  Ganzzahl  Bereich: 0 - 255 Standard: 0 <br><br>  Elementaktionen: <br>  "Get-enum-settings": gboolean user_function (GstElement * -Objekt, <br>  gchararray arg0, <br>  gpointer arg1, <br>  gpointer arg2); <br>  "Get-Boolean-Einstellung": gboolean user_function (GstElement * -Objekt, <br>  gchararray arg0, <br>  gpointer arg1, <br>  gpointer arg2); <br>  "Get-int-settings": gboolean user_function (GstElement * -Objekt, <br>  gchararray arg0, <br>  gpointer arg1, <br>  gpointer arg2, <br>  gpointer arg3); <br>  "Start-Capture": void user_function (GstElement * -Objekt); <br>  "Stop-Capture": void user_function (GstElement * -Objekt); <br></div></div><br>  Viele dieser Parameter k√∂nnen zum Konfigurieren von Parametern bei der H.264-Komprimierung verwendet werden.  Ich finde das ziemlich √ºberraschend, da die Komprimierung durch den Chip in der Kamera erfolgt.  Im folgenden Beispiel wird die Standarddatenrate von 3 auf 5 Mbit / s erh√∂ht und das Standard-Keyframe-Intervall von 10 auf 3 Sekunden verringert: <br><br><pre> <code class="bash hljs">gst-launch-1.0 -v -e uvch264src initial-bitrate=5000000 average-bitrate=5000000 iframe-period=3000 device=/dev/video0 name=src auto-start=<span class="hljs-literal"><span class="hljs-literal">true</span></span> src.vfsrc ! queue ! video/x-raw,format=YUY2,width=320,height=240,framerate=10/1 ! xvimagesink sync=<span class="hljs-literal"><span class="hljs-literal">false</span></span> src.vidsrc ! queue ! video/x-h264,width=1280,height=720,framerate=30/1 ! h264parse ! avdec_h264 ! xvimagesink sync=<span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br>  Andererseits gibt es keine Parameter zum Anpassen der √ºblichen Parameter der Webcam, wie z. B. Kontrast, Helligkeit, Fokus usw. Um sie zu konfigurieren, ben√∂tigen wir daher noch externe Tools wie v4l2.ctl oder die in n√§chster Abschnitt. <br><br><h4>  v4l2src </h4><br>  Es sieht so aus, als k√∂nnten wir auch das gute alte v4l2src verwenden, um H.264-codierte Streams vom Logitech C920 zu erfassen: <br><br><pre> <code class="bash hljs">gst-launch-1.0 -v -e v4l2src device=/dev/video1 ! queue ! video/x-h264,width=1280,height=720,framerate=30/1 ! h264parse ! avdec_h264 ! xvimagesink sync=<span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br>  Dies ist wahrscheinlich auf die Entwicklung von gstreamer und V4L2 zur√ºckzuf√ºhren.  Diese Option sieht einfacher aus, wenn Sie die H.264-Komprimierungseinstellungen nicht √§ndern m√ºssen. Dadurch erhalten wir Zugriff auf Kameraeinstellungen wie Helligkeit und Kontrast.  Es hat auch den Vorteil, dass es sich in einem guten Plugin-Paket befindet, das in Zukunft m√∂glicherweise besser aufbewahrt wird. <br><br><h4>  Webcasting √ºber Gstreamer </h4><br>  Starten Sie auf dem empfangenden Computer den Empf√§nger: <br><br><pre> <code class="bash hljs">gst-launch-1.0 -v udpsrc port=6666 ! application/x-rtp, encoding-name=H264 ! rtph264depay ! h264parse ! avdec_h264 ! videoconvert ! autovideosink</code> </pre> <br>  Auf einem Ger√§t mit einer Kamera starten wir die √úbertragung von hardwarecodiertem Video: <br><br><pre> <code class="bash hljs">gst-launch-1.0 uvch264src name=src auto-start=<span class="hljs-literal"><span class="hljs-literal">true</span></span> src.vidsrc ! video/x-h264,width=160,height=120,framerate=30/1 ! h264parse ! rtph264pay ! udpsink host=192.168.1.196 port=6666</code> </pre> <br>  Besonderer Dank geht an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Amomum, die</a> mir beim Schreiben dieses Codes geholfen hat. <br><br><h4>  Zusammenfassung der Verz√∂gerung der Video√ºbertragung √ºber Gstreamer </h4><br>  Selbst mit einer Aufl√∂sung von 1920 * 1080 √ºberschritt die Prozessorlast von Beaglebone Blue 30% nicht und die Videoverz√∂gerung betrug nicht mehr als 0,3 Sekunden.  Ja, da das Video in dieser Version √ºber udp gesendet wurde, f√§llt das Bild bei Verlust von Paketen zum n√§chsten Schl√ºsselbild auseinander, aber wir k√∂nnen es so konfigurieren, dass Schl√ºsselbilder h√§ufiger gesendet werden. <br><br><h3>  ROS-Aufgaben </h3><br>  Es bleibt nur noch, das empfangene Video in ROS zu pushen, wenn jemand dabei helfen kann, schreiben Sie in einem pers√∂nlichen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415567/">https://habr.com/ru/post/de415567/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415557/index.html">Codec 2 + neuronales Netzwerk = ganzer Podcast auf einer Diskette</a></li>
<li><a href="../de415559/index.html">Die Geschichte der Entwicklung von Call Centern oder wie Technologien die Arbeit der Betreiber mit Kunden ver√§ndert haben</a></li>
<li><a href="../de415561/index.html">So √ºbertragen Sie Ereignisse von Veeam Backup & Replication in Instant Messenger</a></li>
<li><a href="../de415563/index.html">Die Behandlung von "mechanischem" Scrum. Teil 2. Team</a></li>
<li><a href="../de415565/index.html">Warum (heute) 444 zur√ºckgibt, ist nicht immer sinnvoll</a></li>
<li><a href="../de415569/index.html">HOWTO Setup Ubuntu 18.04 Sendmail + DKIM + SPF + DMARC oder wie ich es geschafft habe, in die Google Mail-Bastion zu gelangen</a></li>
<li><a href="../de415571/index.html">kaggle: IEEE-Kameramodellidentifikation</a></li>
<li><a href="../de415573/index.html">Optimierung eines Modells f√ºr den 3D-Druck am Beispiel der Blender-Software</a></li>
<li><a href="../de415575/index.html">Funktionen zum Dokumentieren von PostgreSQL-Datenbanken. Teil eins</a></li>
<li><a href="../de415577/index.html">Folien des Kurses "DBMS Technologies and Development"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>