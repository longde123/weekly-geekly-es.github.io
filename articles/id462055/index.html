<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤ âœŒğŸ¿ ğŸ•ï¸ Pengalaman menerjemahkan proyek besar dari Flow ke TypeScript ğŸ’™ ğŸ‘¨ğŸ¿â€ğŸ« ğŸ˜¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="JavaScript adalah salah satu bahasa dengan pengetikan dinamis. Bahasa seperti itu nyaman untuk pengembangan aplikasi yang cepat, tetapi ketika beberap...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengalaman menerjemahkan proyek besar dari Flow ke TypeScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/directum/blog/462055/"><img src="https://habrastorage.org/webt/yz/xc/aw/yzxcaw_zmgfag6uoogghhx9xv7s.jpeg" alt="Logo directum"><br><br>  JavaScript adalah salah satu bahasa dengan pengetikan dinamis.  Bahasa seperti itu nyaman untuk pengembangan aplikasi yang cepat, tetapi ketika beberapa tim mengambil pengembangan satu proyek besar, lebih baik untuk memilih salah satu alat untuk pengecekan jenis dari awal. <br><br>  Anda bisa mulai mengembangkan kode TypeScript atau memasukkannya dalam proyek Flow.  TypeScript adalah versi kompilasi dari JavaScript yang dikembangkan oleh Microsoft.  Flow, tidak seperti TypeScript, bukan bahasa, tetapi alat yang memungkinkan Anda untuk menganalisis kode dan memeriksa jenis.  Anda dapat menemukan banyak artikel dan video di internet tentang pendekatan ini, serta panduan tentang cara mulai menggunakan pengetikan.  Dalam artikel ini kami ingin memberi tahu Anda mengapa Flow tidak cocok untuk kami, dan bagaimana kami mulai beralih ke Scripteks. <br><a name="habracut"></a><br><h2>  Sedikit sejarah </h2><br>  Pada 2016, kami mulai mengembangkan klien web berbasis React / Redux untuk sistem ECM kami.  Flow dipilih untuk menguji pengetikan karena alasan berikut: <br><br><ol><li>  React and Flow adalah produk dari Facebook perusahaan yang sama. </li><li>  Flow berkembang lebih aktif. </li><li>  Flow mudah diintegrasikan ke dalam proyek. </li></ol><br>  Tetapi proyek bertambah, jumlah tim pengembangan meningkat, dan sejumlah masalah muncul ketika menggunakan Flow: <br><br><ol><li>  Pengecekan tipe latar belakang Aliran menggunakan terlalu banyak sumber daya PC.  Akibatnya, beberapa pengembang mematikannya dan mulai memeriksa sesuai kebutuhan. </li><li>  Ada beberapa situasi ketika dibutuhkan waktu untuk membawa kode sejalan dengan Flow ketika menulis kode itu sendiri. </li><li>  Kode mulai muncul dalam proyek, yang diperlukan hanya untuk lulus tes aliran.  Misalnya, periksa ganda untuk null: <br><br><pre><code class="javascript hljs">foo() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.activeFormContainer == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// to do something if (this.activeFormContainer != null) // only for Flow this.activeFormContainer.style.minWidth = '100px'; }</span></span></code> </pre> </li><li>  Sebagian besar pengembang menggunakan editor kode Visual Studio Code, di mana Flow tidak memiliki dukungan sebaik TypeScript.  Penyelesaian otomatis (IntelliSense) tidak selalu berfungsi selama pengembangan, dan navigasi kode tidak stabil.  Saya ingin memiliki kenyamanan pengembangan yang sama seperti ketika menulis dalam C # di Visual Studio. </li></ol><br>  Beberapa pengembang memiliki ide untuk mencoba beralih ke TypeScript.  Untuk menguji ide transisi dan meyakinkan manajemen, kami memutuskan untuk mencoba prototipe. <br><br><h2>  Prototipe </h2><br>  Kami ingin menguji dua ide pada prototipe: <br><br><ol><li>  Cobalah menerjemahkan keseluruhan proyek. </li><li>  Siapkan proyek sehingga Anda dapat menggunakan kedua Flow dan Script secara paralel. </li></ol><br>  Untuk ide pertama, diperlukan utilitas yang akan mengkonversi semua file proyek.  Di jaringan ditemukan salah satunya.  Dilihat dari deskripsi, dia akan dapat menerjemahkan sebagian besar, tetapi beberapa perubahan harus diedit oleh diri kita sendiri, atau utilitas itu sendiri harus ditambahkan.  Kami dapat mengonversi proyek uji dengan sejumlah kecil file.  Tetapi proyek yang sebenarnya tidak dapat dikompilasi, itu perlu untuk mengedit terlalu banyak file.  Kami memutuskan untuk tidak melanjutkan ke arah ini, karena: <br><br><ol><li>  Masih banyak yang harus dilakukan!  Dan sementara kami akan menyelesaikan proyek, tim yang tersisa akan terus mengembangkan fungsionalitas baru, memperbaiki bug, menulis tes.  Selain itu, akan membutuhkan banyak waktu untuk menggabungkan file. </li><li>  Bahkan jika kita menerjemahkan proyek dengan cara ini, maka seberapa banyak pekerjaan yang harus dilakukan oleh penguji kita! </li></ol><br>  Meskipun kami meninggalkan opsi ini, kami mendapatkan pengalaman yang bermanfaat di sana.  Menjadi jelas perkiraan jumlah pekerjaan yang perlu dilakukan untuk menerjemahkan setiap file.  Inilah terjemahan dari komponen React yang sederhana. <br> <a href=""><img src="https://habrastorage.org/webt/xa/d8/h1/xad8h1wgyhpfy1jydrgxmuqy1ga.jpeg" alt="Membandingkan Flow dan Kode TypeScript"><br></a> <br><br>  Seperti yang Anda lihat, tidak ada banyak perubahan.  Pada dasarnya, mereka adalah sebagai berikut: <br><br><ul><li>  hapus // @ flow; </li><li>  ganti tipe dengan antarmuka yang lebih akrab; </li><li>  tambahkan pengubah akses; </li><li>  ganti tipe dengan tipe dari pustaka ts (dari contoh pada gambar: event handler dan event itu sendiri). </li></ul><br>  Implementasi pada ide kedua akan memungkinkan pengembangan lebih lanjut, tetapi sudah pada TypeScript, dan di latar belakang untuk perlahan-lahan menerjemahkan basis kode yang ada.  Ini memberikan beberapa keuntungan: <br><br><ol><li>  Mudah diterjemahkan, tanpa takut kehilangan sesuatu. </li><li>  Mudah diuji. </li><li>  Mudah untuk menggabungkan perubahan. </li></ol><br>  Tetapi tidak sepenuhnya jelas apakah proyek dapat dikonfigurasi untuk bekerja dengan dua jenis pengetikan secara paralel.  Pencarian di Internet tidak menghasilkan sesuatu yang konkret, jadi mereka mulai mengatasinya sendiri.  Secara teori, penganalisa aliran hanya memeriksa file dengan ekstensi js / jsx dan berisi komentar: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//@flow  /* @flow */</span></span></code> </pre><br>  Untuk kompiler TypeScript, file harus memiliki ekstensi ts / tsx.  Dari sinilah kedua pendekatan untuk mengetik harus bekerja secara bersamaan dan tidak saling mengganggu.  Berdasarkan ini, kami mengatur lingkungan proyek.  Menggunakan pengalaman prototipe pertama, kami menerjemahkan beberapa file.  Menyusun proyek, meluncurkan klien - semuanya bekerja seperti sebelumnya! <br><br><h2>  Lampu hijau </h2><br>  Dan satu hari yang indah - hari perencanaan sprint, tim kami memiliki Kisah Pengguna "Mulai Beralih ke TypeScript" di backlog, dengan daftar karya berikut: <br><br><ol><li>  Siapkan webpack. </li><li>  Konfigurasikan tslint. </li><li>  Siapkan lingkungan pengujian. </li><li>  Terjemahkan file ke TypeScript. </li></ol><br><h3>  Penyiapan paket web </h3><br>  Langkah pertama adalah mengajarkan webpack bagaimana menangani file dengan ekstensi ts / tsx.  Untuk melakukan ini, kami menambahkan aturan ke bagian aturan dari file konfigurasi.  Ts-loader yang awalnya digunakan: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// webpack.config.js const rules = [ ... { test: /\.(ts|tsx)?$/, loader: 'ts-loader', options: { transpileOnly: true } } ];</span></span></code> </pre><br>  Untuk mempercepat perakitan, ketik pengecekan dimatikan: <code>transpileOnly: true</code> , karena  IDE sudah menunjukkan kesalahan saat menulis kode. <br><br>  Tetapi ketika kami mulai menerjemahkan tindakan Redux kami, menjadi jelas bahwa mereka membutuhkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plugin babel-plugin-transform-class-display-name</a> untuk berfungsi.  Plugin ini menambahkan properti displayName statis ke semua kelas.  Setelah terjemahan, hanya tindakan ts-loader yang diproses, dan ini tidak memungkinkan plugin babel untuk diterapkan.  Sebagai hasilnya, kami meninggalkan ts-loader dan memperluas aturan yang ada untuk js / jsx dengan menambahkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">babel</a> / preset-typescript: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// webpack.config.js const rules = [ { test: /\.(ts|tsx|js|jsx)?$/, exclude: /node_modules|lib/, loader: 'babel-loader?cacheDirectory=true' }, ... ];</span></span></code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// .babelrc.js const presets = [ [ "@babel/preset-env", { "modules": !isTest ? false : 'commonjs', "useBuiltIns": false } ], "@babel/typescript", "@babel/preset-react", ];</span></span></code> </pre><br>  Agar kompiler TypeScript bekerja dengan benar, Anda perlu menambahkan file konfigurasi tsconfig.json, itu diambil dari dokumentasi. <br><br><h3>  Konfigurasikan Tslint </h3><br>  Kode yang ditulis menggunakan Flow juga diperiksa menggunakan eslint.  TypeScript memiliki padanannya, tslint.  Awalnya, saya ingin mentransfer semua aturan dari eslint ke tslint.  Ada upaya untuk menyinkronkan aturan melalui plugin tslint-eslint-rules, tetapi sebagian besar aturan tidak didukung.  Dimungkinkan juga untuk menggunakan eslint untuk memeriksa file ts menggunakan typescript-eslint-parser.  Namun, sayangnya, hanya satu pengurai yang dapat dihubungkan ke eslint.  Jika Anda hanya menggunakan ts-parser untuk semua jenis file, banyak kesalahan aneh muncul di file js dan ts.  Akibatnya, kami menggunakan seperangkat aturan yang disarankan, diperluas ke persyaratan kami: <br><br><pre> <code class="json hljs">// tslint.json <span class="hljs-string"><span class="hljs-string">"extends"</span></span>: [<span class="hljs-string"><span class="hljs-string">"tslint:recommended"</span></span>, <span class="hljs-string"><span class="hljs-string">"tslint-react"</span></span>]</code> </pre><br><h3>  Terjemahkan file ke dalam TypeScript </h3><br>  Sekarang semuanya sudah siap, dan Anda dapat mulai menerjemahkan file.  Untuk mulai dengan, kami memutuskan untuk mentransfer komponen Bereaksi kecil, yang digunakan di seluruh proyek.  Pilihannya jatuh pada komponen "Tombol". <br><br><img src="https://habrastorage.org/webt/ka/fg/ri/kafgri2le33qadvazbpa4creaxk.png" alt="Tombol dalam proyek"><br><br>  Kami mengalami masalah selama proses terjemahan: tidak semua perpustakaan pihak ketiga memiliki pengetikan TypeScript, misalnya, bem-cn-lite.  Pada sumber daya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TypeSearch</a> dari Microsoft, tipe perpustakaan untuk itu tidak dapat ditemukan.  untuk hampir semua pustaka yang diperlukan, kami menemukan dan menghubungkan pustaka jenis ts.  Salah satu solusinya adalah terhubung melalui membutuhkan: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'bem-cn-lite'</span></span>);</code> </pre><br>  Tetapi pada saat yang sama, masalah dengan kurangnya jenis tidak terpecahkan.  Oleh karena itu, kami membuat "rintisan" untuk tipe itu sendiri, menggunakan utilitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dts-gen</a> : <br><br><pre> <code class="bash hljs">dts-gen -m bem-cn-lite</code> </pre><br>  Utilitas menghasilkan file dengan ekstensi * .d.ts.  File ditempatkan di folder @types dan mengonfigurasi tsconfig.json: <br><br><pre> <code class="json hljs">// tsconfig.json <span class="hljs-string"><span class="hljs-string">"typeRoots"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"./@types"</span></span>, <span class="hljs-string"><span class="hljs-string">"./node_modules/@types"</span></span> ]</code> </pre><br>  Selanjutnya, dengan analogi dengan prototipe, kami menerjemahkan komponen.  Menyusun proyek, meluncurkan klien - semuanya berhasil!  Tetapi tes itu gagal. <br><br><h3>  Pengaturan lingkungan pengujian </h3><br>  Untuk menguji aplikasi, kami menggunakan Storybook dan Mocha. <br><br>  Storybook digunakan untuk pengujian regresi visual ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> ).  Seperti halnya proyek itu sendiri, ia dibuat menggunakan webpack dan memiliki file konfigurasinya sendiri.  Oleh karena itu, untuk bekerja dengan file ts / tsx, itu harus dikonfigurasikan secara analogi dengan konfigurasi proyek itu sendiri. <br><br>  Sementara kami menggunakan ts-loader untuk membangun proyek, kami berhenti menjalankan tes Mocha.  Untuk mengatasi masalah ini, tambahkan ts-node ke lingkungan pengujian: <br><br><pre> <code class="json hljs">// mocha.opts --require @babel/polyfill --require @babel/register --require test/index.js --require tsconfig-paths/register --require ts-node/register/transpile-only --recursive --reporter mochawesome --reporter-options reportDir=../../bin/TestResults,reportName=js-test-results,inlineAssets=<span class="hljs-literal"><span class="hljs-literal">true</span></span> --exit</code> </pre><br>  Tetapi setelah beralih ke Babel, Anda bisa menyingkirkannya. <br><br><h2>  Masalahnya </h2><br>  Dalam proses penerjemahan, kami menemukan sejumlah besar masalah dengan berbagai tingkat kompleksitas.  Mereka terutama terkait dengan kurangnya pengalaman kami dengan TypeScript.  Berikut ini beberapa di antaranya: <br><br><ol><li>  Impor komponen / fungsi dari berbagai jenis file. </li><li>  Terjemahan komponen tingkat tinggi. </li><li>  Kehilangan riwayat perubahan. </li></ol><br><h3>  Impor komponen / fungsi dari berbagai jenis file </h3><br>  Saat menggunakan komponen / fungsi dari berbagai jenis file, ekstensi file perlu ditentukan: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { foo } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./utils.ts'</span></span></code> </pre><br>  Ini memungkinkan Anda untuk menambahkan ekstensi yang valid ke file konfigurasi webpack dan eslint: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// webpack.config.js resolve: { â€¦ extensions: [ '.tsx', '.ts', '.js' ] }</span></span></code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// .eslintrc.js "import/resolver": { "node": { "extensions": [ ".js", ".jsx", ".ts", ".tsx", ".json" ] } }</span></span></code> </pre><br><h3>  Terjemahan komponen tingkat tinggi </h3><br>  Dari semua jenis file, terjemahan Komponen Orde Tinggi (HOC) menyebabkan masalah paling besar.  Ini adalah fungsi yang mengambil komponen pada input dan mengembalikan komponen baru.  Ini terutama digunakan untuk menggunakan kembali logika, misalnya, itu bisa menjadi fungsi yang menambahkan kemampuan untuk memilih elemen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyComponentWithSeletedItem = withSelectedItem(MyComponent);</code> </pre><br>  Atau koneksi paling terkenal, dari perpustakaan Redux.  Mengetik fungsi-fungsi seperti itu tidak sepele dan membutuhkan menghubungkan perpustakaan tambahan untuk bekerja dengan tipe.  Saya tidak akan menjelaskan proses terjemahan secara terperinci, karena Anda dapat menemukan banyak manual tentang subjek di internet.  Singkatnya, masalahnya adalah fungsi seperti itu abstrak: komponen apa pun dengan set properti apa pun dapat menerima input.  Ini bisa berupa komponen Button dengan properti title dan onClick atau komponen Picture dengan properti alt dan imgUrl.  Set properti ini tidak diketahui sebelumnya, hanya properti yang ditambahkan fungsi itu yang diketahui.  Agar compiler TypeScript tidak bersumpah saat menggunakan komponen yang diperoleh dengan bantuan fungsi tersebut, perlu untuk "memotong" properti yang ditambahkan fungsi dari tipe kembali. <br><br>  Untuk melakukan ini, Anda perlu: <br><br><ol><li>  Tarik properti ini ke antarmuka: <br><br><pre> <code class="javascript hljs">interface IWithSelectItem { <span class="hljs-attr"><span class="hljs-attr">selectedItem</span></span>: number; handleSelectedItemChange: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id: number</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; }</code> </pre></li><li>  Hapus semua properti yang memasuki antarmuka IWithSelectItem dari antarmuka komponen.  Untuk melakukan ini, Anda dapat menggunakan operasi Diff &lt;T, U&gt; dari pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jenis utilitas</a> . <br><br><pre> <code class="javascript hljs">React.ComponentType&lt;Diff&lt;TPropsComponent, IWithSelectItem&gt;&gt;</code> </pre></li></ol><br><h3>  Kehilangan riwayat perubahan </h3><br>  Untuk bekerja dengan sumber, misalnya, tinjauan kode, kami menggunakan Team Foundation Server.  Saat menerjemahkan file, kami menemukan satu fitur yang tidak menyenangkan.  Alih-alih satu file yang diubah, dua muncul di kumpulan permintaan: <br><br><ul><li>  remote - versi lama file; </li><li>  dibuat - versi baru. <br><br><img src="https://habrastorage.org/webt/rd/cs/ac/rdcsac47lojd8ojlyfvckqhgrlc.jpeg" alt="Seperti apa di tarik permintaan"></li></ul><br>  Perilaku ini diamati jika ada banyak perubahan dalam file (kesamaan &lt;50%), misalnya, untuk file kecil.  Untuk mengatasi masalah ini, kami mencoba menggunakan: <br><br><ul><li>  perintah git mv </li><li>  jalankan dua commit: yang pertama mengubah ekstensi file, yang kedua adalah dengan koreksi langsung. </li></ul><br>  Namun, sayangnya, kedua pendekatan itu tidak membantu kami. <br><br><h2>  Ringkasan </h2><br>  Gunakan Flow atau TypeScript - semua orang memutuskan untuk dirinya sendiri, kedua pendekatan memiliki pro dan kontra mereka.  Kami memilih TypeScript untuk diri kami sendiri.  Dan Anda diyakinkan dari pengalaman Anda sendiri: jika Anda memilih salah satu pendekatan dan tiba-tiba menyadari, bahkan setelah tiga tahun itu tidak cocok untuk Anda, maka Anda selalu dapat mengubahnya.  Dan untuk transisi yang lebih lancar, Anda dapat mengonfigurasi proyek, seperti kami, untuk bekerja secara paralel. <br><br>  Pada saat penulisan, kami belum sepenuhnya beralih ke TypeScript, tetapi kami telah menulis ulang bagian utama - "inti" dari proyek.  Dalam basis kode, Anda dapat menemukan contoh terjemahan semua jenis file, dari komponen reaksi sederhana hingga komponen tingkat tinggi.  Juga, pelatihan dilakukan di antara semua tim pengembangan, dan sekarang setiap tim, sebagai bagian dari tugasnya, mentransfer bagian dari proyek ke tugas-tugas tersebut. <br><br>  Kami berencana untuk menyelesaikan transisi sebelum akhir tahun, menerjemahkan tes dan buku cerita, dan bahkan mungkin menulis beberapa aturan tslint kami. <br><br>  Menurut perasaan pribadi saya, saya dapat mengatakan bahwa pengembangan mulai memakan waktu lebih sedikit, pengecekan tipe dilakukan dengan cepat, sementara tidak memuat sistem, dan pesan kesalahan bagi saya secara pribadi menjadi lebih dimengerti. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462055/">https://habr.com/ru/post/id462055/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462043/index.html">Smart Fishing di FishSensor</a></li>
<li><a href="../id462045/index.html">Pendapat lain tentang perbedaan antara bin, sbin, usr / bin, usr / sbin</a></li>
<li><a href="../id462047/index.html">Blockchain sebagai platform transformasi digital</a></li>
<li><a href="../id462049/index.html">Bagaimana menjadi spesialis yang lebih dicari di bidang Ilmu Data pada tahun 2019</a></li>
<li><a href="../id462051/index.html">Analisis: cara menghasilkan uang dari investasi dalam indeks saham dan ETF</a></li>
<li><a href="../id462065/index.html">Ivan aka BANO.notIT: "Jika OSM mulai mengiklankan dan mempromosikan dirinya sendiri, orang-orang baru akan datang dengan ide-ide baru"</a></li>
<li><a href="../id462067/index.html">LinkedIn dan seni membual promosi diri</a></li>
<li><a href="../id462069/index.html">Pilot dengan bank: bagaimana startup tidak bisa crash di landasan</a></li>
<li><a href="../id462071/index.html">Generator non-acak dari kode bank Tinkoff satu kali acak</a></li>
<li><a href="../id462073/index.html">Kerugian standar Proof-of-Stake atau bagaimana kami memilih algoritma pencarian konsensus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>