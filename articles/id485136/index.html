<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ· ğŸ‘¨ğŸ½â€ğŸ”¬ ğŸ§‘ğŸ½â€ğŸ¤â€ğŸ§‘ğŸ» Pelacakan dan Pemantauan Istio: Layanan Mikro dan Prinsip Ketidakpastian ğŸ‚ğŸ¾ ğŸ‘©ğŸ¼â€ğŸ’¼ ğŸŒ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prinsip ketidakpastian Heisenberg menyatakan bahwa tidak mungkin secara simultan mengukur posisi suatu objek dan kecepatannya. Jika suatu objek berger...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pelacakan dan Pemantauan Istio: Layanan Mikro dan Prinsip Ketidakpastian</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/485136/">  Prinsip ketidakpastian Heisenberg menyatakan bahwa tidak mungkin secara simultan mengukur posisi suatu objek dan kecepatannya.  Jika suatu objek bergerak, maka ia tidak memiliki lokasi.  Dan jika lokasinya, berarti ia tidak memiliki kecepatan. <br><br><img src="https://habrastorage.org/webt/sl/dx/7l/sldx7l5gkazjrjsrzplh02uzfhk.png" width="100%"><br><br>  Sedangkan untuk layanan microser pada platform Red Hat OpenShift (dan menjalankan Kubernetes), berkat perangkat lunak open-source yang sesuai, mereka dapat secara bersamaan melaporkan kinerja dan kesehatannya.  Tentu saja, ini tidak membantah Heisenberg lama, tetapi menghilangkan ketidakpastian ketika bekerja dengan aplikasi cloud.  Istio memudahkan untuk mengatur pelacakan (tracing) dan pemantauan aplikasi semacam itu untuk menjaga semuanya tetap terkendali. <br><a name="habracut"></a><br><h3>  Tentukan terminologi </h3><br>  Yang kami maksud dengan <b>tracing</b> adalah aktivitas sistem logging.  Kedengarannya cukup umum, tetapi sebenarnya salah satu aturan utama di sini adalah untuk membuang data jejak ke penyimpanan yang sesuai tanpa khawatir memformatnya.  Dan semua pekerjaan mencari dan menganalisis data dipercayakan kepada konsumen mereka.  Istio menggunakan sistem jejak Jaeger, yang mengimplementasikan model data OpenTracing. <br><br>  <b>Dengan jejak</b> (Jejak, dan kata "jejak" digunakan di sini dalam arti "jejak", seperti, misalnya, dalam pemeriksaan balistik) kami akan berarti data yang sepenuhnya menggambarkan bagian dari permintaan atau unit kerja, seperti yang mereka katakan, "dari dan ke".  Sebagai contoh, segala sesuatu yang terjadi dari saat pengguna menekan tombol pada halaman web hingga saat data dikembalikan, termasuk semua layanan microser yang terlibat dalam hal ini.  Kita dapat mengatakan bahwa satu jejak sepenuhnya menggambarkan (atau mensimulasikan) bagian dari permintaan bolak-balik.  Di antarmuka Jaeger, trek didekomposisi menjadi komponen di sepanjang sumbu waktu, seperti bagaimana rantai dapat didekomposisi menjadi tautan yang terpisah.  Hanya alih-alih tautan, trek terdiri dari bentang yang disebut. <br><br>  <b>Rentang</b> adalah interval dari awal unit kerja hingga penyelesaiannya.  Melanjutkan analoginya, kita dapat mengatakan bahwa setiap rentang adalah tautan terpisah dalam rantai.  Suatu rentang mungkin atau mungkin tidak memiliki satu atau lebih rentang anak.  Akibatnya, rentang tingkat atas (rentang akar) akan memiliki durasi total yang sama dengan jejak yang dimiliki. <br><br>  Sebenarnya, <b>pemantauan</b> adalah pengamatan sistem Anda - melalui mata, melalui UI atau melalui otomatisasi.  Pemantauan didasarkan pada data jejak.  Di Istio, pemantauan dilaksanakan menggunakan alat Prometheus dan memiliki UI yang sesuai.  Prometheus mendukung pemantauan otomatis menggunakan Lansiran dan Lansiran Manajer Lansiran. <br><br><h3>  Tinggalkan goresannya </h3><br>  Agar pelacakan dimungkinkan, aplikasi harus membuat koleksi rentang.  Kemudian mereka harus diekspor ke Jaeger sehingga pada gilirannya menciptakan representasi visual dari jejak tersebut.  Antara lain, rentang ini menandai nama operasi, serta cap waktu awal dan akhir.  Rentang dikirim dengan meneruskan header Jaeger untuk permintaan HTTP dari permintaan masuk ke permintaan keluar.  Bergantung pada bahasa pemrograman yang digunakan, ini mungkin memerlukan sedikit modifikasi dari kode sumber aplikasi.  Berikut ini adalah contoh kode Java (saat menggunakan kerangka Boot Spring) yang menambahkan header B3 (gaya Zipkin) ke permintaan Anda di kelas konfigurasi Spring: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9y/mo/yd/9ymoydbpezhtbvshfg2tgpewnk8.png"></div><br>  Pengaturan tajuk berikut digunakan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uy/e-/yg/uye-yg-mezone3fs_1o-vquryvu.png"></div><br>  Jika Anda menggunakan Java, Anda dapat membiarkan kode tidak tersentuh, cukup tambahkan beberapa baris ke file POM Maven dan tetapkan variabel lingkungan.  Berikut adalah baris yang perlu Anda tambahkan ke file POM.XML untuk mengimplementasikan Jaeger Tracer Resolver: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kr/np/vj/krnpvjjnx-6r-icjjttenmdaq-4.png"></div><br>  Dan variabel lingkungan yang sesuai diatur di Dockerfile: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/b8/2a/lh/b82alhxdifmkgfiv3q3hdq1o05m.png"></div><br>  Itu saja, sekarang semuanya sudah diatur, dan layanan microser kami akan mulai menghasilkan data jejak. <br><br><h3>  Kami melihat secara umum </h3><br>  Istio termasuk panel kontrol sederhana berdasarkan Grafana.  Ketika semuanya dikonfigurasi dan berjalan pada platform Red Hat OpenShift PaaS (dalam contoh kami, Red Hat OpenShift dan Kubernetes digunakan pada minishift), panel ini diluncurkan dengan perintah berikut: <br><br><pre><code class="plaintext hljs">open "$(minishift openshift service grafana -u)/d/1/istio-dashboard?refresh=5â©Id=1"</code> </pre> <br>  Panel Grafana memungkinkan Anda untuk dengan cepat mengevaluasi sistem.  Sebuah fragmen dari panel ini ditunjukkan pada gambar di bawah ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zh/jj/lr/zhjjlrilmbtgrdo08lkopbnwh1u.png"></div><br>  Di sini Anda dapat melihat bahwa pelanggan microservice memanggil preferensi microservice v1, dan yang pada gilirannya memanggil rekomendasi layanan microser v1 dan v2.  Panel Grafana memiliki blok Baris Dasbor untuk metrik tingkat tinggi, seperti jumlah total permintaan (Volume Permintaan Global), persentase permintaan yang berhasil (tingkat keberhasilan), kesalahan 4xx.  Selain itu, ada tampilan Server Mesh dengan grafik untuk setiap layanan dan blok Baris Layanan untuk melihat informasi terperinci untuk setiap wadah untuk setiap layanan. <br><br><h3>  Sekarang gali lebih dalam </h3><br>  Dengan jejak yang dikonfigurasi dengan benar, Istio, seperti yang mereka katakan, langsung dari kotak memungkinkan Anda untuk mempelajari analisis kinerja sistem.  Di Jaeger UI, Anda bisa melihat jejak dan melihat seberapa jauh dan dalam mereka pergi, serta secara visual melokalisasi kemacetan kinerja.  Saat menggunakan Red Hat OpenShift pada platform minishift, luncurkan Jaeger UI menggunakan perintah berikut: <br><br><pre> <code class="plaintext hljs">minishift openshift service jaeger-query --in-browser</code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lz/8j/x1/lz8jx118ortdebrs6nlmv8-kwws.png"></div><br>  Apa yang bisa dikatakan tentang jejak di layar ini: <br><br><ul><li>  Ini dibagi menjadi 7 rentang. </li><li>  Total waktu eksekusi adalah 6,99 ms. </li><li>  Rekomendasi microservice, yang merupakan yang terakhir dalam rantai, membutuhkan 0,69 ms. </li></ul><br>  Diagram jenis ini memungkinkan Anda mengetahui dengan cepat situasi di mana kinerja seluruh sistem menderita karena satu layanan yang kurang berfungsi. <br><br>  Sekarang mari kita mempersulit tugas dan meluncurkan dua contoh dari microservice rekomendasi: v2 dengan skala oc --replicas = 2 deployment / recommendation-v2 command.  Berikut adalah pod yang akan kita miliki setelah ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ew/ly/tp/ewlytpvsmyay1m7aai46a5xcono.png"></div><br>  Jika sekarang kita beralih kembali ke Jaeger dan menggunakan rentang untuk layanan rekomendasi, kita akan melihat permintaan pod yang dialihkan.  Dengan demikian, kami dapat dengan mudah melokalisasi rem pada level pod tertentu.  Anda harus melihat bidang node_id: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/o6/ag/rj/o6agrj_goch7itiy27nxkpckmxy.png"></div><br><h3>  Kemana dan bagaimana semuanya berjalan </h3><br>  Sekarang kita pergi ke antarmuka Prometheus dan sangat diharapkan kita melihat di sana bahwa permintaan antara versi kedua dan pertama dari layanan rekomendasi dibagi dalam rasio 2: 1, ketat oleh jumlah pod yang berfungsi.  Selain itu, grafik ini akan berubah secara dinamis saat menskala pod ke atas dan ke bawah, yang akan sangat berguna dengan Canary Deployment (kami akan memeriksa skema penyebaran ini secara lebih rinci di lain waktu). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ri/vg/ja/rivgjapmewz2mfhfll7bydezpyo.png"></div><br><h3>  Itu baru permulaan </h3><br>  Bahkan, hari ini, seperti yang mereka katakan, kami hanya sedikit menyentuh gudang informasi yang berguna tentang Jaeger, Grafana, dan Prometheus.  Secara umum, ini adalah tujuan kami - untuk membimbing Anda ke arah yang benar dan membuka prospek Istio. <br><br>  Dan ingat, semua ini sudah dibangun ke dalam Istio.  Saat menggunakan bahasa pemrograman tertentu (misalnya, Java) dan kerangka kerja (misalnya, Spring Boot) semua ini dapat direalisasikan tanpa sepenuhnya menyentuh kode aplikasi itu sendiri.  Ya, kode harus sedikit dimodifikasi jika Anda menggunakan bahasa lain, terutama Nodejs atau C #.  Tetapi karena ketertelusuran (baca, â€œpenelusuranâ€) adalah salah satu prasyarat untuk membuat sistem cloud yang andal, dalam hal apa pun, Anda harus mengedit kode apakah Anda memiliki Istio atau tidak.  Jadi mengapa tidak menghabiskan upaya lebih menguntungkan? <br><br>  Setidaknya agar selalu menjawab pertanyaan "di mana?" Dan "seberapa cepat?" Dengan kepastian 100%. <br><br><h3>  Rekayasa Kekacauan di Istio: Itu Dikandung </h3><br><h3>  Kemampuan untuk memecahkan barang-barang membantu memastikan bahwa barang-barang itu tidak rusak </h3><br>  Pengujian perangkat lunak bukan hanya hal yang rumit, tetapi juga yang penting.  Pada saat yang sama, pengujian untuk kebenaran (misalnya, apakah suatu fungsi mengembalikan hasil yang benar) adalah satu hal, dan pengujian dalam jaringan yang tidak dapat diandalkan adalah tugas yang sama sekali berbeda (sering diyakini bahwa jaringan selalu bekerja tanpa kegagalan, dan ini adalah yang pertama dari delapan kesalahpahaman mengenai distribusi komputasi).  Salah satu kesulitan dalam memecahkan masalah ini adalah bagaimana mensimulasikan kegagalan dalam sistem atau mengenalkannya secara sengaja dengan melakukan apa yang disebut injeksi kesalahan.  Ini dapat dilakukan dengan memodifikasi kode sumber aplikasi itu sendiri.  Tapi kemudian Anda tidak akan menguji kode asli Anda, tetapi versinya, yang secara khusus mensimulasikan kegagalan.  Akibatnya, Anda berisiko masuk ke pelukan fatal dari injeksi kesalahan dan bertabrakan dengan tas heisen - kegagalan yang hilang ketika Anda mencoba untuk mendeteksinya. <br><br>  Dan sekarang kita akan menunjukkan bagaimana Istio membantu mengatasi kesulitan ini satu-dua. <br><br><h3>  Bagaimana kelihatannya ketika semuanya baik-baik saja </h3><br>  Pertimbangkan skenario berikut: kami memiliki dua pod untuk microservice rekomendasi kami, yang kami ambil dari tutorial Istio.  Satu pod ditandai sebagai v1 dan yang lainnya sebagai v2.  Seperti yang Anda lihat, sementara semuanya bekerja dengan baik: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kn/yp/ku/knypkuxns77xf9hyiqtmmnl2qtm.png"></div><br>  (Omong-omong, nomor di sebelah kanan hanyalah penghitung panggilan untuk setiap pod) <br><br>  Tapi kita tidak butuh ini, kan?  Baiklah, mari kita coba hancurkan semuanya tanpa menyentuh kode sumber sama sekali. <br><br><h3>  Kami mengatur interupsi dalam pekerjaan layanan mikro </h3><br>  Di bawah ini adalah file yaml untuk aturan routing Istio, yang dalam setengah kasus akan gagal (kesalahan server 503): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l7/kw/xm/l7kwxmggkngarcusz4sy00epmcc.png"></div><br>  Harap dicatat bahwa kami secara eksplisit menetapkan bahwa dalam setengah kasus kesalahan 503 harus dikembalikan. <br><br>  Dan berikut ini adalah tangkapan layar dari perintah curl yang diluncurkan dalam loop setelah kami mengaktifkan aturan ini untuk mensimulasikan kegagalan.  Seperti yang Anda lihat, setengah dari permintaan mengembalikan kesalahan 503, dan terlepas dari pod - v1 atau v2 mana - mereka pergi ke: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/t5/-6/62/t5-6620-bhqwlupwj_eevq7ud6s.png"></div><br>  Untuk memulihkan operasi normal, cukup menghapus aturan ini, dalam kasus kami, perintah istioctl delete routerule Recommendation-503 -n tutorial.  Di sini Tutorial adalah nama dari proyek Red Hat OpenShift yang menjalankan tutorial Istio kami. <br><br><h3>  Membuat Penundaan Buatan </h3><br>  Kesalahan buatan 503 membantu menguji sistem untuk toleransi kesalahan, tetapi kemampuan untuk memprediksi dan menangani penundaan akan membuat Anda lebih terkesan.  Dan keterlambatan dalam kehidupan nyata lebih sering terjadi daripada kegagalan.  Layanan-mikro yang berjalan lambat adalah racun yang diderita seluruh sistem.  Berkat Istio, Anda dapat menguji kode yang terkait dengan keterlambatan pemrosesan tanpa mengubahnya sama sekali.  Untuk mulai dengan, kami akan menunjukkan bagaimana melakukan ini dalam kasus keterlambatan jaringan yang diperkenalkan secara buatan. <br><br>  Harap perhatikan bahwa setelah pengujian seperti itu, Anda mungkin perlu (atau ingin) memperbaiki kode Anda.  Berita baiknya adalah, dalam hal ini Anda akan bertindak proaktif, bukan reaktif.  Itulah bagaimana siklus pengembangan harus dibangun: coding-testing-feedback-coding-testing ... <br><br>  Beginilah aturannya terlihat ... Meskipun Anda tahu apa?  Istio sangat sederhana, dan file yaml ini sangat jelas sehingga semua yang ada dalam contoh ini berbicara sendiri, lihat saja: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/au/2p/92/au2p92jsexrmthvsbjmfkbyh05c.png"></div><br>  Dalam setengah kasus, kami akan memiliki penundaan 7 detik.  Dan ini sama sekali tidak sama seperti jika kita memasukkan perintah sleep pada kode sumber, karena Istio benar-benar menunda permintaan selama 7 detik.  Karena Istio mendukung pelacakan Jaeger, penundaan ini sangat baik di UI miring Jaeger, seperti yang ditunjukkan pada tangkapan layar di bawah ini.  Perhatikan permintaan panjang di sudut kanan atas diagram - durasinya 7,02 detik: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1h/xo/4l/1hxo4lzzbyzue3isyckez6ez4fo.png"></div><br>  Skenario ini memungkinkan Anda untuk menguji kode di bawah kondisi latensi jaringan.  Dan jelas bahwa dengan menghapus aturan ini, kami akan menghapus penundaan buatan.  Kami ulangi, tetapi sekali lagi kami melakukan semua ini tanpa menyentuh kode sumber. <br><br><h3>  Jangan mundur dan jangan menyerah </h3><br>  Fitur lain dari Istio yang berguna untuk rekayasa kekacauan adalah panggilan berulang ke layanan beberapa kali.  Intinya di sini bukan untuk berhenti mencoba, ketika permintaan pertama berakhir dengan kesalahan 503 - dan kemudian, mungkin, untuk kali kesebelas kita beruntung.  Mungkin layanan hanya berbaring sebentar karena suatu alasan.  Ya, alasan ini harus digali dan dihilangkan.  Tapi ini nanti, tapi untuk sekarang mari kita coba untuk membuat sistem terus bekerja. <br><br>  Jadi, kami ingin layanan untuk memberikan kesalahan 503 dari waktu ke waktu, dan setelah itu Istio akan mencoba menghubunginya lagi.  Dan di sini kita jelas membutuhkan cara untuk menghasilkan kesalahan 503, tanpa menyentuh kode itu sendiri ... <br><br>  Berhenti menunggu!  Kami baru saja melakukannya. <br><br>  File ini akan membuat layanan rekomendasi-v2 menghasilkan kesalahan 503 dalam setengah kasus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ot/6x/s4/ot6xs4clozb273bdfk32ct1gcvy.png"></div><br>  Jelas, sebagian dari permintaan akan gagal: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pu/jd/90/pujd90d9qf7tslucey3184dnvik.png"></div><br>  Dan sekarang kita akan menggunakan fungsi Coba Lagi Istio: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lq/nh/2y/lqnh2yeuargpzyskjb6o9ptsstu.png"></div><br>  Aturan perutean ini melakukan tiga percobaan ulang dengan interval dua detik dan harus mengurangi (dan idealnya sepenuhnya dihapus dari radar) 503 kesalahan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wp/ed/jy/wpedjyfo8jskkadpnonzppc3wgu.png"></div><br>  Kami meringkas: kami membuatnya sehingga Istio, pertama, menghasilkan 503 kesalahan untuk setengah dari permintaan.  Dan kedua, Istio yang sama membuat tiga upaya untuk menyambung kembali ke layanan jika terjadi kesalahan 503. Akibatnya, semuanya bekerja dengan baik.  Dengan demikian, menggunakan fungsi Coba Lagi, kami memenuhi janji kami untuk tidak mundur dan tidak menyerah. <br><br>  Dan ya, kami melakukannya lagi tanpa menyentuh kode sama sekali.  Yang kami butuhkan hanyalah dua aturan perutean Istio: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/g2/hu/9a/g2hu9aiyuemt8qq7ugn1x14lekq.png"></div><br><h3>  Bagaimana tidak mengecewakan seorang pengguna atau tujuh jangan menunggu </h3><br>  Dan sekarang kita membalikkan situasi dan mempertimbangkan skenario ketika Anda tidak harus mundur dan hanya memberikan waktu yang tetap.  Dan kemudian Anda hanya perlu berhenti mencoba memproses permintaan agar tidak memaksa semua orang untuk menunggu satu layanan pengereman.  Dengan kata lain, kami tidak akan melindungi posisi yang hilang, tetapi akan pindah ke garis cadangan agar tidak mengecewakan pengguna situs dan tidak memaksanya untuk merana karena ketidaktahuan. <br><br>  Di Istio, Anda dapat mengatur batas waktu permintaan.  Jika layanan melebihi batas waktu ini, kesalahan 504 (Gateway Timeout) dikembalikan - lagi, semua ini dilakukan melalui konfigurasi Istio.  Tetapi kita harus menambahkan perintah sleep ke kode sumber layanan (dan kemudian, tentu saja, jalankan rebuild dan redeploy) untuk mensimulasikan operasi layanan yang lambat.  Sayangnya, itu tidak akan berhasil jika tidak. <br><br>  Jadi, kami memasukkan tidur tiga detik ke kode layanan rekomendasi v2, membangun kembali gambar yang sesuai dan membuat mode ulang wadah, dan sekarang kami akan menambahkan batas waktu menggunakan aturan perutean Istio berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6y/5v/z7/6y5vz7wmsbnnvjb-vv5brcsdp5o.png"></div><br>  Tangkapan layar di atas menunjukkan bahwa kami mencoba menghubungi layanan rekomendasi jika kami tidak menerima respons dalam satu detik, yaitu, sebelum kesalahan 504 terjadi. Setelah menerapkan aturan perutean ini (dan menambahkan tidur tiga detik ke kode layanan rekomendasi) : v2), kami mendapatkan ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ok/eq/ii/okeqiihvoiw5hbwur5l4c3ggibe.png"></div><br>  Kami ulangi lagi, tetapi batas waktu dapat diatur tanpa menyentuh kode sumber.  Dan bonus tambahan di sini adalah sekarang Anda dapat memodifikasi kode Anda sehingga merespons timeout, dan mudah untuk menguji peningkatan ini menggunakan Istio. <br><br><h3>  Dan sekarang semuanya bersama </h3><br>  Membuat sedikit kekacauan dengan Istio adalah cara yang bagus untuk menguji kode Anda dan keandalan sistem Anda secara keseluruhan.  Pola fallback, sekat, dan pemutus sirkuit, mekanisme untuk menciptakan kegagalan dan penundaan buatan, dan juga panggilan dan waktu tunggu berulang kali akan sangat berguna saat membuat sistem cloud yang toleran terhadap kesalahan.  Dikombinasikan dengan Kubernetes dan Red Hat OpenShift, alat ini membantu Anda dengan percaya diri menghadapi masa depan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id485136/">https://habr.com/ru/post/id485136/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id485122/index.html">Judul "Baca artikel untuk Anda." Oktober - Desember 2019</a></li>
<li><a href="../id485124/index.html">Tes murni dalam PHP dan PHPUnit</a></li>
<li><a href="../id485126/index.html">Mu-mu, pakan-pakan, dukun: evolusi komunikasi akustik</a></li>
<li><a href="../id485128/index.html">Menghemat lisensi Mikrotik CHR</a></li>
<li><a href="../id485132/index.html">Bergabung dengan Google Play Indie Games Festival</a></li>
<li><a href="../id485138/index.html">Pelokalan aplikasi: bagaimana kami membuat terjemahan dan pengembangan teman</a></li>
<li><a href="../id485144/index.html">Bagaimana saya memperbaiki dasar yang rusak dan apa yang terjadi</a></li>
<li><a href="../id485146/index.html">Gaji di TI pada paruh kedua 2019: menurut kalkulator Habr Career</a></li>
<li><a href="../id485148/index.html">Unicode yang menggemaskan ini</a></li>
<li><a href="../id485150/index.html">Fisika untuk penembak PvP seluler, atau bagaimana kita membuat ulang game dua dimensi menjadi tiga dimensi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>