<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∞üèΩ üëã üå´Ô∏è Mencari kesalahan dalam kode sumber SDK Layanan Web Amazon untuk .NET üéí üë©üèæ‚Äçüöí ‚ôøÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selamat datang di semua penggemar yang merusak kode orang lain. :) Hari ini di laboratorium kami, kami memiliki bahan baru untuk penelitian - kode sum...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mencari kesalahan dalam kode sumber SDK Layanan Web Amazon untuk .NET</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/437514/"><p><img src="https://habrastorage.org/getpro/habr/post_images/188/292/f27/188292f271dd0648b09f848dbe66efa6.png" alt="Gambar 1"></p><br>  Selamat datang di semua penggemar yang merusak kode orang lain.  :) Hari ini di laboratorium kami, kami memiliki bahan baru untuk penelitian - kode sumber AWS SDK untuk proyek .NET.  Pada saat itu, kami menulis artikel tentang memeriksa AWS SDK untuk C ++.  Maka tidak ada sesuatu yang sangat menarik.  Mari kita lihat apa yang layak. NET dari versi AWS SDK.  Sekali lagi, ini adalah kesempatan besar untuk menunjukkan kemampuan penganalisa PVS-Studio dan membuat dunia sedikit lebih baik. <br><a name="habracut"></a><br>  Amazon Web Services (AWS) SDK untuk .NET adalah seperangkat alat pengembang, dimaksudkan untuk membuat aplikasi berdasarkan .NET dalam infrastruktur AWS.  Set ini memungkinkan untuk menyederhanakan proses penulisan kode secara signifikan.  SDK mencakup set API .NET untuk berbagai layanan AWS, seperti Amazon S3, Amazon EC2, DynamoDB, dan lainnya.  Kode sumber SDK tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> . <br><br>  Seperti yang saya sebutkan, pada saat itu kami telah menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> tentang memeriksa AWS SDK untuk C ++.  Artikel itu ternyata kecil - hanya beberapa kesalahan yang ditemukan per 512 ribu baris kode.  Kali ini kita berurusan dengan ukuran kode yang jauh lebih besar, yang mencakup sekitar 34 ribu file cs, dan jumlah total baris kode (tidak termasuk yang kosong) sangat mengesankan 5 juta.  Sebagian kecil kode (200 ribu baris dalam file 664-cs) dikumpulkan untuk pengujian, saya belum mempertimbangkannya. <br><br>  Jika kualitas kode .NET dari versi SDK kurang lebih sama dengan salah satu dari C ++ (dua kesalahan per 512 KLOC), maka kita harus mendapatkan jumlah kesalahan sekitar 10 kali lebih besar.  Tentu saja, ini adalah metodologi perhitungan yang sangat tidak akurat, yang tidak memperhitungkan kekhasan linguistik dan banyak faktor lainnya, tetapi saya tidak berpikir pembaca sekarang ingin masuk ke penalaran yang membosankan.  Sebagai gantinya, saya sarankan beralih ke hasil. <br><br>  Pemeriksaan dilakukan menggunakan PVS-Studio 6.27.  Ini hanya luar biasa, tetapi masih faktanya adalah bahwa dalam AWS SDK untuk .NET, penganalisa berhasil mendeteksi 40 kesalahan, yang layak untuk dibicarakan.  Ini menunjukkan tidak hanya kualitas tinggi dari kode SDK (sekitar 4 kesalahan per 512 KLOC), tetapi juga kualitas yang sebanding dari penganalisis C # PVS-Studio dibandingkan dengan C ++.  Hasil yang bagus! <br><br>  Penulis AWS SDK untuk .NET, Anda benar-benar juara!  Dengan setiap proyek, Anda menunjukkan kualitas kode yang luar biasa.  Ini bisa menjadi contoh yang bagus untuk tim lain.  Namun, tentu saja, saya tidak akan menjadi pengembang analisa statis, jika saya tidak memberikan 2 sen saya.  :) Kami sudah bekerja dengan tim Lumberyard dari Amazon tentang penggunaan PVS-Studio.  Karena ini adalah perusahaan yang sangat besar dengan banyak unit di seluruh dunia, sangat mungkin bahwa tim AWS SDK untuk .NET belum pernah mendengar tentang PVS-Studio.  Lagi pula, saya belum menemukan tanda-tanda menggunakan penganalisis kami dalam kode SDK, meskipun tidak mengatakan apa-apa.  Namun, setidaknya, tim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggunakan</a> alat analisa yang dibangun ke dalam Visual Studio.  Sangat bagus, tetapi ulasan kode selalu dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditingkatkan</a> :). <br><br>  Akibatnya, saya berhasil menemukan beberapa bug dalam kode SDK dan, akhirnya, saatnya untuk membaginya. <br><br>  <b>Kesalahan dalam logika</b> <br><br>  <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3008</a> [CWE-563] Variabel 'this.linker.s3.region' diberi nilai dua kali berturut-turut.  Mungkin ini sebuah kesalahan.  Periksa baris: 116, 114. AWSSDK.DynamoDBv2.Net45 S3Link.cs 116 <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Region { get { .... } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (String.IsNullOrEmpty(value)) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.linker.s3.region = <span class="hljs-string"><span class="hljs-string">"us-east-1"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.linker.s3.region = value; } }</code> </pre> <br>  Penganalisis memperingatkan tentang penetapan nilai berulang untuk variabel yang sama.  Dari kode menjadi jelas bahwa ini disebabkan oleh kesalahan yang melanggar logika program kerja: nilai variabel <i>this.linker.s3.region</i> akan selalu sama dengan nilai nilai variabel, terlepas dari kondisi <i>if (String.IsNullOrEmpty (value))</i> .  pernyataan <i>kembali</i> terlewatkan di badan <i>if</i> block.  Kode perlu diperbaiki sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Region { get { .... } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (String.IsNullOrEmpty(value)) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.linker.s3.region = <span class="hljs-string"><span class="hljs-string">"us-east-1"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.linker.s3.region = value; } }</code> </pre> <br>  <b>Rekursi tak terbatas</b> <br><br>  <b>Peringatan PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3110</a> [CWE-674] Kemungkinan rekursi tak terbatas di dalam properti 'OnFailure'.  AWSSDK.ElasticMapReduce.Net45 ResizeJobFlowStep.cs 171 <br><br><pre> <code class="cpp hljs">OnFailure? onFailure = null; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OnFailure? OnFailure { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.OnFailure; } <span class="hljs-comment"><span class="hljs-comment">// &lt;= set { this.onFailure = value; } }</span></span></code> </pre> <br>  Contoh klasik kesalahan ketik, yang mengarah pada rekursi tak terbatas di <i>dapatkan</i> <i>aksesor</i> properti <i>OnFailure</i> .  Alih-alih mengembalikan nilai bidang pribadi pada <i>Kegagalan,</i> akses ke properti <i>OnFailure</i> terjadi.  Varian yang benar: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OnFailure? OnFailure { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onFailure; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onFailure = value; } }</code> </pre> <br>  Anda mungkin bertanya: "Bagaimana cara kerjanya?"  Sejauh ini - tidak bagaimana.  Properti tidak digunakan di tempat lain, tetapi ini bersifat sementara.  Pada satu titik, seseorang akan mulai menggunakannya dan pasti akan menerima hasil yang tidak terduga.  Untuk mencegah kesalahan ketik seperti itu, disarankan untuk tidak menggunakan pengidentifikasi yang hanya berbeda dalam hal huruf pertama. <br><br>  Komentar lain untuk konstruksi ini adalah menggunakan pengidentifikasi, yang sepenuhnya cocok dengan nama tipe <i>OnFailure</i> .  Dari sudut pandang kompiler, itu cukup dapat diterima, tetapi ini mempersulit persepsi kode untuk seseorang. <br><br>  Kesalahan serupa lainnya: <br><br>  <b>Peringatan PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3110</a> [CWE-674] Kemungkinan rekursi tak terbatas di dalam properti 'SSES3'.  AWSSDK.S3.Net45 InventoryEncryption.cs 37 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> SSES3 sSES3; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SSES3 SSES3 { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SSES3; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SSES3 = value; } }</code> </pre> <br>  Situasinya identik dengan yang dijelaskan di atas.  Namun, di sini rekursi tak terbatas akan terjadi ketika mengakses properti <i>SSES3</i> baik untuk membaca dan menugaskan.  Varian yang benar: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SSES3 SSES3 { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sSES3; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sSES3 = value; } }</code> </pre> <br>  <b>Tes dengan pertimbangan</b> <br><br>  Sekarang saya ingin mengutip tugas dari pengembang, diambil dengan menggunakan metode Copy-Paste.  Lihatlah cara kode terlihat di editor Visual Studio, dan cobalah untuk menemukan kesalahan. <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/bfa/71b/1ab/bfa71b1ab4af941c43e5349df51b1614.png" alt="Gambar 3"></p><br>  <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3029</a> Ekspresi kondisional dari pernyataan 'jika' yang terletak bersebelahan adalah identik.  Periksa baris: 91, 95. AWSSDK.AppSync.Net45 BuatApiKeyResponseUnmarshaller.cs 91 <br><br>  Saya mengurangi tubuh metode <i>UnmarshallException</i> , setelah menghapus semua yang tidak diperlukan.  Sekarang Anda dapat melihat bahwa pemeriksaan identik saling mengikuti: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override AmazonServiceException </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnmarshallException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errorResponse.Code != null &amp;&amp; errorResponse.Code.Equals(<span class="hljs-string"><span class="hljs-string">"LimitExceededException"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LimitExceededException(errorResponse.Message, innerException, errorResponse.Type, errorResponse.Code, errorResponse.RequestId, statusCode); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errorResponse.Code != null &amp;&amp; errorResponse.Code.Equals(<span class="hljs-string"><span class="hljs-string">"LimitExceededException"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LimitExceededException(errorResponse.Message, innerException, errorResponse.Type, errorResponse.Code, errorResponse.RequestId, statusCode); } .... }</code> </pre> <br>  Tampaknya bug itu tidak kasar - hanya pemeriksaan tambahan.  Namun demikian, sering kali pola seperti itu mengindikasikan masalah yang lebih serius dalam kode, ketika pemeriksaan yang diperlukan tidak akan dilakukan. <br><br>  Dalam kode tersebut, ada beberapa kesalahan serupa. <br><br>  <b>Peringatan PVS-Studio:</b> <br><br><ul><li>  V3029 Ekspresi kondisional dari pernyataan 'jika' yang terletak berdampingan adalah identik.  Periksa baris: 75, 79. AWSSDK.CloudDirectory.Net45 Buat SkemaResponseUnmarshaller.cs 75 </li><li>  V3029 Ekspresi kondisional dari pernyataan 'jika' yang terletak berdampingan adalah identik.  Periksa baris: 105, 109. AWSSDK.CloudDirectory.Net45 GetSchemaAsJsonResponseUnmarshaller.cs 105 </li><li>  V3029 Ekspresi kondisional dari pernyataan 'jika' yang terletak berdampingan adalah identik.  Periksa baris: 201, 205. AWSSDK.CodeCommit.Net45 PostCommentForPullRequestResponseUnmarshaller.cs 201 </li><li>  V3029 Ekspresi kondisional dari pernyataan 'jika' yang terletak berdampingan adalah identik.  Periksa baris: 101, 105. AWSSDK.CognitoIdentityProvider.Net45 VerifikasiSoftwareTokenResponseUnmarshaller.cs 101 </li><li>  V3029 Ekspresi kondisional dari pernyataan 'jika' yang terletak berdampingan adalah identik.  Periksa baris: 72, 76. Pembaruan AWSSDK.Glue.Net45ResponseUnmarshaller.cs 72 </li><li>  V3029 Ekspresi kondisional dari pernyataan 'jika' yang terletak berdampingan adalah identik.  Periksa baris: 123, 127. AWSSDK.Neptune.Net45 PulihkanDBClusterDariSnapshotResponseUnmarshaller.cs 123 </li><li>  V3029 Ekspresi kondisional dari pernyataan 'jika' yang terletak berdampingan adalah identik.  Periksa baris: 167, 171. AWSSDK.Neptune.Net45 PulihkanDBClusterDariSnapshotResponseUnmarshaller.cs 167 </li><li>  V3029 Ekspresi kondisional dari pernyataan 'jika' yang terletak berdampingan adalah identik.  Periksa baris: 127, 131. AWSSDK.RDS.Net45 PulihkanDBClusterDariSnapshotResponseUnmarshaller.cs 127 </li><li>  V3029 Ekspresi kondisional dari pernyataan 'jika' yang terletak berdampingan adalah identik.  Periksa baris: 171, 175. AWSSDK.RDS.Net45 PulihkanDBClusterDariSnapshotResponseUnmarshaller.cs 171 </li><li>  V3029 Ekspresi kondisional dari pernyataan 'jika' yang terletak berdampingan adalah identik.  Periksa baris: 99, 103. AWSSDK.Rekognition.Net45 Kenali SelebrasiResponseUnmarshaller.cs 99 </li></ul><br>  <b>Apa itu</b> <br><br>  <b>Peringatan PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3062</a> Objek 'atributName' digunakan sebagai argumen untuk metode sendiri.  Pertimbangkan untuk memeriksa argumen aktual pertama dari metode 'Berisi'.  AWSSDK.MobileAnalytics.Net45 CustomEvent.cs 261 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// &lt;summary&gt; /// Dictionary that stores attribute for this event only. /// &lt;/summary&gt; private Dictionary&lt;string,string&gt; _attributes = new Dictionary&lt;string,string&gt;(); /// &lt;summary&gt; /// Gets the attribute. /// &lt;/summary&gt; /// &lt;param name="attributeName"&gt;Attribute name.&lt;/param&gt; /// &lt;returns&gt;The attribute. Return null of attribute doesn't /// exist.&lt;/returns&gt; public string GetAttribute(string attributeName) { if(string.IsNullOrEmpty(attributeName)) { throw new ArgumentNullException("attributeName"); } string ret = null; lock(_lock) { if(attributeName.Contains(attributeName)) // &lt;= ret = _attributes[attributeName]; } return ret; }</span></span></code> </pre> <br>  Penganalisis telah mendeteksi kesalahan dalam metode <i>GetAttribute</i> : string diperiksa apakah mengandung itu sendiri.  Dari uraian metode, dapat diketahui bahwa jika nama atribut (kunci <i>atributName</i> ) ditemukan (dalam kamus <i>_attributes</i> ), nilai atribut harus dikembalikan, jika tidak - <i>null</i> .  Faktanya, karena condition <i>attributeName.Contains (atributName)</i> selalu benar, upaya dilakukan untuk mengembalikan nilai dengan kunci yang mungkin tidak ditemukan dalam kamus.  Kemudian, alih-alih mengembalikan <i>nol,</i> pengecualian <i>KeyNotFoundException</i> akan dibuang. <br><br>  Mari kita coba perbaiki kode ini.  Untuk memahami lebih baik bagaimana melakukan ini, Anda harus melihat metode lain: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// &lt;summary&gt; /// Determines whether this instance has attribute the specified /// attributeName. /// &lt;/summary&gt; /// &lt;param name="attributeName"&gt;Attribute name.&lt;/param&gt; /// &lt;returns&gt;Return true if the event has the attribute, else /// false.&lt;/returns&gt; public bool HasAttribute(string attributeName) { if(string.IsNullOrEmpty(attributeName)) { throw new ArgumentNullException("attributeName"); } bool ret = false; lock(_lock) { ret = _attributes.ContainsKey(attributeName); } return ret; }</span></span></code> </pre> <br>  Metode ini memeriksa apakah nama <i>atribut</i> (kunci <i>atributName</i> ) ada di kamus <i>_attributes</i> .  Mari kita kembali ke metode <i>GetAttribute</i> lagi dan memperbaiki kesalahan: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> attributeName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(attributeName)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-string"><span class="hljs-string">"attributeName"</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ret = null; lock(_lock) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_attributes.ContainsKey(attributeName)) ret = _attributes[attributeName]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre> <br>  Sekarang metode melakukan apa yang dinyatakan dalam deskripsi. <br><br>  Satu lagi komentar kecil untuk fragmen kode ini.  Saya perhatikan bahwa penulis menggunakan <i>kunci</i> ketika bekerja dengan kamus <i>_attributes</i> .  Jelas bahwa ini diperlukan ketika memiliki akses multithreaded, tetapi konstruksi <i>kunci</i> agak lambat dan rumit.  Alih-alih <i>Kamus</i> , dalam hal ini, mungkin, akan lebih mudah untuk menggunakan kamus versi thread-safe - <i>ConcurrentDictionary</i> .  Dengan cara ini, tidak perlu <i>terkunci.</i>  Meskipun, mungkin saya tidak tahu tentang spesifik proyek. <br><br>  <b>Perilaku mencurigakan</b> <br><br>  <b>Peringatan PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3063</a> [CWE-571] Bagian dari ekspresi kondisional selalu benar jika dievaluasi: string.IsNullOrEmpty (inferredIndexName).  AWSSDK.DynamoDBv2.PCL ContextInternal.cs 802 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetQueryIndexName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> inferredIndexName = null; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(specifiedIndexName) &amp;&amp; indexNames.Count == <span class="hljs-number"><span class="hljs-number">1</span></span>) { inferredIndexName = indexNames[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (indexNames.Contains(specifiedIndexName, StringComparer.Ordinal)) { inferredIndexName = specifiedIndexName; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(inferredIndexName) &amp;&amp; <span class="hljs-comment"><span class="hljs-comment">// &lt;= indexNames.Count &gt; 0) throw new InvalidOperationException("Local Secondary Index range key conditions are used but no index could be inferred from model. Specified index name = " + specifiedIndexName); .... }</span></span></code> </pre> <br>  Penganalisa khawatir tentang <i>string</i> cek. <i>IsNullOrEmpty (disimpulkanIndexName)</i> .  Memang, string <i>inferredIndexName</i> ditugaskan <i>nol</i> , maka nilai variabel ini tidak berubah di mana pun, maka karena alasan tertentu diperiksa untuk <i>null</i> atau string kosong.  Terlihat mencurigakan.  Mari kita lihat lebih dekat fragmen kode di atas.  Saya sengaja tidak menguranginya untuk memahami situasi dengan lebih baik.  Jadi, dalam pernyataan <i>if</i> pertama (dan juga yang berikutnya), variabel yang <i>ditentukanIndexName</i> entah bagaimana diperiksa.  Bergantung pada hasil pemeriksaan, variabel <i>inferredIndexName</i> mendapatkan nilai baru.  Sekarang mari kita lihat pernyataan <i>if</i> ketiga.  Badan pernyataan ini (melempar pengecualian) akan dilakukan jika <i>indexNames.Count&gt; 0,</i> sebagai bagian pertama dari seluruh kondisi, yaitu <i>string. IsNullOrEmpty (inferredIndexName)</i> selalu benar.  Mungkin, variabel yang <i>ditentukanIndexName</i> dan <i>disimpulkanIndexName</i> digabungkan atau cek ketiga harus tanpa yang <i>lain</i> , mewakili pernyataan mandiri <i>jika</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(specifiedIndexName) &amp;&amp; indexNames.Count == <span class="hljs-number"><span class="hljs-number">1</span></span>) { inferredIndexName = indexNames[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (indexNames.Contains(specifiedIndexName, StringComparer.Ordinal)) { inferredIndexName = specifiedIndexName; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(inferredIndexName) &amp;&amp; indexNames.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(....);</code> </pre> <br>  Dalam hal ini, sulit untuk memberikan jawaban yang pasti tentang opsi untuk memperbaiki kode ini.  Bagaimanapun, penulis perlu memeriksanya. <br><br>  <b>NullReferenceException</b> <br><br>  <b>Peringatan PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3095</a> [CWE-476] Objek 'conditionValues' digunakan sebelum diverifikasi terhadap nol.  Periksa baris: 228, 238. AWSSDK.Core.Net45 JsonPolicyWriter.cs 228 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeConditions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (....) { IList&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; conditionValues = keyEntry.Value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conditionValues.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// &lt;= continue; .... if (conditionValues != null &amp;&amp; conditionValues.Count != 0) { .... } .... } }</span></span></code> </pre> <br>  Ini klasik.  Variabel <i>conditionValues</i> digunakan tanpa pemeriksaan awal untuk <i>null</i> .  Sementara nanti dalam kode pemeriksaan ini dilakukan.  Kode perlu diperbaiki sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeConditions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (....) { IList&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; conditionValues = keyEntry.Value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conditionValues != null &amp;&amp; conditionValues.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conditionValues != null &amp;&amp; conditionValues.Count != <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... } .... } }</code> </pre> <br>  Saya menemukan beberapa kesalahan serupa dalam kode. <br><br>  <b>Peringatan PVS-Studio:</b> <br><br><ul><li>  V3095 [CWE-476] Objek 'ts.Listeners' digunakan sebelum diverifikasi terhadap nol.  Periksa baris: 140, 143. AWSSDK.Core.Net45 Logger.Diagnostic.cs 140 </li><li>  V3095 [CWE-476] Objek 'obj' digunakan sebelum diverifikasi terhadap null.  Periksa baris: 743, 745. AWSSDK.Core.Net45 JsonMapper.cs 743 </li><li>  V3095 [CWE-476] Objek 'multipartUploadMultipartUploadpartsList' digunakan sebelum diverifikasi terhadap nol.  Periksa baris: 65, 67. AWSSDK.S3.Net45 LengkapMultipartUploadRequestMarshaller.cs 65 </li></ul><br>  Peringatan berikut sangat mirip artinya, tetapi kasusnya berlawanan dengan yang dibahas di atas. <br><br>  <b>Peringatan PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3125</a> [CWE-476] Objek 'state' digunakan setelah diverifikasi terhadap null.  Periksa baris: 139, 127. AWSSDK.Core.Net45 RefreshingAWSCredentials.cs 139 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateToGeneratedCredentials</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( CredentialsRefreshState state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> errorMessage; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ShouldUpdate) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == null) errorMessage = <span class="hljs-string"><span class="hljs-string">"Unable to generate temporary credentials"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AmazonClientException(errorMessage); } state.Expiration -= PreemptExpiryTime; <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br>  Salah satu fragmen kode termasuk memeriksa nilai variabel <i>keadaan</i> untuk <i>null</i> .  Dalam kode di bawah ini, variabel digunakan untuk berhenti berlangganan dari acara <i>PreemptExpiryTime</i> , namun, pemeriksaan untuk <i>null</i> tidak lagi dilakukan dan melempar pengecualian <i>NullReferenceException</i> menjadi mungkin.  Versi kode yang lebih aman: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateToGeneratedCredentials</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( CredentialsRefreshState state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> errorMessage; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ShouldUpdate) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == null) errorMessage = <span class="hljs-string"><span class="hljs-string">"Unable to generate temporary credentials"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AmazonClientException(errorMessage); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state != null) state.Expiration -= PreemptExpiryTime; .... }</code> </pre> <br>  Dalam kode, ada kesalahan serupa lainnya: <br><br>  <b>Peringatan PVS-Studio:</b> <br><br><ul><li>  V3125 [CWE-476] Objek 'wrapRequest.Content' digunakan setelah diverifikasi terhadap nol.  Periksa baris: 395, 383. AWSSDK.Core.Net45 HttpHandler.cs 395 </li><li>  V3125 [CWE-476] Objek 'datasetUpdates' digunakan setelah diverifikasi terhadap nol.  Periksa baris: 477, 437. AWSSDK.CognitoSync.Net45 Dataset.cs 477 </li><li>  V3125 [CWE-476] Objek 'cORSConfigurationCORSConfigurationcORSRulesListValue' digunakan setelah diverifikasi terhadap nol.  Periksa baris: 125, 111. AWSSDK.S3.Net45 PutCORSConfigurationRequestMarshaller.cs 125 </li><li>  V3125 [CWE-476] Objek 'lifecycleConfigurationLifecycleConfigurationrulesListValue' digunakan setelah diverifikasi terhadap nol.  Periksa baris: 157, 68. AWSSDK.S3.Net45 PutLifecycleConfigurationRequestMarshaller.cs 157 </li><li>  V3125 [CWE-476] Objek 'this.Key' digunakan setelah diverifikasi terhadap null.  Periksa baris: 199, 183. AWSSDK.S3.Net45 S3PostUploadRequest.cs 199 </li></ul><br>  <b>Realitas non-alternatif</b> <br><br>  <b>Peringatan PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3009</a> [CWE-393] Aneh bahwa metode ini selalu mengembalikan satu dan nilai yang sama dari 'benar'.  AWSSDK.Core.Net45 Lexer.cs 651 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State19</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'"'</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'\\'</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Metode ini selalu mengembalikan <i>true</i> .  Mari kita lihat betapa pentingnya kode panggilan.  Saya memeriksa kasus-kasus menggunakan metode <i>State19</i> .  Ini terlibat dalam mengisi array handler <i>fsm_handler_table</i> sama dengan metode serupa lainnya (masing-masing ada 28 di antaranya dengan nama, mulai dari <i>State1</i> ke <i>State28</i> ).  Di sini penting untuk dicatat bahwa, selain <i>State19</i> , untuk beberapa penangan lainnya peringatan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3009</a> [CWE-393] juga dikeluarkan.  Ini adalah penangan: <i>State23, State26, State27, State28</i> .  Peringatan, yang dikeluarkan oleh penganalisa untuk mereka: <br><br><ul><li>  V3009 [CWE-393] Aneh bahwa metode ini selalu mengembalikan satu dan nilai 'benar' yang sama.  AWSSDK.Core.Net45 Lexer.cs 752 </li><li>  V3009 [CWE-393] Aneh bahwa metode ini selalu mengembalikan satu dan nilai 'benar' yang sama.  AWSSDK.Core.Net45 Lexer.cs 810 </li><li>  V3009 [CWE-393] Aneh bahwa metode ini selalu mengembalikan satu dan nilai 'benar' yang sama.  AWSSDK.Core.Net45 Lexer.cs 822 </li><li>  V3009 [CWE-393] Aneh bahwa metode ini selalu mengembalikan satu dan nilai 'benar' yang sama.  AWSSDK.Core.Net45 Lexer.cs 834 </li></ul><br>  Berikut adalah cara deklarasi dan inisialisasi array dari penangan terlihat seperti: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StateHandler[] fsm_handler_table; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PopulateFsmTables</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ fsm_handler_table = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StateHandler[<span class="hljs-number"><span class="hljs-number">28</span></span>] { State1, State2, .... State19, .... State23, .... State26, State27, State28 };</code> </pre> <br>  Untuk melengkapi gambar, mari kita lihat kode salah satu penangan yang belum <i>dianalisis oleh penganalisa</i> , misalnya, <i>State2</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State2</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  Inilah cara terjadinya panggilan penangan: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextToken</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { handler = fsm_handler_table[state - <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (! handler (fsm_context)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= throw new JsonException (input_char); .... } .... }</span></span></code> </pre> <br>  Seperti yang bisa kita lihat, pengecualian akan dilemparkan untuk mengembalikan <i>kesalahan</i> .  Dalam kasus kami, untuk penangan <i>State19, State23, State26 State27</i> dan <i>State28</i> ini tidak akan pernah terjadi.  Terlihat mencurigakan.  Di sisi lain, lima penangan memiliki perilaku yang sama (akan selalu kembali <i>benar</i> ), jadi mungkin itu sangat dibuat-buat dan bukan hasil kesalahan ketik. <br><br>  Mengapa saya begitu terlibat dalam semua ini?  Situasi ini sangat signifikan dalam arti bahwa analisa statis sering hanya dapat mengindikasikan konstruksi yang mencurigakan.  Dan bahkan seseorang (bukan mesin), yang tidak memiliki pengetahuan yang cukup tentang proyek tersebut, masih belum dapat memberikan jawaban penuh tentang adanya kesalahan, bahkan setelah menghabiskan waktu mempelajari kode.  Pengembang harus meninjau kode ini. <br><br>  <b>Cek tidak berarti</b> <br><br>  <b>Peringatan PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3022</a> [CWE-571] Ekspresi 'doLog' selalu benar.  AWSSDK.Core.Net45 StoredProfileAWSCredentials.cs 235 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidCredentialsExistInSharedFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... var doLog = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { doLog = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InvalidDataException) { doLog = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (doLog) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { .... } .... }</span></span></code> </pre> <br>  Perhatikan variabel <i>doLog</i> .  Setelah inisialisasi dengan nilai <i>palsu</i> , variabel ini akan mendapatkan nilai <i>sebenarnya</i> dalam semua kasus lebih lanjut di sepanjang kode.  Oleh karena itu, periksa <i>apakah (doLog)</i> selalu benar.  Mungkin, sebelumnya dalam metode ada cabang, di mana variabel <i>doLog</i> tidak diberi nilai apa pun.  Pada saat pengecekan dapat berisi nilai <i>palsu</i> , yang diterima saat inisialisasi.  Tetapi sekarang tidak ada cabang seperti itu. <br><br>  Kesalahan serupa lainnya: <br><br>  <b>Peringatan PVS-Studio:</b> Ekspresi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3022</a> '! Hasil' selalu salah.  AWSSDK.CognitoSync.PCL SQLiteLocalStorage.cs 353 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PutValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = PutValueHelper(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!result) &lt;= { _logger.DebugFormat(<span class="hljs-string"><span class="hljs-string">"{0}"</span></span>, @<span class="hljs-string"><span class="hljs-string">"Cognito Sync - SQLiteStorage - Put Value Failed"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { UpdateLastModifiedTimestamp(....); } .... }</code> </pre> <br>  Penganalisa mengklaim bahwa nilai variabel <i>hasil</i> selalu benar.  Mungkin hanya dalam kasus jika metode <i>PutValueHelper</i> akan selalu mengembalikan <i>true</i> .  Lihatlah metode ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PutValueHelper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (record == null) { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br>  Memang, metode ini akan mengembalikan <i>true</i> dalam semua kondisi.  Selain itu, penganalisa telah mengeluarkan peringatan untuk metode ini.  <b>Peringatan PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3009</a> [CWE-393] Aneh bahwa metode ini selalu mengembalikan satu dan nilai yang sama dari 'benar'.  SQLiteLocalStorage.cs 1016 <br><br>  Saya sengaja tidak mengutip peringatan ini sebelumnya ketika saya menanyakan bug <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3009 lainnya</a> dan menyimpannya untuk kasus ini.  Dengan demikian, alat itu benar untuk menunjukkan kesalahan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3022</a> dalam kode panggilan. <br><br>  <b>Salin-tempel.</b>  <b>Lagi</b> <br><br>  <b>Peringatan PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3001</a> Ada sub-ekspresi identik 'this.token == JsonToken.String' di sebelah kiri dan di sebelah kanan '||'  operator.  AWSSDK.Core.Net45 JsonReader.cs 343 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.token == JsonToken.ObjectEnd || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.token == JsonToken.ArrayEnd || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.token == JsonToken.String || <span class="hljs-comment"><span class="hljs-comment">// &lt;= this.token == JsonToken.Boolean || this.token == JsonToken.Double || this.token == JsonToken.Int || this.token == JsonToken.UInt || this.token == JsonToken.Long || this.token == JsonToken.ULong || this.token == JsonToken.Null || this.token == JsonToken.String // &lt;= )) { .... } .... }</span></span></code> </pre> <br>  Bidang <i>this.token</i> dibandingkan dua kali dengan nilai <i>JsonToken.String</i> dari enumerasi <i>JsonToken</i> .  Mungkin, salah satu perbandingan harus berisi nilai enumerasi lain.  Jika demikian, kesalahan serius telah dibuat di sini. <br><br>  <b>Refactoring + kekurangan perhatian?</b> <br><br>  <b>Peringatan PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3025</a> [CWE-685] Format salah.  Jumlah item format yang berbeda diharapkan saat memanggil fungsi 'Format'.  Argumen tidak digunakan: AWSConfigs.AWSRegionKey.  AWSSDK.Core.Net45 AWSRegion.cs 116 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InstanceProfileAWSRegion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Format(CultureInfo.InvariantCulture, <span class="hljs-string"><span class="hljs-string">"EC2 instance metadata was not available or did not contain region information."</span></span>, AWSConfigs.AWSRegionKey)); } .... }</code> </pre> <br>  Mungkin, format string untuk metode <i>string.Format</i> sebelumnya berisi item format <i>{0},</i> yang mana argumen <i>AWSConfigs.AWSRegionKey</i> ditetapkan.  Kemudian string diubah, item format hilang, tetapi pengembang lupa untuk menghapus argumen.  Contoh kode yang diberikan bekerja tanpa kesalahan (pengecualian dilemparkan dalam kasus yang berlawanan - item format tanpa argumen), tetapi terlihat tidak bagus.  Kode harus diperbaiki sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( <span class="hljs-string"><span class="hljs-string">"EC2 instance metadata was not available or did not contain region information."</span></span>); }</code> </pre> <br>  <b>Tidak aman</b> <br><br>  <b>Peringatan PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3083</a> [CWE-367] Doa yang tidak aman dari acara 'mOnSyncSuccess', NullReferenceException dimungkinkan.  Pertimbangkan menugaskan acara ke variabel lokal sebelum menjalankannya.  AWSSDK.CognitoSync.PCL Dataset.cs 827 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FireSyncSuccessEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Record&gt; records)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mOnSyncSuccess != null) { mOnSyncSuccess(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SyncSuccessEventArgs(records)); } }</code> </pre> <br>  Situasi umum dari panggilan yang tidak aman dari pengendali acara.  Seorang pengguna dapat berhenti berlangganan antara pemeriksaan variabel <i>mOnSyncSuccess</i> untuk <i>null</i> dan pemanggilan seorang penangan, sehingga nilainya akan menjadi <i>nol</i> .  Kemungkinan skenario seperti itu kecil, tetapi masih lebih baik untuk membuat kode lebih aman: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FireSyncSuccessEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Record&gt; records)</span></span></span><span class="hljs-function"> </span></span>{ mOnSyncSuccess?.Invoke(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SyncSuccessEventArgs(records)); }</code> </pre> <br>  Dalam kode, ada kesalahan serupa lainnya: <br><br>  <b>Peringatan PVS-Studio:</b> <br><br><ul><li>  V3083 [CWE-367] Doa yang tidak aman dari acara 'mOnSyncFailure', NullReferenceException dimungkinkan.  Pertimbangkan menugaskan acara ke variabel lokal sebelum menjalankannya.  AWSSDK.CognitoSync.PCL Dataset.cs 839 </li><li>  V3083 [CWE-367] Doa acara tidak aman, NullReferenceException dimungkinkan.  Pertimbangkan menugaskan acara ke variabel lokal sebelum menjalankannya.  AWSSDK.Core.PCL AmazonServiceClient.cs 332 </li><li>  V3083 [CWE-367] Doa acara tidak aman, NullReferenceException dimungkinkan.  Pertimbangkan menugaskan acara ke variabel lokal sebelum menjalankannya.  AWSSDK.Core.PCL AmazonServiceClient.cs 344 </li><li>  V3083 [CWE-367] Doa acara tidak aman, NullReferenceException dimungkinkan.  Pertimbangkan menugaskan acara ke variabel lokal sebelum menjalankannya.  AWSSDK.Core.PCL AmazonServiceClient.cs 357 </li><li>  V3083 [CWE-367] Doa yang tidak aman dari acara 'mExceptionEvent', NullReferenceException dimungkinkan.  Pertimbangkan menugaskan acara ke variabel lokal sebelum menjalankannya.  AWSSDK.Core.PCL AmazonServiceClient.cs 366 </li><li>  V3083 [CWE-367] Doa acara tidak aman, NullReferenceException dimungkinkan.  Pertimbangkan menugaskan acara ke variabel lokal sebelum menjalankannya.  AWSSDK.Core.PCL AmazonWebServiceRequest.cs 78 </li><li>  V3083 [CWE-367] Doa yang tidak aman dari acara 'OnRead', NullReferenceException dimungkinkan.  Pertimbangkan menugaskan acara ke variabel lokal sebelum menjalankannya.  AWSSDK.Core.PCL EventStream.cs 97 </li><li>  V3083 [CWE-367] Doa acara tidak aman, NullReferenceException dimungkinkan.  Pertimbangkan menugaskan acara ke variabel lokal sebelum menjalankannya.  AWSSDK.Core.Android NetworkReachability.cs 57 </li><li>  V3083 [CWE-367] Doa acara tidak aman, NullReferenceException dimungkinkan.  Pertimbangkan menugaskan acara ke variabel lokal sebelum menjalankannya.  AWSSDK.Core.Android NetworkReachability.cs 94 </li><li>  V3083 [CWE-367] Doa acara tidak aman, NullReferenceException dimungkinkan.  Pertimbangkan menugaskan acara ke variabel lokal sebelum menjalankannya.  AWSSDK.Core.iOS NetworkReachability.cs 54 </li></ul><br>  <b>Kelas kasar</b> <br><br>  <b>Peringatan PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3126</a> Ketik 'JsonData' yang mengimplementasikan antarmuka &lt;qu&gt; IEquatable tidak menggantikan metode 'GetHashCode'.  AWSSDK.Core.Net45 JsonData.cs 26 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonData</span></span></span><span class="hljs-class"> :</span></span> IJsonWrapper, IEquatable&lt;JsonData&gt; { .... }</code> </pre> <br>  Kelas <i>JsonData</i> berisi cukup banyak kode, jadi saya tidak memberikannya secara keseluruhan, hanya mengutip deklarasi.  Kelas ini benar-benar tidak mengandung metode yang diganti <i>GetHashCode,</i> yang tidak aman, karena dapat menyebabkan perilaku yang salah ketika menggunakan tipe <i>JsonData</i> untuk bekerja, misalnya, dengan koleksi.  Mungkin, tidak ada masalah saat ini, tetapi di masa depan jenis strategi ini mungkin berubah.  Kesalahan ini dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> lebih terinci. <br><br>  <b>Kesimpulan</b> <br><br>  Ini semua adalah bug menarik yang saya dapat mendeteksi dalam kode AWS SDK untuk .NET menggunakan penganalisa statis PVS-Studio.  Saya ingin menyoroti sekali lagi kualitas proyek.  Saya menemukan sejumlah kecil kesalahan untuk 5 juta baris kode.  Meskipun mungkin analisis yang lebih menyeluruh dari peringatan yang dikeluarkan akan membiarkan saya menambahkan beberapa kesalahan lagi ke daftar ini.  Namun demikian, sangat mungkin bahwa saya menambahkan beberapa peringatan untuk kesalahan tanpa biaya.  Kesimpulan yang tidak ambigu dalam hal ini selalu dibuat hanya oleh pengembang yang berada dalam konteks kode yang diperiksa. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id437514/">https://habr.com/ru/post/id437514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id437502/index.html">Saya akan berhenti membuang yang baik di tempat sampah</a></li>
<li><a href="../id437504/index.html">Komponen kecil: apa yang bisa salah? Kami menggunakan prinsip tanggung jawab tunggal</a></li>
<li><a href="../id437508/index.html">CVE-2019-6111 dan kerentanan scp lainnya</a></li>
<li><a href="../id437510/index.html">Apa yang terjadi ketika Anda mengirim SMS</a></li>
<li><a href="../id437512/index.html">Apa fungsi murni dalam JavaScript?</a></li>
<li><a href="../id437516/index.html">Mencari bug di Amazon Web Services SDK untuk kode sumber .NET</a></li>
<li><a href="../id437518/index.html">Serangan kumbang</a></li>
<li><a href="../id437520/index.html">‚ÄúCahaya saya adalah cermin! - katakan, tunjukkan dualis saya ... ": desain satu kerangka kerja yang bagus dan dapatkan yang kedua sebagai hadiah</a></li>
<li><a href="../id437522/index.html">Koloni. Bab 22: Keputusan Akhir</a></li>
<li><a href="../id437524/index.html">Buat Catur AI Sederhana: 5 Langkah Mudah</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>