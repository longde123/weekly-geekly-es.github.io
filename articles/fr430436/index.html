<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ôüèª üì≥ üíÆ Vers QUIC: ce qui sous-tend HTTP / 3 üòö üèì üë®üèª‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Une nouvelle √©tape importante dans l'histoire d'Internet commence sous nos yeux: nous pouvons supposer que HTTP / 3 a d√©j√† √©t√© annonc√©. Fin octobre, M...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vers QUIC: ce qui sous-tend HTTP / 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/Voximplant/blog/430436/"> Une nouvelle √©tape importante dans l'histoire d'Internet commence sous nos yeux: nous pouvons supposer que HTTP / 3 a d√©j√† √©t√© annonc√©.  Fin octobre, Mark Nottingham de l'IETF a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sugg√©r√© de d√©j√† d√©cider d'un nom</a> pour le nouveau protocole sur lequel l'IETF s'est construit depuis 2015.  Ainsi, au lieu de noms de type QUIC, un fort HTTP / 3 est apparu.  Les publications occidentales ont d√©j√† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://daniel.haxx.se/blog/tag/">√©crit √† ce sujet</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://www.zdnet.com/article/http-over-quic-to-be-renamed-">plus d'une fois</a> .  L'histoire de QUIC a commenc√© dans les entrailles de Good Corporation en 2012, car seuls les serveurs de Google prenaient en charge les connexions HTTP sur QUIC, mais le temps passe et Facebook a d√©j√† commenc√© √† mettre en ≈ìuvre cette technologie (le 7 novembre, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Facebook</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LiteSpeed ‚Äã‚Äãont</a> fait la premi√®re interaction via HTTP / 3 );  Actuellement, la part des sites prenant en charge QUIC est de 1,2%.  Enfin, le groupe de travail WebRTC se tourne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©galement vers QUIC</a> (plus voir l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">API QUIC</a> ), donc dans un avenir pr√©visible, la vid√©o / audio en temps r√©el passera par QUIC au lieu de RTP / RTCP.  Par cons√©quent, nous avons d√©cid√© qu'il serait formidable de r√©v√©ler les d√©tails de l'IETF QUIC: sp√©cialement pour Habr, nous avons pr√©par√© une traduction du longread dotting i.  Profitez-en! <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/r4/ee/3s/r4ee3svcbqzrlxwfzuajri7go04.png"></div><a name="habracut"></a><br>  QUIC (Quick UDP Internet Connections) est un nouveau protocole de couche de transport par d√©faut chiffr√© qui comporte de nombreuses am√©liorations HTTP: √† la fois pour acc√©l√©rer le trafic et augmenter la s√©curit√©.  QUIC a √©galement un objectif √† long terme: remplacer √©ventuellement TCP et TLS.  Dans cet article, nous examinerons √† la fois les puces QUIC cl√©s et les raisons pour lesquelles le Web en b√©n√©ficiera, ainsi que les probl√®mes de prise en charge de ce tout nouveau protocole. <br><br>  En fait, il existe deux protocoles du m√™me nom: Google QUIC (gQUIC), le protocole original d√©velopp√© par les ing√©nieurs de Google il y a plusieurs ann√©es, qui, apr√®s une s√©rie d'exp√©riences, a √©t√© adopt√© par l'Internet Engineering Task Force (IETF) pour la normalisation. <br><br>  IETF QUIC (ci-apr√®s simplement QUIC) pr√©sente d√©j√† des diff√©rences si fortes avec gQUIC qu'il peut √™tre consid√©r√© comme un protocole distinct.  Du format de package √† la prise de contact et au mappage HTTP, QUIC a am√©lior√© l'architecture gQUIC d'origine en collaborant avec de nombreuses organisations et d√©veloppeurs qui ont un objectif commun: rendre Internet plus rapide et plus s√©curis√©. <br><br>  Alors, quelles am√©liorations offre QUIC? <br><br><h2>  S√©curit√© int√©gr√©e (et performances) </h2><br>  L'une des diff√©rences les plus notables entre QUIC et TCP v√©n√©rable est l'objectif d√©clar√© √† l'origine d'√™tre un protocole de transport <b>s√©curis√© par d√©faut</b> .  QUIC y parvient en utilisant l'authentification et le chiffrement, qui se produisent g√©n√©ralement √† un niveau sup√©rieur (par exemple, dans TLS), et non dans le protocole de transport lui-m√™me. <br><br>  La prise de contact QUIC originale combine la communication √† trois voies habituelle sur TCP avec la prise de contact TLS 1.3, qui fournit l'authentification des participants, ainsi que la coordination des param√®tres cryptographiques.  Pour ceux qui connaissent TLS: QUIC remplace le niveau d'enregistrement TLS par son propre format de trame, mais utilise en m√™me temps des poign√©es de main TLS. <br><br>  Cela permet non seulement √† la connexion d'√™tre toujours crypt√©e et authentifi√©e, mais aussi plus rapidement pour √©tablir la connexion initiale: une poign√©e de main QUIC ordinaire effectue l'√©change entre le client et le serveur en une seule passe, tandis que TCP + TLS 1.3 effectue deux passes. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h2/lq/o4/h2lqo4o2itthtb_h7qopgt7kbc4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/g6/ne/vg/g6nevg964eqgvmzillfvnet3lus.png"></div><br>  Cependant, QUIC va plus loin et crypte √©galement les m√©tadonn√©es de connexion qui peuvent √™tre facilement compromises par un tiers.  Par exemple, les attaquants peuvent utiliser des num√©ros de paquets pour diriger les utilisateurs sur plusieurs chemins r√©seau lorsque la migration de connexion est utilis√©e (voir ci-dessous).  QUIC chiffre les num√©ros de paquets, de sorte qu'ils ne peuvent √™tre corrig√©s par personne d'autre que les vrais participants √† la connexion. <br><br>  Le chiffrement peut √©galement √™tre efficace contre la ¬´stagnation¬ª - un ph√©nom√®ne qui ne permet pas d'utiliser la flexibilit√© du protocole en raison d'hypoth√®ses incorrectes dans les impl√©mentations (ossification - c'est pourquoi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TLS 1.3 a √©t√©</a> pr√©sent√© pendant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">longtemps</a> . Nous ne l'avons publi√© qu'apr√®s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">quelques modifications</a> qui emp√™cher les blocs ind√©sirables pour les nouvelles r√©visions TLS). <br><br><h2>  Blocage du d√©but de la file d'attente (blocage en t√™te de ligne) </h2><br>  L'une des principales am√©liorations apport√©es par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://blog.cloudflare.com/introducing-">HTTP / 2</a> est la possibilit√© de combiner diff√©rentes requ√™tes HTTP dans une seule connexion TCP.  Cela permet aux applications HTTP / 2 de traiter les demandes en parall√®le et de mieux utiliser le canal r√©seau. <br><br>  Bien s√ªr, ce fut un pas en avant significatif.  Parce que les applications ant√©rieures devaient initier de nombreuses connexions TCP + TLS si elles voulaient traiter plusieurs requ√™tes HTTP en m√™me temps (par exemple, lorsque le navigateur doit recevoir √† la fois CSS et JavaScript pour afficher la page).  La cr√©ation de nouvelles connexions n√©cessite plusieurs prises de contact, ainsi que l'initialisation de la fen√™tre de surcharge: cela signifie ralentir le rendu de la page.  Les requ√™tes HTTP combin√©es √©vitent cela. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lj/rc/lb/ljrclbypotymwhoajopsze57jry.jpeg"></div><br><br>  Cependant, il y a un inconv√©nient: puisque plusieurs requ√™tes / r√©ponses sont transmises sur la m√™me connexion TCP, elles d√©pendent toutes √©galement de la perte de paquets, m√™me si les donn√©es perdues ne concernent qu'une seule des requ√™tes.  Cela s'appelle "bloquer le d√©but de la file d'attente". <br><br>  QUIC va plus loin et fournit un support de premi√®re classe pour combiner les demandes, par exemple, diff√©rentes demandes HTTP peuvent √™tre consid√©r√©es comme des demandes QUIC de transport diff√©rentes, mais en m√™me temps, elles utiliseront toutes la m√™me connexion QUIC - c'est-√†-dire que des poign√©es de main suppl√©mentaires ne sont pas n√©cessaires, il y en a une √©tat d'encombrement, les demandes QUIC sont d√©livr√©es ind√©pendamment - par cons√©quent, dans la plupart des cas, la perte de paquets affecte une seule demande. <br><br>  Ainsi, il est possible de r√©duire consid√©rablement le temps, par exemple, pour le rendu complet d'une page Web (CSS, JavaScript, images et autres ressources), en particulier dans le cas d'un r√©seau surcharg√© avec une perte de paquets √©lev√©e. <br><br><h2>  Si simple, hein? </h2><br>  Pour tenir sa promesse, le protocole QUIC doit surmonter certaines des hypoth√®ses que de nombreuses applications r√©seau tiennent pour acquises.  Cela peut compliquer la mise en ≈ìuvre et la mise en ≈ìuvre de QUIC. <br><br>  QUIC est con√ßu pour √™tre livr√© sur des datagrammes UDP afin de faciliter le d√©veloppement et d'√©viter les probl√®mes avec les p√©riph√©riques r√©seau qui abandonnent les paquets de protocoles inconnus (car la plupart des p√©riph√©riques prennent en charge UDP).  Il permet √©galement √† QUIC de vivre dans l'espace utilisateur. Ainsi, par exemple, les navigateurs pourront impl√©menter de nouvelles fonctionnalit√©s de protocole et les transmettre aux utilisateurs finaux, sans attendre les mises √† jour du syst√®me d'exploitation. <br><br>  Cependant, le bon objectif de r√©duire les probl√®mes de r√©seau rend plus difficile la protection des paquets et leur acheminement correct. <br><br><h2>  Un NAT pour se r√©unir tous ensemble et s'unir avec une seule volont√© noire </h2><br>  En r√®gle g√©n√©rale, les routeurs NAT fonctionnent avec des connexions TCP en utilisant un tuple de 4 valeurs (IP source et port plus IP et port de destination), ainsi que la surveillance des paquets TCP SYN, ACK et FIN transmis sur le r√©seau;  les routeurs peuvent d√©terminer quand une nouvelle connexion est √©tablie et quand elle s'est termin√©e.  Par cons√©quent, une gestion pr√©cise des liaisons NAT (communications entre IP et ports internes et externes) est possible. <br><br>  Dans le cas de QUIC, ce n'est pas encore possible, car  les routeurs NAT modernes ne connaissent pas encore QUIC, donc ils r√©trogradent g√©n√©ralement vers un traitement UDP par d√©faut et moins pr√©cis, ce qui signifie des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©lais d'expiration arbitraires (parfois courts)</a> , ce qui peut affecter les connexions √† long terme. <br><br>  Lorsqu'une nouvelle liaison se produit (par exemple, en raison d'un d√©lai d'attente), le p√©riph√©rique en dehors du p√©rim√®tre NAT commence √† recevoir des paquets d'une autre source, ce qui rend impossible de maintenir la connexion en utilisant uniquement un tuple de 4 valeurs. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xg/ze/kz/xgzekzn8kq0nhe9--wkbotrxxmq.png"></div><br><br>  Et ce n'est pas seulement NAT!  Une fonctionnalit√© QUIC est appel√©e migration de connexion et permet aux appareils de transf√©rer des connexions vers d'autres adresses / chemins IP √† leur discr√©tion.  Par exemple, un client mobile pourra transf√©rer une connexion QUIC d'un r√©seau mobile vers un r√©seau WiFi d√©j√† connu (l'utilisateur a entr√© un caf√© pr√©f√©r√©, etc.). <br><br>  QUIC essaie de r√©soudre ce probl√®me avec le concept d'ID de connexion: une information de longueur arbitraire, transmise en paquets QUIC et permettant d'identifier la connexion.  Les appareils d'extr√©mit√© peuvent utiliser cet ID pour suivre leurs connexions sans se r√©concilier avec le tuple.  En pratique, il devrait y avoir de nombreux ID pointant vers la m√™me connexion, par exemple, pour √©viter de connecter des chemins diff√©rents lorsque la connexion est migr√©e, car l'ensemble du processus est contr√¥l√© uniquement par les p√©riph√©riques finaux et non par les bo√Ætiers de m√©diation. <br><br>  Cependant, il peut y avoir un probl√®me pour les op√©rateurs de t√©l√©communications qui utilisent anycast et le routage ECMP, o√π une adresse IP peut potentiellement identifier des centaines ou des milliers de serveurs.  √âtant donn√© que les routeurs frontaliers de ces r√©seaux ne savent pas encore comment traiter le trafic QUIC, il peut arriver que des paquets UDP provenant de la m√™me connexion QUIC, mais avec des tuples diff√©rents, soient envoy√©s √† diff√©rents serveurs, ce qui signifie une d√©connexion. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d4/vq/us/d4vqusefrkw1ideoglo-_heq8py.png"></div><br><br>  Pour √©viter cela, les op√©rateurs peuvent avoir besoin d'impl√©menter un √©quilibreur de niveau plus intelligent.  Cela peut √™tre r√©alis√© par programme sans affecter les routeurs frontaliers eux-m√™mes (par exemple, voir le projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Katran</a> de Facebook). <br><br><h2>  Qpack </h2><br>  Une autre fonctionnalit√© utile de HTTP / 2 √©tait la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://blog.cloudflare.com/hpack-the-silent-killer-feature-of-">compression d'en-t√™te (HPACK)</a> , qui permet aux terminaux de r√©duire la taille des donn√©es envoy√©es en supprimant les demandes et r√©ponses inutiles. <br><br>  En particulier, entre autres techniques, HPACK utilise des tables dynamiques avec des en-t√™tes qui ont d√©j√† √©t√© envoy√©s / re√ßus √† partir de demandes / r√©ponses HTTP pr√©c√©dentes, ce qui permet aux appareils de se r√©f√©rer dans de nouvelles demandes / r√©ponses aux en-t√™tes rencontr√©s pr√©c√©demment (au lieu de les renvoyer) . <br><br>  Les tables HPACK doivent √™tre synchronis√©es entre l'encodeur (la partie qui envoie la demande / la r√©ponse) et le d√©codeur (le c√¥t√© r√©cepteur), sinon le d√©codeur ne peut tout simplement pas d√©coder ce qu'il re√ßoit. <br><br>  Dans le cas de HTTP / 2 sur TCP, cette synchronisation est transparente car la couche de transport (TCP) d√©livre les requ√™tes / r√©ponses dans le m√™me ordre dans lequel elles ont √©t√© envoy√©es.  Autrement dit, vous pouvez envoyer des instructions au d√©codeur pour mettre √† jour les tables dans une simple demande / r√©ponse.  Mais avec QUIC, les choses sont beaucoup plus compliqu√©es. <br><br>  QUIC peut livrer plusieurs requ√™tes / r√©ponses HTTP dans diff√©rentes directions en m√™me temps, ce qui signifie que QUIC garantit l'ordre de livraison dans une direction, alors qu'il n'y a pas de telle garantie dans le cas de plusieurs directions. <br><br>  Par exemple, si un client envoie une demande HTTP A dans le flux QUIC A, ainsi qu'une demande B dans le flux B, alors en raison de la permutation de paquets ou de pertes de r√©seau, le serveur recevra la demande B avant la demande A. Et si la demande B a √©t√© cod√©e comme a √©t√© indiqu√© dans l'en-t√™te de la demande A, le serveur ne pourra tout simplement pas d√©coder la demande B, car il n'a pas encore vu la demande A. <br><br>  Le protocole gQUIC a r√©solu ce probl√®me en rendant simplement tous les en-t√™tes (mais pas les corps) des requ√™tes / r√©ponses HTTP <b>s√©quentielles</b> dans un seul flux gQUIC.  Cela garantit que tous les en-t√™tes sont dans le bon ordre, quoi qu'il arrive.  Il s'agit d'un sch√©ma tr√®s simple, avec son aide, les solutions existantes peuvent continuer √† utiliser du code affin√© sous HTTP / 2;  d'autre part, cela augmente la probabilit√© de bloquer le d√©but de la file d'attente, ce que QUIC est con√ßu pour r√©duire.  Par cons√©quent, le groupe de travail IETF QUIC a d√©velopp√© un nouveau mappage entre HTTP et QUIC (HTTP / QUIC), ainsi qu'un nouveau principe de compression d'en-t√™te, QPACK. <br><br>  Dans la version finale des sp√©cifications HTTP / QUIC et QPACK, chaque √©change de demande / r√©ponse HTTP utilise son propre flux QUIC bidirectionnel, donc le blocage du d√©but de la file d'attente ne se produit pas.  De plus, afin de prendre en charge QPACK, chaque participant cr√©e deux flux QUIC unidirectionnels suppl√©mentaires, l'un pour envoyer les mises √† jour de table, l'autre pour confirmer leur r√©ception.  Ainsi, le codeur QPACK ne peut utiliser le lien vers la table dynamique qu'apr√®s que le d√©codeur a confirm√© sa r√©ception. <br><br><h2>  R√©flexion r√©fringente </h2><br>  Un probl√®me commun avec les protocoles bas√©s sur UDP est leur sensibilit√© aux attaques par r√©flexion, lorsque l'attaquant force un serveur √† envoyer une √©norme quantit√© de donn√©es √† la victime.  L'attaquant usurpe son adresse IP afin que le serveur pense que la demande de donn√©es provient de l'adresse de la victime. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4e/ee/ov/4eeeovjfl-9or5j0uq-9he0btrg.png"></div><br>  Ce type d'attaque peut √™tre tr√®s efficace lorsque la r√©ponse du serveur est incomparablement plus grande que la demande.  Dans ce cas, ils parlent de ¬´gain¬ª. <br><br>  TCP n'est g√©n√©ralement pas utilis√© pour de telles attaques, car les paquets de la poign√©e de main d'origine (SYN, SYN + ACK, ...) ont la m√™me longueur, donc ils n'ont pas de potentiel "d'amplification". <br><br>  En revanche, la prise de contact QUIC est tr√®s asym√©trique: comme dans TLS, le serveur QUIC envoie d'abord sa cha√Æne de certificats, qui peut √™tre assez grande, malgr√© le fait que le client ne doit envoyer que quelques octets (le message du client ClientHello TLS est int√©gr√© au package QUIC )  Pour cette raison, l'emballage d'origine QUIC doit √™tre augment√© jusqu'√† une certaine longueur minimale, m√™me si le contenu de l'emballage est beaucoup plus petit.  Quoi qu'il en soit, cette mesure n'est toujours pas tr√®s efficace, car une r√©ponse de serveur typique contient plusieurs paquets et peut donc √™tre plus qu'un package client √©largi. <br><br>  Le protocole QUIC d√©finit √©galement un m√©canisme de v√©rification de source explicite: le serveur, au lieu de donner une r√©ponse importante, envoie uniquement un paquet de nouvelle tentative avec un jeton unique, que le client envoie ensuite au serveur dans un nouveau paquet.  Ainsi, le serveur a plus confiance que le client n'a pas d'adresse IP de remplacement et vous pouvez mettre fin √† la prise de contact.  Moins de la d√©cision - le temps de la poign√©e de main augmente, au lieu d'une passe, deux sont d√©j√† n√©cessaires. <br><br>  Une autre solution consiste √† r√©duire la r√©ponse du serveur √† une taille o√π l'attaque par r√©flexion devient moins efficace - par exemple, en utilisant des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">certificats ECDSA</a> (g√©n√©ralement ils sont beaucoup plus petits que RSA).  Nous avons √©galement exp√©riment√© un m√©canisme de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">compression de certificat TLS</a> utilisant des algorithmes de compression standard tels que zlib et brotli;  il s'agit d'une fonctionnalit√© qui est apparue pour la premi√®re fois dans gQUIC mais qui n'est actuellement pas prise en charge dans TLS. <br><br><h2>  Performances UDP </h2><br>  L'un des probl√®mes constants de QUIC est le mat√©riel et les logiciels existants qui ne peuvent pas fonctionner avec QUIC.  Nous avons d√©j√† examin√© comment QUIC essaie de g√©rer les bo√Ætiers de m√©diation r√©seau comme les routeurs, mais un autre domaine potentiellement probl√©matique est la performance d'envoi / r√©ception de donn√©es entre les p√©riph√©riques QUIC via UDP.  Depuis de nombreuses ann√©es, des efforts ont √©t√© faits pour optimiser autant que possible les impl√©mentations TCP, y compris les capacit√©s de d√©chargement int√©gr√©es dans les logiciels (par exemple, les syst√®mes d'exploitation) et dans le mat√©riel (interfaces r√©seau), mais rien de tout cela ne concerne UDP. <br><br>  Cependant, ce n'est qu'une question de temps avant que les impl√©mentations QUIC d√©passent ces am√©liorations et avantages.  Jetez un ≈ìil aux efforts r√©cents pour impl√©menter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le d√©chargement UDP sur Linux</a> , qui permettrait aux applications de combiner et de transmettre plusieurs segments UDP entre l'espace utilisateur et la pile r√©seau de l'espace noyau au prix d'environ un segment;  un autre exemple est la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">prise en</a> charge de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">z√©rocopie pour les sockets sous Linux</a> , gr√¢ce √† laquelle les applications pourraient √©viter le co√ªt de la copie de la m√©moire de l'espace utilisateur vers l'espace noyau. <br><br><h2>  Conclusion </h2><br>  Comme HTTP / 2 et TLS 1.3, le protocole QUIC devrait apporter une tonne de nouvelles fonctionnalit√©s qui am√©lioreront les performances et la s√©curit√© des sites Web et des autres participants √† l'infrastructure Internet.  Le groupe de travail de l'IETF a l'intention de d√©ployer la premi√®re version des sp√©cifications QUIC d'ici la fin de l'ann√©e, il est donc temps de r√©fl√©chir √† la fa√ßon dont nous pouvons tirer le meilleur parti des avantages de QUIC. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430436/">https://habr.com/ru/post/fr430436/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430426/index.html">Rebranding des produits Western Digital: qu'est-ce qui a chang√©?</a></li>
<li><a href="../fr430428/index.html">Le site "Escher II" dans la nomination "Projet Internet du Peuple" Prix Runet 2018</a></li>
<li><a href="../fr430430/index.html">Fullstack - pourquoi est-ce cool ou comment profiter du travail</a></li>
<li><a href="../fr430432/index.html">La fen√™tre modale que vous attendiez. Ou comment appeler une fen√™tre contextuelle √† partir de diff√©rents boutons sur JS pur</a></li>
<li><a href="../fr430434/index.html">Lancement de la visionneuse d'images √† partir de Windows XP sur Windows moderne</a></li>
<li><a href="../fr430438/index.html">Ombres r√©alistes pour roguelike</a></li>
<li><a href="../fr430446/index.html">Encore une fois sur les avantages de "l'esclavage mobile"</a></li>
<li><a href="../fr430448/index.html">Ce qui donne l'apprentissage automatique au d√©tail: un exemple de projet</a></li>
<li><a href="../fr430450/index.html">Mod√®le de d√©veloppement utilisant un processeur bas√© sur la pile comme exemple</a></li>
<li><a href="../fr430452/index.html">Feu, eau et fine pulv√©risation. Comment les r√©sidents et les visiteurs du centre de Lakhta seront prot√©g√©s contre les incendies</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>