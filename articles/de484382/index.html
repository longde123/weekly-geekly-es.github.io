<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöé üïâÔ∏è ‚úãüèæ Bellman-Ford-Algorithmus üíÇüèº ü¶Ñ üôè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im Vorgriff auf den Beginn des Kurses ‚ÄûAlgorithmen f√ºr Entwickler‚Äú haben sie eine weitere √úbersetzung eines interessanten Artikels vorbereitet. 



 P...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bellman-Ford-Algorithmus</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/484382/">  <i>Im Vorgriff auf den Beginn des Kurses <a href="https://otus.pw/fQmF/">‚ÄûAlgorithmen f√ºr Entwickler‚Äú haben sie</a> eine weitere √úbersetzung eines interessanten Artikels vorbereitet.</i> <br><br><img src="https://habrastorage.org/webt/46/2_/bq/462_bqiiv5wfe1icrywppqofpws.png"><br><hr><br>  <b>Problem</b> : Wenn ein Graph und ein Anfangsscheitelpunkt src in einem Graphen gegeben sind, ist es notwendig, die k√ºrzesten Wege von src zu allen Scheitelpunkten in einem gegebenen Graphen zu finden.  Das Diagramm kann Kanten mit negativen Gewichten enthalten. <br><br>  Wir haben bereits den Dijkstra-Algorithmus besprochen, um dieses Problem zu l√∂sen.  Der Dijkstra-Algorithmus ist ein gieriger Algorithmus, und seine Komplexit√§t ist O (VLogV) (unter Verwendung des Fibonacci-Heap).  Dijkstra funktioniert jedoch nicht f√ºr Diagramme mit negativer Kantengewichtung, w√§hrend Bellman-Ford dies vollst√§ndig tut.  Der Bellman-Ford-Algorithmus ist noch einfacher als der Dijkstra-Algorithmus und eignet sich gut f√ºr verteilte Systeme.  Gleichzeitig ist seine Komplexit√§t <i>O (VE)</i> , was mehr als der Indikator f√ºr den Dijkstra-Algorithmus ist. <br><br>  <b>Empfehlung</b> : Bevor Sie mit der Anzeige der L√∂sung fortfahren, <a href="https://practice.geeksforgeeks.org/problems/negative-weight-cycle/0">√ºben Sie sich</a> selbst. <br><a name="habracut"></a><br><h3>  Algorithmus </h3><br>  Das Folgende sind detaillierte Schritte. <br><br>  <i>Eingabe</i> : Graph und anf√§nglicher Vertex <code>src</code> . <br>  <i>Ausgabe</i> : Die k√ºrzeste Entfernung zu allen Scheitelpunkten von src.  Wenn ein Zyklus mit negativem Gewicht auftritt, werden die k√ºrzesten Abst√§nde nicht berechnet, und es wird eine Meldung angezeigt, die das Vorhandensein eines solchen Zyklus anzeigt. <br><br><ol><li>  In diesem Schritt werden die Abst√§nde vom Anfangsscheitelpunkt zu allen anderen Scheitelpunkten als unendlich initialisiert, und der Abstand zu src selbst wird mit 0 angenommen. Ein Array <code>dist[]</code> Gr√∂√üe <code>|V|</code>  mit allen Werten gleich unendlich, mit Ausnahme des <code>dist[src]</code> -Elements, wobei <code>src</code> der urspr√ºngliche Scheitelpunkt ist. </li><li>  Der zweite Schritt berechnet die k√ºrzesten Entfernungen.  Die folgenden Schritte m√ºssen ausgef√ºhrt werden <code>|V|</code>  -1 mal, wobei <code>|V|</code>  - Die Anzahl der Eckpunkte in diesem Diagramm. <br><ul><li>  F√ºhren Sie f√ºr jede <i>UV-</i> Kante die folgende Aktion aus: <br>  Wenn <code>dist[v] &gt; dist[u] +   uv</code> , dann aktualisiere <code>dist[v]</code> <br> <code>dist [v] = dist [u] +   uv</code> <br> </li></ul></li><li>  In diesem Schritt wird gemeldet, ob in der Grafik ein negativer Gewichtszyklus vorliegt.  <i>F√ºhren Sie</i> f√ºr jedes Kanten- <i>UV</i> Folgendes aus: <br><br><ul><li>  Wenn <code>dist[v] &gt; dist[u] +   uv</code> , enth√§lt der Graph einen Zyklus mit negativem Gewicht. <br></li></ul></li></ol><br>  Die Idee von Schritt 3 ist, dass Schritt 2 die k√ºrzeste Distanz garantiert, wenn der Graph keinen Zyklus mit negativem Gewicht enth√§lt.  Wenn wir alle Kanten erneut durchgehen und einen k√ºrzeren Pfad f√ºr einen der Scheitelpunkte erhalten, ist dies ein Signal f√ºr das Vorhandensein eines negativen Gewichtszyklus. <br><br>  Wie funktioniert es  Wie bei anderen dynamischen Programmieraufgaben berechnet der Algorithmus die k√ºrzesten Pfade von unten nach oben.  Zun√§chst werden die k√ºrzesten Abst√§nde berechnet, dh Pfade mit einer L√§nge von nicht mehr als einer Kante.  Dann berechnet es die k√ºrzesten Wege mit einer L√§nge von nicht mehr als zwei Kanten und so weiter.  Nach der i-ten Iteration der √§u√üeren Schleife werden die k√ºrzesten Pfade mit einer L√§nge von nicht mehr als <i>i</i> Kanten berechnet.  In jedem einfachen Pfad kann es maximal <i>| V | -1</i> Kanten geben, so dass die √§u√üere Schleife genau <i>| V | -1</i> Mal l√§uft.  Die Idee ist, dass, wenn wir den k√ºrzesten Pfad mit nicht mehr als <i>i</i> Kanten berechnen, das Iterieren √ºber alle Kanten garantiert, dass der k√ºrzeste Pfad mit nicht mehr als <i>i + 1</i> Kanten erhalten wird (der Beweis ist recht einfach, Sie k√∂nnen sich auf <a href="http://courses.csail.mit.edu/6.006/spring11/lectures/lec15.pdf">diese</a> Vorlesung oder <a href="http://www.youtube.com/watch%3Fv%3DTtezuzs39nk">Videovorlesung vom MIT</a> beziehen ) <br><br><h4>  Beispiel </h4><br>  Schauen wir uns den Algorithmus im folgenden Diagrammbeispiel an.  Bilder <a href="http://www.cs.arizona.edu/classes/cs445/spring07/ShortestPath2.prn.pdf">von hier aufgenommen</a> . <br>  Der anf√§ngliche Scheitelpunkt sei 0. Nehmen Sie alle Entfernungen als unendlich, mit Ausnahme der Entfernung zu <code>src</code> selbst.  Die Gesamtanzahl der Scheitelpunkte im Diagramm betr√§gt 5, sodass alle Kanten viermal verschoben werden m√ºssen. <br><br><img src="https://habrastorage.org/webt/mc/by/aj/mcbyaj-zot8xgs3op0eytzy_j9s.png"><br><br>  Lassen Sie die Rippen in der folgenden Reihenfolge herausarbeiten: (B, E), (D, B), (B, D), (A, B), (A, C), (D, C), (B, C), ( E, D).  Die folgenden Abst√§nde erhalten wir, als der Durchgang entlang der Rippen zum ersten Mal abgeschlossen wurde.  Die erste Zeile zeigt die Anfangsabst√§nde, die zweite Zeile zeigt die Abst√§nde, wenn die Kanten (B, E), (D, B), (B, D) und (A, B) verarbeitet werden.  Die dritte Zeile zeigt den Bearbeitungsabstand (A, C).  Die vierte Zeile zeigt, was passiert, wenn (D, C), (B, C) und (E, D) verarbeitet werden. <br><br><img src="https://habrastorage.org/webt/fw/qg/_a/fwqg_a7bjrpgdazxqkyrlus_hg8.png"><br><br>  Die erste Iteration stellt sicher, dass alle k√ºrzesten Pfade nicht l√§nger als der Pfad einer Kante sind.  Die folgenden Abst√§nde erhalten wir, wenn der zweite Durchgang an allen Kanten abgeschlossen ist (die letzte Zeile zeigt die Endwerte). <br><br><img src="https://habrastorage.org/webt/ay/vn/oc/ayvnoc7tqegmemompcimnftttk4.png"><br><br>  Die zweite Iteration stellt sicher, dass alle k√ºrzesten Pfade eine L√§nge von h√∂chstens 2 Kanten haben.  Der Algorithmus l√§uft 2 weitere Male entlang aller Kanten.  Entfernungen werden nach der zweiten Iteration minimiert, sodass die dritten und vierten Iterationen die Entfernungswerte nicht aktualisieren. <br><br>  Implementierung: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Python program for Bellman-Ford's single source # shortest path algorithm. from collections import defaultdict # Class to represent a graph class Graph: def __init__(self, vertices): self.V = vertices # No. of vertices self.graph = [] # default dictionary to store graph # function to add an edge to graph def addEdge(self, u, v, w): self.graph.append([u, v, w]) # utility function used to print the solution def printArr(self, dist): print("Vertex Distance from Source") for i in range(self.V): print("% d \t\t % d" % (i, dist[i])) # The main function that finds shortest distances from src to # all other vertices using Bellman-Ford algorithm. The function # also detects negative weight cycle def BellmanFord(self, src): # Step 1: Initialize distances from src to all other vertices # as INFINITE dist = [float("Inf")] * self.V dist[src] = 0 # Step 2: Relax all edges |V| - 1 times. A simple shortest # path from src to any other vertex can have at-most |V| - 1 # edges for i in range(self.V - 1): # Update dist value and parent index of the adjacent vertices of # the picked vertex. Consider only those vertices which are still in # queue for u, v, w in self.graph: if dist[u] != float("Inf") and dist[u] + w &lt; dist[v]: dist[v] = dist[u] + w # Step 3: check for negative-weight cycles. The above step # guarantees shortest distances if graph doesn't contain # negative weight cycle. If we get a shorter path, then there # is a cycle. for u, v, w in self.graph: if dist[u] != float("Inf") and dist[u] + w &lt; dist[v]: print "Graph contains negative weight cycle" return # print all distance self.printArr(dist) g = Graph(5) g.addEdge(0, 1, -1) g.addEdge(0, 2, 4) g.addEdge(1, 2, 3) g.addEdge(1, 3, 2) g.addEdge(1, 4, 2) g.addEdge(3, 2, 5) g.addEdge(3, 1, 1) g.addEdge(4, 3, -3) # Print the solution g.BellmanFord(0) # This code is contributed by Neelam Yadav</span></span></code> </pre> <br><br>  <b>Ausgabewerte:</b> <b><br></b> <br><img src="https://habrastorage.org/webt/jm/zw/tb/jmzwtbctl4wb4fvukrfgrl7keyu.png"><br><br>  <b>Anmerkungen:</b> <br><br><ol><li>  Negative Gewichte werden in verschiedenen Grafikanwendungen gefunden.  Anstatt beispielsweise die Kosten eines Pfades zu erh√∂hen, k√∂nnen wir davon profitieren, wenn wir einem bestimmten Pfad folgen. </li><li>  Der Bellman-Ford-Algorithmus funktioniert besser f√ºr verteilte Systeme (besser als der Dijkstra-Algorithmus).  Im Gegensatz zu Dijkstra, wo wir den Mindestwert aller Eckpunkte ermitteln m√ºssen, werden bei Bellman Ford Kanten einzeln betrachtet. </li></ol><br>  <b>√úbungen:</b> <br><br><ol><li>  Der Bellman-Ford-Standardalgorithmus meldet nur dann k√ºrzeste Wege, wenn er keine Zyklen mit negativem Gewicht aufweist.  √Ñndern Sie es so, dass es die k√ºrzesten Pfade meldet, auch wenn es einen solchen Zyklus gibt. </li><li>  K√∂nnen wir den Dijkstra-Algorithmus verwenden, um die k√ºrzesten Pfade in einer Grafik mit negativen Gewichten zu finden?  Es gibt eine solche Idee: Berechnen Sie den minimalen Gewichtswert, addieren Sie einen positiven Wert (der dem absoluten Wert des minimalen Gewichtswerts entspricht) zu allen Gewichten und f√ºhren Sie den Dijkstra-Algorithmus f√ºr das modifizierte Diagramm aus.  Wird ein solcher Algorithmus funktionieren? </li></ol><br>  <a href="https://www.geeksforgeeks.org/bellman-ford-algorithm-simple-implementation/">Einfache Implementierung des Bellman-Ford-Algorithmus</a> <br><br>  <b>Quellen:</b> <br><br>  <a href="http://www.youtube.com/watch%3Fv%3DTtezuzs39nk">www.youtube.com/watch?v=Ttezuzs39nk</a> <br>  <a href="http://en.wikipedia.org/wiki/Bellman%25E2%2580%2593Ford_algorithm">en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm</a> <br>  <a href="http://www.cs.arizona.edu/classes/cs445/spring07/ShortestPath2.prn.pdf">www.cs.arizona.edu/classes/cs445/spring07/ShortestPath2.prn.pdf</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484382/">https://habr.com/ru/post/de484382/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484372/index.html">Smart House mit Xiaomi am Beispiel einer Sauna</a></li>
<li><a href="../de484374/index.html">Reise in die Mitte ... Hafenarbeiter Bild. Oder wie man ein Bild aus der Registrierung ohne Andockfenster herunterl√§dt</a></li>
<li><a href="../de484376/index.html">Samsung Moskauer Zentrum f√ºr K√ºnstliche Intelligenz in Mitarbeitergeschichten</a></li>
<li><a href="../de484378/index.html">SwayWM - UnixPorn Yourself</a></li>
<li><a href="../de484380/index.html">Umzug - das letzte Jahrhundert! Alternativen zu std :: move in ‚ÄûC ++ der Zukunft‚Äú</a></li>
<li><a href="../de484386/index.html">AWS_Ru Meetup bei der Raiffeisenbank</a></li>
<li><a href="../de484388/index.html">VVVVVV ??? VVVVVV !!! :)</a></li>
<li><a href="../de484390/index.html">Einblicke in die 18 besten Java-Frameworks f√ºr 2020</a></li>
<li><a href="../de484392/index.html">Anf√§lle</a></li>
<li><a href="../de484394/index.html">Sieben aufregendste Weltraummissionen des kommenden Jahres</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>