<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßë üõåüèº üà∫ Rutoken, OpenSSL und eine lokale Zertifizierungsstelle zum Signieren von Nachrichten üòä üëÉüèæ üèí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einiger Zeit bestand im Rahmen des Projekts die Notwendigkeit, die gleichzeitige Anzahl von Computern zu begrenzen, die Zugriff auf eine Webanwend...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rutoken, OpenSSL und eine lokale Zertifizierungsstelle zum Signieren von Nachrichten</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444646/"> Vor einiger Zeit bestand im Rahmen des Projekts die Notwendigkeit, die gleichzeitige Anzahl von Computern zu begrenzen, die Zugriff auf eine Webanwendung haben, die im lokalen Netzwerk des Kunden ausgef√ºhrt wird. <br><br>  Die Entscheidung, Hardware-USB-Token zur Identifizierung des Computers zu verwenden, fiel von selbst.  Die Wahl lag beim Rutoken EDS: Es funktioniert ohne Treiber. Um in einer Webanwendung zu arbeiten, ben√∂tigen Sie nur ein vom Entwickler freigegebenes Browser-Plug-In.  Da das Token den Computer und nicht den Benutzer identifizieren sollte, sollte die Arbeit mit ihm vollst√§ndig ‚Äûtransparent‚Äú sein: Wenn es vorhanden ist, arbeitet das System einfach still, ohne dem Benutzer unn√∂tige Fragen zu stellen. <br><br>  Es wurde entschieden: Wenn Sie sich beim System anmelden, signieren Sie die Benutzeranmeldeinformationen mit einer uneingeschr√§nkten Signatur des auf Rutoken gespeicherten Zertifikats mithilfe des Rootoken-Plugins und √ºberpr√ºfen Sie den Server.  √úberpr√ºfen Sie nach einer erfolgreichen Anmeldung mit dem Plugin das physische Vorhandensein desselben Tokens und melden Sie sich vom System ab, wenn dies nicht der Fall ist.  Im Rahmen des genannten Projekts war dies ausreichend. <br><br>  Sie m√ºssen eine eigene Zertifizierungsstelle (CA) erstellen, um signierte Nachrichten auszutauschen oder signierte Nachrichten von einem Client an einen Server zu senden.  Client-Zertifikate m√ºssen sich auf USB-Token in privaten Schl√ºsselcontainern befinden, und die Signatur√ºberpr√ºfung muss auf dem Server mithilfe von OpenSSL durchgef√ºhrt werden <br><br>  Also die Aufgabe: <b>Installation und Konfiguration auf dem Linux-Server der CA.</b>  <b>Stellen Sie Client-Zertifikate bereit, die Computer auf USB-Token identifizieren</b> . <br><br>  Um es zu l√∂sen, ben√∂tigen Sie: <br><br><ul><li>  OpenSSL 1.1.0 und h√∂her mit Unterst√ºtzung f√ºr GOST-Algorithmen </li><li>  Rutoken EDS </li><li>  Integrationsmodul mit OpenSSL von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Entwicklerseite</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PKCS # 11-Bibliothek</a> , sowie ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstprogramm zur Verwaltung des Tokens</a> (rtAdmin) </li><li>  opensc, pcsc-lite-ccid Pakete installiert </li></ul><a name="habracut"></a><br><ol><li>  Wir erstellen ein Verzeichnis, in dem sich die <b>Zertifizierungsstelle</b> befindet, und kopieren die im System enthaltene OpenSSL-Konfiguration (auf den neuesten Versionen von Ubuntu befindet sich <b>/etc/ssl/openssl.cnf</b> ). </li><li>  Wir konfigurieren "unsere" openssl.cnf: <br><br>  a) F√ºgen Sie am Anfang der Dateianweisungen zum Verbinden der Token-Engine Folgendes hinzu: <br><br><pre><code class="plaintext hljs">openssl_conf = openssl_def [ openssl_def ] engines = engine_section [ engine_section ] rtengine = gost_section [ gost_section ] dynamic_path = /path/to/rutoken/openssl/connector/librtengine.so MODULE_PATH = /path/to/rutoken/pkcs11/librtpkcs11ecp.so RAND_TOKEN = pkcs11:manufacturer=Aktiv%20Co.;model=Rutoken%20ECP default_algorithms = CIPHERS, DIGEST, PKEY, RAND</code> </pre> <br>  b) Kommentieren Sie die Zeile aus <br><br><pre> <b><code class="plaintext hljs"># req_extensions = v3_req # The extensions to add to a certificate request</code></b> </pre> <br>  c) <b>Geben Sie im</b> Abschnitt <b>[v3_req]</b> die folgenden Parameter an: <br><br><pre> <b><code class="plaintext hljs">subjectSignTool = ASN1:FORMAT:UTF8,UTF8String:   extendedKeyUsage=emailProtection keyUsage=digitalSignature,nonRepudiation,keyEncipherment,dataEncipherment</code></b> </pre><br>  d) Entfernen Sie im Abschnitt [v3_ca] die kritische Option aus dem Parameter basicConstraints: <br><br><pre> <code class="plaintext hljs">basicConstraints = CA:true</code> </pre> <br>  <i>Wof√ºr?</i>  <i>Ehrliche Antwort: Ich wei√ü es nicht.</i>  <i>Alle Beispiele f√ºr Stammzertifikate, die ich heruntergeladen habe, um das Thema herauszufinden, waren jedoch ohne kritisches Zeichen.</i>  <i>Ich stelle die Frage "wof√ºr?"</i>  <i>erfahrenere Kollegen.</i> <i><br></i> <br><br>  e) Legen Sie optional die Standardwerte fest, die angeboten werden, wenn selbstsignierte Zertifikate ausgestellt und Anforderungen f√ºr die Ausstellung von Client-Zertifikaten generiert werden.  Diese Parameter befinden sich im Abschnitt <b>[req_distinguished_name]</b> <br><br>  Der Parameter mit dem Postfix _default ist der Standardwert.  Ein Beispiel: <br><br><pre> <b><code class="plaintext hljs">countryName = Country Name (2 letter code) countryName_default = AU countryName_min = 2 countryName_max = 2</code></b> </pre> <br>  <i>Wenn das System Sie <b>auffordert, den</b> Parameter <b>countryName einzugeben</b> , wird in eckigen Klammern angezeigt, dass der Wert AU standardm√§√üig <b>beibehalten</b> wird.</i> <i><br></i> <br><br>  Damit ist die Konfiguration der OpenSSL-Konfiguration abgeschlossen.  Es bleibt offen, um OpenSSL anzuzeigen, dass es notwendig ist, es zu verwenden.  Setzen Sie dazu die Umgebungsvariable OPENSSL_CONF: <br><br><pre> <b><code class="plaintext hljs">export OPENSSL_CONF=/path/to/your/openssl.cnf</code></b> </pre> </li><li>  Wir erstellen eine Verzeichnisstruktur, in der Informationen zu unserer Zertifizierungsstelle gespeichert werden. <br>  Wechseln Sie dazu in das erstellte Verzeichnis mit der gerade bearbeiteten Datei openssl.cnf und f√ºhren Sie die folgenden Schritte aus: <br><br>  a) Erstellen Sie darin Unterverzeichnisse: <br><br>  <b>demoCA</b> <b><br></b>  <b>demoCA / privat</b> <b><br></b>  <b>demoCA / newcerts</b> <b><br></b> <br>  <i><b>Hinweis:</b> Der demoCA-Name wird im Abschnitt <b>[CA_default]</b> der Datei <b>openssl.cnf angegeben</b> .</i>  <i>Sie k√∂nnen es √§ndern (in Schritt 2) und dann anstelle von demoCA damit arbeiten.</i> <br><br>  b) Erstellen Sie im demoCA-Verzeichnis eine leere <b>index.txt-</b> Datei und eine <b>serielle</b> Datei, die wir mit einem Texteditor √∂ffnen und dort Zeile 01 schreiben. Dies ist der Z√§hler f√ºr ausgestellte Zertifikate.  Nach der Ausstellung jedes n√§chsten Zertifikats erh√∂ht sich der Wert in dieser Datei um eins. </li><li>  Optional formatieren wir unser Token mit dem Dienstprogramm rtAdmin. Jetzt ist alles f√ºr die Bereitstellung der Zertifizierungsstelle bereit. <br><br>  Der Aktionsalgorithmus ist weitgehend einfach: <br><br>  <i>a) Wir stellen das Stammzertifikat des Zertifizierungszentrums mit dem GOST-Algorithmus aus:</i> <i><br><br></i> <ul><li>  Generieren Sie einen privaten Schl√ºssel, um ein selbstsigniertes CA-Zertifikat auszustellen </li><li>  Generieren Sie mit dem generierten Schl√ºssel ein selbstsigniertes X509-Zertifikat </li></ul><br>  b) auf jedem der USB-Token <br><br><ul><li>  ein Schl√ºsselpaar generieren (den sogenannten privaten Schl√ºsselcontainer) </li><li>  Generieren Sie eine Zertifikatsignierungsanforderung mit dem generierten Token-Schl√ºssel </li><li>  Stellen Sie ein Zertifikat f√ºr diese Anfrage aus </li><li>  Speichern Sie das Zertifikat auf dem Token im privaten Schl√ºsselcontainer </li></ul><br>  Das Folgende ist eine Implementierung dieses Algorithmus f√ºr ein einzelnes Token: <br><br>  <i>Generierung privater Schl√ºssel f√ºr CA-Zertifikat (wir verwenden den GOST-Algorithmus):</i> <br><br><pre> <code class="plaintext hljs">openssl genpkey -algorithm gost2012_256 -pkeyopt paramset:A -outform PEM -out demoCA/private/cakey.pem</code> </pre> <br>  <i>Wir stellen ein selbstsigniertes CA-Zertifikat aus:</i> <br><br><pre> <code class="plaintext hljs">&lt;b&gt;openssl req -new -x509 -key demoCA/private/cakey.pem -out demoCA/certs/cacert.pem -extensions v3_ca -days +3650 -outform PEM</code> </pre> <br>  Bitte beachten Sie: Wir haben in der Befehlszeile angegeben, dass die <b>v3_ca-</b> Erweiterungen aus der openssl_cnf-Konfiguration verwendet werden m√ºssen.  Dort ist es unsere CA.  G√ºltigkeit von 10 Jahren.  Eine h√§ufige Sache f√ºr CA.  Aber mehr ist m√∂glich. <br><br>  <b>W√§hrend</b> der Ausstellung eines Zertifikats werden Sie vom System aufgefordert, die Parameterwerte einzugeben, die sich im Abschnitt <b>[req_distinguished_name]</b> unserer Datei <b>openssl.cnf befinden</b> <br><br>  Jetzt starten wir Token-Operationen.  Wenn das Token neu ist oder mit Standardwerten formatiert ist, lautet die PIN des Benutzers 12345678. Ich gehe davon aus, dass dies genau so ist.  Andernfalls m√ºssen Sie die richtige Benutzer-PIN angeben und im Allgemeinen sicherstellen, dass in den folgenden Beispielen die Namen der bereits auf dem Token vorhandenen Objekte nicht mit den eingegebenen Objekten √ºberlappen. <br><br>  Zun√§chst <i>generieren</i> wir <i>ein Schl√ºsselpaar.</i>  OpenSSL kann diesen Vorgang auf Rutoken nicht ausf√ºhren, daher verwenden wir das Dienstprogramm pkcs11-tool aus dem OpenSC-Paket: <br><br><pre> <code class="plaintext hljs">pkcs11-tool --module /path/to/your/librtpkcs11ecp.so --login --pin 12345678 --keypairgen --key-type GOSTR3410:A --id 303030303031 --label 'client01'</code> </pre> <br>  <i><b>Wichtiger Hinweis:</b> Wir haben die ID 303030303031 angegeben. Alle zwei Ziffern dieser ID sind nichts anderes als der ASCII-Code der Zeichen ‚Äû0‚Äú bzw. ‚Äû1‚Äú.</i>  <i>Bei Operationen mit OpenSSL sieht es wie folgt aus: "id = 000001"</i> <i><br></i> <br>  Generieren Sie eine Zertifikatanforderung: <br><br><pre> <code class="plaintext hljs">openssl req -utf8 -new -keyform engine -key 'pkcs11:id=000001' -engine rtengine -out demoCA/newcerts/client01.csr</code> </pre> <br>  Wenn alles richtig gemacht wurde, dann das System <br><br><ul><li>  Fordern Sie eine PIN an </li><li>  fordert Parameter f√ºr den Zertifikatsnamen an (aus dem Abschnitt <b>[req_distinguished_name]</b> ) </li><li>  gibt eine Anforderungsdatei f√ºr die Zertifikatsignierung aus </li></ul><br>  Mit dieser Anfrage signieren wir ein Client-Zertifikat ( <i>im Beispiel ist das Zertifikat 1825 Tage g√ºltig. <b>Es ist wichtig,</b> dass dieser Zeitraum den G√ºltigkeitszeitraum Ihres Stammzertifikats nicht √ºberschreitet</i> ): <br><br><pre> <code class="plaintext hljs">openssl ca -utf8 -days +1825 -keyfile demoCA/private/cakey.pem -cert demoCA/certs/cacert.pem -in demoCA/newcerts/client01.csr -outdir demoCA/newcerts -out demoCA/certs/client01.pem</code> </pre> <br>  Das System zeigt das Zertifikat an, fragt nach der Entscheidung, es zu unterschreiben (Antwort ‚Äûy‚Äú) und nach der Entscheidung, das neue Zertifikat zu speichern (antworten Sie erneut mit ‚Äûy‚Äú). <br><br>  Wir speichern das erhaltene Zertifikat f√ºr das Token: <br><br><pre> <code class="plaintext hljs">pkcs11-tool --module /path/to/your/librtpkcs11ecp.so --login --pin 12345678 --id=303030303031 -w demoCA/certs/client01.pem -y cert</code> </pre><br>  <b>Das ist alles.</b> <br><br>  Testen des geschaffenen ‚ÄûWunders‚Äú.  Dazu unterschreiben und verifizieren wir die Unterschrift des Satzes "Hallo Welt!": <br><br><pre> <code class="plaintext hljs">echo Hello,world! | openssl cms -nodetach -sign -signer demoCA/certs/client01.pem -keyform engine -inkey "pkcs11:id=000001" -engine rtengine -binary -noattr -outform PEM | openssl cms -verify -CAfile demoCA/certs/cacert.pem -inform PEM</code> </pre> <br>  Wenn alles korrekt durchgef√ºhrt wurde, fordert das System eine PIN an, signiert die Nachricht, √ºberpr√ºft die Signatur und zeigt bei Erfolg die urspr√ºngliche Nachricht und das Ergebnis der √úberpr√ºfung an (‚ÄûErfolg‚Äú). <br><br>  <i><b>Bemerkung</b></i> .  Wenn Sie zur Titelaufgabe zur√ºckkehren und mit dem Plugin signieren, sollte beachtet werden, dass das Plugin standardm√§√üig das Ergebnis der Signierung nicht im PEM-Format, sondern im DER-Format liefert, das in base64 codiert ist.  Um die Signatur zu √ºberpr√ºfen, m√ºssen Sie daher zuerst von base64 dekodieren und bei der √úberpr√ºfung das Eingabe-DER-Format angeben. <br><br>  Viel Gl√ºck! </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444646/">https://habr.com/ru/post/de444646/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444634/index.html">Epic Games gibt Entwicklern 100 Millionen US-Dollar</a></li>
<li><a href="../de444636/index.html">Warum kann ich nicht f√ºr das Geld wachsen?</a></li>
<li><a href="../de444638/index.html">Qualit√§tssicherung beim CodeFest. Automatisierung, Management, Infrastruktur, Verkauf von Kn√∂deln im Laden</a></li>
<li><a href="../de444640/index.html">Kostya Gorsky, Intercom: √ºber St√§dte und Ambitionen, Produktdenken, F√§higkeiten f√ºr Designer und Selbstentwicklung</a></li>
<li><a href="../de444644/index.html">VMware NSX f√ºr die Kleinsten. Teil 4. Routing konfigurieren</a></li>
<li><a href="../de444650/index.html">Bakterielles Deodorant: eine symbiotische Beziehung zwischen Laubfr√∂schen und Pseudomonas-Bakterien</a></li>
<li><a href="../de444652/index.html">‚ÄûEs ist Zeit, aus dem Frontend auszusteigen‚Äú: Andrey Sitnik √ºber die Stagnation der Community, Open Source und nicht nur</a></li>
<li><a href="../de444654/index.html">Die Wirtschaft der Freude. Mentoring als Sonderfall. Das Gesetz von drei Prozent</a></li>
<li><a href="../de444658/index.html">Video von Badoo PHP Meetup # 2: √úber Tests und Codequalit√§t</a></li>
<li><a href="../de444660/index.html">Protokollieren aller Datenbankabfragen in Asp.Net Boilerplate 4.3 .Net Core 2.1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>