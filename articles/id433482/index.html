<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌯 👨‍👨‍👦‍👦 🙅🏻 Django di bawah mikroskop 🤚🏽 ✊🏾 🔘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jika menurut laporan Artyom Malyshev ( proofit404 ) mereka akan membuat film, maka sutradara akan menjadi Quentin Tarantino - dia sudah membuat satu f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Django di bawah mikroskop</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/433482/">  Jika menurut laporan Artyom Malyshev ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">proofit404</a> ) mereka akan membuat film, maka sutradara akan menjadi Quentin Tarantino - dia sudah membuat satu film tentang Django, dia juga akan merekam yang kedua.  Semua detail dari kehidupan mekanisme internal Django dari byte pertama permintaan HTTP ke byte terakhir dari respons.  The extravaganza bentuk parser, kompilasi penuh aksi dari SQL, efek khusus dari implementasi mesin template untuk HTML.  Siapa yang mengelola kumpulan koneksi dan bagaimana?  Semua ini dalam urutan kronologis pemrosesan objek WSGI.  Di semua layar negara - decoding "Django di bawah mikroskop". <br><br><img src="https://habrastorage.org/webt/np/fq/rq/npfqrqbbgfwn2lktbgdq9h4xhgg.jpeg"><br><br>  <strong>Tentang pembicara: Artyom Malyshev</strong> adalah pendiri proyek Dry Python dan pengembang inti dari Django Channels versi 1.0.  Dia telah menulis Python selama 5 tahun dan telah membantu mengatur pertemuan Python Rannts di Nizhny Novgorod.  Artyom mungkin tidak asing bagi Anda dengan nama panggilan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">PROOFIT404</a> .  Presentasi laporan disimpan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/AvGl7Vi2yT4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Sekali waktu, kami meluncurkan versi lama Django.  Kemudian dia tampak menakutkan dan sedih. <br><br><img src="https://habrastorage.org/webt/yv/i5/a9/yvi5a9ueicvuhwgsyf8npzvojne.jpeg"><br><br>  Mereka melihat <code>self_check</code> berlalu, kami memasang semuanya dengan benar, semuanya berfungsi dan sekarang Anda dapat menulis kode.  Untuk mencapai semua ini, kami harus menjalankan <code>django-admin runserver</code> . <br><br><pre> <code class="plaintext hljs">$ django-admin runserver Performing system checks… System check identified no issues (0 silenced). You have unapplied migrations; your app may not work properly until they are applied. Run 'python manage.py migrate1 to apply them. August 21, 2018 - 15:50:53 Django version 2.1, using settings 'mysite.settings' Starting development server at http://127.0.0.1:8000/Quit the server with CONTROL-C.</code> </pre><br>  Proses dimulai, memproses permintaan HTTP, dan semua keajaiban terjadi di dalam dan semua kode yang ingin kami tampilkan kepada pengguna saat situs dijalankan. <br><br><h2>  Instalasi <br></h2><br>  <code>django-admin</code> muncul di sistem ketika kami menginstal Django menggunakan, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pip, manajer paket</a> . <br><br><pre> <code class="python hljs">$ pip install Django <span class="hljs-comment"><span class="hljs-comment"># setup.py from setuptools import find_packages, setup setup( name='Django', entry_points={ 'console_scripts': [ 'django-admin = django.core.management:execute_from_command_line' ] }, )</span></span></code> </pre><br>  <code>entry_points setuptools</code> muncul, yang menunjuk ke fungsi <code>execute_from_command_line</code> .  Fungsi ini adalah titik masuk untuk operasi apa pun dengan Django, untuk setiap proses saat ini. <br><br><h3>  Bootstrap <br></h3><br>  Apa yang terjadi di dalam suatu fungsi?  <strong>Bootstrap</strong> , yang terbagi menjadi dua iterasi. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.core.management django.setup().</span></span></code> </pre><br><h4>  Konfigurasikan pengaturan <br></h4><br>  Yang pertama adalah <strong>membaca konfigurasi</strong> : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> django.conf.global_settings import_module(os.environ[<span class="hljs-string"><span class="hljs-string">"DJANGO_SETTINGS_MODULE"</span></span>])</code> </pre><br>  Pengaturan default <code>global_settings</code> , kemudian dari variabel lingkungan kami mencoba menemukan modul dengan <code>DJANGO_SETTINGS_MODULE</code> , yang ditulis pengguna.  Pengaturan ini digabungkan menjadi satu ruang nama. <br><br>  Siapa pun yang menulis di Django setidaknya "Halo, dunia" tahu bahwa ada <code>INSTALLED_APPS</code> - tempat kami menulis kode pengguna. <br><br><h4>  Mengisi aplikasi <br></h4><br>  Pada bagian kedua, semua aplikasi ini, pada dasarnya paket, diulang satu per satu.  Kami membuat untuk setiap Konfigurasi, kami mengimpor model untuk bekerja dengan database dan kami memeriksa model untuk integritas.  Lebih jauh lagi, kerangka kerjanya menjalankan <code>Check</code> , yaitu, memeriksa bahwa setiap model memiliki kunci utama, semua kunci asing menunjuk ke bidang yang ada dan bahwa bidang Null tidak ditulis dalam BooleanField, tetapi NullBooleanField digunakan. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> entry <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> settings.INSTALLED_APPS: cfg = AppConfig.create(entry) cfg.import_models()</code> </pre><br>  Ini adalah pemeriksaan kewarasan minimum untuk model, untuk panel admin, untuk apa saja - tanpa terhubung ke database, tanpa sesuatu yang sangat rumit dan spesifik.  Pada tahap ini, Django belum tahu perintah mana yang Anda minta untuk dieksekusi, yaitu, tidak membedakan <code>migrate</code> dari <code>runserver</code> atau <code>shell</code> . <br><br>  Kemudian kita menemukan diri kita dalam modul yang mencoba menebak dengan argumen baris perintah perintah mana yang ingin kita jalankan dan di mana aplikasi itu berada. <br><br><h2>  Perintah manajemen <br></h2><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.core.management subcommand = sys.argv[1] app_name = find(pkgutils.iter_modules(settings.INSTALLED_APPS)) module = import_module( '%s.management.commands.%s' % (app_name, subcommand) ) cmd = module.Command() cmd.run_from_argv(self.argv)</span></span></code> </pre><br>  Dalam hal ini, modul runserver akan memiliki modul <code>django.core.management.commands.runserver</code> .  Setelah mengimpor modul, dengan konvensi, <code>Command</code> kelas global dipanggil di dalam, dipakai, dan kami berkata: " <em>Saya menemukan Anda, di sini Anda memiliki argumen baris perintah yang dilewati pengguna, melakukan sesuatu dengan mereka</em> ." <br><br>  Selanjutnya, kita pergi ke modul runserver dan melihat bahwa <b>Django terbuat dari "regexp and sticks"</b> , yang akan saya bicarakan secara rinci hari ini: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.core.management.commands.runserver naiveip_re = re.compile(r"""^(?: (?P&lt;addr&gt; (?P&lt;ipv4&gt;\d{1,3}(?:\.\d{1,3}){3}) | # IPv4 address (?P&lt;ipv6&gt;\[[a-fA-F0-9:]+\]) | # IPv6 address (?P&lt;fqdn&gt;[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*) # FQDN ):)?(?P&lt;port&gt;\d+)$""", re.X)</span></span></code> </pre><br><h3>  Perintah <br></h3><br>  Gulir ke bawah satu setengah layar - akhirnya kita masuk ke definisi tim kami yang memulai server. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.core.management.commands.runserver class Command(BaseCommand): def handle(self, *args, **options): httpd = WSGIServer(*args, **options) handler = WSGIHandler() httpd.set_app(handler) httpd.serve_forever()</span></span></code> </pre><br>  <code>BaseCommand</code> melakukan serangkaian operasi minimal agar argumen baris perintah menghasilkan argumen untuk memanggil fungsi <code>*args</code> dan <code>**options</code> .  Kita melihat bahwa instance server WSGI sedang dibuat di sini, WSGIHandler global diinstal di server WSGI ini - ini persisnya <strong>God Object Django</strong> .  Kita dapat mengatakan bahwa ini adalah satu-satunya contoh kerangka kerja.  Instance diinstal pada server secara global - melalui <code>set application</code> dan mengatakan: "Putar di Event Loop, jalankan permintaan." <br><br><blockquote>  Selalu ada Perulangan Acara di suatu tempat dan seorang programmer yang memberinya tugas. <br></blockquote><br><h2>  Server WSGI <br></h2><br>  Apa itu <strong>WSGIHandler</strong> ?  WSGI adalah antarmuka yang memungkinkan Anda untuk memproses permintaan HTTP dengan tingkat abstraksi minimum, dan terlihat seperti sesuatu dalam bentuk fungsi. <br><br><h3>  Handler WSGI <br></h3><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.core.handlers.wsgi class WSGIHandler: def __call__(self, environ, start_response): signals.request_started.send() request = WSGIRequest(environ) response = self.get_response(request) start_response(response.status, response.headers) return response</span></span></code> </pre><br>  Sebagai contoh, ini adalah instance dari kelas yang memiliki <code>call</code> ditentukan.  Dia menunggu entri kamusnya, di mana header akan disajikan sebagai byte dan file-handler.  Handler diperlukan untuk membaca <code>&lt;body&gt;</code> permintaan.  Server itu sendiri juga memberikan callback <code>start_response</code> sehingga kami dapat mengirim <code>response.headers</code> dan header-nya, misalnya, status, dalam satu bundel. <br><br>  Lebih lanjut, kita bisa meneruskan tubuh respons ke server melalui objek respons.  <strong>Respons</strong> adalah generator yang bisa Anda ulangi. <br><br>  Semua server yang ditulis untuk WSGI - Gunicorn, uWSGI, Waitress, bekerja pada antarmuka ini dan dapat dipertukarkan.  Kami sekarang mempertimbangkan server untuk pengembangan, tetapi server mana pun sampai pada titik di Django itu mengetuk lingkungan dan panggilan balik. <br><br><h2>  Apa yang ada di dalam Objek Tuhan? <br></h2><br>  Apa yang terjadi di dalam fungsi Objek Dewa global ini di dalam Django? <br><br><ul><li>  PERMINTAAN. </li><li>  MIDDLEWARES. </li><li>  Permintaan ROUTING untuk melihat. </li><li>  LIHAT - pemrosesan kode pengguna tampilan dalam. </li><li>  BENTUK - bekerja dengan formulir. </li><li>  ORM. </li><li>  TEMPLATE </li><li>  TANGGAPAN. </li></ul><br>  Semua mesin yang kita inginkan dari Django berlangsung dalam satu fungsi, yang tersebar di seluruh kerangka kerja. <br><br><h3>  Minta <br></h3><br>  Kami membungkus lingkungan WSGI, yang merupakan kamus sederhana, di beberapa objek khusus, untuk kenyamanan bekerja dengan lingkungan.  Misalnya, lebih mudah untuk mengetahui panjang permintaan pengguna melalui bekerja dengan sesuatu yang mirip dengan kamus daripada dengan string byte yang perlu diuraikan dan mencari entri nilai kunci di dalamnya.  Saat bekerja dengan cookie, saya juga tidak ingin menghitung secara manual apakah periode penyimpanan telah kedaluwarsa atau belum, dan entah bagaimana menafsirkannya. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.core.handlers.wsgi class WSGIRequest(HttpRequest): @cached_property def GET(self): return QueryDict(self.environ['QUERY_STRING']) @property def POST(self): self._load_post_and_files() return self._post @cached_property def COOKIES(self): return parse_cookie(self.environ['HTTP_COOKIE'])</span></span></code> </pre><br>  Permintaan berisi parser, serta satu set penangan untuk mengontrol pemrosesan tubuh permintaan POST: apakah itu file dalam memori atau sementara dalam penyimpanan pada disk.  Semuanya diputuskan di dalam Permintaan.  Permintaan di Django juga merupakan objek agregator di mana semua middlewares dapat menaruh informasi yang kita butuhkan tentang sesi, otentikasi, dan otorisasi pengguna.  Kita dapat mengatakan bahwa ini juga merupakan Obyek Tuhan, tetapi lebih kecil. <br><br>  Permintaan Lebih Lanjut sampai ke middleware. <br><br><h3>  Middlewares <br></h3><br>  <strong>Middleware</strong> adalah pembungkus yang membungkus fungsi lain seperti dekorator.  Sebelum melepaskan kendali middleware, dalam metode panggilan kami memberikan respons atau memanggil middleware yang sudah dibungkus. <br><br>  Inilah yang tampak seperti middleware dari sudut pandang programmer. <br><br><h4>  Pengaturan <br></h4><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># settings.py MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', ]</span></span></code> </pre><br><h4>  Tentukan <br></h4><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Middleware</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, get_response=None)</span></span></span><span class="hljs-function">:</span></span> self.get_response = get_response <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__call__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, request)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.get_response(request)</code> </pre><br>  Dari sudut pandang Django, middlewares terlihat seperti tumpukan: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.core.handlers.base def load_middleware(self): handler = convert_exception_to_response(self._get_response) for middleware_path in reversed(settings.MIDDLEWARE): middleware = import_string(middleware_path) instance = middleware(handler) handler = convert_exception_to_response(instance) self._middleware_chain = handler</span></span></code> </pre><br><h4>  Terapkan <br></h4><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_response</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, request)</span></span></span><span class="hljs-function">:</span></span> set_urlconf(settings.ROOT_URLCONF) response = self._middleware_chain(request) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response</code> </pre><br>  Kami mengambil fungsi <code>get_response</code> awal, membungkusnya dengan handler, yang akan menerjemahkan, misalnya, <code>permission error</code> dan <code>not found error</code> ke dalam kode HTTP yang benar.  Kami membungkus semuanya dalam middleware itu sendiri dari daftar.  Tumpukan middlewares tumbuh, dan masing-masing berikutnya membungkus yang sebelumnya.  Ini sangat mirip dengan menerapkan tumpukan dekorator yang sama untuk semua tampilan dalam suatu proyek, hanya secara terpusat.  Tidak perlu berkeliling dan mengatur pembungkus dengan tangan Anda sesuai dengan proyek, semuanya nyaman dan logis. <br><br>  Kami melewati 7 lingkaran middlewares, permintaan kami bertahan dan memutuskan untuk memprosesnya.  Selanjutnya kita sampai pada modul routing. <br><br><h3>  Routing <br></h3><br>  Di sinilah kami memutuskan penangan mana yang akan dipanggil untuk permintaan tertentu.  Dan ini diselesaikan: <br><br><ul><li>  berdasarkan url; </li><li>  dalam spesifikasi WSGI, di mana request.path_info dipanggil. </li></ul><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.core.handlers.base def _get_response(self, request): resolver = get_resolver() view, args, kwargs = resolver.resolve(request.path_info) response = view(request, *args, **kwargs) return response</span></span></code> </pre><br><h4>  Url <br></h4><br>  Kami mengambil resolver, memberi makan url permintaan saat ini dan mengharapkannya untuk mengembalikan fungsi tampilan itu sendiri, dan dari url yang sama kami mendapatkan argumen yang dapat digunakan untuk memanggil tampilan.  Kemudian <code>get_response</code> panggilan tampilan, menangani pengecualian dan melakukan sesuatu dengannya. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># urls.py urlpatterns = [ path('articles/2003/', views.special_case_2003), path('articles/&lt;int:year&gt;/', views.year_archive), path('articles/&lt;int:year&gt;/&lt;int:month&gt;/', views.month_archive) ]</span></span></code> </pre><br><h4>  Penyelesai <br></h4><br>  Beginilah bentuk resolver: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.urls.resolvers _PATH_RE = re.compile( r'&lt;(?:(?P&lt;converter&gt;[^&gt;:]+):)?(?P&lt;parameter&gt;\w+)&gt;' ) def resolve(self, path): for pattern in self.url_patterns: match = pattern.search(path) if match: return ResolverMatch( self.resolve(match[0]) ) raise Resolver404({'path': path})</span></span></code> </pre><br>  Ini juga regexp, tetapi rekursif.  Ini masuk di bagian url, mencari apa yang diinginkan pengguna: pengguna lain, posting, blog, atau semacam konverter, misalnya, tahun tertentu yang perlu diselesaikan, dimasukkan ke dalam argumen, dilemparkan ke argumen, dilemparkan ke int. <br><br>  Merupakan karakteristik bahwa kedalaman rekursi dari metode tekad selalu sama dengan jumlah argumen yang disebut tampilan.  Jika terjadi kesalahan dan kami tidak menemukan url tertentu, kesalahan tidak ditemukan terjadi. <br><br>  Lalu kami akhirnya melihat - kode yang ditulis oleh programmer. <br><br><h3>  Lihat <br></h3><br>  Dalam representasi yang paling sederhana, ini adalah fungsi yang mengembalikan permintaan dari respons, tetapi di dalamnya kami melakukan tugas-tugas logis: "untuk, jika, suatu hari" - banyak tugas berulang.  Django memberi kami tampilan berbasis kelas di mana Anda dapat menentukan detail spesifik, dan semua perilaku akan ditafsirkan dalam format yang benar oleh kelas itu sendiri. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.views.generic.edit class ContactView(FormView): template_name = 'contact.html' form_class = ContactForm success_url = '/thanks/'</span></span></code> </pre><br><h4>  Bagan alur metode <br></h4><br><pre> <code class="python hljs">self.dispatch() self.post() self.get_form() self.form_valid() self.render_to_response()</code> </pre><br>  Metode <code>dispatch</code> instance ini sudah dalam pemetaan url alih-alih fungsi.  Pengiriman berdasarkan kata kerja HTTP mengerti metode mana yang harus dihubungi: POST datang kepada kami dan kami kemungkinan besar ingin instantiate objek form, jika form valid, simpan ke database dan perlihatkan templat.  Ini semua dilakukan melalui sejumlah besar mixin yang membentuk kelas ini. <br><br><h3>  Formulir <br></h3><br>  Formulir harus dibaca dari soket sebelum masuk ke tampilan Django - melalui penangan file yang sama yang terletak di lingkungan WSGI.  form-data adalah aliran byte, di mana pemisah dijelaskan - kita dapat membaca blok ini dan membuat sesuatu darinya.  Ini bisa menjadi korespondensi nilai kunci, jika itu adalah bidang, bagian dari file, lalu lagi beberapa bidang - semuanya dicampur. <br><br><pre> <code class="python hljs">Content-Type: multipart/form-data;boundary=<span class="hljs-string"><span class="hljs-string">"boundary"</span></span> --boundary name=<span class="hljs-string"><span class="hljs-string">"field1"</span></span> value1 --boundary name=<span class="hljs-string"><span class="hljs-string">"field2"</span></span>; value2</code> </pre><br><h4>  Parser <br></h4><br>  Parser terdiri dari 3 bagian. <br><br>  Chunk iterator yang menciptakan pembacaan yang diharapkan dari aliran byte berubah menjadi iterator yang dapat menghasilkan <code>boundaries</code> .  Ini menjamin bahwa jika sesuatu kembali, itu akan menjadi batas.  Hal ini diperlukan agar di dalam pengurai tidak perlu menyimpan keadaan koneksi, membaca dari soket atau tidak membaca untuk meminimalkan logika pemrosesan data. <br><br>  Selanjutnya, generator membungkus di <strong>LazyStream</strong> , yang lagi-lagi membuat file objek dari itu, tetapi dengan pembacaan yang diharapkan.  Jadi parser sudah bisa berjalan melalui potongan-potongan byte dan membangun nilai kunci dari mereka. <br><br>  <strong>bidang dan data di sini akan selalu berupa string</strong> .  Jika kami menerima datatime dalam format ISO, formulir Django (yang ditulis oleh programmer) akan menerima, menggunakan bidang-bidang tertentu, misalnya cap waktu. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.http.multipartparser self._post = QueryDict(mutable=True) stream = LazyStream(ChunkIter(self._input_data)) for field, data in Parser(stream): self._post.append(field, force_text(data))</span></span></code> </pre><br>  Lebih jauh, bentuknya, kemungkinan besar, ingin menyimpan dirinya sendiri dalam basis data, dan di sini Django ORM dimulai. <br><br><h3>  ORM <br></h3><br>  Sekitar melalui permintaan DSL untuk ORM dijalankan: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># models.py Entry.objects.exclude( pub_date__gt=date(2005, 1, 3), headline='Hello', )</span></span></code> </pre><br>  Menggunakan kunci, Anda dapat mengumpulkan ekspresi SQL yang serupa: <br><br><pre> <code class="python hljs">SELECT * WHERE NOT (pub_date &gt; <span class="hljs-string"><span class="hljs-string">'2005-1-3'</span></span> AND headline = <span class="hljs-string"><span class="hljs-string">'Hello'</span></span>)</code> </pre><br>  Bagaimana kabarnya? <br><br><h4>  Queryset <br></h4><br>  Metode <code>exclude</code> memiliki objek <code>Query</code> bawah tenda.  Objek dilewatkan argumen ke fungsi, dan itu menciptakan hirarki objek, yang masing-masing dapat mengubah dirinya menjadi bagian terpisah dari permintaan SQL sebagai string. <br><br>  Ketika melintasi pohon, masing-masing bagian melakukan polling pada node anaknya, menerima query SQL yang bersarang, dan sebagai hasilnya, kita dapat membangun SQL sebagai string.  Sebagai contoh, nilai-kunci tidak akan menjadi bidang SQL yang terpisah, tetapi akan dibandingkan dengan nilai-nilai.  Gabungan dan penolakan query bekerja dengan cara yang sama dengan traversal pohon rekursif, untuk setiap node yang disebut sebagai pemeran SQL. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.db.models.query sql.Query(Entry).where.add( ~Q( Q(F('pub_date') &gt; date(2005, 1, 3)) &amp; Q(headline='Hello') ) )</span></span></code> </pre><br><h4>  Kompiler <br></h4><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.db.models.expressions class Q(tree.Node): AND = 'AND' OR = 'OR' def as_sql(self, compiler, connection): return self.template % self.field.get_lookup('gt')</span></span></code> </pre><br><h3>  Keluaran <br></h3><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Q(headline=<span class="hljs-string"><span class="hljs-string">'Hello'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># headline = 'Hello' &gt;&gt;&gt; F('pub_date') # pub_date &gt;&gt;&gt; F('pub_date') &gt; date(2005, 1, 3) # pub_date &gt; '2005-1-3' &gt;&gt;&gt; Q(...) &amp; Q(...) # ... AND ... &gt;&gt;&gt; ~Q(...) # NOT …</span></span></code> </pre><br>  Kompiler pembantu kecil dilewatkan ke metode ini, yang dapat membedakan dialek MySQL dari PostgreSQL dan mengatur gula sintaksis yang digunakan dalam dialek database tertentu dengan benar. <br><br><h3>  Routing DB <br></h3><br>  Ketika kami menerima permintaan SQL, model mengetuk pada perutean DB dan menanyakan basis data yang mana.  Dalam 99% kasus, ini akan menjadi basis data default, sisanya 1% - semacam miliknya sendiri. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.db.utils class ConnectionRouter: def db_for_read(self, model, **hints): if model._meta.app_label == 'auth': return 'auth_db'</span></span></code> </pre><br>  Membungkus driver basis data dari antarmuka pustaka tertentu, seperti Python MySQL atau Psycopg2, menciptakan objek universal yang dapat digunakan Django.  Ada pembungkus untuk kursor, pembungkus untuk transaksi. <br><br><h4>  Kolam renang penghubung <br></h4><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.db.backends.base.base class BaseDatabaseWrapper: def commit(self): self.validate_thread_sharing() self.validate_no_atomic_block() with self.wrap_database_errors: return self.connection.commit()</span></span></code> </pre><br>  Dalam koneksi khusus ini, kami mengirim permintaan ke soket yang mengetuk database dan menunggu eksekusi.  Pembungkus perpustakaan akan membaca respon manusia dari database dalam bentuk catatan, dan Django mengumpulkan contoh model dari data ini dalam tipe Python.  Ini bukan iterasi yang rumit. <br><br>  Kami menulis sesuatu ke dalam basis data, membaca sesuatu, dan memutuskan untuk memberi tahu pengguna tentang hal itu menggunakan halaman HTML.  Untuk melakukan ini, Django memiliki bahasa templat yang tidak disukai komunitas yang terlihat seperti bahasa pemrograman, hanya dalam file HTML. <br><br><h3>  Templat <br></h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> django.template.loader <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> render_to_string render_to_string(<span class="hljs-string"><span class="hljs-string">'my_template.html'</span></span>, {<span class="hljs-string"><span class="hljs-string">'entries'</span></span>: ...})</code> </pre><br><h4>  Kode <br></h4><br><pre> <code class="python hljs">&lt;ul&gt; {% <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> entry <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> entries %} &lt;li&gt;{{ entry.name }}&lt;/li&gt; {% endfor %} &lt;/ul&gt;</code> </pre><br><h4>  Parser <br></h4><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.template.base BLOCK_TAG_START = '{%' BLOCK_TAG_END = '%}' VARIABLE_TAG_START = '{{' VARIABLE_TAG_END = '}}' COMMENT_TAG_START = '{#' COMMENT_TAG_END = '#}' tag_re = (re.compile('(%s.*?%s|%s.*?%s|%s.*?%s)' % (re.escape(BLOCK_TAG_START), re.escape(BLOCK_TAG_END), re.escape(VARIABLE_TAG_START), re.escape(VARIABLE_TAG_END), re.escape(COMMENT_TAG_START), re.escape(COMMENT_TAG_END))))</span></span></code> </pre><br>  Kejutan - regexp lagi.  Hanya pada bagian akhir harus ada koma, dan daftar akan jauh ke bawah.  Ini mungkin regexp paling sulit yang pernah saya lihat dalam proyek ini. <br><br><h3>  Lexer <br></h3><br>  Handler template dan interpreter sangat sederhana.  Ada lexer yang menggunakan regexp untuk menerjemahkan teks ke dalam daftar token kecil. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.template.base def tokenize(self): for bit in tag_re.split(template_string): lineno += bit.count('\n') yield bit</span></span></code> </pre><br>  Kami beralih ke daftar token, lihat: "Siapa kamu?  Membungkus Anda dalam simpul tag. "  Misalnya, jika ini adalah awal dari beberapa <code>if</code> atau <code>for</code> atau <code>for</code> , penangan tag akan mengambil penangan yang sesuai.  For handler itu sendiri memberi tahu parser: "Baca saya daftar token sampai ke tag penutup." <br><br>  Operasi kembali ke parser. <br><br><blockquote>  Node, tag, dan parser adalah hal yang saling rekursif, dan kedalaman rekursi biasanya sama dengan bersarangnya template itu sendiri dengan tag. <br></blockquote><br><h4>  Parser <br></h4><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> tokens: token = tokens.pop() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> token.startswith(BLOCK_TAG_START): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> TagNode(token) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> token.startswith(VARIABLE_TAG_START): ...</code> </pre><br>  Penangan tag memberi kita simpul tertentu, misalnya, dengan loop for, yang muncul metode <code>render</code> . <br><br><h4>  Untuk loop <br></h4><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.template.defaulttags @register.tag('for') def do_for(parser, token): args = token.split_contents() body = parser.parse(until=['endfor']) return ForNode(args, body)</span></span></code> </pre><br><h4>  Untuk simpul <br></h4><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ForNode</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Node)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, context)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> context.push(): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.args: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> self.body.render(context)</code> </pre><br>  Metode <code>render</code> adalah pohon render.  Setiap simpul atas dapat pergi ke simpul anak, memintanya untuk membuat.  Pemrogram digunakan untuk menunjukkan beberapa variabel dalam templat ini.  Ini dilakukan melalui <code>context</code> - disajikan dalam bentuk kamus reguler.  Ini adalah tumpukan kamus untuk meniru lingkup ketika kita memasukkan tag.  Misalnya, jika <code>context</code> sendiri mengubah beberapa tag lain di dalam loop <code>for</code> , maka ketika kita keluar dari loop perubahan akan dibatalkan.  Ini nyaman karena ketika semuanya bersifat global, sulit untuk bekerja. <br><br><h3>  Tanggapan <br></h3><br>  Akhirnya, kami mendapat tanggapan dari respons HTTP: <br><br><blockquote>  Halo Dunia! <br></blockquote><br>  Kami dapat memberikan garis ke pengguna. <br><br><ul><li>  Kembalikan respons ini dari tampilan. </li><li>  Lihat daftar middlewares. </li><li>  Middlewares menanggapi, memodifikasi, melengkapi, dan meningkatkan ini. </li><li>  Respons mulai beralih di dalam WSGIHandler, sebagian ditulis ke soket, dan browser menerima respons dari server kami. </li></ul><br>  Semua startup terkenal yang ditulis dalam Django, seperti Bitbucket atau Instagram, dimulai dengan siklus kecil yang dilalui setiap programmer. <br><br>  Semua ini, dan presentasi di Moscow Python Conf ++, perlu bagi Anda untuk lebih memahami apa yang ada di tangan Anda dan bagaimana menggunakannya.  Dalam sihir apa pun, ada sebagian besar regexp yang harus Anda masak. <br><br><blockquote>  Artyom Malyshev dan 23 pembicara hebat lainnya <strong>pada tanggal 5 April</strong> akan kembali memberi kita banyak bahan untuk dipikirkan dan dibahas tentang topik Python pada konferensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Moskow Python Conf ++</a> .  Pelajari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jadwal</a> dan bergabunglah dalam pertukaran pengalaman dalam menyelesaikan berbagai masalah menggunakan Python. <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433482/">https://habr.com/ru/post/id433482/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433468/index.html">Fault Injection: Sistem Anda tidak dapat diandalkan jika Anda belum mencoba untuk memecahkannya</a></li>
<li><a href="../id433472/index.html">Unity 2018.3 dirilis</a></li>
<li><a href="../id433474/index.html">Pylint dari dalam ke luar. Bagaimana dia melakukannya?</a></li>
<li><a href="../id433478/index.html">Mengapa Django dipilih di Tinkoff Magazine</a></li>
<li><a href="../id433480/index.html">Kisah Holivarny tentang linter</a></li>
<li><a href="../id433486/index.html">Apa lagi? Kebangkitan kartu debit non-bank</a></li>
<li><a href="../id433488/index.html">Christmas Scrum Meetup UPD Broadcast mitap</a></li>
<li><a href="../id433490/index.html">Ulasan Printer Creality CR-X 3D</a></li>
<li><a href="../id433494/index.html">10 idiom bahasa Inggris yang tidak akan Anda ketahui</a></li>
<li><a href="../id433496/index.html">Perusahaan milik negara wajib untuk beralih ke perangkat lunak dalam negeri pada tahun 2022</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>