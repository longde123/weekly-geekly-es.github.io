<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé¶ üîõ ü§öüèæ AresDB-Demo: Uber GPU-basiertes Open Source-Echtzeitanalysetool ü•ï üë®üèΩ‚Äçüåæ üó≥Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dank der Echtzeitanalyse erhalten wir als Uber-Mitarbeiter eine Vorstellung vom Stand der Dinge und der Arbeitseffizienz. Auf der Grundlage der Daten ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>AresDB-Demo: Uber GPU-basiertes Open Source-Echtzeitanalysetool</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/440072/"><p>  Dank der Echtzeitanalyse erhalten wir als Uber-Mitarbeiter eine Vorstellung vom Stand der Dinge und der Arbeitseffizienz. Auf der Grundlage der Daten entscheiden wir, wie die Qualit√§t der Arbeit auf der Uber-Plattform verbessert werden kann.  Das Projektteam √ºberwacht beispielsweise die Marktlage und identifiziert potenzielle Probleme auf unserer Plattform.  Software, die auf maschinellen Lernmodellen basiert, prognostiziert Passagierangebote und die Nachfrage nach Fahrern;  Datenverarbeitungsspezialisten verbessern Modelle f√ºr maschinelles Lernen, um die Qualit√§t der Prognosen zu verbessern. </p><br><p><img src="https://habrastorage.org/webt/ii/ml/9e/iiml9el5ttzjjxvz6jrx1ff_zng.png"></p><br><p>  In der Vergangenheit haben wir f√ºr Echtzeitanalysen Datenbankl√∂sungen anderer Unternehmen verwendet, aber keine hat alle unsere Kriterien hinsichtlich Funktionalit√§t, Skalierbarkeit, Effizienz, Kosten und Betriebsanforderungen erf√ºllt. </p><br><p>  AresDB wurde im November 2018 ver√∂ffentlicht und ist ein Open-Source-Echtzeitanalysetool.  Es verwendet ein unkonventionelles Netzteil, Grafikprozessoren (GPU), mit denen Sie den Umfang der Analyse erh√∂hen k√∂nnen.  Die GPU-Technologie, ein vielversprechendes Echtzeit-Analysetool, hat in den letzten Jahren erhebliche Fortschritte gemacht und ist daher ideal f√ºr paralleles Echtzeit-Computing und Datenverarbeitung geeignet. </p><br><p>  In den folgenden Abschnitten beschreiben wir die Struktur von AresDB und wie diese interessante L√∂sung f√ºr die Echtzeitanalyse es uns erm√∂glichte, Uber-Datenbankl√∂sungen f√ºr die Echtzeitanalyse effizienter und rationaler zu vereinheitlichen, zu vereinfachen und zu verbessern.  Wir hoffen, dass Sie nach dem Lesen dieses Artikels AresDB als Teil Ihrer eigenen Projekte ausprobieren und auch dessen N√ºtzlichkeit sicherstellen! </p><a name="habracut"></a><br><h3 id="prilozheniya-uber-dlya-analiza-v-realnom-vremeni">  Uber Echtzeit-Analyseanwendungen </h3><br><p>  Die Datenanalyse ist entscheidend f√ºr den Erfolg von Uber.  Unter anderem werden Analysewerkzeuge verwendet, um die folgenden Aufgaben zu l√∂sen: </p><br><ul><li>  Erstellen von <strong>Dashboards</strong> zur √úberwachung von Gesch√§ftsmetriken. </li><li>  Treffen <strong>automatischer Entscheidungen</strong> (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ermittlung der Reisekosten</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ermittlung von Betrugsf√§llen</a> ) auf der Grundlage der gesammelten zusammenfassenden Messdaten. </li><li>  Erstellen Sie <strong>zuf√§llige Abfragen</strong> zur Diagnose, Fehlerbehebung und Fehlerbehebung von Gesch√§ftsvorg√§ngen. </li></ul><br><p>  Wir kategorisieren diese Funktionen mit unterschiedlichen Anforderungen wie folgt: </p><br><p><img src="https://habrastorage.org/webt/oa/sp/lm/oasplm7jy6mqhkoevqutusej-sa.png"></p><br><p>  Dashboards und Entscheidungssysteme verwenden Echtzeitanalysesysteme, um √§hnliche Abfragen f√ºr relativ kleine, aber sehr wichtige Teilmengen von Daten (mit der h√∂chsten Datenrelevanz) mit hohem QPS und geringer Latenz zu erstellen. </p><br><h3 id="potrebnost-v-drugom-analiticheskom-module">  Ben√∂tigen Sie ein anderes Analysemodul </h3><br><p>  Das h√§ufigste Problem, das Uber mithilfe von Echtzeitanalyse-Tools l√∂st, ist die Berechnung von Zeitreihenpopulationen.  Diese Berechnungen geben eine Vorstellung von Benutzerinteraktionen, damit wir die Qualit√§t der Dienste entsprechend verbessern k√∂nnen.  Basierend darauf fordern wir Indikatoren f√ºr bestimmte Parameter (z. B. Tag, Stunde, Stadtkennung und Reisestatus) f√ºr einen bestimmten Zeitraum f√ºr zuf√§llig gefilterte (oder manchmal kombinierte) Daten an.  Im Laufe der Jahre hat Uber mehrere Systeme eingesetzt, um dieses Problem auf verschiedene Weise zu l√∂sen. </p><br><p>  Hier sind einige L√∂sungen von Drittanbietern, mit denen wir diese Art von Problem gel√∂st haben: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apache Pinot</a> , eine in Java geschriebene verteilte Open-Source-Analysedatenbank, eignet sich f√ºr umfangreiche Datenanalysen.  Pinot verwendet eine interne Lambda-Architektur, um Paketdaten und Echtzeitdaten im Spaltenspeicher abzufragen, einen invertierten Bitindex zum Filtern und einen Sternbaum, um aggregierte Ergebnisse zwischenzuspeichern.  Es unterst√ºtzt jedoch keine schl√ºsselbasierte Deduplizierung, Aktualisierung oder Einf√ºgung, Zusammenf√ºhrung oder erweiterte Abfragefunktionen wie die Geodatenfilterung.  Da Pinot eine JVM-basierte Datenbank ist, ist das Abfragen im Hinblick auf die Speichernutzung sehr teuer. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Elasticsearch wird</a> von Uber verwendet, um verschiedene Streaming-Analyseaufgaben zu l√∂sen.  Es basiert auf der Apache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lucene-</a> Bibliothek, in der Dokumente gespeichert sind, f√ºr die Volltext-Schl√ºsselwortsuche und einen invertierten Index.  Das System ist weit verbreitet und erweitert, um aggregierte Daten zu unterst√ºtzen.  Ein invertierter Index bietet Filterung, ist jedoch nicht f√ºr das Speichern und Filtern von Daten basierend auf Zeitbereichen optimiert.  Datens√§tze werden in Form von JSON-Dokumenten gespeichert, was zus√§tzliche Kosten f√ºr den Zugriff auf das Repository und die Anforderungen verursacht.  Wie Pinot ist Elasticsearch eine JVM-basierte Datenbank und unterst√ºtzt dementsprechend die Join-Funktion nicht, und die Ausf√ºhrung von Abfragen nimmt viel Speicherplatz in Anspruch. </li></ul><br><p>  Obwohl diese Technologien ihre St√§rken haben, fehlten ihnen einige der f√ºr unseren Anwendungsfall erforderlichen Funktionen.  Wir brauchten eine einheitliche, vereinfachte und optimierte L√∂sung, und bei der Suche arbeiteten wir in einer nicht standardm√§√üigen Richtung (genauer gesagt innerhalb der GPU). </p><br><h3 id="ispolzovanie-gpu-dlya-analiza-v-realnom-vremeni">  Verwendung der GPU f√ºr die Echtzeitanalyse </h3><br><p>  F√ºr ein realistisches Rendern von Bildern mit einer hohen Bildrate verarbeiten GPUs gleichzeitig eine gro√üe Anzahl von Formen und Pixeln mit hoher Geschwindigkeit.  Obwohl die Tendenz, die Taktfrequenz von Datenverarbeitungseinheiten in den letzten Jahren zu erh√∂hen, abgenommen hat, hat die Anzahl der Transistoren im Chip nur nach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dem Moore'schen Gesetz</a> zugenommen.  Infolgedessen steigt die GPU-Rechengeschwindigkeit, gemessen in Gigaflops pro Sekunde (Gflops / s), schnell an.  Abbildung 1 zeigt einen Vergleich des theoretischen Geschwindigkeitstrends (Gflops / s) der NVIDIA-GPU und der Intel-CPU √ºber die Jahre: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/mq/gh/wg/mqghwgau9j51rlgs_hratcvmw7i.png"></a> </p><br><p>  <em>Abbildung 1. Vergleich der Gleitkomma-CPU- und GPU-Leistung mit einfacher Genauigkeit √ºber mehrere Jahre.</em>  <em>Bild aus dem CUDA C-Programmierhandbuch von Nvidia.</em> </p><br><p>  Bei der Entwicklung des Echtzeitanalyseanforderungsmechanismus war die Entscheidung zur Integration der GPU selbstverst√§ndlich.  In Uber erfordert eine typische Echtzeitanalyseanforderung, dass Daten in wenigen Tagen mit Millionen oder sogar Milliarden von Datens√§tzen verarbeitet, dann gefiltert und in kurzer Zeit zusammengefasst werden.  Diese Rechenaufgabe passt perfekt in das Allzweck-GPU-Parallelverarbeitungsmodell, weil sie: </p><br><ul><li>  Sie verarbeiten Daten parallel mit sehr hoher Geschwindigkeit. </li><li>  Sie bieten eine h√∂here Rechengeschwindigkeit (Gflops / s), wodurch sie sich hervorragend f√ºr die Ausf√ºhrung komplexer Rechenaufgaben (in Datenbl√∂cken) eignen, die parallelisiert werden k√∂nnen. </li><li>  Sie bieten eine h√∂here Leistung (ohne Verz√∂gerung) beim Datenaustausch zwischen der Recheneinheit und dem Speicher (ALU und globale Speicher-GPU) im Vergleich zu Zentraleinheiten (CPUs), was sie ideal f√ºr die Verarbeitung von parallelen Speicher-E / A-Aufgaben macht, die erfordert eine erhebliche Datenmenge. </li></ul><br><p>  Wir konzentrierten uns auf die Verwendung einer GPU-basierten Analysedatenbank und bewerteten - vom Standpunkt unserer Anforderungen aus - mehrere vorhandene Analysel√∂sungen, die GPUs verwenden: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kinetica</a> , ein GPU-basiertes Analysetool, kam 2009 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf den</a> Markt, zun√§chst f√ºr den Einsatz in der US-Armee und bei Geheimdiensten.  Obwohl es das hohe Potenzial der GPU-Technologie in der Analytik demonstriert, haben wir festgestellt, dass f√ºr unsere Nutzungsbedingungen viele Schl√ºsselfunktionen fehlen, einschlie√ülich √Ñndern des Schemas, teilweises Einf√ºgen oder Aktualisieren, Datenkomprimierung, Festplatten- und Speicherkonfiguration auf Spaltenebene und Verbindung durch r√§umliche Beziehungen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OmniSci</a> , ein Open-Source-SQL-Abfragemodul, schien eine vielversprechende Option zu sein. Bei der Bewertung des Produkts stellten wir jedoch fest, dass einige wichtige Funktionen f√ºr die Verwendung in Uber fehlten, z. B. die Deduplizierung.  Obwohl OminiSci 2017 den Open-Source-Code seines Projekts einf√ºhrte, kamen wir nach der Analyse der auf C ++ basierenden L√∂sung zu dem Schluss, dass eine √Ñnderung oder Verzweigung der Codebasis praktisch nicht m√∂glich ist. </li><li>  GPU-basierte Echtzeit-Analysetools wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GPUQP</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CoGaDB</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GPUDB</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ocelot</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OmniDB</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Virginian</a> werden h√§ufig in Forschungs- und Bildungseinrichtungen eingesetzt.  Angesichts ihrer akademischen Ziele konzentrieren sich diese Entscheidungen jedoch eher auf die Entwicklung von Algorithmen und Testkonzepten als auf die L√∂sung realer Probleme.  Aus diesem Grund haben wir sie nicht ber√ºcksichtigt - unter den Bedingungen unseres Volumens und Umfangs. </li></ul><br><p>  Im Allgemeinen zeigen diese Systeme den enormen Vorteil und das Potenzial der Datenverarbeitung mithilfe der GPU-Technologie und haben uns dazu inspiriert, eine eigene Echtzeit-Analysel√∂sung auf Basis der GPU zu entwickeln, die an die Anforderungen von Uber angepasst ist.  Basierend auf diesen Konzepten haben wir den Quellcode f√ºr AresDB entwickelt und ge√∂ffnet. </p><br><h3 id="obzor-arhitektury-aresdb">  AresDB-Architektur√ºbersicht </h3><br><p>  Auf hoher Ebene speichert AresDB die meisten Daten im Hostspeicher (RAM, der mit der CPU verbunden ist), verwendet die CPU zur Verarbeitung empfangener Daten und Festplatten zur Wiederherstellung von Daten.  W√§hrend des Anforderungszeitraums √ºbertr√§gt AresDB Daten vom Hostspeicher zum GPU-Speicher zur parallelen Verarbeitung in der GPU.  Wie in Abbildung 2 unten gezeigt, enth√§lt AresDB Speicher, Metadatenspeicher und Festplatte: </p><br><p><img src="https://habrastorage.org/webt/my/o0/1h/myo01hflityxzcgrlcfrecplyxc.png"><br>  <em>Abbildung 2. Die einzigartige Architektur von AresDB umfasst Speicher-, Festplatten- und Metadatenspeicher.</em> </p><br><h3 id="tablicy">  Tabellen </h3><br><p>  Im Gegensatz zu den meisten relationalen Datenbankverwaltungssystemen (RDBMS) verf√ºgt AresDB nicht √ºber einen Datenbank- oder Schemabereich.  Alle Tabellen geh√∂ren zum selben Bereich in einem Cluster / einer Instanz von AresDB, sodass Benutzer direkt darauf zugreifen k√∂nnen.  Benutzer speichern ihre Daten in Form von Faktentabellen und Dimensionstabellen. </p><br><p>  <strong>Faktentabelle</strong> </p><br><p>  Die Faktentabelle speichert einen endlosen Strom von Zeitreihenereignissen.  Benutzer verwenden eine Faktentabelle, um Ereignisse / Fakten zu speichern, die in Echtzeit auftreten. Jedes Ereignis ist mit dem Zeitpunkt des Ereignisses verkn√ºpft, und die Tabelle wird h√§ufig zum Zeitpunkt des Ereignisses abgefragt.  Als Beispiel f√ºr die Art der Informationen, die in der Faktentabelle gespeichert sind, k√∂nnen wir Reisen benennen, bei denen jede Reise ein Ereignis ist, und die Zeit der Reiseanforderung wird h√§ufig als die Zeit des Ereignisses bezeichnet.  Wenn einem Ereignis mehrere Zeitstempel zugeordnet sind, wird nur ein Zeitstempel als Uhrzeit des Ereignisses angezeigt und in der Faktentabelle angezeigt. </p><br><p>  <strong>Messtabelle</strong> </p><br><p>  In der Messtabelle werden die aktuellen Merkmale der Einrichtungen (einschlie√ülich St√§dte, Kunden und Fahrer) gespeichert.  Beispielsweise k√∂nnen Benutzer Informationen √ºber die Stadt, insbesondere den Namen der Stadt, die Zeitzone und das Land, in der Messtabelle speichern.  Im Gegensatz zu Faktentabellen, die st√§ndig wachsen, sind Dimensionstabellen immer in ihrer Gr√∂√üe begrenzt (beispielsweise ist bei Uber die Stadttabelle durch die tats√§chliche Anzahl von St√§dten auf der Welt begrenzt).  Ma√ütabellen erfordern keine spezielle Zeitspalte. </p><br><h3 id="tipy-dannyh">  Datentypen </h3><br><p>  Die folgende Tabelle zeigt die aktuellen Datentypen, die von AresDB unterst√ºtzt werden: </p><br><p><img src="https://habrastorage.org/webt/zj/vl/9v/zjvl9v3bezbrorzdbv71ricwzoq.png"></p><br><p>  In AresDB werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeichenfolgen</a> automatisch in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufz√§hlungen</a> konvertiert, bevor sie in die Datenbank eingegeben werden, um das Speichern und die Abfrageeffizienz zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vereinfachen</a> .  Dies erm√∂glicht die √úberpr√ºfung der Gleichheit zwischen Gro√ü- und Kleinschreibung, unterst√ºtzt jedoch keine erweiterten Vorg√§nge wie Verkettung, Teilzeichenfolgen, Masken und den Abgleich regul√§rer Ausdr√ºcke.  In Zukunft beabsichtigen wir, die Volllinien-Support-Option hinzuzuf√ºgen. </p><br><h3 id="osnovnye-funkcii">  Hauptfunktionen </h3><br><p>  Die AresDB-Architektur unterst√ºtzt die folgenden Funktionen: </p><br><ul><li>  <strong>Spaltenbasierter Speicher mit Komprimierung</strong> zur Steigerung der Speichereffizienz (weniger Speicher in Byte zum Speichern von Daten) und der Abfrageeffizienz (weniger Datenaustausch zwischen CPU-Speicher und GPU-Speicher bei der Verarbeitung einer Anforderung) </li><li>  <strong>Echtzeit-Aktualisierung oder Einf√ºgung mit Prim√§rschl√ºsseldeduplizierung</strong> , um die Datengenauigkeit und Echtzeit-Datenaktualisierungen in wenigen Sekunden zu verbessern </li><li>  <strong>GPU-Anforderungsverarbeitung</strong> f√ºr hochparallele <strong>GPU</strong> -Datenverarbeitung mit geringer Anforderungslatenz (von Sekundenbruchteilen bis zu mehreren Sekunden) </li></ul><br><h3 id="stolbchatoe-hranilische">  Spaltenspeicherung </h3><br><p>  <strong>Vektor</strong> </p><br><p>  AresDB speichert alle Daten in einem Spaltenformat.  Die Werte jeder Spalte werden als Spaltenwertvektor gespeichert.  Der Konfidenz- / Unsicherheitsmarker der Werte in jeder Spalte wird in einem separaten Nullvektor gespeichert, w√§hrend der Konfidenzmarker jedes Werts als ein Bit dargestellt wird. </p><br><p>  <strong>Aktiver Speicher</strong> </p><br><p>  AresDB speichert unkomprimierte und unsortierte Spaltendaten (aktive Vektoren) im aktiven Speicher.  Datens√§tze im aktiven Speicher werden in (aktive) Pakete eines bestimmten Volumes unterteilt.  Beim Empfang von Daten werden neue Pakete erstellt, w√§hrend alte Pakete nach der Archivierung von Datens√§tzen gel√∂scht werden.  Der Prim√§rschl√ºsselindex wird zum Auffinden von Deduplizierungs- und Aktualisierungsdatens√§tzen verwendet.  Abbildung 3 unten zeigt, wie wir aktive Datens√§tze organisieren und den Prim√§rschl√ºsselwert verwenden, um ihren Speicherort zu bestimmen: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/sa/ak/mk/saakmkzjumbdukxzaizxhmjbcik.png"></a> <br>  <em>Abbildung 3. Wir verwenden den Prim√§rschl√ºsselwert, um den Speicherort des Pakets und die Position jedes Datensatzes innerhalb des Pakets zu bestimmen.</em> </p><br><p> Die Werte jeder Spalte im Paket werden als Spaltenvektor gespeichert.  Der Zuverl√§ssigkeits- / Unsicherheitsmarker von Werten in jedem Wertvektor wird als separater Nullvektor gespeichert, und der Zuverl√§ssigkeitsmarker jedes Werts wird als ein Bit dargestellt.  In Abbildung 4 unten bieten wir ein Beispiel mit f√ºnf Werten f√ºr die Spalte <code>city_id</code> : </p><br><p> <a href=""><img src="https://habrastorage.org/webt/zp/bs/ld/zpbsldqk0yij-dvewowbgawy8eq.png"></a> <br>  <em>Abbildung 4. Wir speichern Werte (Istwert) und Nullvektoren (Konfidenzmarker) von nicht komprimierten Spalten in der Datentabelle.</em> </p><br><h3 id="arhivnoe-hranilische">  Archivspeicher </h3><br><p>  AresDB speichert auch fertige, sortierte und komprimierte Spaltendaten (Archivvektoren) im Archivspeicher √ºber Faktentabellen.  Datens√§tze im Archivspeicher werden ebenfalls stapelweise verteilt.  Im Gegensatz zu aktiven Paketen speichert das Archivpaket Datens√§tze pro Tag gem√§√ü der koordinierten Weltzeit (UTC).  Ein Archivpaket verwendet seit Unix Epoch die Anzahl der Tage als Paketkennung. </p><br><p>  Datens√§tze werden in sortierter Form gem√§√ü einer benutzerdefinierten Spaltensortierreihenfolge gespeichert.  Wie in Abbildung 5 unten gezeigt, sortieren wir zuerst nach der Spalte <code>city_id</code> und dann nach der <code>city_id</code> : </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ah/qm/dm/ahqmdmonjmy4trbjpzf7lqqdm10.png"></a> <br>  <em>Abbildung 5. Wir sortieren alle Zeilen nach city_id, dann nach state und komprimieren dann jede Spalte nach Gruppencodierung.</em>  <em>Nach dem Sortieren und Komprimieren erh√§lt jede Spalte einen Abrechnungsvektor.</em> </p><br><p>  Das Ziel beim Festlegen der Benutzersortierreihenfolge f√ºr Spalten lautet wie folgt: </p><br><ul><li>  Maximierung des Komprimierungseffekts durch Sortieren von Spalten mit einer kleinen Anzahl von Elementen.  Die maximale Komprimierung verbessert die Speichereffizienz (zum Speichern von Daten sind weniger Bytes erforderlich) und die Abfrageeffizienz (weniger Bytes werden zwischen dem CPU-Speicher und dem GPU-Speicher √ºbertragen). </li><li>  Bereitstellen einer bequemen bereichsbasierten Vorfilterung f√ºr g√§ngige √§quivalente Filter, z. B. city_id = 12.  Durch die Vorfilterung wird die Anzahl der Bytes minimiert, die zum √úbertragen von Daten zwischen dem CPU-Speicher und dem GPU-Speicher erforderlich sind, wodurch die Abfrageeffizienz maximiert wird. </li></ul><br><p>  Eine Spalte wird nur komprimiert, wenn sie in der vom Benutzer angegebenen Sortierreihenfolge vorhanden ist.  Wir versuchen nicht, Spalten mit einer gro√üen Anzahl von Elementen zu komprimieren, da dies wenig Speicherplatz spart. </p><br><p>  Nach dem Sortieren werden die Daten f√ºr jede qualifizierte Spalte mithilfe einer bestimmten Gruppencodierungsoption komprimiert.  Zus√§tzlich zum Wertvektor und zum Nullvektor f√ºhren wir einen Abrechnungsvektor ein, um denselben Wert erneut darzustellen. </p><br><h3 id="priem-dannyh-v-realnom-vremeni-s-podderzhkoy-funkciy-obnovleniya-i-vstavki">  Echtzeit-Datenempfang mit Unterst√ºtzung f√ºr Aktualisierungs- und Einf√ºgefunktionen </h3><br><p>  Clients erhalten Daten √ºber die HTTP-API, indem sie ein Service Pack ver√∂ffentlichen.  Ein Service Pack ist ein speziell geordnetes Bin√§rformat, das die Speicherplatznutzung minimiert und gleichzeitig den zuf√§lligen Zugriff auf Daten gew√§hrleistet. </p><br><p>  Wenn AresDB das Service Pack empf√§ngt, schreibt es zuerst das Service Pack in das Wiederherstellungsvorgangsprotokoll.  Wenn ein Service Pack am Ende des Ereignisprotokolls hinzugef√ºgt wird, identifiziert und √ºberspringt AresDB sp√§te Eintr√§ge in den Faktentabellen zur Verwendung im aktiven Speicher.  Ein Datensatz wird als "sp√§t" betrachtet, wenn die Ereigniszeit vor der archivierten Zeit des Trennungsereignisses liegt.  F√ºr Datens√§tze, die nicht als "sp√§t" eingestuft werden, verwendet AresDB den Prim√§rschl√ºsselindex, um das Paket im aktiven Speicher zu suchen, in den Sie sie einf√ºgen m√∂chten.  Wie in Abbildung 6 unten gezeigt, werden neue Datens√§tze (die zuvor aufgrund des Prim√§rschl√ºsselwerts nicht gefunden wurden) in den leeren Bereich eingef√ºgt und vorhandene Datens√§tze direkt aktualisiert: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/px/y9/ee/pxy9eenpxhgejwvtih8gg37rppu.png"></a> <br>  <em>Abbildung 6. Wenn Daten empfangen werden, werden nach dem Hinzuf√ºgen des Service Packs zum Ereignisprotokoll die ‚Äûsp√§ten‚Äú Eintr√§ge zur umgekehrten Warteschlange und andere Eintr√§ge zum aktiven Speicher hinzugef√ºgt.</em> </p><br><h3 id="arhivirovanie">  Archivierung </h3><br><p>  Wenn Daten empfangen werden, werden Datens√§tze entweder im aktiven Speicher hinzugef√ºgt / aktualisiert oder der umgekehrten Warteschlange hinzugef√ºgt und warten auf die Platzierung im Archivspeicher. </p><br><p>  Wir starten regelm√§√üig einen geplanten Prozess, der als Archivierung bezeichnet wird, in Bezug auf die Datens√§tze des aktiven Speichers, um neue Datens√§tze (Datens√§tze, die noch nie archiviert wurden) an den Archivspeicher anzuh√§ngen.  Der Archivierungsprozess verarbeitet nur die Datens√§tze im aktiven Speicher mit der Ereigniszeit im Bereich zwischen der alten Abschaltzeit (Abschaltzeit vom letzten Archivierungsprozess) und der neuen Abschaltzeit (neue Abschaltzeit basierend auf dem Parameter f√ºr die Archivierungsverz√∂gerung im Tabellenlayout). </p><br><p>  Die Datensatzereigniszeit wird verwendet, um zu bestimmen, in welchen Archivpaketdatens√§tzen kombiniert werden sollen, wenn Archivdaten in t√§gliche Pakete gepackt werden.  Die Archivierung erfordert keine Deduplizierung des Index des Prim√§rschl√ºsselwerts w√§hrend des Zusammenf√ºhrens, da nur Datens√§tze im Bereich zwischen der alten und der neuen Abschaltzeit archiviert werden. </p><br><p>  Abbildung 7 unten zeigt ein Diagramm nach dem Zeitpunkt des Ereignisses eines bestimmten Datensatzes. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/6t/l6/uc/6tl6ucxgbni_inkqwjo8u0pxcrs.png"></a> <br>  <em>Abbildung 7. Wir verwenden die Ereigniszeit und die Ausl√∂sezeit, um die Datens√§tze als neu (aktiv) und alt zu definieren (die Ereigniszeit ist fr√ºher als die archivierte Zeit des Ausl√∂seereignisses).</em> </p><br><p>  In diesem Fall ist das Archivierungsintervall das Zeitintervall zwischen den beiden Archivierungsprozessen, und die Archivierungsverz√∂gerung ist der Zeitraum nach dem Zeitpunkt des Ereignisses, jedoch bis zur Archivierung des Ereignisses.  Beide Parameter sind in den Einstellungen des AresDB-Tabellenschemas definiert. </p><br><h3 id="obratnoe-zapolnenie">  Verf√ºllung </h3><br><p>  Wie in Abbildung 7 oben gezeigt, werden alte Datens√§tze (deren Ereigniszeit vor der archivierten Zeit des Herunterfahrereignisses liegt) f√ºr Faktentabellen zur umgekehrten Warteschlange hinzugef√ºgt und schlie√ülich als Teil des Auff√ºllprozesses verarbeitet.  Die Ausl√∂ser dieses Prozesses sind auch die Zeit oder Gr√∂√üe der umgekehrten Warteschlange, wenn sie einen Schwellenwert erreicht.  Im Vergleich zum Hinzuf√ºgen von Daten zum aktiven Speicher ist das Auff√ºllen asynchron und im Hinblick auf CPU- und Speicherressourcen relativ teuer.  Das Auff√ºllen wird in den folgenden Szenarien verwendet: </p><br><ul><li>  Verarbeitung zuf√§lliger, sehr sp√§ter Daten </li><li>  Manuelle Erfassung historischer Daten aus einem vorgelagerten Datenstrom </li><li>  Eingabe historischer Daten in k√ºrzlich hinzugef√ºgte Spalten </li></ul><br><p>  Im Gegensatz zur Archivierung ist der Backfill-Prozess idempotent und erfordert eine Deduplizierung basierend auf dem Wert des Prim√§rschl√ºssels.  F√ºllbare Daten sind letztendlich f√ºr Abfragen sichtbar. </p><br><p>  Die umgekehrte Warteschlange wird mit einer vordefinierten Gr√∂√üe im Speicher gehalten, und bei einer gro√üen Menge an Auff√ºllung wird der Prozess f√ºr den Client blockiert, bis die Warteschlange durch Starten des Auff√ºllprozesses gel√∂scht wird. </p><br><h3 id="obrabotka-zaprosa">  Anfrage bearbeiten </h3><br><p>  In der aktuellen Implementierung muss der Benutzer die von Uber erstellte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ares Query Language</a> (AQL) verwenden, um Abfragen in AresDB auszuf√ºhren.  AQL ist eine effektive Sprache f√ºr analytische Zeitreihenabfragen und folgt nicht der Standard-SQL-Syntax wie "SELECT FROM WHERE GROUP BY" wie andere SQL-√§hnliche Sprachen.  Stattdessen wird AQL in strukturierten Feldern verwendet und kann in JSON-, YAML- und Go-Objekten enthalten sein.  Anstelle der <code>/SELECT (*) /FROM   /GROUP BY city_id, /WHERE  = ¬´¬ª /AND request_at &gt;= 1512000000</code> wird die entsprechende AQL-Variante in JSON wie folgt geschrieben: </p><br><pre> <code class="plaintext hljs">{ ‚Äútable‚Äù: ‚Äútrips‚Äù, ‚Äúdimensions‚Äù: [ {‚ÄúsqlExpression‚Äù: ‚Äúcity_id‚Äù} ], ‚Äúmeasures‚Äù: [ {‚ÄúsqlExpression‚Äù: ‚Äúcount(*)‚Äù} ], ;‚Äù&gt; ‚ÄúrowFilters‚Äù: [ ‚Äústatus = 'completed'‚Äù ], ‚ÄútimeFilter‚Äù: { ‚Äúcolumn‚Äù: ‚Äúrequest_at‚Äù, ‚Äúfrom‚Äù: ‚Äú2 days ago‚Äù } }</code> </pre> <br><p>  Im JSON-Format bietet AQL Entwicklern eines Dashboards und eines Entscheidungsfindungssystems einen bequemeren Programmabfragealgorithmus als SQL, mit dem sie Abfragen einfach erstellen und mithilfe von Code bearbeiten k√∂nnen, ohne sich um Dinge wie SQL-Injection k√ºmmern zu m√ºssen.  Es fungiert als universelles Abfrageformat f√ºr typische Architekturen von Webbrowsern, externen und internen Servern bis zur Datenbank (AresDB).  Dar√ºber hinaus bietet AQL eine praktische <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Syntax</a> zum Filtern nach Zeit und Batching mit Unterst√ºtzung f√ºr die eigene Zeitzone.  Dar√ºber hinaus unterst√ºtzt die Sprache eine Reihe von Funktionen, z. B. implizite Unterabfragen, um h√§ufige Fehler bei Abfragen zu vermeiden, und erleichtert Entwicklern der internen Schnittstelle das Analysieren und Umschreiben von Abfragen. </p><br><p>  Trotz der vielen Vorteile, die AQL bietet, sind wir uns bewusst, dass die meisten Ingenieure mit SQL besser vertraut sind.  Die Bereitstellung einer SQL-Schnittstelle zum Ausf√ºhren von Abfragen ist einer der n√§chsten Schritte, die wir im Rahmen unserer Bem√ºhungen zur Verbesserung der Interaktion mit AresDB-Benutzern betrachten werden. </p><br><p>  Das Flussdiagramm f√ºr die Ausf√ºhrung von AQL-Abfragen ist in Abbildung 8 dargestellt: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/c7/bo/qq/c7boqqkfrjkqgn8i2zeb1ji6wje.png"></a> <br>  <em>Abbildung 8. Das AresDB-Abfrageflussdiagramm verwendet unsere eigene AQL-Abfragesprache, um Daten schnell und effizient zu verarbeiten und abzurufen.</em> </p><br><h3 id="kompilyaciya-zaprosov">  Abfragekompilierung </h3><br><p>  Eine AQL-Abfrage wird in den internen Abfragekontext kompiliert.  Ausdr√ºcke in Filtern, Messungen und Parametern werden in abstrakten Syntaxb√§umen (AST) zur weiteren Verarbeitung durch einen Grafikprozessor (GPU) analysiert. </p><br><h3 id="zagruzka-dannyh">  Laden von Daten </h3><br><p>  AresDB verwendet Vorfilter, um Archivdaten kosteng√ºnstig zu filtern, bevor sie zur parallelen Verarbeitung an die GPU gesendet werden.  Da archivierte Daten nach der konfigurierten Spaltenreihenfolge sortiert sind, k√∂nnen einige Filter diese Sortierreihenfolge und die bin√§re Suchmethode verwenden, um den geeigneten √úbereinstimmungsbereich zu bestimmen.  Insbesondere k√∂nnen √§quivalente Filter f√ºr alle anf√§nglich sortierten X-Spalten und ein optionaler Bereichsfilter f√ºr sortierte Spalten X + 1 als vorl√§ufige Filter verwendet werden, wie in Abbildung 9 unten gezeigt. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/mq/gj/cw/mqgjcwi-es1twxn2navrzd6bhki.png"></a> <br>  <em>Abbildung 9. AresDB filtert die Spaltendaten vor, bevor sie zur Verarbeitung an die GPU gesendet werden.</em> </p><br><p>  Nach der Vorfilterung sollten nur gr√ºne Werte (die die Filterbedingung erf√ºllen) zur parallelen Verarbeitung an die GPU gesendet werden.  Eingabedaten werden in die GPU geladen und jeweils paketweise verarbeitet.  Dies umfasst sowohl aktive Pakete als auch Archivpakete. </p><br><p>  AresDB verwendet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CUDA-Streams</a> f√ºr Pipelining und Datenverarbeitung.  F√ºr jede Anforderung werden zwei Str√∂me abwechselnd zur Verarbeitung in zwei √ºberlappenden Stufen angewendet.  In Abbildung 10 unten bieten wir ein Diagramm an, das diesen Prozess veranschaulicht. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/gg/b-/hv/ggb-hvvb1tbno_uq2rbokxu1ehi.png"></a> <br>  <em>Abbildung 10. In AresDB √ºbertragen und verarbeiten zwei CUDA-Threads abwechselnd Daten.</em> </p><br><h3 id="vypolnenie-zaprosa">  Abfrageausf√ºhrung </h3><br><p>  Der Einfachheit halber verwendet AresDB <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Thrust-Bibliothek</a> zum Implementieren von Abfrageausf√ºhrungsprozeduren, die Bl√∂cke eines fein abgestimmten parallelen Algorithmus f√ºr die schnelle Implementierung von Abfragen im aktuellen Tool bietet. </p><br><p>  In Thrust werden Eingabe- und Ausgabevektordaten unter Verwendung von Iteratoren mit wahlfreiem Zugriff ausgewertet.  Jeder GPU-Thread sucht an seiner Arbeitsposition nach Eingabe-Iteratoren, liest die Werte und f√ºhrt Berechnungen durch und schreibt das Ergebnis an die entsprechende Position im Ausgabe-Iterator. </p><br><p>  Zur Auswertung von AresDB-Ausdr√ºcken folgt das OOPK-Modell (One Operator Per Core). </p><br><p>  In Abbildung 11 unten wird diese Prozedur anhand des AST-Beispiels demonstriert, das aus dem Dimensionsausdruck <code>request_at ‚Äì request_at % 86400</code> in der Phase der Anforderungskompilierung generiert wurde: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/rq/zd/cq/rqzdcq1dpy3vnwhi8tjqppsxroq.png"></a> <br>  <em>Abbildung 11. AresDB verwendet das OOPK-Modell zur Auswertung von Ausdr√ºcken.</em> </p><br><p>  Im OOPK-Modell umgeht die AresDB-Abfrage-Engine jeden Blattknoten des AST-Baums und gibt einen Iterator f√ºr den Quellknoten zur√ºck.  Wenn der Wurzelknoten ebenfalls endlich ist, wird die Wurzelaktion direkt auf dem Eingabe-Iterator ausgef√ºhrt. </p><br><p>  F√ºr jeden Nicht-Root-Nicht-End-Knoten (in diesem Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Modulo-Operation</a> ) wird ein tempor√§rer Arbeitsbereichsvektor zugewiesen, um das Zwischenergebnis zu speichern, das aus dem Ausdruck <code>request_at% 86400</code> .  Mit Thrust wird eine Kernelfunktion gestartet, um das Ergebnis dieser Anweisung in der GPU zu berechnen.  Die Ergebnisse werden im Arbeitsbereich-Iterator gespeichert. </p><br><p>  Bei einem Root-Knoten wird die Kernelfunktion auf dieselbe Weise ausgef√ºhrt wie bei einem nicht-root-Knoten, der nicht endlich ist.  Abh√§ngig von der Art des Ausdrucks, der im Folgenden ausf√ºhrlich beschrieben wird, werden verschiedene Ausgabeaktionen ausgef√ºhrt: </p><br><ul><li>  Filtern, um die Anzahl der Eingabevektorelemente zu reduzieren </li><li>  Aufzeichnen von Messausgangsdaten in einem Messvektor f√ºr die anschlie√üende Zusammenf√ºhrung von Daten </li><li>  Notieren Sie die Ausgabe der Parameter im Parametervektor f√ºr die anschlie√üende Zusammenf√ºhrung der Daten </li></ul><br><p>  Nach der Auswertung des Ausdrucks werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sortierung</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Transformation</a> durchgef√ºhrt, um die Daten endg√ºltig zu kombinieren.  Bei Sortier- und Transformationsoperationen verwenden wir die Werte des Dimensionsvektors als Schl√ºsselwerte f√ºr das Sortieren und Transformieren und die Werte des Parametervektors als Werte zum Kombinieren von Daten.  Somit werden Zeilen mit √§hnlichen Dimensionswerten gruppiert und kombiniert.  Abbildung 12 zeigt diesen Sortier- und Konvertierungsprozess. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ki/wn/hg/kiwnhgruuhvlm2wenraxbrwhwwk.png"></a> <br>  <em>Abbildung 12. Nach der Auswertung des Ausdrucks sortiert und konvertiert AresDB die Daten gem√§√ü den Schl√ºsselwerten der Messvektoren (Schl√ºsselwert) und Parameter (Wert).</em> </p><br><p>  AresDB unterst√ºtzt auch die folgenden erweiterten Abfragefunktionen: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Join</a> : AresDB unterst√ºtzt derzeit eine Hash-Join-Option zwischen der Faktentabelle und der Dimensionstabelle </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sch√§tzen der Anzahl der Hyperloglog-Elemente</a> : AresDB verwendet den Hyperloglog-Algorithmus </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Geo Intersect</a> : AresDB unterst√ºtzt derzeit nur miteinander verbundene Vorg√§nge zwischen GeoPoint und GeoShape </li></ul><br><h3 id="upravlenie-resursami">  Ressourcenmanagement </h3><br><p>  Als Datenbank, die auf internem Speicher basiert, muss AresDB die folgenden Arten der Speichernutzung verwalten: </p><br><p><img src="https://habrastorage.org/webt/20/_4/bb/20_4bbooneymuteoxhig9tqcdjk.png"></p><br><p>  Beim Start von AresDB wird das konfigurierte Budget f√ºr gemeinsam genutzten Speicher verwendet.  Das Budget ist in alle sechs Speichertypen unterteilt und sollte auch gen√ºgend Platz f√ºr das Betriebssystem und andere Prozesse lassen.  Dieses Budget enth√§lt auch eine statisch konfigurierte √úberlastungssch√§tzung, einen vom Server √ºberwachten aktiven Datenspeicher und archivierte Daten, die der Server je nach verbleibendem Speicherbudget herunterladen und l√∂schen m√∂chte. <br>  Abbildung 13 zeigt das AresDB-Hostspeichermodell. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/no/dq/2t/nodq2t_tlr0fn-cy6ubrdwpqofi.png"></a> <br>  <em>Abbildung 13. AresDB verwaltet seine eigene Speichernutzung so, dass das konfigurierte Gesamtprozessbudget nicht √ºberschritten wird.</em> </p><br><p>  Mit AresDB k√∂nnen Benutzer Preload-Tage und Priorit√§ten auf Spaltenebene f√ºr Faktentabellen festlegen und archivierte Daten nur an Preload-Tagen vorab laden.  Daten, die zuvor nicht heruntergeladen wurden, werden bei Bedarf von der Festplatte in den Speicher geladen.  Beim Auff√ºllen l√∂scht AresDB auch archivierte Daten aus dem Hostspeicher.  Die Prinzipien der AresDB-Entfernung basieren auf den folgenden Parametern: Anzahl der Tage des Vorladens, Priorit√§ten der Spalten, Tag der Kompilierung des Pakets und Gr√∂√üe der Spalte. </p><br><p>  AresDB verwaltet auch mehrere GPU-Ger√§te und simuliert Ger√§teressourcen als GPU-Threads und Ger√§tespeicher, um die Verwendung des GPU-Speichers f√ºr die Verarbeitung von Anforderungen zu verfolgen.  AresDB verwaltet GPU-Ger√§te √ºber einen Ger√§te-Manager, der GPU-Ger√§teressourcen in zwei Dimensionen (GPU-Threads und Ger√§tespeicher) modelliert und die Speichernutzung bei der Verarbeitung von Anforderungen verfolgt.  Nach dem Kompilieren der Anforderung k√∂nnen Benutzer mit AresDB die Menge an Ressourcen sch√§tzen, die zum Abschlie√üen der Anforderung erforderlich sind.  Die Speicheranforderungen des Ger√§ts m√ºssen erf√ºllt sein, bevor die Anforderung gel√∂st wird.  Wenn auf einem Ger√§t derzeit nicht gen√ºgend Speicher vorhanden ist, sollte die Anforderung warten.  Derzeit kann AresDB eine oder mehrere Anforderungen gleichzeitig auf demselben GPU-Ger√§t ausf√ºhren, wenn das Ger√§t alle Ressourcenanforderungen erf√ºllt. </p><br><p>  In der aktuellen Implementierung speichert AresDB keine Eingaben im Ger√§tespeicher f√ºr die Wiederverwendung in mehreren Anforderungen.  AresDB zielt darauf ab, Abfragen f√ºr Datens√§tze zu unterst√ºtzen, die st√§ndig in Echtzeit aktualisiert und schlecht zwischengespeichert werden.  In zuk√ºnftigen Versionen von AresDB beabsichtigen wir, Funktionen zum Zwischenspeichern von Daten im GPU-Speicher zu implementieren, um die Abfrageleistung zu optimieren. </p><br><h3 id="primer-ispolzovaniya-obzornaya-informacionnaya-panel-uber">  Anwendungsbeispiel: Uber √úbersicht Dashboard </h3><br><p>  Bei Uber verwenden wir AresDB, um Dashboards zum Abrufen von Gesch√§ftsinformationen in Echtzeit zu erstellen.  AresDB ist daf√ºr verantwortlich, prim√§re Ereignisse mit st√§ndigen Aktualisierungen zu speichern und kritische Metriken in Sekundenbruchteilen zu berechnen, dank GPU-Ressourcen zu geringen Kosten, sodass Benutzer Dashboards interaktiv verwenden k√∂nnen.  Beispielsweise werden anonymisierte Reisedaten mit einer langen G√ºltigkeitsdauer im Data Warehouse von mehreren Diensten aktualisiert, darunter unser Versandsystem, Zahlungs- und Preissysteme.  Um Reisedaten effizient zu nutzen, teilen Benutzer Daten in verschiedene Dimensionen auf und teilen sie auf, um Einblicke in Echtzeitl√∂sungen zu erhalten. </p><br><p>  Bei Verwendung von AresDB ist das Uber-Dashboard ein weit verbreitetes Analyse-Dashboard, das von Teams im Unternehmen verwendet wird, um relevante Metriken und Echtzeitantworten zur Verbesserung der Benutzererfahrung zu erstellen. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/p-/8e/k6/p-8ek6nx3gioyhngzczop7oh1jw.png"></a> <br>  <em>Abbildung 14. Im Stundenmodus verwendet das Uber-Dashboard AresDB, um Echtzeitdatenanalysen f√ºr bestimmte Zeitr√§ume anzuzeigen.</em> </p><br><p>     ,  ,    : </p><br><p> <strong> ( )</strong> </p><br><p><img src="https://habrastorage.org/webt/he/7a/q4/he7aq4btwhfbdgmj3qy-npinpyy.png"></p><br><p> <strong> ( )</strong> </p><br><p><img src="https://habrastorage.org/webt/wi/ox/pb/wioxpbxuygxvf3lg3gs0velx-rc.png"></p><br><h3 id="shemy-tablic-v-aresdb">    AresDB </h3><br><p>     ,  ,       AresDB   : </p><br><p><img src="https://habrastorage.org/webt/uz/ur/hq/uzurhq1u-nkwue6eq7zqepbyqiu.jpeg"></p><br><p>    ,       ,    ,    ,        ,       . </p><br><p>       <a href="">  AresDB</a>      ,  Apache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kafka</a> ,       ,  Apache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Flink</a>  Apache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spark</a> . </p><br><h3 id="primery-zaprosov-dlya-aresdb">    AresDB </h3><br><p>           , ¬´   ¬ª  ¬´ ¬ª.         ,  -.           24         AQL: </p><br><p><img src="https://habrastorage.org/webt/po/1m/1u/po1m1uit03geewuvntsviruc5pw.jpeg"></p><br><p> <strong>   : <br></strong>         ,        ,   . </p><br><p><img src="https://habrastorage.org/webt/63/wr/9h/63wr9hhyak0furssgtfxa_bcj98.png"></p><br><p>      ,    AresDB    ,     ,                 . AresDB       ,       ,          . </p><br><h3 id="sleduyuschie-shagi">   </h3><br><p> AresDB    Uber         ,            .     ,  ,       AresDB    . </p><br><p>         : </p><br><ul><li> <strong> </strong> :         AresDB,  ,     ,        . </li><li> <strong>   </strong> :      AresDB   2018        ,           ,      AresDB    . </li><li> <strong>  </strong> :       ,     ,          ,       . </li><li> <strong>  </strong> :           ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   (LLVM)</a>    GPU. </li></ul><br><p> AresDB  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a>   Apache.     AresDB     . </p><br><p> <em>          ,         .</em> </p><br><h3 id="blagodarnosti">  Danksagung </h3><br><p> <em>    (Kate Zhang),   (Jennifer Anderson),   (Nikhil Joshi),   (Abhi Khune),   (Shengyue Ji),   (Chinmay Soman),   (Xiang Fu),   (David Chen)    (Li Ning)  ,      !</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de440072/">https://habr.com/ru/post/de440072/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440060/index.html">TensorFlow auf Apache Ignite</a></li>
<li><a href="../de440062/index.html">Mit Vergn√ºgen planen. Wie wir Prozesse ohne Manager einrichten</a></li>
<li><a href="../de440064/index.html">Rechenzentren zur Auswahl: London, Moskau, Z√ºrich, St. Petersburg</a></li>
<li><a href="../de440066/index.html">VSCode-Erweiterungen zur Vereinfachung der JavaScript- und Vue-Entwicklung</a></li>
<li><a href="../de440070/index.html">Julia, Gradientenabstieg und Simplex-Methode</a></li>
<li><a href="../de440074/index.html">Roskomos h√§lt es f√ºr falsch, die Raptor-Motoren Ilona Mask und RD-180 zu vergleichen</a></li>
<li><a href="../de440076/index.html">√úbersetzung und Interpretation von Werbung aus dem Englischen ins Russische</a></li>
<li><a href="../de440078/index.html">Schnelles Compiler-Ger√§t. Teil 4</a></li>
<li><a href="../de440084/index.html">10 Milliarden Softwareexporte sind vernachl√§ssigbar</a></li>
<li><a href="../de440086/index.html">MS-DOS Virus World</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>