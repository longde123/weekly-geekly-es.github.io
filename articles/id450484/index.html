<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👍🏾 🌽 ☝🏾 Kinerja Animasi Situs Web 👐🏾 👦🏼 🌖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saat mengembangkan situs yang melampaui kerangka bootstrap bersyarat, cepat atau lambat muncul pertanyaan tentang kinerja animasi. Mereka sangat penti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kinerja Animasi Situs Web</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450484/"><p><img src="https://habrastorage.org/webt/ih/4a/ik/ih4aikfcshl-qmlrus_osjofine.jpeg" alt="gambar"></p><br><p> Saat mengembangkan situs yang melampaui kerangka bootstrap bersyarat, cepat atau lambat muncul pertanyaan tentang kinerja animasi.  Mereka sangat penting di situs desain, seperti yang masuk dalam katalog Awwwards, FWA, CSS Design Awards, dll.  Dalam hal ini, seringkali tugas membuat animasi dan optimasi berikutnya, jika perlu, berada di pundak pengembang yang tidak terlalu berpengalaman yang bahkan tidak tahu harus mulai dari mana.  Biasanya, semua ini diterjemahkan ke dalam situs penghambatan yang tidak mungkin digunakan, dan sikap negatif selanjutnya terhadap seluruh kelas proyek semacam itu.  Pada artikel ini, kami akan mencoba mencari tahu di mana batas kinerja animasi yang dapat diterima, kemacetan apa yang umum dan ke mana harus mencari alat pengembang di tempat pertama. </p><a name="habracut"></a><br><p>  <em>Sebuah komentar kecil: karena artikel ini lebih ditujukan untuk pengembang pemula dan tujuannya adalah untuk menunjukkan pendekatan umum untuk mengoptimalkan animasi, banyak hal akan diberikan dalam bentuk yang disederhanakan, tidak cukup akademis.</em> </p><br><h2 id="kak-brauzer-otobrazhaet-stranicu">  Cara browser menampilkan halaman </h2><br><p>  Pertama-tama, penting untuk memahami apa yang terjadi ketika browser menampilkan kepada kami kondisi halaman saat ini.  Ada empat langkah utama: </p><br><ol><li>  Perhitungan gaya (browser mem-parsing pemilih CSS, menentukan gaya mana yang harus diterapkan untuk apa) </li><li>  Pembuatan tata letak (tata letak halaman sebenarnya terbentuk) </li><li>  Lukisan (membuat representasi piksel elemen untuk rendering berikutnya) </li><li>  Komposisi lapisan (peramban mengumpulkan semuanya dan ditampilkan di layar) </li></ol><br><p>  Selain itu, browser selalu bertindak dalam urutan ini dan berlanjut hingga akhir.  Ketika halaman awalnya ditampilkan setelah memuatnya, keempat langkah harus dilalui.  Di masa depan, tindakan kami dapat menyebabkan eksekusi salah satunya, tetapi pada saat yang sama semua tindakan selanjutnya akan dieksekusi.  Tapi bukan yang sebelumnya. </p><br><p>  Kami akan mempertimbangkan hambatan dari masing-masing langkah ini lebih lanjut, dan sekarang kami akan mengajukan satu pertanyaan konyol pada pandangan pertama, dari mana, secara teori, Anda harus mulai ... </p><br><h2 id="tormozit-ili-ne-tormozit-vot-v-chem-vopros">  Apakah itu melambat atau tidak, itu pertanyaannya ... </h2><br><p>  Sangat sering Anda dapat bertemu orang-orang yang tidak melakukan apa-apa dengan situs web yang jelas lambat dan mengatakan "tetapi kecepatan halaman saya memberi 100 poin, semuanya baik-baik saja."  Atau sebaliknya, di situs yang berfungsi dengan baik, orang telah terlibat dalam beberapa jenis optimasi untuk waktu yang lama, karena beberapa algoritma bekerja secara tidak efisien berdasarkan pada beberapa metrik misterius.  Tetapi di antara yang ekstrem ini haruslah menjadi pusat dari akal sehat, jadi di mana itu? </p><br><p><img src="https://habrastorage.org/webt/zv/su/nv/zvsunvxfwjqvs98q0_yhc9s5jry.jpeg" alt="gambar"></p><br><p>  Untuk <del>  kenal zen </del>  untuk memahami apakah Anda perlu mengoptimalkan animasi Anda, Anda perlu menyadari pemikiran filosofis yang mendalam: </p><br><blockquote>  Jika Anda melihat bahwa situs itu lambat, itu berarti lambat.  Jika Anda tidak melihat bahwa situs melambat, maka itu tidak melambat. </blockquote><p>  Untuk beberapa alasan, banyak orang menganggap pernyataan ini sangat bodoh, tetapi benarkah begitu?  Untuk pengguna akhir, kinerja bukan semacam metrik atau algoritma ideal dengan justifikasi matematis yang ketat.  Baginya, kinerja adalah salah satu dari dua hal: melambat atau tidak melambat. </p><br><p>  Bagaimana dia menentukan ini?  Mata seseorang yang menghabiskan banyak waktu di belakang monitor mulai bereaksi tajam terhadap penurunan fps.  Ini menyebabkan perasaan tidak nyaman yang aneh.  Karenanya, tugas kami, sebagai pengembang, adalah untuk mencegah subsidensi.  Apakah pengguna terbiasa melihat browser berfungsi pada 60fps?  Nah, maka kita melakukan semuanya sehingga semuanya tetap seperti itu.  Kami mengambil laptop dengan setrika sedang dan mencari.  Kami melihat jauh lebih sedikit dari 60fps - kami mengoptimalkan.  Kami melihat sekitar 60 - jangan menyentuh apa pun.  Pengguna tidak akan melihat perbedaannya, dan kami akan menghabiskan banyak waktu untuk optimasi demi optimalisasi. </p><br><blockquote>  Jangan lakukan optimasi untuk optimisasi. </blockquote><br><h2 id="165ms">  16,5 ms </h2><br><p>  Mengekspresikan diri dengan fps tidak nyaman, jadi mari beralih ke milidetik.  Dengan pembagian sederhana 1000ms / 60fps, kami mendapatkan sekitar 16,5ms waktu per frame. </p><br><p>  Apa artinya ini?  Untuk 16.5ms, browser harus menampilkan keadaan halaman saat ini dengan animasi, mengikuti langkah-langkah yang kita lihat di atas, dan pada saat yang sama, sumber daya harus tetap untuk pekerjaan skrip lain, komunikasi dengan server, dll.  Jika lebih banyak waktu dihabiskan untuk menampilkan kondisi halaman saat ini, kita akan melihat melalui mata kita lag.  Jika sekitar 16 ms, maka tidak akan ada amblesan, tetapi kemungkinan beban besi akan sangat tinggi, pendingin akan berdengung, dan telepon akan memanas.  Jadi, kita perlu memastikan bahwa rendering satu frame tidak mendekati nilai ini dalam waktu, dan bahkan lebih baik tidak lebih dari 10 ms, sehingga ada margin dalam kinerja.  Jangan lupa bahwa pengujian selalu dilakukan pada perangkat keras tengah - misalnya, dalam contoh berikut, tangkapan layar akan dilakukan pada Pentium Silver dengan grafis terintegrasi. </p><br><blockquote>  Tes pada perangkat keras yang lebih mungkin dimiliki pengguna Anda.  Jika Anda memiliki prosesor kelas atas dan pertanian pertambangan di bawah meja di tempat kerja Anda, maka semuanya akan bekerja dengan baik untuk Anda, sementara pengguna Anda dengan laptop anggaran bisa sangat sedih. </blockquote><p>  Agar tidak hanya mengandalkan mata dan intuisi Anda yang baik, ada baiknya menguasai alat pengembang, setidaknya di tingkat dasar.  Mereka tidak hanya akan memberikan data kinerja yang akurat, tetapi juga memberi tahu Anda di mana harus mencari masalah, jika semuanya tidak bekerja dengan baik. </p><br><h2 id="instrumenty-razrabotchika-v-google-chrome">  Alat Pengembang di Google Chrome </h2><br><p>  Banyak coders sering dipukul oleh alat pengembang di browser lebih dari konsol linux.  Tetapi sebenarnya tidak ada yang perlu ditakutkan.  Ya, ada banyak tombol, tetapi mereka berlebihan untuk menyelesaikan masalah kita.  Sekarang kita akan melihat di mana ada baiknya memperhatikan terlebih dahulu untuk memahami apa yang harus dilakukan dengan animasi, dan apakah perlu melakukan sesuatu sama sekali. </p><br><p>  Ketika datang ke kinerja, kami akan menghabiskan sebagian besar waktu di tab kinerja dan tekan tombol yang sama. </p><br><p><img src="https://habrastorage.org/webt/a_/wd/vn/a_wdvnjnvppuvnrzp_f4sxp4gb0.png" alt="gambar"></p><br><p>  Pintasan Ctrl-E atau tombol bundar di sebelah kiri mulai dan berhenti merekam apa yang terjadi.  Hasilnya ditampilkan di sini.  Browser menulis banyak hal, tetapi lebih baik melihatnya sekali daripada membacanya berkali-kali, jadi mari kita mengambil beberapa jenis animasi dan melihatnya.  Biarkan itu menjadi animasi CSS sederhana untuk pemula.  Jika Anda membukanya di layar penuh, Anda dapat melihatnya berfungsi dengan kemacetan yang nyata: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/sfi0zy/embed/preview/Xwrqpw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Kami akan merekam beberapa detik dalam mode layar penuh dan melihat apa yang terjadi di sana: </p><br><p><img src="https://habrastorage.org/webt/ih/4a/ik/ih4aikfcshl-qmlrus_osjofine.jpeg" alt="gambar"></p><br><p>  Browser mencatat semua yang dilakukannya.  Di bagian atas jendela kita melihat grafik fps.  Dapat dengan mudah digunakan untuk mendeteksi anomali jika, dalam proses bekerja dengan halaman, ia mulai melambat dengan tajam.  Jika Anda mengklik grafik dengan mouse dan menariknya ke samping atau memutar roda, Anda dapat memilih rentang waktu ini dan informasi terperinci untuk itu akan ditampilkan di bawah.  Dalam contoh sederhana kami, tidak ada anomali, tetapi jelas terlihat bahwa semuanya tidak bekerja dengan sangat merata. </p><br><p>  Segera memperhatikan garis <em>Frames</em> , itu berisi informasi tentang waktu yang dihabiskan pada setiap frame.  Anda dapat memperhatikan bahwa waktu ini terus-menerus melonjak dan secara signifikan melebihi 16 ms (di bawah, dalam contoh praktis, kami akan sedikit meningkatkan animasi ini). </p><br><p>  Selanjutnya kita melihat beberapa baris di mana beban ditampilkan dalam berbagai warna - Anda dapat melihat berapa banyak waktu yang dihabiskan browser untuk berbagai jenis kegiatan.  Animasi kami seragam dan operasi yang sama dilakukan untuk setiap frame, ditandai dengan ungu dan hijau.  Jika Anda memindahkan mouse di atas blok berwarna, itu akan menjadi jelas bahwa kita berurusan dengan item yang disebutkan di awal - <em>menghitung ulang gaya</em> dan <em>memperbarui layer tree</em> berwarna ungu, dan <em>lapisan</em> <em>cat</em> dan <em>komposit</em> berwarna hijau. </p><br><p>  Pertimbangkan animasi lain.  Kali ini dengan skrip - generator suara sederhana.  Ini adalah contoh yang cukup ilustratif, meskipun tidak menarik dari sudut pandang desain: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/sfi0zy/embed/preview/QRLrBJ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Anda mungkin memperhatikan bahwa blok kuning telah ditambahkan yang menampilkan eksekusi skrip.  Jika akan ada banyak pemanggilan fungsi, maka untuk setiap pemanggilan satu blok lagi akan ditambahkan - berdasarkan ukurannya, mudah untuk menemukan fungsi “terberat”, yang, mungkin, perlu memulai pengoptimalan. </p><br><p><img src="https://habrastorage.org/webt/er/j_/cb/erj_cbmcg89tvzk-dco35nqcmia.jpeg" alt="gambar"></p><br><p>  Dalam contoh tersebut, waktu yang dihabiskan untuk satu frame berfluktuasi sekitar 80ms.  Tetapi apa yang ada di sana, bahkan dengan mata telanjang Anda dapat dengan jelas melihat bagaimana semuanya crash.  Melihat bagian <em>ringkasan</em> di bawah ini, kami melihat bahwa skrip memakan waktu paling banyak.  Dibandingkan dengan mereka, <em>rendering</em> dan <em>pengecatan</em> tampak seperti kesalahan yang bisa diabaikan.  Tidak selalu, tentu saja, itu terjadi, tetapi cukup sering. </p><br><p>  Jika Anda mengklik blok yang ditandai sebagai <em>panggilan fungsi</em> , maka di bawah ini adalah tautan ke fungsi dalam kode skrip.  Jika Anda melewatinya, Anda dapat melihat bahwa dalam contoh ini ada siklus melalui semua piksel pada layar.  Akan lebih logis untuk melakukan tugas seperti itu pada shader, maka kinerjanya akan jauh lebih baik.  Tetapi kita akan melihatnya dalam contoh-contoh praktis. </p><br><h2 id="chto-delat-esli">  Apa yang harus dilakukan jika ... </h2><br><p>  Kami mempelajari langkah-langkah apa yang ada saat menampilkan kondisi halaman saat ini di browser, dan ke mana harus mencari yang mana yang paling memakan waktu.  Sudah saatnya berkenalan dengan alasan paling umum mengapa langkah ini atau itu mulai membutuhkan terlalu banyak sumber daya dan memberikan beberapa tips tentang apa yang harus dilakukan dalam kasus ini atau itu. </p><br><h2 id="style-calculation">  Perhitungan gaya </h2><br><p>  Jika Anda melihat bahwa sudah pada langkah ini masalah mulai - kemungkinan besar intinya bahkan tidak di animasi, tetapi pada kenyataan bahwa ada terlalu banyak elemen pada halaman.  Dalam situs desain ini cukup jarang, biasanya masalah seperti itu adalah satelit dari tabel besar dengan ribuan elemen, tetapi jika Anda masih menemukan ini: </p><br><blockquote>  Kurangi jumlah elemen pada halaman, sederhanakan tata letaknya.  Berikan perhatian khusus pada pengulangan potongan kode dengan pembungkus, kemungkinan mereka dapat dihapus. </blockquote><p>  Alasan kedua yang terkait dengan yang pertama adalah pemilih CSS yang kompleks.  Jika pada halaman kecil sangat mungkin untuk menggunakan hack yang bersarang dalam, rumit dengan elemen tetangga, dll, maka pada halaman yang sangat besar ini semua dapat menyebabkan kinerja yang buruk. </p><br><blockquote>  Sederhanakan penyeleksi CSS, gunakan BEM. </blockquote><br><h2 id="layout-creation">  Pembuatan tata letak </h2><br><p>  Item ini sudah lebih dekat dengan desain dan animasi, hal-hal menarik dimulai di sini.  Hal pertama yang penting untuk dipahami adalah bahwa seluruh tata letak terbentuk.  Jika kita mengubah sesuatu, itu terbentuk lagi.  Karena alasan ini, bahkan perubahan kecil pada halaman besar dapat menyebabkan keterlambatan nyata pada langkah ini. </p><br><p>  Aturan utama yang memandu kami saat membuat animasi adalah tidak mengizinkan restrukturisasi tata letak dengan biaya berapa pun.  Karena itu, kami biasanya tidak mencoba mengoptimalkannya (dan tidak ada peluang khusus), yaitu, kami berusaha menghindarinya. </p><br><p>  Ada banyak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">properti</a> yang dapat menyebabkan pembangunan kembali tata letak, Anda dapat menemukan daftar di Internet, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">csstriggers.com</a> tidak buruk.  Lebih sering daripada yang lain di animasi Anda dapat menemukan properti: </p><br><pre><code class="plaintext hljs">display position / top / left / right / bottom width / height padding / margin border font-size / font-weight / line-height ...</code> </pre> <br><p>  Anda mungkin memperhatikan bahwa semua properti ini disatukan oleh satu hal - mereka menggambarkan karakteristik geometrik elemen - parameter tampilan, ukuran dan lokasi fisik.  Jadi, alih-alih mengingat semuanya, ingat apa yang mereka maksud. </p><br><blockquote>  Jangan mengubah sifat geometris elemen, lebih baik menggunakan transformasi dan opacity. </blockquote><p>  Secara terpisah, perlu dicatat bahwa mengubah latar belakang elemen juga akan mengembalikan kita ke langkah ini.  Mereka terus-menerus lupa tentang ini, jadi kami menyoroti dalam rekomendasi terpisah: </p><br><blockquote>  Jangan mengubah elemen latar belakang. </blockquote><p>  Di beberapa browser ( <del>  Saya tidak akan menusuk jari di Firefox </del>  ) kelambatan khas animasi CSS dengan transformasi dapat muncul, terutama jika lebih dari satu animasi dilakukan per unit waktu.  Dari luar, ini mungkin terlihat tidak hanya sebagai jeda dalam karyanya, tetapi juga sebagai "gangguan" dari animasi di awal.  Tampaknya browser terus-menerus menghitung ulang sesuatu.  Perilaku ini hampir selalu diperbaiki menggunakan properti <em>visibilitas-backface</em> . </p><br><blockquote>  Jika memungkinkan, tambahkan visibilitas backface: disembunyikan ke elemen animasi. </blockquote><p>  Selain itu, membangun kembali tata letak disebabkan oleh panggilan kami ke elemen dari skrip.  Selain itu, ini tidak harus menjadi perubahan langsung ke CSS, ini juga dapat menjadi daya tarik untuk beberapa properti dan metode elemen.  Yang paling umum adalah: </p><br><pre> <code class="plaintext hljs">offset*** client*** inner*** scroll***</code> </pre> <br><p>  Dalam animasi, Anda harus berhati-hati dengan mereka, karena  jika kita mulai merujuk ke properti dan metode ini untuk sejumlah besar elemen, maka setiap kali ini akan menyebabkan restrukturisasi tata letak. </p><br><blockquote>  Hindari merujuk ke properti dan metode yang disebutkan untuk masing-masing elemen dalam loop. </blockquote><br><h2 id="painting-i-layer-composition">  Lukisan dan komposisi lapisan </h2><br><p>  Kami akan mempertimbangkan dua langkah ini bersama, sebagai  mereka agak terkait dan biasanya jika ada masalah dengan satu, mereka akan bersama yang lain.  Melewati langkah-langkah ini, menghindarinya tidak akan berhasil, jadi kami mencoba untuk mengoptimalkannya. </p><br><p>  Browser tidak menyiapkan gambar piksel halaman, tetapi di bagian - lapisan.  Mungkin ada banyak.  Setiap lapisan ada seolah-olah dalam dirinya sendiri dan tidak mempengaruhi sisanya, yang menciptakan dasar untuk beberapa peretasan CSS.  Tapi kita akan membicarakannya lain kali.  Kemudian gambar terakhir dikumpulkan dari lapisan-lapisan ini.  Dalam konteks animasi, sangat berguna untuk menempatkan elemen animasi di layer terpisah sehingga perubahannya tidak memengaruhi semua yang ada di sekitarnya.  Sangat diharapkan bahwa kandungan unsur-unsurnya kecil.  Kita dapat melakukan ini menggunakan properti <em>will-change</em> atau, seperti yang kita lakukan sebelumnya, <em>transform: translateZ (0)</em> .  Satu-satunya hal yang perlu diingat adalah Anda tidak dapat menambah jumlah layer tanpa batas.  Pada titik tertentu, ini akan memainkan trik dan kinerja sebaliknya akan turun.  Jadi akan ada dua tips: </p><br><blockquote>  Gunakan will-change atau transform: translateZ (0) untuk memindahkan elemen animasi ke layer terpisah. </blockquote><p>  tetapi pada saat bersamaan </p><br><blockquote>  Jangan berlebihan dengan bisnis ini.  Periksa di alat pengembang bahwa itu tidak lebih buruk. </blockquote><p>  Sangat sering, masalah serius disebabkan oleh filter yang entah bagaimana mengubah gambar elemen.  Ini bisa berupa filter CSS sederhana dengan opsi <em>blur</em> atau bingung dengan SVG, tetapi efeknya akan sama - penurunan kinerja yang nyata. </p><br><blockquote>  Jangan gunakan filter kompleks.  Jika Anda masih membutuhkan efek yang dimaksudkan, pertimbangkan untuk menerapkannya di WebGL. </blockquote><br><h2 id="naskolko-eti-sovety-rabotayut">  Bagaimana cara kerja tips ini? </h2><br><p>  Mereka bekerja, tetapi Anda tidak perlu mengharapkan keajaiban dari mereka.  Di internet, para pemula terkadang mengatakan, "Saya menambahkan surat wasiat, tetapi tidak ada yang berubah."  Biasanya ini berarti bahwa masalah utama ada di tempat lain, dan teknik ini memberi sedikit peningkatan produktivitas sehingga tidak diperhatikan.  Itulah mengapa penting untuk menggunakan alat pengembang untuk memahami dengan jelas di mana hambatannya dan tidak menghabiskan waktu dan upaya untuk mencoba mengoptimalkan apa yang berfungsi dengan baik. </p><br><p>  Dari semua ini kita dapat menyimpulkan bahwa tidak ada banyak cara untuk mempengaruhi rendering halaman, dan efeknya tidak selalu signifikan.  Trik ini bukan peluru perak, mereka lebih dibutuhkan untuk memoles animasi.  Jika kita melihat situs-situs dengan kinerja sangat buruk, kita akan melihat bahwa dalam sebagian besar kasus, skrip kita sendiri yang harus disalahkan, dan bukan masalah misterius dengan parsing CSS di suatu tempat di perut browser. </p><br><h2 id="skripty">  Skrip ... </h2><br><p>  Apakah Anda tahu di mana masalah dengan animasi penghambatan tumbuh paling sering (menurut pengamatan saya)?  Di sini dari pendekatan pengembangan ini: </p><br><p><img src="https://habrastorage.org/webt/31/ov/_a/31ov_auhpakgnb4tu2mtfapgi7w.jpeg" alt="gambar"></p><br><p>  Kedengarannya konyol, tapi memang begitu.  Terus-menerus ada solusi, jelas disalin dari suatu tempat sepenuhnya tanpa memahami apa yang sedang terjadi.  Bahkan terjadi bahwa Anda dapat menghapus setengah kode dan semuanya akan terus berfungsi.  Seringkali kode dalam jawaban untuk SO atau Pemanggang Roti tidak dimaksudkan untuk produksi Anda.  Itu harus jelas.  Dia menunjukkan ide, menjawab pertanyaan, tetapi sama sekali bukan opsi akhir yang optimal untuk tugas spesifik Anda. </p><br><blockquote>  Jika Anda sudah menyalin, maka setidaknya lihat kode untuk tindakan yang tidak perlu. </blockquote><br><h2 id="requestanimationframe">  RequestAnimationFrame </h2><br><p>  Mereka sering berbicara tentang metode ini dan merekomendasikan untuk menggunakannya daripada <em>setTimeout / setInterval</em> dalam animasi.  Ini masuk akal, karena metode-metode tersebut memiliki sifat tidak sinkron dengan bingkai yang digambar ulang oleh peramban, menghasilkan kelambatan kecil.  Tetapi ada dua poin. </p><br><p>  Pertama, jika lebih dari satu elemen dianimasikan pada halaman dan kami memanggil requestAnimationFrame berkali-kali, ini akan menyebabkan penurunan tajam fps.  Secara teori, ini seharusnya tidak, tetapi dalam praktiknya, semuanya terjadi begitu saja.  Anda dapat membiasakan diri dengan tes di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><blockquote>  Gabungkan semua callback animasi menjadi satu requestAnimationFrame. </blockquote><p>  Poin kedua lebih cenderung terhubung dengan situasi di mana kita sudah memiliki animasi yang berat, mungkin dengan penggunaan kanvas, yang kita tidak dapat singkirkan atau tidak punya waktu untuk mengulang, dan hal berikut terjadi: katakanlah animasi harus diselesaikan dalam N detik dan kita sudah menggunakan <em>requestAnimationFrame</em> .  Tetapi dibutuhkan banyak sumber daya untuk menghitung keadaan saat ini dan kami melihat gambar ini: animasi bekerja dengan lancar, indah, tetapi dalam 2N, atau bahkan 3N detik.  Akibatnya, semuanya dianggap sangaaaat.  Untuk memperbaiki perilaku ini, Anda dapat menentang semua rekomendasi, menggunakan <em>setInterval / setTimeout</em> dan mengikat status elemen animasi ke waktu fisik, dan bukan ke frame abstrak.  Akibatnya, kami mendapatkan penurunan formal dalam fps, tetapi dengan efek psikologis dari peningkatan produktivitas. </p><br><blockquote>  Dalam hal animasi yang sangat lambat, mungkin masuk akal untuk menolak requestAnimationFrame yang mendukung setInterval / setTimeout. </blockquote><br><h2 id="canvas-i-sheydery">  Kanvas dan Shader </h2><br><p>  Sebagian besar animasi di situs non-standar terkait dengan kanvas.  Ini bisa dimengerti, CSS adalah hal yang terbatas, tetapi di sini kita dapat mewujudkan fantasi desainer.  Tetapi Anda perlu diingat bahwa kanvas 2d-biasa jauh dari teknologi paling produktif.  Jika Anda mulai menggambar banyak elemen di atasnya atau bekerja dengan piksel secara langsung, maka Anda akan dengan cepat menemukan fakta bahwa fps sedang tenggelam, atau tiba-tiba <em>lukisan</em> dan <em>komposisi lapisan</em> mulai memakan banyak waktu secara tidak senonoh.  Masalah ini dapat dilihat dengan jelas dalam contoh: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/sfi0zy/embed/preview/vdYRoj" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Mari kita lihat apa yang dilakukan browser (Google Chrome terbaru di Linux): </p><br><p><img src="https://habrastorage.org/webt/na/ox/5k/naox5kmmcqfuosbsfhgozpq91zw.jpeg" alt="gambar"></p><br><p>  Perhatikan berapa banyak langkah <em>komposisi lapisan</em> telah diperluas.  Terlihat sedikit tidak masuk akal, karena hanya ada satu elemen, apa yang bisa dirakit di sana begitu lama?  Tetapi ketika menggunakan kanvas 2d, perilaku ini tidak biasa, dan ada hubungannya dengan ini sangat bermasalah.  Ini adalah salah satu alasan mengapa kita biasanya cenderung menggunakan WebGL, tidak ada pertanyaan seperti itu. </p><br><blockquote>  Jika ada pilihan antara kanvas 2d dan WebGL, pilih yang kedua.  Ini akan memberikan bonus kinerja awal pada tugas yang sama. </blockquote><p>  Apa yang biasanya dikaitkan dengan WebGL?  Dengan shader.  Dan debugging shader adalah sakit kepala bagi siapa saja yang bekerja dengannya.  Dan alat pengembang di sini praktis tidak berdaya.  Biasanya, jika ada terlalu banyak perhitungan di shader, kita lihat dalam ringkasan di bawah ini bahwa waktu yang paling banyak adalah "sederhana", yang sebenarnya adalah pelaksanaan shaders kami terlepas dari browser, dan kami tidak bisa mendapatkan detail yang berguna. </p><br><p>  Ada beberapa rekomendasi tentang fungsi mana yang lebih disukai daripada shader, karena fungsi tersebut seharusnya lebih optimal.  Atau bahwa operasi pemblokiran harus dihindari.  Ini semua benar, tetapi menurut pengamatan saya, dalam kebanyakan kasus, shader yang memperlambat situs terlalu banyak hanyalah shader yang sangat besar.  Jika Anda menulis 100 baris GLSL di satu tempat, ini hampir dijamin bekerja dengan buruk.  Dan jika ada juga konstruksi bersarang yang berbeda, loop, maka semuanya - tulis hilang.  Sulit untuk memberikan rekomendasi apa pun di sini, kecuali: </p><br><blockquote>  Jika Anda menyadari selama pekerjaan bahwa semuanya lebih rumit daripada yang tampak pada awalnya, dan bahwa akan ada banyak kode dan akan melambat - lebih baik untuk membahas hal ini dengan perancang dan pelanggan sesegera mungkin dan pikirkan apa yang bisa diubah. </blockquote><p>  Seringkali Anda bisa sampai pada kesimpulan bahwa video yang sudah disiapkan sebelumnya akan bekerja jauh lebih baik daripada mencoba membuat sesuatu yang membingungkan secara real time.  Ingat ini.  Ya, semua orang ingin menunjukkan diri mereka sendiri, mereka ingin pamer "tapi saya bisa melakukannya seperti itu", tetapi jangan lupa tentang pengguna akhir. </p><br><p>  Sehubungan dengan pemikiran ini, saya mengingat "penyakit" yang membuat Olimpiade sebelumnya sangat rentan.  Untuk beberapa alasan, ini sangat dimanifestasikan ketika bekerja dengan kanvas.  Karena alasan itu, Anda harus selalu dengan hati-hati menyalin kode orang-orang tersebut.  Mereka mencoba menggunakan algoritma matematika yang "benar", formula fisik yang kompleks, untuk menghitung semua pergerakan elemen dengan akurasi yang tinggi, bahkan ketika itu benar-benar tidak berguna.  Hal ini menyebabkan peningkatan beban pada prosesor dan fakta bahwa untuk 10 ms bersyarat kami tidak berhasil menghitung apa pun.  Dalam praktiknya, Anda sering dapat bertahan dengan rumus perkiraan dan pengetahuan fisika sekolah.  Tidak perlu mempersulit hal-hal, kami membuat situs web, bukan perangkat lunak untuk rudal balistik. </p><br><blockquote>  Gunakan algoritma sederhana. </blockquote><p>  Ada trik lain yang disebut <em>RayMarching</em> .  Beberapa orang menganggap penciptaan efek yang berbeda dengannya sebagai sesuatu seperti tantangan, pemanasan untuk pikiran, dan kadang-kadang hasilnya sangat mengesankan.  Sebagai contoh, seluruh dunia bawah laut dihasilkan di sini (saya memasukkan video, karena dari perhitungan ini secara real time telepon / laptop dapat menggantung sendiri): </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/mQXUHTTq4E8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Shader itu sendiri dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  Dalam praktiknya, ini semua membutuhkan sumber daya yang luar biasa untuk bekerja.  Dalam mode layar penuh, kami memiliki 400-800ms per frame (secara umum, dalam contoh ini, dapat mencapai hingga 1500ms): </p><br><p><img src="https://habrastorage.org/webt/pj/jj/pj/pjjjpj9fu4fcqkvtqg2bggwhqhc.jpeg" alt="gambar"></p><br><p>  Jadi jika Anda mendapati diri Anda berpikir untuk melakukan sesuatu seperti ini di situs pertempuran, beri Anda keyboard di kepala, minum teh dan pikirkan tentang opsi alternatif untuk menerapkan efek. </p><br><blockquote>  Jangan gunakan RayMarching, ini cara yang pasti untuk mematikan kinerja. </blockquote><br><h2 id="prakticheskiy-primer">  Contoh praktis </h2><br><p>  Sering kali tidak ada cukup contoh dalam artikel tentang produktivitas, tetapi sulit untuk mengatakannya.  Jadi pertimbangkan pasangan.  Ingat contoh terowongan pemintalan CSS pertama?  Peramban melakukan banyak hal: </p><br><p><img src="https://habrastorage.org/webt/ih/4a/ik/ih4aikfcshl-qmlrus_osjofine.jpeg" alt="gambar"></p><br><p>  Kami ingin mempercepat sedikit.  Di mana untuk memulai?  Kami melihat blok ungu, yang berarti bahwa peramban secara konstan membangun kembali tata letak.  Tidak ada skrip di sana, tetapi ada animasi CSS di mana sesuatu berubah.  Mari kita lihat kode mereka: </p><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">keyframes</span></span> rotate { <span class="hljs-selector-tag"><span class="hljs-selector-tag">from</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">rotate</span></span>(0); } <span class="hljs-selector-tag"><span class="hljs-selector-tag">to</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">rotate</span></span>(360deg); } } @<span class="hljs-keyword"><span class="hljs-keyword">keyframes</span></span> move-block { <span class="hljs-selector-tag"><span class="hljs-selector-tag">from</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translateX</span></span>(0); <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: @color1; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">to</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translateX</span></span>(-@block-size * 6); <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: @color2; } }</code> </pre> <br><p>  Transformasi tidak membuat kita takut, tetapi kita melihat perubahan di latar belakang elemen.  Kami ingat bahwa ini dapat menyebabkan restrukturisasi tata letak, dan kami pikir apa yang dapat dilakukan dalam situasi ini ... </p><br><p>  Mengubah latar belakang harus dihilangkan dengan cara apa pun, jadi berdasarkan ide umum animasi, kami memutuskan bahwa Anda dapat meletakkan gradien radial di atas, yang akan menciptakan efek volume yang hampir sama.  Seseorang akan mengatakan bahwa gradien memiliki efek buruk pada kinerja, tetapi kami tidak akan mengubahnya.  Biarkan itu lebih baik begitu itu berdampak buruk daripada kita akan memiliki seluruh gunung elemen yang terus-menerus mempengaruhi buruk.  Hasilnya adalah: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/sfi0zy/embed/preview/OYLZpx" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Mari kita lihat apa yang dilakukan browser: </p><br><p><img src="https://habrastorage.org/webt/0i/hc/oh/0ihcohn8cxnwbrq78qgmo8b0-w4.jpeg" alt="gambar"></p><br><p>  Wow ... Alih-alih banyak aksi, kita melihat panggilan langka ke GPU dan tidak ada yang lain, sementara animasi itu sendiri mulai bekerja terasa lebih halus. </p><br><h2 id="esche-primer">  Contoh lain </h2><br><p>  Ingat bagaimana peramban dalam generator suara terlihat: </p><br><p><img src="https://habrastorage.org/webt/er/j_/cb/erj_cbmcg89tvzk-dco35nqcmia.jpeg" alt="gambar"></p><br><p>  Masalahnya pasti ada di skrip.  Dapat dilihat bahwa blok "render" adalah yang terbesar.  Ini adalah fungsi utama kami untuk menampilkan gambar.  Mari kita lihat dia: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> imageData = CTX.createImageData(CTX.canvas.width, CTX.canvas.height); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; imageData.data.length; i += <span class="hljs-number"><span class="hljs-number">4</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> color = getRandom(); imageData.data[i] = color; imageData.data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] = color; imageData.data[i + <span class="hljs-number"><span class="hljs-number">2</span></span>] = color; imageData.data[i + <span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-number"><span class="hljs-number">255</span></span>; } CTX.putImageData(imageData, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); requestAnimationFrame(render); }</code> </pre> <br><p>  Pasti ada pekerjaan yang terjadi dengan piksel individu.  Ini sangat tidak sehat.  Kami mengatakan bahwa jika mungkin lebih baik menggunakan bukan 2d-kanvas, tetapi WebGL, dan tugas ini hanya ingin diparalelkan menggunakan shader.  Mari kita lakukan: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/sfi0zy/embed/preview/VOZxGp" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Apa hasilnya?  Lihat sendiri: </p><br><p><img src="https://habrastorage.org/webt/3m/td/vh/3mtdvhlrjo4-cjuqmzieis4tr7w.jpeg" alt="gambar"></p><br><p>  Waktu untuk satu bingkai menurun hingga hampir 16 ms.  Tentu saja ini tidak ideal, tetapi masih lebih baik dari 80 ms.  Dalam animasi indah yang kompleks, perolehan kinerja seperti itu bisa sangat terlihat.  Saya mengambil kesempatan ini untuk merekomendasikan bahwa pemula membiasakan diri dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengenalan shader dalam pemrograman</a> dan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kelanjutan dengan contoh-contoh</a> . </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Pada artikel ini, kami menemukan cara mengoptimalkan kinerja animasi, cara menggunakan alat pengembang di Chrome dalam konteks ini, dan apa yang harus dicari terlebih dahulu.  Saya harap informasi ini akan bermanfaat bagi pengembang yang dihadapkan dengan tugas seperti itu untuk pertama kalinya dan tidak tahu harus mulai dari mana. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id450484/">https://habr.com/ru/post/id450484/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id450472/index.html">Bagaimana cara membuat peta jalan yang sempurna?</a></li>
<li><a href="../id450474/index.html">Pengenalan python</a></li>
<li><a href="../id450476/index.html">Bagaimana kami mendaftarkan perusahaan di UE</a></li>
<li><a href="../id450478/index.html">Saat ini, banyak add-on populer untuk Firefox telah berhenti berfungsi karena masalah sertifikat.</a></li>
<li><a href="../id450480/index.html">Bagaimana komputasi kuantum dapat memengaruhi pengembangan perangkat lunak</a></li>
<li><a href="../id450486/index.html">9. Periksa Titik Memulai R80.20. Kontrol Aplikasi & Penyaringan URL</a></li>
<li><a href="../id450488/index.html">Aplikasi Android Chock Norris Facts di Kotlin</a></li>
<li><a href="../id450490/index.html">Kesepakatan $ 6,9 miliar: mengapa pengembang GPU membeli produsen peralatan jaringan</a></li>
<li><a href="../id450492/index.html">Pekerjaan sosial dan desain terbuka. Pendahuluan</a></li>
<li><a href="../id450494/index.html">Bagaimana terjemahan dari istilah trunk bergantung pada vendor switch?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>