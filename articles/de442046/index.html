<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôçüèª üë∏üèΩ üíÜüèº Reagieren und Code teilen üôèüèø üè£ ü§òüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich habe vor sehr langer Zeit, im Jahr 2008, als Yandex ein wenig suspendiert war und Yandex.Direct-Skripte, die synchron mit der Site verbunden waren...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reagieren und Code teilen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442046/"><p>  Ich habe vor sehr langer Zeit, im Jahr 2008, als Yandex ein wenig suspendiert war und Yandex.Direct-Skripte, die synchron mit der Site verbunden waren, diese Site einfach get√∂tet, die Code-Aufteilung kennengelernt.  Im Allgemeinen war es damals normal, wenn Ihre ‚ÄûSkripte‚Äú 10 Dateien sind, die Sie in der einzig richtigen Reihenfolge verbinden, was immer noch (mit Verz√∂gerung) immer noch einwandfrei funktioniert. <br>  Dann fing ich an, aktiv mit Karten zu arbeiten, und sie sind immer noch als externe Skripte verbunden, nat√ºrlich Lazy-Load.  Dann habe ich als Mitglied des Yandex.Maps-Teams aktiv <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ymodules verwendet</a> , um das Baumsch√ºtteln auf dem Client zu verwenden, was eine perfekte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codeaufteilung</a> erm√∂glichte. </p><br><p> Und dann ging ich zu <code>webpack</code> und <code>React</code> , in das Land der ver√§ngstigten Idioten, die sich <code>require.ensure</code> wie ein Widder an einem neuen Tor und tat es immer noch. </p><br><p>  Das Aufteilen von Code ist kein Wow-Feature, sondern ein Muss.  Trotzdem w√ºrde die <code>SSR</code> nicht st√∂ren ... </p><br><p><img src="https://habrastorage.org/webt/47/7y/ay/477yayld6xtgc06hmgfejbrfpxc.jpeg"></p><a name="habracut"></a><br><h3 id="malenkoe-vvedenie">  Kleine Einf√ºhrung </h3><br><p>  Heutzutage, wenn Bundles jeden Tag dicker werden, wird die Codeaufteilung wichtiger denn je.  Zu Beginn kamen die Leute aus dieser Situation heraus, indem sie einfach separate Einstiegspunkte f√ºr jede Seite ihrer Anwendung erstellten, was im Allgemeinen gut ist, aber f√ºr SPA nicht funktioniert. <br>  Dann kam die Funktion <code>require.ensure</code> , heute bekannt als <code>dynamic import</code> (nur Import), √ºber die Sie einfach ein Modul anfordern k√∂nnen, das Sie etwas sp√§ter erhalten. </p><br><p>  Die erste Bibliothek √ºber diesen Fall f√ºr React war <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">reaktionsladbar</a> , der Hype, um den es mir immer noch nicht sehr klar ist und der bereits gestorben ist (es hat einfach aufgeh√∂rt, dem Autor zu gefallen). </p><br><p>  Im Moment wird die mehr oder weniger "offizielle" Wahl <code>React.lazy</code> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ladbare Komponenten</a> (nur <code>@loadable</code> ) sein, und die Wahl zwischen ihnen ist offensichtlich: </p><br><ul><li>  React.lazy kann SSR (Server Side Rendering) im Allgemeinen nicht verwenden.  Selbst in Tests wird es ohne spezielle T√§nze mit einem Tamburin fallen, wie zum Beispiel "synchrone Versprechen". </li><li>  Eine ladbare SSR kann und unterst√ºtzt zwar Suspense, ist aber nicht schlechter als React.Lazy. </li></ul><br><p>  Loadable unterst√ºtzt insbesondere sch√∂ne Wrapper zum Laden von Bibliotheken (loadable.lib, Sie k√∂nnen moment.js in React renderProp √ºbernehmen) und hilft dem Webpack auf der Serverseite, eine Liste der verwendeten Skripte, Stile und Ressourcen f√ºr das Prefetching zu sammeln (das Webpack selbst nicht wirklich kennt).  Lesen Sie im Allgemeinen die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offizielle Dokumentation</a> . </p><br><h3 id="ssr">  SSR </h3><br><p>  Im Allgemeinen liegt das ganze Problem in der SSR.  F√ºr CSR (Client Side Render) passt entweder React.lazy oder ein kleines Skript mit 10 Zeilen - dies wird definitiv ausreichen, und es macht keinen Sinn, eine gro√üe externe Bibliothek anzuschlie√üen.  Auf dem Server reicht dies jedoch nicht aus.  Und wenn Sie keine SSR wirklich ben√∂tigen, k√∂nnen Sie das Lesen √ºberspringen.  Sie haben keine Probleme, die lange und schwer gel√∂st werden m√ºssen. </p><br><p>  SSR ist ein Schmerz.  Ich bin (in gewisser Weise) einer der Betreuer von ladbaren Komponenten und es ist einfach schrecklich, wie viele Fehler an verschiedenen Orten auftreten.  Und mit jedem Update fliegt das Webpack noch mehr. </p><br><h3 id="ssr--css">  SSR + CSS </h3><br><p>  Eine noch gr√∂√üere Ursache f√ºr Probleme mit SSRs ist CSS. <br>  Wenn Sie Styled-Komponenten haben - es tut nicht so weh -, werden sie mit einem <code>transform-stream</code> der selbst dem endg√ºltigen Code das hinzuf√ºgt, was ben√∂tigt wird.  Die Hauptsache ist, dass es √ºberall eine Version von SC geben muss, sonst funktioniert der Fokus nicht - eine Version von SC kann nichts anderes √ºber sich selbst erz√§hlen, und SC liebt es, sich zu vermehren (√ºberpr√ºfen Sie Ihr Bundle).  Um ehrlich zu sein, f√§llt gerade wegen dieser Einschr√§nkung der Fokus normalerweise <strong>aus</strong> . </p><br><p>  C Emotion ist einfacher - ihr <code>styled</code> Adapter spuckt nur <code>&lt;style&gt;</code> vor der Komponente selbst aus und das Problem ist gel√∂st.  Einfach, billig und fr√∂hlich.  Im Prinzip ist es sehr mobilfreundlich und optimiert die Erstansicht erheblich.  Aber ein bisschen verdirbt die Sekunde.  Und pers√∂nlich erlaubt mir mein Gewissen nicht, solche Stile zu integrieren. </p><br><p>  Mit normalem CSS (einschlie√ülich des aus verschiedenen CSS-in-JS-Bibliotheken mit unterschiedlicher Magie erhaltenen) ist es noch einfacher - Informationen dazu finden Sie in der Webpack-Spalte, und es ist ‚Äûbekannt‚Äú, welches CSS verbunden werden muss. </p><br><h3 id="poryadok-podklyucheniya">  Verbindungsreihenfolge </h3><br><p>  Hier hat sich der Hund begraben.  Wann soll ich mich verbinden? <br>  Die SSR-freundliche <code>ReactDOM.hydrate</code> dass Sie vor dem Aufrufen von <code>ReactDOM.hydrate</code> alle "Komponenten" herunterladen m√ºssen, die bereits in der Antwort des Servers vorhanden sind, die derzeit auf dem Client geladenen Skripts sich jedoch nicht leisten k√∂nnen. </p><br><p>  Daher bieten alle Bibliotheken einen bestimmten R√ºckruf an, der aufgerufen wird, wenn alles geladen werden muss, und Sie k√∂nnen das <em>Gehirn</em> starten.  Dies ist die Bedeutung der Arbeit von SSR-Codesplitting-Bibliotheken. </p><br><p>  JS kann jederzeit geladen werden, und normalerweise wird ihre Liste am Ende des HTML-Codes hinzugef√ºgt, aber CSS, damit keine FOUC vorhanden ist, muss am Anfang hinzugef√ºgt werden. <br>  Alle Bibliotheken k√∂nnen dies f√ºr den alten <code>renderToString</code> , und nicht alle Bibliotheken k√∂nnen dies f√ºr <code>renderToNodeStream</code> tun. <br>  Es spielt keine Rolle, ob Sie nur JS (dies geschieht nicht) oder SC / Emotion (die sich selbst hinzuf√ºgen) haben.  Aber - wenn Sie "nur CSS" haben - das ist es.  Entweder sind sie am Ende, oder Sie m√ºssen <code>renderToString</code> oder eine andere Pufferung verwenden, die eine TTFB-Verz√∂gerung (Time To First Byte) bietet und das Gef√ºhl, diese SSR im Allgemeinen zu haben, geringf√ºgig verringert. </p><br><p>  Und nat√ºrlich - all dies ist an das Webpack gebunden und auf keine andere Weise.  Daher schlage ich bei allem Respekt vor Greg, dem Autor von ladbaren Komponenten, vor, andere Optionen in Betracht zu ziehen. </p><br><blockquote>  Als n√§chstes folgt eine dreiteilige Agenda, deren Hauptidee darin besteht, etwas zu tun, das nicht get√∂tet wird und nicht vom B√ºndler abh√§ngig ist. </blockquote><br><h3 id="1-react-imported-component">  1. Reagierte importierte Komponente </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">React-Imported-Component</a> ist kein schlechter "Loader" mit einer mehr oder weniger standardm√§√üigen Schnittstelle, die ladbaren Komponenten sehr √§hnlich ist und SSR f√ºr alles kann, was sich bewegt. </p><br><p>  Die Idee ist sehr einfach. </p><br><ul><li>  Quellcodes werden gescannt, alle <code>import</code> werden gefunden und in eine separate Datei <strong>kopiert</strong> </li><li>  Mit dem <code>babel plugin</code> jeder Aufruf zum <code>import</code> zu etwas Zucker <br><pre> <code class="plaintext hljs">const AsyncComponent1 = imported(() =&gt; import('./MyComponent')); ///// const AsyncComponent1 = imported(() =&gt; importedWrapper("imported_18g2v0c_component", import('./MyComponent')));</code> </pre> </li><li>  Wenn Sie die Funktion "import" aufrufen, wird toString einfach ausgef√ºhrt und die magische Nummer wird herausgezogen.  So wird klar, was verursacht wurde.  (Ja - dies legt einige Einschr√§nkungen f√ºr den Code fest, aber weniger als bei anderen Ladern, die ihren Import √ºberhaupt nicht "nicht" k√∂nnen.) </li><li>  Auf dem Client haben wir eine Datei, in der alle m√∂glichen Importe gesammelt werden und jeder Import <em>wiederholt werden kann</em> . </li></ul><br><p>  Sie m√ºssen <code>stats.json</code> , sich nicht an die Webpack-Optimierung anpassen (Verkettung oder allgemeiner Code) - Sie m√ºssen nur die "Bezeichnung" eines Imports im Schl√ºssel im Array abgleichen und erneut importieren.  Wie es als Teil eines bestimmten Bundlers ausgef√ºhrt wird, wie viele Dateien tats√§chlich heruntergeladen werden und von wo ist nicht sein Problem. </p><br><p>  Minus - Der Beginn des Ladens "verwendeter" Chunks erfolgt nach dem Laden des Hauptpakets, in dem die Zuordnung gespeichert ist. Dies ist etwas "sp√§ter" als bei ladbaren Komponenten, bei denen diese Informationen direkt zu HTML hinzugef√ºgt werden. </p><br><p>  Ja, mit CCS funktioniert es in keiner Weise nach dem Wort. </p><br><h3 id="2-used-styles">  2. gebrauchte Stile </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwendete Stile</a> funktionieren jedoch nur mit CSS, jedoch √§hnlich wie reaktionsimportierte Komponenten. </p><br><ul><li>  scannt alle CSS (im Build-Verzeichnis) </li><li>  merkt sich, wo welche Klasse definiert ist </li><li>  scannt die Ausgabe von renderToNodeStream (oder <code>renderToString</code> Antwort von <code>renderToString</code> ) </li><li>  Findet class = 'XXX', stimmt mit der Datei √ºberein und spuckt sie in der Serverantwort aus. </li><li>  (Nun, und teleportiert dann alle diese Stile zum Kopf, um das Hydrat nicht zu brechen).  Stilkomponenten funktionieren genauso. </li></ul><br><p>  Es gibt keine TTBT-Verz√∂gerung, sie ist nicht an den B√ºndler gebunden - ein M√§rchen.  Funktioniert wie eine Uhr, wenn die Stile gut geschrieben sind. </p><br><p>  <a href="">React-Import-Komponente + gebrauchte Stile + Paketarbeitsbeispiel</a> . </p><br><blockquote>  Nicht der offensichtlichste Bonus - auf dem Server erledigen beide Bibliotheken w√§hrend des Startvorgangs "alles, was ben√∂tigt wird", bis der Express-Server den ersten Client empfangen kann, und werden sowohl auf dem Server als auch w√§hrend der Tests vollst√§ndig synchronisiert. </blockquote><br><h3 id="3-react-prerendered-component">  3. Reader-Prerendered-Komponente </h3><br><p>  Und die Bibliothek schlie√üt die ersten drei, was <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"teilweise Rehydration"</a> bewirkt, und zwar auf eine so gro√üv√§terliche Weise, dass ich mich sofort wundere.  Sie f√ºgt wirklich "Diven" hinzu. </p><br><ul><li>  auf dem Server: <br><ul><li>  wickelt ein St√ºck Holz in eine Div mit einem "ber√ºhmten Ausweis" </li></ul></li><li>  auf dem Client: <br><ul><li>  Der Komponentenkonstruktor findet sein eigenes div </li><li>  kopiert sein innerHTML, bevor React es nimmt. </li><li>  Verwendet diesen HTML-Code, bis der Client bereit ist, ihn zu <code>hydrate</code> </li><li>  Technisch erm√∂glicht dies die Verwendung von Hybrid SSR (Rendertron) </li></ul></li></ul><br><pre> <code class="plaintext hljs">const AsyncLoadedComponent = loadable(() =&gt; import('./deferredComponent')); const AsyncLoadedComponent = imported(() =&gt; import('./deferredComponent')); &lt;PrerenderedComponent live={AsyncLoadedComponent.preload()} // when Promise got resolve - component will go "live" &gt; &lt;AsyncLoadedComponent /&gt; // meanwhile you will see "preexisting" content &lt;/PrerenderedComponent&gt;</code> </pre> <br><p>  Dieser Fokus funktioniert nicht mit ladbaren Komponenten, da er <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht von einem Versprechen zum Vorspannen zur√ºckkehrt</a> .  Dies ist besonders wichtig f√ºr Bibliotheken wie React <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">-Snap</a> (und andere "Prerender"), die "Inhalt" haben, aber keine "echte" SSR durchlaufen haben. </p><br><p><img src="https://habrastorage.org/webt/av/oa/uy/avoauymgvrxzwyo18-8skc69cws.png"></p><br><p>  Aus Sicht des Codes sind dies 10 Zeilen plus etwas mehr, um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">stabile SSR-CSR-UIDs</a> zu erhalten, die die zuf√§llige Reihenfolge des Ladens und der Ausf√ºhrung des Codes ber√ºcksichtigen. </p><br><p>  Boni: </p><br><ul><li>  Sie m√ºssen nicht auf das "Laden aller Skripte" warten, bevor Sie die <em>Gehirne</em> starten - die Gehirne werden gestartet, sobald sie bereit sind </li><li>  Sie <strong>m√ºssen √ºberhaupt</strong> keine Gehirne laden, sodass SSR-Daten √ºbrig bleiben (wenn keine SSR-Version vorhanden ist, werden die Gehirne weiterhin geladen).  Genau wie in jQuery-Zeiten. </li><li>  Sie k√∂nnen auch das Stream- <strong>Caching</strong> gro√üer Renderbl√∂cke implementieren (theoretisch Suspence-kompatibel) - wiederum mithilfe des Transformations-Streams. </li><li>  und Serialisieren / Deserialisieren des Status in / aus HTML, wie w√§hrend jQuery </li></ul><br><p>  Im Prinzip waren Serialisierung und Deserialisierung die Hauptidee bei der Erstellung einer Bibliothek, um das Problem der Duplizierung des Zustands zu l√∂sen (Bild aus dem Artikel √ºber SSR).  Caching kam sp√§ter an. <br><img src="https://habrastorage.org/webt/wb/9q/ni/wb9qniykqfav6ouzmjkrtpjhy5w.png"></p><br><h3 id="itogo">  Insgesamt </h3><br><p>  Insgesamt gibt es drei Ans√§tze, mit denen Sie Ihre Sicht auf SSR und Codeaufteilung √§ndern k√∂nnen.  Der erste funktioniert mit JS-Codesplitting und bricht nicht.  Der zweite funktioniert mit CSS-Codesplitting und bricht nicht.  Die dritte Methode vereinfacht und beschleunigt einige Prozesse auf HTML-Ebene und bricht auch hier nicht ab. </p><br><p>  Links zu Bibliotheken: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/theKashey/react-imported-component/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/theKashey/react-prerendered-component</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/theKashey/used-styles</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/smooth-code/loadable-components/</a> </li><li>  (f√ºr diejenigen, die sich im Tank befinden) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://reactjs.org/blog/2018/10/23/react-v-16-6.html#reactlazy-code-splitting-with-suspense</a> </li></ul><br><p>  Artikel (in englischer Sprache) </p><br><ul><li>  (√ºber importiert) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://hackernoon.com/react-and-code-splitting-made-easy-f118befb5168</a> </li><li>  (ungef√§hr vorgerendert) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://medium.com/@antonkorzunov/react-server-side-code-splitting-made-again-a61f8cbbd64b</a> </li><li>  (√ºber SSR) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://developers.google.com/web/updates/2019/02/rendering-on-the-web#partial-rehydration</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442046/">https://habr.com/ru/post/de442046/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442034/index.html">ReCaptcha-Bypass in Selentests</a></li>
<li><a href="../de442036/index.html">Laufzeit f√ºr ausgereifte Container: Containerd wird CNCF-Absolvent</a></li>
<li><a href="../de442038/index.html">Die Zusammenfassung der Ereignisse f√ºr HR-Experten im Bereich IT im M√§rz 2019</a></li>
<li><a href="../de442040/index.html">Partnerschaft als wirksames Instrument f√ºr die Gesch√§ftsentwicklung</a></li>
<li><a href="../de442044/index.html">Wie wir das Zabbix-Einzelhandels√ºberwachungssystem verwenden</a></li>
<li><a href="../de442048/index.html">Wie Google Programmer h√§ufig auftretende Probleme l√∂st</a></li>
<li><a href="../de442050/index.html">Was tun, wenn Sie Geld f√ºr die Reparatur von Fehlern sammeln m√∂chten und nur Wikipedia zur Hand ist?</a></li>
<li><a href="../de442052/index.html">Neue Technologien k√∂nnen die Aufl√∂sung von Bildern biologischer Gewebe verzehnfachen</a></li>
<li><a href="../de442054/index.html">Februar 2019 Joomla Digest</a></li>
<li><a href="../de442056/index.html">M√§rz IT Events Digest (Teil 1)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>