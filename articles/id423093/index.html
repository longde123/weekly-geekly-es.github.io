<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐍 🈷️ 👀 Kami meningkatkan keacakan fakta bahwa [mungkin] [hampir] secara tidak sengaja 🍹 ⛪️ 🔰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="angka acak lebih enak jika sedikit lada 

 Kami akan menggabungkan teori dengan praktik - kami akan menunjukkan bahwa meningkatkan entropi urutan acak...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami meningkatkan keacakan fakta bahwa [mungkin] [hampir] secara tidak sengaja</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423093/"><img src="https://habrastorage.org/webt/g9/kh/sg/g9khsgflhymunz9z4_dd9qww1ny.jpeg"><br>  <i>angka acak lebih enak jika sedikit lada</i> <br><br>  Kami akan menggabungkan teori dengan praktik - kami akan menunjukkan bahwa meningkatkan entropi urutan acak adalah mungkin, setelah itu kami akan melihat kode sumber yang melakukan ini. <br><br>  Saya benar-benar ingin menulis tentang fakta bahwa generasi nomor acak yang berkualitas tinggi, sangat entropis, sangat penting dalam memecahkan sejumlah besar masalah, tetapi ini mungkin berlebihan.  Saya harap semua orang tahu ini dengan sangat baik. <br><br>  Dalam mengejar angka acak berkualitas, orang menciptakan perangkat yang sangat cerdas (lihat, misalnya, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ).  Pada prinsipnya, sumber-sumber keacakan cukup baik dibangun ke dalam API sistem operasi, tetapi ini adalah masalah serius, dan cacing keraguan selalu memakan kita sedikit: apakah RNG yang saya gunakan cukup baik dan itu rusak ... katakanlah, oleh pihak ketiga? <br><a name="habracut"></a><br><h3>  Sedikit teori </h3><br>  <b>Untuk mulai dengan, kami menunjukkan bahwa dengan pendekatan yang tepat, kualitas RNG yang ada tidak dapat diturunkan.</b>  Pendekatan yang benar dan paling sederhana adalah untuk melapisi urutan lain melalui operasi XOR pada urutan <i>utama</i> .  Urutan <i>utama</i> mungkin, misalnya, RNG sistemik, yang kami anggap bagus, tetapi masih ada beberapa keraguan, dan kami memiliki keinginan untuk bermain aman.  Sekuens <i>tambahan</i> mungkin, misalnya, generator bilangan pseudo-acak, yang hasilnya terlihat bagus, tetapi kita tahu bahwa entropinya yang sebenarnya sangat rendah.  Urutan yang <i>dihasilkan</i> akan menjadi hasil dari penerapan operasi XOR ke bit dari urutan primer dan sekunder.  <b>Nuansa yang signifikan: urutan</b> primer dan sekunder harus independen satu sama lain.  Artinya, entropi mereka harus diambil dari sumber yang berbeda secara fundamental, yang saling ketergantungan yang tidak dapat dihitung. <br><br>  Ditunjukkan dengan <b><i>x</i></b> bit berikutnya dari urutan utama, dan <b><i>y</i></b> - bit yang sesuai dari yang tambahan.  Bit dari urutan yang dihasilkan dilambangkan dengan <b><i>r</i></b> : <br>  r = x⊕y <br><br>  <b>Upaya pertama untuk membuktikan.</b>  Mari kita coba melalui entropi informasi <b><i>x</i></b> , <b><i>y</i></b> dan <b><i>r</i></b> .  Kami menunjukkan probabilitas nol <b><i>x</i></b> sebagai <b><i>p <sub>x0</sub></i></b> , dan probabilitas nol <b><i>y</i></b> sebagai <b><i>p <sub>y0</sub></i></b> .  Entropi informasi <b><i>x</i></b> dan <b><i>y</i></b> dihitung sesuai dengan rumus Shannon: <br><br>  H <sub>x</sub> = - (p <sub>x0</sub> log <sub>2</sub> p <sub>x0</sub> + (1 - p <sub>x0</sub> ) log <sub>2</sub> (1 - p <sub>x0</sub> )) <br>  H <sub>y</sub> = - (p <sub>y0</sub> log <sub>2</sub> p <sub>y0</sub> + (1 - p <sub>y0</sub> ) log <sub>2</sub> (1 - p <sub>y0</sub> )) <br><br>  Nol dalam urutan yang dihasilkan muncul ketika ada dua nol atau dua unit pada input.  Probabilitas nol r: <br><br>  p <sub>r0</sub> = p <sub>x0</sub> p <sub>y0</sub> + (1 - p <sub>x0</sub> ) (1 - p <sub>y0</sub> ) <br>  H <sub>r</sub> = - (p <sub>r0</sub> log <sub>2</sub> p <sub>r0</sub> + (1 - p <sub>r0</sub> ) log <sub>2</sub> (1 - p <sub>r0</sub> )) <br><br>  Untuk membuktikan tidak berubahnya urutan utama, perlu untuk membuktikannya <br>  <b><i>Hr - Hx ≥ 0</i></b> untuk nilai <b><i>p <sub>x0</sub></i></b> dan <b><i>p <sub>y0</sub></i></b> .  Saya tidak bisa membuktikannya secara analitis, tetapi perhitungan yang divisualisasikan menunjukkan bahwa peningkatan entropi membentuk permukaan yang halus, yang tidak akan berkurang di mana pun: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mb/un/5x/mbun5xdlkm3zmxc-7brg5lypo4q.png"></div><br>  Sebagai contoh, jika kita menambahkan sinyal tambahan sangat miring dengan <i>p <sub>y0</sub></i> = 0,1 ke sinyal utama miring c <i>p <sub>x0</sub></i> = 0,3 (entropi 0,881), kita mendapatkan hasil <i>p <sub>r0</sub></i> = 0,66 dengan entropi 0,925. <br><br>  Jadi, entropi tidak bisa rusak, tetapi ini belum akurat.  Oleh karena itu, upaya kedua diperlukan.  Namun, melalui entropi kita juga bisa membuktikan.  Skema (semua langkah cukup sederhana, Anda dapat melakukannya sendiri): <br><br><ol><li>  Kami membuktikan bahwa entropi memiliki maksimum pada titik <i>p <sub>0</sub></i> = 1/2. </li><li>  Kami membuktikan bahwa untuk setiap <i>p <sub>x0</sub></i> dan <i>p <sub>y0,</sub></i> nilai <i>p <sub>r0</sub></i> tidak bisa lebih jauh dari 1/2 dari <i>p <sub>x0</sub></i> . </li></ol><br>  <b>Upaya kedua untuk membuktikan.</b>  Melalui kemampuan menebak.  Misalkan seorang penyerang a priori memiliki beberapa informasi tentang urutan primer dan sekunder.  Kepemilikan informasi dinyatakan dalam kemampuan dengan beberapa probabilitas untuk menebak terlebih dahulu nilai <b><i>x</i></b> , <b><i>y</i></b> dan, sebagai hasilnya, <b><i>r</i></b> .  Probabilitas menebak <b><i>x</i></b> dan <b><i>y masing-masing</i></b> dilambangkan dengan <b><i>g <sub>x</sub></i></b> dan <b><i>g</i></b> <b><i>y</i></b> (dari kata guess).  Bit dari urutan yang dihasilkan ditebak ketika kedua nilai ditebak dengan benar, atau ketika keduanya salah, sehingga kemungkinan menebak adalah ini: <br>  g <sub>r</sub> = g <sub>x</sub> g <sub>y</sub> + (1 - g <sub>x</sub> ) (1 - g <sub>y</sub> ) = 2 g <sub>x</sub> g <sub>y</sub> - g <sub>x</sub> - g <sub>y</sub> + 1 <br><br>  Ketika kita memiliki penebak yang sempurna, kita memiliki <b><i>g</i></b> = 1.  Jika kita tidak tahu apa-apa, <b><i>g</i></b> adalah ... tidak, bukan nol, tapi 1/2.  Ini persis probabilitas menebak ternyata jika kita membuat keputusan dengan melemparkan koin.  Kasus yang sangat menarik adalah ketika <b><i>g</i></b> &lt;1/2.  Di satu sisi, penebak seperti itu di suatu tempat di dalam dirinya memiliki data tentang nilai yang diprediksi, tetapi untuk beberapa alasan membalikkan hasilnya, dan dengan demikian <i>koin</i> menjadi <i>lebih buruk</i> .  Harap ingat frasa "lebih buruk daripada koin", ini akan berguna bagi kami di bawah ini.  Dari sudut pandang teori komunikasi matematis (dan, sebagai hasilnya, teori informasi kuantitatif yang akrab bagi kita), situasi ini tidak masuk akal, karena ini bukan teori informasi, tetapi teori disinformasi, tetapi dalam kehidupan kita memiliki situasi ini lebih sering daripada yang kita inginkan . <br><br>  Pertimbangkan kasus pembatas: <br><br><ul><li>  <b><i>g <sub>x</sub> = 1</i></b> , mis., urutan <b><i>x</i></b> sepenuhnya dapat diprediksi: <br>  g <sub>r</sub> = g <sub>x</sub> g <sub>y</sub> + (1 - g <sub>x</sub> ) (1 - g <sub>y</sub> ) = 1 g <sub>y</sub> + (1−1) (1 - g <sub>y</sub> ) = g <sub>y</sub> <br>  Artinya, probabilitas menebak hasilnya sama dengan probabilitas menebak urutan tambahan. </li><li>  <b><i>g <sub>y</sub> = 1</i></b> : Mirip dengan yang sebelumnya.  Probabilitas menebak hasilnya sama dengan probabilitas menebak urutan utama. </li><li>  <b><i>g <sub>x</sub> = 1/2</i></b> , mis. urutan <b><i>x</i></b> benar <b><i>-</i></b> benar tidak dapat diprediksi: <br>  g <sub>r</sub> = 2 g <sub>x</sub> g <sub>y</sub> - g <sub>x</sub> - g <sub>y</sub> + 1 = 2/2 g <sub>y</sub> - 1/2 - g <sub>y</sub> +1 = g <sub>y</sub> - g <sub>y</sub> + 1/2 = 1/2 <br>  Artinya, penambahan setiap urutan tambahan tidak merusak ketidakpastian sepenuhnya dari yang utama. </li><li>  <b><i>g <sub>y</sub> = 1/2</i></b> : Mirip dengan yang sebelumnya.  Menambahkan urutan ekstra yang sama sekali tidak dapat diprediksi membuat hasilnya sama sekali tidak dapat diprediksi. </li></ul><br>  Untuk membuktikan bahwa menambahkan urutan tambahan ke yang utama tidak akan membantu penyerang, kita perlu mencari tahu dalam kondisi apa <b><i>gr</i></b> mungkin lebih besar dari <b><i>g <sub>x</sub></i></b> , yaitu. <br><br>  2 g <sub>x</sub> g <sub>y</sub> - g <sub>x</sub> - g <sub>y</sub> + 1&gt; g <sub>x</sub> <br><br>  Pindahkan g <sub>x</sub> dari sisi kanan ke kiri, dan g <sub>y</sub> dan 1 ke kanan: <br><br>  2 g <sub>x</sub> g <sub>y</sub> - g <sub>x</sub> - g <sub>x</sub> &gt; g <sub>y</sub> - 1 <br>  2 g <sub>x</sub> g <sub>y</sub> - 2 g <sub>x</sub> &gt; g <sub>y</sub> - 1 <br>  Kami mengambil di sisi kiri 2g <sub>x</sub> dari tanda kurung: <br>  2 g <sub>x</sub> (g <sub>y</sub> - 1)&gt; g <sub>y</sub> - 1 <br>  Karena kita memiliki g <sub>y</sub> kurang dari satu (kasus pembatas ketika g <sub>y</sub> = 1, kita telah mempertimbangkan), kita mengubah g <sub>y</sub> −1 menjadi 1 - g <sub>y</sub> , tanpa lupa mengubah "lebih" menjadi "kurang": <br>  2 g <sub>x</sub> (1 - g <sub>y</sub> ) &lt;1 - g <sub>y</sub> <br><br>  Kurangi “1 - g <sub>y</sub> ” dan dapatkan kondisi di mana menambahkan urutan tambahan akan meningkatkan situasi bagi penyerang untuk menebak: <br><br>  2 g <sub>x</sub> &lt;1 <br>  g <sub>x</sub> &lt;1/2 <br><br>  Yaitu, <b><i>g <sub>r</sub></i></b> bisa lebih besar dari <b><i>g <sub>x</sub></i></b> hanya ketika menebak urutan utama <i>lebih buruk daripada koin</i> .  Kemudian, ketika prediktor kita terlibat dalam sabotase sadar. <br><br>  <b>Beberapa pertimbangan tambahan tentang entropi.</b> <br><br><ol><li>  Entropi adalah konsep yang sangat mitologis.  Informasi - termasuk.  Ini sangat mengganggu.  Seringkali, entropi informasi direpresentasikan sebagai semacam masalah halus yang hadir secara objektif dalam data atau tidak.  Bahkan, entropi informasi bukanlah sesuatu yang hadir dalam sinyal itu sendiri, tetapi penilaian kuantitatif dari kesadaran a priori penerima pesan mengenai pesan itu sendiri.  Artinya, ini bukan hanya tentang sinyal, tetapi juga tentang penerima.  Jika penerima sama sekali tidak tahu tentang sinyal di muka, entropi informasi dari unit biner yang ditransmisikan adalah persis 1 bit, terlepas dari bagaimana sinyal itu diterima dan apa itu. </li><li>  Kami memiliki teorema penambahan entropi yang menyatakan bahwa total entropi sumber independen sama dengan jumlah entropi dari sumber-sumber ini.  Jika kita menggabungkan urutan utama dengan yang tambahan melalui penggabungan, kita akan mempertahankan entropi dari sumber, tetapi akan mendapatkan hasil yang buruk, karena dalam tugas kita kita perlu mengevaluasi bukan total entropi, tetapi yang spesifik, dalam hal bit yang terpisah.  Gabungan sumber memberi kita entropi spesifik dari hasil yang sama dengan rata-rata aritmatika dari entropi sumber, dan urutan tambahan yang lemah entropi secara alami memperburuk hasilnya.  Penerapan operasi XOR mengarah pada fakta bahwa kami kehilangan beberapa entropi, tetapi kami dijamin memiliki entropi yang dihasilkan tidak lebih buruk daripada entropi maksimum dari persyaratan. </li><li>  Cryptographers memiliki dogma: menggunakan pseudo-random number generator adalah arogansi yang tidak termaafkan.  Karena generator ini memiliki entropi spesifik kecil.  Tetapi kami baru mengetahui bahwa jika semuanya dilakukan dengan benar, entropi menjadi satu tong madu yang tidak dapat dimanjakan oleh jumlah tar. </li><li>  Jika kita hanya memiliki 10 byte entropi nyata, tersebar di satu kilobyte data, dari sudut pandang formal, kita hanya memiliki 1% dari entropi spesifik, yang sangat buruk.  Tetapi jika 10 byte ini dioleskan secara kualitatif, dan terlepas dari brute force, tidak ada cara untuk menghitung 10 byte ini, semuanya tidak terlihat begitu buruk.  10 byte adalah 2 <sup>80</sup> , dan jika brute force kita per detik mencari melalui satu triliun opsi, kita akan memerlukan rata-rata 19 ribu tahun untuk belajar bagaimana menebak karakter berikutnya. </li></ol><br>  Seperti disebutkan di atas, entropi informasi adalah nilai relatif.  Di mana, untuk satu subjek, entropi spesifik adalah 1, untuk yang lain itu mungkin 0. Selain itu, satu dengan 1 mungkin tidak memiliki cara untuk mengetahui keadaan sebenarnya.  Sistem RNG menghasilkan aliran yang tidak dapat dibedakan bagi kita dari yang benar-benar acak, tetapi kita hanya bisa berharap itu benar-benar acak <i>untuk semua orang</i> .  Dan percayalah.  Jika paranoia menunjukkan bahwa kualitas RNG utama mungkin tiba-tiba tidak memuaskan, masuk akal untuk melakukan lindung nilai dengan bantuan yang lain. <br><br><h3>  Menerapkan RNG penjumlahan dengan Python </h3><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Random, SystemRandom <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> BPF <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> _BPF, RECIP_BPF <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> _RECIP_BPF <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> functools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> reduce <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> _reduce <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> operator <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> xor <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> _xor <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompoundRandom</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(SystemRandom)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__new__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls, *sources)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Positional arguments must be descendants of Random"""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> all(isinstance(src, Random) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> src <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sources): <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> TypeError(<span class="hljs-string"><span class="hljs-string">"all the sources must be descendants of Random"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> super().__new__(cls) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *sources)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Positional arguments must be descendants of Random"""</span></span> self.sources = sources super().__init__() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getrandbits</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, k)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""getrandbits(k) -&gt; x. Generates an int with k random bits."""</span></span> <span class="hljs-comment"><span class="hljs-comment">########         : return _reduce(_xor, (src.getrandbits(k) for src in self.sources), 0) def random(self): """Get the next random number in the range [0.0, 1.0).""" ########  ,   SystemRandom   .  ... return self.getrandbits(_BPF) * _RECIP_BPF</span></span></code> </pre> <br>  Contoh penggunaan: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random_xe <span class="hljs-comment"><span class="hljs-comment"># &lt;&lt;&lt;    &gt;&gt;&gt; from random import Random, SystemRandom &gt;&gt;&gt; #  : &gt;&gt;&gt; myrandom1 = random_xe.CompoundRandom(SystemRandom(), Random()) &gt;&gt;&gt; #    Random: &gt;&gt;&gt; myrandom1.random() 0.4092251189581082 &gt;&gt;&gt; myrandom1.randint(100, 200) 186 &gt;&gt;&gt; myrandom1.gauss(20, 10) 19.106991205743107</span></span></code> </pre> <br>  SystemRandom, yang dianggap benar, diambil sebagai aliran utama, dan sebagai aliran sekunder - standar PRNG Acak.  Poinnya, tentu saja, tidak terlalu banyak.  PRNG standar jelas bukan jenis suplemen yang layak dimulainya.  Sebagai gantinya, Anda dapat menggabungkan dua RNG sistemik bersama-sama: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>myrandom2 = random_xe.CompoundRandom(SystemRandom(), SystemRandom())</code> </pre> <br>  Artinya, kebenaran dalam hal ini bahkan lebih sedikit (walaupun karena alasan tertentu Bruce Bruce merekomendasikan dalam Kriptografi Terapan untuk beberapa alasan), karena perhitungan di atas hanya berlaku untuk sumber independen.  Jika sistem RNG dikompromikan, hasilnya juga akan dikompromikan.  Pada prinsipnya, penerbangan yang mewah dalam mencari sumber entropi tambahan tidak dibatasi oleh apa pun (di dunia kita, gangguan jauh lebih umum daripada pesanan), tetapi sebagai solusi sederhana saya akan menawarkan HashRandom PRSP, juga diterapkan di perpustakaan random_xe. <br><br><h3>  PRSP didasarkan pada streaming hashing melingkar </h3><br>  Dalam kasus paling sederhana, Anda dapat mengambil sejumlah kecil data awal (misalnya, meminta pengguna untuk menghidupkan keyboard), menghitung hash mereka, dan kemudian menambahkan hash secara siklik ke input algoritma hash dan mengambil hash berikut.  Secara skematis, ini dapat direpresentasikan sebagai berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ka/fk/ei/kafkeiisv_tow0ib7kibsqwhbuy.png"></div><br><br>  Kekuatan kriptografi dari proses ini didasarkan pada dua asumsi: <br><br><ol><li>  Tugas mengembalikan data asli dari nilai hash sangat rumit. </li><li>  Menggunakan nilai hash, tidak mungkin mengembalikan keadaan internal algoritma hashing. </li></ol><br>  Setelah berkonsultasi dengan paranoid internal, ia mengakui asumsi kedua sebagai tidak perlu, dan oleh karena itu, dalam implementasi akhir dari PRNG, skema ini sedikit rumit: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rv/mp/hz/rvmphzdunz3q25vy61tm65okwv4.png"></div><br><br>  Sekarang, jika penyerang berhasil mendapatkan nilai "Hash 1r", ia tidak akan dapat menghitung nilai "Hash 2r" yang mengikutinya, karena ia tidak memiliki nilai "Hash 2h" yang tidak dapat dikenali tanpa menghitung fungsi hash "melawan wol".  Dengan demikian, kekuatan kriptografi dari skema ini sesuai dengan kekuatan kriptografi dari algoritma hashing yang digunakan. <br><br>  Contoh penggunaan: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-comment"><span class="hljs-comment">#  ,  HashRandom     '123': &gt;&gt;&gt; myrandom3 = random_xe.CompoundRandom(SystemRandom(), random_xe.HashRandom('123')) &gt;&gt;&gt; #    Random: &gt;&gt;&gt; myrandom3.random() 0.8257149881148604</span></span></code> </pre> <br>  Secara default, algoritma SHA-256 digunakan.  Jika Anda menginginkan sesuatu yang lain, Anda dapat mentransfer jenis algoritma hashing yang diinginkan ke konstruktor dengan parameter kedua.  Sebagai contoh, mari kita membuat RNG komposit, meringkas berikut ini di tumpukan: <br><br>  1. RNG sistemik (ini sakral). <br>  2. Input pengguna diproses oleh algoritma SHA3-512. <br>  3. Waktu yang dihabiskan untuk input ini diproses oleh SHA-256. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> getpass <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> getpass &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> perf_counter &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> hashlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sha3_512 <span class="hljs-comment"><span class="hljs-comment">#    : &gt;&gt;&gt; def super_myrandom(): t_start = perf_counter() return random_xe.CompoundRandom(SystemRandom(), random_xe.HashRandom( getpass('  :'), sha3_512), random_xe.HashRandom(perf_counter() - t_start)) &gt;&gt;&gt; myrandom4 = super_myrandom()   : &gt;&gt;&gt; myrandom4.random() 0.35381173716740766</span></span></code> </pre> <br>  <b>Kesimpulan:</b> <br><br><ol><li>  Jika kita tidak yakin dengan generator bilangan acak kita, kita bisa dengan mudah dan luar biasa murah menyelesaikan masalah ini. </li><li>  Memecahkan masalah ini, kita tidak bisa berbuat lebih buruk.  Hanya lebih baik.  Dan itu terbukti secara matematis. </li><li>  Kita tidak boleh lupa untuk mencoba memastikan bahwa sumber entropi yang digunakan independen. </li></ol><br>  Sumber perpustakaan ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id423093/">https://habr.com/ru/post/id423093/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id423083/index.html">Bagaimana saya menjadi pengembang di ABBYY</a></li>
<li><a href="../id423085/index.html">Penyeimbangan beban penyetelan halus</a></li>
<li><a href="../id423087/index.html">Jangan mendorong mata saya</a></li>
<li><a href="../id423089/index.html">Programmer di MBLT DEV 2018</a></li>
<li><a href="../id423091/index.html">Bergetar untuk pengembang Android. Cara membuat UI untuk Aktivitas menggunakan Flutter</a></li>
<li><a href="../id423095/index.html">Apa yang Baru di Presentasi Apple</a></li>
<li><a href="../id423097/index.html">Tugas dan solusi untuk pejuang PostgreSQL</a></li>
<li><a href="../id423101/index.html">Menyebarkan Penyimpanan LINSTOR untuk Proxmox</a></li>
<li><a href="../id423103/index.html">Python Podcasts: Hanya Itu yang Kami Temukan</a></li>
<li><a href="../id423105/index.html">System.IO.Pipelines: IO Kinerja Tinggi dalam .NET</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>