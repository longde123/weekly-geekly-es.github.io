<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëè ‚úåüèª üóØÔ∏è Alles was Sie brauchen ist URL üë®üèø‚Äçüéì üå´Ô∏è üë°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="VKontakte-Benutzer tauschen t√§glich 10 Milliarden Nachrichten aus. Sie senden sich gegenseitig Fotos, Comics, Memes und andere Anh√§nge. Wir werden Ihn...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Alles was Sie brauchen ist URL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/vk/blog/467605/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/g6/l2/us/g6l2usvzzisf7ezfubycuyoty08.jpeg" alt="Bild"></div><br>  VKontakte-Benutzer tauschen t√§glich 10 Milliarden Nachrichten aus.  Sie senden sich gegenseitig Fotos, Comics, Memes und andere Anh√§nge.  Wir werden Ihnen <b><code>URLProtocol</code></b> , wie wir eine iOS-Anwendung zum Hochladen von Bildern mit <b><code>URLProtocol</code></b> , und Schritt f√ºr Schritt werden wir herausfinden, wie wir unsere eigene implementieren k√∂nnen. <br><a name="habracut"></a><br>  Vor ungef√§hr anderthalb Jahren war die Entwicklung eines neuen Nachrichtenabschnitts in der VK-Anwendung f√ºr iOS in vollem Gange.  Dies ist der erste Abschnitt, der vollst√§ndig in Swift geschrieben wurde.  Es befindet sich in einem separaten Modul <code>vkm</code> (VK Messages), das nichts √ºber das Ger√§t der Hauptanwendung wei√ü.  Es kann sogar in einem separaten Projekt ausgef√ºhrt werden - die grundlegenden Funktionen zum Lesen und Senden von Nachrichten funktionieren weiterhin.  In der Hauptanwendung werden Nachrichtencontroller √ºber den entsprechenden Container View Controller hinzugef√ºgt, um beispielsweise eine Liste von Konversationen oder Nachrichten in einer Konversation anzuzeigen. <br><br>  Nachrichten sind einer der beliebtesten Bereiche der mobilen VKontakte-Anwendung. Daher ist es wichtig, dass sie wie eine Uhr funktionieren.  Im <code>messages</code> k√§mpfen wir um jede Codezeile.  Es hat uns immer sehr gut gefallen, wie ordentlich die Nachrichten in die Anwendung integriert sind, und wir bem√ºhen uns sicherzustellen, dass alles beim Alten bleibt. <br><br>  Nachdem wir den Abschnitt schrittweise mit neuen Funktionen gef√ºllt hatten, n√§herten wir uns der folgenden Aufgabe: Es war erforderlich, das Foto, das an die Nachricht angeh√§ngt ist, zuerst in einem Entwurf anzuzeigen und nach dem Senden in der allgemeinen Liste der Nachrichten zu erstellen.  Wir k√∂nnten einfach ein Modul hinzuf√ºgen, um mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>PHImageManager</code></a> zu arbeiten, aber zus√§tzliche Bedingungen erschwerten die Aufgabe. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0l/7t/hm/0l7thmey5vyyonmpbt5wicd-vjm.gif" alt="Bild"></div><br><br>  Bei der Auswahl eines Snapshots kann der Benutzer diesen verarbeiten: Filter anwenden, drehen, zuschneiden usw. In der VK-Anwendung wird diese Funktionalit√§t in einer separaten <code>AssetService</code> Komponente <code>AssetService</code> .  Jetzt musste man aus dem Nachrichtenprojekt lernen, mit ihm zu arbeiten. <br><br><blockquote>  Nun, die Aufgabe ist ganz einfach, wir werden es tun.  Dies ist ungef√§hr die durchschnittliche L√∂sung, da es viele Variationen gibt.  Wir nehmen das Protokoll, legen es in Nachrichten ab und f√ºllen es mit Methoden.  Wir erweitern den AssetService, passen das Protokoll an und f√ºgen unsere Cache-Implementierung hinzu!  f√ºr die Viskosit√§t.  Dann f√ºgen wir die Implementierung in Nachrichten ein, f√ºgen sie einem Dienst oder Manager hinzu, der mit all dem funktioniert, und beginnen, sie zu verwenden.  Gleichzeitig kommt immer noch ein neuer Entwickler und verurteilt, w√§hrend er versucht, alles herauszufinden, fl√ºsternd ... (na ja, verstehen Sie).  Gleichzeitig tritt Schwei√ü auf seiner Stirn auf. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7i/ze/q8/7izeq8h2gkpsgj2qybfro74kobc.jpeg" alt="Bild"></div><br></blockquote><br>  Diese Entscheidung <i>gefiel uns nicht</i> .  Es werden neue Entit√§ten <code>AssetService</code> , √ºber die Nachrichtenkomponenten bei der Arbeit mit Bildern aus <code>AssetService</code> Bescheid wissen <code>AssetService</code> .  Der Entwickler muss au√üerdem zus√§tzliche Arbeit leisten, um herauszufinden, wie dieses System funktioniert.  Schlie√ülich gab es eine zus√§tzliche implizite Verkn√ºpfung zu den Komponenten des Hauptprojekts, die wir zu vermeiden versuchen, damit der Nachrichtenabschnitt weiterhin als unabh√§ngiges Modul funktioniert. <br><br>  Ich wollte das Problem l√∂sen, damit das Projekt √ºberhaupt nichts dar√ºber wusste, welche Art von Bild ausgew√§hlt wurde, wie es gespeichert werden sollte, ob es speziell geladen und gerendert werden musste.  Dar√ºber hinaus haben wir bereits die M√∂glichkeit, herk√∂mmliche Bilder aus dem Internet herunterzuladen, nur werden sie nicht √ºber einen zus√§tzlichen Dienst heruntergeladen, sondern einfach per <code>URL</code> .  Tats√§chlich gibt es keinen Unterschied zwischen den beiden Bildtypen.  Nur einige werden lokal gespeichert, w√§hrend andere auf dem Server gespeichert werden. <br><br>  Wir hatten also eine sehr einfache Idee: Was ist, wenn das Laden lokaler Assets auch √ºber eine <code>URL</code> erlernt werden <code>URL</code> ?  Es scheint, als w√ºrde dies mit einem Klick auf <s>Thanos '</s> Finger alle unsere Probleme l√∂sen: Sie m√ºssen nichts √ºber <code>AssetService</code> wissen, neue Datentypen hinzuf√ºgen und die Entropie vergeblich erh√∂hen, lernen, einen neuen Bildtyp zu laden, sich um das Zwischenspeichern von Daten k√ºmmern.  Klingt nach einem Plan. <br><br><h2>  Wir brauchen nur eine URL </h2><br>  Wir haben diese Idee ber√ºcksichtigt und beschlossen, das <code>URL</code> Format zu definieren, das zum Laden lokaler Assets verwendet wird: <br><br><pre> <code class="json hljs">asset://?id=<span class="hljs-number"><span class="hljs-number">123</span></span>&amp;width=<span class="hljs-number"><span class="hljs-number">1920</span></span>&amp;height=<span class="hljs-number"><span class="hljs-number">1280</span></span></code> </pre> <br>  Wir werden den Wert der Eigenschaft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>localIdentifier</code></a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>localIdentifier</code></a> als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>PHObject</code></a> und die Parameter <code>width</code> und <code>height</code> , um die Bilder der gew√ºnschten Gr√∂√üe zu laden.  Wir f√ºgen auch einige weitere Parameter wie <code>crop</code> , <code>filter</code> und <code>rotate</code> , mit denen Sie mit den Informationen des verarbeiteten Bildes arbeiten k√∂nnen. <br><br>  Um diese <code>URL</code> erstellen wir ein <code>AssetURLProtocol</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AssetURLProtocol</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLProtocol</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br>  Seine Aufgabe besteht darin, das Image √ºber <code>AssetService</code> zu laden und die bereits gebrauchsfertigen Daten zur√ºckzugeben. <br><br>  All dies erm√∂glicht es uns, die Arbeit des <code>URL</code> Protokolls und des <code>URL Loading System</code> fast vollst√§ndig zu delegieren. <br><br>  Innerhalb der Nachrichten kann mit den g√§ngigsten <code>URL</code> nur in einem anderen Format gearbeitet werden.  Es wird auch m√∂glich sein, den vorhandenen Mechanismus zum Laden von Bildern wiederzuverwenden. Es ist sehr einfach, in der Datenbank zu serialisieren und das Zwischenspeichern von Daten √ºber Standard- <code>URLCache</code> . <br><br>  Hat es geklappt?  Wenn Sie beim Lesen dieses Artikels ein Foto aus der Galerie an die Nachricht in der VKontakte-Anwendung anh√§ngen k√∂nnen, dann ja :) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bm/6j/tb/bm6jtb7mkd489czjvwhzpy-dpo0.jpeg" alt="Bild"></div><br>  Um zu verdeutlichen, wie Sie Ihr <code>URLProtocol</code> implementieren, schlage ich vor, dies <code>URLProtocol</code> eines Beispiels zu betrachten. <br><br>  Wir haben uns die Aufgabe gestellt: eine einfache Anwendung mit einer Liste zu implementieren, in der Sie eine Liste von Kartenschnappsch√ºssen an den angegebenen Koordinaten anzeigen m√ºssen.  Zum Herunterladen von Snapshots verwenden wir den Standard- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>MKMapSnapshotter</code></a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>MapKit</code></a> und laden Daten √ºber das benutzerdefinierte <code>URLProtocol</code> .  Das Ergebnis k√∂nnte ungef√§hr so ‚Äã‚Äãaussehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l1/bg/s8/l1bgs8g0xzehoxt49oddmmtbuoe.gif" alt="Bild"></div><br>  Zun√§chst implementieren wir den Mechanismus zum Laden von Daten per <code>URL</code> .  Um den Kartenschnappschuss anzuzeigen, m√ºssen wir die Koordinaten des Punktes kennen - seine Breite und L√§nge ( <code>latitude</code> , <code>longitude</code> ).  Definieren Sie das benutzerdefinierte <code>URL</code> Format, mit dem Informationen geladen werden sollen: <br><br><pre> <code class="json hljs">map://?latitude=<span class="hljs-number"><span class="hljs-number">59.935634</span></span>&amp;longitude=<span class="hljs-number"><span class="hljs-number">30.325935</span></span></code> </pre> <br>  Jetzt implementieren wir <code>URLProtocol</code> , das solche Links verarbeitet und das gew√ºnschte Ergebnis generiert.  Erstellen wir die <code>MapURLProtocol</code> Klasse, die wir von der Basisklasse <code>URLProtocol</code> erben.  Trotz seines Namens ist <code>URLProtocol</code> eine abstrakte Klasse.  <code>URLProtocol</code> Sie nicht verlegen, hier verwenden wir andere Konzepte - <code>URLProtocol</code> repr√§sentiert genau das <code>URL</code> Protokoll und hat keine Beziehung zu OOP-Begriffen.  Also <code>MapURLProtocol</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MapURLProtocol</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLProtocol</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br>  Jetzt definieren wir einige erforderliche Methoden neu, ohne die das <code>URL</code> Protokoll nicht funktioniert: <br><br><h3>  1. <code>canInit(with:)</code> </h3><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">func</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">canInit</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLRequest</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bool</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.url?.scheme == <span class="hljs-string"><span class="hljs-string">"map"</span></span> }</code> </pre> <br>  Die Methode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>canInit(with:)</code></a> wird ben√∂tigt, um anzugeben, welche Arten von Anforderungen unser <code>URL</code> Protokoll verarbeiten kann.  Angenommen, das Protokoll verarbeitet in diesem Beispiel nur Anforderungen mit einem <code>map</code> in der <code>URL</code> .  Vor dem Starten einer Anforderung durchl√§uft die <code>URL Loading System</code> alle f√ºr die Sitzung registrierten Protokolle und ruft diese Methode auf.  Das erste registrierte Protokoll, das bei dieser Methode <code>true</code> zur√ºckgibt, wird zur Verarbeitung der Anforderung verwendet. <br><br><h4>  <code>canonicalRequest(for:)</code> </h4><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">func</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">canonicalRequest</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">for</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLRequest</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLRequest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request }</code> </pre> <br>  Die Methode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>canonicalRequest(for:)</code></a> soll die Anforderung auf kanonische Form reduzieren.  Die Dokumentation besagt, dass die Implementierung des Protokolls selbst entscheidet, was als Definition dieses Konzepts zu betrachten ist.  Hier k√∂nnen Sie das Schema normalisieren, der Anforderung bei Bedarf Header hinzuf√ºgen usw. Die einzige Voraussetzung f√ºr die Funktion dieser Methode ist, dass f√ºr jede eingehende Anforderung immer das gleiche Ergebnis erzielt wird, auch weil diese Methode auch zur Suche nach zwischengespeicherten Antworten verwendet wird Anfragen in <code>URLCache</code> . <br><br><h4>  3. <code>startLoading()</code> </h4><br>  Die Methode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>startLoading()</code></a> beschreibt die gesamte Logik zum Laden der erforderlichen Daten.  In diesem Beispiel m√ºssen Sie die Anforderungs- <code>URL</code> analysieren und basierend auf den Werten der <code>latitude</code> und <code>latitude</code> zu <code>MKMapSnapshotter</code> und den gew√ºnschten Kartenschnappschuss laden. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = request.url, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> components = <span class="hljs-type"><span class="hljs-type">URLComponents</span></span>(url: url, resolvingAgainstBaseURL: <span class="hljs-literal"><span class="hljs-literal">false</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> queryItems = components.queryItems <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fail(with: .badURL) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } load(with: queryItems) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with queryItems: [URLQueryItem])</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> snapshotter = <span class="hljs-type"><span class="hljs-type">MKMapSnapshotter</span></span>(queryItems: queryItems) snapshotter.start( with: <span class="hljs-type"><span class="hljs-type">DispatchQueue</span></span>.global(qos: .background), completionHandler: handle ) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(snapshot: MKMapSnapshotter.Snapshot?, error: Error?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> snapshot = snapshot, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = snapshot.image.jpegData(compressionQuality: <span class="hljs-number"><span class="hljs-number">1</span></span>) { complete(with: data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error = error { fail(with: error) } }</code> </pre> <br>  Nach dem Empfang der Daten muss das Protokoll korrekt heruntergefahren werden: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">complete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with data: Data)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = request.url, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> client = client <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> response = <span class="hljs-type"><span class="hljs-type">URLResponse</span></span>( url: url, mimeType: <span class="hljs-string"><span class="hljs-string">"image/jpeg"</span></span>, expectedContentLength: data.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>, textEncodingName: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> ) client.urlProtocol(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didReceive: response, cacheStoragePolicy: .allowed) client.urlProtocol(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didLoad: data) client.urlProtocolDidFinishLoading(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) }</code> </pre> <br>  Erstellen Sie zun√§chst ein Objekt vom Typ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>URLResponse</code></a> .  Dieses Objekt enth√§lt wichtige Metadaten f√ºr die Beantwortung einer Anfrage.  Dann f√ºhren wir drei wichtige Methoden f√ºr ein Objekt vom Typ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>URLProtocolClient</code></a> .  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>client</code></a> Eigenschaft dieses Typs enth√§lt jede Entit√§t des <code>URL</code> Protokolls.  Es fungiert als Proxy zwischen dem <code>URL</code> Protokoll und der gesamten <code>URL Loading System</code> , das beim <code>URL Loading System</code> dieser Methoden R√ºckschl√ºsse darauf zieht, was mit den Daten zu tun ist: Cache, Anforderungen an <code>completionHandler</code> , Protokollabschaltung irgendwie verarbeiten usw. und die Anzahl der Aufrufe dieser Methoden kann abh√§ngig von der Protokollimplementierung variieren.  Beispielsweise k√∂nnen wir Daten <code>URLProtocolClient</code> aus dem Netzwerk herunterladen und <code>URLProtocolClient</code> regelm√§√üig dar√ºber informieren, um den Fortschritt des <code>URLProtocolClient</code> in der Schnittstelle <code>URLProtocolClient</code> . <br><br>  Wenn beim Betrieb des Protokolls ein Fehler auftritt, muss <code>URLProtocolClient</code> auch korrekt verarbeitet und benachrichtigt werden: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with error: Error)</span></span></span></span> { client?.urlProtocol(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didFailWithError: error) }</code> </pre> <br>  Dieser Fehler wird dann an den <code>completionHandler</code> der Anfrage gesendet, wo er verarbeitet und dem Benutzer eine sch√∂ne Nachricht angezeigt werden kann. <br><br><h4>  4. <code>stopLoading()</code> </h4><br>  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>stopLoading()</code></a> -Methode wird aufgerufen, wenn die Protokolloperation aus irgendeinem Grund abgeschlossen wurde.  Dies kann entweder ein erfolgreicher Abschluss oder ein Fehlerabschluss oder eine Stornierung der Anforderung sein.  Dies ist ein guter Ort, um belegte Ressourcen freizugeben oder tempor√§re Daten zu l√∂schen. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stopLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { }</code> </pre> <br>  Damit ist die Implementierung des <code>URL</code> Protokolls abgeschlossen, das √ºberall in der Anwendung verwendet werden kann.  F√ºgen Sie noch ein paar Dinge hinzu, um unser Protokoll anzuwenden. <br><br><h4> <code>URLImageView</code> </h4> <br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLImageView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIImageView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> task: <span class="hljs-type"><span class="hljs-type">URLSessionDataTask?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> taskId: <span class="hljs-type"><span class="hljs-type">Int?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url: URL)</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(task == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> || task?.taskIdentifier != taskId) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>(url: url) task = session.dataTask(with: request, completionHandler: complete) taskId = task?.taskIdentifier task?.resume() } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">complete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data: Data?, response: URLResponse?, error: Error?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.taskId == task?.taskIdentifier, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = data, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> image = <span class="hljs-type"><span class="hljs-type">UIImage</span></span>(data: data) { didLoadRemote(image: image) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didLoadRemote</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image: UIImage)</span></span></span></span> { <span class="hljs-type"><span class="hljs-type">DispatchQueue</span></span>.main.async { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.image = image } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareForReuse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { task?.cancel() taskId = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> image = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br>  Dies ist eine einfache Klasse, der Nachkomme von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>UIImageView</code></a> , eine √§hnliche Implementierung, die Sie wahrscheinlich in jeder Anwendung haben.  Hier laden wir das Bild einfach √ºber die <code>URL</code> in die Methode <code>render(url:)</code> und schreiben es in die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>image</code></a> .  Der Vorteil ist, dass Sie absolut jedes Bild hochladen k√∂nnen, entweder √ºber die <code>http</code> / <code>https</code> <code>URL</code> oder √ºber unsere benutzerdefinierte <code>URL</code> . <br><br>  Um Anforderungen zum Laden von Bildern auszuf√ºhren, ben√∂tigen Sie au√üerdem ein Objekt vom Typ <code>URLSession</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> config: <span class="hljs-type"><span class="hljs-type">URLSessionConfiguration</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = <span class="hljs-type"><span class="hljs-type">URLSessionConfiguration</span></span>.ephemeral <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.protocolClasses = [ <span class="hljs-type"><span class="hljs-type">MapURLProtocol</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> }() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> session = <span class="hljs-type"><span class="hljs-type">URLSession</span></span>( configuration: config, delegate: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, delegateQueue: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> )</code> </pre> <br>  Die Sitzungskonfiguration ist hier besonders wichtig.  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>URLSessionConfiguration</code></a> gibt es eine wichtige Eigenschaft f√ºr uns - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>protocolClasses</code></a> .  Dies ist eine Liste der Arten von <code>URL</code> Protokollen, die eine Sitzung mit dieser Konfiguration verarbeiten kann.  Standardm√§√üig unterst√ºtzt die Sitzung die Verarbeitung von <code>http</code> / <code>https</code> Protokollen. Wenn benutzerdefinierte Unterst√ºtzung erforderlich ist, m√ºssen diese angegeben werden.  <code>MapURLProtocol</code> Sie in unserem Beispiel <code>MapURLProtocol</code> . <br><br>  Sie m√ºssen lediglich den View Controller implementieren, der Kartenschnappsch√ºsse anzeigt.  Den Quellcode finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Hier ist das Ergebnis: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ed/gf/c8/edgfc8crekglljfq33hfggic520.gif" alt="Bild"></div><br><h2>  Was ist mit Caching? </h2><br>  Alles scheint gut zu funktionieren - bis auf einen wichtigen Punkt: Wenn wir die Liste hin und her scrollen, erscheinen wei√üe Flecken auf dem Bildschirm.  Es scheint, dass Snapshots in keiner Weise zwischengespeichert werden und f√ºr jeden Aufruf der <code>render(url:)</code> -Methode <code>MKMapSnapshotter</code> wir <code>MKMapSnapshotter</code> Daten √ºber <code>MKMapSnapshotter</code> .  Dies braucht Zeit und daher solche Ladel√ºcken.  Es lohnt sich, einen Daten-Caching-Mechanismus zu implementieren, damit bereits erstellte Snapshots nicht erneut heruntergeladen werden.  Hier nutzen wir die Leistung des <code>URL Loading System</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>URLCache</code></a> , f√ºr das bereits ein Caching-Mechanismus f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>URLCache</code></a> vorgesehen ist. <br><br>  Betrachten Sie diesen Prozess genauer und teilen Sie die Arbeit mit dem Cache in zwei wichtige Phasen ein: Lesen und Schreiben. <br><br><h3>  Lesen </h3><br>  Um zwischengespeicherte Daten korrekt zu lesen, ben√∂tigt die <code>URL Loading System</code> Hilfe, um Antworten auf mehrere wichtige Fragen zu erhalten: <br><br>  <b>1. Welcher URLCache soll verwendet werden?</b> <br><br>  Nat√ºrlich ist <code>URLCache.shared</code> bereits fertig, aber die <code>URL Loading System</code> <code>URLCache.shared</code> kann es nicht immer verwenden. Schlie√ülich m√∂chte der Entwickler m√∂glicherweise seine eigene <code>URLCache</code> Entit√§t erstellen und verwenden.  Um diese Frage zu beantworten, verf√ºgt die <code>URLSessionConfiguration</code> Sitzungskonfiguration √ºber eine <code>urlCache</code> Eigenschaft.  Es wird sowohl zum Lesen als auch zum Aufzeichnen von Antworten auf Anforderungen verwendet.  Wir werden einige <code>URLCache</code> f√ºr diese Zwecke in unserer vorhandenen Konfiguration <code>URLCache</code> . <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> config: <span class="hljs-type"><span class="hljs-type">URLSessionConfiguration</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = <span class="hljs-type"><span class="hljs-type">URLSessionConfiguration</span></span>.ephemeral <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.urlCache = <span class="hljs-type"><span class="hljs-type">ImageURLCache</span></span>.current <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.protocolClasses = [ <span class="hljs-type"><span class="hljs-type">MapURLProtocol</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> }()</code> </pre> <br>  <b>2. Muss ich zwischengespeicherte Daten verwenden oder erneut herunterladen?</b> <br><br>  Die Antwort auf diese Frage h√§ngt von der <code>URLRequest</code> Anforderung ab, die wir ausf√ºhren werden.  Beim Erstellen einer Anforderung haben wir die M√∂glichkeit, zus√§tzlich zur <code>URL</code> eine Cache-Richtlinie im Argument <code>cachePolicy</code> anzugeben. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>( url: url, cachePolicy: .returnCacheDataElseLoad, timeoutInterval: <span class="hljs-number"><span class="hljs-number">30</span></span> )</code> </pre> <br>  Der Standardwert ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>.useProtocolCachePolicy</code></a> , der ebenfalls in der Dokumentation beschrieben wird.  Dies bedeutet, dass in dieser Version die Aufgabe, eine zwischengespeicherte Antwort auf eine Anforderung zu finden und ihre Relevanz zu bestimmen, vollst√§ndig in der Implementierung des <code>URL</code> Protokolls liegt.  Aber es gibt einen einfacheren Weg.  Wenn Sie den Wert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>.returnCacheDataElseLoad</code></a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>.returnCacheDataElseLoad</code></a> das <code>URLProtocol</code> <code>URL Loading System</code> beim Erstellen der n√§chsten Entit√§t <code>URLProtocol</code> Teil der Arbeit: Es fragt <code>urlCache</code> zwischengespeicherten Antwort auf die aktuelle Anforderung mithilfe der Methode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>cachedResponse(for:)</code></a> .  Wenn zwischengespeicherte Daten vorhanden sind, wird ein Objekt vom Typ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>CachedURLResponse</code></a> sofort √ºbertragen, wenn das <code>URLProtocol</code> initialisiert und in der Eigenschaft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>cachedResponse</code></a> gespeichert wird: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>( request: <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>, cachedResponse: <span class="hljs-type"><span class="hljs-type">CachedURLResponse?</span></span>, client: <span class="hljs-type"><span class="hljs-type">URLProtocolClient?</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>( request: request, cachedResponse: cachedResponse, client: client ) }</code> </pre> <br>  <code>CachedURLResponse</code> ist eine einfache Klasse, die Daten ( <code>Data</code> ) und Metainformationen f√ºr sie ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>URLResponse</code></a> ) enth√§lt. <br><br>  Wir k√∂nnen die <code>startLoading</code> Methode nur ein <code>startLoading</code> √§ndern und den Wert dieser Eigenschaft darin √ºberpr√ºfen - und das Protokoll sofort mit diesen Daten beenden: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cachedResponse = cachedResponse { complete(with: cachedResponse.data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = request.url, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> components = <span class="hljs-type"><span class="hljs-type">URLComponents</span></span>(url: url, resolvingAgainstBaseURL: <span class="hljs-literal"><span class="hljs-literal">false</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> queryItems = components.queryItems <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fail(with: .badURL) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } load(with: queryItems) } }</code> </pre> <br><h3>  Aufzeichnen </h3><br>  Um Daten im Cache zu finden, m√ºssen Sie sie dort ablegen.  Das <code>URL Loading System</code> k√ºmmert sich ebenfalls um diese Arbeit.  Alles, was von uns verlangt wird, ist ihr mitzuteilen, dass wir die Daten zwischenspeichern m√∂chten, wenn das Protokoll mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>cacheStoragePolicy</code></a> Cache-Richtlinieneinstellung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>cacheStoragePolicy</code></a> .  Dies ist eine einfache Aufz√§hlung mit den folgenden Werten: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StoragePolicy</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> allowed <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> allowedInMemoryOnly <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> notAllowed }</code> </pre> <br>  Sie bedeuten, dass das Zwischenspeichern im Speicher und auf der Festplatte nur im Speicher zul√§ssig oder verboten ist.  In unserem Beispiel geben wir an, dass das Zwischenspeichern im Speicher und auf der Festplatte zul√§ssig ist. Warum nicht? <br><br><pre> <code class="swift hljs">client.urlProtocol(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didReceive: response, cacheStoragePolicy: .allowed)</code> </pre> <br>  Mit ein paar einfachen Schritten haben wir die M√∂glichkeit unterst√ºtzt, Karten-Snapshots zwischenzuspeichern.  Und jetzt funktioniert die Anwendung so: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l1/bg/s8/l1bgs8g0xzehoxt49oddmmtbuoe.gif" alt="Bild"></div><br>  Wie Sie sehen, gibt es keine wei√üen Flecken mehr - die Karten werden einmal geladen und dann einfach aus dem Cache wiederverwendet. <br><br><h2>  Nicht immer einfach </h2><br>  Bei der Implementierung des <code>URL</code> Protokolls sind eine Reihe von Abst√ºrzen aufgetreten. <br><br>  Die erste <code>URLCache</code> die interne Implementierung der Interaktion des <code>URL Loading System</code> <code>URLCache</code> mit <code>URLCache</code> beim Zwischenspeichern von Antworten auf Anforderungen.  In der Dokumentation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hei√üt es</a> : Trotz der <code>URLCache</code> von <code>URLCache</code> kann der Betrieb der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>cachedResponse(for:)</code></a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>storeCachedResponse(_:for:)</code></a> zum Lesen / Schreiben von Antworten auf Anforderungen zu einer <code>URLCache</code> von Zust√§nden f√ºhren. Daher sollte dieser Punkt in Unterklassen von <code>URLCache</code> ber√ºcksichtigt werden.  Wir haben erwartet, dass mit <code>URLCache.shared</code> dieses Problem gel√∂st wird, aber es hat sich als falsch herausgestellt.  Um dies zu beheben, verwenden wir einen separaten <code>ImageURLCache</code> Cache, einen Nachkommen von <code>URLCache</code> , in dem wir die angegebenen Methoden synchron in einer separaten Warteschlange ausf√ºhren.  Als angenehmen Bonus k√∂nnen wir die Cache-Kapazit√§t im Speicher und auf der Festplatte separat von anderen <code>URLCache</code> Entit√§ten <code>URLCache</code> . <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> accessQueue = <span class="hljs-type"><span class="hljs-type">DispatchQueue</span></span>( label: <span class="hljs-string"><span class="hljs-string">"image-urlcache-access"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cachedResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request: URLRequest)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CachedURLResponse?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">ImageURLCache</span></span>.accessQueue.sync { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.cachedResponse(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: request) } } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">storeCachedResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> response: CachedURLResponse, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request: URLRequest)</span></span></span></span> { <span class="hljs-type"><span class="hljs-type">ImageURLCache</span></span>.accessQueue.sync { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.storeCachedResponse(response, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: request) } }</code> </pre> <br>  Ein weiteres Problem wurde nur auf Ger√§ten mit iOS 9 reproduziert. Die Methoden zum Starten und Beenden des Ladens des <code>URL</code> Protokolls k√∂nnen f√ºr verschiedene Threads ausgef√ºhrt werden, was zu seltenen, aber unangenehmen Abst√ºrzen f√ºhren kann.  Um das Problem zu l√∂sen, speichern wir den aktuellen Thread in der <code>startLoading</code> Methode und f√ºhren dann den Download-Abschlusscode direkt in diesem Thread aus. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread: <span class="hljs-type"><span class="hljs-type">Thread!</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = request.url, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> components = <span class="hljs-type"><span class="hljs-type">URLComponents</span></span>(url: url, resolvingAgainstBaseURL: <span class="hljs-literal"><span class="hljs-literal">false</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> queryItems = components.queryItems <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fail(with: .badURL) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } thread = <span class="hljs-type"><span class="hljs-type">Thread</span></span>.current <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cachedResponse = cachedResponse { complete(with: cachedResponse) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { load(request: request, url: url, queryItems: queryItems) } }</code> </pre> <br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(snapshot: MKMapSnapshotter.Snapshot?, error: Error?)</span></span></span></span> { thread.execute { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> snapshot = snapshot, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = snapshot.image.jpegData(compressionQuality: <span class="hljs-number"><span class="hljs-number">0.7</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.complete(with: data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error = error { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.fail(with: error) } } }</code> </pre> <br><h2>  Wann kann ein URL-Protokoll n√ºtzlich sein? </h2><br>  Infolgedessen st√∂√üt fast jeder Benutzer unserer iOS-Anwendung auf die eine oder andere Weise auf Elemente, die √ºber das <code>URL</code> Protokoll funktionieren.  Neben dem Herunterladen von Medien aus der Galerie helfen uns verschiedene Implementierungen von <code>URL</code> Protokollen beim Anzeigen von Karten und Umfragen sowie beim Anzeigen von Chat-Avataren, die aus Fotos ihrer Teilnehmer bestehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5v/jz/sl/5vjzsliedpi6l9qt6qhnaloi1l8.jpeg" alt="Bild"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p0/g4/rz/p0g4rzbdjqqbx3oc-ochol6ilwy.jpeg" alt="Bild"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n4/1e/mb/n41embtawargx2zofdmevlyq_nk.jpeg" alt="Bild"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j4/dn/gj/j4dngjkluh5gyxb3od9vwkse9zu.jpeg" alt="Bild"></div><br>  Wie jede L√∂sung hat <code>URLProtocol</code> seine Vor- und Nachteile. <br><br><h3>  Nachteile von <code>URLProtocol</code> </h3><br><ul><li>  <b>Fehlende strikte Eingabe</b> - Beim Erstellen einer <code>URL</code> Schema- und Linkparameter manuell √ºber Zeichenfolgen angegeben.  Wenn Sie einen Tippfehler machen, wird der gew√ºnschte Parameter nicht verarbeitet.  Dies kann das Debuggen der Anwendung und die Suche nach Fehlern in ihrem Betrieb erschweren.  In der VKontakte-Anwendung verwenden wir spezielle <code>URLBuilder</code> , die die endg√ºltige <code>URL</code> basierend auf den √ºbergebenen Parametern bilden.  Diese Entscheidung ist nicht sehr sch√∂n und widerspricht etwas dem Ziel, keine zus√§tzlichen Einheiten zu produzieren, aber es gibt noch keine bessere Idee.  Wir wissen jedoch, dass es einen speziellen <code>URLBuilder</code> , der Ihnen hilft, keinen Fehler zu machen, wenn Sie eine benutzerdefinierte <code>URL</code> erstellen m√ºssen. </li><li>  <b>Nicht offensichtliche Abst√ºrze</b> - Ich habe bereits einige Szenarien beschrieben, die dazu f√ºhren k√∂nnen, dass eine Anwendung mit <code>URLProtocol</code> abst√ºrzt.  Vielleicht gibt es noch andere.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Solche Probleme werden jedoch wie √ºblich entweder durch sorgf√§ltiges Lesen der Dokumentation oder durch eingehende Untersuchung der Stapelverfolgung und Auffinden der Wurzel des Problems gel√∂st. </font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vorteile von URLProtocol </font></font></h3><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schwache Komponentenkonnektivit√§t</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Der Teil der Anwendung, der das Laden der ben√∂tigten Daten initiiert, wei√ü m√∂glicherweise √ºberhaupt nicht, wie sie organisiert ist: Welche Komponenten werden daf√ºr verwendet, wie ist das Caching angeordnet? </font><font style="vertical-align: inherit;">Wir kennen nur ein bestimmtes Format </font></font><code>URL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- und interagieren nur damit.</font></font></li><li> <b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><code>URL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einfache </font><b><font style="vertical-align: inherit;">Implementierung</font></b><font style="vertical-align: inherit;"> - F√ºr den korrekten Betrieb des </font><font style="vertical-align: inherit;">Protokolls reicht es aus, mehrere einfache Methoden zu implementieren und das Protokoll zu registrieren. </font><font style="vertical-align: inherit;">Danach kann es √ºberall in der Anwendung verwendet werden.</font></font></li><li> <b>  </b> ‚Äî       ,      ,   <code>URL</code> -.       <code>URL</code> , <code>URLSession</code> , <code>URLSessionDataTask</code> . </li><li> <b> </b> ‚Äî    <code>URL</code> -   <code>URL</code> -,             <code>URL Loading System</code> . </li><li> <b>*  API</b> ‚Äî      .     ,        API,   -  ,   <code>URL</code> -.       ,       API         ,  .         <code>URL</code> -      <code>http</code> / <code>https</code> . </li></ul><br> <code>URL</code> - ‚Äî         .      .  -   ,   -    ,   ,    , ‚Äî  ,      .  ,     , ‚Äî  <code>URL</code> . <br><br> <b>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  GitHub</a></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467605/">https://habr.com/ru/post/de467605/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467591/index.html">Der neue Beweis l√∂st die Approximation von Zahlen wie pi</a></li>
<li><a href="../de467593/index.html">(Nicht relevant, repariert) Hinweis. Wie Tele2 den Zugriff auf das pers√∂nliche Konto neuer Abonnenten teilt</a></li>
<li><a href="../de467595/index.html">Reisen durch das Selectel-Rechenzentrum. Dinosaur on Fire, VMware, C2F5H und der unsichtbare Werwolf</a></li>
<li><a href="../de467597/index.html">Personalisierung von Big Data-Produktrichtlinien mit Vowpal Wabbit</a></li>
<li><a href="../de467599/index.html">3D-Grafik-Rendering mit OpenGL</a></li>
<li><a href="../de467607/index.html">Gest√§ndnis des Hafenhassers</a></li>
<li><a href="../de467609/index.html">Erstellen einer mobilen Anwendung in React Native</a></li>
<li><a href="../de467611/index.html">Algorithmen zur Erkennung von Bildumrissen</a></li>
<li><a href="../de467615/index.html">Wie man einen Python-Wrapper erstellt und nicht verr√ºckt wird</a></li>
<li><a href="../de467617/index.html">Kaspresso: das Autotest-Framework, auf das Sie gewartet haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>