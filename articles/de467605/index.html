<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👏 ✌🏻 🗯️ Alles was Sie brauchen ist URL 👨🏿‍🎓 🌫️ 👡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="VKontakte-Benutzer tauschen täglich 10 Milliarden Nachrichten aus. Sie senden sich gegenseitig Fotos, Comics, Memes und andere Anhänge. Wir werden Ihn...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Alles was Sie brauchen ist URL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/vk/blog/467605/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/g6/l2/us/g6l2usvzzisf7ezfubycuyoty08.jpeg" alt="Bild"></div><br>  VKontakte-Benutzer tauschen täglich 10 Milliarden Nachrichten aus.  Sie senden sich gegenseitig Fotos, Comics, Memes und andere Anhänge.  Wir werden Ihnen <b><code>URLProtocol</code></b> , wie wir eine iOS-Anwendung zum Hochladen von Bildern mit <b><code>URLProtocol</code></b> , und Schritt für Schritt werden wir herausfinden, wie wir unsere eigene implementieren können. <br><a name="habracut"></a><br>  Vor ungefähr anderthalb Jahren war die Entwicklung eines neuen Nachrichtenabschnitts in der VK-Anwendung für iOS in vollem Gange.  Dies ist der erste Abschnitt, der vollständig in Swift geschrieben wurde.  Es befindet sich in einem separaten Modul <code>vkm</code> (VK Messages), das nichts über das Gerät der Hauptanwendung weiß.  Es kann sogar in einem separaten Projekt ausgeführt werden - die grundlegenden Funktionen zum Lesen und Senden von Nachrichten funktionieren weiterhin.  In der Hauptanwendung werden Nachrichtencontroller über den entsprechenden Container View Controller hinzugefügt, um beispielsweise eine Liste von Konversationen oder Nachrichten in einer Konversation anzuzeigen. <br><br>  Nachrichten sind einer der beliebtesten Bereiche der mobilen VKontakte-Anwendung. Daher ist es wichtig, dass sie wie eine Uhr funktionieren.  Im <code>messages</code> kämpfen wir um jede Codezeile.  Es hat uns immer sehr gut gefallen, wie ordentlich die Nachrichten in die Anwendung integriert sind, und wir bemühen uns sicherzustellen, dass alles beim Alten bleibt. <br><br>  Nachdem wir den Abschnitt schrittweise mit neuen Funktionen gefüllt hatten, näherten wir uns der folgenden Aufgabe: Es war erforderlich, das Foto, das an die Nachricht angehängt ist, zuerst in einem Entwurf anzuzeigen und nach dem Senden in der allgemeinen Liste der Nachrichten zu erstellen.  Wir könnten einfach ein Modul hinzufügen, um mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>PHImageManager</code></a> zu arbeiten, aber zusätzliche Bedingungen erschwerten die Aufgabe. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0l/7t/hm/0l7thmey5vyyonmpbt5wicd-vjm.gif" alt="Bild"></div><br><br>  Bei der Auswahl eines Snapshots kann der Benutzer diesen verarbeiten: Filter anwenden, drehen, zuschneiden usw. In der VK-Anwendung wird diese Funktionalität in einer separaten <code>AssetService</code> Komponente <code>AssetService</code> .  Jetzt musste man aus dem Nachrichtenprojekt lernen, mit ihm zu arbeiten. <br><br><blockquote>  Nun, die Aufgabe ist ganz einfach, wir werden es tun.  Dies ist ungefähr die durchschnittliche Lösung, da es viele Variationen gibt.  Wir nehmen das Protokoll, legen es in Nachrichten ab und füllen es mit Methoden.  Wir erweitern den AssetService, passen das Protokoll an und fügen unsere Cache-Implementierung hinzu!  für die Viskosität.  Dann fügen wir die Implementierung in Nachrichten ein, fügen sie einem Dienst oder Manager hinzu, der mit all dem funktioniert, und beginnen, sie zu verwenden.  Gleichzeitig kommt immer noch ein neuer Entwickler und verurteilt, während er versucht, alles herauszufinden, flüsternd ... (na ja, verstehen Sie).  Gleichzeitig tritt Schweiß auf seiner Stirn auf. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7i/ze/q8/7izeq8h2gkpsgj2qybfro74kobc.jpeg" alt="Bild"></div><br></blockquote><br>  Diese Entscheidung <i>gefiel uns nicht</i> .  Es werden neue Entitäten <code>AssetService</code> , über die Nachrichtenkomponenten bei der Arbeit mit Bildern aus <code>AssetService</code> Bescheid wissen <code>AssetService</code> .  Der Entwickler muss außerdem zusätzliche Arbeit leisten, um herauszufinden, wie dieses System funktioniert.  Schließlich gab es eine zusätzliche implizite Verknüpfung zu den Komponenten des Hauptprojekts, die wir zu vermeiden versuchen, damit der Nachrichtenabschnitt weiterhin als unabhängiges Modul funktioniert. <br><br>  Ich wollte das Problem lösen, damit das Projekt überhaupt nichts darüber wusste, welche Art von Bild ausgewählt wurde, wie es gespeichert werden sollte, ob es speziell geladen und gerendert werden musste.  Darüber hinaus haben wir bereits die Möglichkeit, herkömmliche Bilder aus dem Internet herunterzuladen, nur werden sie nicht über einen zusätzlichen Dienst heruntergeladen, sondern einfach per <code>URL</code> .  Tatsächlich gibt es keinen Unterschied zwischen den beiden Bildtypen.  Nur einige werden lokal gespeichert, während andere auf dem Server gespeichert werden. <br><br>  Wir hatten also eine sehr einfache Idee: Was ist, wenn das Laden lokaler Assets auch über eine <code>URL</code> erlernt werden <code>URL</code> ?  Es scheint, als würde dies mit einem Klick auf <s>Thanos '</s> Finger alle unsere Probleme lösen: Sie müssen nichts über <code>AssetService</code> wissen, neue Datentypen hinzufügen und die Entropie vergeblich erhöhen, lernen, einen neuen Bildtyp zu laden, sich um das Zwischenspeichern von Daten kümmern.  Klingt nach einem Plan. <br><br><h2>  Wir brauchen nur eine URL </h2><br>  Wir haben diese Idee berücksichtigt und beschlossen, das <code>URL</code> Format zu definieren, das zum Laden lokaler Assets verwendet wird: <br><br><pre> <code class="json hljs">asset://?id=<span class="hljs-number"><span class="hljs-number">123</span></span>&amp;width=<span class="hljs-number"><span class="hljs-number">1920</span></span>&amp;height=<span class="hljs-number"><span class="hljs-number">1280</span></span></code> </pre> <br>  Wir werden den Wert der Eigenschaft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>localIdentifier</code></a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>localIdentifier</code></a> als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>PHObject</code></a> und die Parameter <code>width</code> und <code>height</code> , um die Bilder der gewünschten Größe zu laden.  Wir fügen auch einige weitere Parameter wie <code>crop</code> , <code>filter</code> und <code>rotate</code> , mit denen Sie mit den Informationen des verarbeiteten Bildes arbeiten können. <br><br>  Um diese <code>URL</code> erstellen wir ein <code>AssetURLProtocol</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AssetURLProtocol</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLProtocol</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br>  Seine Aufgabe besteht darin, das Image über <code>AssetService</code> zu laden und die bereits gebrauchsfertigen Daten zurückzugeben. <br><br>  All dies ermöglicht es uns, die Arbeit des <code>URL</code> Protokolls und des <code>URL Loading System</code> fast vollständig zu delegieren. <br><br>  Innerhalb der Nachrichten kann mit den gängigsten <code>URL</code> nur in einem anderen Format gearbeitet werden.  Es wird auch möglich sein, den vorhandenen Mechanismus zum Laden von Bildern wiederzuverwenden. Es ist sehr einfach, in der Datenbank zu serialisieren und das Zwischenspeichern von Daten über Standard- <code>URLCache</code> . <br><br>  Hat es geklappt?  Wenn Sie beim Lesen dieses Artikels ein Foto aus der Galerie an die Nachricht in der VKontakte-Anwendung anhängen können, dann ja :) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bm/6j/tb/bm6jtb7mkd489czjvwhzpy-dpo0.jpeg" alt="Bild"></div><br>  Um zu verdeutlichen, wie Sie Ihr <code>URLProtocol</code> implementieren, schlage ich vor, dies <code>URLProtocol</code> eines Beispiels zu betrachten. <br><br>  Wir haben uns die Aufgabe gestellt: eine einfache Anwendung mit einer Liste zu implementieren, in der Sie eine Liste von Kartenschnappschüssen an den angegebenen Koordinaten anzeigen müssen.  Zum Herunterladen von Snapshots verwenden wir den Standard- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>MKMapSnapshotter</code></a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>MapKit</code></a> und laden Daten über das benutzerdefinierte <code>URLProtocol</code> .  Das Ergebnis könnte ungefähr so ​​aussehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l1/bg/s8/l1bgs8g0xzehoxt49oddmmtbuoe.gif" alt="Bild"></div><br>  Zunächst implementieren wir den Mechanismus zum Laden von Daten per <code>URL</code> .  Um den Kartenschnappschuss anzuzeigen, müssen wir die Koordinaten des Punktes kennen - seine Breite und Länge ( <code>latitude</code> , <code>longitude</code> ).  Definieren Sie das benutzerdefinierte <code>URL</code> Format, mit dem Informationen geladen werden sollen: <br><br><pre> <code class="json hljs">map://?latitude=<span class="hljs-number"><span class="hljs-number">59.935634</span></span>&amp;longitude=<span class="hljs-number"><span class="hljs-number">30.325935</span></span></code> </pre> <br>  Jetzt implementieren wir <code>URLProtocol</code> , das solche Links verarbeitet und das gewünschte Ergebnis generiert.  Erstellen wir die <code>MapURLProtocol</code> Klasse, die wir von der Basisklasse <code>URLProtocol</code> erben.  Trotz seines Namens ist <code>URLProtocol</code> eine abstrakte Klasse.  <code>URLProtocol</code> Sie nicht verlegen, hier verwenden wir andere Konzepte - <code>URLProtocol</code> repräsentiert genau das <code>URL</code> Protokoll und hat keine Beziehung zu OOP-Begriffen.  Also <code>MapURLProtocol</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MapURLProtocol</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLProtocol</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br>  Jetzt definieren wir einige erforderliche Methoden neu, ohne die das <code>URL</code> Protokoll nicht funktioniert: <br><br><h3>  1. <code>canInit(with:)</code> </h3><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">func</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">canInit</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLRequest</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bool</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.url?.scheme == <span class="hljs-string"><span class="hljs-string">"map"</span></span> }</code> </pre> <br>  Die Methode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>canInit(with:)</code></a> wird benötigt, um anzugeben, welche Arten von Anforderungen unser <code>URL</code> Protokoll verarbeiten kann.  Angenommen, das Protokoll verarbeitet in diesem Beispiel nur Anforderungen mit einem <code>map</code> in der <code>URL</code> .  Vor dem Starten einer Anforderung durchläuft die <code>URL Loading System</code> alle für die Sitzung registrierten Protokolle und ruft diese Methode auf.  Das erste registrierte Protokoll, das bei dieser Methode <code>true</code> zurückgibt, wird zur Verarbeitung der Anforderung verwendet. <br><br><h4>  <code>canonicalRequest(for:)</code> </h4><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">func</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">canonicalRequest</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">for</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLRequest</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLRequest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request }</code> </pre> <br>  Die Methode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>canonicalRequest(for:)</code></a> soll die Anforderung auf kanonische Form reduzieren.  Die Dokumentation besagt, dass die Implementierung des Protokolls selbst entscheidet, was als Definition dieses Konzepts zu betrachten ist.  Hier können Sie das Schema normalisieren, der Anforderung bei Bedarf Header hinzufügen usw. Die einzige Voraussetzung für die Funktion dieser Methode ist, dass für jede eingehende Anforderung immer das gleiche Ergebnis erzielt wird, auch weil diese Methode auch zur Suche nach zwischengespeicherten Antworten verwendet wird Anfragen in <code>URLCache</code> . <br><br><h4>  3. <code>startLoading()</code> </h4><br>  Die Methode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>startLoading()</code></a> beschreibt die gesamte Logik zum Laden der erforderlichen Daten.  In diesem Beispiel müssen Sie die Anforderungs- <code>URL</code> analysieren und basierend auf den Werten der <code>latitude</code> und <code>latitude</code> zu <code>MKMapSnapshotter</code> und den gewünschten Kartenschnappschuss laden. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = request.url, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> components = <span class="hljs-type"><span class="hljs-type">URLComponents</span></span>(url: url, resolvingAgainstBaseURL: <span class="hljs-literal"><span class="hljs-literal">false</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> queryItems = components.queryItems <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fail(with: .badURL) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } load(with: queryItems) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with queryItems: [URLQueryItem])</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> snapshotter = <span class="hljs-type"><span class="hljs-type">MKMapSnapshotter</span></span>(queryItems: queryItems) snapshotter.start( with: <span class="hljs-type"><span class="hljs-type">DispatchQueue</span></span>.global(qos: .background), completionHandler: handle ) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(snapshot: MKMapSnapshotter.Snapshot?, error: Error?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> snapshot = snapshot, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = snapshot.image.jpegData(compressionQuality: <span class="hljs-number"><span class="hljs-number">1</span></span>) { complete(with: data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error = error { fail(with: error) } }</code> </pre> <br>  Nach dem Empfang der Daten muss das Protokoll korrekt heruntergefahren werden: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">complete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with data: Data)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = request.url, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> client = client <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> response = <span class="hljs-type"><span class="hljs-type">URLResponse</span></span>( url: url, mimeType: <span class="hljs-string"><span class="hljs-string">"image/jpeg"</span></span>, expectedContentLength: data.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>, textEncodingName: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> ) client.urlProtocol(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didReceive: response, cacheStoragePolicy: .allowed) client.urlProtocol(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didLoad: data) client.urlProtocolDidFinishLoading(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) }</code> </pre> <br>  Erstellen Sie zunächst ein Objekt vom Typ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>URLResponse</code></a> .  Dieses Objekt enthält wichtige Metadaten für die Beantwortung einer Anfrage.  Dann führen wir drei wichtige Methoden für ein Objekt vom Typ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>URLProtocolClient</code></a> .  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>client</code></a> Eigenschaft dieses Typs enthält jede Entität des <code>URL</code> Protokolls.  Es fungiert als Proxy zwischen dem <code>URL</code> Protokoll und der gesamten <code>URL Loading System</code> , das beim <code>URL Loading System</code> dieser Methoden Rückschlüsse darauf zieht, was mit den Daten zu tun ist: Cache, Anforderungen an <code>completionHandler</code> , Protokollabschaltung irgendwie verarbeiten usw. und die Anzahl der Aufrufe dieser Methoden kann abhängig von der Protokollimplementierung variieren.  Beispielsweise können wir Daten <code>URLProtocolClient</code> aus dem Netzwerk herunterladen und <code>URLProtocolClient</code> regelmäßig darüber informieren, um den Fortschritt des <code>URLProtocolClient</code> in der Schnittstelle <code>URLProtocolClient</code> . <br><br>  Wenn beim Betrieb des Protokolls ein Fehler auftritt, muss <code>URLProtocolClient</code> auch korrekt verarbeitet und benachrichtigt werden: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with error: Error)</span></span></span></span> { client?.urlProtocol(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didFailWithError: error) }</code> </pre> <br>  Dieser Fehler wird dann an den <code>completionHandler</code> der Anfrage gesendet, wo er verarbeitet und dem Benutzer eine schöne Nachricht angezeigt werden kann. <br><br><h4>  4. <code>stopLoading()</code> </h4><br>  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>stopLoading()</code></a> -Methode wird aufgerufen, wenn die Protokolloperation aus irgendeinem Grund abgeschlossen wurde.  Dies kann entweder ein erfolgreicher Abschluss oder ein Fehlerabschluss oder eine Stornierung der Anforderung sein.  Dies ist ein guter Ort, um belegte Ressourcen freizugeben oder temporäre Daten zu löschen. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stopLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { }</code> </pre> <br>  Damit ist die Implementierung des <code>URL</code> Protokolls abgeschlossen, das überall in der Anwendung verwendet werden kann.  Fügen Sie noch ein paar Dinge hinzu, um unser Protokoll anzuwenden. <br><br><h4> <code>URLImageView</code> </h4> <br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLImageView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIImageView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> task: <span class="hljs-type"><span class="hljs-type">URLSessionDataTask?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> taskId: <span class="hljs-type"><span class="hljs-type">Int?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url: URL)</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(task == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> || task?.taskIdentifier != taskId) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>(url: url) task = session.dataTask(with: request, completionHandler: complete) taskId = task?.taskIdentifier task?.resume() } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">complete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data: Data?, response: URLResponse?, error: Error?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.taskId == task?.taskIdentifier, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = data, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> image = <span class="hljs-type"><span class="hljs-type">UIImage</span></span>(data: data) { didLoadRemote(image: image) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didLoadRemote</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image: UIImage)</span></span></span></span> { <span class="hljs-type"><span class="hljs-type">DispatchQueue</span></span>.main.async { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.image = image } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareForReuse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { task?.cancel() taskId = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> image = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br>  Dies ist eine einfache Klasse, der Nachkomme von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>UIImageView</code></a> , eine ähnliche Implementierung, die Sie wahrscheinlich in jeder Anwendung haben.  Hier laden wir das Bild einfach über die <code>URL</code> in die Methode <code>render(url:)</code> und schreiben es in die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>image</code></a> .  Der Vorteil ist, dass Sie absolut jedes Bild hochladen können, entweder über die <code>http</code> / <code>https</code> <code>URL</code> oder über unsere benutzerdefinierte <code>URL</code> . <br><br>  Um Anforderungen zum Laden von Bildern auszuführen, benötigen Sie außerdem ein Objekt vom Typ <code>URLSession</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> config: <span class="hljs-type"><span class="hljs-type">URLSessionConfiguration</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = <span class="hljs-type"><span class="hljs-type">URLSessionConfiguration</span></span>.ephemeral <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.protocolClasses = [ <span class="hljs-type"><span class="hljs-type">MapURLProtocol</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> }() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> session = <span class="hljs-type"><span class="hljs-type">URLSession</span></span>( configuration: config, delegate: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, delegateQueue: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> )</code> </pre> <br>  Die Sitzungskonfiguration ist hier besonders wichtig.  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>URLSessionConfiguration</code></a> gibt es eine wichtige Eigenschaft für uns - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>protocolClasses</code></a> .  Dies ist eine Liste der Arten von <code>URL</code> Protokollen, die eine Sitzung mit dieser Konfiguration verarbeiten kann.  Standardmäßig unterstützt die Sitzung die Verarbeitung von <code>http</code> / <code>https</code> Protokollen. Wenn benutzerdefinierte Unterstützung erforderlich ist, müssen diese angegeben werden.  <code>MapURLProtocol</code> Sie in unserem Beispiel <code>MapURLProtocol</code> . <br><br>  Sie müssen lediglich den View Controller implementieren, der Kartenschnappschüsse anzeigt.  Den Quellcode finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Hier ist das Ergebnis: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ed/gf/c8/edgfc8crekglljfq33hfggic520.gif" alt="Bild"></div><br><h2>  Was ist mit Caching? </h2><br>  Alles scheint gut zu funktionieren - bis auf einen wichtigen Punkt: Wenn wir die Liste hin und her scrollen, erscheinen weiße Flecken auf dem Bildschirm.  Es scheint, dass Snapshots in keiner Weise zwischengespeichert werden und für jeden Aufruf der <code>render(url:)</code> -Methode <code>MKMapSnapshotter</code> wir <code>MKMapSnapshotter</code> Daten über <code>MKMapSnapshotter</code> .  Dies braucht Zeit und daher solche Ladelücken.  Es lohnt sich, einen Daten-Caching-Mechanismus zu implementieren, damit bereits erstellte Snapshots nicht erneut heruntergeladen werden.  Hier nutzen wir die Leistung des <code>URL Loading System</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>URLCache</code></a> , für das bereits ein Caching-Mechanismus für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>URLCache</code></a> vorgesehen ist. <br><br>  Betrachten Sie diesen Prozess genauer und teilen Sie die Arbeit mit dem Cache in zwei wichtige Phasen ein: Lesen und Schreiben. <br><br><h3>  Lesen </h3><br>  Um zwischengespeicherte Daten korrekt zu lesen, benötigt die <code>URL Loading System</code> Hilfe, um Antworten auf mehrere wichtige Fragen zu erhalten: <br><br>  <b>1. Welcher URLCache soll verwendet werden?</b> <br><br>  Natürlich ist <code>URLCache.shared</code> bereits fertig, aber die <code>URL Loading System</code> <code>URLCache.shared</code> kann es nicht immer verwenden. Schließlich möchte der Entwickler möglicherweise seine eigene <code>URLCache</code> Entität erstellen und verwenden.  Um diese Frage zu beantworten, verfügt die <code>URLSessionConfiguration</code> Sitzungskonfiguration über eine <code>urlCache</code> Eigenschaft.  Es wird sowohl zum Lesen als auch zum Aufzeichnen von Antworten auf Anforderungen verwendet.  Wir werden einige <code>URLCache</code> für diese Zwecke in unserer vorhandenen Konfiguration <code>URLCache</code> . <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> config: <span class="hljs-type"><span class="hljs-type">URLSessionConfiguration</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = <span class="hljs-type"><span class="hljs-type">URLSessionConfiguration</span></span>.ephemeral <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.urlCache = <span class="hljs-type"><span class="hljs-type">ImageURLCache</span></span>.current <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.protocolClasses = [ <span class="hljs-type"><span class="hljs-type">MapURLProtocol</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> }()</code> </pre> <br>  <b>2. Muss ich zwischengespeicherte Daten verwenden oder erneut herunterladen?</b> <br><br>  Die Antwort auf diese Frage hängt von der <code>URLRequest</code> Anforderung ab, die wir ausführen werden.  Beim Erstellen einer Anforderung haben wir die Möglichkeit, zusätzlich zur <code>URL</code> eine Cache-Richtlinie im Argument <code>cachePolicy</code> anzugeben. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>( url: url, cachePolicy: .returnCacheDataElseLoad, timeoutInterval: <span class="hljs-number"><span class="hljs-number">30</span></span> )</code> </pre> <br>  Der Standardwert ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>.useProtocolCachePolicy</code></a> , der ebenfalls in der Dokumentation beschrieben wird.  Dies bedeutet, dass in dieser Version die Aufgabe, eine zwischengespeicherte Antwort auf eine Anforderung zu finden und ihre Relevanz zu bestimmen, vollständig in der Implementierung des <code>URL</code> Protokolls liegt.  Aber es gibt einen einfacheren Weg.  Wenn Sie den Wert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>.returnCacheDataElseLoad</code></a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>.returnCacheDataElseLoad</code></a> das <code>URLProtocol</code> <code>URL Loading System</code> beim Erstellen der nächsten Entität <code>URLProtocol</code> Teil der Arbeit: Es fragt <code>urlCache</code> zwischengespeicherten Antwort auf die aktuelle Anforderung mithilfe der Methode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>cachedResponse(for:)</code></a> .  Wenn zwischengespeicherte Daten vorhanden sind, wird ein Objekt vom Typ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>CachedURLResponse</code></a> sofort übertragen, wenn das <code>URLProtocol</code> initialisiert und in der Eigenschaft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>cachedResponse</code></a> gespeichert wird: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>( request: <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>, cachedResponse: <span class="hljs-type"><span class="hljs-type">CachedURLResponse?</span></span>, client: <span class="hljs-type"><span class="hljs-type">URLProtocolClient?</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>( request: request, cachedResponse: cachedResponse, client: client ) }</code> </pre> <br>  <code>CachedURLResponse</code> ist eine einfache Klasse, die Daten ( <code>Data</code> ) und Metainformationen für sie ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>URLResponse</code></a> ) enthält. <br><br>  Wir können die <code>startLoading</code> Methode nur ein <code>startLoading</code> ändern und den Wert dieser Eigenschaft darin überprüfen - und das Protokoll sofort mit diesen Daten beenden: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cachedResponse = cachedResponse { complete(with: cachedResponse.data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = request.url, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> components = <span class="hljs-type"><span class="hljs-type">URLComponents</span></span>(url: url, resolvingAgainstBaseURL: <span class="hljs-literal"><span class="hljs-literal">false</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> queryItems = components.queryItems <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fail(with: .badURL) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } load(with: queryItems) } }</code> </pre> <br><h3>  Aufzeichnen </h3><br>  Um Daten im Cache zu finden, müssen Sie sie dort ablegen.  Das <code>URL Loading System</code> kümmert sich ebenfalls um diese Arbeit.  Alles, was von uns verlangt wird, ist ihr mitzuteilen, dass wir die Daten zwischenspeichern möchten, wenn das Protokoll mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>cacheStoragePolicy</code></a> Cache-Richtlinieneinstellung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>cacheStoragePolicy</code></a> .  Dies ist eine einfache Aufzählung mit den folgenden Werten: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StoragePolicy</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> allowed <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> allowedInMemoryOnly <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> notAllowed }</code> </pre> <br>  Sie bedeuten, dass das Zwischenspeichern im Speicher und auf der Festplatte nur im Speicher zulässig oder verboten ist.  In unserem Beispiel geben wir an, dass das Zwischenspeichern im Speicher und auf der Festplatte zulässig ist. Warum nicht? <br><br><pre> <code class="swift hljs">client.urlProtocol(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didReceive: response, cacheStoragePolicy: .allowed)</code> </pre> <br>  Mit ein paar einfachen Schritten haben wir die Möglichkeit unterstützt, Karten-Snapshots zwischenzuspeichern.  Und jetzt funktioniert die Anwendung so: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l1/bg/s8/l1bgs8g0xzehoxt49oddmmtbuoe.gif" alt="Bild"></div><br>  Wie Sie sehen, gibt es keine weißen Flecken mehr - die Karten werden einmal geladen und dann einfach aus dem Cache wiederverwendet. <br><br><h2>  Nicht immer einfach </h2><br>  Bei der Implementierung des <code>URL</code> Protokolls sind eine Reihe von Abstürzen aufgetreten. <br><br>  Die erste <code>URLCache</code> die interne Implementierung der Interaktion des <code>URL Loading System</code> <code>URLCache</code> mit <code>URLCache</code> beim Zwischenspeichern von Antworten auf Anforderungen.  In der Dokumentation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">heißt es</a> : Trotz der <code>URLCache</code> von <code>URLCache</code> kann der Betrieb der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>cachedResponse(for:)</code></a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>storeCachedResponse(_:for:)</code></a> zum Lesen / Schreiben von Antworten auf Anforderungen zu einer <code>URLCache</code> von Zuständen führen. Daher sollte dieser Punkt in Unterklassen von <code>URLCache</code> berücksichtigt werden.  Wir haben erwartet, dass mit <code>URLCache.shared</code> dieses Problem gelöst wird, aber es hat sich als falsch herausgestellt.  Um dies zu beheben, verwenden wir einen separaten <code>ImageURLCache</code> Cache, einen Nachkommen von <code>URLCache</code> , in dem wir die angegebenen Methoden synchron in einer separaten Warteschlange ausführen.  Als angenehmen Bonus können wir die Cache-Kapazität im Speicher und auf der Festplatte separat von anderen <code>URLCache</code> Entitäten <code>URLCache</code> . <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> accessQueue = <span class="hljs-type"><span class="hljs-type">DispatchQueue</span></span>( label: <span class="hljs-string"><span class="hljs-string">"image-urlcache-access"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cachedResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request: URLRequest)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CachedURLResponse?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">ImageURLCache</span></span>.accessQueue.sync { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.cachedResponse(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: request) } } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">storeCachedResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> response: CachedURLResponse, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request: URLRequest)</span></span></span></span> { <span class="hljs-type"><span class="hljs-type">ImageURLCache</span></span>.accessQueue.sync { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.storeCachedResponse(response, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: request) } }</code> </pre> <br>  Ein weiteres Problem wurde nur auf Geräten mit iOS 9 reproduziert. Die Methoden zum Starten und Beenden des Ladens des <code>URL</code> Protokolls können für verschiedene Threads ausgeführt werden, was zu seltenen, aber unangenehmen Abstürzen führen kann.  Um das Problem zu lösen, speichern wir den aktuellen Thread in der <code>startLoading</code> Methode und führen dann den Download-Abschlusscode direkt in diesem Thread aus. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread: <span class="hljs-type"><span class="hljs-type">Thread!</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = request.url, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> components = <span class="hljs-type"><span class="hljs-type">URLComponents</span></span>(url: url, resolvingAgainstBaseURL: <span class="hljs-literal"><span class="hljs-literal">false</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> queryItems = components.queryItems <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fail(with: .badURL) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } thread = <span class="hljs-type"><span class="hljs-type">Thread</span></span>.current <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cachedResponse = cachedResponse { complete(with: cachedResponse) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { load(request: request, url: url, queryItems: queryItems) } }</code> </pre> <br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(snapshot: MKMapSnapshotter.Snapshot?, error: Error?)</span></span></span></span> { thread.execute { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> snapshot = snapshot, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = snapshot.image.jpegData(compressionQuality: <span class="hljs-number"><span class="hljs-number">0.7</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.complete(with: data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error = error { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.fail(with: error) } } }</code> </pre> <br><h2>  Wann kann ein URL-Protokoll nützlich sein? </h2><br>  Infolgedessen stößt fast jeder Benutzer unserer iOS-Anwendung auf die eine oder andere Weise auf Elemente, die über das <code>URL</code> Protokoll funktionieren.  Neben dem Herunterladen von Medien aus der Galerie helfen uns verschiedene Implementierungen von <code>URL</code> Protokollen beim Anzeigen von Karten und Umfragen sowie beim Anzeigen von Chat-Avataren, die aus Fotos ihrer Teilnehmer bestehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5v/jz/sl/5vjzsliedpi6l9qt6qhnaloi1l8.jpeg" alt="Bild"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p0/g4/rz/p0g4rzbdjqqbx3oc-ochol6ilwy.jpeg" alt="Bild"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n4/1e/mb/n41embtawargx2zofdmevlyq_nk.jpeg" alt="Bild"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j4/dn/gj/j4dngjkluh5gyxb3od9vwkse9zu.jpeg" alt="Bild"></div><br>  Wie jede Lösung hat <code>URLProtocol</code> seine Vor- und Nachteile. <br><br><h3>  Nachteile von <code>URLProtocol</code> </h3><br><ul><li>  <b>Fehlende strikte Eingabe</b> - Beim Erstellen einer <code>URL</code> Schema- und Linkparameter manuell über Zeichenfolgen angegeben.  Wenn Sie einen Tippfehler machen, wird der gewünschte Parameter nicht verarbeitet.  Dies kann das Debuggen der Anwendung und die Suche nach Fehlern in ihrem Betrieb erschweren.  In der VKontakte-Anwendung verwenden wir spezielle <code>URLBuilder</code> , die die endgültige <code>URL</code> basierend auf den übergebenen Parametern bilden.  Diese Entscheidung ist nicht sehr schön und widerspricht etwas dem Ziel, keine zusätzlichen Einheiten zu produzieren, aber es gibt noch keine bessere Idee.  Wir wissen jedoch, dass es einen speziellen <code>URLBuilder</code> , der Ihnen hilft, keinen Fehler zu machen, wenn Sie eine benutzerdefinierte <code>URL</code> erstellen müssen. </li><li>  <b>Nicht offensichtliche Abstürze</b> - Ich habe bereits einige Szenarien beschrieben, die dazu führen können, dass eine Anwendung mit <code>URLProtocol</code> abstürzt.  Vielleicht gibt es noch andere.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Solche Probleme werden jedoch wie üblich entweder durch sorgfältiges Lesen der Dokumentation oder durch eingehende Untersuchung der Stapelverfolgung und Auffinden der Wurzel des Problems gelöst. </font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vorteile von URLProtocol </font></font></h3><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schwache Komponentenkonnektivität</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Der Teil der Anwendung, der das Laden der benötigten Daten initiiert, weiß möglicherweise überhaupt nicht, wie sie organisiert ist: Welche Komponenten werden dafür verwendet, wie ist das Caching angeordnet? </font><font style="vertical-align: inherit;">Wir kennen nur ein bestimmtes Format </font></font><code>URL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- und interagieren nur damit.</font></font></li><li> <b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><code>URL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einfache </font><b><font style="vertical-align: inherit;">Implementierung</font></b><font style="vertical-align: inherit;"> - Für den korrekten Betrieb des </font><font style="vertical-align: inherit;">Protokolls reicht es aus, mehrere einfache Methoden zu implementieren und das Protokoll zu registrieren. </font><font style="vertical-align: inherit;">Danach kann es überall in der Anwendung verwendet werden.</font></font></li><li> <b>  </b> —       ,      ,   <code>URL</code> -.       <code>URL</code> , <code>URLSession</code> , <code>URLSessionDataTask</code> . </li><li> <b> </b> —    <code>URL</code> -   <code>URL</code> -,             <code>URL Loading System</code> . </li><li> <b>*  API</b> —      .     ,        API,   -  ,   <code>URL</code> -.       ,       API         ,  .         <code>URL</code> -      <code>http</code> / <code>https</code> . </li></ul><br> <code>URL</code> - —         .      .  -   ,   -    ,   ,    , —  ,      .  ,     , —  <code>URL</code> . <br><br> <b>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  GitHub</a></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467605/">https://habr.com/ru/post/de467605/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467591/index.html">Der neue Beweis löst die Approximation von Zahlen wie pi</a></li>
<li><a href="../de467593/index.html">(Nicht relevant, repariert) Hinweis. Wie Tele2 den Zugriff auf das persönliche Konto neuer Abonnenten teilt</a></li>
<li><a href="../de467595/index.html">Reisen durch das Selectel-Rechenzentrum. Dinosaur on Fire, VMware, C2F5H und der unsichtbare Werwolf</a></li>
<li><a href="../de467597/index.html">Personalisierung von Big Data-Produktrichtlinien mit Vowpal Wabbit</a></li>
<li><a href="../de467599/index.html">3D-Grafik-Rendering mit OpenGL</a></li>
<li><a href="../de467607/index.html">Geständnis des Hafenhassers</a></li>
<li><a href="../de467609/index.html">Erstellen einer mobilen Anwendung in React Native</a></li>
<li><a href="../de467611/index.html">Algorithmen zur Erkennung von Bildumrissen</a></li>
<li><a href="../de467615/index.html">Wie man einen Python-Wrapper erstellt und nicht verrückt wird</a></li>
<li><a href="../de467617/index.html">Kaspresso: das Autotest-Framework, auf das Sie gewartet haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>