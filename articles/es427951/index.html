<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëé üéè üë®üèæ‚Äçüè≠ Probar su aplicaci√≥n Go como una caja negra con Rspec üë©‚Äçüè´ ‚óÄÔ∏è üíç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Las pruebas bien escritas reducen significativamente el riesgo de "romper" la aplicaci√≥n al agregar una nueva funci√≥n o corregir un error. En sistemas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Probar su aplicaci√≥n Go como una caja negra con Rspec</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427951/">  Las pruebas bien escritas reducen significativamente el riesgo de "romper" la aplicaci√≥n al agregar una nueva funci√≥n o corregir un error.  En sistemas complejos que constan de varios componentes interconectados, lo m√°s dif√≠cil es probar su terreno com√∫n. <br><br>  En este art√≠culo, hablar√© sobre c√≥mo encontramos la dificultad de escribir buenas pruebas al desarrollar un componente en Go y c√≥mo resolvimos este problema usando la biblioteca RSpec en Ruby on Rails. <br><a name="habracut"></a><br><h2>  Agregar Ir a la pila de tecnolog√≠a del proyecto </h2><br>  Uno de los proyectos que eTeam est√° desarrollando, donde trabajo, se puede dividir en: panel de administraci√≥n, cuenta de usuario, generador de informes y procesamiento de solicitudes de varios servicios con los que estamos integrados. <br><br>  La parte responsable de procesar las solicitudes es lo m√°s importante, por lo que quer√≠a que fuera lo m√°s confiable y asequible posible.  Al ser parte de una aplicaci√≥n monol√≠tica, se arriesgaba a recibir un error al cambiar secciones de c√≥digo no relacionadas con √©l.  Tambi√©n exist√≠a el riesgo de perder el procesamiento al cargar otros componentes de la aplicaci√≥n.  El n√∫mero de trabajadores de Ngnix por aplicaci√≥n es limitado y, a medida que la carga creci√≥, por ejemplo, al abrir muchas p√°ginas pesadas en el panel de administraci√≥n, los trabajadores libres se detuvieron y el procesamiento de solicitudes se ralentiz√≥ o incluso disminuy√≥. <br><br>  Estos riesgos, as√≠ como la madurez de este sistema (durante meses no tuvo que hacer cambios) lo convirtieron en un candidato ideal para la separaci√≥n en un servicio separado. <br>  Se decidi√≥ escribir este servicio por separado en Go.  Ten√≠a que compartir el acceso a la base de datos con la aplicaci√≥n Rails.  La responsabilidad de los posibles cambios en la estructura de la tabla permaneci√≥ con Rails.  En principio, dicho esquema con una base de datos com√∫n funciona bien, mientras que solo hay dos aplicaciones.  Se ve√≠a as√≠: <br><br><img src="https://habrastorage.org/webt/67/19/wy/6719wyo52lzxj3ofrjy4epnitjq.png" alt="imagen"><br><br>  El servicio fue escrito y desplegado en instancias separadas de Rails.  Ahora, al implementar aplicaciones Rails, no tiene que preocuparse de que afecte el procesamiento de consultas.  El servicio aceptaba solicitudes HTTP directamente, sin Ngnix, usaba un poco de memoria, era de alguna manera minimalista. <br><br><h2>  El problema con nuestras pruebas unitarias en Go </h2><br>  Las pruebas unitarias se implementaron en la aplicaci√≥n Go, y todas las consultas de la base de datos en ellas se bloquearon.  Entre otros argumentos a favor de tal soluci√≥n se encontraba el siguiente: la aplicaci√≥n principal de Rails es responsable de la estructura de la base de datos, por lo que la aplicaci√≥n go no "posee" la informaci√≥n para crear una base de datos de prueba.  El procesamiento de solicitudes para la mitad consisti√≥ en l√≥gica de negocios y la otra mitad en trabajar con la base de datos, y esta mitad estaba completamente bloqueada.  Moki en Go parece menos "legible" que en Ruby.  Al agregar una nueva funci√≥n para leer datos de la base de datos, era necesario agregarle moki en el conjunto de pruebas fallidas que funcionaban antes.  Como resultado, tales pruebas unitarias fueron ineficaces y extremadamente fr√°giles. <br><br><h2>  M√©todo de soluci√≥n </h2><br>  Para eliminar estas deficiencias, se decidi√≥ cubrir el servicio con pruebas funcionales ubicadas en la aplicaci√≥n Rails y probar el servicio en Go como una caja negra.  Como una caja blanca, todav√≠a no funcionar√≠a, porque desde ruby, incluso con todo el deseo, ser√≠a imposible intervenir en el servicio, por ejemplo, mojar alg√∫n m√©todo para verificar si se est√° llamando.  Tambi√©n significaba que las solicitudes enviadas por el servicio probado tambi√©n eran imposibles de bloquear, por lo tanto, se necesitaba otra aplicaci√≥n para capturarlas y registrarlas.  Algo as√≠ como RequestBin, pero local.  Ya escribimos una utilidad similar, as√≠ que la usamos. <br><br>  El siguiente esquema ha resultado: <br><br><ol><li>  rspec compila e inicia el servicio sobre la marcha, pas√°ndole una configuraci√≥n, que contiene acceso a la base de prueba y un cierto puerto para recibir solicitudes HTTP, por ejemplo 8082 </li><li>  Tambi√©n se lanza una utilidad para registrar las solicitudes HTTP recibidas en el puerto 8083 </li><li>  escribimos pruebas ordinarias en RSpec, es decir  cree los datos necesarios en la base de datos y env√≠e una solicitud a localhost: 8082, como a un servicio externo, por ejemplo, usando HTTParty </li><li>  respuesta parsim;  verificar cambios en la base de datos;  obtenemos la lista de solicitudes registradas de "RequestBin" y las verificamos. </li></ol><br><h2>  Detalles de implementaci√≥n: </h2><br>  Ahora sobre c√≥mo se implement√≥.  Para fines de demostraci√≥n, nombremos el servicio probado: "TheService" y creemos un contenedor para √©l: <br><br><pre><code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#/spec/support/the_service.rb #ensure that after all specs TheService will be stopped RSpec.configure do |config| config.after :suite do TheServiceControl.stop end end class TheServiceControl class &lt;&lt; self </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@pid</span></span></span><span class="hljs-comment"> = nil </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@config</span></span></span><span class="hljs-comment"> = nil def config puts "Please create file: #{config_path}" unless File.exist?(config_path) </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@config</span></span></span><span class="hljs-comment"> = YAML.load_file(config_path) end def host TheServiceControl.config['server']['addr'] end def config_path Rails.root.join('spec', 'support', 'the_service_config.yml') end def start # will be described below end def stop # will be described below end def post(params, headers) HTTParty.post("http://#{host}/request", body: params, headers: headers ) end end end</span></span></code> </pre> <br>  Por si acaso, har√© una reserva de que en Rspec debe configurarse para cargar autom√°ticamente los archivos desde la carpeta de "soporte": <br><br><pre> <code class="ruby hljs">Dir[Rails.root.join(<span class="hljs-string"><span class="hljs-string">'spec/support/**/*.rb'</span></span>)].each {<span class="hljs-params"><span class="hljs-params">|f|</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require</span></span> f}</code> </pre><br>  El m√©todo de inicio: <br><br><ul><li>  lee desde una configuraci√≥n separada la ruta a las fuentes de TheService y la informaci√≥n necesaria para ejecutar.  Porque  esta informaci√≥n puede diferir de los diferentes desarrolladores, esta configuraci√≥n est√° excluida de Git.  La misma configuraci√≥n contiene la configuraci√≥n necesaria para que se inicie el programa.  Estas configuraciones heterog√©neas se encuentran en un solo lugar para no producir archivos adicionales. <br></li><li>  compila y ejecuta el programa a trav√©s de "go run {ruta a main.go} {ruta a config}" </li><li>  sondeando cada segundo, espera hasta que el programa en ejecuci√≥n est√© listo para aceptar solicitudes <br></li><li>  recuerda el identificador de proceso para no reiniciar y poder detenerlo. </li></ul><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#/spec/support/the_service.rb class TheServiceControl #.... def start return unless </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@pid</span></span></span><span class="hljs-comment">.nil? puts "TheService starting. " env = config['rails']['env'] cmd = "go run #{config['rails']['main_go']} --config.file=#{config_path}" puts cmd #useful for debug when need run project manually #compile and run Dir.chdir(File.dirname(config['rails']['main_go'])) { </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@pid</span></span></span><span class="hljs-comment"> = Process.spawn(env, cmd, pgroup: true) } #wait until it ready to accept connections VCR.configure { |c| c.allow_http_connections_when_no_cassette = true } 1.upto(10) do response = HTTParty.get("http://#{host}/monitor") rescue nil break if response.try(:code) == 200 sleep(1) end VCR.configure { |c| c.allow_http_connections_when_no_cassette = false } puts "TheService started. PID: #{</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@pid</span></span></span><span class="hljs-comment">}" end #.... end</span></span></code> </pre><br>  config en s√≠ mismo: <br><br><pre> <code class="hljs pgsql">#/spec/support/the_service_config.yml <span class="hljs-keyword"><span class="hljs-keyword">server</span></span>: addr: <span class="hljs-number"><span class="hljs-number">127.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>:<span class="hljs-number"><span class="hljs-number">8082</span></span> db: dsn: dbname=project_test sslmode=<span class="hljs-keyword"><span class="hljs-keyword">disable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>=postgres <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>=secret redis: url: redis://<span class="hljs-number"><span class="hljs-number">127.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>:<span class="hljs-number"><span class="hljs-number">6379</span></span>/<span class="hljs-number"><span class="hljs-number">1</span></span> rails: main_go: /home/me/go/src/github.com/company/theservice/main.go recorder_addr: <span class="hljs-number"><span class="hljs-number">127.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>:<span class="hljs-number"><span class="hljs-number">8083</span></span> env: <span class="hljs-type"><span class="hljs-type">PATH</span></span>: <span class="hljs-string"><span class="hljs-string">'/home/me/.gvm/gos/go1.10.3/bin'</span></span> GOROOT: <span class="hljs-string"><span class="hljs-string">'/home/me/.gvm/gos/go1.10.3'</span></span> GOPATH: <span class="hljs-string"><span class="hljs-string">'/home/me/go'</span></span></code> </pre><br>  El m√©todo de detenci√≥n simplemente detiene el proceso.  Lo nuevo es que ruby ‚Äã‚Äãejecuta el comando "go run" que ejecuta el binario compilado en un proceso secundario cuya identificaci√≥n es desconocida.  Si simplemente detiene el proceso iniciado desde ruby, el proceso secundario no se detiene autom√°ticamente y el puerto permanece ocupado.  Por lo tanto, la detenci√≥n se produce por ID de grupo de procesos: <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#/spec/support/the_service.rb class TheServiceControl #.... def stop return if </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@pid</span></span></span><span class="hljs-comment">.nil? print "Stopping TheService (PID: #{</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@pid</span></span></span><span class="hljs-comment">}). " Process.kill("KILL", -Process.getpgid(</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@pid</span></span></span><span class="hljs-comment">)) res = Process.wait </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@pid</span></span></span><span class="hljs-comment"> = nil puts "Stopped. #{res}" end #.... end</span></span></code> </pre><br>  Ahora prepararemos un contexto compartido donde definiremos las variables predeterminadas, iniciaremos TheService si no se ha iniciado y deshabilitaremos temporalmente la videograbadora (desde su punto de vista, hablamos con un servicio externo, pero para nosotros ahora no es as√≠): <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#spec/support/shared_contexts/the_service_black_box.rb shared_context 'the_service_black_box' do let(:params) do { type: 'save', data: 1 } end let(:headers) { { 'HTTPS' =&gt; 'on', 'Content-Type' =&gt; 'application/json; charset=utf-8' } } subject(:response) { TheServiceControl.post(params, headers)} before(:all) { TheServiceControl.start } around(:each) do |example| VCR.configure { |c| c.allow_http_connections_when_no_cassette = true } example.run VCR.configure { |c| c.allow_http_connections_when_no_cassette = false } end end</span></span></code> </pre><br>  y ahora puedes comenzar a escribir las especificaciones ellos mismos: <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#spec/requests/the_service/ping_spec.rb require 'spec_helper' describe 'ping request' do include_context 'the_service_black_box' it 'returns response back' do params[:type] = 'ping' params[:data] = '123' parsed_response = JSON.parse(response.body) # make request and parse response expect(parsed_response['error']).to be nil expect(parsed_response['result']).to eq '123' expect(Log.count).to eq 1 #check something in DB end # more specs... end</span></span></code> </pre><br>  TheService puede realizar sus solicitudes HTTP a servicios externos.  Usando la configuraci√≥n, redirigimos a una utilidad local que los escribe.  Tambi√©n hay un contenedor para que se inicie y pare, es similar a la clase "TheServiceControl", excepto que la utilidad simplemente puede iniciarse sin compilaci√≥n. <br><br><h2>  Bollos extra </h2><br>  La aplicaci√≥n Go se escribi√≥ para que todos los registros y la informaci√≥n de depuraci√≥n se muestren en STDOUT.  Cuando se inicia en producci√≥n, esta salida se env√≠a a un archivo.  Y cuando se inicia desde Rspec, se muestra en la consola, lo que ayuda mucho al depurar. <br><br>  Si las especificaciones se ejecutan de forma selectiva, para lo cual no se necesita TheService, entonces no se inicia. <br><br>  Para evitar perder tiempo desarrollando el servicio cada vez que reinicia la especificaci√≥n al desarrollar, puede iniciar el servicio manualmente en el terminal y no desactivarlo.  Si es necesario, incluso puede ejecutarlo en el IDE en modo de depuraci√≥n, y luego la especificaci√≥n preparar√° todo lo que necesita, lanzar√° una solicitud de servicio, se detendr√° y podr√° degradar sin problemas.  Esto hace que el enfoque TDD sea muy conveniente. <br><br><h2>  Conclusiones </h2><br>  Tal esquema ha estado funcionando durante aproximadamente un a√±o y nunca ha fallado.  Las especificaciones son mucho m√°s legibles que las pruebas unitarias en Go, y no se basan en el conocimiento de la estructura interna del servicio.  Si, por alguna raz√≥n, necesitamos reescribir el servicio en otro idioma, no tendremos que cambiar las especificaciones, excepto el contenedor, que solo necesita iniciar el servicio de prueba con otro comando. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es427951/">https://habr.com/ru/post/es427951/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es427941/index.html">Implemente Kubernetes HA-cluster en Baremetal usando Kubeadm y Keepalived (gu√≠a simple)</a></li>
<li><a href="../es427943/index.html">Estamos a la espera de televisores LG OLED serie 8K en junio de 2019, el lanzamiento puede retrasarse</a></li>
<li><a href="../es427945/index.html">Hipervisor para tontos</a></li>
<li><a href="../es427947/index.html">Las redes neuronales no entienden qu√© son las ilusiones √≥pticas.</a></li>
<li><a href="../es427949/index.html">Nuestra falta de voluntad para cambiar nos impide comprender las estad√≠sticas.</a></li>
<li><a href="../es427953/index.html">Los microservicios hacen el mundo m√°s f√°cil (pero no)</a></li>
<li><a href="../es427955/index.html">Por qu√© no uso puntos de historia para la planificaci√≥n de sprint</a></li>
<li><a href="../es427957/index.html">DNS sobre TLS - Cifre nuestras consultas DNS usando Stunnel y Lua</a></li>
<li><a href="../es427959/index.html">Compru√©balo: hizo una mesa</a></li>
<li><a href="../es427961/index.html">C√≥mo Yandex intent√≥ copiar mi servicio de mapas de calor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>