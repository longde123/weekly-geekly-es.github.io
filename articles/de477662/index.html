<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≠ üßñüèΩ üíÖüèæ Zugriff auf Redd Tyres auf FTDI-Br√ºcken üôÖüèª ü§πüèø ü§úüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir haben einen gro√üen theoretischen Block abgeschlossen, in dem gezeigt wird, wie ein FPGA-Subsystem f√ºr den Redd-Komplex erstellt wird. Wie organisi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zugriff auf Redd Tyres auf FTDI-Br√ºcken</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477662/">  Wir haben einen gro√üen theoretischen Block abgeschlossen, in dem gezeigt wird, wie ein FPGA-Subsystem f√ºr den Redd-Komplex erstellt wird.  Wie organisiert man die Kommunikation zwischen dem FPGA und dem zentralen Prozessor des Komplexes?  Wie einfach ist es, Hochgeschwindigkeitsdatenstr√∂me im RAM zu speichern, das direkt mit dem FPGA verbunden ist, um sie anschlie√üend gem√§chlich an den Zentralprozessor zu √ºbertragen (oder umgekehrt, um Daten in diesem RAM f√ºr die anschlie√üende schnelle Ausgabe an den Kanal zu speichern).  Wir haben die Verfolgungstechniken des Nios II-Prozessors √ºberpr√ºft.  Wir sind in der Lage, die Leistung des auf Nios II basierenden Prozessorsystems so zu optimieren, dass die Arbeit so effizient wie m√∂glich verl√§uft.  Im Allgemeinen haben wir alle notwendigen Minimum-Theorien studiert, und es w√§re an der Zeit, mit der Praxis fortzufahren, indem wir ein nicht sehr komplexes, aber praktisch n√ºtzliches Ger√§t entwerfen ... Aber es gibt ein ABER. <br><br>  Aus den Kommentaren zu den Artikeln ging hervor, dass einige Leser glauben, Redd und FPGA seien wie Lenin und die Partei.  Dass sie untrennbar miteinander verbunden sind.  In der Tat ist dies √ºberhaupt nicht so.  Ich wollte nur ein Gespr√§ch √ºber den Redd-Komplex mit etwas Interessantem beginnen, aber was k√∂nnte interessanter sein als FPGA?  Nun, und ein Gespr√§ch zu beginnen, auf einen Blick zu unterbrechen, ist dumm.  Und schlie√ülich ist der gro√üe logische Block abgeschlossen.  Und um zu zeigen, dass FPGAs weit von Redd entfernt sind, schlage ich vor, ungef√§hr drei Artikel √ºber Dinge zu verfassen, die nichts damit zu tun haben.  Nun, und nachdem Sie diesen Block abgeschlossen haben, gehen Sie bereits zur FPGA-Praxis. <br><br><img src="https://habrastorage.org/webt/nu/nw/7p/nunw7p7f7c5hcnmlsv7haliroz8.png"><br><a name="habracut"></a><br><h2>  Einleitung </h2><br>  Das Erstaunlichste ist, dass mich die guten Chefs, sobald ich mich zu einem Exkurs zu anderen Themen entschlossen hatte, in eine schwierige Auseinandersetzung mit einem Projekt gest√ºrzt haben, an dem mit der VHDL-Sprache und Xilinx-FPGA gearbeitet wird.  Zum einen habe ich deshalb lange Zeit keinen Stift mehr in die Hand genommen, und zum anderen ist klar, dass die Erstellung von praktischen Artikeln eine Vielzahl von Experimenten erfordert.  Es ist etwas schwierig, gleichzeitig mit VHDL / Verilog und Xilinx / Altera umzugehen.  Ein Bruch in den Geschichten √ºber FPGAs m√ºsste also trotzdem gemacht werden. <br><br>  Also  Im <a href="https://habr.com/ru/post/452656/">ersten Artikel der Reihe haben</a> wir bereits das Strukturdiagramm des Redd-Komplexes untersucht.  Lass es uns noch einmal tun. <br><br><img src="https://habrastorage.org/webt/vf/hv/da/vfhvda1kmsax-zkxaue4xu_ysmk.png"><br><br>  In dem heutigen Artikel werden Linux-Experten wahrscheinlich keine wertvollen Informationen finden, aber es lohnt sich, die Bilder oberfl√§chlich zu betrachten.  Diejenigen, die wie ich an die Arbeit mit Windows gew√∂hnt sind, finden eine Liste vorgefertigter Techniken, mit denen Sie mit dem Komplex arbeiten k√∂nnen.  Im Allgemeinen wird dieser Artikel die F√§higkeiten dieser und anderer Lesergruppen auf einen Nenner bringen. <br><br><div class="spoiler">  <b class="spoiler_title">Vorherige Zyklusartikel</b> <div class="spoiler_text"><ol><li>  <a href="https://habr.com/ru/post/452656/">Entwicklung der einfachsten ‚ÄûFirmware‚Äú f√ºr in Redd installierte FPGAs und Debugging am Beispiel des Speichertests.</a> </li><li>  <a href="https://habr.com/ru/post/453682/">Entwicklung der einfachsten "Firmware" f√ºr in Redd installierte FPGAs.</a>  <a href="https://habr.com/ru/post/453682/">Teil 2. Programmcode.</a> </li><li>  <a href="https://habr.com/ru/post/454938/">Entwicklung eines eigenen Kerns zur Einbettung in ein FPGA-basiertes Prozessorsystem.</a> </li><li>  <a href="https://habr.com/ru/post/456008/">Entwicklung von Programmen f√ºr den Zentralprozessor Redd am Beispiel des Zugangs zum FPGA.</a> </li><li>  <a href="https://habr.com/ru/post/462253/">Die ersten Versuche mit dem Streaming-Protokoll am Beispiel der Verbindung von CPU und Prozessor im FPGA des Redd-Komplexes.</a> </li><li>  <a href="https://habr.com/ru/post/464795/">Frohe Quartusel, oder wie der Prozessor zu einem solchen Leben gekommen ist.</a> </li><li>  <a href="https://habr.com/ru/post/467353/">Code-Optimierungsmethoden f√ºr Redd.</a>  <a href="https://habr.com/ru/post/467353/">Teil 1: Cache-Effekt.</a> </li><li>  <a href="https://habr.com/ru/post/468027/">Code-Optimierungsmethoden f√ºr Redd.</a>  <a href="https://habr.com/ru/post/468027/">Teil 2: Nicht zwischengespeicherter Speicher und Parallelbusbetrieb.</a> </li><li>  <a href="https://habr.com/ru/post/469985/">Umfassende Codeoptimierung: Austausch eines Taktgenerators zur Verbesserung der Systemleistung.</a> </li></ol><br></div></div><br><h2>  UART-Bl√∂cke (serielle Ports) </h2><br>  Im Blockdiagramm sehen wir den FT4232-Controller, der 4 serielle Ports (UART) implementiert: <br><br><img src="https://habrastorage.org/webt/75/bh/hy/75bhhyfnu_19uedfnkc7bzyrido.png"><br><br>  Wenn Sie jedoch globaler sprechen, verf√ºgt der Redd-Komplex nicht √ºber vier, sondern √ºber sechs serielle Anschl√ºsse.  Die gerade erw√§hnten vier haben CMOS-Ebenen und zwei weitere sind auf der Hauptplatine verl√∂tet, da der Komplex auf einem normalen PC basiert. <br><br><img src="https://habrastorage.org/webt/14/vj/pl/14vjplsdplqalj4lcm-4g4nmnvg.png"><br><br>  Dementsprechend haben sie Pegel - RS232 (plus oder minus 12 Volt).  RS232-Ports - alles ist klar, sie werden in Form von zwei Standard-DB-9-Anschl√ºssen angezeigt. <br><br><img src="https://habrastorage.org/webt/xk/d0/h6/xkd0h6xvaxlz7gxl8v-r4t9n8de.png"><br><br>  und wo nach Leitungen mit CMOS-Pegeln suchen?  Im Allgemeinen - an einem gemeinsamen Anschluss.  Die Belegung ist im Stromlaufplan dargestellt.  Es gibt unter anderem Kontakte, die UART entsprechen. <br><br><img src="https://habrastorage.org/webt/nm/pv/cr/nmpvcraxowuy0oea7wkin1aqulu.png"><br><br>  √Ñu√üerlich sieht dieser Anschluss folgenderma√üen aus: <br><br><img src="https://habrastorage.org/webt/mf/qa/8h/mfqa8hkbar6y7u8shn39eiend2a.png"><br><br>  Wie man es benutzt, h√§ngt von der jeweiligen Aufgabe ab.  Sie k√∂nnen f√ºr jedes Ger√§t einen Kabelbaum erstellen.  Dieser Ansatz ist n√ºtzlich, wenn jemand den Redd-Komplex verwendet, um regelm√§√üig hergestellte Ger√§te der gleichen Art zu testen.  Der Hauptzweck des Komplexes ist jedoch immer noch das Debuggen der zu entwickelnden Ausr√ºstung.  In diesem Fall ist es einfacher, eine tempor√§re Verbindung herzustellen.  Dieses vor√ºbergehende Muster ist auf Bildschirmschonern f√ºr alle Artikel sichtbar: Aruino-Dr√§hte werden direkt in den Stecker eingef√ºhrt.  Nat√ºrlich ist das Z√§hlen von Kontakten immer noch ein Vergn√ºgen, und wenn sie versehentlich abbrechen, ist es so schwierig, das Umschalten wiederherzustellen, dass es einfacher ist, alles von Grund auf neu zu verbinden.  Um das Leben zu erleichtern, gibt es daher eine Riser-Platine, an die Sie mindestens mit Hilfe von zweireihigen Steckverbindern, mindestens mit derselben Arduino-Verdrahtung, anschlie√üen k√∂nnen. <br><br><img src="https://habrastorage.org/webt/rb/we/66/rbwe66z9f5eahs3efqpxq93di6e.png"><br><br><h2>  UART-Softwarezugriff </h2><br>  Die serielle Schnittstelle ist ein gut etabliertes und standardisiertes Element. Die Arbeit mit ihr erfolgt daher nicht √ºber bestimmte FTDI-Bibliotheken, sondern √ºber Standardverfahren.  Schauen wir uns an, wie diese Tools unter Linux aussehen. <br><br><h4>  Portnamen </h4><br>  Aus einer Reihe von Artikeln und Foren im Netzwerk geht hervor, dass die von USB-Serial-Adaptern bereitgestellten Portnamen im Format / dev / ttyUSB0, / dev / ttyUSB1 usw. vorliegen.  Unter Linux k√∂nnen alle Ger√§te mit denselben Befehlen angezeigt werden wie normale Verzeichnisse (Ger√§te sind n√§mlich dieselben Dateien).  Mal sehen, welche Namen in unserem System sind.  Wir geben den Befehl: <br>  <b>ls / dev /</b> <br><br><img src="https://habrastorage.org/webt/dj/ho/4g/djho4ghfwyceuqy6fjzezh3gyo8.png"><br><br>  Die Namen, die uns interessieren, sind rot hervorgehoben.  Etwas viel von ihnen.  Welcher Port entspricht was?  Wer sich mit Linux auskennt, kennt Tausende von Zauberspr√ºchen f√ºr alle F√§lle.  Aber f√ºr diejenigen, die immer noch mit Windows 3.1 gearbeitet haben (nun ja, parallel zu der damals recht peppigen alten Frau RT-11), ist es immer noch schwer, sich zu erinnern, mit zunehmendem Alter ist es schwieriger, sich an die neue zu erinnern.  Daher ist es auf einfache Weise einfacher, jedes Mal alles zu finden.  Und ich habe den Eingang zu diesem einfachen Pfad mit einem gr√ºnen Rahmen hervorgehoben.  Bedingtes Unterverzeichnis serial.  Jetzt schauen wir uns den Namespace <b>/ dev / an</b> .  Und sehen wir uns das Leerzeichen <b>/ dev / serial an</b> : <br><br><img src="https://habrastorage.org/webt/kw/fc/31/kwfc3189zwxl3ut80xwehvplt70.png"><br><br>  Gro√üartig!  Wir vertiefen uns in die Hierarchie, schauen uns das Leerzeichen <b>/ dev / serial / by-id an</b> .  Wenn Sie nur nach vorne schauen, sage ich, dass Sie f√ºr die korrekte Anzeige den <b>Befehl ls</b> mit der <b>Option ‚Äìl verwenden m√ºssen</b> (danke an meinen Chef f√ºr die Klarstellung).  Das hei√üt, wir geben den Befehl: <br>  <b>ls ‚Äìl / dev / serial / by-id</b> <br><br><img src="https://habrastorage.org/webt/qq/vl/vd/qqvlvdgcgak3c5cembrbmj4myue.png"><br><br>  Einerseits ist alles in Ordnung.  Jetzt wissen wir, welche Namen im Space <b>/ dev / ttyUSBX</b> welchem ‚Äã‚ÄãGer√§t entsprechen.  Von der FT4232 (Quad) Bridge organisierte Ports haben insbesondere Namen von <b>ttyUSB3</b> bis <b>ttyUSB6</b> .  Andererseits habe ich bei der Betrachtung dieser Website festgestellt, dass es in Paris in der Kammer der Gewichte und Ma√üe unbedingt einen Raum geben muss, in dem der Standard des Chaos liegt ... Denn irgendwie muss man in der Lage sein, seinen Wert zu messen.  <b>Nehmen</b> wir an, das Fehlen der Ports <b>/ dev / ttyUSB0</b> und <b>/ dev / ttyUSB1</b> kann leicht erkl√§rt werden.  Aber wie l√§sst sich erkl√§ren, dass die "nativen" Ports, die auf den Nachkommen der installierten FTDI-Bridge basieren, von den ersten drei nummeriert sind und der f√ºr ein bestimmtes Projekt eingef√ºgte Prolific-Controller eines Drittanbieters die Portnummer 2 hat?  Wie kann man in einer solchen Umgebung arbeiten?  Morgen wird jemand einen anderen Controller an den Komplex anschlie√üen (da der Komplex es verschiedenen Entwicklergruppen erm√∂glicht, gleichzeitig mit verschiedenen Ger√§ten zu arbeiten), und die Anschl√ºsse werden wieder freigegeben.  Welche Ports m√ºssen in der Konfigurationsdatei f√ºr eine funktionierende Anwendung registriert werden? <br><br>  Es stellt sich heraus, dass nicht alles so schlimm ist.  Erstens sind der gelbe Name <b>/ dev / ttyUSB3</b> und der blaue Name <b>/ dev / serial / by-id / usb-FTDI_Quad_RS232-HS-if00-port0</b> zwei Aliase desselben Ger√§ts.  Die zweite Option kann auch als Portname angegeben werden, ist aber bereits dauerhafter als die erste.  Es stimmt, in diesem Fall ist alles etwas schlecht.  Ein externer Controller, der auf FT4232 basiert, kann an den Komplex angeschlossen werden, und es ist bereits erforderlich, sich mit deren Nummerierung zu befassen.  Und hier kommt uns "zweitens" zu Hilfe.  N√§mlich eine andere alternative Namenskonvention.  Wir erinnern uns, dass das <b>Verzeichnis / dev / serial</b> nicht nur das Unterverzeichnis <b>/ by-id</b> enthielt, sondern auch das Unterverzeichnis <b>/ by-path</b> .  Wir √ºberpr√ºfen den Inhalt (er befindet sich am unteren Rand der n√§chsten Abbildung unter einer roten Linie). <br><br><img src="https://habrastorage.org/webt/y1/mm/xa/y1mmxabnvjburuzedzirgzusjbm.png"><br><br>  Alles hier ist an die physische Architektur gebunden.  Und ich habe bereits viele Male gesagt, dass alle Controller im Komplex an die Platinen gel√∂tet sind, sodass sich die interne Hierarchie nicht √§ndert.  Daher ist der Name <b>/dev/serial/by-path/pci-0000:00:15.0-usb-0:6.5:1.0-port0</b> der schwierigste. <br><br>  Insgesamt haben wir folgende M√∂glichkeiten, um nach dem Portnamen zu suchen (sollte einmal durchgef√ºhrt werden, die Ergebnisse f√ºr Ihre Instanz des Komplexes k√∂nnen in die Tabelle eingetragen und st√§ndig verwendet werden): <br><br><ol><li>  Geben Sie den Befehl <b>ls ‚Äìl / dev / serial / by-id ein</b> . </li><li>  Geben Sie den <b>Befehl ls ‚Äìl / dev / serial / by-path ein</b> . </li><li>  Suchen Sie aus den Ergebnissen von Punkt 1 den Portnamen, der dem erforderlichen Port der erforderlichen Bridge entspricht.  Suchen Sie den gleichen Anschlussnamen in den Ergebnissen von Absatz 2. Nehmen Sie den physischen Namen, der diesem Absatz entspricht. </li></ol><br>  Bei den Ports, die vom Controller auf dem Motherboard bedient werden, ist alles etwas komplizierter.  Hier k√∂nnen Sie den Weg vom einfachsten Befehl " <b>ls / dev</b> " nicht <b>zur√ºcklegen</b> , aber Sie m√ºssen sich an etwas erinnern (oder zumindest daran, dass Sie sich hier an uns wenden k√∂nnen, um Hilfe zu erhalten).  √úberall hei√üt es, dass die typischen <b>Portnamen ttyS0-ttyS3 sind</b> .  Es bleibt die Frage, auf welchen Namen sich die realen Ports in unserem System befinden.  Ich habe den folgenden Spruch gefunden, der diese Frage beantwortet: <br>  <b>ls / sys / class / tty / * / device / driver</b> <br><br>  Hier ist die Antwort des Systems: <br><br><img src="https://habrastorage.org/webt/oc/gi/v7/ocgiv7g8ffmcmzr_bfypwrn__6g.png"><br><br>  Es stellt sich heraus, dass wir die Namen <b>/ dev / ttyS2</b> und <b>/ dev / ttyS3 verwenden m√ºssen</b> .  Warum - ich wei√ü es nicht.  Eines ist jedoch erfreulich: Hier sind keine besonderen √Ñnderungen vorgesehen, sodass diese Konstanten gespeichert und verwendet werden k√∂nnen, ohne bef√ºrchten zu m√ºssen, dass sie sich √§ndern werden. <br><br><h4>  Code-Entwicklung </h4><br>  Bei der Entwicklung sollten Sie das wunderbare <b>Handbuch zur seriellen Programmierung f√ºr POSIX-Betriebssysteme verwenden</b> (der erste direkte Link, den Sie erhalten, lautet <a href="https://www.cmrr.umn.edu/~strupp/serial.html" rel="nofollow">https://www.cmrr.umn.edu/~strupp/serial.html</a> , aber niemand wei√ü, wie lange es h√§lt).  Es ist besonders wichtig, dass Sie wissen, wie Sie mit einem vollst√§ndigen Satz von Signalen arbeiten, da die Ports im Komplex vollst√§ndig implementiert sind.  Es ist wahr, heute werden wir nur die Tx- und Rx-Leitungen verwenden. <br><br>  Normalerweise gebe ich die Ergebnisse des Oszillogramms an, aber jetzt stellt sich heraus, dass ich mich in einem nahezu realen Zustand befinde: Der Komplex befindet sich dort, wo meine H√§nde nicht reichen, sodass ich den Oszilloskop-Tastkopf nicht anschlie√üen kann.  Um zumindest einige Ergebnisse zu sehen, haben Kollegen auf meine Bitte hin dem Komplex einige Eintr√§ge nach dem folgenden klassischen Schema hinzugef√ºgt: <br><br><img src="https://habrastorage.org/webt/4k/it/be/4kitbevmwnyxbllumfdz0qzr2a0.png"><br><br>  Versuchen wir, von einem Port auf einen anderen zu √ºbertragen.  In unserem Fall sind die Ports <b>/dev/serial/by-path/pci-0000:00:15.0-usb-0:6.5:1.2-port0</b> und <b>/dev/serial/by-path/pci-0000:00:15.0- verbunden usb-0: 6.5: 1.3-port0</b> . <br><br>  Wie Programme f√ºr den Redd-Zentralprozessor geschrieben werden, haben wir bereits in einem der <a href="https://habr.com/ru/post/456008/">vorherigen Artikel</a> besprochen. Deshalb beschr√§nken wir uns heute nur auf den Programmtext, der unter dem Eindruck des Dokuments <b>Serial Programming Guide f√ºr POSIX-Betriebssysteme geschrieben wurde</b> .  Tats√§chlich ist der wichtigste interessante Punkt die Umstellung der Empfangsstrategie auf blockierungsfreies Lesen, der Rest ist trivial.  In Anbetracht der Unordnung in den Beispielen im Netzwerk zu diesem Thema ist es jedoch besser, ein einfaches Beispiel zur Hand zu haben (es wird sp√§ter gezeigt, dass selbst ein Beispiel, das auf diesem wunderbaren Dokument basiert, nicht zu 100% funktioniert hat, der folgende Code unterscheidet sich von den darin beschriebenen Kanonen in einer Zeile, aber mehr dazu weiter unten). <br><br><div class="spoiler">  <b class="spoiler_title">Der gleiche Beispielcode</b> <div class="spoiler_text"><pre><code class="plaintext hljs">#include &lt;cstdio&gt; #include &lt;unistd.h&gt; /* UNIX standard function definitions */ #include &lt;fcntl.h&gt; /* File control definitions */ #include &lt;errno.h&gt; /* Error number definitions */ #include &lt;termios.h&gt; /* POSIX terminal control definitions */ int OpenUART(const char* portName, speed_t baudRate) { //   int fd = open(portName, O_RDWR | O_NOCTTY | O_NDELAY); //     if (fd == -1) { return fd; } //     fcntl(fd, F_SETFL, FNDELAY); //    termios options; tcgetattr(fd, &amp;options); // ,       // ,   .  ... cfsetspeed(&amp;options, baudRate); //    ... // 1  ,   , 8    options.c_cflag &amp;= ~PARENB; options.c_cflag &amp;= ~CSTOPB; options.c_cflag &amp;= ~CSIZE; options.c_cflag |= CS8; options.c_cflag |= (CLOCAL | CREAD); // , ... tcsetattr(fd, TCSANOW, &amp;options); return fd; } int main() { printf("hello from ReddUARTTest!\n"); int fd1 = OpenUART("/dev/serial/by-path/pci-0000:00:15.0-usb-0:6.5:1.3-port0", 9600); int fd2 = OpenUART("/dev/serial/by-path/pci-0000:00:15.0-usb-0:6.5:1.2-port0", 9600); if ((fd1 != -1) &amp;&amp; (fd2 != -1)) { static const unsigned char dataForSend[] = {0xff,0xfe,0xfd,0xfb}; //      write(fd1, dataForSend, sizeof(dataForSend)); unsigned char dataForReceive[128]; ssize_t cnt = 0; //     ,  , //         int readSteps = 0; //      ,   while (cnt &lt; (ssize_t)sizeof(dataForSend)) { readSteps += 1; ssize_t rd = read(fd2, dataForReceive + cnt, sizeof(dataForReceive) - cnt); //   - ,     if (rd &lt;= 0) { usleep(1000); } else //  -   { cnt += rd; } } //   printf("%d read operations\n", readSteps); printf("Read Data: "); for (unsigned int i = 0; i &lt; cnt; i++) { printf("%X ", dataForReceive[i]); } printf("\n"); } else { printf("Error with any port open!\n"); } //   if (fd1 != -1) { close(fd1); } if (fd2 != -1) { close(fd2); } return 0; }</code> </pre> <br></div></div><br>  Laufen - wir erhalten das vorhergesagte Ergebnis: <br><br><pre> <code class="plaintext hljs">hello from ReddUARTTest! 14 read operations Read Data: FF FE FD FB</code> </pre><br>  Es ist ersichtlich, dass 4 Bytes 14 Versuche in Anspruch nahmen, das hei√üt, das Lesen wurde nicht blockiert.  Manchmal gab das System den Status "Keine neuen Daten" zur√ºck und das Programm ging f√ºr eine Millisekunde in den Ruhezustand. <br><br>  Im Allgemeinen ist alles in Ordnung, aber ohne ein Oszilloskop kann ich nicht sicher sein, dass zwei auf demselben Chip basierende Ports die Geschwindigkeit wirklich festlegen.  Ich bin bereits auf die Tatsache gesprungen, dass die Geschwindigkeit die gleiche war (daf√ºr hatte er einen Controller), aber nicht den, den ich bestellt habe.  Lassen Sie uns zumindest irgendwie √ºberpr√ºfen, ob es zumindest kontrolliert wird.  Dazu stelle ich die Geschwindigkeit des Empfangsanschlusses auf das Doppelte der Geschwindigkeit des Sendeanschlusses ein.  Wenn Sie die Physik des Daten√ºbertragungsprozesses kennen, k√∂nnen Sie vorhersagen, wie diese Daten w√§hrend des Empfangs verzerrt werden.  Betrachten wir die √úbertragung des 0xff-Bytes in grafischer Form.  S - Startbit (es gibt immer Null), P - Stopbit (es gibt immer Eins), 0-7 - Datenbits (f√ºr die Konstante 0xFF - alle Einheiten). <br><br><img src="https://habrastorage.org/webt/kx/0p/cz/kx0pczh7nor5fcn1nhkor8nrwum.png"><br><br>  √úberlagern wir diese Ansicht nun mit der Ansicht, wie alles von einem Empf√§nger angezeigt wird, der mit der doppelten Geschwindigkeit arbeitet: <br><br><img src="https://habrastorage.org/webt/mp/n7/qn/mpn7qngefktxruxtyrex7ykrpwk.png"><br><br>  Gro√üartig.  Der Wert "1111 1110" sollte akzeptiert werden (die Daten gehen das niedrigstwertige Bit vorw√§rts), dh 0xFE.  Die zweite H√§lfte des √ºbertragenen Wertes hat keinen Einfluss auf den Empfang, da die Einheiten der Stille in der Leitung entsprechen.  Das hei√üt, wir haben ein Byte √ºbertragen, ein Byte wird auch kommen. <br><br>  Wir werden zur Verifizierung das gleiche Diagramm erstellen, das dem √ºbertragenen 0xFE-Wert entspricht: <br><br><img src="https://habrastorage.org/webt/do/e6/x2/doe6x2t9aapieqiat4gtkp9j8_y.png"><br><br>  Erwarten Sie den Wert "1111 1000" oder 0xF8.  Nun, lassen Sie uns √ºberpr√ºfen, was mit dem √ºbergebenen Wert 0xFD zu erwarten ist: <br><br><img src="https://habrastorage.org/webt/c9/er/d0/c9erd0bsjla_b5bkwpmmzbqnrlm.png"><br><br>  Wir bekommen den Wert 0xE6.  Nun, f√ºr den √ºbertragenen Wert 0xFB erhalten wir den empfangenen 0x9E (Sie k√∂nnen die Grafik zeichnen und selbst sehen).  Gro√üartig!  Wir √§ndern eine einzelne Zeile in der Testanwendung und ersetzen die Geschwindigkeit von 9600 durch 19200: <br><br><pre> <code class="plaintext hljs"> int fd2 = OpenUART("/dev/serial/by-path/pci-0000:00:15.0-usb-0:6.5:1.2-port0", 19200);</code> </pre><br>  Wir fangen an und bekommen dieses Ergebnis der Arbeit: <br><br><pre> <code class="plaintext hljs">hello from ReddUARTTest! 9 read operations Read Data: FE F8 E6 9E</code> </pre><br>  √úbrigens habe ich diese √úberpr√ºfung nicht vergeblich durchgef√ºhrt.  Zuerst habe ich andere Geschwindigkeitseinstellungsfunktionen verwendet (cfsetispeed / cfsetospeed pair) und sie haben nicht funktioniert!  Dank dieses Tests wurde das Problem rechtzeitig erkannt und behoben.  Wenn Sie mit Ger√§ten arbeiten, k√∂nnen Sie nie der Intuition vertrauen.  Alles sollte √ºberpr√ºft werden! <br><br><h4>  Power Line Management 220 Volt </h4><br>  Im Allgemeinen beziehen sich 220-Volt-Stromleitungen nicht auf das Thema des Artikels (FTDI-Br√ºcken), sondern auf das Thema dieses Abschnitts (serielle Schnittstellen).  Werfen wir einen kurzen Blick auf sie. <br><br><img src="https://habrastorage.org/webt/fj/py/1f/fjpy1fqzjfykydgxo28fctebh1c.png"><br><br>  Als wir die Ports aufgelistet haben, sahen wir diesen Namen: <br><br><img src="https://habrastorage.org/webt/rt/0g/k7/rt0gk7ammjno5n1hgfh5waz85ri.png"><br><br>  Dies ist eine virtuelle serielle Schnittstelle.  Es ist so virtuell, dass es keine Rolle spielt, welche Parameter es hat (Portgeschwindigkeit, Anzahl der Bits, Parit√§tsformat usw.).  Egal welche Parameter er eingestellt hat, er wird immer noch perfekt mit Befehlen umgehen k√∂nnen.  Und genau diese Teams steuern die Steckdosen des Komplexes. <br><br><img src="https://habrastorage.org/webt/yc/ry/sk/ycryskkv2xpfkxnex41xbn5pooo.png"><br><br>  Bei der Entwicklung des Befehlssystems wurde beschlossen, auf komplexe Befehlsschnittstellen zu verzichten.  Die Verwaltung ben√∂tigt ein Byte, ohne Framing-Strings und andere Details, obwohl das Byte in Textform vorliegt (damit es beim Debuggen bequem vom Terminal √ºbertragen werden kann).  Diese Pr√§gnanz l√§sst sich leicht erkl√§ren: √úber die String-Schnittstelle k√∂nnen Sie St√∂rungen in einem unsicheren UART-Kanal behandeln.  In unserem Fall l√§uft die Arbeit jedoch physisch √ºber den USB-Kanal, der durch zyklische Steuercodes gesch√ºtzt ist.  Die Verarbeitung des R√ºcklaufs erfordert entweder das Schreiben von zus√§tzlichem Code oder das permanente Leeren von Puffern, was nicht immer praktisch ist.  Deshalb gibt es keine Benchmarks f√ºr Strings, es gibt keine Antworten.  Es wird angenommen, dass der Kanal stabil ist.  Wenn Sie eine Antwort w√ºnschen, k√∂nnen Sie diese explizit anfordern.  Das hei√üt, die Leistung des Blocks kann jederzeit einfach √ºberpr√ºft werden, indem nach dem Befehl ein zus√§tzliches Byte gesendet wird. <br><br>  Betrachten Sie die Befehle, die gesendet werden k√∂nnen: <br><div class="scrollable-table"><table><tbody><tr><th>  Das team </th><th>  Termin </th></tr><tr><td>  'A' </td><td>  Schalten Sie die erste Steckdose ein </td></tr><tr><td>  'a' </td><td>  Schalten Sie die erste Steckdose aus </td></tr><tr><td>  'B' </td><td>  Schalten Sie die zweite Steckdose ein </td></tr><tr><td>  'b' </td><td>  Schalten Sie die zweite Steckdose aus </td></tr><tr><td>  'C' </td><td>  Schalten Sie die dritte Steckdose ein (falls vorhanden) </td></tr><tr><td>  'c' </td><td>  Schalten Sie die dritte Steckdose aus (falls vorhanden) </td></tr><tr><td>  '?' </td><td>  Outlet-Status wiederherstellen </td></tr></tbody></table></div><br>  Der Befehl '?'  (Fragezeichen) ist das einzige, das eine Antwort zur√ºckgibt.  Als Antwort darauf kommen immer 3 Bytes, von denen jedes dem Zustand eines der Ausg√§nge entspricht.  Tats√§chlich entsprechen die Zust√§nde den Befehlen.  Beispiel: 'abc' - alle drei Ausg√§nge sind jetzt ausgeschaltet, 'Abc' - der erste ist eingeschaltet, der zweite und der dritte sind ausgeschaltet usw. <br><br>  F√ºr Experimente mit diesem Subsystem empfehle ich, kein spezielles Programm zu schreiben (es unterscheidet sich nicht von dem oben angegebenen, nur die an die Ports gesendeten Daten sind unterschiedlich), sondern die OS-Tools zu verwenden und interaktiv mit Sockets zu spielen. <br><br>  Nach vielen Experimenten mit dem Verfolgen des Ports √ºber den Befehl cat und dem Senden von Befehlen in einem parallelen Fenster mithilfe des Echoprogramms wurde mir klar, dass ich aus irgendeinem Grund keine Ergebnisse mit zwei putty-basierten ssh-Terminals erzielen kann (auch wenn ich nur mit diesen Ports spiele dass er perfekt mit seinem Programm experimentiert hat).  Daher musste ich das Standard-Minicom-Programm installieren.  Ich erinnere Sie an den Installationsbefehl: <br>  <b>sudo apt-get minicom</b> <br><br>  F√ºhren Sie als N√§chstes den folgenden Befehl aus: <br>  <b>minicom ‚ÄìD / dev / ttyACM0</b> <br><br>  Der Portname ist kurz, da er bei manuellen Experimenten am einfachsten einzugeben ist.  In der Software-Arbeit ist es wie immer besser, einen Namen zu verwenden, der an die Hardware-Hierarchie gebunden ist.  Wieder einmal stelle ich fest, dass ich keine anderen Portparameter konfiguriere, da es virtuell ist.  Es funktioniert mit allen Einstellungen. <br><br>  Dann dr√ºcken wir das Fragezeichen im Terminal und erhalten sofort (ohne Zeilenvorschub) eine Antwort <br><br><img src="https://habrastorage.org/webt/41/my/-j/41my-jjk9cffmmflot_zk_ph0ck.png"><br><br>  Dies bedeutet, dass derzeit alle Steckdosen ausgeschaltet sind.  Nehmen wir an, wir m√∂chten die zweite Steckdose einschalten.  Dr√ºcken Sie die Gro√übuchstabe 'B'.  Es erfolgt keine Reaktion auf dem Bildschirm.  Dr√ºcken Sie '?'. Wieder erhalten wir eine neue Zeile mit der Antwort: <br><br><img src="https://habrastorage.org/webt/5i/uz/-r/5iuz-rrjfbmier5bfmazwx1svb0.png"><br><br>  Alles arbeitet.  Vergessen Sie nicht, 220 Volt auszuschalten (Befehl 'b').  Sie k√∂nnen das Terminal verlassen, indem Sie nacheinander Strg + A und dann X dr√ºcken. Das Experiment ist abgeschlossen. <br><br><h2>  SPI und I <sup>2</sup> C Reifen </h2><br>  SPI-Busse (die auch im Quad-SPI-Modus arbeiten k√∂nnen) und I <sup>2</sup> C werden in Kombination mit Universal Bridges implementiert.  Das hei√üt, der Komplex hat im Allgemeinen zwei Br√ºcken, von denen jede entweder im SPI-Modus oder in I <sup>2</sup> C eingeschaltet werden kann. Im Strukturdiagramm sieht der entsprechende Abschnitt folgenderma√üen aus: <br><br><img src="https://habrastorage.org/webt/uy/lp/6k/uylp6kc6vcqjrlwluk5nxzpcezc.png"><br><br>  Das Wesentliche beim Einschalten der Endbusse ist aus dem elektrischen Schaltplan ersichtlich.  Betrachten Sie nur einen von zwei Controllern: <br><br><img src="https://habrastorage.org/webt/ah/rj/ah/ahrjahvujglcs3uoxl-wsdxfcpy.png"><br><br>  Somit kreuzen sich die SPI- und I <sup>2</sup> C-Busse in keiner Weise.  Einschr√§nkungen f√ºr die gemeinsame Verwendung werden nur durch die von FTDI im FT4222H-Controller auferlegten Einschr√§nkungen bestimmt.  Leider hei√üt es in der Dokumentation, dass immer nur eine Schnittstelle aktiv sein kann: <br><br><img src="https://habrastorage.org/webt/zc/7d/dw/zc7ddwfm-tstpt9lumoydqexceu.png"><br><br>  Wie Sie die Leitungen CFG1_0..CFG1_1 und CFG2_0..CFG2_1 verwalten, erfahren Sie im n√§chsten Artikel.  Jetzt glauben wir, dass sie alle aufgehoben sind. <br><br>  Im Allgemeinen ist die Arbeit mit dem Controller in dem Dokument <b>FT4222H USB2.0 TO QUADSPI / I2C BRIDGE IC</b> sehr gut beschrieben. Daher werden die Funktionen der Betriebsmodi der Controller nicht ber√ºcksichtigt.  Aus dem genannten Dokument geht alles sehr klar hervor. <br><br>  Die Beschreibung des Software-Supports finden Sie im nicht minder bemerkenswerten Dokument <b>AN_329 User Guide For LibFT4222</b> .  Wir haben bereits zweimal mit der FTDI-Br√ºcke gearbeitet: in der zweiten H√§lfte <a href="https://habr.com/ru/post/456008/">dieses Artikels</a> und in der zweiten H√§lfte <a href="https://habr.com/ru/post/462253/">davon</a> .  Wenn Sie dieses Dokument mit diesen Artikeln vergleichen, k√∂nnen Sie es schnell herausfinden und Ihren eigenen Code schreiben.  Lassen Sie mich nur den Referenzcode zeigen, der Daten an den SPI-Bus sendet, ohne auf die Details seiner Implementierung einzugehen. Es sieht schmerzhaft aus, als w√§re er bereits mit FT2232 analysiert worden. <br><br><div class="spoiler">  <b class="spoiler_title">Code, der Daten an den SPI-Bus sendet.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include "../ftd2xx/ftd2xx.h" #include "../LibFT4222/inc/LibFT4222.h" void SpiTest (int pos) { FT_HANDLE ftHandle = NULL; FT_STATUS ftStatus; FT4222_STATUS ft4222Status; //   ftStatus = FT_Open(pos, &amp;ftHandle); if (FT_OK != ftStatus) { // open failed printf ("error: Cannot Open FTDI Device\n"); return; } ft4222Status = FT4222_SPIMaster_Init(ftHandle, SPI_IO_SINGLE, CLK_DIV_4, CLK_IDLE_LOW, CLK_LEADING, 0x01); if (FT4222_OK != ft4222Status) { printf ("error: Cannot switch to SPI Master Mode\n"); // spi master init failed return; } uint8 wrBuf [] = {0x9f,0xff,0xff,0xff,0xff,0xff,0xff}; uint8 rdBuf [sizeof (wrBuf)]; uint16 dwRead; ft4222Status = FT4222_SPIMaster_SingleReadWrite (ftHandle,rdBuf,wrBuf,sizeof (wrBuf),&amp;dwRead,TRUE); if (FT4222_OK != ft4222Status) { printf ("error: Error on ReadWrite\n"); } else { printf ("received: "); for (int i=0;i&lt;6;i++) { printf ("0x%X ",rdBuf[i]); } printf ("\n"); } FT4222_UnInitialize(ftHandle); FT_Close(ftHandle); }</code> </pre><br></div></div><br><h4>  SPI-Bus-Teile </h4><br>  Codeentwickler f√ºr Mikrocontroller verwenden h√§ufig den SPI-Bus als Generator f√ºr eine vorbestimmte Frequenz.  Tats√§chlich h√§ngen rein programmatisch √ºber GPIO-Leitungen erzeugte Impulse von vielen Faktoren ab.  Erstens erfordert das Verzweigen, das Drehen der Schleife, Prozessorzyklen.  Zweitens k√∂nnen Unterbrechungen, DMA und andere unvorhergesehene Faktoren den Prozessor st√∂ren.  SPI ist mehr oder weniger stabil, wissen Sie selbst, wie Sie es schaffen, Bytes in den Puffer zu legen.  Eine typische Anwendung des SPI-Blocks, die keinen direkten Bezug zu diesem SPI selbst hat, ist die Steuerung von RGB-LEDs, f√ºr die die Genauigkeit der Einstellung der Impulsdauer sehr wichtig ist. <br><br>  Leider ist dies f√ºr FTDI-Br√ºcken nicht akzeptabel.  Das obige Codefragment erzeugt diese Impulse auf dem Bus: <br><br><img src="https://habrastorage.org/webt/dv/zx/pe/dvzxpe6cevog4qaklf2zy8tkdye.png"><br><br>  In diesem Fall werden die SPI-Betriebsregeln nicht verletzt, aus Sicht dieses Busses funktioniert alles einwandfrei.  Denken Sie daran, dass auf Controllern √ºbliche kundenspezifische L√∂sungen hier nicht funktionieren.  Es stimmt, der Komplex hat viele freie USB-Anschl√ºsse.  Alle nicht standardm√§√üigen Bl√∂cke k√∂nnen separat entwickelt und mit ihnen verbunden werden. <br><br><h4>  Reifenteile I <sup>2</sup> C </h4><br>  Das einzige, was Sinn macht, ist das Fehlen von Pull-up-Widerst√§nden f√ºr den I <sup>2</sup> C-Bus auf der Seite des Komplexes anzuzeigen.  Das ist aber normal: An der Seite des Arbeitsger√§ts befindet sich noch ein Aufzug.  Heutzutage kann ein Pull-up auf eine beliebige Spannung eingestellt werden, daher ist es logisch, dass es auf dem Zielger√§t eingestellt ist. <br><br><h2>  Fazit </h2><br>  Heute haben wir praktische Kenntnisse in der Arbeit mit Reifen erworben, die von FTDI-Br√ºcken implementiert wurden.  Im Allgemeinen ist die Arbeit mit ihnen Standard, es ist nur so, dass das gesamte Wissen in einem einzigen Artikel zusammengefasst wird, um nicht St√ºck f√ºr St√ºck nach ihnen zu suchen.  Das n√§chste Mal werden wir ein Modul in Betracht ziehen, das nicht standardm√§√üige Ger√§te steuert und auf der Basis des STM32-Controllers implementiert wird.  Im Strukturdiagramm entspricht dieser Abschnitt: <br><br><img src="https://habrastorage.org/webt/ic/w4/9g/icw49gdqjdx26qahasd425ul-sm.png"><br><br>  Aber eigentlich ist dort alles etwas interessanter ... </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477662/">https://habr.com/ru/post/de477662/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477648/index.html">MVCC in PostgreSQL-3. Zeilenversionen</a></li>
<li><a href="../de477650/index.html">Verschl√ºsselung des TLS-Verkehrs nach GOST-2012-Algorithmen mit Stunnel</a></li>
<li><a href="../de477654/index.html">Probieren Sie den verbesserten instanceof-Operator in Java 14 aus</a></li>
<li><a href="../de477656/index.html">Also trotzdem, warum brauchst du make?</a></li>
<li><a href="../de477658/index.html">Active Restore: Kann Disaster Recovery schneller sein? Viel schneller</a></li>
<li><a href="../de477668/index.html">29. November, 18 Uhr - devleads-mitap</a></li>
<li><a href="../de477670/index.html">Was gibt Testautomatisierung</a></li>
<li><a href="../de477672/index.html">Rechte und Pflichten der Teammitglieder: rechtliche und kulturelle Aspekte</a></li>
<li><a href="../de477674/index.html">Bedeutet KI Liebe?</a></li>
<li><a href="../de477678/index.html">Perspektiven f√ºr das digitale Fernsehen in Russland</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>