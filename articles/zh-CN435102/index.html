<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐌 🙍🏽 🔀 关于词法分析的一些知识 💱 👩🏽‍🚀 👸🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="曾几何时，当天空是蓝色时，草变得更绿，恐龙在地球上漫游……不，算了一下恐龙。 好吧，总的来说，很久以前，这个想法浮现在脑海，分散了对标准Web编程的注意力，并做了一些更疯狂的事情。 当然可以，但是选择只能由您自己编写解释器。 我能说什么... 永远不要编写自己的编程语言 。 但是我从这一切中获得了一...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>关于词法分析的一些知识</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435102/"><img src="https://habrastorage.org/webt/93/ob/36/93ob36rkepacsoqhbmlu4bj3g0q.png"><br><br> 曾几何时，当天空是蓝色时，草变得更绿，恐龙在地球上漫游……不，算了一下恐龙。 好吧，总的来说，很久以前，这个想法浮现在脑海，分散了对标准Web编程的注意力，并做了一些更疯狂的事情。 当然可以，但是选择只能由您自己编写解释器。 我能说什么... <i>永远不要编写自己的编程语言</i> 。 但是我从这一切中获得了一些经验，因此我决定分享一下。 让我们从最基础的词法分析器开始。 <br><a name="habracut"></a><br><h2> 前言 </h2><br> 在您开始了解哪种动物“词法分析器”之前，有必要弄清楚YaP的构成。 <br><br> 在现代世界中，每个编译器/解释器/编译器/类似的东西（让我们简称为“编译器”，不区分类型）分为两部分。 在聪明的叔叔的术语中，这些片段称为“前端”和“后端”。 不，这根本不是什么，在使用网络时，我们习惯于调用的内容，并且前端不是用带有HTML的JS编写的。 虽然...好吧。 <br><br> 前端的第一个任务是获取<b>文本</b>并将其转换为<b>AST</b> （抽象语法树），并在途中检查语法（有时还包括语义）。 第二个后端的任务是使其全部正常工作。 如果代码在解释器中汇编，则AST为虚拟处理器（虚拟机）创建一组指令，如果为编译器，则为真实处理器创建一组指令。 在生活中，所有事情都更加复杂，可能无法完全实现。 例如，在使用GCC编译器的情况下，所有东西都混在一起，但是Clang已经规范化了，LLVM是编译器“后端”的典型代表。 <br><br><img src="https://habrastorage.org/webt/un/ai/wa/unaiwa1kmx5jci6uxnhngor5ozs.png"><br><br> 现在，让我们了解一个称为前端的部分。 <br><br><h2> 词法分析 </h2><br> 词法分析器的任务和词法分析的阶段是在入口处获得很多字母，并将它们分为某些类别-“令牌”。 因此，词法分析也称为“令牌化”。 这是每个现有编译器生成的文本处理的第一阶段。 <br><br> 像这样： <br><br><pre><code class="php hljs">$tokens = [<span class="hljs-string"><span class="hljs-string">'class'</span></span>, <span class="hljs-string"><span class="hljs-string">'\w+'</span></span>, <span class="hljs-string"><span class="hljs-string">'}'</span></span>, <span class="hljs-string"><span class="hljs-string">'{'</span></span>]; var_dump(lex(<span class="hljs-string"><span class="hljs-string">'class Example {}'</span></span>, $tokens)); <span class="hljs-comment"><span class="hljs-comment">// array(4) { // [0] =&gt; string(5) "class" // [1] =&gt; string(7) "Example" // [2] =&gt; string(1) "{" // [3] =&gt; string(1) "}" // }</span></span></code> </pre> <br> 顺便说一句，这里我们已经写了很多工具来使生活更轻松。 我们用来解析文本的<i>preg</i>函数完全<i>可以完成</i>此任务。 但是，有更方便的工具可以解决此问题： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Phlexy</a> ，由Nikita Popov撰写。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Hoa</a>是一个包含Lexer + Parser + Grammar的工具包。 </li><li>  Anthony Ferrara编写的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Port Yacc</a> ，这也是一个复杂的工具包，上面编写了著名的Popov <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PHP解析器</a> ，适用于使用代码分析的工具。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Railt Lexer</a>我的PHP 7.1+实现 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Parle</a>是PHP的扩展，它允许一组有限的PCRE表达式（不能提前查找和使用其他语法构造）。 </li><li> 最后，标准的php函数<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">token_get_all</a> ，直接用于PHP的词法分析。 </li></ul><br> 好吧，很明显，有很多小玩意儿可以用记号分隔文本，也许我什至忘了一些东西，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Doctrine</a> lexer。 但是接下来呢？ <br><br><h2> 词法分析器的类型 </h2><br> 和往常一样，一切都不像看起来那么简单。 词法分析器至少有两种不同的类别。 您可以套用规则，这是很琐碎的通常选择，它已经将所有内容划分为令牌。 其配置与我上面显示的示例没有太大不同。 但是，还有另一个选项称为<b>multistate</b> 。 这样的词法分析器有点难以理解，因此，我想再谈一些。 <br><br> 多状态词法分析器的任务是根据先前的状态显示各种标记。 好吧，例如，在PHP中，使用&lt;？Php +？&gt;标签，内部行，注释和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">HEREDOC</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NOWDOC</a>构造来形成这种“过渡”状态。 <br><br> 还记得上面带有4个令牌的示例吗？ 让我们对其进行一些修改以了解这些状态是什么： <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Example</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// class Example {} }</span></span></code> </pre><br> 在这种情况下，如果我们拥有最简单的词法分析器，却不具备PCRE的广泛功能，那么我们将获得以下标记集： <br><br><pre> <code class="php hljs">var_dump(lex(...)); <span class="hljs-comment"><span class="hljs-comment">// array(9) { // [0] =&gt; string(5) "class" // [1] =&gt; string(7) "Example" // [2] =&gt; string(1) "{" // [3] =&gt; string(2) "//" // [4] =&gt; string(5) "class" // [5] =&gt; string(7) "Example" // [6] =&gt; string(1) "{" // [7] =&gt; string(1) "}" // [8] =&gt; string(1) "}" //}</span></span></code> </pre><br> 如您所见，我们对元素3-5的使用完全是平庸的：注释是出乎意料的，并且被分成了标记，尽管它应该被视为一个整体。 <br><br> 当然，借助PCRE功能，可以借助简单的规则“ <i>// [^ \ n] * \ n</i> ”来撕掉这样的令牌，但是如果不是这样的话？ 好吧，还是我们要用手给它加气？ 简而言之，在多状态词法分析器的情况下-我们可以说所有令牌都应该在<b>No1</b>组中，一旦找到“ <i>//</i> ”令牌，就应该过渡到<b>No2</b>组。 在第二组内部，如果找到了标记“ <i>\ n</i> ”，则反向转换-返回到第一组的转换。 <br><br> 像这样： <br><br><pre> <code class="php hljs">$tokens = [ <span class="hljs-string"><span class="hljs-string">'group-1'</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">'class'</span></span>, <span class="hljs-string"><span class="hljs-string">'\w+'</span></span>, <span class="hljs-string"><span class="hljs-string">'{'</span></span>, <span class="hljs-string"><span class="hljs-string">'}'</span></span>, <span class="hljs-string"><span class="hljs-string">'//'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'group-2'</span></span> <span class="hljs-comment"><span class="hljs-comment">//      2 ], 'group-2' =&gt; [ "\n" =&gt; 'group-1', //    1    '.*' ] ];</span></span></code> </pre><br> 我认为现在如何解析某些HEREDOC变得越来越清楚，因为即使具有PCRE的全部功能，鉴于这种HEREDOC语法支持变量插值，编写这种情况的规则仍然非常麻烦。 只需尝试使用内置的<i>token_get_all</i>函数（note&gt; 12 token）来解析这样的内容： <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $example = <span class="hljs-number"><span class="hljs-number">42</span></span>; $a = &lt;&lt;&lt;EOL Your answer is $example !!! EOL; var_dump(token_get_all(file_get_contents(<span class="hljs-keyword"><span class="hljs-keyword">__FILE__</span></span>)));</code> </pre><br> 好吧，看来我们已经准备好开始练习。 <br><br><h2> 练习 </h2><br> 让我们记住在PHP中用于此类事情的东西吗？ 好吧，当然是preg_match！ 好吧，下来 基于preg_match的算法在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Hoa</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">中实现，</a>并<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在Phelxy的此实现中实现</a> 。 它的任务很简单： <br><br><ol><li> 我们手头上有源文本和一系列常规。 </li><li> 我们匹配直到找到合适的东西。 </li><li> 找到一块后，将其从文本中切出并进一步匹配。 </li></ol><br> 在代码形式中，它将看起来像这样： <br><br><div class="spoiler">  <b class="spoiler_title">代码表</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleLexer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array&lt;string&gt; */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $tokens = []; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array&lt;string&gt; $tokens */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $tokens)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($tokens <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $definition) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;tokens[$name] = \sprintf(<span class="hljs-string"><span class="hljs-string">'/\G%s/isSum'</span></span>, $definition); } } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $sources * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> iterable&amp;\Traversable&lt;string&gt; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> RuntimeException */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $sources)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterable</span></span></span><span class="hljs-function"> </span></span>{ [$offset, $length] = [<span class="hljs-number"><span class="hljs-number">0</span></span>, \strlen($sources)]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($offset &lt; $length) { [$name, $token] = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;next($sources, $offset); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $name =&gt; $token; $offset += \strlen($token); } } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $sources * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> int $offset * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> array&lt;string,string&gt; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> RuntimeException */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $sources, int $offset)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;tokens <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $pcre) { \preg_match($pcre, $sources, $matches, <span class="hljs-number"><span class="hljs-number">0</span></span>, $offset); $token = \reset($matches); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (\count($matches) &amp;&amp; \strpos($sources, $token, $offset) === $offset) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [$name, $token]; } } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \RuntimeException(<span class="hljs-string"><span class="hljs-string">'Unrecognized token at offset '</span></span> . $offset); } }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">使用代码表</b> <div class="spoiler_text"><pre> <code class="php hljs">$lexer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleLexer([ <span class="hljs-string"><span class="hljs-string">'T_CLASS'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'class'</span></span>, <span class="hljs-string"><span class="hljs-string">'T_CONST'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'\w+'</span></span>, <span class="hljs-string"><span class="hljs-string">'T_BRACE_OPEN'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'{'</span></span>, <span class="hljs-string"><span class="hljs-string">'T_BRACE_CLOSE'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'}'</span></span>, <span class="hljs-string"><span class="hljs-string">'T_WHITESPACE'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'\s+'</span></span>, ]); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> \sprintf(<span class="hljs-string"><span class="hljs-string">'| %-10s | %-20s |'</span></span>, <span class="hljs-string"><span class="hljs-string">'VALUE'</span></span>, <span class="hljs-string"><span class="hljs-string">'NAME'</span></span>) . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($lexer-&gt;lex(<span class="hljs-string"><span class="hljs-string">'class Example {}'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $token) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> \sprintf(<span class="hljs-string"><span class="hljs-string">'| %-10s | %-20s |'</span></span>, <span class="hljs-string"><span class="hljs-string">'"'</span></span> . \trim($token, <span class="hljs-string"><span class="hljs-string">"\n"</span></span>) . <span class="hljs-string"><span class="hljs-string">'"'</span></span>, $name) . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; }</code> </pre><br></div></div><br> 这种方法非常简单，并且允许几次键盘按下操作来修改next（）方法区域中的词法分析器，从而在状态之间添加过渡并将手淫的这种划分变成原始的多状态词法分析器。 在<i>$ this-&gt;令牌区域中，</i>只需添加类似<i>$ this-&gt;令牌[$ this-&gt; state]的内容</i> 。 <br><br> 但是，除了原始主义本身之外，还有另一个缺点，虽然可能不会致命，但仍然...这样的实现速度非常慢。 在i7 7600k上，我碰巧是它的所有者-一种类似的算法每秒处理大约400个令牌，并且随着它们的变化（即，我们传递给构造函数的定义）的增加，它会减慢俄罗斯更换总统的速度...对不起 当然，我想说的是它将<b>非常缓慢地</b>工作。 <br><br> 好的，我们该怎么办？ 对于初学者，您可以了解问题所在。 事实是，每当我们在该语言的内部使用<b>preg_match时</b> ，带有JIT的编译器PCRE就会出现（在PHP 7.3中，PCRE2已经存在）。 每次他自己解析常客并为他们收集一个解析器时，我们将使用该解析器解析文本以创建标记。 听起来有些奇怪和重言。 但简而言之，每个令牌都需要从1到N个常规编译，其中N是这些令牌的定义数。 同时，值得注意的是，即使应用了“ <i>S</i> ”标志和在构造器中使用“ <i>\ G</i> ”进行优化（生成标记的正则表达式）也无济于事。 <br><br> 摆脱这种情况只有一种方法-您需要一次性解析所有这些文本，即 通过仅执行一个<b>preg_match</b>函数。 仍然需要解决两个问题： <br><br><ol><li> 如何指示正则表达式N1的结果对应于标记N2？ 即 例如，如何指示“ <i>\ w +</i> ”是<i>T_CONST</i> 。 </li><li> 结果如何确定令牌的顺序。 如您所知， <b>preg_match</b>或<b>preg_match_all</b>的结果将包含所有混合的内容。 即使有了作为第四个参数传递的标志的帮助，情况也不会改变。 </li></ol><br> 在这里您可以停下来思考一下。 好吧 <br><br> 第一个问题的解决方案<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">称为PCRE组</a> ，也称为“子掩码”。 使用规则：“ <i>（？&lt;T_WHITESPACE&gt; \ s + | &lt;T_WORD&gt; \ w + | ...）</i> ”通过将它们与它们的名称进行比较，可以一次性获得所有令牌。 匹配的结果将形成一个关联数组，该数组由对<i>[[TOKEN_NAME =&gt; TOKEN_VALUE]]组成</i> 。 <br><br> 第二个比较复杂。 但是，您可以在此处应用战术技巧并使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">preg_replace_callback</a>函数。 它的特殊之处在于，对于每个标记，从第一个到最后一个，将严格按顺序调用作为第二个参数传递的匿名。 <br><br> 为了不使人烦恼，实现如下： <br><br><div class="spoiler">  <b class="spoiler_title">另一段代码</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PregReplaceLexer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array&lt;string&gt; */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $tokens = []; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array&lt;string&gt; $tokens */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $tokens)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($tokens <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $definition) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;tokens[] = \sprintf(<span class="hljs-string"><span class="hljs-string">'(?&lt;%s&gt;%s)'</span></span>, $name, $definition); } } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $sources * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> iterable&amp;\Traversable&lt;string,string&gt; */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $sources)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterable</span></span></span><span class="hljs-function"> </span></span>{ $result = []; \preg_replace_callback(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;compilePcre(), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $matches)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;$result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (\array_reverse($matches) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $value) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (\is_string($name) &amp;&amp; $value !== <span class="hljs-string"><span class="hljs-string">''</span></span>) { $result[] = [$name, $value]; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }, $sources); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($result <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [$name, $value]) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $name =&gt; $value; } } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> string */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compilePcre</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \sprintf(<span class="hljs-string"><span class="hljs-string">'/\G(?:%s)/isSum'</span></span>, \implode(<span class="hljs-string"><span class="hljs-string">'|'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;tokens)); } }</code> </pre><br></div></div><br> 并且它的使用与以前的版本没有什么不同。 同时，工作速度从每秒<b>400个</b>令牌增加到<b>57,000个</b>令牌。 我<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在实现中</a>应用的就是这种算法，它负责重写Hoa源代码。 顺便说一句，如果您使用Parle，则每秒最多可以压缩<b>600,000个</b>令牌。 总体情况如下所示（在PHP 7.1中启用了XDebug，因此数字较低，但是可以大致表示比率）。 <br><br> <a href=""><img src="https://habrastorage.org/webt/rr/yw/qr/rrywqr04hb7lt5zdhdpmu8ppdc8.png"></a> <br><br><ul><li> 黄色是Parle的本机扩展。 </li><li> 蓝色-通过<i>preg_replace_callback</i>使用预组装的常规<i>函数</i>实现。 </li><li> 红色-相同，但在调用<i>preg_replace_callback</i>期间具有生成的<i>规律性</i> 。 </li><li> 绿色-通过<i>preg_match</i>实现。 </li></ul><br><h2> 怎么了 </h2><br> 好吧，所有这些当然是很棒的，但是那些不耐烦的人很想问这个问题：“谁根本需要这个？” 在PHP的抽象世界中，“ fig-fig-and-site-ready”的原则占主导地位-不需要此类库，我们会坦白地说。 但是，如果我们讨论整个生态系统，那么我们可以回想一下臭名昭著的库，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">symfony / yaml</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Doctrine</a> 。  Symfony中的注释与PHP中的子语言相同，需要分别的词汇和语法解析。 此外，甚至还没有多少用PHP编写的知名CoffeeScript，Less和Scss / Sass编译器。 好吧，或者是，并基于它进行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">预处理</a> 。 我什至不会提到像phpmd或phpcs这样的代码分析工具。 而且像phpDocumentnor或Sami这样的文档生成器非常简单。 这些项目中的每个项目在解析文本/代码的第一阶段都采用了词法分析。 <br><br> 这不是一个完整的项目清单，也许我希望我的故事能够帮助您发现新事物并加以补充。 <br><br><h2> 后记 </h2><br> 展望未来，如果有人对解析器和编译器感兴趣，那么会有一些有关此主题的有趣报告，尤其是来自JetBrains的专家： <br><br><div class="spoiler">  <b class="spoiler_title">录影带</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/zI1QmnRRBMA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br> 当然，仍然可以在大量YouTube上找到Andrei Breslav（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">abreslav</a> ）的大部分表演-我建议您观看。 <br><br> 好吧，对于小说迷来说， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有这样一种资源</a>对我个人非常有用。 <br><br> 发布后脚本。 如果您被史诗般的广阔空间所包围，那么您可以安全地以任何方便的方式通知作者。 <br><br> 另外，我想举<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一个简单的PHP词法分析器的示例</a> ，现在看来它并不那么令人恐惧，现在甚至可以清楚地知道它是做什么的，对吗？ 尽管我在欺骗谁，但常客们的眼睛在流血。  =） <br><br> 谢谢你 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN435102/">https://habr.com/ru/post/zh-CN435102/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN435088/index.html">中国流媒体巨头腾讯音乐公开发行股票-这意味着什么，竞争对手应该期待什么</a></li>
<li><a href="../zh-CN435090/index.html">现代汽车集团介绍了无线充电和自动泊车的概念</a></li>
<li><a href="../zh-CN435094/index.html">Sega Mega Drive和Raspberry Pi第2部分的游戏手柄（最终的六个按钮）</a></li>
<li><a href="../zh-CN435096/index.html">暖管收音机的效果</a></li>
<li><a href="../zh-CN435098/index.html">亚行vs间谍cam和麦克风</a></li>
<li><a href="../zh-CN435106/index.html">再说一次passport.js</a></li>
<li><a href="../zh-CN435108/index.html">使用Prolog</a></li>
<li><a href="../zh-CN435112/index.html">企业面试</a></li>
<li><a href="../zh-CN435114/index.html">春季数据JPA</a></li>
<li><a href="../zh-CN435118/index.html">Save File Me-具有客户端加密的免费备份服务</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>