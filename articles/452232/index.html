<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙏🏿 🔄 👧🏿 ObjectRepository: patrón de repositorio en memoria .NET para sus proyectos domésticos 👳 ✏️ 💯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¿Por qué almacenar todos los datos en la memoria? 


 Para almacenar datos del sitio o del servidor, el primer deseo de la mayoría de las personas sen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ObjectRepository: patrón de repositorio en memoria .NET para sus proyectos domésticos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452232/"><h2 id="zachem-hranit-vse-dannye-v-pamyati">  ¿Por qué almacenar todos los datos en la memoria? </h2><br><p>  Para almacenar datos del sitio o del servidor, el primer deseo de la mayoría de las personas sensatas será una base de datos SQL. </p><br><p>  Pero a veces surge la idea de que el modelo de datos no es adecuado para SQL: por ejemplo, al crear una búsqueda o un gráfico social, debe buscar relaciones complejas entre objetos. </p><br><p>  <strong>La peor situación es cuando trabaja en un equipo y un colega no puede generar consultas rápidas.</strong>  <strong>¿Cuánto tiempo pasaste resolviendo problemas de N + 1 y creando índices adicionales para que SELECT en la página principal funcionase en un tiempo razonable?</strong> </p><br><p>  Otro enfoque popular es NoSQL.  Hace unos años hubo una gran expectación sobre este tema: para cualquier oportunidad, implementamos MongoDB y disfrutamos de las respuestas en forma de documentos json <em>(por cierto, ¿cuántas muletas tuvieron que insertarse debido a los enlaces circulares en los documentos?)</em> . </p><br><p>  ¿Por qué no intentar almacenar todos los datos en la memoria de la aplicación, guardándolos periódicamente en un almacenamiento arbitrario (archivo, base de datos remota)? </p><a name="habracut"></a><br><p> La memoria se ha vuelto barata, y cualquier dato posible de la mayoría de los proyectos pequeños y medianos cabe en 1 GB de memoria.  <em>(Por ejemplo, mi proyecto de casa favorito: un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">rastreador financiero</a> que mantiene estadísticas diarias y un historial de mis gastos, saldos y transacciones durante un año y medio, consume solo 45 MB de memoria).</em> </p><br><p>  Pros: </p><br><ul><li>  El acceso a los datos se está volviendo más fácil: no necesita preocuparse por las consultas, la carga diferida, las funciones ORM, trabaje con objetos C # comunes; </li><li>  No hay problemas asociados con el acceso desde diferentes hilos; </li><li>  Muy rápido: sin solicitudes de red, sin traducción de código al lenguaje de consulta, sin (des) serialización de objetos; </li><li>  Está permitido almacenar datos en cualquier forma, al menos en XML en el disco, al menos en SQL Server, al menos en Azure Table Storage. </li></ul><br><p>  Contras: </p><br><ul><li>  Se pierde la escala horizontal y, como resultado, no se puede implementar el tiempo de inactividad cero; </li><li>  Si la aplicación falla, puede perder parcialmente los datos.  <em>(Pero nuestra aplicación nunca falla, ¿verdad?)</em> </li></ul><br><h2 id="kak-eto-rabotaet">  Como funciona </h2><br><p>  El algoritmo es el siguiente: </p><br><ul><li>  Al principio, se establece una conexión con el almacén de datos y se descargan los datos; </li><li>  Se construye un modelo de objetos, índices primarios e índices de relación (1: 1, 1: Muchos); </li><li>  Se crea una suscripción para cambiar las propiedades de los objetos (INotifyPropertyChanged) y para agregar o eliminar elementos de la colección (INotifyCollectionChanged); </li><li>  Cuando se activa la suscripción: el objeto modificado se agrega a la cola para escribir en el almacén de datos; </li><li>  Periódicamente (por temporizador), los cambios en el almacenamiento se almacenan en la secuencia de fondo; </li><li>  Cuando sale de la aplicación, los cambios en el repositorio también se guardan. </li></ul><br><h2 id="primer-koda">  Ejemplo de código </h2><br><div class="spoiler">  <b class="spoiler_title">Agregar las dependencias necesarias</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   Install-Package OutCode.EscapeTeams.ObjectRepository    //  ,      //  ,   . Install-Package OutCode.EscapeTeams.ObjectRepository.File Install-Package OutCode.EscapeTeams.ObjectRepository.LiteDb Install-Package OutCode.EscapeTeams.ObjectRepository.AzureTableStorage    //  -       Hangfire // Install-Package OutCode.EscapeTeams.ObjectRepository.Hangfire</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Describimos el modelo de datos que se almacenará en el repositorio.</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ParentEntity</span></span> : <span class="hljs-title"><span class="hljs-title">BaseEntity</span></span> {  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParentEntity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Guid id</span></span></span><span class="hljs-function">)</span></span> =&gt; Id = id; }  <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ChildEntity</span></span> : <span class="hljs-title"><span class="hljs-title">BaseEntity</span></span> {  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChildEntity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Guid id</span></span></span><span class="hljs-function">)</span></span> =&gt; Id = id;  <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Guid ParentId { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }  <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Entonces el modelo de objeto:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ParentModel</span></span> : <span class="hljs-title"><span class="hljs-title">ModelBase</span></span> {  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParentModel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ParentEntity entity</span></span></span><span class="hljs-function">)</span></span>  {    Entity = entity;  }    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParentModel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>  {    Entity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ParentEntity(Guid.NewGuid());  }    <span class="hljs-comment"><span class="hljs-comment">//   1:Many  public IEnumerable&lt;ChildModel&gt; Children =&gt; Multiple&lt;ChildModel&gt;(x =&gt; x.ParentId);    protected override BaseEntity Entity { get; } }  public class ChildModel : ModelBase {  private ChildEntity _childEntity;    public ChildModel(ChildEntity entity)  {    _childEntity = entity;  }    public ChildModel()  {    _childEntity = new ChildEntity(Guid.NewGuid());  }    public Guid ParentId  {    get =&gt; _childEntity.ParentId;    set =&gt; UpdateProperty(() =&gt; _childEntity.ParentId, value);  }    public string Value  {    get =&gt; _childEntity.Value;    set =&gt; UpdateProperty(() =&gt; _childEntity.Value, value);  }    //       public ParentModel Parent =&gt; Single&lt;ParentModel&gt;(ParentId);    protected override BaseEntity Entity =&gt; _childEntity; }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Y finalmente, la clase del repositorio en sí para acceder a los datos:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyObjectRepository</span></span> : <span class="hljs-title"><span class="hljs-title">ObjectRepositoryBase</span></span> {  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyObjectRepository</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IStorage storage</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">storage, NullLogger.Instance</span></span></span><span class="hljs-function">)</span></span>  {    IsReadOnly = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ,            AddType((ParentEntity x) =&gt; new ParentModel(x));    AddType((ChildEntity x) =&gt; new ChildModel(x));      //   Hangfire       Hangfire  ObjectRepository    // this.RegisterHangfireScheme();      Initialize();  } }</span></span></code> </pre> </div></div><br><p>  Cree una instancia de ObjectRepository: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> memory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MemoryStream(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> db = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LiteDatabase(memory); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dbStorage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LiteDbStorage(db);  <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> repository = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyObjectRepository(dbStorage); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> repository.WaitForInitialize();</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Si el proyecto usará HangFire</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigureServices</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IServiceCollection services, ObjectRepository objectRepository</span></span></span><span class="hljs-function">)</span></span> {  services.AddHangfire(s =&gt; s.UseHangfireStorage(objectRepository)); }</code> </pre> </div></div><br><p>  Insertar un nuevo objeto: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newParent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ParentModel() repository.Add(newParent);</code> </pre> <br><p>  En esta llamada, el objeto <strong>ParentModel se</strong> agrega tanto a la memoria caché local como a la cola de escritura en la base de datos.  Por lo tanto, esta operación toma O (1), y puede trabajar inmediatamente con este objeto. </p><br><p>  Por ejemplo, para encontrar este objeto en el repositorio y asegurarse de que el objeto devuelto sea la misma instancia: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parents = repository.Set&lt;ParentModel&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myParent = parents.Find(newParent.Id); Assert.IsTrue(ReferenceEquals(myParent, newParent));</code> </pre> <br><p>  ¿Qué pasa con esto?  <em>El conjunto &lt;ParentModel&gt; ()</em> devuelve un <em>TableDictionary &lt;ParentModel&gt;</em> , que contiene <em>ConcurrentDictionary &lt;ParentModel, ParentModel&gt;</em> y proporciona funcionalidad adicional para índices primarios y secundarios.  Esto le permite tener métodos para buscar por Id (u otros índices personalizados arbitrarios) sin enumerar por completo todos los objetos. </p><br><p>  Cuando se agregan objetos al <em>ObjectRepository</em> , se agrega una suscripción para cambiar sus propiedades, por lo que cualquier cambio en las propiedades también hace que este objeto se agregue a la cola de escritura. <br>  Actualizar las propiedades desde el exterior tiene el mismo aspecto que trabajar con un objeto POCO: </p><br><pre> <code class="cs hljs">myParent.Children.First().Property = <span class="hljs-string"><span class="hljs-string">"Updated value"</span></span>;</code> </pre> <br><p>  Puede eliminar un objeto de las siguientes maneras: </p><br><pre> <code class="cs hljs">repository.Remove(myParent); repository.RemoveRange(otherParents); repository.Remove&lt;ParentModel&gt;(x =&gt; !x.Children.Any());</code> </pre> <br><p>  Esto también agrega el objeto a la cola de borrado. </p><br><h2 id="kak-rabotaet-sohranenie">  ¿Cómo funciona la conservación? </h2><br><p>  <em>ObjectRepository</em> al cambiar los objetos rastreados (tanto al agregar o quitar como al cambiar propiedades) genera el evento <em>ModelChanged</em> , al que <em>está suscrito IStorage</em> .  Las implementaciones de <em>IStorage,</em> cuando ocurre un evento <em>ModelChanged</em> , <em>resumen</em> los cambios en 3 colas: agregar, actualizar y eliminar. </p><br><p>  Además, las implementaciones de <em>IStorage</em> durante la inicialización crean un temporizador que cada 5 segundos hace que se guarden los cambios. </p><br><p>  <em>Además, hay una API para forzar una llamada de guardado: <strong>ObjectRepository.Save ()</strong> .</em> </p><br><p>  Antes de cada guardado, las primeras operaciones sin sentido se eliminan de las colas (por ejemplo, eventos duplicados, cuando el objeto ha cambiado dos veces o la adición / eliminación rápida de objetos), y solo luego el guardado en sí. </p><br><p>  <em>En todos los casos, se guarda todo el objeto, por lo que es posible que los objetos se guarden en un orden diferente al que se cambiaron, incluidas las versiones más nuevas de los objetos que en el momento de agregarlos a la cola.</em> </p><br><h2 id="chto-est-eschyo">  Que mas hay </h2><br><ul><li>  Todas las bibliotecas están basadas en .NET Standard 2.0.  Se puede usar en cualquier proyecto moderno .NET. </li><li>  La API es segura para subprocesos.  Las colecciones internas se basan en <em>ConcurrentDictionary</em> , los controladores de eventos tienen bloqueos o no los necesitan. <br>  Lo único que debe recordar es llamar a <em>ObjectRepository.Save ();</em> </li><li>  Índices personalizados (requieren unicidad): </li></ul><br><pre> <code class="cs hljs">repository.Set&lt;ChildModel&gt;().AddIndex(x =&gt; x.Value); repository.Set&lt;ChildModel&gt;().Find(x =&gt; x.Value, <span class="hljs-string"><span class="hljs-string">"myValue"</span></span>);</code> </pre> <br><h2 id="kto-eto-ispolzuet">  ¿Quién lo está usando? </h2><br><p>  Personalmente, comencé a usar este enfoque en todos los proyectos de pasatiempos, porque es conveniente y no requiere grandes gastos para escribir una capa de acceso a datos o implementar una infraestructura pesada.  Personalmente, por regla general, almacenar datos en litedb o en un archivo suele ser suficiente para mí. </p><br><p>  Pero en el pasado, cuando EscapeTeams, el inicio tardío, se hizo con el equipo ( <em>pensaban que era dinero, pero no, experiencia otra vez</em> ), usaron Azure Table Storage para almacenar datos. </p><br><h2 id="plany-na-buduschee">  Planes futuros </h2><br><p>  Me gustaría solucionar una de las principales desventajas de este enfoque: el escalado horizontal.  Para hacer esto, necesita transacciones distribuidas (¡sic!), O tomar una decisión decidida de que los mismos datos de diferentes instancias no deberían cambiar, o dejar que cambien de acuerdo con el principio "quién es el último, eso es correcto". </p><br><p>  Desde un punto de vista técnico, veo el siguiente esquema posible: </p><br><ul><li>  Almacene EventLog y Snapshot en lugar del modelo de objeto </li><li>  Encuentre otras instancias (agregue puntos finales de todas las instancias? Descubrimiento de Udp? ¿Maestro / esclavo? A la configuración) </li><li>  Replicar entre instancias EventLog a través de cualquiera de los algoritmos de consenso, como RAFT. </li></ul><br><p>  También hay otro problema que me molesta: la eliminación en cascada o la detección de casos de eliminación de objetos a los que se hace referencia desde otros objetos. </p><br><h2 id="ishodnyy-kod">  Código fuente </h2><br><p>  Si lee hasta aquí, solo queda código por leer, puede ser <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">encontrado en github</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/452232/">https://habr.com/ru/post/452232/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../452222/index.html">Torres telefónicas aeronáuticas, el siguiente paso 5G</a></li>
<li><a href="../452224/index.html">La guía rápida para un desarrollador web</a></li>
<li><a href="../452226/index.html">El titulo sera diferente</a></li>
<li><a href="../452228/index.html">Anna Boyarkina, Miro (anteriormente RealtimeBoard): sobre pensamiento de producto, cultura de equipo, habilidades futuras</a></li>
<li><a href="../452230/index.html">Estudiamos el diodo del túnel en el ejemplo de 3I306M</a></li>
<li><a href="../452234/index.html">Termómetro e higrómetro en ATMEGA 328P-MU: aumento del nivel de desarrollo de Arduino</a></li>
<li><a href="../452236/index.html">Armonía de scripts dentro de la aplicación de Android</a></li>
<li><a href="../452240/index.html">Lo que es común entre el orgasmo y el wifi</a></li>
<li><a href="../452244/index.html">PHPUnit. Gerente de entidad de Doctrina llorona</a></li>
<li><a href="../452246/index.html">Entrevista con Vitaly Bragilevsky: "Un mundo en el que todos programarán en Haskell no es un buen mundo"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>