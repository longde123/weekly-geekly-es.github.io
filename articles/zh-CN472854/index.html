<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👥 👩‍🚀 🔛 Unity UI分析：谁破坏了我的批处理？ 👩🏼‍🍳 👩🏿 🕐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="您花费了无数的时间来优化Unity UI。 但是为了引起抑制，只需对几乎不可见的UI Canvas元素的微小属性进行少量修改即可。 发生这种情况时，即使对Unity UI进行性能分析也无法避免降低FPS。 您准备好解决长时间的错误吗？ 

 这正是我上一个项目中发生的事情... 

 我在Oculu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unity UI分析：谁破坏了我的批处理？</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472854/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/r6/wn/1j/r6wn1jozbycrjiy7ddbrwfkrelm.png"></div><br>  <i>您花费了无数的时间来优化Unity UI。</i>  <i>但是为了引起抑制，只需对几乎不可见的UI Canvas元素的微小属性进行少量修改即可。</i>  <i>发生这种情况时，即使对Unity UI进行性能分析也无法避免降低FPS。</i>  <i>您准备好解决长时间的错误吗？</i> <br><br>  <em>这正是我上一个项目中发生的事情...</em> <br><br> 我在<em>Oculus Quest</em>的游戏端口中努力优化了几个UI面板。 基本上，任务是将透支水平降低到可接受的值，以便GPU可以应对最重要的事情-真实的3D渲染。 <br><br> 因此，我至少花了一个月的时间对Unity UI进行优化，最终还是取得了不错的进展。 <br><br> 在某个时候，UI变得如此优化，以至于几乎不影响GPU时序。 我实现的不透明UI的调光技术弥补了UI分层（在其他元素上方绘制的元素）引起的大多数重绘。 <br><br> 因此，我得到了一个高度优化的混合UI系统，该系统实质上与在其下绘制的3D元素重叠。 丢弃这些重叠片段的呈现变得非常容易。 <br><br>  <em>但是，这项工作还远远没有完成...</em> <br><br> 当我插入<em>Unity UI Profiler时</em> ，一件事引起了我的注意。 <br><br> 我看到过载的CPU在渲染UI的每一帧中花费超过<em>1毫秒</em> 。 对于一个为整个游戏分配<em>13毫秒</em>预算的平台来说，这是很多时间：物理，逻辑，3D渲染，输入，VR和网络代码。 <br><br> 毕竟，在某些情况下，UI甚至会更多地“杀死” CPU性能。 <a name="habracut"></a><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/67c/3ba/b71/67c3bab71f90eccec18cd823ba554ce4.png"></div><br>  <em>Unity UI：昂贵的构建批处理</em> <br><br> 这说明一件事： <strong>可以针对GPU优化UI，但这不一定意味着针对CPU进行了优化</strong> 。 <br><br> 实际上，在渲染Unity UI时，CPU和GPU任务非常不同。 毫不奇怪，我建议以不同的方式进行CPU和GPU优化，这在我之前关于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">Unity UI优化的</a>文章中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">已有</a>讨论。 <br><br> 对Unity UI的进一步分析揭示了一个明显的问题：在每个新框架（即  <strong>画布（Canvas Rebuild）在每个框架中都进行了重建</strong> 。 <br><br>  CPU上的恒定负载为<em>1 ms</em> ...哦，哦。 <br><br>  <em>但是Unity为什么要对我这样做？</em>  <em>我以为Unity会缓存所有的Canvas接口...</em> <br><br> 其实是的。  Unity有效地缓存了Canvas，因此只能收集一次。 <br><br> 但是，当您更改“画布”中任何UI元素的属性-颜色，位置等时，就会出现问题。 <br><br> 就是说，我们喜欢的所有动画，例如，当您将鼠标悬停在鼠标上时，其效果会降低生产力，而您可能不知道这些。 <br><br>  <strong>更改UI属性后，Unity会运行著名的Canvas Rebuild，这会破坏游戏的性能</strong> 。 <br><br> 接口的Canvas Rebuild强制Unity引擎迭代遍历此Canvas的所有UI元素，以生成优化的绘制调用列表（许多顶点，颜色，材质等）。 而Canvas Rebuild所需的时间要比<em>Seat熊猫</em> <em>从零</em>加速<em>到60 mph</em>所需的时间长。 <br><br> 意识到我们一直在遭受Canvas Rebuild的困扰，因此提出一个问题是合乎逻辑的... <br><br>  <em>为什么我们会遭受Canvas Rebuilds的困扰，对此该怎么办？</em> <br><br> 为了回答这个简单的问题，我不得不花费5个多小时来研究该主题并使用<em>Unity UI Profiler</em> 。 <br><br> 让我们做对。 <br><br><h2>  1.对Unity UI进行性能分析：目前一切正常... </h2><br> 假设我们有一个简单的UI。 <br><br> 该用户界面不执行任何操作，仅出现在屏幕上，使尝试通过它查看内容的玩家感到烦恼。 <br><br> 作为“网格布局”组中的350多个图像的集合，它看起来像这样： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd4/426/32a/dd442632a007e73ae8bd5e61a166ccf1.jpg"></div><br>  <em>Unity UI分析示例</em> <br><br> 即使有350多个图像，一切也还是井井有条。 在标准情况下，UI将仅在两个绘制调用中进行渲染，因为其中只有两个唯一的图像不在精灵图集中。 <br><br> 实际上，在分析器中，我可以看到CPU几乎没有负载。 在UI上花费的<em>大部分时间</em>都少于<em>0.01 ms</em> ，这真是太好了。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/946/be0/f2f/946be0f2f42a4374467b4e8ea95d537e.png"></div><br>  <i>Unity UI分析：一个神秘的浪潮</i> <br><br>  <em>（...大部分时间）</em> <br><br>  <em>等一下，图表末尾的CPU资源激增来自何处？</em> <br><br><h2>  2. Unity UI分析：突然的画布重建！ </h2><br>  Unity Profile结束时发生了什么？ 非常奇怪，仅一秒钟，Unity UI上的CPU开销就翻了一番。 <br><br>  <em>我想玩游戏</em> <br><br> 在以下示例中找到两个区别<em>（您可能必须在单独的窗口中打开图像才能看到更好的图像）</em> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd2/836/f9e/dd2836f9e617fe165c546d0644cf62bf.png"></div><br>  <em>Unity UI分析：低成本画布</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df0/d11/69c/df0d1169cff9c9a2e6e76970a1cc9d7c.png"></div><br>  <em>Unity UI分析：画布重建</em> <br><br> 我给你五秒钟的时间来解决。 <br><br>  <em>5，4 ...好吧，这是简化任务的提示：</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f4b/aad/439/f4baad43996f2b73f2f9003523d26e7f.png"></div><br>  <i>Unity UI分析：开销画布重建</i> <br><br>  <em>哇！</em> <br><br>  <code>PostLateUpdate.UpdateRectTransform</code>和<code>UGUI.Rendering.UpdateBatches</code>强烈希望成为该节目的主要明星。 <br><br> 这些区域是做什么的？ <br><br> 第一个是<code>UpdateRectTransform</code> ，它清楚地表明某些对象的变换已更改，因此Unity必须执行昂贵的逻辑以反映视觉变化。 我们不知道它是<code>RectTransform</code>的位置，旋转，比例还是其他某些属性。 <br><br> 地狱，我们甚至都不知道这只是一个属性还是一次。 是单个对象还是多个对象？ 哪一个呢？  <strong>这就是问题：我们不知道</strong> 。 <br><br> 第二个昂贵的片段<code>UpdateBatches</code>与重建整个Canvas几何体的需求有关。 此过程称为“ <em>画布重建”</em> 。 重建Canvas意味着Unity遍历整个Canvas层次结构以生成绘图调用列表。 计算所有元素的顶点，索引，颜色和uv，然后执行传递过程以合并最大可能的绘制调用次数，以减少CPU上的不必要负载，并将其传递给图形驱动程序。 <br><br> 现在，我们似乎知道发生了什么，并且步入正轨。 但是如何避免这种Canvas检修？ 是什么原因造成的？ <br><br> 我们需要更多具体信息... <br><br>  <strong>总结一下</strong> <br><br><ul><li> 更改UI元素中的属性会将元素本身标记为脏 </li><li>  UI元素可以完全脏，但也可以部分脏：顶部脏，布局脏，材料脏。 从部分脏状态恢复比较容易 </li><li> 将任何Canvas元素标记为脏后，Unity会完全重建它 </li><li> 画布重建对于CPU来说是昂贵的，因此要避免的最重要的事情是 </li></ul><br><h2>  3.寻找有害生物：政治上不正确的暴力手段 </h2><br> 我们仍然需要回答以下问题： <br><br>  <em>是什么原因导致这些画布重建？</em> <br><br> 事实证明，找不到<em>快速的</em>方法，特别是对于大型的Canvas层次结构。 <br><br> 但是首先，我将向您展示<strong>一种蛮力方法，以查找Canvas Rebuild的原因</strong> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85c/595/242/85c5952429acc0a55f174400284dcf86.png"></div><br>  <strong>1.让Unity UI Profiler继续记录</strong> <br><br> 我们将筛选指标，以便我们专注于最重要的：渲染，脚本和UI。 <br><br> 跟踪初始标记以了解当前方案的成本，其中应包括昂贵的Canvas Rebuild。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/127/b62/df2/127b62df2a89cb5d6bf94a79883a7547.png"></div><br>  <strong>2.从用户界面停用游戏对象并比较读数</strong> <br><br> 选择游戏对象组并将其停用。 <br><br> 比较性能指标。 <br><br> 如果读数没有太大改善，请继续停用游戏对象，直到看到明显的改善为止。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ae/18c/c17/0ae18cc17731bebb6b83b2a42e99e192.png"></div><br>  <strong>3.找到什么改变了它的属性</strong> <br><br> 我们能够选择调用“画布重建”的对象。 但是，究竟是什么引起了他们的原因？ <br><br> 也许它的规模会随着脚本而改变？ 还是他的位置随着动画而改变？ <br><br> 右键单击<em>RectTransform</em>并选择“ <em>在场景中查找引用</em> ”将非常方便。 <br><br> 当您找出导致Canvas重建的原因时，请对其进行一些处理，例如，关闭动画或变换。 <br><br>  <em>Ruben，但是如何在庞大的UI层次结构中使用此方法？</em>  <em>别跟我说废话</em> <br><br> 我说过这个过程既不会很快也不有趣，但是玩家会感谢您的。 <br><br> 这就是重点。 首先，存在巨大的等级制度不是理想的情况。 如此庞大且深入的层次结构使Canvas Rebuild对CPU而言是如此昂贵。 <br><br> 但是可能会（并且将会）出现大量且嵌套的UI层次结构，因此希望Canvas Rebuild最重要的是游戏性。 <br><br> 尽管蛮力方法有助于找到Canvas大修的根源，但从长远来看，它的伸缩性不好。 <br><br>  <strong>在优化UI方面变得更加专业之后，我创建了一个工具，可以提供所需的所有答案，从而使项目满足玩家的期望</strong> ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16c/8a0/e91/16c8a0e91e1f4289bba8c314eb25562b.png"></div><br>  <em>分析画布重建</em> <br><br><h2>  4.奖金：增强Unity Profiler UI优化功能 </h2><br> 我希望您已经了解Canvas Rebuild的频繁程度和令人不安的情况。 <br><br> 这些感染我的游戏的剧变夺走了整个CPU预算的10％之多！ <br><br> 如我们所见，有一种蛮力方法可以找到Canvas Rebuild源。 也许您可以使用我的有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">优化Unity UI的</a>文章中列出的策略来处理它们。 <br><br> 但是，这种容易出错的过程永远无法满足真正的专家。 您可能需要花几天的时间与Canvas Rebuild进行斗争，但是在最意外的时刻，一旦插入Unity UI Profiler，它们就会消失。 <br><br> 如果您正在开发用于VR的游戏，这将变得至关重要。 我们不希望在世界空间的UI中重建Canvas。 如果您不能摆脱改革，那么您的玩家很可能会忍受不了。 <br><br>  <em>好了，我有了摆脱Canvas Rebuilds的想法。</em>  <em>但是Unity Profiler几乎不提供任何信息！</em>  <em>你有什么建议？</em> <br><br> 很高兴你问。 事实证明， <strong>我们可以说服Unity Profiler向我们提供有关妨碍UI性能的有用信息</strong> 。 <br><br> 我们可以扩展<em>Unity UI Profiler</em>的功能。 为此，您需要修改公共可用的Unity UI源代码。 到达源代码后，您将需要<strong>查找发生Canvas Rebuilds的代码功能</strong> 。 然后，我们需要使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow"><em>BeginSample</em></a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow"><em>EndSample事件</em></a> <em>探查器进行</em> API魔术。 <br><br> 如果您运行的是Unity 2019.1或更早版本，则Unity UI源代码已上传到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">Bitbucket存储库中</a> 。 还有一个用于下载，安装和修改的指南。 <br><br> 我有什么建议？ 使用不低于2019.2.0的更高版本的Unity。  <strong>默认情况下，较新版本的Unity带有源UI</strong> ，因为UI系统现在是程序包管理器的一部分。 这是最轻松的方式。 <br><br> 这是我在研究期间发现的代码清单，可以在其中添加Profiling API调用： <br><br><ul><li>  <em><strong>CanvasUpdateRegistry.cs</strong> ： <a href="" rel="external nofollow"><em>PerformUpdate函数</em></a></em> <br></li><li>  <strong>Graphic.cs</strong> ： <a href="" rel="external nofollow">SetAllDirty</a>函数 <br></li><li>  <strong>Graphic.cs</strong> ：其他功能，例如<a href="" rel="external nofollow">SetVerticesDirty</a> ， <a href="" rel="external nofollow">SetMaterialDirty</a>等。 </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/92c/cfa/f5a/92ccfaf5ad950c1236f2b68c24cc3295.png"></div><br>  <i>Unity UI：分析源</i> <br><br> 有帮助吗？ 是的 <br><br> 对艺术家/设计师来说方便吗？ 不行 <br><br> 是诗人<strong>编写了小型的开源<em>Unity扩展</em> ，扩展了Unity Profiler的功能</strong> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7d/675/185/f7d675185b4e9e2196ef32a0b6362255.png"></div><br> 这个免费的工具将使我们能够在不同的配置模式之间快速切换，以确保最佳的游戏性能。 <br><br> 这个Unity Profiler扩展器的最好之处是什么？ 它可以在编辑器外部运行，从根本上减轻了在为Android和其他平台配置UI时的麻烦。 <br><br> 在这里，它的所有功能仅由两个按钮控制： <br><br><ul><li>  <em>Buff我的Unity Profiler</em> <br></li><li>  <em>Nerf我的Unity Profiler</em> 。 </li></ul><br> 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="external nofollow">在此处</a>获得此工具。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN472854/">https://habr.com/ru/post/zh-CN472854/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN472838/index.html">实际上，在80-90％的情况下，Web应用程序由于前端而变慢：采访Ivan Akulov</a></li>
<li><a href="../zh-CN472840/index.html">软件定义的存储，还是什么杀死了恐龙？</a></li>
<li><a href="../zh-CN472848/index.html">对IT事业的思考</a></li>
<li><a href="../zh-CN472850/index.html">专业还是生命：如果您不害怕，请赢得一门Netology课程</a></li>
<li><a href="../zh-CN472852/index.html">manbetx客户端打不开为云和商业产品的用户做出改变</a></li>
<li><a href="../zh-CN472856/index.html">我如何用桌子和木棍创建质量控制服务</a></li>
<li><a href="../zh-CN472860/index.html">级联缓存无效。 第一部分</a></li>
<li><a href="../zh-CN472864/index.html">检查点：CPU和RAM优化</a></li>
<li><a href="../zh-CN472866/index.html">护身符，保持稳定沟通</a></li>
<li><a href="../zh-CN472868/index.html">电话服务器管理：RUVDS移动客户端</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>