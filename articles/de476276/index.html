<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï∂Ô∏è ‚úàÔ∏è üë∂ Schreiben eines einfachen Balancers auf Go üå≤ üë®‚Äç‚öñÔ∏è ü§¥üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Load Balancer spielen eine Schl√ºsselrolle in der Webarchitektur. Mit ihnen k√∂nnen Sie die Last auf mehrere Backends verteilen und so die Skalierbarkei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schreiben eines einfachen Balancers auf Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/476276/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/t8/nm/ze/t8nmzevaswfyxtitu7xpx3ml-ho.jpeg"></div><br>  Load Balancer spielen eine Schl√ºsselrolle in der Webarchitektur.  Mit ihnen k√∂nnen Sie die Last auf mehrere Backends verteilen und so die Skalierbarkeit verbessern.  Und da wir mehrere Backends konfiguriert haben, wird der Service hoch verf√ºgbar, da der Balancer im Falle eines Ausfalls auf einem Server einen anderen funktionierenden Server ausw√§hlen kann. <br><br>  Nachdem ich mit professionellen Balancern wie NGINX gespielt hatte, versuchte ich, aus Spa√ü einen einfachen Balancer zu erstellen.  Ich habe es auf Go geschrieben, es ist eine moderne Sprache, die volle Parallelit√§t unterst√ºtzt.  Die Standardbibliothek in Go bietet viele Funktionen und erm√∂glicht das Schreiben von Hochleistungsanwendungen mit weniger Code.  Dar√ºber hinaus wird zur Vereinfachung der Verteilung eine einzelne statisch verkn√ºpfte Bin√§rdatei generiert. <br><a name="habracut"></a><br><h2>  Wie unser Balancer funktioniert </h2><br>  Es werden verschiedene Algorithmen verwendet, um die Last auf die Backends zu verteilen.  Zum Beispiel: <br><br><ul><li>  Round Robin - Die Last wird unter Ber√ºcksichtigung der gleichen Rechenleistung der Server gleichm√§√üig verteilt. </li><li>  Weighted Round Robin - Je nach Rechenleistung k√∂nnen Servern unterschiedliche Gewichte zugewiesen werden. </li><li>  Geringste Verbindungen - Die Last wird auf Server mit der geringsten Anzahl aktiver Verbindungen verteilt. </li></ul><br>  In unserem Balancer implementieren wir den einfachsten Algorithmus - Round Robin. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3e/35c/751/b3e35c7510dc44451088756d14739161.png"></div><br><br><h2>  Auswahl bei Round Robin </h2><br>  Der Round Robin-Algorithmus ist einfach.  Es gibt allen Darstellern die gleiche M√∂glichkeit, Aufgaben zu erledigen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b3/4a7/861/3b34a78610b7c1e2d22b85f0419700d2.png"></div><br>  <i>W√§hlen Sie Server in Round Robin aus, um eingehende Anforderungen zu verarbeiten.</i> <br><br>  Wie in der Abbildung gezeigt, w√§hlt der Algorithmus die Server zyklisch in einem Kreis aus.  Aber wir k√∂nnen sie nicht <i>direkt</i> ausw√§hlen, oder? <br><br>  Und wenn der Server l√ºgt?  Wir m√ºssen wahrscheinlich keinen Datenverkehr dorthin senden.  Das hei√üt, der Server kann nicht direkt verwendet werden, bis wir ihn in den gew√ºnschten Zustand versetzt haben.  Es ist erforderlich, den Datenverkehr nur an die Server zu leiten, die in Betrieb sind. <br><br><h2>  Definieren Sie die Struktur </h2><br>  Wir m√ºssen alle Details im Zusammenhang mit dem Backend nachverfolgen.  Sie m√ºssen wissen, ob er lebt, und die URL verfolgen.  Dazu k√∂nnen wir folgende Struktur definieren: <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Backend <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { URL *url.URL Alive <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> mux sync.RWMutex ReverseProxy *httputil.ReverseProxy }</code> </pre> <br>  Keine Sorge, ich erkl√§re die Bedeutung der Felder im Backend. <br><br>  Jetzt m√ºssen Sie im Balancer irgendwie alle Backends verfolgen.  Dazu k√∂nnen Sie Slice und einen variablen Z√§hler verwenden.  Definiere es in ServerPool: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ServerPool <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { backends []*Backend current <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span> }</code> </pre> <br><h2>  Verwenden von ReverseProxy </h2><br>  Wie wir bereits festgestellt haben, besteht das Wesen des Balancers darin, den Datenverkehr auf verschiedene Server zu verteilen und die Ergebnisse an den Client zur√ºckzugeben.  In der Go-Dokumentation hei√üt es: <br><br>  <i>ReverseProxy ist ein HTTP-Handler, der eingehende Anforderungen entgegennimmt und an einen anderen Server sendet und die Antworten an den Client zur√ºcksendet.</i> <br><br>  Genau das, was wir brauchen.  Das Rad muss nicht neu erfunden werden.  Sie k√∂nnen unsere Anfragen einfach √ºber <code>ReverseProxy</code> . <br><br><pre> <code class="go hljs">u, _ := url.Parse(<span class="hljs-string"><span class="hljs-string">"http://localhost:8080"</span></span>) rp := httputil.NewSingleHostReverseProxy(u) <span class="hljs-comment"><span class="hljs-comment">// initialize your server and add this as handler http.HandlerFunc(rp.ServeHTTP)</span></span></code> </pre> <br>  Mit <code>httputil.NewSingleHostReverseProxy(url)</code> Sie <code>ReverseProxy</code> initialisieren, das Anforderungen an die √ºbergebene <code>url</code> sendet.  Im obigen Beispiel wurden alle Anforderungen an localhost: 8080 gesendet und die Ergebnisse an den Client gesendet. <br><br>  Wenn Sie sich die Signatur der ServeHTTP-Methode ansehen, finden Sie die Signatur des HTTP-Handlers darin.  Daher k√∂nnen Sie es in <code>http</code> an <code>HandlerFunc</code> . <br><br>  Weitere Beispiele finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://golang.org/pkg/net/http/">Dokumentation</a> . <br><br>  F√ºr unseren Balancer k√∂nnen Sie <code>ReverseProxy</code> mit der zugeh√∂rigen <code>URL</code> im <code>Backend</code> initiieren, sodass ReverseProxy Anforderungen an die <code>URL</code> weiterleitet. <br><br><h2>  Serverauswahlprozess </h2><br>  Bei der n√§chsten Serverauswahl m√ºssen wir die zugrunde liegenden Server √ºberspringen.  Aber Sie m√ºssen die Z√§hlung organisieren. <br><br>  Zahlreiche Clients stellen eine Verbindung zum Balancer her, und wenn jeder von ihnen den n√§chsten Knoten auffordert, Datenverkehr zu √ºbertragen, kann ein Race Condition auftreten.  Um dies zu verhindern, k√∂nnen wir <code>ServerPool</code> mit <code>mutex</code> blockieren.  Aber es wird redundant sein, au√üerdem wollen wir <code>ServerPool</code> nicht blockieren.  Wir m√ºssen nur den Z√§hler um eins erh√∂hen. <br><br>  Die beste L√∂sung, um diese Anforderungen zu erf√ºllen, w√§re die atomare Inkrementierung.  Go unterst√ºtzt es mit dem <code>atomic</code> Package. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *ServerPool)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextIndex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(atomic.AddUint64(&amp;s.current, <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)) % <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(s.backends))) }</code> </pre> <br>  Wir erh√∂hen den aktuellen Wert atomar um eins und geben den Index zur√ºck, indem wir die L√§nge des Arrays √§ndern.  Dies bedeutet, dass der Wert immer im Bereich von 0 bis zur L√§nge des Arrays liegen sollte.  Letztendlich interessieren wir uns f√ºr einen bestimmten Index, nicht f√ºr den gesamten Z√§hler. <br><br><h2>  Einen Live-Server ausw√§hlen </h2><br>  Wir wissen bereits, dass unsere Anfragen zyklisch √ºber alle Server hinweg rotiert werden.  Und wir m√ºssen nur den Leerlauf √ºberspringen. <br><br>  <code>GetNext()</code> immer einen Wert zwischen 0 und der L√§nge des Arrays zur√ºck.  Wir k√∂nnen jederzeit den n√§chsten Knoten abrufen, und wenn dieser inaktiv ist, m√ºssen wir das Array als Teil der Schleife weiter durchsuchen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c1/7a7/fc5/9c17a7fc56f9bf6c9e4583c29127aa55.png"></div><br>  <i>Wir durchlaufen das Array.</i> <br><br>  Wie in der Abbildung gezeigt, m√∂chten wir vom n√§chsten Knoten zum Ende der Liste gehen.  Dies kann mit <code>next + length</code> .  Um jedoch einen Index auszuw√§hlen, m√ºssen Sie ihn auf die L√§nge des Arrays beschr√§nken.  Dies kann einfach mit der √Ñnderungsoperation durchgef√ºhrt werden. <br><br>  Nachdem wir w√§hrend der Suche einen funktionierenden Server gefunden haben, sollte dieser als aktuell markiert sein: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// GetNextPeer returns next active peer to take a connection func (s *ServerPool) GetNextPeer() *Backend { // loop entire backends to find out an Alive backend next := s.NextIndex() l := len(s.backends) + next // start from next and move a full cycle for i := next; i &lt; l; i++ { idx := i % len(s.backends) // take an index by modding with length // if we have an alive backend, use it and store if its not the original one if s.backends[idx].IsAlive() { if i != next { atomic.StoreUint64(&amp;s.current, uint64(idx)) // mark the current one } return s.backends[idx] } } return nil }</span></span></code> </pre><br><h2>  Vermeidung der Racebedingung in der Backend-Struktur </h2><br>  Hier m√ºssen Sie sich an ein wichtiges Thema erinnern.  Die <code>Backend</code> Struktur enth√§lt eine Variable, die von mehreren Goroutinen gleichzeitig ge√§ndert oder abgefragt werden kann. <br><br>  Wir wissen, dass Goroutinen die Variable mehr lesen als in sie schreiben.  Aus diesem <code>RWMutex</code> wir uns f√ºr <code>RWMutex</code> entschieden, um den Zugriff auf <code>Alive</code> zu serialisieren. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// SetAlive for this backend func (b *Backend) SetAlive(alive bool) { b.mux.Lock() b.Alive = alive b.mux.Unlock() } // IsAlive returns true when backend is alive func (b *Backend) IsAlive() (alive bool) { b.mux.RLock() alive = b.Alive b.mux.RUnlock() return }</span></span></code> </pre><br><h2>  Ausgleichsanforderungen </h2><br>  Nun k√∂nnen wir eine einfache Methode formulieren, um unsere Anforderungen auszugleichen.  Es wird nur fehlschlagen, wenn alle Server ausfallen. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// lb load balances the incoming request func lb(w http.ResponseWriter, r *http.Request) { peer := serverPool.GetNextPeer() if peer != nil { peer.ReverseProxy.ServeHTTP(w, r) return } http.Error(w, "Service not available", http.StatusServiceUnavailable) }</span></span></code> </pre> <br>  Diese Methode kann einfach als <code>HandlerFunc</code> an den HTTP-Server <code>HandlerFunc</code> . <br><br><pre> <code class="go hljs">server := http.Server{ Addr: fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">":%d"</span></span>, port), Handler: http.HandlerFunc(lb), }</code> </pre><br><h2>  Wir leiten den Datenverkehr nur an aktive Server weiter </h2><br>  Unser Balancer hat ein ernstes Problem.  Wir wissen nicht, ob der Server l√§uft.  Um dies herauszufinden, m√ºssen Sie den Server √ºberpr√ºfen.  Hierf√ºr gibt es zwei M√∂glichkeiten: <br><br><ul><li>  Aktiv: Beim Ausf√ºhren der aktuellen Anforderung stellen wir fest, dass der ausgew√§hlte Server nicht antwortet, und markieren ihn als inaktiv. </li><li>  Passiv: Sie k√∂nnen Server in bestimmten Abst√§nden anpingen und den Status √ºberpr√ºfen. </li></ul><br><h2>  Aktive √úberpr√ºfung laufender Server </h2><br>  Wenn ein Fehler <code>ReverseProxy</code> initiiert <code>ErrorHandler</code> die <code>ErrorHandler</code> R√ºckruffunktion.  Dies kann verwendet werden, um Fehler zu erkennen: <br><br><pre> <code class="go hljs">proxy.ErrorHandler = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(writer http.ResponseWriter, request *http.Request, e error)</span></span></span></span> { log.Printf(<span class="hljs-string"><span class="hljs-string">"[%s] %s\n"</span></span>, serverUrl.Host, e.Error()) retries := GetRetryFromContext(request) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> retries &lt; <span class="hljs-number"><span class="hljs-number">3</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> &lt;-time.After(<span class="hljs-number"><span class="hljs-number">10</span></span> * time.Millisecond): ctx := context.WithValue(request.Context(), Retry, retries+<span class="hljs-number"><span class="hljs-number">1</span></span>) proxy.ServeHTTP(writer, request.WithContext(ctx)) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-comment"><span class="hljs-comment">// after 3 retries, mark this backend as down serverPool.MarkBackendStatus(serverUrl, false) // if the same request routing for few attempts with different backends, increase the count attempts := GetAttemptsFromContext(request) log.Printf("%s(%s) Attempting retry %d\n", request.RemoteAddr, request.URL.Path, attempts) ctx := context.WithValue(request.Context(), Attempts, attempts+1) lb(writer, request.WithContext(ctx)) }</span></span></code> </pre> <br>  Bei der Entwicklung dieses Fehlerhandlers haben wir die Funktionen von Closures verwendet.  Dies erm√∂glicht es uns, externe Variablen wie Server-URLs in unserer Methode zu erfassen.  Der Handler √ºberpr√ºft den Wiederholungsz√§hler. Wenn er kleiner als 3 ist, senden wir dieselbe Anforderung erneut an denselben Server.  Dies liegt daran, dass der Server aufgrund vor√ºbergehender Fehler m√∂glicherweise unsere Anforderungen verwirft, diese jedoch bald verf√ºgbar sind (der Server verf√ºgt m√∂glicherweise nicht √ºber freie Sockets f√ºr neue Clients).  Sie m√ºssen also den Verz√∂gerungstimer f√ºr einen neuen Versuch nach ca. 10 ms einstellen.  Mit jeder Anfrage erh√∂hen wir die Anzahl der Versuche. <br><br>  Nach jedem fehlgeschlagenen Versuch markieren wir den Server als inaktiv. <br><br>  Jetzt m√ºssen Sie einen neuen Server f√ºr dieselbe Anforderung zuweisen.  Wir werden dies mit dem Versuchsz√§hler unter Verwendung des <code>context</code> tun.  Nachdem wir die Anzahl der Versuche erh√∂ht haben, √ºbergeben wir sie an <code>lb</code> , um einen neuen Server f√ºr die Verarbeitung der Anforderung auszuw√§hlen. <br><br>  Wir k√∂nnen dies nicht auf unbestimmte Zeit tun, daher werden wir in <code>lb</code> pr√ºfen, ob die maximale Anzahl von Versuchen erreicht wurde, bevor wir mit der Verarbeitung der Anforderung fortfahren. <br><br>  Sie k√∂nnen einfach den Versuchsz√§hler aus der Anfrage abrufen. Wenn er das Maximum erreicht, unterbrechen wir die Anfrage. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// lb load balances the incoming request func lb(w http.ResponseWriter, r *http.Request) { attempts := GetAttemptsFromContext(r) if attempts &gt; 3 { log.Printf("%s(%s) Max attempts reached, terminating\n", r.RemoteAddr, r.URL.Path) http.Error(w, "Service not available", http.StatusServiceUnavailable) return } peer := serverPool.GetNextPeer() if peer != nil { peer.ReverseProxy.ServeHTTP(w, r) return } http.Error(w, "Service not available", http.StatusServiceUnavailable) }</span></span></code> </pre> <br>  Dies ist eine rekursive Implementierung. <br><br><h2>  Verwenden des Kontextpakets </h2><br>  Mit dem <code>context</code> k√∂nnen Sie n√ºtzliche Daten in HTTP-Anforderungen speichern.  Wir werden dies aktiv nutzen, um Daten zu verfolgen, die sich auf Anfragen beziehen - <code>Attempt</code> und <code>Retry</code> . <br><br>  Zun√§chst m√ºssen Sie die Schl√ºssel f√ºr den Kontext festlegen.  Es wird empfohlen, keine Zeichenfolgen, sondern eindeutige numerische Werte zu verwenden.  Go verf√ºgt √ºber ein <code>iota</code> Schl√ºsselwort f√ºr die inkrementelle Implementierung von Konstanten, von denen jede einen eindeutigen Wert enth√§lt.  Dies ist eine gro√üartige L√∂sung zum Definieren von Zifferntasten. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( Attempts <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-literal"><span class="hljs-literal">iota</span></span> Retry )</code> </pre> <br>  Sie k√∂nnen den Wert dann extrahieren, wie wir es normalerweise mit der <code>HashMap</code> tun.  Der Standardwert kann von der aktuellen Situation abh√§ngen. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// GetAttemptsFromContext returns the attempts for request func GetRetryFromContext(r *http.Request) int { if retry, ok := r.Context().Value(Retry).(int); ok { return retry } return 0 }</span></span></code> </pre><br><h2>  Passive Server√ºberpr√ºfung </h2><br>  Passive √úberpr√ºfungen identifizieren und beheben Serverausf√§lle.  Wir rufen sie in einem bestimmten Intervall an, um ihren Status zu bestimmen. <br><br>  Versuchen Sie zum Pingen, eine TCP-Verbindung herzustellen.  Wenn der Server antwortet, wird markiert, dass er funktioniert.  Diese Methode kann angepasst werden, um bestimmte Endpunkte wie <code>/status</code> aufzurufen.  Stellen Sie sicher, dass die Verbindung nach dem Erstellen geschlossen wird, um die zus√§tzliche Belastung des Servers zu verringern.  Andernfalls wird er versuchen, diese Verbindung aufrechtzuerhalten und schlie√ülich seine Ressourcen zu ersch√∂pfen. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// isAlive checks whether a backend is Alive by establishing a TCP connection func isBackendAlive(u *url.URL) bool { timeout := 2 * time.Second conn, err := net.DialTimeout("tcp", u.Host, timeout) if err != nil { log.Println("Site unreachable, error: ", err) return false } _ = conn.Close() // close it, we dont need to maintain this connection return true }</span></span></code> </pre> <br>  Jetzt k√∂nnen Sie die Server durchlaufen und deren Status markieren: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// HealthCheck pings the backends and update the status func (s *ServerPool) HealthCheck() { for _, b := range s.backends { status := "up" alive := isBackendAlive(b.URL) b.SetAlive(alive) if !alive { status = "down" } log.Printf("%s [%s]\n", b.URL, status) } }</span></span></code> </pre> <br>  Um diesen Code regelm√§√üig auszuf√ºhren, k√∂nnen Sie den Timer in Go ausf√ºhren.  Hiermit k√∂nnen Sie Ereignisse im Kanal anh√∂ren. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// healthCheck runs a routine for check status of the backends every 2 mins func healthCheck() { t := time.NewTicker(time.Second * 20) for { select { case &lt;-tC: log.Println("Starting health check...") serverPool.HealthCheck() log.Println("Health check completed") } } }</span></span></code> </pre> <br>  In diesem Code gibt der <code>&lt;-tC</code> Kanal alle 20 Sekunden einen Wert zur√ºck.  <code>select</code> k√∂nnen Sie dieses Ereignis definieren.  Wenn keine <code>default</code> vorliegt, wird gewartet, bis mindestens ein Fall ausgef√ºhrt werden kann. <br><br>  F√ºhren Sie nun den Code in einer separaten Goroutine aus: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> healthCheck()</code> </pre><br><h2>  Fazit </h2><br>  In diesem Artikel haben wir viele Fragen untersucht: <br><br><ul><li>  Round Robin Algorithmus </li><li>  ReverseProxy aus der Standardbibliothek </li><li>  Mutexe </li><li>  Atomare Operationen </li><li>  Kurzschl√ºsse </li><li>  R√ºckrufe </li><li>  Auswahloperation </li></ul><br>  Es gibt viele weitere M√∂glichkeiten, unseren Balancer zu verbessern.  Zum Beispiel: <br><br><ul><li>  Verwenden Sie Heap, um Live-Server zu sortieren und den Suchbereich zu verringern. </li><li>  Statistiken sammeln. </li><li>  Implementieren Sie den gewichteten Round-Robin-Algorithmus mit der geringsten Anzahl von Verbindungen. </li><li>  Unterst√ºtzung f√ºr Konfigurationsdateien hinzuf√ºgen. </li></ul><br>  Usw. <br><br>  Der Quellcode ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de476276/">https://habr.com/ru/post/de476276/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de476264/index.html">Telegrammbot zum Erlernen von Fremdsprachen: Vom Wortballen bis zum Sprechen</a></li>
<li><a href="../de476266/index.html">Praktikum bei Mars Digital Technologies. Wie wir Deep Learning bei M & M angewendet haben</a></li>
<li><a href="../de476268/index.html">L√∂sungen f√ºr das Auffinden von Fehlern, die das PVS-Studio-Team auf Konferenzen in den Jahren 2018-2019 anbietet</a></li>
<li><a href="../de476270/index.html">Unser Won: TopCoder Open 2019</a></li>
<li><a href="../de476272/index.html">Antworten auf Aufgaben vom PVS-Studio-Stand auf Konferenzen 2018-2019</a></li>
<li><a href="../de476278/index.html">BLACK HAT USA Konferenz. Reich werden oder sterben: Mit Black Hat Geld im Internet verdienen. Teil 3</a></li>
<li><a href="../de476280/index.html">Durch Dornen zu DOS: Vier Disketten, die die Welt ver√§nderten</a></li>
<li><a href="../de476284/index.html">Wir formulieren eine Strategie f√ºr die Arbeit mit Fehlern in React</a></li>
<li><a href="../de476286/index.html">Top 5 JS-Frameworks f√ºr die Front-End-Entwicklung im Jahr 2020. Teil 1</a></li>
<li><a href="../de476288/index.html">Top 5 JS-Frameworks f√ºr die Front-End-Entwicklung im Jahr 2020. Teil 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>