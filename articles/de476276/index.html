<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕶️ ✈️ 👶 Schreiben eines einfachen Balancers auf Go 🌲 👨‍⚖️ 🤴🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Load Balancer spielen eine Schlüsselrolle in der Webarchitektur. Mit ihnen können Sie die Last auf mehrere Backends verteilen und so die Skalierbarkei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schreiben eines einfachen Balancers auf Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/476276/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/t8/nm/ze/t8nmzevaswfyxtitu7xpx3ml-ho.jpeg"></div><br>  Load Balancer spielen eine Schlüsselrolle in der Webarchitektur.  Mit ihnen können Sie die Last auf mehrere Backends verteilen und so die Skalierbarkeit verbessern.  Und da wir mehrere Backends konfiguriert haben, wird der Service hoch verfügbar, da der Balancer im Falle eines Ausfalls auf einem Server einen anderen funktionierenden Server auswählen kann. <br><br>  Nachdem ich mit professionellen Balancern wie NGINX gespielt hatte, versuchte ich, aus Spaß einen einfachen Balancer zu erstellen.  Ich habe es auf Go geschrieben, es ist eine moderne Sprache, die volle Parallelität unterstützt.  Die Standardbibliothek in Go bietet viele Funktionen und ermöglicht das Schreiben von Hochleistungsanwendungen mit weniger Code.  Darüber hinaus wird zur Vereinfachung der Verteilung eine einzelne statisch verknüpfte Binärdatei generiert. <br><a name="habracut"></a><br><h2>  Wie unser Balancer funktioniert </h2><br>  Es werden verschiedene Algorithmen verwendet, um die Last auf die Backends zu verteilen.  Zum Beispiel: <br><br><ul><li>  Round Robin - Die Last wird unter Berücksichtigung der gleichen Rechenleistung der Server gleichmäßig verteilt. </li><li>  Weighted Round Robin - Je nach Rechenleistung können Servern unterschiedliche Gewichte zugewiesen werden. </li><li>  Geringste Verbindungen - Die Last wird auf Server mit der geringsten Anzahl aktiver Verbindungen verteilt. </li></ul><br>  In unserem Balancer implementieren wir den einfachsten Algorithmus - Round Robin. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3e/35c/751/b3e35c7510dc44451088756d14739161.png"></div><br><br><h2>  Auswahl bei Round Robin </h2><br>  Der Round Robin-Algorithmus ist einfach.  Es gibt allen Darstellern die gleiche Möglichkeit, Aufgaben zu erledigen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b3/4a7/861/3b34a78610b7c1e2d22b85f0419700d2.png"></div><br>  <i>Wählen Sie Server in Round Robin aus, um eingehende Anforderungen zu verarbeiten.</i> <br><br>  Wie in der Abbildung gezeigt, wählt der Algorithmus die Server zyklisch in einem Kreis aus.  Aber wir können sie nicht <i>direkt</i> auswählen, oder? <br><br>  Und wenn der Server lügt?  Wir müssen wahrscheinlich keinen Datenverkehr dorthin senden.  Das heißt, der Server kann nicht direkt verwendet werden, bis wir ihn in den gewünschten Zustand versetzt haben.  Es ist erforderlich, den Datenverkehr nur an die Server zu leiten, die in Betrieb sind. <br><br><h2>  Definieren Sie die Struktur </h2><br>  Wir müssen alle Details im Zusammenhang mit dem Backend nachverfolgen.  Sie müssen wissen, ob er lebt, und die URL verfolgen.  Dazu können wir folgende Struktur definieren: <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Backend <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { URL *url.URL Alive <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> mux sync.RWMutex ReverseProxy *httputil.ReverseProxy }</code> </pre> <br>  Keine Sorge, ich erkläre die Bedeutung der Felder im Backend. <br><br>  Jetzt müssen Sie im Balancer irgendwie alle Backends verfolgen.  Dazu können Sie Slice und einen variablen Zähler verwenden.  Definiere es in ServerPool: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ServerPool <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { backends []*Backend current <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span> }</code> </pre> <br><h2>  Verwenden von ReverseProxy </h2><br>  Wie wir bereits festgestellt haben, besteht das Wesen des Balancers darin, den Datenverkehr auf verschiedene Server zu verteilen und die Ergebnisse an den Client zurückzugeben.  In der Go-Dokumentation heißt es: <br><br>  <i>ReverseProxy ist ein HTTP-Handler, der eingehende Anforderungen entgegennimmt und an einen anderen Server sendet und die Antworten an den Client zurücksendet.</i> <br><br>  Genau das, was wir brauchen.  Das Rad muss nicht neu erfunden werden.  Sie können unsere Anfragen einfach über <code>ReverseProxy</code> . <br><br><pre> <code class="go hljs">u, _ := url.Parse(<span class="hljs-string"><span class="hljs-string">"http://localhost:8080"</span></span>) rp := httputil.NewSingleHostReverseProxy(u) <span class="hljs-comment"><span class="hljs-comment">// initialize your server and add this as handler http.HandlerFunc(rp.ServeHTTP)</span></span></code> </pre> <br>  Mit <code>httputil.NewSingleHostReverseProxy(url)</code> Sie <code>ReverseProxy</code> initialisieren, das Anforderungen an die übergebene <code>url</code> sendet.  Im obigen Beispiel wurden alle Anforderungen an localhost: 8080 gesendet und die Ergebnisse an den Client gesendet. <br><br>  Wenn Sie sich die Signatur der ServeHTTP-Methode ansehen, finden Sie die Signatur des HTTP-Handlers darin.  Daher können Sie es in <code>http</code> an <code>HandlerFunc</code> . <br><br>  Weitere Beispiele finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://golang.org/pkg/net/http/">Dokumentation</a> . <br><br>  Für unseren Balancer können Sie <code>ReverseProxy</code> mit der zugehörigen <code>URL</code> im <code>Backend</code> initiieren, sodass ReverseProxy Anforderungen an die <code>URL</code> weiterleitet. <br><br><h2>  Serverauswahlprozess </h2><br>  Bei der nächsten Serverauswahl müssen wir die zugrunde liegenden Server überspringen.  Aber Sie müssen die Zählung organisieren. <br><br>  Zahlreiche Clients stellen eine Verbindung zum Balancer her, und wenn jeder von ihnen den nächsten Knoten auffordert, Datenverkehr zu übertragen, kann ein Race Condition auftreten.  Um dies zu verhindern, können wir <code>ServerPool</code> mit <code>mutex</code> blockieren.  Aber es wird redundant sein, außerdem wollen wir <code>ServerPool</code> nicht blockieren.  Wir müssen nur den Zähler um eins erhöhen. <br><br>  Die beste Lösung, um diese Anforderungen zu erfüllen, wäre die atomare Inkrementierung.  Go unterstützt es mit dem <code>atomic</code> Package. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *ServerPool)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextIndex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(atomic.AddUint64(&amp;s.current, <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)) % <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(s.backends))) }</code> </pre> <br>  Wir erhöhen den aktuellen Wert atomar um eins und geben den Index zurück, indem wir die Länge des Arrays ändern.  Dies bedeutet, dass der Wert immer im Bereich von 0 bis zur Länge des Arrays liegen sollte.  Letztendlich interessieren wir uns für einen bestimmten Index, nicht für den gesamten Zähler. <br><br><h2>  Einen Live-Server auswählen </h2><br>  Wir wissen bereits, dass unsere Anfragen zyklisch über alle Server hinweg rotiert werden.  Und wir müssen nur den Leerlauf überspringen. <br><br>  <code>GetNext()</code> immer einen Wert zwischen 0 und der Länge des Arrays zurück.  Wir können jederzeit den nächsten Knoten abrufen, und wenn dieser inaktiv ist, müssen wir das Array als Teil der Schleife weiter durchsuchen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c1/7a7/fc5/9c17a7fc56f9bf6c9e4583c29127aa55.png"></div><br>  <i>Wir durchlaufen das Array.</i> <br><br>  Wie in der Abbildung gezeigt, möchten wir vom nächsten Knoten zum Ende der Liste gehen.  Dies kann mit <code>next + length</code> .  Um jedoch einen Index auszuwählen, müssen Sie ihn auf die Länge des Arrays beschränken.  Dies kann einfach mit der Änderungsoperation durchgeführt werden. <br><br>  Nachdem wir während der Suche einen funktionierenden Server gefunden haben, sollte dieser als aktuell markiert sein: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// GetNextPeer returns next active peer to take a connection func (s *ServerPool) GetNextPeer() *Backend { // loop entire backends to find out an Alive backend next := s.NextIndex() l := len(s.backends) + next // start from next and move a full cycle for i := next; i &lt; l; i++ { idx := i % len(s.backends) // take an index by modding with length // if we have an alive backend, use it and store if its not the original one if s.backends[idx].IsAlive() { if i != next { atomic.StoreUint64(&amp;s.current, uint64(idx)) // mark the current one } return s.backends[idx] } } return nil }</span></span></code> </pre><br><h2>  Vermeidung der Racebedingung in der Backend-Struktur </h2><br>  Hier müssen Sie sich an ein wichtiges Thema erinnern.  Die <code>Backend</code> Struktur enthält eine Variable, die von mehreren Goroutinen gleichzeitig geändert oder abgefragt werden kann. <br><br>  Wir wissen, dass Goroutinen die Variable mehr lesen als in sie schreiben.  Aus diesem <code>RWMutex</code> wir uns für <code>RWMutex</code> entschieden, um den Zugriff auf <code>Alive</code> zu serialisieren. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// SetAlive for this backend func (b *Backend) SetAlive(alive bool) { b.mux.Lock() b.Alive = alive b.mux.Unlock() } // IsAlive returns true when backend is alive func (b *Backend) IsAlive() (alive bool) { b.mux.RLock() alive = b.Alive b.mux.RUnlock() return }</span></span></code> </pre><br><h2>  Ausgleichsanforderungen </h2><br>  Nun können wir eine einfache Methode formulieren, um unsere Anforderungen auszugleichen.  Es wird nur fehlschlagen, wenn alle Server ausfallen. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// lb load balances the incoming request func lb(w http.ResponseWriter, r *http.Request) { peer := serverPool.GetNextPeer() if peer != nil { peer.ReverseProxy.ServeHTTP(w, r) return } http.Error(w, "Service not available", http.StatusServiceUnavailable) }</span></span></code> </pre> <br>  Diese Methode kann einfach als <code>HandlerFunc</code> an den HTTP-Server <code>HandlerFunc</code> . <br><br><pre> <code class="go hljs">server := http.Server{ Addr: fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">":%d"</span></span>, port), Handler: http.HandlerFunc(lb), }</code> </pre><br><h2>  Wir leiten den Datenverkehr nur an aktive Server weiter </h2><br>  Unser Balancer hat ein ernstes Problem.  Wir wissen nicht, ob der Server läuft.  Um dies herauszufinden, müssen Sie den Server überprüfen.  Hierfür gibt es zwei Möglichkeiten: <br><br><ul><li>  Aktiv: Beim Ausführen der aktuellen Anforderung stellen wir fest, dass der ausgewählte Server nicht antwortet, und markieren ihn als inaktiv. </li><li>  Passiv: Sie können Server in bestimmten Abständen anpingen und den Status überprüfen. </li></ul><br><h2>  Aktive Überprüfung laufender Server </h2><br>  Wenn ein Fehler <code>ReverseProxy</code> initiiert <code>ErrorHandler</code> die <code>ErrorHandler</code> Rückruffunktion.  Dies kann verwendet werden, um Fehler zu erkennen: <br><br><pre> <code class="go hljs">proxy.ErrorHandler = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(writer http.ResponseWriter, request *http.Request, e error)</span></span></span></span> { log.Printf(<span class="hljs-string"><span class="hljs-string">"[%s] %s\n"</span></span>, serverUrl.Host, e.Error()) retries := GetRetryFromContext(request) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> retries &lt; <span class="hljs-number"><span class="hljs-number">3</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> &lt;-time.After(<span class="hljs-number"><span class="hljs-number">10</span></span> * time.Millisecond): ctx := context.WithValue(request.Context(), Retry, retries+<span class="hljs-number"><span class="hljs-number">1</span></span>) proxy.ServeHTTP(writer, request.WithContext(ctx)) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-comment"><span class="hljs-comment">// after 3 retries, mark this backend as down serverPool.MarkBackendStatus(serverUrl, false) // if the same request routing for few attempts with different backends, increase the count attempts := GetAttemptsFromContext(request) log.Printf("%s(%s) Attempting retry %d\n", request.RemoteAddr, request.URL.Path, attempts) ctx := context.WithValue(request.Context(), Attempts, attempts+1) lb(writer, request.WithContext(ctx)) }</span></span></code> </pre> <br>  Bei der Entwicklung dieses Fehlerhandlers haben wir die Funktionen von Closures verwendet.  Dies ermöglicht es uns, externe Variablen wie Server-URLs in unserer Methode zu erfassen.  Der Handler überprüft den Wiederholungszähler. Wenn er kleiner als 3 ist, senden wir dieselbe Anforderung erneut an denselben Server.  Dies liegt daran, dass der Server aufgrund vorübergehender Fehler möglicherweise unsere Anforderungen verwirft, diese jedoch bald verfügbar sind (der Server verfügt möglicherweise nicht über freie Sockets für neue Clients).  Sie müssen also den Verzögerungstimer für einen neuen Versuch nach ca. 10 ms einstellen.  Mit jeder Anfrage erhöhen wir die Anzahl der Versuche. <br><br>  Nach jedem fehlgeschlagenen Versuch markieren wir den Server als inaktiv. <br><br>  Jetzt müssen Sie einen neuen Server für dieselbe Anforderung zuweisen.  Wir werden dies mit dem Versuchszähler unter Verwendung des <code>context</code> tun.  Nachdem wir die Anzahl der Versuche erhöht haben, übergeben wir sie an <code>lb</code> , um einen neuen Server für die Verarbeitung der Anforderung auszuwählen. <br><br>  Wir können dies nicht auf unbestimmte Zeit tun, daher werden wir in <code>lb</code> prüfen, ob die maximale Anzahl von Versuchen erreicht wurde, bevor wir mit der Verarbeitung der Anforderung fortfahren. <br><br>  Sie können einfach den Versuchszähler aus der Anfrage abrufen. Wenn er das Maximum erreicht, unterbrechen wir die Anfrage. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// lb load balances the incoming request func lb(w http.ResponseWriter, r *http.Request) { attempts := GetAttemptsFromContext(r) if attempts &gt; 3 { log.Printf("%s(%s) Max attempts reached, terminating\n", r.RemoteAddr, r.URL.Path) http.Error(w, "Service not available", http.StatusServiceUnavailable) return } peer := serverPool.GetNextPeer() if peer != nil { peer.ReverseProxy.ServeHTTP(w, r) return } http.Error(w, "Service not available", http.StatusServiceUnavailable) }</span></span></code> </pre> <br>  Dies ist eine rekursive Implementierung. <br><br><h2>  Verwenden des Kontextpakets </h2><br>  Mit dem <code>context</code> können Sie nützliche Daten in HTTP-Anforderungen speichern.  Wir werden dies aktiv nutzen, um Daten zu verfolgen, die sich auf Anfragen beziehen - <code>Attempt</code> und <code>Retry</code> . <br><br>  Zunächst müssen Sie die Schlüssel für den Kontext festlegen.  Es wird empfohlen, keine Zeichenfolgen, sondern eindeutige numerische Werte zu verwenden.  Go verfügt über ein <code>iota</code> Schlüsselwort für die inkrementelle Implementierung von Konstanten, von denen jede einen eindeutigen Wert enthält.  Dies ist eine großartige Lösung zum Definieren von Zifferntasten. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( Attempts <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-literal"><span class="hljs-literal">iota</span></span> Retry )</code> </pre> <br>  Sie können den Wert dann extrahieren, wie wir es normalerweise mit der <code>HashMap</code> tun.  Der Standardwert kann von der aktuellen Situation abhängen. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// GetAttemptsFromContext returns the attempts for request func GetRetryFromContext(r *http.Request) int { if retry, ok := r.Context().Value(Retry).(int); ok { return retry } return 0 }</span></span></code> </pre><br><h2>  Passive Serverüberprüfung </h2><br>  Passive Überprüfungen identifizieren und beheben Serverausfälle.  Wir rufen sie in einem bestimmten Intervall an, um ihren Status zu bestimmen. <br><br>  Versuchen Sie zum Pingen, eine TCP-Verbindung herzustellen.  Wenn der Server antwortet, wird markiert, dass er funktioniert.  Diese Methode kann angepasst werden, um bestimmte Endpunkte wie <code>/status</code> aufzurufen.  Stellen Sie sicher, dass die Verbindung nach dem Erstellen geschlossen wird, um die zusätzliche Belastung des Servers zu verringern.  Andernfalls wird er versuchen, diese Verbindung aufrechtzuerhalten und schließlich seine Ressourcen zu erschöpfen. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// isAlive checks whether a backend is Alive by establishing a TCP connection func isBackendAlive(u *url.URL) bool { timeout := 2 * time.Second conn, err := net.DialTimeout("tcp", u.Host, timeout) if err != nil { log.Println("Site unreachable, error: ", err) return false } _ = conn.Close() // close it, we dont need to maintain this connection return true }</span></span></code> </pre> <br>  Jetzt können Sie die Server durchlaufen und deren Status markieren: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// HealthCheck pings the backends and update the status func (s *ServerPool) HealthCheck() { for _, b := range s.backends { status := "up" alive := isBackendAlive(b.URL) b.SetAlive(alive) if !alive { status = "down" } log.Printf("%s [%s]\n", b.URL, status) } }</span></span></code> </pre> <br>  Um diesen Code regelmäßig auszuführen, können Sie den Timer in Go ausführen.  Hiermit können Sie Ereignisse im Kanal anhören. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// healthCheck runs a routine for check status of the backends every 2 mins func healthCheck() { t := time.NewTicker(time.Second * 20) for { select { case &lt;-tC: log.Println("Starting health check...") serverPool.HealthCheck() log.Println("Health check completed") } } }</span></span></code> </pre> <br>  In diesem Code gibt der <code>&lt;-tC</code> Kanal alle 20 Sekunden einen Wert zurück.  <code>select</code> können Sie dieses Ereignis definieren.  Wenn keine <code>default</code> vorliegt, wird gewartet, bis mindestens ein Fall ausgeführt werden kann. <br><br>  Führen Sie nun den Code in einer separaten Goroutine aus: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> healthCheck()</code> </pre><br><h2>  Fazit </h2><br>  In diesem Artikel haben wir viele Fragen untersucht: <br><br><ul><li>  Round Robin Algorithmus </li><li>  ReverseProxy aus der Standardbibliothek </li><li>  Mutexe </li><li>  Atomare Operationen </li><li>  Kurzschlüsse </li><li>  Rückrufe </li><li>  Auswahloperation </li></ul><br>  Es gibt viele weitere Möglichkeiten, unseren Balancer zu verbessern.  Zum Beispiel: <br><br><ul><li>  Verwenden Sie Heap, um Live-Server zu sortieren und den Suchbereich zu verringern. </li><li>  Statistiken sammeln. </li><li>  Implementieren Sie den gewichteten Round-Robin-Algorithmus mit der geringsten Anzahl von Verbindungen. </li><li>  Unterstützung für Konfigurationsdateien hinzufügen. </li></ul><br>  Usw. <br><br>  Der Quellcode ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de476276/">https://habr.com/ru/post/de476276/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de476264/index.html">Telegrammbot zum Erlernen von Fremdsprachen: Vom Wortballen bis zum Sprechen</a></li>
<li><a href="../de476266/index.html">Praktikum bei Mars Digital Technologies. Wie wir Deep Learning bei M & M angewendet haben</a></li>
<li><a href="../de476268/index.html">Lösungen für das Auffinden von Fehlern, die das PVS-Studio-Team auf Konferenzen in den Jahren 2018-2019 anbietet</a></li>
<li><a href="../de476270/index.html">Unser Won: TopCoder Open 2019</a></li>
<li><a href="../de476272/index.html">Antworten auf Aufgaben vom PVS-Studio-Stand auf Konferenzen 2018-2019</a></li>
<li><a href="../de476278/index.html">BLACK HAT USA Konferenz. Reich werden oder sterben: Mit Black Hat Geld im Internet verdienen. Teil 3</a></li>
<li><a href="../de476280/index.html">Durch Dornen zu DOS: Vier Disketten, die die Welt veränderten</a></li>
<li><a href="../de476284/index.html">Wir formulieren eine Strategie für die Arbeit mit Fehlern in React</a></li>
<li><a href="../de476286/index.html">Top 5 JS-Frameworks für die Front-End-Entwicklung im Jahr 2020. Teil 1</a></li>
<li><a href="../de476288/index.html">Top 5 JS-Frameworks für die Front-End-Entwicklung im Jahr 2020. Teil 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>