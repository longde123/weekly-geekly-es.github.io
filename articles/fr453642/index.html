<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎂 📢 💻 Analyseur intelligent pour un nombre écrit en mots 👧🏽 👏🏾 🎖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prologue 


 Bonjour, chers lecteurs. Dans cet article, je vais vous expliquer comment analyser un nombre écrit en russe. 


 Intelligent, cet analyse...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyseur intelligent pour un nombre écrit en mots</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453642/"><img src="https://habrastorage.org/webt/x_/al/d2/x_ald2dbs-mrb8gyk1v9z7fzk9w.png"><br><br><h1>  Prologue </h1><br><p>  Bonjour, chers lecteurs.  Dans cet article, je vais vous expliquer comment analyser un nombre écrit en russe. </p><br><p>  Intelligent, cet analyseur permet d'extraire des nombres du texte avec des erreurs commises à la suite d'une saisie incorrecte ou à la suite de la reconnaissance optique du texte d'une image (OCR). </p><br><p>  Pour les paresseux: <br>  Lien vers le projet github: <a href="">lien</a> . </p><br><a name="habracut"></a><br><h1>  De l'algorithme au résultat </h1><br><p>  Cette section décrira les algorithmes utilisés.  Attention, beaucoup de lettres! </p><br><h2>  Énoncé du problème </h2><br><p> Au travail, je dois reconnaître le texte d'un document imprimé photographié avec un appareil photo pour smartphone / tablette.  En raison de l'accord de non-divulgation, je ne peux pas donner d'exemple de photographie, mais le fait est que le document a un tableau dans lequel certains indicateurs sont écrits en chiffres et en mots, et ces données doivent être lues.  L'analyse du texte dans les mots est nécessaire comme outil de validation supplémentaire pour garantir que le numéro est correctement reconnu.  Mais, comme vous le savez, l'OCR ne garantit pas une reconnaissance de texte précise.  Par exemple, le nombre vingt, écrit en mots, peut être reconnu comme «dvupat» ou même comme «dvupat».  Il est nécessaire d'en tenir compte et d'extraire le maximum d'informations, en évaluant l'ampleur de l'erreur possible. </p><br><p>  <b>Remarque</b>  Pour la reconnaissance de texte, j'utilise tesseract 4. Pour .NET, il n'y a pas de package NuGet prêt à l'emploi de la quatrième version, donc j'en ai créé un à partir de la branche principale du projet, qui peut être utile: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Genesis.Tesseract4</a> . </p><br><br><h2>  Algorithme de base d'analyse des nombres </h2><br><p>  Commençons par un simple, à savoir avec un algorithme de reconnaissance de texte écrit en mots, jusqu'à présent sans erreurs.  Si vous êtes intéressé par l'analyse intelligente, ignorez cette section. </p><br><p>  Je ne suis pas particulièrement doué pour la recherche sur Google, donc je n'ai pas immédiatement trouvé d'algorithme prêt à l'emploi pour résoudre ce problème.  Cependant, c'est encore mieux, car  un algorithme inventé par nous-mêmes donne plus de place au codage.  Et la tâche elle-même s'est avérée intéressante. </p><br><p>  Prenons donc un petit nombre, par exemple, «cent vingt-trois».  Il se compose de trois mots ( <i>jetons</i> ), chacun correspondant à un nombre, tous ces nombres se résument: </p><br> <code>"  " =  +  +  = 100 + 20 + 3 = 123</code> <br> <br><p>  Jusqu'à présent, tout est simple, mais nous creusons plus profondément, par exemple, considérons le nombre «deux cent douze mille cent cinq». </p><br> <code>"    " = ( + ) ×  + ( + ) = 212 * 1.000 + 105 = 212.105.</code> <br> <br><p>  Comme vous pouvez le voir, lorsqu'il y a des milliers dans le nombre (ainsi que des millions et d'autres degrés de mille), le nombre est divisé en parties constituées d'un petit nombre local, dans l'exemple ci-dessus - 212, et d'un facteur (1000).  Il peut y avoir plusieurs de ces fragments, mais ils vont tous dans l'ordre décroissant du facteur, par exemple, mille ou mille ne peuvent pas suivre mille.  Cela est également vrai pour des parties d'un petit nombre, car des centaines ne peuvent pas suivre des centaines et des dizaines de dizaines, donc l'entrée «cent cinq cents» est incorrecte.  Nous appellerons une caractéristique qui relie deux jetons du même type un <i>niveau</i> , par exemple, les jetons «cent» et «trois cents» ont un niveau, et il est supérieur au jeton «cinquante». </p><br><p>  De ces considérations naît l'idée d'un algorithme.  Écrivons tous les jetons ( <i>échantillons</i> ) possibles, chacun d'eux assignera un numéro, ainsi que deux paramètres - le niveau et le signe du multiplicateur. </p><br><div class="scrollable-table"><table><tbody><tr><th>  Jeton </th><th>  Numéro </th><th>  Niveau </th><th>  Multiplicateur? </th></tr><tr><td>  zéro <br></td><td>  0 <br></td><td>  1 <br></td><td>  non <br></td></tr><tr><td>  simple / simple <br></td><td>  1 <br></td><td>  1 <br></td><td>  non <br></td></tr><tr><td>  deux / deux <br></td><td>  2 <br></td><td>  1 <br></td><td>  non <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  1 <br></td><td>  non <br></td></tr><tr><td>  dix-neuf <br></td><td>  19 <br></td><td>  1 <br></td><td>  non <br></td></tr><tr><td>  vingt <br></td><td>  20 <br></td><td>  2 <br></td><td>  non <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  2 <br></td><td>  non <br></td></tr><tr><td>  quatre-vingt-dix <br></td><td>  90 <br></td><td>  2 <br></td><td>  non <br></td></tr><tr><td>  cent <br></td><td>  100 <br></td><td>  3 <br></td><td>  non <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  3 <br></td><td>  non <br></td></tr><tr><td>  neuf cents <br></td><td>  900 <br></td><td>  3 <br></td><td>  non <br></td></tr><tr><td>  mille / mille / mille <br></td><td>  1 000 <br></td><td>  4 <br></td><td>  oui <br></td></tr><tr><td>  millions / millions / millions <br></td><td>  1 000 000 <br></td><td>  5 <br></td><td>  oui <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  ... <br></td><td>  oui <br></td></tr><tr><td>  quadrillion / quadrillion / quadrillion <br></td><td>  1 000 000 000 000 000 <br></td><td>  8 <br></td><td>  oui <br></td></tr></tbody></table></div><br><p>  En fait, vous pouvez ajouter d'autres jetons à ce tableau, y compris pour les langues étrangères, mais n'oubliez pas que dans certains pays, un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">système de nommage</a> long plutôt qu'un court <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">est utilisé</a> . </p><br><p>  Passons maintenant à l'analyse.  Nous obtiendrons quatre quantités: </p><br><ol><li>  <i>Niveau global</i> (globalLevel).  Indique le niveau du dernier multiplicateur.  Initialement indéfini et nécessaire pour le contrôle.  Si nous rencontrons un jeton multiplicateur dont le niveau est supérieur ou égal au global, alors c'est une erreur. </li><li>  <i>Valeur globale</i> (globalValue).  Additionneur total, où le résultat est le résultat de la multiplication du nombre et du facteur locaux. </li><li>  <i>Niveau local</i> (localLevel).  Indique le niveau du dernier jeton.  Initialement indéfini, fonctionne de manière similaire au niveau global, mais est réinitialisé après la découverte du multiplicateur. </li><li>  <i>Valeur locale</i> (localValue)  Un additionneur de jeton non multiplicateur, c'est-à-dire  numéros jusqu'à 999. </li></ol><br><p>  L'algorithme est le suivant: </p><br><ol><li>  Divisez la chaîne en jetons en utilisant le régulier "\ s +". </li><li>  Nous prenons le jeton suivant, nous obtenons des informations à ce sujet à partir de l'échantillon. </li><li>  S'il s'agit d'un multiplicateur: <br><ul><li>  Si le niveau global est défini, nous nous assurons qu'il est supérieur ou égal au niveau du jeton.  Sinon, il s'agit d'une erreur; le numéro est incorrect. </li><li>  Définissez le niveau global au niveau du jeton actuel. </li><li>  Multipliez la valeur du jeton par la valeur locale et ajoutez le résultat à la valeur globale. </li><li>  Nous effaçons la valeur et le niveau locaux. </li></ul></li><li>  Si ce n'est pas un multiplicateur: <br><ul><li>  Si le niveau local est défini, nous nous assurons qu'il est supérieur ou égal au niveau du jeton.  Sinon, il s'agit d'une erreur; le numéro est incorrect. </li><li>  Définissez le niveau local au niveau du jeton actuel. </li><li>  Ajoutez la valeur du jeton à la valeur locale. </li></ul></li><li>  Nous renvoyons le résultat comme la somme des valeurs globales et locales. </li></ol><br><p>  Un exemple de travail pour le nombre «deux millions deux cent douze mille cent quatre-vingt-cinq». </p><br><div class="scrollable-table"><table><tbody><tr><th>  Jeton <br></th><th>  globalLevel <br></th><th>  globalValue <br></th><th>  localLevel <br></th><th>  localValue <br></th></tr><tr><td></td><td>  - <br></td><td>  - <br></td><td>  - <br></td><td>  - <br></td></tr><tr><td>  deux <br></td><td>  - <br></td><td>  - <br></td><td>  1 <br></td><td>  2 <br></td></tr><tr><td>  millions <br></td><td>  5 <br></td><td>  2 000 000 <br></td><td>  - <br></td><td>  - <br></td></tr><tr><td>  deux cents <br></td><td>  5 <br></td><td>  2 000 000 <br></td><td>  3 <br></td><td>  200 <br></td></tr><tr><td>  douze <br></td><td>  5 <br></td><td>  2 000 000 <br></td><td>  1 <br></td><td>  212 <br></td></tr><tr><td>  mille <br></td><td>  4 <br></td><td>  2.212.000 <br></td><td>  - <br></td><td>  - <br></td></tr><tr><td>  cent <br></td><td>  4 <br></td><td>  2.212.000 <br></td><td>  3 <br></td><td>  100 <br></td></tr><tr><td>  quatre-vingts <br></td><td>  4 <br></td><td>  2.212.000 <br></td><td>  2 <br></td><td>  180 <br></td></tr><tr><td>  cinq <br></td><td>  4 <br></td><td>  2.212.000 <br></td><td>  1 <br></td><td>  185 <br></td></tr></tbody></table></div><p>  Le résultat sera le 2.212.185. </p><br><h2>  Analyse intelligente </h2><br><p>  Cet algorithme peut être utilisé pour implémenter d'autres comparaisons, et pas seulement pour l'analyse des nombres, c'est pourquoi je vais essayer de le décrire plus en détail. </p><br><p>  Avec l'analyse du nombre correctement écrit compris.  Réfléchissons maintenant aux erreurs qui peuvent se produire si le nombre obtenu à la suite de l'OCR est mal écrit.  Je ne considère pas d'autres options, mais vous pouvez modifier l'algorithme pour une tâche spécifique. </p><br><p>  J'ai identifié trois types d'erreurs que j'ai rencontrées au cours du travail: </p><br><ol><li>  Remplacez les caractères par d'autres avec un style similaire.  Par exemple, la lettre «c» est pour une raison quelconque remplacée par «p», et «n» par «et» et vice versa.  Lorsque vous utilisez la troisième version de tesseract, il est possible de remplacer la lettre «o» par zéro.  Ces erreurs sont les plus courantes et nécessitent un réglage pour une bibliothèque de reconnaissance spécifique.  Ainsi, les principes de fonctionnement des versions 3 et 4 de tesseract ont des différences cardinales, donc les erreurs y seront différentes. <br></li><li>  Fusion de jetons.  Les mots peuvent fusionner (n'ont pas encore rencontré le contraire).  En combinaison avec la première erreur, il génère des phrases démoniaques telles que "double one".  Essayons également de diaboliser ces monstres. <br></li><li>  Bruit - caractères et phrases laissés dans le texte.  Malheureusement, il n'y a pas grand-chose à faire pour le moment, mais il existe une perspective pour la collecte de statistiques suffisamment importantes. <br></li></ol><br><p>  Dans le même temps, l'algorithme d'analyse décrit ci-dessus ne change presque pas, la principale différence est de diviser la chaîne en jetons. </p><br><p>  Mais commençons par collecter des statistiques sur l'utilisation des lettres dans les jetons.  Sur les 33 lettres de la langue russe, seulement 20 sont utilisées lors de l'écriture d'entiers non négatifs, appelons-les de <i>bonnes lettres</i> : </p><br> <code></code> <br> <br><p>  Les 13 autres, respectivement, seront appelés <i>mauvaises lettres</i> .  La taille maximale du jeton est de 12 caractères (13 en comptant pour le quadrillion).  Les sous-chaînes plus longues que cette valeur doivent être divisées. </p><br><p>  Pour comparer les chaînes et les jetons, j'ai décidé d'utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'algorithme de Wagner-Fisher</a> , bien que je l'appelle le nom de Levenshtein dans le code.  Je n'ai pas besoin d'instructions éditoriales, j'ai donc implémenté une version mémoire de l'algorithme.  Je dois admettre que la mise en œuvre de cet algorithme s'est avérée être une tâche plus difficile que l'analyseur lui-même. </p><br><p>  Un petit programme éducatif: la distance Levenshtein est un cas particulier de l'algorithme de Wagner-Fisher, lorsque le coût d'insertion, de suppression et de remplacement de caractères est statique.  Ce n'est pas le cas dans notre tâche.  Évidemment, si nous trouvons une mauvaise lettre dans une sous-chaîne, alors elle doit être remplacée par une bonne lettre, mais remplacer un bon par une mauvaise est extrêmement indésirable.  D'une manière générale, c'est impossible, mais la situation dépend de la tâche spécifique. </p><br><p>  Pour décrire le coût d'insertion, de suppression et de remplacement de caractères, j'ai créé un tableau comme celui-ci: un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien vers un tableau avec des poids</a> .  Bien qu'il soit rempli avec la méthode des trois P (sexe, doigt, plafond), mais si vous le remplissez avec des données basées sur les statistiques OCR, vous pouvez améliorer considérablement la qualité de la reconnaissance des nombres.  Le code de bibliothèque contient le fichier de ressources NumeralLevenshteinData.txt, dans lequel vous pouvez insérer des données d'une table similaire à l'aide de Ctrl + A, Ctrl + C et Ctrl + V. </p><br><p>  Si un caractère non-table est trouvé dans le texte, par exemple zéro, le coût de son insertion est égal à la valeur maximale de la table, et le coût de la suppression et du remplacement est égal au minimum, donc l'algorithme est plus susceptible de remplacer zéro par la lettre «o», et si vous utilisez la troisième version de tesseract , il est alors logique d'ajouter zéro au tableau et d'écrire le prix minimum pour le remplacer par la lettre «o». </p><br><p>  Nous avons donc préparé les données pour l'algorithme de Wagner-Fisher, apportons des modifications à l'algorithme pour diviser la chaîne en jetons.  Pour ce faire, nous effectuerons une analyse supplémentaire de chaque jeton, mais avant cela, nous développerons les informations sur le jeton avec les caractéristiques suivantes: </p><br><ul><li>  <i>Niveau d'erreur</i> .  Un nombre réel de 0 (pas d'erreur) à 1 (le jeton est incorrect), ce qui signifie à quel point le jeton a été comparé à l'échantillon. <br></li><li>  <i>Un signe d'utilisation d'un jeton</i> .  Lors de l'analyse d'une chaîne avec des débris entrecoupés, une partie des jetons sera rejetée, car cet attribut ne sera pas défini.  Dans ce cas, la valeur d'erreur totale sera considérée comme la moyenne arithmétique des erreurs des jetons utilisés. <br></li></ul><br><p>  Algorithme d'analyse de jeton: </p><br><ol><li>  Nous essayons de trouver le jeton dans le tableau tel quel.  Si nous trouvons - tout va bien, retournez-le. </li><li>  Sinon, faites une liste des options possibles: </li><li><p>  Nous essayons de faire correspondre le jeton avec l'échantillon en utilisant l'algorithme de Wagner-Fisher.  Cette option se compose d'un jeton (échantillon mappé) et son erreur est égale à la meilleure distance divisée par la longueur de l'échantillon. </p><br>  <b>Exemple: le</b> jeton «zéro» est comparé à l'échantillon «zéro», tandis que la distance est de 0,5, car  le coût de remplacement de la mauvaise lettre «y» par un bon «o» est de 0,5.  L'erreur totale pour ce jeton sera de 0,5 / 4 = 0,125. <br></li><li><p>  Si la sous-chaîne est suffisamment grande (j'ai 6 caractères), nous essayons de la diviser en deux parties d'au moins 3 caractères chacune.  Pour une chaîne de 6 caractères, il y aura une seule division: 3 + 3 caractères.  Pour une chaîne de 7 caractères - il y a déjà deux options, 3 + 4 et 4 + 3, etc.  Pour chacune des options, nous appelons récursivement la même fonction d'analyse de jeton, nous entrons les options reçues dans la liste. </p><br><p>  Afin de ne pas mourir en récurrence, nous déterminons le niveau maximum d'échec.  En outre, les options obtenues à la suite de la division sont artificiellement dégradées d'un certain montant (option, par défaut 0,1), de sorte que l'option de comparaison directe a plus de valeur.  J'ai dû ajouter cette opération, car  les sous-étapes du type "double" ont été divisées avec succès en jetons "deux" et "cinq", et n'ont pas été réduites à "vingt".  Hélas, ce sont les caractéristiques de la langue russe. </p><br><p>  <b>Exemple: le</b> jeton «double» a une comparaison directe avec l'échantillon «vingt», erreur 0,25.  De plus, la meilleure option pour diviser est «deux» + «cinq» avec un coût de 0,25 (en remplaçant «a» par «i»), aggravé artificiellement à 0,35, ce qui fait que le jeton «vingt» est préféré. </p><br></li><li>  Après avoir compilé toutes les options, nous sélectionnons la meilleure par le minimum d'erreurs des jetons qui y participent.  Le résultat est renvoyé. </li></ol><br><p>  De plus, la vérification des jetons est introduite dans l'algorithme de génération de nombres principal afin que leur erreur ne dépasse pas une certaine valeur (option, par défaut 0,67).  Avec cela, nous éliminons les déchets potentiels, mais pas avec beaucoup de succès. </p><br><h2>  L'algorithme en bref pour ceux qui étaient trop paresseux pour lire le texte ci-dessus </h2><br><p>  Nous divisons la chaîne d'entrée représentant le nombre de mots en sous-chaînes en utilisant le \ s + régulier, puis nous essayons de faire correspondre chaque sous-chaîne avec des exemples de jetons ou de la diviser en sous-chaînes plus petites, en choisissant les meilleurs résultats.  En conséquence, nous obtenons un ensemble de jetons par lequel nous générons un nombre, et la valeur d'erreur est prise comme la moyenne arithmétique des erreurs parmi les jetons utilisés dans la génération. </p><br><h2>  Affiner un algorithme pour une tâche spécifique </h2><br><p>  Dans ma tâche, les nombres sont non négatifs et relativement petits, donc j'exclurai les jetons inutiles du "million" et plus.  Pour le test, chers lecteurs, au contraire, j'ai ajouté des jetons de jargon supplémentaires, qui permettaient d'analyser des chaînes telles que "cinq pièces", "tondre deux cents" et même "trois stolniks et deux pièces d'or".  C'est drôle, mais cela n'a même pas nécessité de modifications de l'algorithme. </p><br><h2>  Nouvelle amélioration </h2><br><p>  L'algorithme existant a des défauts: </p><br><ol><li>  <b>Contrôle de cas.</b>  Les chaînes "deux mille" et "deux mille" seront reconnues avec une erreur nulle comme 2000. Dans ma tâche, le contrôle de cas n'est pas requis, il est même dangereux, mais si vous avez besoin d'une telle fonction, cela est résolu en introduisant un drapeau supplémentaire dans le jeton qui est responsable du cas du prochain jeton . <br></li><li>  <b>Nombres négatifs.</b>  Un jeton négatif supplémentaire est introduit avec un traitement spécial.  Rien de compliqué, mais n'oubliez pas que la lettre «y» est mauvaise et n'apparaît pas dans les chiffres, vous devrez changer ses caractéristiques de poids ou espérer qu'elle ne change pas pendant le processus OCR. <br></li><li>  <b>Nombres fractionnaires.</b>  Il est résolu en remplaçant le type long par un double et en introduisant des jetons "dixièmes", "centièmes", etc ... N'oubliez pas de réviser l'échelle des lettres. <br></li><li>  <b>Reconnaissance des numéros saisis par les utilisateurs.</b>  Parce que  lors de la saisie manuelle de texte, nous faisons le plus souvent des erreurs liées à la réédition de siVMolov, vous devez ajouter cette opération à l'algorithme de Wagner-Fisher. <br></li><li>  <b>Prise en charge d'autres langues.</b>  Nous introduisons de nouveaux jetons, élargissons le tableau des poids. <br></li><li>  <b>Manipulation des ordures.</b>  Dans certains documents, les données sont imprimées, la qualité de l'image peut être médiocre, la cellule peut être vide et banale.  Dans ce cas, les ordures qui doivent être nettoyées entrent d'une manière ou d'une autre dans la ligne.  Le mieux que je puisse offrir pour le moment est de prétraiter le document avant l'OCR.  Supprimer les lignes du tableau et les remplir avec une couleur proche de la couleur de l'espace libre de la cellule m'a beaucoup aidé.  Cela n'a pas résolu tous les problèmes, mais a amélioré la qualité de la reconnaissance du texte des documents où le tableau avait des courbures en raison des ecchymoses du document ou d'un photographe tordu.  Idéalement, vous devez faire pivoter la cellule elle-même et la reconnaître séparément, si vous avez bien sûr une table. <br></li></ol><br><h1>  Alors, quel est le résultat net? </h1><br><p>  Le projet contient un exemple d'application console exécutée dans le fichier samples.txt avec des exemples pour l'analyseur.  Voici une capture d'écran des résultats: </p><br><img src="https://habrastorage.org/webt/fq/ed/ac/fqedacgduf7tewa8tvg-tn6zv3s.png"><br><br><p>  Je vous charge d'évaluer le résultat, mais moi, ce n'est pas mal.  L'erreur pour les exemples de reconnaissance réels ne dépasse pas 0,25, bien que je n'aie pas encore exécuté l'ensemble des documents disponibles, tout ne sera probablement pas si fluide là-bas. </p><br><p>  Quant à la dernière section, je me demandais toujours à quel point c'est «dofiga».  En outre, le programme s'est donné une réponse adéquate, combien devrait être pris sur un personnel (je n'utilise pas, mais quand même) et a même déterminé avec précision la signification du vieux mot russe "obscurité".  Et oui, la conclusion ne comprenait pas encore une autre mesure que l'éducation ne permettait pas d'ajouter, mais le programme estime qu'elle est égale à mille =) </p><br><h1>  Quelques mots sur la bibliothèque </h1><br><p>  Au départ, mes projets ne prévoyaient pas la création d'une bibliothèque, j'ai décidé de la concevoir exclusivement pour un Habr.  J'ai essayé de mettre le code dans l'ordre, mais si vous l'utilisez, faites un fork ou une copie, comme  vous n'aurez probablement pas besoin de jargon et d'autres jetons inclus dans les exemples. </p><br><p>  La bibliothèque elle-même est écrite sous .NET Standart 2.0 et C # 7.x, et les algorithmes sont facilement traduits dans d'autres langues. </p><br><p>  En cas d'expansion possible de la bibliothèque, j'ajouterai la composition des composants importants de l'analyseur numérique en mots (espace de noms Genesis.CV.NumberUtils): </p><br><ul><li>  RussianNumber.cs - analyseur directement </li><li>  RussianNumber.Data.cs - fichier avec description des jetons </li><li>  RussianNumber.ToString.cs - convertisseur de nombre en texte en mots </li><li>  RussianNumberParserOptions.cs - options de l'analyseur </li><li>  NumeralLevenshtein.cs - implémentation de l'algorithme de Wagner-Fisher </li><li>  NumeralLevenshteinData.txt - ressource, données de pondération des lettres </li></ul><br><p>  Utilisation: </p><br><ul><li>  RussianNumber.ToString (valeur) - convertir un nombre en texte </li><li>  RussianNumber.Parse (valeur, [options]) - convertit le texte en nombre </li></ul><br><h1>  Conclusion </h1><br><p>  J'espère vraiment que l'article ne vous a pas semblé ennuyeux malgré l'abondance de texte.  Récemment, j'ai trouvé beaucoup de sujets liés à la vision par ordinateur, sur lesquels il y a quelque chose à dire, donc je voudrais avoir une opinion sur ce format d'articles.  Que vaut-il la peine d'ajouter ou, inversement, de supprimer?  Qu'est-ce qui vous intéresse le plus, lecteurs, les algorithmes eux-mêmes ou les fragments de code? </p><br><p>  Aimez-vous l'article?  Découvrez les autres: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Prise en charge de la sérialisation JavaScript de classe JavaScript</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Remplir des modèles de texte avec des données basées sur un modèle.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Implémentation .NET à l'aide de fonctions de bytecode dynamique (IL)</a> <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr453642/">https://habr.com/ru/post/fr453642/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr453618/index.html">Comment nous travaillons avec les idées et comment LANBIX est né</a></li>
<li><a href="../fr453622/index.html">Programmeur de puces G-Shield: écriture de certificats numériques sur des puces au stade de la production</a></li>
<li><a href="../fr453626/index.html">Aventures dans un flux séparé. Rapport Yandex</a></li>
<li><a href="../fr453628/index.html">Que paierez-vous dans 20 ans?</a></li>
<li><a href="../fr453634/index.html">École d'analyse système d'Alfa Bank</a></li>
<li><a href="../fr453644/index.html">Interview - 10 questions sur Swift. 3e partie</a></li>
<li><a href="../fr453646/index.html">Normalisation des données dans une base de données distribuée, des microservices et un ERP</a></li>
<li><a href="../fr453650/index.html">Noyau logiciel de la cyber-infrastructure embarquée du chasseur d'attaque unifié F-35</a></li>
<li><a href="../fr453652/index.html">LogRock: test via la journalisation</a></li>
<li><a href="../fr453656/index.html">Web statique: retour aux sources?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>