<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßòüèª ü§∫ üîà REST Assured: Was wir aus f√ºnf Jahren mit dem Tool gelernt haben üêÄ üìè üë©üèª‚Äçüé§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="REST Assured - DSL zum Testen von REST-Diensten, das in Java-Tests eingebettet ist. Diese L√∂sung erschien vor mehr als neun Jahren und ist aufgrund ih...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>REST Assured: Was wir aus f√ºnf Jahren mit dem Tool gelernt haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dins/blog/464225/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">REST Assured</a> - DSL zum Testen von REST-Diensten, das in Java-Tests eingebettet ist.  Diese L√∂sung erschien vor mehr als neun Jahren und ist aufgrund ihrer Einfachheit und praktischen Funktionalit√§t popul√§r geworden. </p><br><p>  In DINS haben wir mehr als 17.000 Tests damit geschrieben und in den f√ºnf Jahren der Verwendung sind wir auf viele Fallstricke gesto√üen, die nicht direkt nach dem Importieren der Bibliothek in das Projekt herausgefunden werden k√∂nnen: ein statischer Kontext, Verwirrung in der Reihenfolge, in der Filter auf die Abfrage angewendet werden, Schwierigkeiten bei der Strukturierung des Tests. </p><br><p>  Dieser Artikel befasst sich mit solchen impliziten Funktionen von REST Assured.  Sie m√ºssen ber√ºcksichtigt werden, wenn die M√∂glichkeit besteht, dass die Anzahl der Tests im Projekt schnell zunimmt - damit Sie sie sp√§ter nicht neu schreiben m√ºssen. </p><br><p><img src="https://habrastorage.org/webt/yr/xi/jp/yrxijpz_m48cyfek2-0czo55bqc.png" alt="Bild"></p><a name="habracut"></a><br><h3 id="chto-testiruem">  Was testen wir? </h3><br><p>  DINS ist an der Entwicklung der UCaaS-Plattform beteiligt.  Insbesondere entwickeln und testen wir die API, die RingCentral selbst verwendet und Drittentwicklern zur Verf√ºgung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">stellt</a> . </p><br><p>  Bei der Entwicklung einer API ist es wichtig sicherzustellen, dass sie ordnungsgem√§√ü funktioniert. Wenn Sie sie jedoch herausgeben, m√ºssen Sie viel mehr F√§lle √ºberpr√ºfen.  Daher werden jedem neuen Endpunkt Dutzende und Hunderte von Tests hinzugef√ºgt.  Tests werden in Java geschrieben, TestNG wird als Testframework ausgew√§hlt und REST Assured wird f√ºr API-Anforderungen verwendet. </p><br><h3 id="kogda-rest-assured-prineset-polzu">  Wenn REST Assured davon profitiert </h3><br><p>  Wenn Sie nicht die gesamte API gr√ºndlich testen m√∂chten, k√∂nnen Sie dies am einfachsten mit REST Assured tun.  Es eignet sich gut zur √úberpr√ºfung der Reaktionsstruktur, der PVD und der Rauchtests. </p><br><p>  So sieht ein einfacher Test aus, der √ºberpr√ºft, ob der Endpunkt beim Zugriff den Status 200 OK anzeigt: </p><br><pre><code class="java hljs">given() .baseUri(<span class="hljs-string"><span class="hljs-string">"http://cookiemonster.com"</span></span>) .when() .get(<span class="hljs-string"><span class="hljs-string">"/cookies"</span></span>) .then() .assertThat() .statusCode(<span class="hljs-number"><span class="hljs-number">200</span></span>);</code> </pre> <br><p>  Die angegebenen Schl√ºsselw√∂rter, <code>when</code> und <code>then</code> bilden die Anfrage: <code>given</code> bestimmt, was in der Anfrage gesendet wird, <code>when</code> - mit welcher Methode und an welchen Endpunkt wir die Anfrage senden und <code>then</code> - wie die empfangene Antwort √ºberpr√ºft wird.  Dar√ºber hinaus k√∂nnen Sie den Antworttext in Form eines Objekts vom Typ <code>JsonPath</code> oder <code>XmlPath</code> und dann die empfangenen Daten verwenden. </p><br><p>  Echte Tests sind normalerweise gr√∂√üer und komplizierter.  Header, Cookies, Autorisierung und Anfragetext werden zu Anfragen hinzugef√ºgt.  Wenn die zu testende API nicht aus Dutzenden eindeutiger Ressourcen besteht, f√ºr die jeweils spezielle Parameter erforderlich sind, sollten Sie vorgefertigte Vorlagen irgendwo speichern, um sie sp√§ter einem bestimmten Aufruf im Test hinzuzuf√ºgen. </p><br><p>  Daf√ºr gibt es in REST Assured: </p><br><ul><li>  <code>RequestSpecification</code> / <code>ResponseSpecification</code> ; </li><li>  Grundkonfiguration; </li><li>  Filter. </li></ul><br><h3 id="requestspecification-i-responsespecification">  RequestSpecification und ResponseSpecification </h3><br><p>  Mit diesen beiden Klassen k√∂nnen Sie die Anforderungsparameter und Erwartungen aus der Antwort ermitteln: </p><br><pre> <code class="java hljs">RequestSpecification requestSpec = given() .baseUri(<span class="hljs-string"><span class="hljs-string">"http://cookiemonster.com"</span></span>) .header(<span class="hljs-string"><span class="hljs-string">"Language"</span></span>, <span class="hljs-string"><span class="hljs-string">"en"</span></span>); requestSpec.when() .get(<span class="hljs-string"><span class="hljs-string">"/cookiesformonster"</span></span>) .then() .statusCode(<span class="hljs-number"><span class="hljs-number">200</span></span>); requestSpec.when() .get(<span class="hljs-string"><span class="hljs-string">"/soup"</span></span>) .then() .statusCode(<span class="hljs-number"><span class="hljs-number">400</span></span>);</code> </pre> <br><pre> <code class="java hljs">ResponseSpecification responseSpec = expect() .statusCode(<span class="hljs-number"><span class="hljs-number">200</span></span>); given() .expect() .spec(responseSpec) .when() .get(<span class="hljs-string"><span class="hljs-string">"/hello"</span></span>); given() .expect() .spec(responseSpec) .when() .get(<span class="hljs-string"><span class="hljs-string">"/goodbye"</span></span>);</code> </pre> <br><p>  Eine Spezifikation wird in mehreren Aufrufen, Tests und Testklassen verwendet, je nachdem, wo sie definiert ist - es gibt keine Einschr√§nkung.  Sie k√∂nnen einer einzelnen Anforderung sogar mehrere Spezifikationen hinzuf√ºgen.  Dies ist jedoch eine potenzielle <strong>Problemquelle</strong> : </p><br><pre> <code class="java hljs">RequestSpecification requestSpec = given() .baseUri(<span class="hljs-string"><span class="hljs-string">"http://cookiemonster.com"</span></span>) .header(<span class="hljs-string"><span class="hljs-string">"Language"</span></span>, <span class="hljs-string"><span class="hljs-string">"en"</span></span>); RequestSpecification yetAnotherRequestSpec = given() .header(<span class="hljs-string"><span class="hljs-string">"Language"</span></span>, <span class="hljs-string"><span class="hljs-string">"fr"</span></span>); given() .spec(requestSpec) .spec(yetAnotherRequestSpec) .when() .get(<span class="hljs-string"><span class="hljs-string">"/cookies"</span></span>) .then() .statusCode(<span class="hljs-number"><span class="hljs-number">200</span></span>);</code> </pre> <br><p>  Anrufliste: </p><br><pre> <code class="plaintext hljs">Request method: GET Request URI: http://localhost:8080/ Headers: Language=en Language=fr Accept=*/* Cookies: &lt;none&gt; Multiparts: &lt;none&gt; Body: &lt;none&gt; java.net.ConnectException: Connection refused (Connection refused)</code> </pre> <br><p>  Es stellte sich heraus, dass alle Header zum Aufruf hinzugef√ºgt wurden, aber der URI wurde pl√∂tzlich zu localhost - obwohl er in der ersten Spezifikation hinzugef√ºgt wurde. </p><br><p>  Dies geschah aufgrund der Tatsache, dass REST Assured √úberschreibungen f√ºr Anforderungsparameter unterschiedlich behandelt (dasselbe gilt f√ºr die Antwort).  √úberschriften oder Filter werden der Liste hinzugef√ºgt und dann der Reihe nach angewendet.  Es kann nur einen URI geben, daher wird der letzte angewendet.  Es wurde in der zuletzt hinzugef√ºgten Spezifikation nicht angegeben. Daher √ºberschreibt REST Assured es mit dem Standardwert (localhost). </p><br><p>  <strong>Wenn Sie der Anforderung eine Spezifikation hinzuf√ºgen, f√ºgen Sie eine hinzu</strong> .  Der Rat scheint offensichtlich, aber wenn das Projekt mit Tests w√§chst, erscheinen Hilfsklassen und grundlegende Testklassen, bevor Methoden in ihnen erscheinen.  Es wird schwierig, den √úberblick dar√ºber zu behalten, was mit Ihrer Anfrage tats√§chlich passiert, insbesondere wenn mehrere Personen gleichzeitig Tests schreiben. </p><br><h3 id="bazovaya-konfiguraciya-rest-assured">  Grundlegende REST-versicherte Konfiguration </h3><br><p>  Eine andere M√∂glichkeit, Vorlagenabfragen in REST Assured durchzuf√ºhren, besteht darin, die Grundkonfiguration zu konfigurieren und die statischen Felder der RestAssured-Klasse zu definieren: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BeforeMethod</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configureRestAssured</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span></span>{ RestAssured.baseURI = <span class="hljs-string"><span class="hljs-string">"http://cookiemonster.com"</span></span>; RestAssured.requestSpecification = given() .header(<span class="hljs-string"><span class="hljs-string">"Language"</span></span>, <span class="hljs-string"><span class="hljs-string">"en"</span></span>); RestAssured.filters(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RequestLoggingFilter(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ResponseLoggingFilter()); ... }</code> </pre> <br><p>  Werte werden der Anforderung jedes Mal automatisch hinzugef√ºgt.  Die Konfiguration wird mit den Anmerkungen <code>@BeforeMethod</code> in TestNG und <code>@BeforeEach</code> in JUnit kombiniert, sodass Sie sicher sein k√∂nnen, dass jeder Test, den Sie ausf√ºhren, mit denselben Parametern beginnt. </p><br><p>  Die <strong>Konfiguration kann jedoch zu Problemen f√ºhren, da sie statisch ist</strong> . </p><br><p>  Beispiel: Vor jedem Test nehmen wir einen Testbenutzer, holen ein Autorisierungstoken f√ºr ihn und f√ºgen es dann √ºber AuthenticationScheme oder einen Autorisierungsfilter zur Grundkonfiguration hinzu.  Solange die Tests in einem einzigen Thread ausgef√ºhrt werden, funktioniert alles. <br>  Wenn es zu viele Tests gibt, f√ºhrt die √ºbliche Entscheidung, ihre Ausf√ºhrung in mehrere Threads aufzuteilen, dazu, dass ein Code neu geschrieben wird, damit ein Token von einem Thread nicht in den benachbarten f√§llt. </p><br><h3 id="filtry-rest-assured">  REST-versicherte Filter </h3><br><p>  Filter √§ndern sowohl Anforderungen vor dem Senden als auch Antworten, bevor sie die Einhaltung der angegebenen Erwartungen √ºberpr√ºfen.  Anwendungsbeispiel - Hinzuf√ºgen von Protokollierung oder Autorisierung: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OAuth2Filter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthFilter</span></span></span><span class="hljs-class"> </span></span>{ String accessToken; OAuth2Filter(String accessToken) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.accessToken = accessToken; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Response </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FilterableRequestSpecification requestSpec, FilterableResponseSpecification responseSpec, FilterContext ctx)</span></span></span><span class="hljs-function"> </span></span>{ requestSpec.replaceHeader(<span class="hljs-string"><span class="hljs-string">"Authorization"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bearer "</span></span> + accessToken); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ctx.next(requestSpec, responseSpec); } }</code> </pre> <br><pre> <code class="java hljs">String accessToken = getAccessToken(username, password); OAuth2Filter auth = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OAuth2Filter(accessToken); given() .filter(auth) .filter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RequestLoggingFilter()) .filter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ResponseLoggingFilter()) ...</code> </pre> <br><p>  Filter, die der Anforderung hinzugef√ºgt werden, werden in <code>LinkedList</code> gespeichert.  Bevor Sie eine Anfrage stellen, √§ndert REST Assured diese, indem Sie die Liste durchgehen und einen Filter nach dem anderen anwenden.  Dann wird dasselbe mit der Antwort gemacht, die kam. </p><br><p>  <strong>Die Reihenfolge der Filter ist wichtig</strong> .  Diese beiden Abfragen f√ºhren zu unterschiedlichen Protokollen: Die erste gibt den Autorisierungsheader an, die zweite - Nr.  In diesem Fall wird der Header zu beiden Anforderungen hinzugef√ºgt. Nur im ersten Fall f√ºgt REST Assured vor der Anmeldung zuerst eine Autorisierung hinzu und im zweiten Fall umgekehrt. </p><br><pre> <code class="java hljs">given() .filter(auth) .filter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RequestLoggingFilter()) ‚Ä¶ given() .filter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RequestLoggingFilter()) .filter(auth)</code> </pre> <br><p>  Zus√§tzlich zu der √ºblichen Regel, dass Filter in der Reihenfolge angewendet werden, in der sie hinzugef√ºgt werden, besteht weiterhin die M√∂glichkeit, Ihren Filter durch Implementierung der <code>OrderedFilter</code> Schnittstelle zu priorisieren.  Hier k√∂nnen Sie eine spezielle numerische Priorit√§t f√ºr den Filter festlegen, die √ºber oder unter dem Standardwert (1000) liegt.  Filter mit einer h√∂heren Priorit√§t werden fr√ºher als gew√∂hnlich ausgef√ºhrt, mit einer Priorit√§t darunter - danach. </p><br><p>  Nat√ºrlich k√∂nnen Sie hier verwirrt werden und versehentlich die beiden Filter auf dieselbe Priorit√§t setzen, z. B. 999. Dann wird der zuvor hinzugef√ºgte Filter zuerst auf die Anforderung angewendet. </p><br><h3 id="ne-tolko-filtry">  Nicht nur Filter </h3><br><p>  Die Autorisierung √ºber Filter ist oben dargestellt.  Neben dieser Methode in REST Assured gibt es √ºber <code>AuthenticationScheme</code> noch eine andere: </p><br><pre> <code class="java hljs">String accessToken = getAccessToken(username, password); OAuth2Scheme scheme = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OAuth2Scheme(); scheme.setAccessToken(accessToken); RestAssured.authentication = scheme;</code> </pre> <br><p>  Dies ist eine veraltete Methode.  Stattdessen sollten Sie die oben gezeigte ausw√§hlen.  Es gibt zwei Gr√ºnde: </p><br><p>  <strong>Abh√§ngigkeitsproblem</strong> </p><br><p>  Aus der Dokumentation zu REST Assured geht hervor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> dass zur Verwendung von Oauth1 oder Oauth2 (durch Angabe eines Tokens als Abfrageparameter) je nach Scribe Berechtigungen hinzugef√ºgt werden m√ºssen.  Das Importieren der neuesten Version hilft Ihnen jedoch nicht weiter - es tritt ein Fehler auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, der in einem der offenen Probleme beschrieben wird</a> .  Sie k√∂nnen es nur l√∂sen, indem Sie die alte Version der Bibliothek 2.5.3 importieren.  In diesem Fall werden Sie jedoch auf ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">anderes Problem</a> sto√üen. </p><br><p>  Im Allgemeinen funktioniert keine andere Version von Scribe mit Oauth2 REST Assured Version 3.0.3 und h√∂her (und die aktuelle Version 4.0.0 hat dies nicht behoben). </p><br><p>  <strong>Die Protokollierung funktioniert nicht</strong> </p><br><p>  Filter werden auf Abfragen in einer bestimmten Reihenfolge angewendet.  Und <code>AuthenticationScheme</code> wird nach ihnen angewendet.  Dies bedeutet, dass es schwierig sein wird, ein Problem mit der Autorisierung im Test zu erkennen - es wird nicht verpf√§ndet. </p><br><h3 id="esche-o-sintaksise-rest-assured">  Weitere Informationen zur REST Assured-Syntax </h3><br><p>  Eine gro√üe Anzahl von Tests bedeutet normalerweise, dass sie auch komplex sind.  Und wenn die API das Hauptthema des Testens ist und Sie nicht nur die JSON-Felder, sondern auch die Gesch√§ftslogik √ºberpr√ºfen m√ºssen, wird der Test mit REST Assured zu einem Blatt: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldCorrectlyCountAddedCookies</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Integer addNumber = <span class="hljs-number"><span class="hljs-number">10</span></span>; JsonPath beforeCookies = given() .when() .get(<span class="hljs-string"><span class="hljs-string">"/latestcookies"</span></span>) .then() .assertThat() .statusCode(<span class="hljs-number"><span class="hljs-number">200</span></span>) .extract() .jsonPath(); String beforeId = beforeCookies.getString(<span class="hljs-string"><span class="hljs-string">"id"</span></span>); JsonPath afterCookies = given() .body(String.format(<span class="hljs-string"><span class="hljs-string">"{number: %s}"</span></span>, addNumber)) .when() .put(<span class="hljs-string"><span class="hljs-string">"/cookies"</span></span>) .then() .assertThat() .statusCode(<span class="hljs-number"><span class="hljs-number">200</span></span>) .extract() .jsonPath(); Integer afterNumber = afterCookies.getInt(<span class="hljs-string"><span class="hljs-string">"number"</span></span>); String afterId = afterCookies.getString(<span class="hljs-string"><span class="hljs-string">"id"</span></span>); JsonPath history = given() .when() .get(<span class="hljs-string"><span class="hljs-string">"/history"</span></span>) .then() .assertThat() .statusCode(<span class="hljs-number"><span class="hljs-number">200</span></span>) .extract() .jsonPath(); assertThat(history.getInt(String.format(<span class="hljs-string"><span class="hljs-string">"records.find{r -&gt; r.id == %s}.number"</span></span>, beforeId))) .isEqualTo(afterNumber - addNumber); assertThat(history.getInt(String.format(<span class="hljs-string"><span class="hljs-string">"records.find{r -&gt; r.id == %s}.number"</span></span>, afterId))) .isEqualTo(afterNumber); }</code> </pre> <br><p>  Dieser Test best√§tigt, dass wir beim F√ºttern eines Monster-Cookies korrekt berechnen, wie viele Cookies ihm gegeben wurden, und dies in der Geschichte angeben.  Auf den ersten Blick kann dies jedoch nicht verstanden werden - alle Anforderungen sehen gleich aus, und es ist nicht klar, wo die Vorbereitung der Daten √ºber die API endet und wohin die Testanforderung gesendet wird. </p><br><p>  <code>given()</code> , <code>when()</code> und <code>then()</code> REST Assured von BDD nimmt, wie Spock oder Cucumber.  Bei komplexen Tests geht jedoch ihre Bedeutung verloren, da der Umfang des Tests viel gr√∂√üer als eine Anforderung wird - dies ist eine kleine Aktion, die durch eine Zeile angezeigt werden muss.  Und daf√ºr k√∂nnen Sie REST Assured-Anrufe an Hilfsklassen weiterleiten: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CookieMonsterHelper</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> JsonPath </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCookies</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> given() .when() .get(<span class="hljs-string"><span class="hljs-string">"/cookiesformonster"</span></span>) .then() .extract() .jsonPath(); } ... }</code> </pre> <br><p>  Und rufen Sie den Test an: </p><br><pre> <code class="java hljs">JsonPath response = CookieMonsterHelper.getCookies();</code> </pre> <br><p>  Es ist gut, wenn solche Hilfsklassen universell sind, sodass ein Aufruf einer Methode in eine gro√üe Anzahl von Tests eingebettet werden kann. Dann k√∂nnen sie im Allgemeinen in eine separate Bibliothek gestellt werden: Pl√∂tzlich m√ºssen Sie die Methode irgendwann in einem anderen Projekt aufrufen.  Nur in diesem Fall m√ºssen Sie alle Antwortpr√ºfungen entfernen, die Rest Assured durchf√ºhren kann. Schlie√ülich k√∂nnen h√§ufig sehr unterschiedliche Daten als Antwort auf dieselbe Anforderung zur√ºckgegeben werden. </p><br><h3 id="zaklyuchenie">  Fazit </h3><br><p>  REST Assured ist eine Bibliothek zum Testen.  Sie wei√ü, wie man zwei Dinge macht: Anfragen senden und Antworten √ºberpr√ºfen.  Wenn wir versuchen, es aus den Tests zu entfernen und alle √úberpr√ºfungen zu entfernen, wird es <strong>zu einem HTTP-Client</strong> . </p><br><p>  Wenn Sie eine gro√üe Anzahl von Tests schreiben und diese weiterhin unterst√ºtzen m√ºssen, √ºberlegen Sie, ob Sie einen HTTP-Client mit umst√§ndlicher Syntax, statischer Konfiguration, Verwirrung in der Reihenfolge der Anwendung von Filtern und Spezifikationen und einer Protokollierung ben√∂tigen, die leicht besch√§digt werden kann.  Vor vielleicht neun Jahren war REST Assured das bequemste Werkzeug, aber w√§hrend dieser Zeit tauchten Alternativen auf - Nachr√ºstung, Feign, Unirest usw. -, die solche Funktionen nicht haben. </p><br><p>  Die meisten der im Artikel beschriebenen Probleme manifestieren sich in gro√üen Projekten.  Wenn Sie schnell ein paar Tests schreiben und sie f√ºr immer vergessen m√ºssen und Retrofit es nicht mag, ist REST Assured die beste Option. </p><br><p>  Wenn Sie bereits Tests mit REST Assured schreiben, m√ºssen Sie sich nicht beeilen, um alles neu zu schreiben.  Wenn sie stabil und schnell sind, wird sie mehr Zeit in Anspruch nehmen als praktische Vorteile bringen.  Wenn nicht, ist REST Assured nicht Ihr Hauptproblem. </p><br><p>  T√§glich w√§chst die Anzahl der in DINS f√ºr die RingCentral-API geschriebenen Tests, und sie verwenden weiterhin REST Assured.  Der Zeitaufwand f√ºr den Wechsel zu einem anderen HTTP-Client, zumindest bei neuen Tests, ist zu gro√ü, und die erstellten Hilfsklassen und Methoden, mit denen die Testkonfiguration konfiguriert wird, l√∂sen die meisten Probleme.  In diesem Fall ist es wichtiger, die Integrit√§t des Projekts mit Tests aufrechtzuerhalten, als den sch√∂nsten und modischsten Kunden zu verwenden.  REST Assured erledigt trotz seiner M√§ngel seine Hauptaufgabe. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464225/">https://habr.com/ru/post/de464225/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464209/index.html">Gutenberg Editor, wie man Editoren und Schriftsetzer bequem macht</a></li>
<li><a href="../de464217/index.html">So visualisieren Sie Sound im Web: Eine Auswahl thematischer Materialien und Videovortr√§ge mit Theorie und Praxis</a></li>
<li><a href="../de464219/index.html">Timlid-Toolkit von E-Mail an Kanban-Boards</a></li>
<li><a href="../de464221/index.html">Lernen, mit einem Team bei Saint TeamLead Conf zu arbeiten</a></li>
<li><a href="../de464223/index.html">Bewusstseinsentwicklung bei Saint TeamLead Conf</a></li>
<li><a href="../de464227/index.html">Wie sie in Krasnodar leben und arbeiten</a></li>
<li><a href="../de464233/index.html">Chaos Constructions 2019 kommt ...</a></li>
<li><a href="../de464235/index.html">"Slurm" macht s√ºchtig. Wie man eine Kabale in ein globales Projekt verwandelt</a></li>
<li><a href="../de464237/index.html">Pascal Tanchiki: Wie Kindern in den 90ern das Programmieren beigebracht wurde und was daran falsch war</a></li>
<li><a href="../de464245/index.html">Out-of-Memory Killer unter Linux f√ºr PostgreSQL konfigurieren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>