<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥉 🥔 🕉️ Bagaimana cara mengajar jaringan saraf untuk mereproduksi fisika game 🌠 🏾 ▫️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di hampir semua permainan komputer modern, kehadiran mesin fisik adalah prasyarat. Bendera dan kelinci berkibar ditiup angin, dihujani bola - semua in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana cara mengajar jaringan saraf untuk mereproduksi fisika game</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/479292/"> Di hampir semua permainan komputer modern, kehadiran mesin fisik adalah prasyarat.  Bendera dan kelinci berkibar ditiup angin, dihujani bola - semua ini membutuhkan eksekusi yang tepat.  Dan, tentu saja, bahkan jika tidak semua pahlawan mengenakan jas hujan ... tetapi mereka yang mengenakannya benar-benar membutuhkan simulasi kain pengibar yang memadai. <br><br><img src="https://habrastorage.org/webt/5-/tq/jb/5-tqjb5ugkqhg77mf9vr1lfzz9o.png"><br><br>  Namun demikian, pemodelan fisik penuh dari interaksi seperti itu sering menjadi tidak mungkin, karena urutannya lebih lambat dari yang diperlukan untuk permainan waktu nyata.  Artikel ini menawarkan metode pemodelan baru yang dapat mempercepat simulasi fisik, membuatnya 300-5000 kali lebih cepat.  Tujuannya adalah untuk mencoba mengajarkan jaringan saraf untuk mensimulasikan kekuatan fisik. <br><a name="habracut"></a><br>  Kemajuan dalam pengembangan mesin fisik ditentukan oleh kekuatan komputasi yang berkembang dari peralatan teknis dan pengembangan metode pemodelan yang cepat dan stabil.  Metode tersebut termasuk, misalnya, pemodelan dengan memotong ruang menjadi subruang dan pendekatan berbasis data - yaitu, berdasarkan data.  Yang pertama hanya bekerja dalam subruang yang dikurangi atau dikompresi, di mana hanya beberapa bentuk deformasi yang diperhitungkan.  Untuk proyek besar, ini dapat menyebabkan peningkatan yang signifikan dalam persyaratan teknis.  Pendekatan berbasis data menggunakan memori sistem dan data pra-komputasi yang tersimpan di dalamnya, yang mengurangi persyaratan ini. <br><br>  Di sini kita melihat pendekatan yang menggabungkan kedua metode: dengan cara ini, ini dimaksudkan untuk memanfaatkan kekuatan keduanya.  Metode seperti itu dapat diinterpretasikan dalam dua cara: baik sebagai metode pemodelan subruang parameterisasi oleh jaringan saraf, atau sebagai metode DD berdasarkan pemodelan subruang untuk membangun media simulasi terkompresi. <br><br>  Esensinya adalah ini: pertama kami mengumpulkan data simulasi presisi tinggi menggunakan <abbr title="Maya nCloth - alat bawaan untuk membuat grafik komputer yang sangat realistis, Autodesk Maya, yang memungkinkan Anda membuat kain yang realistis dan bahan yang dapat dideformasi lainnya.">Maya nCloth</abbr> , dan kemudian kami menghitung subruang linier menggunakan <abbr title="Analisis komponen utama (PCA) adalah salah satu cara utama untuk mengurangi dimensi data, sekaligus kehilangan jumlah informasi yang paling sedikit. Dari sudut pandang matematis, metode ini adalah transformasi linear ortogonal yang memetakan data dari ruang fitur asli ke ruang baru dengan dimensi lebih rendah. Dalam hal ini, sumbu pertama dari sistem koordinat baru dibangun sedemikian rupa sehingga dispersi data sepanjang itu akan maksimal. Sumbu kedua dibangun secara ortogonal untuk yang pertama sehingga varians data sepanjang itu juga akan menjadi maksimum dari sisa yang mungkin, dan seterusnya. Dengan demikian, makna metode ini terletak pada kenyataan bahwa setiap komponen utama dikaitkan dengan fraksi tertentu dari total varian dari kumpulan data asli. Pada gilirannya, varians, yang merupakan ukuran dari variabilitas data, dapat mencerminkan tingkat konten informasinya.">metode komponen utama (PCA)</abbr> .  Pada langkah berikutnya, kami menggunakan pembelajaran mesin berdasarkan model jaringan saraf klasik dan metodologi baru kami, setelah itu kami memperkenalkan model terlatih ke dalam algoritma interaktif dengan beberapa optimasi, seperti algoritma dekompresi yang efisien oleh GPU dan metode untuk mendekati normals vertex. <br><br><img src="https://habrastorage.org/webt/6n/_a/1u/6n_a1urmdl9_nqjackk2iwmvuag.png"><br>  <i>Gambar 1. Diagram struktural dari metode ini</i> <br><br><h3>  Data pelatihan </h3><br>  Secara umum, satu-satunya input untuk metode ini adalah stempel waktu mentah dari posisi frame-by-frame dari simpul objek.  Selanjutnya, kami menggambarkan proses pengumpulan data tersebut. <br><br>  Kami melakukan simulasi dalam Maya nCloth, menangkap data pada kecepatan 60 frame per detik, dengan 5 atau 20 subteps dan 10 atau 25 membatasi iterasi, tergantung pada stabilitas simulasi.  Untuk kain, gunakan model T-shirt dengan sedikit peningkatan berat bahan dan ketahanannya terhadap peregangan, dan untuk benda yang cacat, karet keras dengan pengurangan gesekan.  Kami melakukan tumbukan eksternal dengan bertabrakan segitiga geometri eksternal, tumbukan sendiri - simpul dengan simpul untuk kain dan segitiga dengan segitiga untuk karet.  Dalam semua kasus, kami menggunakan ketebalan tumbukan yang agak besar - sekitar 5 cm - untuk memastikan stabilitas model dan mencegah terjepit dan robeknya kain. <br><br>  <i>Tabel 1. Parameter dari objek yang dimodelkan</i> <br><img src="https://habrastorage.org/webt/dw/ag/tf/dwagtfbbptnhiioq-2gutci9ung.png"><br><br>  Untuk berbagai jenis interaksi objek sederhana (misalnya, bola), kami akan menghasilkan gerakan mereka secara acak dengan memotong koordinat acak pada waktu acak.  Untuk mensimulasikan interaksi jaringan dengan karakter, kami menggunakan basis data penangkapan gerak 6,5 × 10 <sup>5</sup> frame, yang merupakan satu animasi besar.  Setelah menyelesaikan simulasi, kami memverifikasi hasilnya dan mengecualikan frame dengan perilaku yang tidak stabil atau buruk.  Untuk adegan dengan rok, kami melepas tangan karakter, karena mereka sering bersinggungan dengan geometri jala kaki dan sekarang tidak signifikan. <br><br><img src="https://habrastorage.org/webt/0r/aa/ug/0raaugw5jdlmj9aqrzac7uj14-e.gif"><br>  <i>Gambar 2. Dua adegan pertama dari tabel</i> <br><br>  Biasanya kita membutuhkan 10 <sup>5</sup> -10 <sup>6</sup> frame data pelatihan.  Dalam pengalaman kami, dalam kebanyakan kasus 10 <sup>5</sup> frame sudah cukup untuk pengujian, sedangkan hasil terbaik dicapai dengan 10 <sup>6</sup> frame. <br><br><h3>  Pelatihan </h3><br>  Selanjutnya, kita akan berbicara tentang proses pembelajaran mesin: tentang parameterisasi dalam jaringan saraf kita, tentang arsitektur jaringan dan langsung tentang teknik itu sendiri. <br><br><h4>  Parameterisasi </h4><br>  Untuk mendapatkan kumpulan data pelatihan, kami mengumpulkan koordinat simpul di setiap frame <i>t</i> menjadi satu vektor <i><sub>xt</sub></i> , dan kemudian menggabungkan vektor frame-by-frame ini ke dalam satu matriks besar X. Matriks ini menjelaskan keadaan objek yang dimodelkan.  Selain itu, kita harus memiliki gagasan tentang keadaan objek eksternal di setiap bingkai.  Untuk objek sederhana (seperti bola), Anda dapat menggunakan koordinat tiga dimensi mereka, sedangkan keadaan model kompleks (karakter) dijelaskan oleh posisi setiap sambungan relatif ke titik referensi: dalam kasus rok, pendukung seperti itu akan menjadi sendi pinggul, dalam kasus jubah - leher.  Untuk objek dengan sistem referensi bergerak, posisi Bumi relatif terhadapnya harus diperhitungkan: maka sistem kami akan mengetahui arah gravitasi, serta kecepatan linier, akselerasi, kecepatan rotasi, dan percepatan rotasi.  Untuk bendera, kita akan memperhitungkan kecepatan dan arah angin.  Akibatnya, untuk setiap objek kita mendapatkan satu vektor besar yang menggambarkan keadaan objek eksternal, dan semua vektor ini juga digabungkan ke dalam matriks Y. <br><br>  Sekarang kita menerapkan PCA ke matriks X dan Y, dan menggunakan matriks transformasi yang dihasilkan Z dan W untuk membangun gambar ruang bagian.  Jika prosedur PCA membutuhkan terlalu banyak memori, sampel pertama data kami. <br><br>  Kompresi PCA mau tidak mau mengakibatkan hilangnya detail, terutama untuk objek dengan banyak kondisi potensial, seperti lipatan tipis kain.  Namun, jika subruang terdiri dari 256 vektor basis, ini biasanya membantu menyimpan sebagian besar detail.  Di bawah ini adalah animasi dari fisika standar jubah dan model dengan 256, 128 dan 64 vektor basis, masing-masing. <br><br><img src="https://habrastorage.org/webt/yt/gg/7a/ytgg7aiprksj0qtezlvbpy2qcs4.gif"><br>  <i>Gambar 3. Perbandingan model kontrol (standar) dengan model yang diperoleh dengan metode kami di ruang dengan basis dimensi yang berbeda</i> <br><br><h4>  Sumber dan Model yang Diperluas </h4><br>  Itu perlu untuk mengembangkan model yang dapat memprediksi keadaan vektor model dalam bingkai masa depan.  Dan karena objek yang dimodelkan biasanya ditandai oleh inersia dengan kecenderungan ke keadaan rata-rata tertentu (setelah prosedur PCA objek mengambil keadaan seperti itu pada nilai nol), model awal yang baik akan menjadi ekspresi yang diwakili oleh garis 9 dari algoritma pada Gambar 4. Di sini α dan β adalah parameter model, ⊙ adalah produk yang meledak.  Nilai-nilai parameter ini akan diperoleh dari sumber data dengan menyelesaikan <abbr title="Metode kuadrat terkecil adalah metode matematika yang digunakan untuk memecahkan berbagai masalah, berdasarkan pada meminimalkan jumlah penyimpangan kuadrat dari beberapa fungsi dari variabel yang diinginkan.">persamaan kuadrat linear terkecil secara</abbr> individual untuk α dan β: <br><br><img src="https://habrastorage.org/webt/4g/ml/d1/4gmld1lrufdu-hdusjpuerfmb6w.png"><br><br>  Di sini † adalah <abbr title="A + disebut matriks pseudoinverse untuk matriks A jika memenuhi kriteria berikut: A A + A = A; A + A A + = A +; (A A +) * = A A +; (A + A) * = A + A.">transformasi pseudoinverse dari matriks</abbr> . <br><br>  Karena prediksi seperti itu hanya perkiraan yang sangat kasar dan tidak memperhitungkan pengaruh objek eksternal, jelas, itu tidak akan dapat secara akurat memodelkan data pelatihan.  Oleh karena itu, kami melatih ne jaringan syaraf perkiraan efek residual dari model sesuai dengan garis 11 algoritma.  Di sini kita parameterisasi <abbr title="Jaringan neural feedforward adalah jaringan neural di mana sinyal merambat secara ketat dari lapisan input ke lapisan output dan tidak merambat ke arah yang berlawanan.">jaringan saraf distribusi langsung</abbr> standar dengan 10 lapisan, untuk setiap lapisan (kecuali output) menggunakan fungsi aktivasi <abbr title="Fungsi aktivasi menentukan nilai output neuron tergantung pada hasil dari jumlah input dan nilai ambang batas yang tertimbang. Fungsi aktivasi ReLu mengembalikan x jika x positif, dan 0 sebaliknya.">ReLU</abbr> .  Tidak termasuk lapisan input dan output, kami menetapkan jumlah unit tersembunyi pada setiap lapisan yang tersisa sama dengan satu setengah ukuran data PCA, yang menyebabkan kompromi yang baik antara ruang yang ditempati pada hard drive dan kinerja. <br><br><img src="https://habrastorage.org/webt/re/7_/ii/re7_iisbng_s83ibdfmcn32idf8.png"><br>  <i>Gambar 4. Algoritma pembelajaran jaringan saraf</i> <br><br><h3>  Pelatihan jaringan saraf </h3><br>  Cara standar untuk melatih jaringan saraf adalah dengan beralih pada seluruh kumpulan data dan melatih jaringan untuk membuat prediksi untuk setiap frame.  Tentu saja, pendekatan seperti itu akan menyebabkan kesalahan belajar yang rendah, tetapi umpan balik dalam prediksi seperti itu akan menyebabkan perilaku hasilnya tidak stabil.  Oleh karena itu, untuk memastikan prediksi jangka panjang yang stabil, algoritma kami menggunakan <abbr title="Perbanyakan kesalahan ke belakang adalah cara untuk melatih jaringan saraf. Pelatihan dengan algoritma ini melibatkan dua lintasan melalui semua lapisan jaringan: langsung dan mundur. Dengan lulus langsung, vektor input diumpankan ke lapisan input jaringan saraf, setelah itu menyebar melalui jaringan dari lapisan ke lapisan. Akibatnya, satu set sinyal output dihasilkan, yang merupakan respons aktual jaringan terhadap gambar input yang diberikan. Selama operan langsung, semua bobot bersih sinaptik diperbaiki. Selama kebalikannya, mereka dikonfigurasikan sesuai dengan aturan koreksi kesalahan: output jaringan aktual dikurangi dari yang diinginkan, sebagai akibatnya dihasilkan sinyal kesalahan. Sinyal ini selanjutnya merambat melalui jaringan ke arah yang berlawanan dengan arah koneksi sinaptik. Bobot sinaptik disesuaikan untuk memaksimalkan output jaringan ke yang diinginkan.">metode propagasi kesalahan kembali</abbr> selama prosedur integrasi. <br><br>  Secara umum, ini bekerja seperti ini: dari jendela kecil data pelatihan <i>z</i> dan <i>w,</i> kami mengambil dua frame pertama <i>z <sub>0</sub></i> dan <i>z <sub>1</sub></i> dan menambahkan sedikit noise <i>r <sub>0</sub></i> , <i>r <sub>1</sub></i> kepada mereka untuk sedikit mengganggu jalur pembelajaran.  Kemudian, untuk memprediksi frame berikutnya, kami menjalankan algoritme beberapa kali, kembali ke hasil prediksi sebelumnya pada setiap langkah waktu baru.  Segera setelah kami mendapatkan prediksi seluruh lintasan, kami menghitung kesalahan koordinat rata-rata, dan kemudian meneruskannya ke pengoptimal AmsGrad menggunakan turunan otomatis yang dihitung menggunakan TensorFlow. <br><br>  Kami akan mengulangi algoritma ini pada sampel mini 16 frame, menggunakan jendela tumpang tindih 32 frame, untuk 100 era atau sampai pelatihan bertemu.  Kami menggunakan tingkat pembelajaran 0,0001, koefisien atenuasi dari tingkat pembelajaran 0,999, dan standar deviasi kebisingan yang dihitung dari tiga komponen pertama ruang PCA.  Pelatihan semacam ini memakan waktu 10 hingga 48 jam, tergantung pada kerumitan instalasi dan ukuran data PCA. <br><br><img src="https://habrastorage.org/webt/k4/fe/in/k4feinopgrygcqm6p3dkrjk1pcu.gif"><br>  <i>Gambar 5. Perbandingan visual rok referensi dan rok yang dipelajari jaringan saraf kami</i> <br><br><h3>  Implementasi sistem </h3><br>  Kami akan menjelaskan secara rinci implementasi metode kami dalam lingkungan interaktif, termasuk mengevaluasi jaringan saraf, menghitung normals ke permukaan objek untuk rendering, dan bagaimana kami menangani persimpangan yang terlihat. <br><br><h4>  Aplikasi rendering </h4><br>  Kami merender model yang dihasilkan dalam aplikasi 3D interaktif sederhana yang ditulis dalam C ++ dan DirectX: kami sekali lagi menerapkan preproses dan operasi jaringan saraf dalam kode C ++ single-threaded dan memuat bobot jaringan biner yang diperoleh selama prosedur pelatihan kami.  Kemudian kami menerapkan beberapa optimasi sederhana untuk estimasi jaringan, khususnya, penggunaan kembali buffer memori dan data matriks-vektor yang jarang, yang menjadi mungkin karena adanya nol unit tersembunyi yang diperoleh berkat fungsi aktivasi ReLU. <br><br><h4>  Dekompresi GPU </h4><br>  Kirim data status z yang dikompresi ke GPU dan dekompres untuk render lebih lanjut.  Untuk tujuan ini, kami menggunakan shader komputasi sederhana, yang untuk setiap titik objek menghitung titik produk dari vektor z dan tiga baris pertama dari matriks U <sup>T yang</sup> sesuai dengan koordinat titik ini, setelah itu kami menambahkan nilai rata-rata <i>x <sub>µ</sub></i> .  Pendekatan ini memiliki dua keunggulan dibandingkan <abbr title="Metode naif adalah metode probabilistik sederhana berdasarkan penerapan teorema Bayes dengan asumsi ketat (naif) tentang independensi. Tergantung pada sifat yang tepat dari model probabilistik, pengklasifikasi Bayes naif dapat dilatih dengan sangat efektif. Dalam banyak aplikasi praktis, metode kemungkinan maksimum digunakan untuk memperkirakan parameter untuk model Bayesian yang naif.">metode</abbr> dekompresi <abbr title="Metode naif adalah metode probabilistik sederhana berdasarkan penerapan teorema Bayes dengan asumsi ketat (naif) tentang independensi. Tergantung pada sifat yang tepat dari model probabilistik, pengklasifikasi Bayes naif dapat dilatih dengan sangat efektif. Dalam banyak aplikasi praktis, metode kemungkinan maksimum digunakan untuk memperkirakan parameter untuk model Bayesian yang naif.">naif</abbr> .  Pertama, paralelisme GPU secara signifikan mempercepat perhitungan vektor model negara, yang dapat memakan waktu hingga 1 ms.  Kedua, mengurangi waktu transfer data antara pusat dan GPU dengan urutan besarnya, yang sangat penting untuk platform di mana transfer seluruh keadaan seluruh objek terlalu lambat. <br><br><h4>  Prediksi Vertex Normal </h4><br>  Selama rendering, tidak cukup hanya memiliki akses ke koordinat titik - informasi tentang deformasi normalnya juga diperlukan.  Biasanya, dalam mesin fisik, hilangkan perhitungan ini, atau lakukan perhitungan ulang frame-by-frame yang naif terhadap normals dengan redistribusi selanjutnya ke simpul-simpul yang bertetangga.  Ini mungkin berubah menjadi tidak efisien, karena implementasi dasar dari prosesor sentral, selain biaya dekompresi dan transfer data, memerlukan 150 μs untuk prosedur seperti itu.  Dan meskipun perhitungan ini dapat dilakukan pada GPU, ternyata lebih sulit untuk diterapkan karena kebutuhan untuk operasi paralel. <br><br>  Sebagai gantinya, kami melakukan regresi linier dari kondisi ruang bagian ke vektor kondisi penuh normal pada shader GPU.  Mengetahui nilai-nilai normals dari simpul di setiap frame, kami menghitung matriks Q, yang paling mewakili representasi dari subruang pada normals dari simpul. <br><br>  Karena prediksi normals dalam metode kami tidak pernah ditampilkan sebelumnya, tidak ada jaminan bahwa pendekatan ini akan akurat, tetapi dalam praktiknya terbukti sangat baik, seperti yang dapat dilihat dari gambar di bawah ini. <br><br><img src="https://habrastorage.org/webt/ex/mn/ef/exmnefvyrkox7j-mcl7brp2vyog.png"><br>  <i>Gambar 6. Perbandingan model yang dihitung dengan metode kami dan referensi (kebenaran dasar), serta perbedaan di antara mereka</i> <br><br><h4>  Pertarungan titik-temu </h4><br>  Jaringan saraf kami belajar untuk melakukan tabrakan secara efisien, namun, karena ketidakakuratan dalam prediksi dan kesalahan yang disebabkan oleh kompresi subruang, persimpangan dapat terjadi antara objek eksternal dan yang disimulasikan.  Selain itu, karena kami menunda perhitungan keadaan penuh adegan hingga permulaan rendering, tidak ada cara untuk secara efektif menyelesaikan masalah ini sebelumnya.  Oleh karena itu, untuk mempertahankan kinerja tinggi, menghilangkan persimpangan ini diperlukan selama rendering. <br><br>  Kami menemukan solusi sederhana dan efektif untuk ini, terdiri dari fakta bahwa perpotongan simpul diproyeksikan ke permukaan primitif dari mana kita membentuk karakter.  Proyeksi ini mudah dilakukan pada GPU menggunakan shader komputasi yang sama yang mendekompresi fabric dan menghitung shading normal. <br><br>  Jadi, pertama-tama, kita akan menyusun karakter dari objek proxy yang terhubung dengan simpul dengan jari-jari awal dan akhir yang berbeda, setelah itu kita akan mentransfer informasi tentang koordinat dan jari-jari objek ini ke shader komputasi.  Sekali lagi, periksa koordinat masing-masing simpul untuk persimpangan dengan objek proxy yang sesuai dan, jika ya, proyeksikan simpul ini ke permukaan objek proxy.  Jadi kami hanya memperbaiki posisi vertex, tanpa menyentuh yang normal itu sendiri, agar tidak merusak shading. <br><br>  Pendekatan ini akan menghapus persimpangan kecil objek yang terlihat, asalkan kesalahan perpindahan verteks tidak begitu besar sehingga proyeksi berada di sisi berlawanan dari objek proxy yang sesuai. <br><br><img src="https://habrastorage.org/webt/ef/9q/al/ef9qal2u48v_kwy6q8pqdspe9qi.png"><br>  <i>Gambar 7. Model karakter terdiri dari objek proxy dan hasil menghilangkan persimpangan terlihat menggunakan metode kami: sebelum dan sesudah</i> <br><br><h3>  Analisis Hasil </h3><br>  Jadi, adegan pengujian kami meliputi: <br><br><ul><li> ,     ; </li><li> ,    ,    ; </li><li> ,   ; </li><li>      ,  ; </li><li> ,    ; </li><li> ,    . </li></ul><br>        ,   . <br><br>    -         16 ,         120  240   . <br><br><img src="https://habrastorage.org/webt/m8/ls/dz/m8lsdz-6i0bgaghswhtf8luequg.gif"><br> <i> 8.   16 . Party time!</i> <br><br><h4>    </h4><br> ,       , ,        ,       . <br><br>   ,          PCA.   ,        ,             ,   . <br><br><img src="https://habrastorage.org/webt/0o/mb/js/0ombjsge3myljg4b2ieuzr0seic.png"><br> <i> 9.   ,    ,  – </i> <br><br><h4>  Eksekusi </h4><br>          ―     ,     .         ,     .        300-5000      ,   .           ,   <abbr title=" -   —       ,       (Projective Dynamics)       ."> -   (HRPD)</abbr> , <abbr title="   (Long short-term memory) —      ,     .      ,                 .  LSTM      ,   (gates) «».">   (LSTM)</abbr>  <abbr title="Metode blok perulangan terkelola - variasi pada topik jaringan LSTM.  Dalam perwujudan ini, gerbang lupa dan gerbang input digabungkan menjadi satu &quot;gerbang pembaruan&quot; (gerbang pembaruan).  Selain itu, keadaan sel dan keadaan laten digabungkan bersama.  Model yang dihasilkan lebih sederhana daripada model LSTM standar.">   (GRU)</abbr> . <br><br>      ,          .        Intel Xeon E5-1650 3.5 GHz    GeForce GTX 1080 Titan. <br><br> <i> 2.    </i> <br><img src="https://habrastorage.org/webt/io/ax/rw/ioaxrwaeedpn506pzo7sv857as4.png"><br><br><h3>      </h3><br> ,         ,   .      ,                  . <br><br>    data-driven ,     . ,   ,         ,           ,    ,       .  ,      ,        ― ,       . <br><br>     ,      ,         ,         . <br><br>         ,      .      data-driven ,     ― ,       .        ,   ,    ,      .        , ,            ,       . <br><br>       ,         .        . <br><br>       , , ,      .   ,   , ―    ,       . -,         ,   ,    -      .                . <br><br> ,       ,       ,     ,     .    ,     ,      ,      , ―         ,       ,     .        . <br><br>        <a href="https://www.youtube.com/watch%3Fv%3DatcKO15YVD8"></a> . <br><br><img src="https://habrastorage.org/webt/1i/hx/uf/1ihxuf4flcfzfps0xuw6sk9p8ts.gif"><br> <i> 10.  vs : choose your fighter</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id479292/">https://habr.com/ru/post/id479292/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id479282/index.html">Jika data tidak sesuai dengan memori. Metode paling sederhana</a></li>
<li><a href="../id479284/index.html">Rumah yang dibangun robot</a></li>
<li><a href="../id479286/index.html">Menulis aplikasi web sederhana menggunakan Spring MVC, Spring Data JPA dan Hibernate</a></li>
<li><a href="../id479288/index.html">Mengapa menerapkan Service Desk dan bagaimana memilih solusi untuk perusahaan Anda</a></li>
<li><a href="../id479290/index.html">Algoritma untuk mencari volume dan pusat massa polihedron</a></li>
<li><a href="../id479294/index.html">GitLab 12.5 dirilis dengan penciptaan cluster EKS dan panel lingkungan</a></li>
<li><a href="../id479296/index.html">Bagaimana saya berhenti membenci dan jatuh cinta pada perkembangan</a></li>
<li><a href="../id479298/index.html">Antipattern PostgreSQL: CTE x CTE</a></li>
<li><a href="../id479300/index.html">Pusat ekologi dan data. Seperti di Rusia dan luar negeri, "data hijau"</a></li>
<li><a href="../id479302/index.html">Dasar-dasar Grafik Unity Shader</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>