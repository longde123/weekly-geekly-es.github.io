<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚Ü™Ô∏è üï¶ üê™ ¬øEs un aut√≥mata un evento? üêæ ü§õüèª üë©üèæ‚Äçü§ù‚Äçüë©üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introducci√≥n 
 Habiendo escuchado de labios autoritarios que ‚Äúlos aut√≥matas son una cosa de eventos‚Äù [3], me di cuenta de que los aut√≥matas finitos...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬øEs un aut√≥mata un evento?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483610/"><h3>  1. Introducci√≥n </h3><br>  Habiendo escuchado de labios autoritarios que ‚Äúlos aut√≥matas son una cosa de eventos‚Äù [3], me di cuenta de que los aut√≥matas finitos est√°n marcados completamente.  Juzgue usted mismo: en la biblioteca Qt, se implementa un modelo de evento de aut√≥matas [1], en UML tambi√©n lo son [2], observamos los aut√≥matas del paquete de extensi√≥n Simulink-Stateflow del sistema MATLAB [4] (en adelante simplemente Stateflow) y all√≠ sobre eventos, etc.  etc.  En este contexto, la declaraci√≥n de Ph.D.  A.A.  Es malo interpretar de otra manera, porque  nada m√°s puede ser, porque no puede ser. <br><br>  Pero, si recuerdas la teor√≠a de los aut√≥matas finitos (TCA), ¬°no hay una palabra sobre aut√≥matas de eventos en ella!  Pero para contradecir la teor√≠a, se necesitan argumentos importantes.  ¬øHay alguna raz√≥n para dudar de la profesionalidad de D. Harell, como creador de la notaci√≥n en la que el lenguaje UML, el paquete Stateflow, basa sus ideas, que, a su vez, no son desconocidas para A.A.  Travieso?  De hecho, existen UML, Stateflow, programaci√≥n SWITCH y otras opciones de programaci√≥n autom√°tica y, en un grado u otro, funcionan con √©xito. <br><br>  Entonces, ¬øes posible eliminar el "estigma de los eventos" del modelo de m√°quina de estados finitos separando las "chuletas de las moscas"?  Es decir  separe la teor√≠a de aut√≥matas y modelos computacionales similares a los modelos de D. Harel.  Y considerar que este √∫ltimo, aunque utiliza la terminolog√≠a de la teor√≠a de aut√≥matas, representa, a juzgar por su implementaci√≥n, el desarrollo de un modelo de diagramas de bloques de programas. <br><a name="habracut"></a><br>  <i>Observaci√≥n 1. En este caso, estamos hablando del modelo de gesti√≥n del programa, y ‚Äã‚Äãno del modelo del programa en s√≠ (para m√°s detalles sobre los modelos, consulte [5]).</i> <br><br>  Entonces, recuerde, la biblioteca Qt implementa un modelo de eventos de una m√°quina de estados finitos, que fue prestada de UML.  Stateflow implementa el mismo modelo.  Es decir  La fuente de los eventos es UML, donde los aut√≥matas se basan en la notaci√≥n propuesta por D. Harel.  Pero culpar a este √∫ltimo por crear tal programaci√≥n autom√°tica tampoco ser√≠a cierto, porque  El ‚Äúacontecimiento‚Äù es una tendencia de los enfoques modernos para la implementaci√≥n de modelos de software.  Se basa en opiniones autorizadas, como las mencionadas "las m√°quinas son una cosa de eventos", y la gran popularidad de los lenguajes y tecnolog√≠as como UML.  Sin duda, este es el resultado de la imitaci√≥n de m√°quinas bajo los principios existentes de operaci√≥n de sistemas operativos. <br><br>  Pero, repetimos, ya que no parece extra√±o, pero para algunos incluso puede convertirse en noticia, en la teor√≠a de aut√≥matas no existe un modelo de evento de un aut√≥mata finito.  Al menos en esa parte que se considera cl√°sica (ver para m√°s detalles, por ejemplo, [6] o [7]).  Existe una clara contradicci√≥n entre teor√≠a y pr√°ctica.  En tal situaci√≥n, debe hacer algo con la teor√≠a o influir de alguna manera en la pr√°ctica.  Pero, tal vez, ¬ølos programadores tienen raz√≥n en su deseo de finalizar el modelo de una m√°quina de estados finitos al incluir el concepto de "evento" en √©l [8, 9]? <br><br>  Pero c√≥mo conectar los deseos de los programadores con el hecho de que "las mayores dificultades en el uso del enfoque de aut√≥matas est√°n relacionadas con la comprensi√≥n de las caracter√≠sticas del funcionamiento de los aut√≥matas en los sistemas de eventos" (ver [8]).  Me gustar√≠a entender las causas de tales problemas y, en este contexto, implementar m√°quinas de eventos y / o sus an√°logos.  Para este prop√≥sito, por detalles, tomamos la implementaci√≥n de aut√≥matas en Qt y los repetimos utilizando el modelo de un aut√≥mata finito cl√°sico. <br><br>  Dicha implementaci√≥n de los aut√≥matas de eventos es necesaria para evaluar y / o superar las "caracter√≠sticas" mencionadas.  El uso del modelo cl√°sico extender√° la teor√≠a de los aut√≥matas a la pr√°ctica de la "programaci√≥n de eventos" tambi√©n.  Y, al final, un an√°logo basado en otro modelo solo expandir√° el √°rea de aplicaci√≥n de los modelos de m√°quinas de estados finitos. <br><br><h3>  2. Eventos, se√±ales e identidad de g√©nero de los aut√≥matas. </h3><br>  En UML, un evento es "un fen√≥meno significativo que tiene una cierta posici√≥n en el tiempo y el espacio ... y conlleva ciertas consecuencias" [10].  Un evento en la teor√≠a de aut√≥matas es un subconjunto de los caracteres de entrada representados por los caracteres del alfabeto de salida (incluso existe el concepto de √°lgebra de eventos en el TCA) [6].  Lo mismo que causa la transici√≥n de un aut√≥mata se llama se√±ales de entrada en la teor√≠a de aut√≥matas.  Son las consecuencias y ‚Äúla raz√≥n, la transici√≥n del aut√≥mata de un estado a otro.  En este caso, las se√±ales de salida son la "respuesta del aut√≥mata a las se√±ales de entrada". Ambas "se refieren a instantes de tiempo determinados por las correspondientes transiciones del aut√≥mata" [6]. En UML, la se√±al (se√±al) es "una entidad con nombre que sirve como medio de comunicaci√≥n entre objetos "[10]. <br><br>  Por lo tanto, los nombres de los t√©rminos son los mismos, pero el significado invertido en ellos es diferente.  Aunque, si los reorganiza, puede encontrar una similitud: queda claro que los eventos en UML corresponden a las se√±ales de las m√°quinas de estados finitos en el TCA.  Pero, tal vez, ¬ødiferentes entidades tambi√©n est√°n ocultas bajo el t√©rmino "m√°quina de estados finitos"?  Tratemos de resolverlo, comenzando con los eventos ... <br><br>  El aut√≥mata de eventos es un aut√≥mata pasivo, porque  funciona solo en el momento de la llegada de los eventos.  En contraste, el aut√≥mata cl√°sico representa el modelo activo.  Funciona sin referencia a nada (para m√°s detalles sobre aut√≥matas pasivos y activos, consulte [9]).  Aqu√≠ comienza la asociaci√≥n con dos corredores, donde el primero es impulsado por patadas (eventos) y el segundo corre por s√≠ mismo. <br><br>  En contraste con [8], al principio no asociaremos los momentos de ocurrencia de eventos con el inicio del aut√≥mata.  Por lo tanto, nos mantendremos en el marco de la teor√≠a de los aut√≥matas, que determina la naturaleza asincr√≥nica del funcionamiento de los aut√≥matas con respecto al entorno externo.  Solo habla de tiempo discreto, en el que el cambio de estado se lleva a cabo durante un per√≠odo arbitrariamente peque√±o, pero no igual a cero, en tiempo real.  Y la raz√≥n de las transiciones es el estado actual y las se√±ales de entrada de la m√°quina, donde las consecuencias son la instalaci√≥n de un nuevo estado y los valores de las se√±ales de salida de la m√°quina (para m√°s detalles sobre la definici√≥n de m√°quinas, consulte [6]). <br><br>  La teor√≠a de los aut√≥matas es flexible para determinar el tiempo discreto, que es un modelo en tiempo real.  Por lo tanto, un ciclo de tiempo discreto puede tener un valor fijo o flotante de un intervalo en tiempo real, y de acuerdo con esto, las m√°quinas se llaman s√≠ncronas o as√≠ncronas.  Al mismo tiempo, el intervalo de tiempo asociado con el reloj puede tener cualquier valor, incluido un valor infinitamente peque√±o, pero no igual a cero. <br><br>  <i>Observaci√≥n 2. Un modelo de m√°quina de estados finitos es uno de los pocos modelos formales que incluye en su definici√≥n un modelo en tiempo real de forma expl√≠cita.</i> <br><br>  Como resultado, la velocidad formalmente "infinita" del aut√≥mata activo permite que cualquier evento sea tratado como una se√±al de entrada potencial (en t√©rminos de UML, la condici√≥n [11] le corresponde).  La m√°quina solo necesitar√° "capturar" tales eventos / se√±ales y pausas entre ellos.  Todo esto define realmente el protocolo para el trabajo conjunto del medio y la m√°quina.  El protocolo tambi√©n deber√≠a resolver el problema de reconocer sucesivamente eventos id√©nticos recibidos.  Sin esto, por ejemplo, dos s√≠mbolos id√©nticos, recibidos uno tras otro, pueden ser percibidos como uno. <br><br>  Formalmente, los matices del procesamiento de eventos no son significativos (ver el mismo aut√≥mata abstracto), pero en la implementaci√≥n pr√°ctica de algoritmos construidos por el tipo de modelo de evento, deben tenerse en cuenta.  En el caso de la biblioteca Qt, su contabilidad est√° oculta en las clases de implementaci√≥n del aut√≥mata.  A continuaci√≥n, tendremos en cuenta las diferencias entre eventos y aut√≥matas cl√°sicos utilizando el ejemplo de la implementaci√≥n de la calculadora m√°s simple de [1], donde se proporciona su "implementaci√≥n de eventos".  En contraste con esta soluci√≥n, se crear√°n modelos equivalentes basados ‚Äã‚Äãen la cl√°sica m√°quina de estados finitos. <br><br><h3>  3. Modelos de calculadora </h3><br>  Entonces, comencemos ... ¬øLlamamos se√±ales de eventos, eventos de aut√≥matas ordinarios ... o en el orden inverso y / o viceversa?  Ugh!  Confundido  En resumen, la completa "globulosa cuzdra shteko budlanula" y algo "rizos".  Para saber qui√©n es qui√©n, qu√© y qu√© llamar, la forma m√°s segura es elegir un "bokra" espec√≠fico y "golpearlo" ... El programa de "calculadora autom√°tica" seguir√° siendo un "lado". <br><br><h4>  3.1.  Modelo de calculadora activa </h4><br>  En la fig.  1 muestra el modelo original de la clase Calculadora de [1].  En apariencia, parece una m√°quina abstracta cl√°sica sin salida.  La diferencia es que Qt conecta acciones cuando entra y sale de un estado.  En la salida, se activan por la se√±al de salida (), y al ingresar al estado, por la se√±al de entrada ().  Pero, notamos, estas acciones no est√°n representadas en el gr√°fico de ninguna manera. <br><br>  Si comparamos el modelo en la Fig.  1 con un aut√≥mata con un estado abstracto (sus otros nombres son aut√≥mata estructural y l√≥gico), se puede ver f√°cilmente que las acciones a la salida del estado corresponden a las se√±ales del aut√≥mata Mealy, y las acciones a la entrada corresponden a las se√±ales del aut√≥mata Moore. <br>  Observaci√≥n 3. Adem√°s, considerando la implementaci√≥n del software del modelo, no hablaremos de se√±ales, eventos, condiciones, etc., sino de las acciones de los aut√≥matas, suponiendo que a nivel de programa est√©n asociadas con ciertas acciones del programa, que en el caso general representado por funciones de software. <br><br>  El llamado aut√≥mata combinado de Mili-Moore (o un aut√≥mata mixto diferente [12]), equivalente al aut√≥mata de la Fig.  1, se muestra en la Fig. 2, donde las funciones correspondientes a las se√±ales de entrada y salida del aut√≥mata tambi√©n se muestran a la derecha del gr√°fico. <br><br><img src="https://habrastorage.org/webt/dq/ki/ps/dqkipszttmbkgyexe9labqsio9e.jpeg" alt="imagen"><br>  <i>Fig.1.</i>  <i>Diagrama de m√°quina de eventos de calculadora</i> <br><br><img src="https://habrastorage.org/webt/c3/la/ue/c3laueqyd9oiwdf9aiu5gpyi_yk.jpeg" alt="imagen"><br>  <i>Fig.2.</i>  <i>Calculadora de la clase de aut√≥matas del conde Miley-Moore</i> <br><br>  Para un modelo similar a un aut√≥mata en la Fig. 2, por acciones de entrada / salida nos referimos a predicados y acciones que son funciones de programa-m√©todos de clases [aut√≥matas].  Los predicados analizan el estado actual de los elementos de memoria (variables, propiedades de clase) de ninguna manera (¬°esto es importante!) Sin afectarlos, pero dependiendo de su valor, devuelve un valor booleano.  Las acciones de un valor no regresan, sino que cambian los elementos de memoria. <br>  De la fig.  2 se deduce que el modelo de la calculadora, como el "cuadro negro", tiene cuatro canales de entrada y siete canales de salida en t√©rminos del n√∫mero de predicados y acciones.  Es f√°cil ver que, en comparaci√≥n con un aut√≥mata abstracto, que por definici√≥n no tiene m√°s de un canal de entrada y uno de salida, un aut√≥mata estructural que tiene muchos canales es m√°s universal, flexible y conveniente. <br><br>  El modelo de la fig.  2 puede simplificarse "pegando" los estados 1 y 2. Para hacer esto, primero debe convertir el aut√≥mata original en un aut√≥mata Mealy.  Lo obtenemos cargando los arcos que ingresan al estado de las se√±ales con las se√±ales representadas por las se√±ales de los v√©rtices del aut√≥mata Moore.  Despu√©s de esto, la operaci√≥n de pegado se hace evidente.  El resultado de pegar estados al estado 2, que ahora se convierte en inicial, se muestra en la Fig.  3) <br><br><img src="https://habrastorage.org/webt/qa/en/yw/qaenywlioaky3gizvfju27faxmm.jpeg" alt="imagen"><br>  <i>Fig.3.</i>  <i>El resultado de la transformaci√≥n y pegado de los estados del aut√≥mata en la Fig. 2</i> <br><br>  Explique la acci√≥n y1 y la variable nTypeButtons.  En total, implementan un protocolo que simula eventos.  La variable nTypeButtons determina el tipo de s√≠mbolos de entrada del aut√≥mata dividi√©ndolos en s√≠mbolos digitales, s√≠mbolos de operaci√≥n, el s√≠mbolo de "reinicio" y el s√≠mbolo de "igual".  Su valor igual a cero significa la ausencia de caracteres de entrada (no se presiona ninguna de las teclas de la calculadora).  Despu√©s de procesar el s√≠mbolo, esto tambi√©n significa que el s√≠mbolo de entrada se percibe autom√°ticamente.  Esto bloquea la respuesta al car√°cter de entrada. <br><br>  El c√≥digo para la clase de la calculadora creada en el marco del entorno de programaci√≥n autom√°tica de componentes visuales (VKPa) [5] se muestra en los listados 1, 2. <br><br><div class="spoiler">  <b class="spoiler_title">Listado 1. Encabezado de clase FCalculator</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"lfsaappl.h"</span></span></span><span class="hljs-meta"> enum Buttons { digit0 = 0, digit1, digit2, digit3, digit4, digit5, digit6, digit7, digit8, digit9, opPlus, opMinus, opCancel, opEqual, opNone }; class FCalculator : public LFsaAppl { public: void MooreAction(); LFsaAppl* Create(CVarFSA *pCVF) { Q_UNUSED(pCVF)return new FCalculator(pTAppCore, nameFsa, pCVarFsaLibrary); } FCalculator(TAppCore *pInfo, string strNam, CVarFsaLibrary *pCVFL); virtual ~FCalculator(void); public: void digitButtonPressed(int button); void operationButtonPressed(int button); private: void s1Entered(); void s2Entered(); void s3Entered(); void s3Exited(); void s5Entered(); void s5Exited(); private: int Rf, Rb; Buttons transitionButton, Op; int nTypeButtons; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// 0 - none; 1 - digit button; 2 - operation button; void doOp(Buttons op); protected: int x1(); int x2(); int x3(); int x4(); void y1(); void y3(); void y5(); void y6(); void y7(); void y8(); void y9(); void y10(); int nState{2}; };</span></span></span></span></code> </pre> <br><br></div></div><br>  Vamos a explicar  En VKPa, cualquier clase de aut√≥mata hereda las propiedades de la clase de aut√≥mata base LFsaAppl.  El m√©todo Create () crea copias de las clases incluidas en las bibliotecas din√°micas de procesos autom√°ticos.  El m√©todo virtual MooreAction () se superpone cuando se selecciona un modelo de aut√≥mata Moore, que define acciones asociadas con los estados del aut√≥mata.  Los m√©todos x [n] e y [n] son ‚Äã‚Äãlos predicados y las acciones asociadas con los canales de entrada / salida del aut√≥mata.  El algoritmo de comportamiento de la clase [aut√≥mata] est√° representado por la tabla de transici√≥n (ver Listado 2), que consiste en una matriz de cadenas de tipo LArc.  El resto del c√≥digo repite el c√≥digo de la clase de origen Calculadora. <br><br><div class="spoiler">  <b class="spoiler_title">Listado 2. Implementaci√≥n de la clase FCalculator</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stdafx.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FCalculator.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"DlgCalculator.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ui_cdlgcalculator.h"</span></span></span><span class="hljs-meta"> static LArc TBL_Calculator[] = { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//* LArc("1", "2","x1", "y1"), // [0-9] LArc("2", "1","x3", "y1"), // [c] LArc("2", "2","x1", "y1"), // [0-9] LArc("2", "3","x2", "y1"), // [+][-] LArc("3", "1","x3", "y3"), // [c] LArc("3", "3","x2", "y3"), // [+][-] LArc("3", "4","x1", "y3"), // [0-9] LArc("3", "5","x4", "y3"), // [=] LArc("4", "1","x3", "y1"), // [c] LArc("4", "3","x2", "y1"), // [+][-] LArc("4", "4","x1", "y1"), // [0-9] LArc("4", "5","x4", "y1"), // [=] LArc("5", "1","x3", "y5"), // [c] LArc("5", "2","x1", "y5"), // [0-9] LArc("5", "3","x2", "y5"), // [+][-] //*/ /* LArc("2", "2","x1", "y1y7"), // [0-9] LArc("2", "2","x3", "y1y6"), // [c] LArc("2", "3","x2", "y1y8"), // [+][-] LArc("3", "2","x3", "y3y6"), // [c] LArc("3", "3","x2", "y3y8"), // [+][-] LArc("3", "4","x1", "y3y7"), // [0-9] LArc("3", "5","x4", "y3y9"), // [=] LArc("4", "2","x3", "y1y6"), // [c] LArc("4", "3","x2", "y1y8"), // [+][-] LArc("4", "4","x1", "y1y7"), // [0-9] LArc("4", "5","x4", "y1y9"), // [=] LArc("5", "2","x3", "y5y6"), // [c] LArc("5", "2","x1", "y5y7"), // [0-9] LArc("5", "3","x2", "y5y8"), // [+][-] */ // LArc("1", "1","--", "y10"), // SWITCH LArc() }; FCalculator::FCalculator(TAppCore *pInfo, string strNam, CVarFsaLibrary *pCVFL): LFsaAppl(TBL_Calculator, strNam, nullptr, pCVFL) { pTAppCore = pInfo; Rf= 0; Rb = 0; Op = opNone; } FCalculator::~FCalculator(void) { } //   int FCalculator::x1() { if (nTypeButtons != 1) return false; else return true; } //   +, - int FCalculator::x2() { if (nTypeButtons == 0 || nTypeButtons != 2) return false; if (transitionButton != opCancel &amp;&amp; transitionButton != opEqual ) return true; else return false; } //  Cancel int FCalculator::x3() { if (nTypeButtons == 0 || nTypeButtons != 2) return false; if (transitionButton == opCancel) return true; else return false; } //  opEqual int FCalculator::x4() { if (nTypeButtons == 0 || nTypeButtons != 2) return false; if (transitionButton == opEqual) return true; else return false; } void FCalculator::y1() { nTypeButtons = 0; } void FCalculator::y3() { s3Exited(); } void FCalculator::y5() { s5Exited(); } void FCalculator::y6() { s1Entered(); } // 1 void FCalculator::y7() { s2Entered(); } // 2, 4 void FCalculator::y8() { s3Entered(); } // 3 void FCalculator::y9() { s5Entered(); } // 5 void FCalculator::y10() { switch(nState) { case 2: if (x1()) { y1();y7(); } if (x3()) { y1();y6(); } if (x2()) { y1();y8(); nState = 3; } break; case 3: if (x3()) { y3();y6(); nState = 2; } if (x2()) { y3();y8(); } if (x1()) { y3();y7(); nState = 4; } if (x4()) { y3();y9(); nState = 5; } break; case 4: if (x3()) { y1();y6(); nState = 2; } if (x2()) { y1();y8(); nState = 3; } if (x1()) { y1();y7(); } if (x4()) { y1();y9(); nState = 5; } break; case 5: if (x3()) { y5();y6(); nState = 2; } if (x1()) { y5();y7(); nState = 2; } if (x2()) { y5();y8(); nState = 3; } break; } } void FCalculator::MooreAction() { // return; string strState = FGetState(); if (strState=="1") { y6(); } else if (strState=="2") { y7(); } else if (strState=="3") { y8(); } else if (strState=="4") { y7(); } else if (strState=="5") { y9(); } } /////////////////////////////////////////////////////////////////////////// void FCalculator::digitButtonPressed(int button) { transitionButton = static_cast&lt;Buttons&gt;(button); nTypeButtons = 1; } void FCalculator::operationButtonPressed(int button) { transitionButton = static_cast&lt;Buttons&gt;(button); nTypeButtons = 2; } void FCalculator::s1Entered() { Rf = 0; Rb = 0; Op = opNone; static_cast&lt;CDlgCalculator*&gt;(this-&gt;pCVarFSA-&gt;pVFsaDialog)-&gt;ui-&gt;lcdNumber-&gt;display(Rf); } void FCalculator::s2Entered() { if (Rf &lt; 9999999) { Rf = Rf*10 + transitionButton; static_cast&lt;CDlgCalculator*&gt;(this-&gt;pCVarFSA-&gt;pVFsaDialog)-&gt;ui-&gt;lcdNumber-&gt;display(Rf); } } void FCalculator::s3Entered() { if (Rb != 0) { doOp(Op); static_cast&lt;CDlgCalculator*&gt;(this-&gt;pCVarFSA-&gt;pVFsaDialog)-&gt;ui-&gt;lcdNumber-&gt;display(Rf); } Rb = Rf; Op = transitionButton; } void FCalculator::s3Exited() { nTypeButtons = 0; if (transitionButton &gt; digit9 &amp;&amp; transitionButton &lt; opCancel ) { doOp(transitionButton); Rb = 0; Op = transitionButton; static_cast&lt;CDlgCalculator*&gt;(this-&gt;pCVarFSA-&gt;pVFsaDialog)-&gt;ui-&gt;lcdNumber-&gt;display(Rf); } else { Rf = 0; } } void FCalculator::s5Entered() { doOp(Op); Op = opNone; Rb = Rf; // added by me static_cast&lt;CDlgCalculator*&gt;(this-&gt;pCVarFSA-&gt;pVFsaDialog)-&gt;ui-&gt;lcdNumber-&gt;display(Rf); } void FCalculator::s5Exited() { nTypeButtons = 0; if (transitionButton &lt;= 9) { Rb = 0; Rf = 0; } } void FCalculator::doOp(Buttons op) { switch (op) { case opPlus: Rf = Rf + Rb; break; case opMinus: Rf = Rb - Rf; break; default: break; } }</span></span></span></span></code> </pre><br><br></div></div><br>  El Listado de avisos 2 contiene tres tablas de salto (dos est√°n comentadas).  As√≠ es como se realizan las capacidades de control dedicado cuando, despu√©s de eliminar el comentario, el comportamiento de la clase se puede cambiar "por clic" sin afectar sus m√©todos y propiedades.  El m√©todo y10 y la l√≠nea correspondiente en la tabla de transici√≥n (vea la l√≠nea marcada con el comentario SWICH) se introdujeron para simular la tecnolog√≠a SWITCH (para m√°s detalles ver [9]) dentro del marco de la tecnolog√≠a VKPA.  En este caso, el comportamiento de cualquier aut√≥mata se modela mediante una llamada c√≠clica al operador SWITCH, que imita el comportamiento del aut√≥mata (aqu√≠ el aut√≥mata VKPa act√∫a como un entorno externo). <br><br><h4>  3.2.  Modelo de calculadora pasiva </h4><br>  El modelo de calculadora activa escanea constantemente los canales de entrada.  Tan pronto como el valor de la variable nTypeButtons se vuelve distinto de cero, esto sirve como un signo de la llegada del siguiente s√≠mbolo a la entrada del aut√≥mata.  Como resultado, la transici√≥n y la acci√≥n y1 se activan, restableciendo la variable nTypeButtons, bloqueando la reactivaci√≥n autom√°tica de la m√°quina por el mismo car√°cter. <br>  A diferencia del modelo de "calculadora activa", un aut√≥mata de eventos no puede, por definici√≥n, reprocesar un s√≠mbolo de entrada.  Ahora est√° claro que "las mayores dificultades en el uso del enfoque de aut√≥matas ... en sistemas de eventos" parecen reducirse a suprimir la actividad de un aut√≥mata activo y vincular su funcionamiento a eventos.  Mostramos el procedimiento para cambiar a un aut√≥mata pasivo utilizando el ejemplo de la "calculadora activa" reci√©n creada. <br>  El entorno VKPa contiene un modo de operaci√≥n paso a paso introducido para depurar procesos autom√°ticos.  Pero se puede usar para simular m√°quinas de eventos.  Para hacer esto, 1) configure el espacio del aut√≥mata en el que se coloca el aut√≥mata un modo de operaci√≥n paso a paso (tenga en cuenta, no un aut√≥mata separado, sino todo el espacio del aut√≥mata que contiene aut√≥matas), y 2) relacione los momentos de ocurrencia de eventos con la ejecuci√≥n de un paso discreto de la operaci√≥n del espacio.  El Listado 3 muestra c√≥mo hacer esto, reflejando solo los cambios realizados en el modelo (el encabezado de clase permanece sin cambios). <br><br><div class="spoiler">  <b class="spoiler_title">Listado 3. Una variante eventual de la clase FCalculator</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> LArc TBL_Calculator[] = { LArc(<span class="hljs-string"><span class="hljs-string">"st"</span></span>, <span class="hljs-string"><span class="hljs-string">"st"</span></span>,<span class="hljs-string"><span class="hljs-string">"^x12"</span></span>, <span class="hljs-string"><span class="hljs-string">"y12"</span></span>), <span class="hljs-comment"><span class="hljs-comment">// LArc("st", "1","x12", "y11"), // // ... }; ... //   bool FCalculator::FCreationOfLinksForVariables() { pNet = GetPointerToNet(); //    if (pNet) { string str = pNet-&gt;strName; //    //  -  pSV = this-&gt;pTAppCore-&gt;pSetVarSetting-&gt;GetAddressVar(const_cast&lt;char*&gt;(str.c_str())); } return true; } ... // int FCalculator::x12() { if (!pNet) return false; if (!pSV) return false; return true; } ... //    step-by-step void FCalculator::y11() { pSV-&gt;bIfStepByStep = true; } //   void FCalculator::y12() { FCreationOfLinksForVariables(); } // ... ///////////////////////////////////////////////////////////////////////////////////////////////////////////////// void FCalculator::digitButtonPressed(int button) { ... pSV-&gt;bIfStopAllTasks = false; //     } void FCalculator::operationButtonPressed(int button) { ... pSV-&gt;bIfStopAllTasks = false; //     } ...</span></span></code> </pre><br><br></div></div><br>  Aqu√≠, en primer lugar, se introduce un estado [inicial] adicional, en el que se verifica la referencia al espacio donde se encuentra la m√°quina y el enlace al objeto que determina las propiedades del espacio (incluido su modo de operaci√≥n).  Eh forma la acci√≥n de y12.  Cuando se establecen los enlaces, hay una transici√≥n al estado inicial [anterior] del modelo de calculadora con la instalaci√≥n de un modo de operaci√≥n paso a paso del espacio del aut√≥mata. <br><br>  Adem√°s, el modelo opera en un modo paso a paso de operaci√≥n espacial.  El lanzamiento de un paso implementa el c√≥digo insertado en los controladores de eventos asociados con la entrada del siguiente car√°cter (consulte el Listado 3 para ver los cambios realizados en los m√©todos digitButtonPressed y operationButtonPressed). <br><br><h3>  4. ¬øPor qu√©? </h3><br>  ¬øPor qu√© inventar algo si hay, como se puede suponer, un modelo de evento m√°s avanzado de D. Harel?  Y c√≥mo pensar de manera diferente si se ejecut√≥ en UML, Stateflow, en la biblioteca Qt, etc.  etc.  y no hay mucho p√°nico por sus defectos.  Bueno, llamaron a las se√±ales eventos y convirtieron la m√°quina activa en una pasiva ... Y si el modelo, como dicen, tambi√©n es formalmente equivalente a las m√°quinas cl√°sicas de Mili / Moore, ¬øc√≥mo no creer en √©l?  Y as√≠ es, si todas estas declaraciones se toman solo por fe ... <br><br>  Tome el comienzo del evento (esto es exactamente lo que hicimos anteriormente).  Un aut√≥mata estructural cl√°sico tiene, por ejemplo, muchos canales de entrada, cada uno de los cuales est√° asociado con una se√±al, y pueden procesarse simult√°neamente / en paralelo.  Pero UML dice que "cada objeto puede procesar solo un evento a la vez" e incluso "si ocurren dos eventos simult√°neamente, el objeto a√∫n los procesar√° uno a la vez" [10].  Por lo tanto, en el nivel de definici√≥n, las se√±ales y los eventos son equivalentes, pero el idilio colapsa en el proceso de implementaci√≥n de las transiciones del modelo. <br><br>  Considere el ejemplo con el que comienzo a probar / aprender cualquier idioma o tecnolog√≠a.  Se trata de la implementaci√≥n de software del modelo de elemento AND-NOT.  A nivel estructural, corresponde a la "caja negra", que tiene dos canales de entrada y una salida, y en el algoritmo, el aut√≥mata que se muestra en la Fig.  4) <br><br><img src="https://habrastorage.org/webt/6q/7d/ve/6q7dve1toup6onrda9kkjsqzg2u.jpeg" alt="imagen"><br>  <i>Fig.</i>  <i>4. El modelo de aut√≥mata del elemento Y NO</i> <br><br>  Es comprensible c√≥mo crear un modelo de procedimiento normal (ver el Listado 4) o c√≥mo implementar un aut√≥mata en el CPSU (ver el Listado 5), pero no es muy claro c√≥mo repetir esto sobre la base del aut√≥mata de eventos de la biblioteca Qt debido al problema de implementar la transici√≥n desde el estado "1" para indicar "0", que requiere el an√°lisis simult√°neo de varios eventos. <br><br>  Listado 4. Implementaci√≥n de objetos del modelo de procedimiento AND-NOT <br><br><div class="spoiler">  <b class="spoiler_title">Listado 4. Implementaci√≥n de objetos del modelo de procedimiento AND-NOT</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">INE</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: INE() {} ~INE(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> bX1, bX2, bY; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bY = !(bX1&amp;&amp;bX2); } };</code> </pre><br><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Listado 5. Implementaci√≥n de objetos del modelo de aut√≥mata AND-NOT</b> <div class="spoiler_text"><pre> <code class="cpp hljs">LArc T_INE[] = { LArc(<span class="hljs-string"><span class="hljs-string">"s1"</span></span>, <span class="hljs-string"><span class="hljs-string">"s0"</span></span>, <span class="hljs-string"><span class="hljs-string">"x1x2"</span></span>, <span class="hljs-string"><span class="hljs-string">"y1"</span></span>), LArc(<span class="hljs-string"><span class="hljs-string">"s0"</span></span>, <span class="hljs-string"><span class="hljs-string">"s1"</span></span>, <span class="hljs-string"><span class="hljs-string">"^x1"</span></span>, <span class="hljs-string"><span class="hljs-string">"y2"</span></span>), LArc(<span class="hljs-string"><span class="hljs-string">"s0"</span></span>, <span class="hljs-string"><span class="hljs-string">"s1"</span></span>, <span class="hljs-string"><span class="hljs-string">"^x2"</span></span>, <span class="hljs-string"><span class="hljs-string">"y2"</span></span>), }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ine</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> LFsaAppl { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Ine(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> strNam = <span class="hljs-string"><span class="hljs-string">"-"</span></span>): LFsaAppl(T_INE, strNam) {} ~Ine(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> bX1, bX2; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bX1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bX2; } };</code> </pre><br><br></div></div>  Por lo tanto, deje que la implementaci√≥n del modelo de evento del elemento NAND en el marco de las clases de aut√≥matas Qt sea "tarea" para los Habrovans.  Solo puedo citar su decisi√≥n en Stateflow como una "guinda del pastel".  Se muestra en la fig.  5. El alivio de Stateflow se usa aqu√≠, lo que permite no marcar la transici√≥n con un evento: si no se especifica el nombre del evento, entonces la transici√≥n ocurrir√° cuando ocurra cualquier evento (consulte la etiqueta de transici√≥n en [13] para ver un ejemplo). <br><br><img src="https://habrastorage.org/webt/_9/j7/4e/_9j74efmsk0ema7itfdezvpmfca.jpeg" alt="imagen"><br>  <i>Fig.</i>  <i>5. Un modelo de aut√≥mata de un elemento AND-NOT en Stateflow</i> <br><br>  Por lo tanto, las m√°quinas de estado son un modelo h√≠brido (activo-pasivo) de una m√°quina.  Es cierto que no est√° claro c√≥mo se comportar√° la m√°quina en ausencia de eventos.  Se puede suponer que se "congelar√°" en anticipaci√≥n de los eventos.  ¬øY si no lo ser√°n?  Es decir  Al final, es m√°s probable que sea un modelo de m√°quina pasiva que activa.  Aunque solo en apariencia es dif√≠cil distinguirlo de este √∫ltimo. <br><br><h3>  5. Conclusi√≥n </h3><br>  En relaci√≥n con los eventos, podemos decir que, debido a la actividad, la implementaci√≥n del modelo cl√°sico de aut√≥matas parece preferible al modelo de aut√≥matas s√≠ncronos.  Si hablamos de programaci√≥n autom√°tica en general, el paquete de extensi√≥n Stateflow demuestra lo que puede ser un tipo de programaci√≥n completamente diferente.  Pero, desafortunadamente, hasta ahora solo en perspectiva, porque  Los problemas persisten debido al modelo computacional Stateflow, que esencialmente sigue siendo un diagrama de bloques.  Parece que precisamente por estas razones, junto con los aut√≥matas, la programaci√≥n visual en Statefow est√° representada por la notaci√≥n de diagramas de flujo. <br><br>  Descubrir d√≥nde est√° la programaci√≥n autom√°tica real y d√≥nde est√° su imitaci√≥n es uno de nuestros principales objetivos.  En el art√≠culo anterior [5], resolvimos una de las tareas b√°sicas planteadas: formulamos el concepto de programas de aut√≥matas.  A continuaci√≥n, debe lidiar con la definici√≥n de un modelo de gesti√≥n de programas que debe ser aut√≥mata finito y efectivo y conveniente para los programadores. <br><br>  Habiendo lidiado con los eventos, sentamos las bases para tal trabajo.  En otros art√≠culos, ya entenderemos los detalles del modelo propuesto por D. Harel.  Corriendo un poco m√°s adelante, decimos que, para decirlo sin rodeos, distorsion√≥ la comprensi√≥n de los aut√≥matas.  Pero, por otro lado, aqu√≠ debemos darle la raz√≥n, ella revel√≥ problemas que no permitir√≠an, sin ella, formar una programaci√≥n autom√°tica efectiva dentro del marco del modelo cl√°sico que atraer√≠a a los programadores. <br><br>  Descubrimos anteriormente que, al menos, a nivel de evento, los aut√≥matas cl√°sicos no tienen problemas.  Lo entenderemos m√°s ... Mientras tanto, esto es solo el comienzo.  Estamos esperando muchas cosas interesantes y, tenga en cuenta, no ir m√°s all√° de la teor√≠a cl√°sica de los aut√≥matas.  Esto es crucial si queremos una programaci√≥n verdaderamente automatizada.  ¬°Te deseamos √©xito!  :) <br><br><h3>  Referencias </h3><br>  1. Borovsky A.N.  Qt4.7.  Programaci√≥n pr√°ctica en C ++.  - SPb.: BHV-Petersburgo, 2012 .-- 496 p. <br>  2. BUCH G., RAMBO J., JACOBSON I. UML.  Manual de usuario.  Segunda edicion.  Akademiya IT: Mosc√∫, 2007 .-- 493 p. <br>  3. Shalyto A. A. Una nueva conferencia sobre programaci√≥n autom√°tica.  2019, [Recurso electr√≥nico], <a href="https://www.youtube.com/watch%3Fv%3DPPWTxceMutk%26feature%3Dyoutu.be" rel="nofollow">Modo de</a> acceso: <a href="https://www.youtube.com/watch%3Fv%3DPPWTxceMutk%26feature%3Dyoutu.be" rel="nofollow">www.youtube.com/watch?v=PPWTxceMutk&amp;feature=youtu.be</a> , gratis.  Yaz  Ruso  (fecha de tratamiento 5 de diciembre de 2019). <br>  4. Flujo de estado.  <a href="https://www.mathworks.com/products/stateflow.html" rel="nofollow">www.mathworks.com/products/stateflow.html</a> , gratis.  Yaz  Ingles  (fecha de circulaci√≥n 7.01.2020). <br>  5. M√°quina de Turing, como modelo de programas de aut√≥matas.  <a href="https://habr.com/ru/post/481998/">habr.com/en/post/481998</a> , gratis.  Yaz  Ruso  (fecha de circulaci√≥n 7.01.2020). <br>  6. Melikhov A.N.  Gr√°ficos orientados y m√°quinas de estados finitos.  - M .: Nauka, 1971. - 416 p. <br>  7. KUDRYAVTSEV VB, Aleshin S.V., PODKOLZIN A.S.  Introducci√≥n a la teor√≠a de aut√≥matas - M.: Ciencia.  Ch.  ed.  Phys.-Math.  lit., 1985 .-- 320 p. <br>  8. Tukkel N.I., Shalyto A.A.  Implementaci√≥n de aut√≥matas al programar sistemas de eventos.  "Programador", 2002. No. 4.  C.74-80. <br>  9. Polikarpova N., A. Shalyto A. Programaci√≥n de aut√≥matas.  2¬™ ed., San Petersburgo.: Peter, 2011 .-- 176 p. <br>  10. Rambo J., Jacobson A., Butch G. UML: referencia especial.  - San Petersburgo: Peter, 2002 .-- 656 p. <br>  11. Goma H. ‚Äã‚ÄãUML.  Dise√±o de sistemas en tiempo real, aplicaciones paralelas y distribuidas: Per.  del ingles  - M .: DMK Press, 2002. - 2002. - 704 p. <br>  12. SHALYTO A.A.  Tecnolog√≠a SWITCH.  Algoritmizaci√≥n y programaci√≥n de tareas de control l√≥gico.  San Petersburgo: Nauka, 1998.628 s. <br>  13. Rogachev G.N.  Anotaciones de flujo de estado.  <a href="http://bourabai.kz/cm/stateflow13.htm" rel="nofollow">bourabai.kz/cm/stateflow13.htm</a> , gratis.  Yaz  Ruso  (fecha de apelaci√≥n 01.10.2020). </div></div><p>Source: <a href="https://habr.com/ru/post/483610/">https://habr.com/ru/post/483610/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../479474/index.html">Why is self-organization of teams so important in Scrum and why there cannot be managers in it</a></li>
<li><a href="../483600/index.html">Libera tu Android</a></li>
<li><a href="../483602/index.html">Conferencia DefCon 27: Detr√°s de escena de la creaci√≥n de insignias electr√≥nicas Parte 2</a></li>
<li><a href="../483604/index.html">Iridium: recibe y decodifica se√±ales de constelaci√≥n satelital en casa</a></li>
<li><a href="../483608/index.html">Visualizaci√≥n de los l√≠mites de una soluci√≥n clasificadora basada en im√°genes.</a></li>
<li><a href="../483612/index.html">Conductor de Tesla multado por cepillarse los dientes mientras conduc√≠a en piloto autom√°tico</a></li>
<li><a href="../483614/index.html">M√©todos para combatir el robo en un club de rob√≥tica.</a></li>
<li><a href="../483616/index.html">Proyecto Lacmus: c√≥mo la visi√≥n por computadora ayuda a salvar a las personas perdidas</a></li>
<li><a href="../483624/index.html">Competencia de Yandex.Taxi: an√°lisis de la pista de back-end del campeonato de programaci√≥n</a></li>
<li><a href="../483626/index.html">C√≥mo describir un trabajo de 100 gitlab en 100 l√≠neas en Jsonnet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>