<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçüî¨ üêÅ üò∞ Demostraci√≥n de AresDB: herramienta de an√°lisis en tiempo real de c√≥digo abierto basada en GPU de Uber ‚úäüèº üÜô üßëüèª‚Äçü§ù‚Äçüßëüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gracias al an√°lisis en tiempo real, nosotros, los empleados de Uber, tenemos una idea del estado de las cosas y la eficiencia del trabajo, y en base a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Demostraci√≥n de AresDB: herramienta de an√°lisis en tiempo real de c√≥digo abierto basada en GPU de Uber</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/440072/"><p>  Gracias al an√°lisis en tiempo real, nosotros, los empleados de Uber, tenemos una idea del estado de las cosas y la eficiencia del trabajo, y en base a los datos, decidimos c√≥mo mejorar la calidad del trabajo en la plataforma de Uber.  Por ejemplo, el equipo del proyecto monitorea el estado del mercado e identifica posibles problemas en nuestra plataforma;  el software basado en modelos de aprendizaje autom√°tico predice las ofertas de pasajeros y la demanda de conductores;  Los especialistas en procesamiento de datos est√°n mejorando los modelos de aprendizaje autom√°tico, a su vez, para mejorar la calidad de los pron√≥sticos. </p><br><p><img src="https://habrastorage.org/webt/ii/ml/9e/iiml9el5ttzjjxvz6jrx1ff_zng.png"></p><br><p>  En el pasado, para el an√°lisis en tiempo real, utilizamos soluciones de bases de datos de otras compa√±√≠as, pero ninguna cumpl√≠a con todos nuestros criterios de funcionalidad, escalabilidad, eficiencia, costo y requisitos operativos. </p><br><p>  Lanzado en noviembre de 2018, AresDB es una herramienta de an√°lisis en tiempo real de c√≥digo abierto.  Utiliza una fuente de alimentaci√≥n no convencional, procesadores gr√°ficos (GPU), que le permite aumentar la escala del an√°lisis.  La tecnolog√≠a GPU, una prometedora herramienta de an√°lisis en tiempo real, ha avanzado significativamente en los √∫ltimos a√±os, por lo que es ideal para la computaci√≥n paralela en tiempo real y el procesamiento de datos. </p><br><p>  En las siguientes secciones, describimos la estructura de AresDB y c√≥mo esta soluci√≥n interesante para el an√°lisis en tiempo real nos permiti√≥ unificar, simplificar y mejorar de manera m√°s racional y m√°s racional las soluciones de bases de datos de Uber para el an√°lisis en tiempo real.  ¬°Esperamos que despu√©s de leer este art√≠culo intente AresDB como parte de sus propios proyectos y tambi√©n se asegure de su utilidad! </p><a name="habracut"></a><br><h3 id="prilozheniya-uber-dlya-analiza-v-realnom-vremeni">  Aplicaciones de an√°lisis en tiempo real de Uber </h3><br><p>  El an√°lisis de datos es cr√≠tico para el √©xito de Uber.  Entre otras funciones, se utilizan herramientas anal√≠ticas para resolver las siguientes tareas: </p><br><ul><li>  Creaci√≥n de <strong>paneles</strong> de control para monitorear m√©tricas de negocios. </li><li>  Tomar <strong>decisiones autom√°ticas</strong> (por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">determinar el costo de un viaje</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">identificar casos de fraude</a> ) en funci√≥n de las m√©tricas resumidas recopiladas. </li><li>  Cree <strong>consultas aleatorias</strong> para diagnosticar, solucionar problemas y resolver problemas de operaciones comerciales. </li></ul><br><p>  Clasificamos estas funciones con diferentes requisitos de la siguiente manera: </p><br><p><img src="https://habrastorage.org/webt/oa/sp/lm/oasplm7jy6mqhkoevqutusej-sa.png"></p><br><p>  Los paneles de control y los sistemas de toma de decisiones utilizan sistemas de an√°lisis en tiempo real para crear consultas similares en subconjuntos de datos relativamente peque√±os pero muy importantes (con el nivel m√°s alto de relevancia de datos) con QPS alto y baja latencia. </p><br><h3 id="potrebnost-v-drugom-analiticheskom-module">  Necesidad de otro m√≥dulo anal√≠tico. </h3><br><p>  El problema m√°s com√∫n que Uber utiliza herramientas de an√°lisis en tiempo real para resolver es calcular las poblaciones de series de tiempo.  Estos c√°lculos dan una idea de las interacciones del usuario para que podamos mejorar la calidad de los servicios en consecuencia.  En base a ellos, solicitamos indicadores para ciertos par√°metros (por ejemplo, d√≠a, hora, identificador de ciudad y estado del viaje) durante un cierto per√≠odo de tiempo para datos filtrados al azar (o a veces combinados).  Con los a√±os, Uber ha implementado varios sistemas dise√±ados para resolver este problema de varias maneras. </p><br><p>  Aqu√≠ hay algunas soluciones de terceros que utilizamos para resolver este tipo de problema: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Apache Pinot</a> , una base de datos anal√≠tica de c√≥digo abierto distribuida escrita en Java, es adecuada para el an√°lisis de datos a gran escala.  Pinot utiliza una arquitectura lambda interna para consultar datos de paquetes y datos en tiempo real en el almacenamiento de columnas, un √≠ndice de bits invertido para el filtrado y un √°rbol de estrellas para almacenar en cach√© los resultados agregados.  Sin embargo, no admite funciones de deduplicaci√≥n, actualizaci√≥n o inserci√≥n, fusi√≥n o consulta avanzada basadas en claves, como el filtrado geoespacial.  Adem√°s, dado que Pinot es una base de datos basada en JVM, las consultas son muy caras en t√©rminos de uso de memoria. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ustic</a> utiliza Elasticsearch para resolver diversas tareas de an√°lisis de transmisi√≥n.  Est√° construido sobre la base de la biblioteca Apache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lucene</a> , que almacena documentos, para la b√∫squeda de palabras clave de texto completo y un √≠ndice invertido.  El sistema est√° extendido y ampliado para admitir datos agregados.  Un √≠ndice invertido proporciona filtrado pero no est√° optimizado para almacenar y filtrar datos basados ‚Äã‚Äãen rangos de tiempo.  Los registros se almacenan en forma de documentos JSON, lo que impone costos adicionales para proporcionar acceso al repositorio y las solicitudes.  Al igual que Pinot, Elasticsearch es una base de datos basada en JVM y, en consecuencia, no es compatible con la funci√≥n de uni√≥n, y la ejecuci√≥n de consultas ocupa una gran cantidad de memoria. </li></ul><br><p>  Aunque estas tecnolog√≠as tienen sus puntos fuertes, carec√≠an de algunas de las caracter√≠sticas necesarias para nuestro caso de uso.  Necesit√°bamos una soluci√≥n unificada, simplificada y optimizada, y en su b√∫squeda trabajamos en una direcci√≥n no est√°ndar (m√°s precisamente, dentro de la GPU). </p><br><h3 id="ispolzovanie-gpu-dlya-analiza-v-realnom-vremeni">  Usando GPU para an√°lisis en tiempo real </h3><br><p>  Para una representaci√≥n realista de im√°genes con una alta velocidad de cuadros, las GPU procesan simult√°neamente una gran cantidad de formas y p√≠xeles a alta velocidad.  Aunque la tendencia a aumentar la frecuencia de reloj de las unidades de procesamiento de datos en los √∫ltimos a√±os ha comenzado a disminuir, la cantidad de transistores en el chip solo ha aumentado de acuerdo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">con la ley de Moore</a> .  Como resultado, la velocidad de c√°lculo de la GPU, medida en gigaflops por segundo (Gflops / s), est√° aumentando r√°pidamente.  La Figura 1 a continuaci√≥n muestra una comparaci√≥n de la tendencia de velocidad te√≥rica (Gflops / s) de la GPU NVIDIA y la CPU Intel a lo largo de los a√±os: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/mq/gh/wg/mqghwgau9j51rlgs_hratcvmw7i.png"></a> </p><br><p>  <em>Figura 1. Comparaci√≥n del rendimiento de CPU y GPU de punto flotante de precisi√≥n simple durante varios a√±os.</em>  <em>Imagen tomada de la Gu√≠a de programaci√≥n CUDA C de Nvidia.</em> </p><br><p>  Al desarrollar el mecanismo de solicitud de an√°lisis en tiempo real, la decisi√≥n de integrar la GPU fue natural.  En Uber, una solicitud t√≠pica de an√°lisis en tiempo real requiere procesar datos en pocos d√≠as con millones o incluso miles de millones de registros, luego filtrarlos y resumirlos en un corto per√≠odo de tiempo.  Esta tarea computacional encaja perfectamente en el modelo de procesamiento paralelo de GPU de prop√≥sito general, porque ellos: </p><br><ul><li>  Procesan datos en paralelo con una velocidad muy alta. </li><li>  Proporcionan una mayor velocidad computacional (Gflops / s), lo que los hace excelentes para realizar tareas computacionales complejas (en bloques de datos) que se pueden paralelizar. </li><li>  Proporcionan un mayor rendimiento (sin demora) en el intercambio de datos entre la unidad de c√≥mputo y el almacenamiento (ALU y GPU de memoria global) en comparaci√≥n con las unidades de procesamiento central (CPU), lo que los hace ideales para procesar tareas de E / S de memoria paralela, que requiere una cantidad significativa de datos. </li></ul><br><p>  Centr√°ndonos en el uso de una base de datos anal√≠tica basada en GPU, nosotros, desde el punto de vista de nuestras necesidades, evaluamos varias soluciones anal√≠ticas existentes que usan GPU: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kinetica</a> , una herramienta anal√≠tica basada en GPU, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sali√≥ al</a> mercado en 2009, inicialmente para su uso en el Ej√©rcito de EE. UU. Y agencias de inteligencia.  Aunque demuestra el alto potencial de la tecnolog√≠a GPU en an√°lisis, descubrimos que para nuestras condiciones de uso, faltan muchas funciones clave, incluido el cambio del esquema, la inserci√≥n o actualizaci√≥n parcial, la compresi√≥n de datos, la configuraci√≥n del disco y la memoria a nivel de columna, y la conexi√≥n por relaciones geoespaciales </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OmniSci</a> , un m√≥dulo de consulta SQL de c√≥digo abierto, parec√≠a una opci√≥n prometedora, pero al evaluar el producto, nos dimos cuenta de que carec√≠a de algunas caracter√≠sticas importantes para su uso en Uber, como la deduplicaci√≥n.  Aunque OminiSci introdujo el c√≥digo fuente abierto de su proyecto en 2017, despu√©s de analizar su soluci√≥n basada en C ++, llegamos a la conclusi√≥n de que ni cambiar ni ramificar su base de c√≥digo es pr√°cticamente factible. </li><li>  Las herramientas de an√°lisis en tiempo real basadas en GPU, incluidas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GPUQP</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CoGaDB</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GPUDB</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ocelot</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OmniDB</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Virginian</a> , a menudo se utilizan en instituciones educativas y de investigaci√≥n.  Sin embargo, dados sus objetivos acad√©micos, estas decisiones se centran en desarrollar algoritmos y probar conceptos, en lugar de resolver problemas del mundo real.  Por esta raz√≥n, no los tomamos en cuenta, en las condiciones de nuestro volumen y escala. </li></ul><br><p>  En general, estos sistemas demuestran la gran ventaja y el potencial de procesar datos utilizando la tecnolog√≠a GPU, y nos inspiraron a crear nuestra propia soluci√≥n de an√°lisis en tiempo real basada en GPU, adaptada a las necesidades de Uber.  En base a estos conceptos, desarrollamos y abrimos el c√≥digo fuente de AresDB. </p><br><h3 id="obzor-arhitektury-aresdb">  Descripci√≥n general de la arquitectura AresDB </h3><br><p>  En un nivel alto, AresDB almacena la mayor√≠a de los datos en la memoria del host (RAM, que est√° conectada a la CPU), usa la CPU para procesar los datos recibidos y los discos para recuperarlos.  Durante el per√≠odo de solicitud, AresDB transfiere datos desde la memoria del host a la memoria de la GPU para el procesamiento paralelo en la GPU.  Como se muestra en la Figura 2 a continuaci√≥n, AresDB incluye almacenamiento de memoria, almacenamiento de metadatos y disco: </p><br><p><img src="https://habrastorage.org/webt/my/o0/1h/myo01hflityxzcgrlcfrecplyxc.png"><br>  <em>Figura 2. La arquitectura √∫nica de AresDB incluye almacenamiento en memoria, disco y almacenamiento de metadatos.</em> </p><br><h3 id="tablicy">  Mesas </h3><br><p>  A diferencia de la mayor√≠a de los sistemas de gesti√≥n de bases de datos relacionales (RDBMS), AresDB no tiene un alcance de base de datos o esquema.  Todas las tablas pertenecen al mismo √°mbito en un cl√∫ster / instancia de AresDB, lo que permite a los usuarios acceder a ellas directamente.  Los usuarios almacenan sus datos en forma de tablas de hechos y tablas de dimensiones. </p><br><p>  <strong>Tabla de hechos</strong> </p><br><p>  La tabla de hechos almacena un flujo interminable de eventos de series de tiempo.  Los usuarios usan una tabla de hechos para almacenar eventos / hechos que ocurren en tiempo real, y cada evento est√° asociado con la hora del evento, y la tabla a menudo se consulta por la hora del evento.  Como un ejemplo del tipo de informaci√≥n que se almacena en la tabla de hechos, podemos nombrar viajes, donde cada viaje es un evento, y la hora de la solicitud de viaje a menudo se conoce como la hora del evento.  Si varias marcas de tiempo est√°n asociadas con un evento, solo una marca de tiempo se indica como la hora del evento y se muestra en la tabla de hechos. </p><br><p>  <strong>Tabla de medidas</strong> </p><br><p>  La tabla de medidas almacena las caracter√≠sticas actuales de las instalaciones (incluidas ciudades, clientes y conductores).  Por ejemplo, los usuarios pueden almacenar informaci√≥n sobre la ciudad, en particular el nombre de la ciudad, la zona horaria y el pa√≠s, en la tabla de medidas.  A diferencia de las tablas de hechos, que est√°n en constante crecimiento, las tablas de dimensiones siempre tienen un tama√±o limitado (por ejemplo, para Uber, la tabla de ciudades est√° limitada por el n√∫mero real de ciudades en el mundo).  Las tablas de medici√≥n no requieren una columna de tiempo especial. </p><br><h3 id="tipy-dannyh">  Tipos de datos </h3><br><p>  La siguiente tabla muestra los tipos de datos actuales admitidos por AresDB: </p><br><p><img src="https://habrastorage.org/webt/zj/vl/9v/zjvl9v3bezbrorzdbv71ricwzoq.png"></p><br><p>  En AresDB, las cadenas se convierten en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enumeraciones</a> autom√°ticamente antes de ingresar a la base de datos para aumentar la comodidad del almacenamiento y la eficiencia de la consulta.  Esto permite verificaciones de igualdad que distinguen entre may√∫sculas y min√∫sculas, pero no admite operaciones avanzadas como concatenaci√≥n, subcadenas, m√°scaras y coincidencia de expresiones regulares.  En el futuro, tenemos la intenci√≥n de agregar la opci√≥n de soporte de l√≠nea completa. </p><br><h3 id="osnovnye-funkcii">  Funciones principales </h3><br><p>  La arquitectura AresDB admite las siguientes caracter√≠sticas: </p><br><ul><li>  <strong>Almacenamiento basado en columnas con compresi√≥n</strong> para aumentar la eficiencia del almacenamiento (menos memoria en bytes para el almacenamiento de datos) y la eficiencia de la consulta (menos intercambio de datos entre la memoria de la CPU y la memoria de la GPU al procesar una solicitud) </li><li>  <strong>Actualizaci√≥n o inserci√≥n en tiempo real con deduplicaci√≥n de clave principal</strong> para mejorar la precisi√≥n de los datos y actualizar los datos en tiempo real en unos segundos </li><li>  <strong>Procesamiento de solicitud de GPU</strong> para <strong>procesamiento</strong> de datos de <strong>GPU</strong> altamente paralelo con baja latencia de solicitud (desde fracciones de segundo a varios segundos) </li></ul><br><h3 id="stolbchatoe-hranilische">  Columna de almacenamiento </h3><br><p>  <strong>Vector</strong> </p><br><p>  AresDB almacena todos los datos en un formato de columna.  Los valores de cada columna se almacenan como un vector de valores de columna.  El marcador de confianza / incertidumbre de los valores en cada columna se almacena en un vector cero separado, mientras que el marcador de confianza de cada valor se presenta como un bit. </p><br><p>  <strong>Almacenamiento activo</strong> </p><br><p>  AresDB almacena datos de columna sin comprimir y sin clasificar (vectores activos) en almacenamiento activo.  Los registros de datos en el almacenamiento activo se dividen en paquetes (activos) de un volumen dado.  Los nuevos paquetes se crean cuando se reciben datos, mientras que los paquetes antiguos se eliminan despu√©s de archivar registros.  El √≠ndice de clave principal se utiliza para localizar deduplicaci√≥n y actualizar registros.  La Figura 3 a continuaci√≥n muestra c√≥mo organizamos los registros activos y utilizamos el valor de la clave principal para determinar su ubicaci√≥n: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/sa/ak/mk/saakmkzjumbdukxzaizxhmjbcik.png"></a> <br>  <em>Figura 3. Usamos el valor de la clave primaria para determinar la ubicaci√≥n del paquete y la posici√≥n de cada registro dentro del paquete.</em> </p><br><p> Los valores de cada columna en el paquete se almacenan como un vector de columna.  El marcador de confiabilidad / incertidumbre de los valores en cada vector de valores se almacena como un vector cero separado, y el marcador de confiabilidad de cada valor se presenta como un bit.  En la Figura 4 a continuaci√≥n, ofrecemos un ejemplo con cinco valores para la columna <code>city_id</code> : </p><br><p> <a href=""><img src="https://habrastorage.org/webt/zp/bs/ld/zpbsldqk0yij-dvewowbgawy8eq.png"></a> <br>  <em>Figura 4. Almacenamos valores (valor real) y vectores cero (marcador de confianza) de columnas sin comprimir en la tabla de datos.</em> </p><br><h3 id="arhivnoe-hranilische">  Almacenamiento de archivos </h3><br><p>  AresDB tambi√©n almacena datos de columna completados, ordenados y comprimidos (vectores de archivo) en el almacenamiento de archivos a trav√©s de tablas de hechos.  Los registros en el almacenamiento de archivos tambi√©n se distribuyen en lotes.  A diferencia de los paquetes activos, el paquete de archivo almacena registros por d√≠a de acuerdo con el Tiempo Universal Coordinado (UTC).  Un paquete de archivo ha estado usando la cantidad de d√≠as como identificador de paquete desde Unix Epoch. </p><br><p>  Los registros se almacenan en forma ordenada de acuerdo con un orden de clasificaci√≥n de columnas definido por el usuario.  Como se muestra en la Figura 5 a continuaci√≥n, clasificamos primero por la columna <code>city_id</code> y luego por la columna de estado: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ah/qm/dm/ahqmdmonjmy4trbjpzf7lqqdm10.png"></a> <br>  <em>Figura 5. Clasificamos todas las filas por city_id, luego por estado y luego comprimimos cada columna por codificaci√≥n de grupo.</em>  <em>Despu√©s de ordenar y comprimir, cada columna recibir√° un vector de contabilidad.</em> </p><br><p>  El objetivo de establecer el orden de clasificaci√≥n del usuario para las columnas es el siguiente: </p><br><ul><li>  Maximizando el efecto de compresi√≥n ordenando columnas con una peque√±a cantidad de elementos en primer lugar.  La compresi√≥n m√°xima mejora la eficiencia del almacenamiento (se requieren menos bytes para almacenar datos) y la eficiencia de la consulta (se transfieren menos bytes entre la memoria de la CPU y la memoria de la GPU). </li><li>  Proporciona un prefiltrado conveniente basado en rango para filtros equivalentes comunes, por ejemplo, city_id = 12.  El prefiltrado minimiza la cantidad de bytes necesarios para transferir datos entre la memoria de la CPU y la memoria de la GPU, lo que maximiza la eficiencia de la consulta. </li></ul><br><p>  Una columna se comprime solo si est√° presente en el orden de clasificaci√≥n especificado por el usuario.  No estamos tratando de comprimir columnas con una gran cantidad de elementos, ya que esto ahorra poca memoria. </p><br><p>  Despu√©s de ordenar, los datos para cada columna calificada se comprimen utilizando una opci√≥n de codificaci√≥n de grupo espec√≠fica.  Adem√°s del vector de valor y el vector cero, introducimos un vector de contabilidad para representar el mismo valor. </p><br><h3 id="priem-dannyh-v-realnom-vremeni-s-podderzhkoy-funkciy-obnovleniya-i-vstavki">  Recepci√≥n de datos en tiempo real con soporte para funciones de actualizaci√≥n e inserci√≥n. </h3><br><p>  Los clientes reciben datos a trav√©s de la API HTTP al publicar un paquete de servicio.  Un paquete de servicio es un formato binario ordenado especial que minimiza el uso del espacio mientras mantiene el acceso aleatorio a los datos. </p><br><p>  Cuando AresDB recibe el paquete de servicio, primero lo escribe en el registro de la operaci√≥n de recuperaci√≥n.  Cuando se agrega un service pack al final del registro de eventos, AresDB identifica y omite las entradas tard√≠as en las tablas de hechos para su uso en el almacenamiento activo.  Un registro se considera "tard√≠o" si la hora del evento es anterior a la hora archivada del evento de desconexi√≥n.  Para los registros que no se consideran "tard√≠os", AresDB usa el √≠ndice de clave principal para ubicar el paquete dentro del almac√©n activo donde desea insertarlos.  Como se muestra en la Figura 6 a continuaci√≥n, los nuevos registros (no encontrados previamente en funci√≥n del valor de la clave primaria) se insertan en un espacio vac√≠o, y los registros existentes se actualizan directamente: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/px/y9/ee/pxy9eenpxhgejwvtih8gg37rppu.png"></a> <br>  <em>Figura 6. Cuando se reciben datos, despu√©s de agregar el paquete de servicio al registro de eventos, las entradas "tard√≠as" se agregan a la cola inversa y otras entradas al almacenamiento activo.</em> </p><br><h3 id="arhivirovanie">  Archivado </h3><br><p>  Cuando se reciben datos, los registros se agregan / actualizan en el almacenamiento activo o se agregan a la cola inversa, esperando su ubicaci√≥n en el almacenamiento de archivos. </p><br><p>  Peri√≥dicamente, iniciamos un proceso programado, denominado archivado, en relaci√≥n con los registros del almacenamiento activo para adjuntar nuevos registros (registros que nunca se han archivado antes) al almacenamiento de archivos.  El proceso de archivo solo procesa registros en el almacenamiento activo con el tiempo de evento en el rango entre el tiempo de apagado anterior (tiempo de apagado del √∫ltimo proceso de archivo) y el nuevo tiempo de apagado (nuevo tiempo de apagado basado en el par√°metro de retraso de archivo en el esquema de la tabla). </p><br><p>  El tiempo de evento de registro se usa para determinar en qu√© registros de paquete de archivo se deben combinar al empacar datos de archivo en paquetes diarios.  El archivado no requiere la deduplicaci√≥n del √≠ndice del valor de la clave primaria durante la fusi√≥n, ya que solo se archivan los registros en el rango entre el tiempo de apagado antiguo y el nuevo. </p><br><p>  La Figura 7 a continuaci√≥n muestra un gr√°fico de acuerdo con el momento del evento de un registro en particular. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/6t/l6/uc/6tl6ucxgbni_inkqwjo8u0pxcrs.png"></a> <br>  <em>Figura 7. Utilizamos el tiempo del evento y el tiempo del viaje para definir los registros como nuevos (activos) y antiguos (el tiempo del evento es anterior al tiempo archivado del evento del viaje).</em> </p><br><p>  En este caso, el intervalo de archivado es el intervalo de tiempo entre los dos procesos de archivado, y el retraso de archivado es el per√≠odo posterior al momento del evento, pero hasta que el evento se archiva.  Ambos par√°metros se definen en la configuraci√≥n del esquema de la tabla AresDB. </p><br><h3 id="obratnoe-zapolnenie">  Relleno </h3><br><p>  Como se muestra en la Figura 7 anterior, los registros antiguos (cuyo tiempo de evento es anterior al tiempo archivado del evento de apagado) para las tablas de hechos se agregan a la cola inversa y finalmente se procesan como parte del proceso de reposici√≥n.  Los desencadenantes de este proceso tambi√©n son el tiempo o el tama√±o de la cola inversa, si alcanza un nivel de umbral.  En comparaci√≥n con el proceso de agregar datos al almacenamiento activo, el relleno es as√≠ncrono y relativamente m√°s costoso en t√©rminos de recursos de CPU y memoria.  El relleno se usa en los siguientes escenarios: </p><br><ul><li>  Procesamiento de datos aleatorios, muy tard√≠os </li><li>  Captura manual de datos hist√≥ricos de un flujo de datos aguas arriba </li><li>  Introducci√≥n de datos hist√≥ricos en columnas agregadas recientemente </li></ul><br><p>  A diferencia del archivo, el proceso de reposici√≥n es idempotente y requiere deduplicaci√≥n basada en el valor de la clave primaria.  Los datos rellenables ser√°n visibles en √∫ltima instancia para las consultas. </p><br><p>  La cola inversa se mantiene en la memoria con un tama√±o predefinido, y con una gran carga de relleno, el proceso se bloquear√° para el cliente hasta que se borre la cola al iniciar el proceso de relleno. </p><br><h3 id="obrabotka-zaprosa">  Procesamiento de solicitudes </h3><br><p>  En la implementaci√≥n actual, el usuario necesita usar el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ares Query Language</a> (AQL) creado por Uber para ejecutar consultas en AresDB.  AQL es un lenguaje efectivo para consultas anal√≠ticas de series de tiempo y no sigue la sintaxis SQL est√°ndar como "SELECCIONAR DONDE GRUPO POR" como otros lenguajes similares a SQL.  En cambio, AQL se usa en campos estructurados y se puede incluir en objetos JSON, YAML y Go.  Por ejemplo, en lugar de la <code>/SELECT (*) /FROM   /GROUP BY city_id, /WHERE  = ¬´¬ª /AND request_at &gt;= 1512000000</code> , la variante AQL equivalente en JSON se escribe de la siguiente manera: </p><br><pre> <code class="plaintext hljs">{ ‚Äútable‚Äù: ‚Äútrips‚Äù, ‚Äúdimensions‚Äù: [ {‚ÄúsqlExpression‚Äù: ‚Äúcity_id‚Äù} ], ‚Äúmeasures‚Äù: [ {‚ÄúsqlExpression‚Äù: ‚Äúcount(*)‚Äù} ], ;‚Äù&gt; ‚ÄúrowFilters‚Äù: [ ‚Äústatus = 'completed'‚Äù ], ‚ÄútimeFilter‚Äù: { ‚Äúcolumn‚Äù: ‚Äúrequest_at‚Äù, ‚Äúfrom‚Äù: ‚Äú2 days ago‚Äù } }</code> </pre> <br><p>  En formato JSON, AQL ofrece a los desarrolladores de un tablero y sistema de toma de decisiones un algoritmo de consulta de programa m√°s conveniente que SQL, permiti√©ndoles componer consultas y manipularlas f√°cilmente usando c√≥digo sin preocuparse por cosas como la inyecci√≥n SQL.  Act√∫a como un formato de consulta universal para arquitecturas t√≠picas de navegadores web, servidores externos e internos hasta la base de datos (AresDB).  Adem√°s, AQL proporciona una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sintaxis</a> conveniente para filtrar por tiempo y por lotes con soporte para su propia zona horaria.  Adem√°s, el lenguaje admite una serie de funciones, como subconsultas impl√≠citas, para evitar errores comunes en las consultas y facilita el proceso de an√°lisis y reescritura de consultas para desarrolladores de la interfaz interna. </p><br><p>  A pesar de los muchos beneficios que ofrece AQL, somos conscientes de que la mayor√≠a de los ingenieros est√°n m√°s familiarizados con SQL.  Proporcionar una interfaz SQL para ejecutar consultas es uno de los pr√≥ximos pasos que consideraremos como parte de nuestros esfuerzos para mejorar la interacci√≥n con los usuarios de AresDB. </p><br><p>  El diagrama de flujo de ejecuci√≥n de consultas AQL se muestra en la Figura 8 a continuaci√≥n: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/c7/bo/qq/c7boqqkfrjkqgn8i2zeb1ji6wje.png"></a> <br>  <em>Figura 8. El diagrama de flujo de consultas de AresDB utiliza nuestro propio lenguaje de consulta AQL para procesar y recuperar datos de manera r√°pida y eficiente.</em> </p><br><h3 id="kompilyaciya-zaprosov">  Compilaci√≥n de consultas </h3><br><p>  Una consulta AQL se compila en el contexto de consulta interna.  Las expresiones en filtros, medidas y par√°metros se analizan en √°rboles de sintaxis abstracta (AST) para su posterior procesamiento a trav√©s de un procesador de gr√°ficos (GPU). </p><br><h3 id="zagruzka-dannyh">  Carga de datos </h3><br><p>  AresDB utiliza prefiltros para filtrar datos de archivos a bajo precio antes de enviarlos a la GPU para su procesamiento en paralelo.  Debido a que los datos archivados se ordenan de acuerdo con el orden de las columnas configuradas, algunos filtros pueden usar este orden de clasificaci√≥n y el m√©todo de b√∫squeda binaria para determinar el rango apropiado de coincidencia.  En particular, los filtros equivalentes para todas las columnas X clasificadas inicialmente y un filtro de rango opcional para columnas clasificadas X + 1 se pueden usar como filtros preliminares, como se muestra en la Figura 9 a continuaci√≥n. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/mq/gj/cw/mqgjcwi-es1twxn2navrzd6bhki.png"></a> <br>  <em>Figura 9. AresDB prefiltra los datos de la columna antes de enviarlos a la GPU para su procesamiento.</em> </p><br><p>  Despu√©s del prefiltrado, solo los valores verdes (que cumplan la condici√≥n del filtro) deben enviarse a la GPU para el procesamiento en paralelo.  Los datos de entrada se cargan en la GPU y se procesan un paquete a la vez.  Esto incluye paquetes activos y paquetes de archivo. </p><br><p>  AresDB utiliza <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">flujos CUDA</a> para canalizaci√≥n y procesamiento de datos.  Para cada solicitud, se aplican dos flujos alternativamente para el procesamiento en dos etapas superpuestas.  En la Figura 10 a continuaci√≥n, ofrecemos un gr√°fico que ilustra este proceso. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/gg/b-/hv/ggb-hvvb1tbno_uq2rbokxu1ehi.png"></a> <br>  <em>Figura 10. En AresDB, dos subprocesos CUDA transmiten y procesan datos alternativamente.</em> </p><br><h3 id="vypolnenie-zaprosa">  Ejecuci√≥n de la consulta </h3><br><p>  Para simplificar, AresDB usa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la biblioteca Thrust</a> para implementar procedimientos de ejecuci√≥n de consultas, que ofrece bloques de un algoritmo paralelo finamente ajustado para una r√°pida implementaci√≥n de consultas en la herramienta actual. </p><br><p>  En Thrust, los datos vectoriales de entrada y salida se eval√∫an utilizando iteradores de acceso aleatorio.  Cada subproceso GPU busca iteradores de entrada en su posici√≥n de trabajo, lee los valores y realiza c√°lculos, y luego escribe el resultado en la posici√≥n correspondiente en el iterador de salida. </p><br><p>  Para evaluar las expresiones AresDB, sigue el modelo de "un operador por n√∫cleo" (OOPK). </p><br><p>  En la Figura 11 a continuaci√≥n, este procedimiento se demuestra utilizando el ejemplo AST generado a partir de la expresi√≥n de dimensi√≥n <code>request_at ‚Äì request_at % 86400</code> en la etapa de compilaci√≥n de la solicitud: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/rq/zd/cq/rqzdcq1dpy3vnwhi8tjqppsxroq.png"></a> <br>  <em>Figura 11. AresDB usa el modelo OOPK para evaluar expresiones.</em> </p><br><p>  En el modelo OOPK, el motor de consulta AresDB omite cada nodo hoja del √°rbol AST y devuelve un iterador para el nodo fuente.  Si el nodo ra√≠z tambi√©n es finito, la acci√≥n ra√≠z se realiza directamente en el iterador de entrada. </p><br><p>  Para cada nodo no final no ra√≠z ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">operaci√≥n de m√≥dulo</a> en este ejemplo), se asigna un vector de espacio de trabajo temporal para almacenar el resultado intermedio obtenido de la expresi√≥n <code>request_at% 86400</code> .  Usando Thrust, se inicia una funci√≥n de kernel para calcular el resultado de esta declaraci√≥n en la GPU.  Los resultados se almacenan en el iterador del espacio de trabajo. </p><br><p>  Para un nodo ra√≠z, la funci√≥n del n√∫cleo se ejecuta de la misma manera que para un nodo no ra√≠z, no finito.  Se realizan varias acciones de salida en funci√≥n del tipo de expresi√≥n, que se describe en detalle a continuaci√≥n: </p><br><ul><li>  Filtrado para reducir la cantidad de elementos vectoriales de entrada </li><li>  Registro de datos de salida de medici√≥n en un vector de medici√≥n para la posterior fusi√≥n de datos </li><li>  Registre la salida de par√°metros en el vector de par√°metros para la posterior fusi√≥n de datos </li></ul><br><p>  Despu√©s de evaluar la expresi√≥n, se realizan la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">clasificaci√≥n</a> y la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">transformaci√≥n</a> para finalmente combinar los datos.  En las operaciones de ordenaci√≥n y transformaci√≥n, utilizamos los valores del vector de dimensi√≥n como valores clave para la ordenaci√≥n y transformaci√≥n, y los valores del vector de par√°metros como valores para combinar datos.  Por lo tanto, las filas con valores de dimensi√≥n similares se agrupan y combinan.  La Figura 12 a continuaci√≥n muestra este proceso de clasificaci√≥n y conversi√≥n. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ki/wn/hg/kiwnhgruuhvlm2wenraxbrwhwwk.png"></a> <br>  <em>Figura 12. Despu√©s de evaluar la expresi√≥n, AresDB clasifica y convierte los datos de acuerdo con los valores clave de los vectores de medici√≥n (valor clave) y los par√°metros (valor).</em> </p><br><p>  AresDB tambi√©n admite las siguientes funciones de consulta avanzadas: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Unir</a> : AresDB actualmente admite una opci√≥n de unir hash entre la tabla de hechos y la tabla de dimensiones </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estimaci√≥n del n√∫mero de elementos de Hyperloglog</a> : AresDB usa el algoritmo Hyperloglog </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Geo Intersect</a> : AresDB actualmente solo admite operaciones interconectadas entre GeoPoint y GeoShape </li></ul><br><h3 id="upravlenie-resursami">  Gesti√≥n de recursos </h3><br><p>  Como una base de datos basada en memoria interna, AresDB debe administrar los siguientes tipos de uso de memoria: </p><br><p><img src="https://habrastorage.org/webt/20/_4/bb/20_4bbooneymuteoxhig9tqcdjk.png"></p><br><p>  Cuando se inicia AresDB, utiliza el presupuesto de memoria compartida configurado.  El presupuesto se divide en los seis tipos de memoria y tambi√©n debe dejar suficiente espacio para el sistema operativo y otros procesos.  Este presupuesto tambi√©n incluye una estimaci√≥n de congesti√≥n configurada est√°ticamente, un almac√©n de datos activo monitoreado por el servidor y datos archivados que el servidor puede decidir descargar y eliminar seg√∫n el presupuesto de memoria restante. <br>  La Figura 13 a continuaci√≥n muestra el modelo de memoria del host AresDB. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/no/dq/2t/nodq2t_tlr0fn-cy6ubrdwpqofi.png"></a> <br>  <em>Figura 13. AresDB administra su propio uso de memoria para que no exceda el presupuesto total del proceso configurado.</em> </p><br><p>  AresDB permite a los usuarios establecer d√≠as de precarga y prioridades a nivel de columna para tablas de hechos y precargar datos archivados solo en d√≠as de precarga.  Los datos que no se han descargado previamente se cargan en la memoria desde el disco a pedido.  Cuando se llena, AresDB tambi√©n elimina los datos archivados de la memoria del host.  Los principios de eliminaci√≥n de AresDB se basan en los siguientes par√°metros: el n√∫mero de d√≠as de precarga, las prioridades de las columnas, el d√≠a de compilaci√≥n del paquete y el tama√±o de la columna. </p><br><p>  AresDB tambi√©n gestiona m√∫ltiples dispositivos GPU y simula recursos del dispositivo como hilos de GPU y memoria del dispositivo, rastreando el uso de la memoria GPU para procesar solicitudes.  AresDB administra los dispositivos GPU a trav√©s de un administrador de dispositivos que modela los recursos del dispositivo GPU en dos dimensiones (subprocesos GPU y memoria del dispositivo) y rastrea el uso de memoria cuando procesa las solicitudes.  Despu√©s de compilar la solicitud, AresDB permite a los usuarios estimar la cantidad de recursos necesarios para completar la solicitud.  Los requisitos de memoria del dispositivo deben cumplirse antes de que se resuelva la solicitud;  Si actualmente no hay suficiente memoria en alg√∫n dispositivo, la solicitud debe esperar.  Actualmente, AresDB puede ejecutar una o m√°s solicitudes en el mismo dispositivo GPU al mismo tiempo si el dispositivo cumple con todos los requisitos de recursos. </p><br><p>  En la implementaci√≥n actual, AresDB no almacena en cach√© la entrada en la memoria del dispositivo para su reutilizaci√≥n en m√∫ltiples solicitudes.  AresDB tiene como objetivo admitir consultas contra conjuntos de datos que se actualizan constantemente en tiempo real y se almacenan en cach√© de forma incorrecta correctamente.  En futuras versiones de AresDB, tenemos la intenci√≥n de implementar funciones para el almacenamiento en cach√© de datos en la memoria de la GPU, lo que ayudar√° a optimizar el rendimiento de las consultas. </p><br><h3 id="primer-ispolzovaniya-obzornaya-informacionnaya-panel-uber">  Ejemplo de uso: panel de informaci√≥n general de Uber </h3><br><p>  En Uber, utilizamos AresDB para crear paneles para obtener informaci√≥n comercial en tiempo real.  AresDB es responsable de almacenar eventos primarios con actualizaciones constantes y calcular m√©tricas cr√≠ticas para ellos en una fracci√≥n de segundo gracias a los recursos de GPU a bajo costo, para que los usuarios puedan usar paneles interactivamente.  Por ejemplo, varios servicios actualizan los datos de viaje an√≥nimos que tienen un per√≠odo de validez largo en el almac√©n de datos, incluidos nuestro sistema de despacho, sistemas de pago y precios.  Para hacer un uso eficiente de los datos de viaje, los usuarios dividen y dividen los datos en diferentes dimensiones para obtener informaci√≥n sobre soluciones en tiempo real. </p><br><p>  Cuando se utiliza AresDB, el panel de Uber es un panel de an√°lisis generalizado que utilizan los equipos dentro de la empresa para producir m√©tricas relevantes y respuestas en tiempo real para mejorar la experiencia del usuario. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/p-/8e/k6/p-8ek6nx3gioyhngzczop7oh1jw.png"></a> <br> <em> 14.       Uber  AresDB           .</em> </p><br><p>     ,  ,    : </p><br><p> <strong> ( )</strong> </p><br><p><img src="https://habrastorage.org/webt/he/7a/q4/he7aq4btwhfbdgmj3qy-npinpyy.png"></p><br><p> <strong> ( )</strong> </p><br><p><img src="https://habrastorage.org/webt/wi/ox/pb/wioxpbxuygxvf3lg3gs0velx-rc.png"></p><br><h3 id="shemy-tablic-v-aresdb">    AresDB </h3><br><p>     ,  ,       AresDB   : </p><br><p><img src="https://habrastorage.org/webt/uz/ur/hq/uzurhq1u-nkwue6eq7zqepbyqiu.jpeg"></p><br><p>    ,       ,    ,    ,        ,       . </p><br><p>       <a href="">  AresDB</a>      ,  Apache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kafka</a> ,       ,  Apache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Flink</a>  Apache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Spark</a> . </p><br><h3 id="primery-zaprosov-dlya-aresdb">    AresDB </h3><br><p>           , ¬´   ¬ª  ¬´ ¬ª.         ,  -.           24         AQL: </p><br><p><img src="https://habrastorage.org/webt/po/1m/1u/po1m1uit03geewuvntsviruc5pw.jpeg"></p><br><p> <strong>   : <br></strong>         ,        ,   . </p><br><p><img src="https://habrastorage.org/webt/63/wr/9h/63wr9hhyak0furssgtfxa_bcj98.png"></p><br><p>      ,    AresDB    ,     ,                 . AresDB       ,       ,          . </p><br><h3 id="sleduyuschie-shagi">   </h3><br><p> AresDB    Uber         ,            .     ,  ,       AresDB    . </p><br><p>         : </p><br><ul><li> <strong> </strong> :         AresDB,  ,     ,        . </li><li> <strong>   </strong> :      AresDB   2018        ,           ,      AresDB    . </li><li> <strong>  </strong> :       ,     ,          ,       . </li><li> <strong>  </strong> :           ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   (LLVM)</a>    GPU. </li></ul><br><p> AresDB  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  </a>   Apache.     AresDB     . </p><br><p> <em>          ,         .</em> </p><br><h3 id="blagodarnosti">  Agradecimientos </h3><br><p> <em>    (Kate Zhang),   (Jennifer Anderson),   (Nikhil Joshi),   (Abhi Khune),   (Shengyue Ji),   (Chinmay Soman),   (Xiang Fu),   (David Chen)    (Li Ning)  ,      !</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/440072/">https://habr.com/ru/post/440072/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../440060/index.html">TensorFlow en Apache Ignite</a></li>
<li><a href="../440062/index.html">Planificaci√≥n con mucho gusto. C√≥mo configuramos procesos sin gerentes</a></li>
<li><a href="../440064/index.html">Centros de datos para elegir: Londres, Mosc√∫, Z√∫rich, San Petersburgo</a></li>
<li><a href="../440066/index.html">Extensiones VSCode para facilitar el desarrollo de JavaScript y Vue</a></li>
<li><a href="../440070/index.html">Julia, pendiente descendente y m√©todo simplex</a></li>
<li><a href="../440074/index.html">Roskomos considera incorrecto comparar los motores Raptor Ilona Mask y RD-180</a></li>
<li><a href="../440076/index.html">Traducci√≥n e interpretaci√≥n de publicidad del ingl√©s al ruso</a></li>
<li><a href="../440078/index.html">Dispositivo compilador r√°pido. Parte 4</a></li>
<li><a href="../440084/index.html">10 mil millones de exportaciones de software son insignificantes</a></li>
<li><a href="../440086/index.html">Mundo de virus MS-DOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>