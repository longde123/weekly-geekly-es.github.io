<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿 🎅🏿 👩🏾‍🔬 Zwei-Phasen-Commit und die Zukunft verteilter Systeme 😤 🍟 ♂️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel simulieren und untersuchen wir ein Zwei-Phasen-Festschreibungsprotokoll mit TLA +. 

 Das Zwei-Phasen-Festschreibungsprotokoll ist p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zwei-Phasen-Commit und die Zukunft verteilter Systeme</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434496/">  In diesem Artikel simulieren und untersuchen wir ein Zwei-Phasen-Festschreibungsprotokoll mit TLA +. <br><br>  Das Zwei-Phasen-Festschreibungsprotokoll ist praktisch und wird heute in vielen verteilten Systemen verwendet.  Trotzdem ist es eher kurz.  Daher können wir es schnell modellieren und viel lernen.  In der Tat werden wir anhand dieses Beispiels veranschaulichen, welches Ergebnis in verteilten Systemen <i>grundsätzlich unmöglich ist</i> . <br><br><h3>  Das Biphase-Commit-Problem </h3><br>  Die Transaktion wird über <b>Ressourcenmanager (RM) geleitet</b> .  Alle RMs müssen vereinbaren, ob die Transaktion <i>abgeschlossen</i> oder <i>abgebrochen wird</i> . <br><br>  Der Transaction Manager (TM) trifft die endgültige Entscheidung: <b>Festschreiben</b> oder <b>Abbrechen</b> .  Voraussetzung für das Commit ist die Bereitschaft, alle RMs zu verpflichten.  Andernfalls sollte die Transaktion abgebrochen werden. <br><a name="habracut"></a><br><h3>  Einige Hinweise zur Modellierung </h3><br>  Der Einfachheit halber führen wir Simulationen in einem Shared-Memory-Modell durch, nicht in einem Messaging-System.  Es bietet auch eine schnelle Modellvalidierung.  Wir werden den Aktionen „Lesen vom benachbarten Knoten und Aktualisieren des Status“ jedoch eine Nichtatomarität hinzufügen, um ein interessantes Verhalten beim Senden von Nachrichten zu erfassen. <br><br>  RM kann nur den TM-Status lesen und seinen eigenen Status lesen / aktualisieren.  Der Status eines anderen Ressourcenmanagers kann nicht gelesen werden.  Ein TM kann den Status aller RM-Knoten lesen und seinen eigenen Status lesen / aktualisieren. <br><br><h3>  Definitionen </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/d93/803/abe/d93803abea49766a0fbd7bb1d168c2c1.png"><br><br>  In den Zeilen 9-10 wird der anfängliche <code>rmState</code> für jeden RM auf " <code>working</code> und TM auf " <code>init</code> . <br><br>  Das <code>canCommit</code> Prädikat ist <code>true</code> wenn alle RMs "vorbereitet" sind (bereit zum Festschreiben).  Wenn RM im <code>canAbort</code> wird das <code>canAbort</code> Prädikat <code>canAbort</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f2a/8a9/11c/f2a8a911c47b672d4f95b1eb59d11e60.png"><br><br>  Das Modellieren von TM ist einfach.  Der Transaktionsmanager prüft die Möglichkeit eines Commits oder einer Stornierung - und aktualisiert <code>tmState</code> . <br><br>  Es besteht die Möglichkeit, dass TM <code>tmState</code> "unzugänglich" machen kann, sondern nur, wenn die <code>TMMAYFAIL</code> Konstante vor der Validierung des Modells auf <code>true</code> ist.  In TLA + bestimmen Markierungen den Atomizitätsgrad, dh die Granularität.  Mit den Bezeichnungen F1 und F2 bezeichnen wir, dass die entsprechenden Operatoren in Bezug auf die vorherigen Operatoren nichtatomisch (nach einer unbestimmten Zeit) ausgeführt werden. <br><br><h3>  RM-Modell </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/425/42e/e7a/42542ee7a105be00451a28460cafc502.png"><br><br>  Das RM-Modell ist auch einfach.  Da die Zustände "Arbeiten" und "Vorbereitet" nicht endgültig sind, wählt RM nicht deterministisch zwischen den Aktionen aus, bis sie den Endzustand erreichen.  Ein "funktionierender" RM kann in einen "unterbrochenen" oder "vorbereiteten" Zustand übergehen.  "Vorbereitet" RM erwartet ein Commit / Cancel von TM - und handelt entsprechend.  Die folgende Abbildung zeigt die möglichen Zustandsübergänge für einen RM.  Beachten Sie jedoch, dass wir mehrere RMs haben, von denen jeder seinen Status in seinem eigenen Tempo durchläuft, ohne den Status der anderen RMs zu kennen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8d9/b25/0bd/8d9b250bd8aeeba4807f08e1d52a2675.png"><br><br><h3>  Zwei-Phasen-Commit-Modell </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/62d/4e6/b1c/62d4e6b1c2046535daddbeeba285c7ac.png"><br><br>  Wir müssen die Konsistenz unseres zweiphasigen Commits überprüfen: damit es keine unterschiedlichen RMs gibt, von denen einer "Commit" und der andere "Abtreibung" sagt. <br><br>  Das Prädikat " <code>Completed</code> überprüft, ob das Protokoll nicht für immer hängt: Am Ende erreicht jeder RM den endgültigen Status " <code>committed</code> oder " <code>aborted</code> . <br><br>  Jetzt können wir das Protokollmodell testen.  Zunächst setzen wir <code>TMMAYFAIL=FALSE, RM=1..3</code> , um das Protokoll mit drei RM und einem TM zu starten, <code>TMMAYFAIL=FALSE, RM=1..3</code> in einer zuverlässigen Konfiguration.  Das Testen des Modells dauert 15 Sekunden und zeigt an, dass keine Fehler vorliegen.  Sowohl <code>Consistency</code> als auch <code>Completed</code> mit jeder möglichen Protokollausführung mit einem Wechsel von RM-Aktionen und TM-Aktionen zufrieden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c25/c9e/ed0/c25c9eed093f51eb577cbbb97a4775b2.png"><br><br>  Setzen <code>TMMAYFAIL=TRUE</code> nun <code>TMMAYFAIL=TRUE</code> und starten Sie die Prüfung neu.  Das Programm führt schnell zu dem gegenteiligen Ergebnis, bei dem RM nicht weiterkommt und auf eine Antwort von einem nicht verfügbaren TM wartet. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/652/e12/7ec/652e127ec391fae452f651c27f2855db.png"><br><br>  Wir sehen, dass bei <code>State=4</code> Übergänge RM2 unterbrochen werden, bei <code>State=7</code> Übergänge RM3 unterbrochen werden, bei <code>State=8</code> geht <code>State=8</code> TM in den Zustand "Auflegen" und fällt auf <code>State=9</code> .  Bei <code>State=10</code> friert <code>State=10</code> System ein, da RM1 für immer in einem vorbereiteten Zustand bleibt und auf eine Entscheidung eines gefallenen TM wartet. <br><br><h3>  BTM-Simulation </h3><br>  Um ein Einfrieren von Transaktionen zu vermeiden, fügen wir ein Backup-TM (BTM) hinzu, das schnell die Kontrolle übernimmt, wenn das Haupt-TM nicht verfügbar ist.  BTM verwendet dieselbe Logik wie TM, um Entscheidungen zu treffen.  Der Einfachheit halber gehen wir davon aus, dass das BTM niemals abstürzt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/43b/96f/842/43b96f8421fe04f10b8adbc573507c36.png"><br><br>  Wenn wir das Modell mit dem hinzugefügten BTM-Prozess testen, erhalten wir eine neue Fehlermeldung. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/369/151/826/369151826a6dbe641acb2ae81340b1ea.png"><br><br>  BTM kann kein Commit akzeptieren, da unsere ursprüngliche Bedingung <code>canCommit</code> besagt, dass alle <code>RMstates</code> Zustände „vorbereitet“ sein müssen, und nicht die Bedingung berücksichtigt, dass einige RMs bereits eine Commit-Entscheidung vom ursprünglichen TM erhalten haben, bevor das TMB die Kontrolle übernimmt.  Es ist notwendig, die Bedingungen von <code>canCommit</code> unter Berücksichtigung einer solchen Situation neu zu schreiben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9ed/4cf/bd5/9ed4cfbd55de80c58a7068b246c2375b.png"><br><br>  Erfolg!  Wenn wir das Modell testen, erreichen wir sowohl Konsistenz als auch Vollständigkeit, da das BTM die Kontrolle übernimmt und die Transaktion abschließt, wenn das TM fällt.  <a href="">Hier ist das 2PCwithBTM-Modell in TLA +</a> (BTM und die zweite Zeile von canCommit sind anfangs nicht kommentiert) und das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">entsprechende PDF</a> . <br><br><h3>  Was ist, wenn RM auch ausfällt? </h3><br>  Wir gingen davon aus, dass RM zuverlässig ist.  Brechen Sie nun diesen Zustand ab und sehen Sie, wie sich das Protokoll verhält, wenn RM ausfällt.  Fügen Sie dem Fehlermodell den Status "unzugänglich" hinzu.  Um das Verhalten zu untersuchen und einen zeitweiligen Verfügbarkeitsverlust zu simulieren, lassen Sie den Notfall-RM wiederherstellen und arbeiten Sie weiter, indem Sie seinen Status aus dem Protokoll lesen.  Hier ist ein weiteres RM-Zustandsübergangsdiagramm mit dem hinzugefügten "unzugänglichen" Zustand und rot markierten Übergängen.  Und unten ist das überarbeitete Modell für RM. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff1/f05/b6c/ff1f05b6cd817bb0d4050de4e30f37b6.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/94d/91f/8da/94d91f8da2aa4674044a71330da06d4e.png"><br><br>  Es ist auch notwendig, <code>canAbort</code> unter Berücksichtigung des Nichtverfügbarkeitszustands zu verfeinern.  TM kann die Entscheidung „auflegen“, wenn sich einer der Dienste in einem unterbrochenen oder unzugänglichen Zustand befindet.  Wenn diese Bedingung weggelassen wird, unterbricht ein gefallener und nicht wiederhergestellter RM den Fortschritt der Transaktion.  Natürlich sollten Sie auch hier den RM berücksichtigen, der die Entscheidung zum Abschluss der Transaktion aus dem Quell-TM gelernt hat. <br><br><h3>  Modellprüfung </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/bf7/973/f0f/bf7973f0fd5815dfec816ff93dc03f3c.png"><br><br>  Wenn wir das Modell testen, gibt es ein Problem der Inkonsistenz!  Wie konnte das passieren?  Wir verfolgen die Spur. <br><br>  Mit <code>State=6</code> alle RMs in einem vorbereiteten Zustand. TM hat eine Entscheidung zum Abschluss der Transaktion getroffen. RM1 hat diese Entscheidung getroffen und auf das RC-Label umgestellt. Dies bedeutet, dass die Bereitschaft besteht, den Status in "abgeschlossen" zu ändern.  (Denken Sie daran, RM1, diese Waffe wird im letzten Akt feuern).  Leider fällt das TM bei <code>State=7</code> und RM2 wird bei <code>State=8</code> nicht mehr verfügbar.  Im neunten Schritt übernimmt das Backup-BTM die Kontrolle und liest den Status der drei RMs als "vorbereitet, unzugänglich, vorbereitet" - und beschließt, die Transaktion im zehnten Schritt abzubrechen.  Erinnerst du dich an RM1?  Er beschließt, die Transaktion abzuschließen, da er eine solche Entscheidung vom ursprünglichen TM erhalten hat, und tritt in Schritt 11 in den <code>committed</code> Zustand ein.  In <code>State=13</code> erfüllt RM3 die Entscheidung, die Transaktion von BTM abzubrechen, und wechselt in den <code>aborted</code> Zustand - und jetzt haben wir die Koordination mit RM1 unterbrochen. <br><br>  In diesem Fall traf das BTM eine Entscheidung, die gegen die <b>Konsistenz</b> verstieß.  Wenn Sie andererseits das BTM warten lassen, bis der RM den unzugänglichen Zustand verlässt, kann es im Falle eines Unfalls am Knoten für immer einfrieren, was die <b>Erfüllungsbedingung</b> (Fortschrittsbedingung) verletzt. <br><br>  <a href="">Eine aktualisierte TLA + -Modelldatei</a> sowie das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">entsprechende PDF finden Sie hier</a> . <br><br><h3>  Unmöglichkeit FLP </h3><br>  Also, was ist passiert?  Wir stießen auf den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Satz von Fisher, Lynch, Paterson (FLP)</a> über die Unmöglichkeit eines Konsenses in einem asynchronen System mit Fehlern. <br><br>  In unserem Beispiel kann BTM nicht richtig entscheiden, ob sich RM2 in einem fehlgeschlagenen Zustand befindet oder nicht - und entscheidet fälschlicherweise, die Transaktion abzubrechen.  Wenn nur das ursprüngliche TM die Entscheidung treffen würde, wäre eine solche Ungenauigkeit beim Erkennen eines Fehlers kein Problem.  RM wird jeder TM-Entscheidung gehorchen, damit Konsistenz und Fortschritt erhalten bleiben. <br><br>  Das Problem ist, dass wir zwei Objekte haben, die Entscheidungen treffen: TM und BTM. Sie betrachten den Zustand von RM zu unterschiedlichen Zeiten und treffen unterschiedliche Entscheidungen.  Eine solche Informationsasymmetrie ist die Wurzel allen Übels in verteilten Systemen. <br><br>  Das Problem verschwindet auch bei der Erweiterung auf ein dreiphasiges Commit nicht.  <a href="">Hier ist ein in TLA + modelliertes dreiphasiges Commit</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PDF-Version</a> ). Im Folgenden finden Sie eine Fehlerverfolgung, die zeigt, dass dieser Zeitverlauf verletzt wurde (auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Wikipedia-Seite zu einem dreiphasigen Commit</a> wird eine Situation beschrieben, in der RM1 nach Erhalt einer Entscheidung vor dem Commit einfriert und RM2 und RM3 festschreiben festschreiben, was die Konsistenz verletzt). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0d3/6d8/06d/0d36d806d38003f3cd995bbefbc0802d.png"><br><br><h3>  Paxos versucht, die Welt zu einem besseren Ort zu machen. </h3><br><img src="https://habrastorage.org/webt/q-/o_/wq/q-o_wq_jdl14y0ulz-nud8k4idw.jpeg"><br><br>  Aber nicht alles ist verloren, die Hoffnung ist nicht gestorben.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wir haben Paxos</a> .  Es wirkt ordentlich im Rahmen des FLP-Theorems.  Die Innovation von Paxos besteht darin, dass es <b>immer sicher ist</b> (auch bei ungenauen Detektoren, asynchroner Ausführung und Fehlern) und <b>die Transaktion schließlich abschließt,</b> wenn ein Konsens möglich wird. <br><br>  Sie können TM in einem Cluster mit drei Paxos-Knoten emulieren. Dadurch wird das TM / BTM-Inkonsistenzproblem gelöst.  Oder, wie Gray und Lampport in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wissenschaftlichen Artikel über den Konsens beim Transaktions-Commit gezeigt haben</a> , wenn RM den Paxos-Container verwendet, um ihre Entscheidungen gleichzeitig mit der TM-Antwort zu speichern, entfällt ein zusätzlicher Schritt im Standardprotokollalgorithmus. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de434496/">https://habr.com/ru/post/de434496/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de434480/index.html">Neues Jahr, Geräte, Feuer</a></li>
<li><a href="../de434482/index.html">Ein weiteres Jahr unseres Blogs: Ergebnisse von 2018</a></li>
<li><a href="../de434486/index.html">Kundenkarten. Google Pay API für Pässe in ASP.NET</a></li>
<li><a href="../de434490/index.html">Wie wir die Freisprecheinrichtung durch Wasserstrahlschneiden gesehen haben</a></li>
<li><a href="../de434494/index.html">Was zu lesen. Liste der russischsprachigen Belletristik für 2017 und 2018</a></li>
<li><a href="../de434498/index.html">MVP und Dolch 2 - Android Application Skeleton - Teil 1</a></li>
<li><a href="../de434500/index.html">Betrüger namens Jeanne oder Watch Your Ears</a></li>
<li><a href="../de434502/index.html">Wie "Digitale Archäologen" eine verlorene Version von SimCity für NES entdeckten und wiederherstellten</a></li>
<li><a href="../de434504/index.html">20 Jahre Fast Reports "Das Produkt wurde in einem Atemzug erstellt, nur hoch ..."</a></li>
<li><a href="../de434506/index.html">Erleben Sie die Veröffentlichung einer Videobearbeitungsanwendung im Microsoft Store</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>